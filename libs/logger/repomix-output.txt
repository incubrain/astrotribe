This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-07T15:41:56.315Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
src/
  types/
    nuxt.d.ts
  centralizedLogger.ts
  config.ts
  enums-domains.ts
  environment.d.ts
  environment.ts
  error-interface.ts
  index.d.ts
  index.ts
  logger.ts
  response-handler.ts
eslint.config.js
package.json
project.json
README.md
rollup.config.ts
tsconfig.json

================================================================
Repository Files
================================================================

================
File: src/types/nuxt.d.ts
================
// libs/logger/types/nuxt.d.ts
import type { CentralizedLogger } from '../centralizedLogger'
import type { Service } from '../enums-domains'

declare module '#app' {
  interface NuxtApp {
    $logger: CentralizedLogger<Service>
  }
}

================
File: src/centralizedLogger.ts
================
import type { H3Event } from 'h3'
import { createClient, type SupabaseClient } from '@supabase/supabase-js'
import { getEnvironment } from './environment.js'
import type { ErrorLogEntry } from './error-interface.js'
import type { Service, ServiceToDomain } from './enums-domains.js'
import {
  NodeWinstonTransport,
  BrowserConsoleTransport,
  Level,
  type LogTransport,
} from './logger.js'

// ANSI constants
const ANSI = {
  reset: '\x1b[0m',
  white: '\x1b[37m',
  gray: '\x1b[90m',
  cyan: '\x1b[36m',
  bgRed: '\x1b[41m',
  bgBlack: '\x1b[40m',
  bright: '\x1b[1m',
  dim: '\x1b[2m',
} as const

const error_type = {
  UNKNOWN_ERROR: 'unknown_error',
} as const

// Icons for levels
const levelIcons: Record<string, string> = {
  [Level.Error]: '‚ùó',
  [Level.Warn]: '‚ö†Ô∏è',
  [Level.Info]: '‚ÑπÔ∏è',
  [Level.Debug]: 'üêõ',
  [Level.Verbose]: 'üîç',
  [Level.Silly]: 'ü§™',
}

interface ConsoleData {
  level: string
  message: string
  service: string
  domain?: string
  timestamp?: string
  stack?: string
  method?: string
  path?: string
}

export class CentralizedLogger<S extends Service = Service> {
  private static instance: CentralizedLogger | null = null
  private supabase: SupabaseClient | null = null
  protected env: ReturnType<typeof getEnvironment>
  private currentService?: S

  // Defaults
  private service: string = 'initializing'
  private domain: string = 'none'
  private transport: LogTransport

  private constructor() {
    this.env = getEnvironment()
    this.initSupabase()

    if (this.env.isBrowser || !this.env.isNode) {
      this.transport = new BrowserConsoleTransport()
    } else {
      this.transport = new NodeWinstonTransport(this.env.isDev)
    }
  }

  public static create<S extends Service>(): CentralizedLogger<S> {
    if (!CentralizedLogger.instance) {
      CentralizedLogger.instance = new CentralizedLogger()
    }
    return CentralizedLogger.instance as CentralizedLogger<S>
  }

  // Keep setServiceName and setDomain if needed
  public setServiceName(name: S) {
    this.currentService = name
    this.service = name
  }

  public setDomain(domain: ServiceToDomain[S]) {
    if (!this.currentService) {
      throw new Error('Service must be set before setting domain')
    }
    this.domain = domain
  }

  private initSupabase() {
    if (this.env.supabase?.url && this.env.supabase?.serviceKey) {
      try {
        this.supabase = createClient(this.env.supabase.url, this.env.supabase.serviceKey)
      } catch (err) {
        console.error('Failed to initialize Supabase client:', err)
      }
    }
  }

  private sanitize(data: any) {
    const clean = { ...data }
    delete clean.password
    delete clean.token
    delete clean.secret
    delete clean.authorization
    delete clean.event
    return clean
  }

  private bold(text: string) {
    return `\x1b[1m${text}\x1b[0m`
  }

  private formatStackTrace(stack: string): string {
    return stack
      .split('\n')
      .map((line) => {
        if (line.trim().startsWith('at ')) {
          const [start, location] = line.split('(')
          if (location) {
            return `${ANSI.gray}${start}(${ANSI.cyan}${location.slice(0, -1)}${ANSI.gray})${ANSI.reset}`
          }
          return `${ANSI.gray}${line}${ANSI.reset}`
        }
        return line
      })
      .join('\n')
  }

  private formatLevelBadge(level: string): string {
    const upperLevel = level.toUpperCase()
    if (level === 'error') {
      return `${ANSI.bgRed}${ANSI.white}${ANSI.bright} ${upperLevel} ${ANSI.reset}`
    } else if (level === 'warn') {
      return `${ANSI.bgBlack}${ANSI.white}${ANSI.bright} ${upperLevel} ${ANSI.reset}`
    }
    return upperLevel
  }

  private getSeverity(level: string): 'low' | 'medium' | 'high' | 'critical' {
    switch (level) {
      case 'error':
        return 'critical'
      case 'warn':
        return 'high'
      case 'info':
        return 'medium'
      default:
        return 'low'
    }
  }

  private async extractEventData(event?: H3Event) {
    if (!this.env.isNode || !event) return null

    try {
      const { getRequestURL, getRequestHeaders, getQuery } = await import('h3')
      return {
        url: getRequestURL(event).toString(),
        method: event.method,
        headers: getRequestHeaders(event),
        query: getQuery(event),
        timestamp: new Date().toISOString(),
        path: event.path,
      }
    } catch (error: any) {
      return null
    }
  }

  private async prepareMetadata(
    level: string,
    message: string,
    userMetadata: any = {},
  ): Promise<{ consoleData: ConsoleData; dbMetadata: Omit<ErrorLogEntry, 'id' | 'created_at'> }> {
    const timestamp = new Date().toISOString()
    const eventData = userMetadata?.event ? await this.extractEventData(userMetadata.event) : null

    const stack = userMetadata?.error?.stack

    if (eventData) {
      message = `${eventData.method} ${eventData.path} - ${message}`
    }

    const consoleData: ConsoleData = {
      level,
      message,
      service: this.service,
      domain: this.domain,
      timestamp,
      stack,
      method: eventData?.method,
      path: eventData?.path,
    }

    const dbMetadata = {
      service_name: this.service,
      domain: this.domain,
      error_type: error_type.UNKNOWN_ERROR,
      severity: this.getSeverity(level),
      message,
      stack_trace: stack,
      metadata: this.sanitize({
        timestamp,
        ...userMetadata,
        ...(eventData && { request: eventData }),
      }),
      context: userMetadata?.context || {},
      environment: this.env.isDev ? 'development' : 'production',
      request_id: eventData?.headers?.['x-request-id'] || userMetadata?.requestId || null,
      correlation_id:
        eventData?.headers?.['x-correlation-id'] || userMetadata?.correlationId || null,
    }

    return { consoleData, dbMetadata }
  }

  private formatLog(data: ConsoleData): string {
    const { level, message, service, domain, timestamp, stack } = data
    const icon = levelIcons[level] ?? ''
    const levelBadge = this.formatLevelBadge(level)
    const timestampStr = timestamp ? `${ANSI.gray}[${timestamp}]${ANSI.reset}` : ''

    let finalMessage = message
    if (level === 'error' && stack) {
      finalMessage += '\n' + this.formatStackTrace(stack)
    }

    return `${timestampStr} ${levelBadge} [${service}|${domain}] ${finalMessage}`
  }

  private async logToDatabase(dbMetadata: Omit<ErrorLogEntry, 'id' | 'created_at'>) {
    if (!this.supabase) return
    try {
      const { error: dbError } = await this.supabase.from('error_logs').insert(dbMetadata)
      if (dbError) console.error('Failed to log to database:', dbError)
    } catch (err) {
      console.error('Error logging to database:', err)
    }
  }

  private shouldLogLevel(level: Level): boolean {
    if (this.env.isNode) {
      // Node environment: Winston handles level filtering
      // but we can still manually prevent silly/debug in prod if needed
      if (
        !this.env.isDev &&
        (level === Level.Debug || level === Level.Silly || level === Level.Verbose)
      ) {
        return false
      }
      return true
    } else {
      // Browser: no Winston, just apply dev filters
      if (
        !this.env.isDev &&
        (level === Level.Debug || level === Level.Silly || level === Level.Verbose)
      ) {
        return false
      }
      return true
    }
  }

  private shouldStoreLog(level: Level): boolean {
    return level === Level.Error || level === Level.Warn
  }

  private async log(level: Level, message: string, metadata?: any) {
    try {
      // 1. Validate the level
      if (!Object.values(Level).includes(level)) {
        console.error('Invalid log level provided:', level)
        level = Level.Error // fallback
      }

      // 2. Check if we should skip verbose logs in production, etc.
      if (!this.shouldLogLevel(level)) {
        return
      }

      // 3. Prepare metadata (can throw if data is non-serializable)
      const { consoleData, dbMetadata } = await this.prepareMetadata(level, message, metadata)

      // 4. Format and log to transport
      const finalMessage = this.formatLog(consoleData)

      await (this.transport as NodeWinstonTransport).log(level, finalMessage)

      // 5. If it‚Äôs an error or warning, store to DB
      if (this.shouldStoreLog(level)) {
        void this.logToDatabase(dbMetadata)
      }
    } catch (error: any) {
      // Fallback in case something in prepareMetadata(), formatLog(), or transport fails
      console.error('Logger encountered an internal error while logging:', {
        originalLevel: level,
        originalMessage: message,
        originalMetadata: metadata,
        loggerError: error?.message,
        stack: error?.stack,
      })
    }
  }

  // Public logging methods
  public async error(message: string, metadata?: any) {
    return this.log(Level.Error, message, metadata)
  }

  public async warn(message: string, metadata?: any) {
    return this.log(Level.Warn, message, metadata)
  }

  public async info(message: string, metadata?: any) {
    return this.log(Level.Info, message, metadata)
  }

  public async verbose(message: string, metadata?: any) {
    return this.log(Level.Verbose, message, metadata)
  }

  public async debug(message: string, metadata?: any) {
    return this.log(Level.Debug, message, metadata)
  }

  public async silly(message: string, metadata?: any) {
    return this.log(Level.Silly, message, metadata)
  }
}

// Factory function
export const createCentralizedLogger = <S extends Service>() => CentralizedLogger.create<S>()

================
File: src/config.ts
================
// config.ts
export const SERVICE_NAMES = {
  API_GATEWAY: 'api-gateway',
  AUTH_SERVICE: 'auth',
  USER_SERVICE: 'user-service',
  PAYMENT_SERVICE: 'payment-service',
  CONTENT_SERVICE: 'content-service',
  ADMIN_SERVICE: 'admin-service',
  SEARCH_SERVICE: 'search-service',
  ANALYTICS_SERVICE: 'analytics-service',
  NOTIFICATION_SERVICE: 'notification-service',
} as const

export type ServiceName = (typeof SERVICE_NAMES)[keyof typeof SERVICE_NAMES]

// Validate service name
export function validateServiceName(name: string): ServiceName {
  if (Object.values(SERVICE_NAMES).includes(name as ServiceName)) {
    return name as ServiceName
  }
  throw new Error(
    `Invalid service name: ${name}. Must be one of: ${Object.values(SERVICE_NAMES).join(', ')}`,
  )
}

================
File: src/enums-domains.ts
================
const CORE_DOMAINS = ['api', 'errors', 'metrics', 'analytics'] as const
const AUTH_DOMAINS = ['auth', 'user-management', 'permissions'] as const
const UI_DOMAINS = ['ui', 'components'] as const
const STORAGE_DOMAINS = ['storage', 'upload'] as const
const CONTENT_DOMAINS = ['content', 'blog', 'news', 'feeds'] as const
const SOCIAL_DOMAINS = ['social', 'notifications'] as const
const MONITORING_DOMAINS = ['monitoring', 'error-logs', 'metrics'] as const
const SYSTEM_DOMAINS = ['database', 'redis', 'server-jobs', 'websocket'] as const
const API_DOMAINS = ['monitoring', 'cron', 'agents', 'validation', 'filter', 'logging'] as const
const JOBS_DOMAINS = ['news_links', 'job_events', 'job_versions', 'job_shutdown'] as const
const URLS = ['url_classifier', 'url_spider'] as const
const SCRAPERS = ['scraper', 'crawler', 'spider'] as const

// Admin-specific domains
const ADMIN_SPECIFIC = [
  'business-systems',
  'business-plan',
  'features',
  'tasks',
  'spider',
  'classifier',
  'jobs',
  'users',
  'referrals',
  'billing',
  'growth',
] as const

// Main app specific domains
const APP_SPECIFIC = ['bookmarks', 'search', 'payments'] as const

export enum Service {
  // Main Applications
  ADMIN = 'admin',
  AUTH = 'auth',
  APP = 'app',
  MONITORING = 'monitoring',
  WEBSITE = 'website',
  CMS = 'cms',
  API = 'api',
  JOBS = 'jobs',

  // Extensions
  CHROME_EXTENSION = 'chrome-extension',
}

export const ServiceDomains = {
  'admin': [
    ...CORE_DOMAINS,
    ...AUTH_DOMAINS,
    ...MONITORING_DOMAINS,
    ...SYSTEM_DOMAINS,
    ...STORAGE_DOMAINS,
    ...ADMIN_SPECIFIC,
  ],
  'auth': [...CORE_DOMAINS, ...AUTH_DOMAINS],
  'app': [
    ...CORE_DOMAINS,
    ...AUTH_DOMAINS,
    ...UI_DOMAINS,
    ...STORAGE_DOMAINS,
    ...CONTENT_DOMAINS,
    ...SOCIAL_DOMAINS,
    ...APP_SPECIFIC,
  ],
  'monitoring': [...CORE_DOMAINS, ...MONITORING_DOMAINS, ...SYSTEM_DOMAINS],
  'website': [...CORE_DOMAINS, ...UI_DOMAINS, ...CONTENT_DOMAINS, 'search'],
  'cms': [...CORE_DOMAINS, ...AUTH_DOMAINS, ...STORAGE_DOMAINS, ...CONTENT_DOMAINS],
  'chrome-extension': ['api', 'errors', ...UI_DOMAINS, ...STORAGE_DOMAINS, 'bookmarks'],
  'api': [...CORE_DOMAINS, ...AUTH_DOMAINS, ...STORAGE_DOMAINS, ...CONTENT_DOMAINS, ...API_DOMAINS],
  'jobs': [
    'test',
    'circuit_breaker',
    'api',
    'errors',
    'metrics',
    'analytics',
    'jobs',
    ...JOBS_DOMAINS,
    ...URLS,
    ...SCRAPERS,
  ],
} as const

export type ServiceToDomain = {
  [S in Service]: (typeof ServiceDomains)[S][number]
}

// Type helper to get domains for a service
export type DomainsForService<S extends Service> = ServiceToDomain[S]

================
File: src/environment.d.ts
================
// src/environment.d.ts
declare global {
  interface Window {
    __NUXT__?: {
      config?: {
        SUPABASE_URL?: string
        SUPABASE_KEY?: string
        SUPABASE_SERVICE_KEY?: string
        SERVICE_NAME?: string
        [key: string]: any
      }
    }
  }

  namespace NodeJS {
    interface ProcessEnv {
      NODE_ENV: 'development' | 'production' | 'test'
      NUXT_APP?: string
      __NUXT_PATHS__?: string
      SUPABASE_URL?: string
      SUPABASE_KEY?: string
      SUPABASE_SERVICE_KEY?: string
      SERVICE_NAME?: string
    }
  }
}

export interface Environment {
  isNode: boolean
  isBrowser: boolean
  isDev: boolean
  supabase: {
    url: string | null
    key: string | null
    serviceKey: string | null
  }
  serviceName: string
}

export {}

================
File: src/environment.ts
================
// src/environment.ts
import type { Environment } from './environment.d.js'

export const getEnvironment = (): Environment => {
  // More robust environment detection
  const isNode = typeof process !== 'undefined' && !!process.versions?.node
  const isBrowser = typeof window !== 'undefined'

  // Check for Nuxt environment
  const isNuxt =
    typeof process !== 'undefined' &&
    (process.env.NUXT_APP === 'true' ||
      (process.env.NODE_ENV === 'development' && process.env.__NUXT_PATHS__))

  // When running in Nuxt SSR, we're technically in Node but should treat it differently
  const effectivelyNode = isNode && !isNuxt

  // Get config from various possible sources
  let config: Record<string, any> = {}

  if (isBrowser && window.__NUXT__?.config) {
    // Browser Nuxt context
    config = window.__NUXT__.config
  } else if (isNode) {
    // Node/SSR context
    config = process.env
  }

  return {
    isNode: effectivelyNode,
    isBrowser,
    isDev: process.env.NODE_ENV === 'development',
    supabase: {
      url: config.SUPABASE_URL || null,
      key: config.SUPABASE_KEY || null,
      serviceKey: config.SUPABASE_SERVICE_KEY || null,
    },
    serviceName: config.SERVICE_NAME ?? 'api-gateway',
  }
}

================
File: src/error-interface.ts
================
export interface ErrorMessage {
  userMessage: string // User-friendly error message if needed
  devMessage: string // Make bugfixing easy!
  error: any
}

export interface ErrorServer extends Omit<ErrorMessage, 'error'> {
  featureRelated?: boolean // default false - log to feature-specific log
  response: { data: any; error: any }
}

// Retryable status codes with descriptions
export const retryableStatusCodes: { [key: number]: string } = {
  408: 'Request Timeout - The server timed out waiting for the request.',
  409: 'Conflict - The request could not be completed due to a conflict with the current state of the target resource.',
  425: 'Too Early - The server is unwilling to risk processing a request that might be replayed.',
  500: 'Internal Server Error - The server encountered an unexpected condition that prevented it from fulfilling the request.',
  502: 'Bad Gateway - The server, while acting as a gateway or proxy, received an invalid response from an inbound server.',
  503: 'Service Unavailable - The server is currently unable to handle the request due to temporary overloading or maintenance of the server.',
  504: 'Gateway Timeout - The server, while acting as a gateway or proxy, did not receive a timely response from an upstream server.',
}

export enum ErrorSeverity {
  LOW = 'low',
  MEDIUM = 'medium',
  HIGH = 'high',
  CRITICAL = 'critical',
}

export enum ErrorType {
  UPLOAD_ERROR = 'UPLOAD_ERROR',
  CONNECTION_ERROR = 'CONNECTION_ERROR',
  AUTHENTICATION_ERROR = 'AUTHENTICATION_ERROR',
  UNIQUE_VIOLATION = 'UNIQUE_VIOLATION',
  FOREIGN_KEY_VIOLATION = 'FOREIGN_KEY_VIOLATION',
  NOT_NULL_VIOLATION = 'NOT_NULL_VIOLATION',
  CONSTRAINT_ERROR = 'CONSTRAINT_ERROR',
  UNDEFINED_TABLE = 'UNDEFINED_TABLE',
  UNDEFINED_PARAMETER = 'UNDEFINED_PARAMETER',
  SYNTAX_ERROR = 'SYNTAX_ERROR',
  DUPLICATE_ALIAS = 'DUPLICATE_ALIAS',
  UNDEFINED_COLUMN = 'UNDEFINED_COLUMN',
  DATA_EXCEPTION = 'DATA_EXCEPTION',
  SERIALIZATION_FAILURE = 'SERIALIZATION_FAILURE',
  DEADLOCK_DETECTED = 'DEADLOCK_DETECTED',
  INSUFFICIENT_RESOURCES = 'INSUFFICIENT_RESOURCES',
  RATE_LIMIT_ERROR = 'RATE_LIMIT_ERROR',
  SERVER_ERROR = 'SERVER_ERROR',
  UNKNOWN_ERROR = 'UNKNOWN_ERROR',
  VALIDATION_ERROR = 'VALIDATION_ERROR',
  NOT_FOUND_ERROR = 'NOT_FOUND_ERROR',
  NETWORK_ERROR = 'NETWORK_ERROR',
}

// Types
export interface ErrorDetails {
  type: ErrorType
  message: string
  severity: ErrorSeverity
  stack?: string
  code?: string | number
  context?: string
  pgError?: string
  operation?: string
  originalError?: any
}

export interface ErrorHandlerOptions {
  context?: string
  userMessage?: string
  devMessage?: string
  throwError?: boolean
}

export interface FetchErrorResponse {
  data?: any
  error?: any
}

export function mapErrorSeverity(error: any): ErrorSeverity {
  if (error.status >= 500) return ErrorSeverity.CRITICAL
  if (error.status === 429) return ErrorSeverity.HIGH

  // Connection errors are critical
  if (error.code?.startsWith('08')) return ErrorSeverity.CRITICAL

  // Authentication errors are high severity
  if (error.code?.startsWith('28')) return ErrorSeverity.HIGH

  // Constraint violations are high severity
  if (error.code?.startsWith('23')) return ErrorSeverity.HIGH

  // Query errors are medium severity
  if (error.code?.startsWith('42')) return ErrorSeverity.MEDIUM

  // Data exceptions are medium severity
  if (error.code?.startsWith('22')) return ErrorSeverity.MEDIUM

  // Transaction errors are high severity
  if (error.code === '40001' || error.code === '40P01') return ErrorSeverity.HIGH

  // System errors are critical
  if (error.code?.startsWith('53')) return ErrorSeverity.CRITICAL

  // Default to medium severity for unknown errors
  return ErrorSeverity.MEDIUM
}

export function mapErrorType(error: any): ErrorType {
  // Connection errors
  if (
    error.code === '08000' ||
    error.code === '08003' ||
    error.code === '08006' ||
    error.code === '08001' ||
    error.code === '08004'
  ) {
    return ErrorType.CONNECTION_ERROR
  }

  // Authentication errors
  if (error.code === '28000' || error.code === '28P01') {
    return ErrorType.AUTHENTICATION_ERROR
  }

  // Constraint violations
  if (error.code === '23505') return ErrorType.UNIQUE_VIOLATION
  if (error.code === '23503') return ErrorType.FOREIGN_KEY_VIOLATION
  if (error.code === '23502') return ErrorType.NOT_NULL_VIOLATION
  if (error.code?.startsWith('23') && !['23505', '23503', '23502'].includes(error.code))
    return ErrorType.CONSTRAINT_ERROR

  // Query errors
  if (error.code === '42P01') return ErrorType.UNDEFINED_TABLE
  if (error.code === '42P02') return ErrorType.UNDEFINED_PARAMETER
  if (error.code === '42601') return ErrorType.SYNTAX_ERROR
  if (error.code === '42P07') return ErrorType.DUPLICATE_ALIAS
  if (error.code === '42703') return ErrorType.UNDEFINED_COLUMN

  // Data errors
  if (error.code?.startsWith('22')) return ErrorType.DATA_EXCEPTION

  // Transaction errors
  if (error.code === '40001') return ErrorType.SERIALIZATION_FAILURE
  if (error.code === '40P01') return ErrorType.DEADLOCK_DETECTED

  // System errors
  if (
    error.code === '53000' ||
    error.code === '53100' ||
    error.code === '53200' ||
    error.code === '53300'
  ) {
    return ErrorType.INSUFFICIENT_RESOURCES
  }

  // HTTP-specific errors
  if (error.status === 429) return ErrorType.RATE_LIMIT_ERROR
  if (error.status >= 500) return ErrorType.SERVER_ERROR

  // Catch-all for unspecified errors
  return ErrorType.UNKNOWN_ERROR
}

export interface LogLevels {
  error: 0
  warn: 1
  info: 2
  http: 3
  verbose: 4
  debug: 5
  silly: 6
}

export class AppError extends Error {
  details: ErrorDetails

  constructor(details: ErrorDetails) {
    super(details.message)
    this.details = details
    this.name = 'AppError'
  }
}

export interface Logger {
  error: (message: string, ...args: any[]) => void
  warn: (message: string, ...args: any[]) => void
  info: (message: string, ...args: any[]) => void
  verbose: (message: string, ...args: any[]) => void
  debug: (message: string, ...args: any[]) => void
  silly: (message: string, ...args: any[]) => void
  http: (message: string, ...args: any[]) => void
}

export interface LogMetadata {
  service: string
  environment: string
  timestamp: string
  correlationId?: string
  requestId?: string
  userId?: string
  browser?: string
  os?: string
  ip?: string
  path?: string
  method?: string
  component?: string
  version?: string
  [key: string]: any
}

export interface LogContext {
  action?: string
  component?: string
  version?: string
  [key: string]: any
}

export interface ErrorLogEntry {
  id: string
  service_name: string
  error_type: string
  severity: 'low' | 'medium' | 'high' | 'critical'
  message: string
  stack_trace?: string
  metadata?: Partial<LogMetadata> // Make it optional and partial
  context?: LogContext
  user_id?: string
  request_id?: string
  correlation_id?: string
  environment: string
  created_at: string
}

================
File: src/index.d.ts
================
// First in the types file (index.d.ts)
import type { LogMetadata } from './error-interface.js'
import type { Service, ServiceToDomain } from './enums-domains.js'

export * from './environment'
export * from './error-interface'
export * from './config'
export * from './enums-domains'
export * from './types/nuxt'

// Generic interface for the logger
export class CentralizedLogger<S extends Service = Service> {
  setServiceName(service: S): void
  setDomain(domain: ServiceToDomain[S]): void
  error(message: string, metadata?: any): void
  warn(message: string, metadata?: any): void
  info(message: string, metadata?: any): void
  verbose(message: string, metadata?: any): void
  debug(message: string, metadata?: any): void
  silly(message: string, metadata?: any): void
}

// Updated factory functions with generics
export function createCentralizedLogger<S extends Service>(): CentralizedLogger<S>
export function useLogger<S extends Service>(tag?: string): CentralizedLogger<S>

// Extended metadata type
export interface LoggerMetadata extends LogMetadata {
  timestamp: string
  context?: string
  error?: Error | unknown
  service: Service
  domain?: string
  [key: string]: any
}

// Response handler with service generic
export function handleResponse<T, S extends Service>(
  logger: CentralizedLogger<S>,
  operation: () => Promise<T>,
  context: string,
  options?: {
    successMessage?: string
    errorMessage?: string
  },
): Promise<T>

================
File: src/index.ts
================
export * from './logger.js'
export * from './error-interface.js'
export * from './centralizedLogger.js'
export * from './environment.js'
export * from './config.js'
export * from './response-handler.js'
export * from './enums-domains.js'

================
File: src/logger.ts
================
// Logging levels
export enum Level {
  Error = 'error',
  Warn = 'warn',
  Info = 'info',
  Verbose = 'verbose',
  Debug = 'debug',
  Silly = 'silly',
}

// Transport interface
export interface LogTransport {
  log(level: Level, message: string): void
}

// Browser console transport
export class BrowserConsoleTransport implements LogTransport {
  log(level: Level, message: string) {
    if (level === Level.Error) {
      console.error(message)
    } else if (level === Level.Warn) {
      console.warn(message)
    } else if (level === Level.Info) {
      console.info(message)
    } else {
      console.log(message)
    }
  }
}

// Node Winston transport
export class NodeWinstonTransport implements LogTransport {
  public initialized = false
  private initPromise: Promise<void> | null = null

  private logger: import('winston').Logger | undefined
  private messageQueue: Array<{ level: Level; message: string }> = []

  constructor(private isDev: boolean) {
    this.isDev = isDev
    this.initPromise = this.init()
  }

  async init(): Promise<void> {
    if (this.initialized) return

    try {
      const w = await import('winston')
      const winston = w ?? w

      const format = winston.format.combine(
        winston.format.printf(({ message }) => String(message ?? 'Message undefined')),
      )

      this.logger = winston.createLogger({
        level: this.isDev ? 'silly' : 'info',
        format,
        transports: [new winston.transports.Console()],
      })

      if (!this.isDev) {
        // Add file transports in production
        this.logger.add(
          new winston.transports.File({
            filename: './logs/error.log',
            level: 'error',
            format: winston.format.combine(
              winston.format.timestamp(),
              winston.format.uncolorize(),
              winston.format.json(),
            ),
          }),
        )

        this.logger.add(
          new winston.transports.File({
            filename: './logs/combined.log',
            format: winston.format.combine(
              winston.format.timestamp(),
              winston.format.uncolorize(),
              winston.format.json(),
            ),
          }),
        )
      }

      this.initialized = true

      // Process any queued messages
      while (this.messageQueue.length > 0) {
        const msg = this.messageQueue.shift()
        if (msg) this.logger.log(msg.level, msg.message)
      }
    } catch (error) {
      console.error('Failed to initialize Winston logger:', error)
      // Fall back to console
      this.logger = console as any
      this.initialized = true
    }
  }

  async log(level: Level, message: string) {
    if (this.initPromise) {
      await this.initPromise
    }

    if (!this.initialized || !this.logger) {
      // Queue the message if not initialized
      this.messageQueue.push({ level, message })
      return
    }

    this.logger.log(level, message)
  }
}

================
File: src/response-handler.ts
================
// @ib/logger/src/response-handler.ts
import { createError } from 'h3'
import type { Logger } from './error-interface.js'

export const handleResponse = async <T>(
  logger: Logger,
  operation: () => Promise<T>,
  context: string,
  options: {
    successMessage?: string
    errorMessage?: string
  } = {},
): Promise<T> => {
  try {
    const result = await operation()
    logger.info(options.successMessage || `${context} succeeded`)
    return result
  } catch (error: any) {
    logger.error(options.errorMessage || `${context} failed`, {
      error,
      context,
    })
    throw createError({
      statusCode: error?.statusCode || 500,
      message: options.errorMessage || `${context} failed: ${error.message}`,
    })
  }
}

================
File: eslint.config.js
================
import baseConfig from '../../eslint.config'

export default {
  ...baseConfig,
  rules: {
    ...baseConfig.rules,
    '@typescript-eslint/consistent-type-imports': 'off',
  },
  env: {
    node: true,
    es2022: true,
  },
  settings: {
    'import/resolver': {
      typescript: {
        project: 'libs/logger/tsconfig.json',
      },
      node: {
        extensions: ['.ts', '.js'],
      },
    },
  },
}

================
File: package.json
================
{
  "name": "@ib/logger",
  "version": "0.0.3",
  "private": true,
  "types": "./dist/index.esm.d.ts",
  "main": "./dist/index.cjs.js",
  "module": "./dist/index.esm.js",
  "exports": {
    ".": {
      "import": "./dist/index.esm.js",
      "require": "./dist/index.cjs.js",
      "types": "./dist/index.esm.d.ts"
    }
  },
  "files": [
    "dist"
  ],
  "scripts": {
    "lint": "nx lint @ib/logger",
    "test": "nx test @ib/logger",
    "dev": "nx build @ib/logger --watch",
    "clean": "rm -rf dist",
    "build": "nx build @ib/logger"
  },
  "dependencies": {
    "@supabase/supabase-js": "^2.47.8",
    "winston": "^3.14.2",
    "@nx/rollup": "20.3.0",
    "@types/node": "^22.10.3"
  },
  "devDependencies": {
    "h3": "^1.8.2"
  }
}

================
File: project.json
================
{
  "name": "@ib/logger",
  "$schema": "../node_modules/nx/schemas/project-schema.json",
  "root": "libs/logger",
  "sourceRoot": "libs/logger/src",
  "projectType": "library",
  "tags": [],
  "release": {
    "version": {
      "generatorOptions": {
        "packageRoot": "libs/logger/dist",
        "currentVersionResolver": "git-tag"
      }
    }
  },
  "targets": {
    "build": {
      "executor": "@nx/rollup:rollup",
      "outputs": ["{workspaceRoot}/libs/logger/dist"],
      "options": {
        "main": "libs/logger/src/index.ts",
        "outputPath": "libs/logger/dist",
        "tsConfig": "libs/logger/tsconfig.json",
        "format": ["esm", "cjs"],
        "generateExportsField": true,
        "rollupConfig": "libs/logger/rollup.config.ts"
      }
    }
  }
}

================
File: README.md
================
logger readme...

================
File: rollup.config.ts
================
import type { RollupOptions } from 'rollup'
import { readFile, writeFile } from 'node:fs/promises'
import { join } from 'node:path'

export default async (config: RollupOptions): Promise<RollupOptions> => {
  return {
    ...config,
    plugins: [
      ...(Array.isArray(config.plugins) ? await Promise.resolve(config.plugins) : []),
      {
        name: 'transform-package-json',
        async writeBundle(options) {
          try {
            const outputDir = (options.dir as string) || 'dist'

            const packageJson = JSON.parse(await readFile('libs/logger/package.json', 'utf8'))

            const transformedPackageJson = {
              ...packageJson,
              types: './index.esm.d.ts',
              main: './index.cjs.js',
              module: './index.esm.js',
              exports: {
                '.': {
                  import: './index.esm.js',
                  require: './index.cjs.js',
                  types: './index.esm.d.ts',
                },
              },
            }

            const outputPath = join(outputDir, 'package.json')
            await writeFile(outputPath, JSON.stringify(transformedPackageJson, null, 2))

            console.log('Final package.json written to:', outputPath)
            console.log('Content:', JSON.stringify(transformedPackageJson, null, 2))
          } catch (error) {
            console.error('Failed to process package.json:', error)
            throw error
          }
        },
      },
    ],
  }
}

================
File: tsconfig.json
================
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": {
    "composite": true,
    "declaration": true,
    "module": "ESNext",
    "target": "ES2022",
    "outDir": "./dist",
    "rootDir": "./src",
    "baseUrl": ".",
    "types": ["node"],
    "moduleResolution": "node",
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}
