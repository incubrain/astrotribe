This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-11-14T04:19:06.056Z

# File Summary

## Purpose
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A header with the file path (## File: path/to/file)
  b. The full contents of the file in a code block

## Usage Guidelines
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
- Pay special attention to the Repository Description. These contain important context and guidelines specific to this project.

## Notes
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

- Line numbers have been added to the beginning of each line.

## Additional Info
### User Provided Header
Main Application context including shared libraries and layers

For more information about Repomix, visit: https://github.com/yamadashy/repomix

# Repository Structure
```
apps/
  main-app/
    app/
      router.options.ts
    components/
      bookmark/
        BookmarkCard.vue
        BookmarkFormMove.vue
        BookmarkList.vue
        BookmarkViewFolder.vue
      company/
        CompanyCard.vue
        CompanyCardSkeleton.vue
      content/
        financial-chart.vue
        org-chart.vue
        timeline.vue
      dev/
        ApiDataViewer.vue
        CodePrevies.vue
        ComponentList.vue
        ComponentPlayground.vue
        EventLogger.vue
        Helpers.vue
        PreviewArea.vue
        PropsEditor.vue
        ResponsiveTester.vue
        Settings.vue
        StateManager.vue
      folder/
        FolderForm.vue
        FolderItem.vue
        FolderTree.vue
      form/
        FormPassword.vue
      nav/
        NavAppTop.vue
        NavMobiBottom.vue
        NavMobiSlideover.vue
      news/
        NewsCard.vue
        NewsCardSkeleton.vue
        NewsModal.vue
        NewsNavigationButton.vue
        NewsSummaryLevel.vue
      newsletter/
        NewsletterBasic.vue
      notification/
        Notification.vue
      onboarding/
        Account.vue
        Interests.vue
        Professional.vue
      post/
        PostCard.vue
      research/
        ResearchCard.vue
      search/
        SearchBar.vue
      supa/
        Download.vue
        Realtime.vue
        Upload.vue
      user/
        settings/
          UserSettingsCard.vue
          UserSettingsItem.vue
      vote/
        VoteAnimate.vue
        VoteButton.vue
      AppBackButton.vue
      ConfirmationDialog.vue
      DeleteConfirmation.vue
      FuzzySearch.vue
      PaymentButton.vue
      UploadCropper.vue
    composables/
      companies/
        companies.store.ts
      events/
        events.store.ts
      news/
        news.store.ts
      users/
        user-settings.store.ts
        user.admin.composable.ts
      category-tags.store.ts
      chat.store.ts
      chunks.store.ts
      feedback.store.ts
      onboarding.composable.ts
      useBookmarkManager.ts
      useBookmarks.ts
      useBookmarkView.ts
      useFolderSystem.ts
      usePages.ts
      usePayments.ts
      usePlan.ts
      usePWA.ts
      useVotesStore.ts
    docs/
      uuid.md
    layouts/
      app-settings.vue
      default.vue
    middleware/
      auth.global.ts
      isCurrentUser.ts
    pages/
      feed/
        [feed].vue
        add.vue
      news/
        index.vue
      profile/
        settings/
          password.vue
          payments.vue
          profile.vue
        votes/
          [type].vue
        bookmarks.vue
        index.vue
      ask.vue
      auth-callback.vue
      companies.vue
      events.vue
      index.vue
      offline.vue
      onboarding.vue
      research.vue
    plugins/
      formbricks.client.ts
      pwa.client.ts
    server/
      api/
        ai/
          ask.ts
        bookmarks/
          [id].delete.ts
          index.ts
          move.patch.ts
          toggle.ts
        folders/
          [id].delete.ts
          [id].patch.ts
          index.ts
        payment/
          [provider]/
            create-order.ts
            subscription.get.ts
            verify-payment.post.ts
        users/
          update.post.ts
        votes/
          [contentType]/
            [id].get.ts
            [id].post.ts
          user/
            [voteType].get.ts
          user.get.ts
        webhook/
          database.ts
        upload.ts
      middleware/
        feature-limit.ts
      plugins/
        error-handler.ts
      utils/
        openai/
          callOpenAI.ts
          openaiClient.ts
        storage/
          storageSupabase.ts
        agents.ts
        errors.ts
        featureLimits.ts
        formatter.ts
        generateServerToken.ts
        groqClient.ts
        rateLimiter.ts
        validator.ts
    shared/
      constants.ts
      index.ts
    tasks/
      setup-posthog.md
    types/
      bookmarks.ts
      folder.ts
      toasts.ts
    app.config.ts
    app.vue
    error.vue
    nuxt.config.ts
    prompt-app-download.ts
    README.md
    tailwind.config.ts
layers/
  advert/
    .playground/
      app.config.ts
      nuxt.config.ts
    components/
      Advertisement.vue
    plugins/
      error-handler.ts
      sentry.server.ts
    server/
      api/
        advertisement/
          metrics.get.ts
          metrics.post.ts
    nuxt.config.ts
  auth/
    .playground/
      app.config.ts
      nuxt.config.ts
    composables/
      user.current.store.ts
    server/
      middleware/
        cors.ts
    nuxt.config.ts
  base/
    .playground/
      app.config.ts
      nuxt.config.ts
    components/
      image/
        ImageHero.vue
        ImageWithFallback.vue
      Background.vue
      Breadcrumbs.vue
      Glass.vue
      GlobalTimer.vue
      Grid.vue
      HelloWorld.vue
      HoverCard.vue
      Image.vue
      InfiniteScroll.vue
      Loader.vue
      Modal.vue
      NavHamburger.vue
      NewLabel.vue
      Pagination.vue
      Popover.vue
      Resizable.vue
      Sidebar.vue
      SideNav.vue
      SocialBlock.vue
      TabView.vue
      YT.client.vue
    composables/
      utils/
        arrays.ts
        hasValueChanged.ts
        objects.ts
        strings.ts
        time.ts
      ab-test.ts
      analytics.ts
      glass-card.ts
      metrics.ts
      modal.ts
      notification.ts
      settings.store.ts
      social.store.ts
      useMediaQuery.ts
      useNavigation.ts
      utils.ts
    plugins/
      error-handler.ts
      posthog.client.ts
      sentry.client.ts
    types/
      content.ts
      database.ts
      index.ts
      users.ts
    nuxt.config.ts
    supabase-provider.ts
  crud/
    .playground/
      app.config.ts
      nuxt.config.ts
    components/
      Feedback.vue
      Upload.vue
    composables/
      audit.ts
      delete.ts
      fetch.ts
      http-handler.ts
      insert.ts
      loading.store.ts
      local-storage.ts
      main.store.ts
      notification.ts
      pagination.store.ts
      rate-limit.ts
      select.ts
      settings.store.ts
      update.ts
      upload.ts
      useApiDataStore.ts
      useBaseError.ts
      user.current.store.ts
    server/
      utils/
        base.interface.ts
    nuxt.config.ts
libs/
  logger/
    src/
      environment.d.ts
      environment.ts
      error-interface.ts
      handler.ts
      logger.ts
    index.d.ts
    index.ts
shared-runtime.config.ts
```

# Repository Files

## File: apps/main-app/app/router.options.ts
```typescript
 1: import type { RouterOptions } from '@nuxt/schema'
 2: 
 3: export default <RouterOptions>{
 4:   scrollBehavior(to, _from, savedPosition) {
 5:     return new Promise((resolve, _reject) => {
 6:       setTimeout(() => {
 7:         if (savedPosition) {
 8:           resolve(savedPosition)
 9:         } else if (to.hash) {
10:           resolve({
11:             el: to.hash,
12:             top: 0,
13:           })
14:         } else {
15:           resolve({ top: 0 })
16:         }
17:       }, 100)
18:     })
19:   },
20: }
```

## File: apps/main-app/components/bookmark/BookmarkCard.vue
```vue
 1: <!-- BookmarksCard -->
 2: <template>
 3:   <div
 4:     :class="[
 5:       'relative group p-4 border border-color rounded-lg hover:shadow-sm transition-shadow',
 6:       selected ? 'ring-2 ring-primary-500 border-transparent' : 'hover:border-color',
 7:     ]"
 8:   >
 9:     <!-- Selection Checkbox -->
10:     <div class="absolute top-2 left-2 z-10">
11:       <input
12:         type="checkbox"
13:         :checked="selected"
14:         class="rounded border-color"
15:         @change="$emit('select', bookmark.id)"
16:       />
17:     </div>
18: 
19:     <!-- Content -->
20:     <div class="space-y-2">
21:       <NuxtImg
22:         :src="bookmark.metadata.thumbnail"
23:         :alt="bookmark.metadata.title"
24:         class="w-full h-48 object-cover rounded"
25:       />
26: 
27:       <h3 class="font-medium line-clamp-2">
28:         {{ bookmark.metadata.title }}
29:       </h3>
30: 
31:       <p class="text-sm text-gray-600 line-clamp-2">
32:         {{ bookmark.metadata.description }}
33:       </p>
34: 
35:       <!-- Folder Badge -->
36:       <div
37:         v-if="bookmark.folder"
38:         class="flex items-center gap-1.5 text-sm text-gray-600"
39:       >
40:         <div
41:           class="w-2 h-2 rounded-full"
42:           :style="{ backgroundColor: bookmark.folder.color }"
43:         />
44:         <span class="truncate">{{ bookmark.folder.name }}</span>
45:         <Icon
46:           v-if="bookmark.folder.is_favorite"
47:           name="mdi:star"
48:           class="w-4 h-4 text-yellow-400"
49:         />
50:       </div>
51:     </div>
52: 
53:     <!-- Actions -->
54:     <div class="absolute top-2 right-2 opacity-0 group-hover:opacity-100 transition-opacity">
55:       <button
56:         class="p-1.5 text-gray-400 hover:text-gray-600"
57:         @click="$emit('move')"
58:       >
59:         <Icon
60:           name="mdi:folder-move"
61:           class="w-5 h-5"
62:         />
63:       </button>
64:       <button
65:         class="p-1.5 text-gray-400 hover:text-red-600"
66:         @click="$emit('delete')"
67:       >
68:         <Icon
69:           name="mdi:trash"
70:           class="w-5 h-5"
71:         />
72:       </button>
73:     </div>
74:   </div>
75: </template>
76: 
77: <script setup lang="ts">
78: import type { Bookmark } from '../../types/bookmarks'
79: 
80: interface Props {
81:   bookmark: Bookmark
82:   selected?: boolean
83:   showSelect?: boolean
84: }
85: 
86: const props = withDefaults(defineProps<Props>(), {
87:   selected: false,
88:   showSelect: false,
89: })
90: 
91: const emit = defineEmits<{
92:   (e: 'select', id: string): void
93:   (e: 'move'): void
94:   (e: 'delete'): void
95: }>()
96: </script>
```

## File: apps/main-app/components/bookmark/BookmarkFormMove.vue
```vue
 1: <script setup lang="ts">
 2: import type { Folder } from '~/types/bookmark'
 3: 
 4: const props = defineProps<{
 5:   folders: Folder[]
 6:   selectedFolder: Folder | null
 7: }>()
 8: 
 9: const emit = defineEmits<{
10:   (e: 'submit', folderId: string): void
11:   (e: 'cancel'): void
12: }>()
13: 
14: const targetFolderId = ref<string | null>(null)
15: 
16: const handleSubmit = () => {
17:   if (targetFolderId.value) {
18:     emit('submit', targetFolderId.value)
19:   }
20: }
21: </script>
22: 
23: <template>
24:   <div class="space-y-4">
25:     <div class="py-4">
26:       <div class="mb-4">
27:         <label class="block text-sm font-medium text-gray-700">Select Destination Folder</label>
28:         <select
29:           v-model="targetFolderId"
30:           class="mt-1 block w-full rounded-md border-gray-300"
31:           required
32:         >
33:           <option
34:             v-for="folder in folders"
35:             :key="folder.id"
36:             :value="folder.id"
37:             :disabled="folder.id === selectedFolder?.id"
38:           >
39:             {{ folder.name }}
40:             {{ folder.id === selectedFolder?.id ? '(Current)' : '' }}
41:           </option>
42:         </select>
43:       </div>
44:     </div>
45: 
46:     <div class="flex justify-end gap-2">
47:       <button
48:         type="button"
49:         @click="$emit('cancel')"
50:         class="px-4 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-md hover:bg-gray-50"
51:       >
52:         Cancel
53:       </button>
54:       <button
55:         @click="handleSubmit"
56:         class="px-4 py-2 text-sm font-medium text-white bg-primary-600 rounded-md hover:bg-primary-700 disabled:opacity-50"
57:         :disabled="!targetFolderId"
58:       >
59:         Move
60:       </button>
61:     </div>
62:   </div>
63: </template>
```

## File: apps/main-app/components/bookmark/BookmarkList.vue
```vue
  1: <!-- BookmarksList -->
  2: <template>
  3:   <div class="flex gap-6">
  4:     <!-- Folder Sidebar -->
  5:     <div class="w-64 flex-shrink-0">
  6:       <FolderTree
  7:         v-model:selected="currentFolderId"
  8:         @select="handleFolderSelect"
  9:       />
 10:     </div>
 11: 
 12:     <!-- Bookmarks Content -->
 13:     <div class="flex-1 space-y-4">
 14:       <!-- Folder Header -->
 15:       <div
 16:         v-if="currentFolder"
 17:         class="flex items-center justify-between"
 18:       >
 19:         <div class="flex items-center gap-2">
 20:           <div
 21:             class="w-3 h-3 rounded-full"
 22:             :style="{ backgroundColor: currentFolder.color }"
 23:           />
 24:           <h2 class="text-lg font-medium">{{ currentFolder.name }}</h2>
 25:           <span
 26:             v-if="currentFolder.is_favorite"
 27:             class="text-yellow-400"
 28:           >
 29:             <Icon
 30:               name="mdi:star"
 31:               class="w-4 h-4"
 32:             />
 33:           </span>
 34:         </div>
 35: 
 36:         <!-- Folder Actions -->
 37:         <div class="flex items-center gap-2">
 38:           <label class="flex items-center text-sm text-gray-600">
 39:             <input
 40:               v-model="includeSubfolders"
 41:               type="checkbox"
 42:               class="rounded border border-color mr-2"
 43:             />
 44:             Include subfolders
 45:           </label>
 46:         </div>
 47:       </div>
 48: 
 49:       <!-- Search -->
 50:       <div class="relative">
 51:         <Icon
 52:           name="mdi:magnify"
 53:           class="absolute left-3 top-1/2 -translate-y-1/2 text-gray-400 w-5 h-5"
 54:         />
 55:         <input
 56:           v-model="searchQuery"
 57:           type="text"
 58:           placeholder="Search bookmarks..."
 59:           class="w-full pl-10 pr-4 py-2 rounded-lg border"
 60:         />
 61:       </div>
 62: 
 63:       <!-- Bookmarks Grid -->
 64:       <div
 65:         v-if="!loading"
 66:         class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4"
 67:       >
 68:         <BookmarkCard
 69:           v-for="bookmark in displayedBookmarks"
 70:           :key="bookmark.id"
 71:           :bookmark="bookmark"
 72:           :selected="selectedBookmarks.includes(bookmark.id)"
 73:           @select="toggleBookmarkSelection"
 74:           @move="showMoveDialog = true"
 75:         />
 76:       </div>
 77: 
 78:       <div
 79:         v-else
 80:         class="flex items-center justify-center h-64"
 81:       >
 82:         <Icon
 83:           name="mdi:loading"
 84:           class="w-8 h-8 text-gray-400 animate-spin"
 85:         />
 86:       </div>
 87:     </div>
 88: 
 89:     <PrimeDialog
 90:       v-model:visible="showMoveModal"
 91:       modal
 92:       header="Move Bookmarks"
 93:       :style="{ width: '90vw', maxWidth: '500px' }"
 94:     >
 95:       <!-- Main Content -->
 96:       <span class="text-surface-500 dark:text-surface-400 block mb-4">
 97:         Select a destination folder for {{ selectedBookmarks.length }} bookmark(s).
 98:       </span>
 99: 
100:       <div class="max-h-[400px] overflow-y-auto p-2">
101:         <FolderTree
102:           v-model:selected-keys="targetFolderId"
103:           selection-mode="single"
104:           :value="folders"
105:           :filter="true"
106:           filter-mode="strict"
107:           class="w-full"
108:         >
109:           <template #default="{ node }">
110:             <div class="flex items-center gap-2">
111:               <div
112:                 class="w-3 h-3 rounded-full"
113:                 :style="{ backgroundColor: node.color }"
114:               />
115:               <span>{{ node.name }}</span>
116:               <Icon
117:                 v-if="node.is_favorite"
118:                 name="mdi:star"
119:                 class="text-yellow-400 w-4 h-4"
120:               />
121:             </div>
122:           </template>
123:         </FolderTree>
124:       </div>
125: 
126:       <!-- Footer -->
127:       <template #footer>
128:         <PrimeButton
129:           label="Cancel"
130:           class="p-button-text"
131:           severity="secondary"
132:           @click="showMoveModal = false"
133:         />
134:         <PrimeButton
135:           label="Move"
136:           :disabled="!targetFolderId"
137:           severity="primary"
138:           @click="(folder) => handleMoveSubmit(folder)"
139:         />
140:       </template>
141:     </PrimeDialog>
142:   </div>
143: </template>
144: 
145: <script setup lang="ts">
146: const { bookmarks, loading, fetchBookmarks, moveBookmarks, searchBookmarks } = useBookmarks()
147: 
148: const { folders, getFavorites } = useFolderSystem()
149: 
150: const currentFolderId = ref<string | null>(null)
151: const includeSubfolders = ref(true)
152: const searchQuery = ref('')
153: const selectedBookmarks = ref<string[]>([])
154: const showMoveDialog = ref(false)
155: const targetFolderId = ref<string | null>(null)
156: 
157: const currentFolder = computed(() => folders.value.find((f) => f.id === currentFolderId.value))
158: 
159: const displayedBookmarks = computed(() => {
160:   if (!searchQuery.value) return bookmarks.value
161:   return searchBookmarks(searchQuery.value)
162: })
163: 
164: const handleFolderSelect = async (folder: Folder) => {
165:   currentFolderId.value = folder.id
166:   await fetchBookmarks({
167:     folder_id: folder.id,
168:     include_subfolders: includeSubfolders.value,
169:   })
170: }
171: 
172: const toggleBookmarkSelection = (bookmarkId: string) => {
173:   const index = selectedBookmarks.value.indexOf(bookmarkId)
174:   if (index === -1) {
175:     selectedBookmarks.value.push(bookmarkId)
176:   } else {
177:     selectedBookmarks.value.splice(index, 1)
178:   }
179: }
180: 
181: const handleMoveBookmarks = async () => {
182:   if (!targetFolderId.value) return
183: 
184:   await moveBookmarks(selectedBookmarks.value, targetFolderId.value)
185:   selectedBookmarks.value = []
186:   showMoveDialog.value = false
187:   targetFolderId.value = null
188: }
189: 
190: watch(includeSubfolders, async () => {
191:   if (currentFolderId.value) {
192:     await fetchBookmarks({
193:       folder_id: currentFolderId.value,
194:       include_subfolders: includeSubfolders.value,
195:     })
196:   }
197: })
198: 
199: onMounted(async () => {
200:   // Start with default folder if exists
201:   const defaultFolder = folders.value.find((f) => f.is_default)
202:   if (defaultFolder) {
203:     currentFolderId.value = defaultFolder.id
204:     await handleFolderSelect(defaultFolder)
205:   } else {
206:     await fetchBookmarks({})
207:   }
208: })
209: </script>
```

## File: apps/main-app/components/bookmark/BookmarkViewFolder.vue
```vue
  1: <template>
  2:   <div class="space-y-6">
  3:     <div class="flex items-center justify-between mb-4">
  4:       <h2 class="text-xl font-semibold">Folders</h2>
  5:       <PrimeButton
  6:         class="p-button-primary"
  7:         @click="showModal = true"
  8:       >
  9:         <div class="flex items-center gap-2">
 10:           <Icon name="mdi:folder-plus" />
 11:           <span
 12:             >New Folder ({{ folderUsage.used }}/{{
 13:               folderUsage.isUnlimited ? '∞' : folderUsage.limit
 14:             }})</span
 15:           >
 16:         </div>
 17:       </PrimeButton>
 18:     </div>
 19: 
 20:     <!-- Folders Grid -->
 21:     <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4">
 22:       <div
 23:         v-for="folder in folders"
 24:         :key="folder.id"
 25:         class="p-4 hover:shadow-md transition-shadow bg-card border border-color rounded-lg cursor-pointer group"
 26:         @click="handleEditClick(folder)"
 27:       >
 28:         <div class="flex items-center justify-between">
 29:           <div class="flex items-center gap-2">
 30:             <div
 31:               class="w-3 h-3 rounded-full"
 32:               :style="{ backgroundColor: folder.color }"
 33:             />
 34:             <h3 class="font-medium">{{ folder.name }}</h3>
 35:             <Icon
 36:               v-if="folder.is_favorite"
 37:               name="mdi:star"
 38:               class="w-4 h-4 text-yellow-400"
 39:             />
 40:           </div>
 41:           <div class="flex items-center gap-2">
 42:             <span
 43:               v-if="folder.is_default"
 44:               class="text-sm text-muted-foreground"
 45:             >
 46:               Default
 47:             </span>
 48:             <Icon
 49:               name="mdi:pencil"
 50:               class="w-4 h-4 opacity-0 group-hover:opacity-100 transition-opacity"
 51:             />
 52:           </div>
 53:         </div>
 54:         <p class="mt-2 text-sm text-muted-foreground">
 55:           {{ getFolderBookmarkCount(folder.id) }} bookmarks
 56:         </p>
 57:       </div>
 58:     </div>
 59: 
 60:     <!-- Modal for both create and edit -->
 61:     <PrimeDialog
 62:       v-model:visible="showModal"
 63:       :modal="true"
 64:       :header="selectedFolder ? 'Edit Folder' : 'New Folder'"
 65:       :style="{ width: '90vw', maxWidth: '500px' }"
 66:     >
 67:       <FolderForm
 68:         :folder="selectedFolder"
 69:         @submit="handleSubmit"
 70:         @delete="handleDelete"
 71:         @cancel="closeModal"
 72:       />
 73:     </PrimeDialog>
 74:   </div>
 75: </template>
 76: 
 77: <script setup lang="ts">
 78: import type { Folder } from '~/types/folder'
 79: 
 80: const { folders, createFolder, updateFolder, deleteFolder } = useFolderSystem()
 81: const { bookmarks } = useBookmarks()
 82: const { getFeatureUsage } = usePlan()
 83: 
 84: const showModal = ref(false)
 85: const selectedFolder = ref<Folder | null>(null)
 86: 
 87: const folderUsage = computed(() => getFeatureUsage('BOOKMARK_FOLDERS', folders.value.length))
 88: 
 89: const getFolderBookmarkCount = (folderId: string) => {
 90:   return bookmarks.value.filter((bookmark) => bookmark.folder_id === folderId).length
 91: }
 92: 
 93: const handleEditClick = (folder: Folder) => {
 94:   selectedFolder.value = folder
 95:   showModal.value = true
 96: }
 97: 
 98: const closeModal = () => {
 99:   showModal.value = false
100:   selectedFolder.value = null
101: }
102: 
103: const handleSubmit = async (data: Partial<Folder>) => {
104:   if (selectedFolder.value) {
105:     await updateFolder(selectedFolder.value.id, data)
106:   } else {
107:     await createFolder(data)
108:   }
109:   closeModal()
110: }
111: 
112: const handleDelete = async () => {
113:   if (selectedFolder.value) {
114:     await deleteFolder(selectedFolder.value.id)
115:     closeModal()
116:   }
117: }
118: </script>
```

## File: apps/main-app/components/company/CompanyCard.vue
```vue
  1: <script setup lang="ts">
  2: defineProps({
  3:   company: {
  4:     type: Object as () => {},
  5:     required: true,
  6:   },
  7: })
  8: 
  9: const { getCategoryName } = useCategoryTagStore()
 10: 
 11: // What to display:
 12: // Company location(s)
 13: // Category
 14: // Tags?
 15: // Name
 16: // Link to website
 17: // Number of news updates
 18: // Scrape Frequency?
 19: // Sector
 20: // Founded Year
 21: // Description - probably a summary of all articles by chatGPT
 22: // Logo
 23: // isHiring (check job board to see, maybe linkedin) - add later, just scrape Linkedin Jobs for now
 24: // isFunded
 25: // valuation
 26: // companySize
 27: // primaryLocation
 28: // country
 29: //
 30: </script>
 31: 
 32: <template>
 33:   <div class="border-color border-b-2 px-4 py-8">
 34:     <div>
 35:       <div class="space-y-4 pb-4">
 36:         <div class="flex items-center gap-4">
 37:           <IBImage
 38:             v-if="company.logo_url"
 39:             class="border-color rounded-full border"
 40:             :img="{
 41:               src: `companies/${company.logo_url}`,
 42:               width: '60',
 43:               height: '60',
 44:             }"
 45:           />
 46:           <div>
 47:             <h3 class="text-balance text-xl font-semibold md:max-h-16">
 48:               {{ company.name }}
 49:             </h3>
 50:             <p
 51:               v-if="company.category_id !== 16"
 52:               class="text-sm"
 53:             >
 54:               {{ getCategoryName(company.category_id) }}
 55:             </p>
 56:           </div>
 57:           <!-- <span class="text-sm w-auto">
 58:             Scraped: {{ useTimeAgo(company.scraped_at).value }}
 59:           </span> -->
 60:         </div>
 61:       </div>
 62:     </div>
 63:     <div class="flex flex-col gap-4">
 64:       <div class="flex items-center gap-2">
 65:         <PrimeTag severity="info">
 66:           {{ company.is_government ? 'Government' : 'Private' }}
 67:         </PrimeTag>
 68:         <PrimeTag
 69:           v-if="company.founding_year"
 70:           severity="info"
 71:         >
 72:           founded: {{ company.founding_year }}
 73:         </PrimeTag>
 74:         <IBNewLabel
 75:           :date="company.created_at!"
 76:           :max-age="14"
 77:         />
 78:       </div>
 79:       <p
 80:         v-if="company.description"
 81:         class="text-sm"
 82:       >
 83:         {{ company.description }}
 84:       </p>
 85:       <div class="flex w-full items-center justify-between pt-4">
 86:         <div>
 87:           <IBSocialBlock
 88:             v-if="company.social_media"
 89:             :socials="company.social_media"
 90:           />
 91:         </div>
 92:         <NuxtLink
 93:           :to="company.url"
 94:           target="_blank"
 95:           rel="noopener"
 96:         >
 97:           <PrimeButton
 98:             label="Website"
 99:             size="small"
100:             outlined
101:           />
102:         </NuxtLink>
103:       </div>
104:     </div>
105:   </div>
106: </template>
```

## File: apps/main-app/components/company/CompanyCardSkeleton.vue
```vue
 1: <script setup lang="ts"></script>
 2: 
 3: <template>
 4:   <div class="border-b-2 border-color px-4 py-8">
 5:     <div>
 6:       <div class="space-y-4 pb-4">
 7:         <div class="flex gap-4 items-center">
 8:           <PrimeSkeleton
 9:             :pt="{
10:               root: 'max-w-16 min-h-16 rounded-full',
11:             }"
12:           />
13: 
14:           <div class="w-full space-y-2">
15:             <PrimeSkeleton class="max-w-64 min-h-6 rounded-md" />
16:             <PrimeSkeleton class="max-w-48 h-4 rounded-md" />
17:           </div>
18:         </div>
19:       </div>
20:     </div>
21:     <div class="flex flex-col gap-4">
22:       <div class="flex gap-2 items-center">
23:         <PrimeSkeleton class="max-w-32 min-h-6 rounded-md" />
24:         <PrimeSkeleton class="max-w-16 min-h-6 rounded-md" />
25:       </div>
26:       <PrimeSkeleton class="w-full min-h-24 rounded-md" />
27: 
28:       <div class="w-full flex justify-between items-center pt-4">
29:         <PrimeSkeleton class="max-w-32 min-h-6 rounded-md" />
30:         <PrimeSkeleton class="max-w-24 min-h-10 rounded-md" />
31:       </div>
32:     </div>
33:   </div>
34: </template>
```

## File: apps/main-app/components/content/financial-chart.vue
```vue
  1: <template>
  2:   <div>
  3:     <Chart
  4:       v-if="chartDataKey"
  5:       :chart="currentChartData"
  6:     />
  7:   </div>
  8: </template>
  9: 
 10: <script setup lang="ts">
 11: type ChartDataKey =
 12:   | 'users'
 13:   | 'revenue'
 14:   | 'globalMarket'
 15:   | 'indianMarket'
 16:   | 'affiliateRevenue'
 17:   | 'useOfFunds'
 18:   | 'financialProgress'
 19: 
 20: const props = defineProps({
 21:   chartDataKey: {
 22:     type: String as PropType<ChartDataKey>,
 23:     required: true,
 24:   },
 25: })
 26: 
 27: // Financial Data
 28: const initialFreeUsers = 10000
 29: const year2FreeUsers = 50000
 30: const year3FreeUsers = 200000
 31: 
 32: const conversionRateYear1 = 0.03
 33: const conversionRateYear2 = 0.06
 34: 
 35: const proPricePerMonth = 30
 36: const expertPricePerMonth = 50
 37: 
 38: const advertisingCPM = 10
 39: const affiliateCommissionYear1 = 0.1
 40: const affiliateCommissionYear2 = 0.15
 41: const affiliateCommissionYear3 = 0.2
 42: const averageSale = 50
 43: const conversionRateAffiliate = 0.05
 44: 
 45: // User Projections
 46: function getFreeUsers(year: number): number {
 47:   switch (year) {
 48:     case 1:
 49:       return initialFreeUsers
 50:     case 2:
 51:       return year2FreeUsers
 52:     case 3:
 53:       return year3FreeUsers
 54:     default:
 55:       throw new Error('Year must be 1, 2, or 3')
 56:   }
 57: }
 58: 
 59: function getConversionRate(year: number): number {
 60:   switch (year) {
 61:     case 1:
 62:       return conversionRateYear1
 63:     case 2:
 64:       return conversionRateYear2
 65:     case 3:
 66:       return conversionRateYear2
 67:     default:
 68:       throw new Error('Year must be 1, 2, or 3')
 69:   }
 70: }
 71: 
 72: function getAffiliateCommission(year: number): number {
 73:   switch (year) {
 74:     case 1:
 75:       return affiliateCommissionYear1
 76:     case 2:
 77:       return affiliateCommissionYear2
 78:     case 3:
 79:       return affiliateCommissionYear3
 80:     default:
 81:       throw new Error('Year must be 1, 2, or 3')
 82:   }
 83: }
 84: 
 85: // User Segmentation
 86: function calculatePayingUsers(
 87:   freeUsers: number,
 88:   conversionRate: number,
 89: ): { proUsers: number, expertUsers: number } {
 90:   const payingUsers = freeUsers * conversionRate
 91:   const proUsers = payingUsers * 0.5
 92:   const expertUsers = payingUsers * 0.5
 93:   return { proUsers, expertUsers }
 94: }
 95: 
 96: // Revenue Calculations
 97: function calculateSubscriptionRevenue(users: number, pricePerMonth: number): number {
 98:   return users * pricePerMonth * 12 // annual revenue
 99: }
100: 
101: function calculateAdvertisingRevenue(impressionsPerMonth: number, cpm: number): number {
102:   return (impressionsPerMonth / 1000) * cpm * 12 // annual revenue
103: }
104: 
105: function calculateAffiliateRevenue(
106:   clicksPerMonth: number,
107:   conversionRate: number,
108:   averageSale: number,
109:   commissionRate: number,
110: ): number {
111:   const sales = clicksPerMonth * conversionRate
112:   const revenue = sales * averageSale
113:   return revenue * commissionRate * 12 // annual revenue
114: }
115: 
116: // Yearly Projections
117: function getClicksPerMonth(year: number): number {
118:   switch (year) {
119:     case 1:
120:       return 10000
121:     case 2:
122:       return 50000
123:     case 3:
124:       return 200000
125:     default:
126:       throw new Error('Year must be 1, 2, or 3')
127:   }
128: }
129: 
130: function getImpressionsPerMonth(year: number): number {
131:   switch (year) {
132:     case 1:
133:       return 100000
134:     case 2:
135:       return 500000
136:     case 3:
137:       return 2000000
138:     default:
139:       throw new Error('Year must be 1, 2, or 3')
140:   }
141: }
142: 
143: function calculateYearlyRevenue(year: number): {
144:   proRevenue: number
145:   expertRevenue: number
146:   adRevenue: number
147:   affiliateRevenue: number
148: } {
149:   const freeUsers = getFreeUsers(year)
150:   const conversionRate = getConversionRate(year)
151:   const clicksPerMonth = getClicksPerMonth(year)
152:   const impressionsPerMonth = getImpressionsPerMonth(year)
153:   const affiliateCommission = getAffiliateCommission(year)
154: 
155:   const { proUsers, expertUsers } = calculatePayingUsers(freeUsers, conversionRate)
156: 
157:   const proRevenue = calculateSubscriptionRevenue(proUsers, proPricePerMonth)
158:   const expertRevenue = calculateSubscriptionRevenue(expertUsers, expertPricePerMonth)
159:   const adRevenue = calculateAdvertisingRevenue(impressionsPerMonth, advertisingCPM)
160:   const affiliateRevenue = calculateAffiliateRevenue(
161:     clicksPerMonth,
162:     conversionRateAffiliate,
163:     averageSale,
164:     affiliateCommission,
165:   )
166: 
167:   return { proRevenue, expertRevenue, adRevenue, affiliateRevenue }
168: }
169: 
170: // Example Usage
171: const year1Revenue = calculateYearlyRevenue(1)
172: const year2Revenue = calculateYearlyRevenue(2)
173: const year3Revenue = calculateYearlyRevenue(3)
174: 
175: const labels = {
176:   years: ['Year 1', 'Year 2', 'Year 3'],
177: }
178: 
179: const chartStyle = {
180:   backgroundColor: [
181:     'rgba(249, 115, 22, 0.2)',
182:     'rgba(6, 182, 212, 0.2)',
183:     'rgb(107, 114, 128, 0.2)',
184:     'rgba(139, 92, 246 0.2)',
185:   ],
186:   borderColor: ['rgb(249, 115, 22)', 'rgb(6, 182, 212)', 'rgb(107, 114, 128)', 'rgb(139, 92, 246)'],
187:   borderWidth: 1,
188: }
189: 
190: const chartStyleFreeUsers = {
191:   backgroundColor: 'rgba(249, 115, 22, 0.2)',
192:   borderColor: 'rgb(249, 115, 22)',
193:   borderWidth: 1,
194: }
195: 
196: const chartStyleProUsers = {
197:   backgroundColor: 'rgba(6, 182, 212, 0.2)',
198:   borderColor: 'rgb(6, 182, 212)',
199:   borderWidth: 1,
200: }
201: 
202: const chartStyleExpertUsers = {
203:   backgroundColor: 'rgba(107, 114, 128, 0.2)',
204:   borderColor: 'rgb(107, 114, 128)',
205:   borderWidth: 1,
206: }
207: 
208: const financialProgressChart = {
209:   id: 2,
210:   title: 'Financial and User Growth Over 12 Months',
211:   subtitle: 'Revenue, Expenses, User Base, and Capital',
212:   scaleType: 'logarithmic',
213:   type: 'bar',
214:   data: {
215:     labels: [
216:       'Month 1',
217:       'Month 2',
218:       'Month 3',
219:       'Month 4',
220:       'Month 5',
221:       'Month 6',
222:       'Month 7',
223:       'Month 8',
224:       'Month 9',
225:       'Month 10',
226:       'Month 11',
227:       'Month 12',
228:     ],
229:     datasets: [
230:       {
231:         label: 'Basic Plan Revenue',
232:         data: [0, 0, 24000, 46200, 79200, 124800, 189000, 241800, 288000, 326700, 367200, 420000],
233:         backgroundColor: 'rgba(249, 115, 22, 0.6)',
234:         borderColor: 'rgb(249, 115, 22)',
235:         borderWidth: 1,
236:         stack: 'stack1',
237:         valueType: 'currency' as const,
238:       },
239:       {
240:         label: 'Medium Plan Revenue',
241:         data: [0, 0, 48000, 92400, 158400, 249600, 378000, 483600, 576000, 653400, 734400, 840000],
242:         backgroundColor: 'rgba(6, 182, 212, 0.6)',
243:         borderColor: 'rgb(6, 182, 212)',
244:         borderWidth: 1,
245:         valueType: 'currency' as const,
246:         stack: 'stack1',
247:       },
248:       {
249:         label: 'Pro Plan Revenue',
250:         data: [0, 0, 0, 0, 0, 249600, 378000, 483600, 576000, 653400, 734400, 840000],
251:         backgroundColor: 'rgba(107, 114, 128, 0.6)',
252:         borderColor: 'rgb(107, 114, 128)',
253:         borderWidth: 1,
254:         valueType: 'currency' as const,
255:         stack: 'stack1',
256:       },
257:       {
258:         label: 'B2B Plan Revenue',
259:         data: [0, 0, 0, 0, 0, 0, 0, 0, 50000, 100000, 150000, 200000],
260:         backgroundColor: 'rgba(139, 92, 246, 0.6)',
261:         borderColor: 'rgb(139, 92, 246)',
262:         borderWidth: 1,
263:         valueType: 'currency' as const,
264:         stack: 'stack1',
265:       },
266:       {
267:         label: 'Ad Revenue',
268:         data: [
269:           0, 10000, 20000, 35000, 55000, 80000, 105000, 130000, 150000, 165000, 180000, 200000,
270:         ],
271:         backgroundColor: 'rgba(34, 197, 94, 0.6)',
272:         borderColor: 'rgb(34, 197, 94)',
273:         borderWidth: 1,
274:         valueType: 'currency' as const,
275:         stack: 'stack1',
276:       },
277:       {
278:         label: 'Expenses',
279:         data: [
280:           200000, 200000, 200000, 200000, 200000, 200000, 200000, 200000, 200000, 200000, 200000,
281:           200000,
282:         ],
283:         backgroundColor: 'rgba(239, 68, 68, 0.6)',
284:         borderColor: 'rgb(239, 68, 68)',
285:         borderWidth: 1,
286:         valueType: 'currency' as const,
287:       },
288:       {
289:         label: 'Total Users',
290:         data: [500, 2000, 4000, 7000, 11000, 16000, 21000, 26000, 30000, 33000, 36000, 40000],
291:         borderColor: 'rgb(59, 130, 246)',
292:         borderWidth: 2,
293:         valueType: 'number' as const,
294:         type: 'line',
295:       },
296:       {
297:         label: 'Paid Users',
298:         data: [0, 0, 80, 154, 264, 416, 630, 806, 960, 1089, 1224, 1400],
299:         borderColor: 'rgb(147, 51, 234)',
300:         borderWidth: 2,
301:         valueType: 'number' as const,
302:         type: 'line',
303:       },
304:       {
305:         label: 'Capital',
306:         data: [
307:           790000, 610000, 502000, 475600, 568200, 1072200, 1922200, 3061200, 4501200, 6199700,
308:           8165700, 10365700,
309:         ],
310:         borderColor: 'rgb(234, 179, 8)',
311:         borderWidth: 2,
312:         valueType: 'currency' as const,
313:       },
314:     ],
315:   },
316:   info: [
317:     { name: 'Final Month Revenue', value: '₹24,00,000' },
318:     { name: 'User Growth', value: '5,000 to 40,000' },
319:     { name: 'Capital Growth', value: '₹7,90,000 to ₹1,03,65,700' },
320:     { name: 'Conversion Rate Growth', value: '2.0% to 3.5%' },
321:   ],
322: }
323: 
324: const currentChartData = computed(() => chartData[props.chartDataKey])
325: 
326: const useOfFundsChart = {
327:   id: 1,
328:   scaleType: 'linear' as const,
329:   title: 'Use of Funds Breakdown',
330:   subtitle: 'Allocation of 10,00,000 INR initial investment',
331:   type: 'pie',
332:   data: {
333:     labels: [
334:       'Product Development',
335:       'Marketing and User Acquisition',
336:       'Team Expansion',
337:       'Operational Costs',
338:     ],
339:     datasets: [
340:       {
341:         label: 'Cost',
342:         data: [400000, 300000, 200000, 100000],
343:         backgroundColor: [
344:           'rgba(249, 115, 22, 0.6)',
345:           'rgba(6, 182, 212, 0.6)',
346:           'rgba(107, 114, 128, 0.6)',
347:           'rgba(139, 92, 246, 0.6)',
348:         ],
349:         borderColor: [
350:           'rgb(249, 115, 22)',
351:           'rgb(6, 182, 212)',
352:           'rgb(107, 114, 128)',
353:           'rgb(139, 92, 246)',
354:         ],
355:         borderWidth: 1,
356:         valueType: 'currency' as const,
357:       },
358:     ],
359:   },
360:   info: [
361:     { name: 'Total Investment', value: '₹10,00,000' },
362:     { name: 'Largest Allocation', value: 'Product Development (₹4,00,000)' },
363:     { name: 'Smallest Allocation', value: 'Operational Costs (₹1,00,000)' },
364:   ],
365: }
366: 
367: const chartData = {
368:   financialProgress: financialProgressChart,
369:   useOfFunds: useOfFundsChart,
370:   users: {
371:     labels: labels.years,
372:     datasets: [
373:       {
374:         type: 'line',
375:         label: 'Free Users',
376:         data: [initialFreeUsers, year2FreeUsers, year3FreeUsers],
377:         ...chartStyleFreeUsers,
378:       },
379:       {
380:         type: 'line',
381:         label: 'Pro Users',
382:         data: [
383:           calculatePayingUsers(initialFreeUsers, conversionRateYear1).proUsers,
384:           calculatePayingUsers(year2FreeUsers, conversionRateYear2).proUsers,
385:           calculatePayingUsers(year3FreeUsers, conversionRateYear2).proUsers,
386:         ],
387:         ...chartStyleProUsers,
388:       },
389:       {
390:         type: 'line',
391:         label: 'Expert Users',
392:         data: [
393:           calculatePayingUsers(initialFreeUsers, conversionRateYear1).expertUsers,
394:           calculatePayingUsers(year2FreeUsers, conversionRateYear2).expertUsers,
395:           calculatePayingUsers(year3FreeUsers, conversionRateYear2).expertUsers,
396:         ],
397:         ...chartStyleExpertUsers,
398:       },
399:     ],
400:   },
401:   revenue: {
402:     labels: labels.years,
403:     datasets: [
404:       {
405:         label: 'Advertising Revenue',
406:         data: [year1Revenue.adRevenue, year2Revenue.adRevenue, year3Revenue.adRevenue],
407:         ...chartStyle,
408:       },
409:       {
410:         label: 'Pro Revenue',
411:         data: [year1Revenue.proRevenue, year2Revenue.proRevenue, year3Revenue.proRevenue],
412:         ...chartStyle,
413:       },
414:       {
415:         label: 'Expert Revenue',
416:         data: [year1Revenue.expertRevenue, year2Revenue.expertRevenue, year3Revenue.expertRevenue],
417:         ...chartStyle,
418:       },
419:     ],
420:   },
421:   globalMarket: {
422:     labels: [2023, 2024, 2025, 2026, 2027, 2028, 2029, 2030, 2031, 2032, 2033, 2034, 2035],
423:     datasets: [
424:       {
425:         label: '7.5% YOY Growth',
426:         data: [
427:           535.0, 575.125, 618.259375, 664.6288281249999, 714.4759902343749, 768.061689501953,
428:           825.6663162145994, 887.5912899306943, 954.1606366754963, 1025.7226844261586,
429:           1102.6518857581204, 1185.3507771899795, 1274.2520854792278,
430:         ],
431:       },
432:       {
433:         label: '9% YOY Growth',
434:         data: [
435:           535.0, 583.1500000000001, 635.6335000000001, 692.8405150000002, 755.1961613500002,
436:           823.1638158715003, 897.2485592999354, 978.0009296369298, 1066.0210133042535,
437:           1161.9629045016363, 1266.5395659067838, 1380.5281268383944, 1504.77565825385,
438:         ],
439:       },
440:       {
441:         label: '16% YOY Growth',
442:         data: [
443:           535.0, 620.5999999999999, 719.8959999999998, 835.0793599999997, 968.6920575999997,
444:           1123.6827868159996, 1303.4720327065595, 1512.0275579396089, 1753.9519672099461,
445:           2034.5842819635375, 2360.1177670777033, 2737.7366098101356, 3175.774467379757,
446:         ],
447:       },
448:     ],
449:   },
450: 
451:   indianMarket: {
452:     labels: [2023, 2024, 2025, 2026, 2027, 2028, 2029, 2030, 2031, 2032, 2033, 2034, 2035],
453:     datasets: [
454:       {
455:         label: '7.5% YOY Growth',
456:         data: [
457:           8.4, 9.03, 9.71, 10.44, 11.23, 12.06, 12.97, 13.95, 15.01, 16.14, 17.35, 18.66, 20.06,
458:         ],
459:       },
460:       {
461:         label: '9% YOY Growth',
462:         data: [
463:           8.4, 9.16, 9.99, 10.89, 11.87, 12.93, 14.08, 15.33, 16.69, 18.2, 19.84, 21.63, 23.58,
464:         ],
465:       },
466:       {
467:         label: '16% YOY Growth',
468:         data: [8.4, 9.74, 11.3, 13.1, 15.2, 17.63, 20.45, 23.72, 27.51, 31.91, 37.01, 42.93, 49.8],
469:       },
470:     ],
471:   },
472: 
473:   affiliateRevenue: {
474:     labels: labels.years,
475:     datasets: [
476:       {
477:         label: 'Affiliate Revenue',
478:         data: [
479:           year1Revenue.affiliateRevenue,
480:           year2Revenue.affiliateRevenue,
481:           year3Revenue.affiliateRevenue,
482:         ],
483:         ...chartStyle,
484:       },
485:     ],
486:   },
487: }
488: </script>
489: 
490: <style scoped></style>
```

## File: apps/main-app/components/content/org-chart.vue
```vue
  1: <template>
  2:   <div class="card overflow-x-auto">
  3:     <PrimeOrganizationChart
  4:       :value="data"
  5:       collapsible
  6:     >
  7:       <template #person="slotProps">
  8:         <div class="flex flex-col">
  9:           <div class="flex flex-col items-center">
 10:             <NuxtImg
 11:               :alt="slotProps.node.data.name"
 12:               :src="slotProps.node.data.image"
 13:               width="80"
 14:               height="80"
 15:               class="rounded-full"
 16:             />
 17:             <h4 class="pb-2 text-xl font-bold">
 18:               {{ slotProps.node.data.name }}
 19:             </h4>
 20:             <span>{{ slotProps.node.data.title }}</span>
 21:           </div>
 22:         </div>
 23:       </template>
 24:       <template #default="slotProps">
 25:         <span>{{ slotProps.node.label }}</span>
 26:       </template>
 27:     </PrimeOrganizationChart>
 28:   </div>
 29: </template>
 30: 
 31: <script setup lang="ts">
 32: const data = ref({
 33:   key: '0',
 34:   type: 'person',
 35:   styleClass: 'bg-indigo-900 text-white border-round-xl',
 36:   data: {
 37:     image: 'images/team/shweta-kulkarni.jpg',
 38:     name: 'Shweta Kulkarni',
 39:     title: 'CEO',
 40:   },
 41:   children: [
 42:     {
 43:       key: '0_0',
 44:       type: 'person',
 45:       styleClass: 'bg-teal-900 text-white border-round-xl',
 46:       data: {
 47:         image: 'images/team/drew-macgibbon.jpg',
 48:         name: 'Drew MacGibbon',
 49:         title: 'CTO',
 50:       },
 51:       children: [
 52:         {
 53:           label: 'DevOps Engineers',
 54:           styleClass: 'bg-teal-900 text-white border-round-xl',
 55:         },
 56:         {
 57:           label: 'Frontend Developers',
 58:           styleClass: 'bg-teal-900 text-white border-round-xl',
 59:         },
 60:         {
 61:           label: 'Backend Developers',
 62:           styleClass: 'bg-teal-900 text-white border-round-xl',
 63:         },
 64:         {
 65:           label: 'AI Specialists',
 66:           styleClass: 'bg-teal-900 text-white border-round-xl',
 67:         },
 68:         {
 69:           label: 'UI/UX Developers',
 70:           styleClass: 'bg-teal-900 text-white border-round-xl',
 71:         },
 72:         {
 73:           label: 'Data Processors / QA',
 74:           styleClass: 'bg-teal-900 text-white border-round-xl',
 75:         },
 76:       ],
 77:     },
 78:     {
 79:       key: '0_1',
 80:       type: 'person',
 81:       styleClass: 'bg-purple-900 text-white border-round-xl',
 82:       data: {
 83:         image: 'images/team/gunashri-vesikar.jpg',
 84:         name: 'Gunashri Vesikar',
 85:         title: 'CFO',
 86:       },
 87:       children: [
 88:         {
 89:           label: 'Accountants',
 90:           styleClass: 'bg-purple-900 text-white border-round-xl',
 91:         },
 92:       ],
 93:     },
 94:     {
 95:       key: '0_2',
 96:       type: 'person',
 97:       styleClass: 'bg-orange-900 text-white border-round-xl',
 98:       data: {
 99:         image: 'images/team/unknown.jpg',
100:         name: 'Unknown',
101:         title: 'COO',
102:       },
103:       children: [
104:         {
105:           label: 'Content Writers',
106:           styleClass: 'bg-orange-900 text-white border-round-xl',
107:         },
108:         {
109:           label: 'Social Media Managers',
110:           styleClass: 'bg-orange-900 text-white border-round-xl',
111:         },
112:         {
113:           label: 'Customer Support Agents',
114:           styleClass: 'bg-orange-900 text-white border-round-xl',
115:         },
116:         {
117:           label: 'Sales People',
118:           styleClass: 'bg-orange-900 text-white border-round-xl',
119:         },
120:       ],
121:     },
122:   ],
123: })
124: </script>
```

## File: apps/main-app/components/content/timeline.vue
```vue
  1: <template>
  2:   <div>
  3:     <h3 class="pb-8 text-center"> Timeline </h3>
  4:     <PrimeTimeline
  5:       :value="events"
  6:       align="alternate"
  7:       class="customized-timeline"
  8:     >
  9:       <template #marker="slotProps">
 10:         <span
 11:           class="z-10 flex items-center justify-center rounded-full border p-1 text-white"
 12:           :style="{ backgroundColor: slotProps.item.color }"
 13:         >
 14:           <Icon
 15:             :name="`mdi:${slotProps.item.icon}`"
 16:             size="32px"
 17:           />
 18:         </span>
 19:       </template>
 20:       <template #content="slotProps">
 21:         <div class="border-color background rounded-lg border p-4">
 22:           <h4 class="m-0 text-2xl">
 23:             {{ slotProps.item.status }}
 24:           </h4>
 25:           <p class="text-lg font-bold">
 26:             {{ slotProps.item.date }}
 27:           </p>
 28:           <p class="text-xl">
 29:             {{ slotProps.item.description }}
 30:           </p>
 31:         </div>
 32:       </template>
 33:     </PrimeTimeline>
 34:   </div>
 35: </template>
 36: 
 37: <script setup lang="ts">
 38: const events = ref([
 39:   // Year 1
 40:   {
 41:     status: 'AI Model Upgrades',
 42:     date: 'Q1 2024',
 43:     icon: 'chart-line',
 44:     color: '#9C27B0',
 45:     description:
 46:       'Continuously improve the accuracy and capabilities of our AI models by integrating advanced machine learning techniques and user feedback.',
 47:   },
 48:   {
 49:     status: 'Gamification and Loyalty Programs',
 50:     date: 'Q2 2024',
 51:     icon: 'star',
 52:     color: '#673AB7',
 53:     description:
 54:       'Introduce gamification elements and loyalty programs to enhance user engagement and incentivize frequent usage.',
 55:   },
 56:   {
 57:     status: 'Scalability Enhancements',
 58:     date: 'Q3 2024',
 59:     icon: 'cog',
 60:     color: '#FF9800',
 61:     description:
 62:       'Optimize our cloud infrastructure to handle increased traffic and ensure smooth performance.',
 63:   },
 64:   {
 65:     status: 'Educational Partnerships',
 66:     date: 'Q4 2024',
 67:     icon: 'account-group',
 68:     color: '#607D8B',
 69:     description:
 70:       'Partner with educational institutions to provide exclusive content and promote our platform among students.',
 71:   },
 72:   {
 73:     status: 'Progressive Web App (PWA)',
 74:     date: 'Q4 2024',
 75:     icon: 'cellphone-link',
 76:     color: '#FF5722',
 77:     description:
 78:       'Develop and launch a PWA to provide a seamless mobile experience without the need for native app development.',
 79:   },
 80:   {
 81:     status: 'Data Quality Improvements',
 82:     date: 'Q4 2024',
 83:     icon: 'database',
 84:     color: '#795548',
 85:     description:
 86:       'Focus on sourcing high-quality data, improving data processing, and cleaning mechanisms.',
 87:   },
 88: 
 89:   // Year 2
 90:   {
 91:     status: 'AI Personalization',
 92:     date: 'Q1 2025',
 93:     icon: 'account',
 94:     color: '#4CAF50',
 95:     description:
 96:       'Develop AI-driven personalization features to provide tailored content and recommendations.',
 97:   },
 98:   {
 99:     status: 'Advanced AI Agents',
100:     date: 'Q2 2025',
101:     icon: 'robot',
102:     color: '#FFC107',
103:     description:
104:       'Introduce more sophisticated AI agents capable of handling complex queries and providing in-depth analysis.',
105:   },
106:   {
107:     status: 'Consulting Services',
108:     date: 'Q3 2025',
109:     icon: 'briefcase',
110:     color: '#03A9F4',
111:     description:
112:       'Offer consulting services to businesses and educational institutions leveraging our AI and data insights.',
113:   },
114:   {
115:     status: 'Multilingual Support',
116:     date: 'Q4 2025',
117:     icon: 'translate',
118:     color: '#E91E63',
119:     description: 'Add support for multiple languages to cater to a global audience.',
120:   },
121:   {
122:     status: 'Mobile Application Development',
123:     date: 'Q4 2025',
124:     icon: 'cellphone',
125:     color: '#FF9800',
126:     description: 'Develop and launch a native mobile application.',
127:   },
128:   {
129:     status: 'Premium Content Expansion',
130:     date: 'Q1 2026',
131:     icon: 'book',
132:     color: '#9C27B0',
133:     description:
134:       'Expand premium content offerings, such as exclusive webinars, research reports, and advanced data insights.',
135:   },
136:   {
137:     status: 'International Partnerships',
138:     date: 'Q2 2026',
139:     icon: 'handshake',
140:     color: '#673AB7',
141:     description:
142:       'Form partnerships with international space agencies, educational institutions, and businesses to expand our reach.',
143:   },
144: 
145:   // Year 4
146:   {
147:     status: 'AR and VR Integration',
148:     date: 'Q1 2027',
149:     icon: 'vr',
150:     color: '#FF5722',
151:     description:
152:       'Integrate AR and VR technologies to provide immersive learning experiences and interactive content.',
153:   },
154:   {
155:     status: 'IoT Integration',
156:     date: 'Q2 2027',
157:     icon: 'cloud',
158:     color: '#795548',
159:     description:
160:       'Leverage Internet of Things (IoT) devices for real-time data collection and analysis.',
161:   },
162:   {
163:     status: 'User-Generated Content Platform',
164:     date: 'Q3 2027',
165:     icon: 'pencil',
166:     color: '#4CAF50',
167:     description: 'Develop a platform for users to create and share their content.',
168:   },
169: 
170:   // Year 5
171:   {
172:     status: 'Educational and Sustainability Initiatives',
173:     date: 'Q1 2028',
174:     icon: 'school',
175:     color: '#FFC107',
176:     description:
177:       'Launch initiatives aimed at promoting space education in underprivileged communities and sustainability projects.',
178:   },
179:   {
180:     status: 'Continuous Improvement Mechanisms',
181:     date: 'Q2 2028',
182:     icon: 'refresh',
183:     color: '#03A9F4',
184:     description:
185:       'Establish continuous feedback loops with users and utilize data analytics to improve our services.',
186:   },
187: ])
188: </script>
189: 
190: <style scoped>
191: @media (max-width: 960px) {
192:   .customized-timeline .p-timeline-event:nth-child(even) {
193:     flex-direction: row;
194:   }
195: 
196:   .customized-timeline .p-timeline-event:nth-child(even) .p-timeline-event-content {
197:     text-align: left;
198:   }
199: 
200:   .customized-timeline .p-timeline-event-opposite {
201:     flex: 0;
202:   }
203: }
204: </style>
```

## File: apps/main-app/components/dev/ApiDataViewer.vue
```vue
 1: <template>
 2:   <div v-if="showComponent">
 3:     <div
 4:       v-tooltip.left="'Page Data Structures'"
 5:       @click="showModal = true"
 6:     >
 7:       <Icon name="ic:baseline-data-object" />
 8:     </div>
 9:     <PrimeDialog
10:       v-model:visible="showModal"
11:       modal
12:       header="API Data Structures"
13:       class="w-11/12 max-w-6xl"
14:     >
15:       <PrimeAccordion
16:         :multiple="true"
17:         class="flex flex-col gap-2"
18:       >
19:         <!-- <PrimeAccordionPanel
20:           v-for="(structure, url, index) in apiDataStore.apiData"
21:           :key="url"
22:           :value="`${index}`"
23:         >
24:           <PrimeAccordionHeader
25:             :pt="{
26:               root: 'rounded-md border gap-2 border-color flex items-center foreground p-2',
27:             }"
28:           >
29:             <p>
30:               {{ url }}
31:             </p>
32:           </PrimeAccordionHeader>
33:           <PrimeAccordionContent>
34:             <pre class="foreground mt-2 max-h-96 overflow-auto rounded p-4">
35:               {{ JSON.stringify(structure, null, 2) }}
36:             </pre>
37:           </PrimeAccordionContent>
38:         </PrimeAccordionPanel> -->
39:       </PrimeAccordion>
40:     </PrimeDialog>
41:   </div>
42: </template>
43: 
44: <script setup lang="ts">
45: // const apiDataStore = useApiDataStore()
46: 
47: const showModal = ref(false)
48: 
49: const isAdmin = ref(true)
50: 
51: const showComponent = computed((): boolean => {
52:   return import.meta.dev || isAdmin.value
53: })
54: </script>
```

## File: apps/main-app/components/dev/CodePrevies.vue
```vue
 1: <template>
 2:   <div class="code-preview">
 3:     <h3>Code Preview</h3>
 4:     <pre><code>{{ generatedCode }}</code></pre>
 5:   </div>
 6: </template>
 7: 
 8: <script setup lang="ts">
 9: import { computed } from 'vue'
10: 
11: const props = defineProps<{
12:   component: { name: string, component: any }
13:   props: Record<string, any>
14:   state: Record<string, any>
15: }>()
16: 
17: const generatedCode = computed(
18:   () => `
19: <template>
20:   <${props.component.name}
21:     ${Object.entries(props.props)
22:         .map(([key, value]) => `:${key}="${JSON.stringify(value)}"`)
23:         .join('\n    ')}
24:   />
25: </template>
26: 
27: <script setup>
28: import { ref } from 'vue'
29: 
30: ${Object.entries(props.state)
31:     .map(([key, value]) => `const ${key} = ref(${JSON.stringify(value)})`)
32:     .join('\n')}
33: <\/script>`,
34: )
35: </script>
```

## File: apps/main-app/components/dev/ComponentList.vue
```vue
 1: <template>
 2:   <div class="component-list">
 3:     <h2>Components</h2>
 4:     <input
 5:       v-model="search"
 6:       placeholder="Search components..."
 7:     />
 8:     <ul>
 9:       <li
10:         v-for="componentName in filteredComponentNames"
11:         :key="componentName"
12:       >
13:         <PrimeButton
14:           size="small"
15:           @click="$emit('select', componentName)"
16:         >
17:           {{ componentName }}
18:         </PrimeButton>
19:       </li>
20:     </ul>
21:   </div>
22: </template>
23: 
24: <script setup lang="ts">
25: import { ref, computed } from 'vue'
26: 
27: const props = defineProps<{
28:   componentNames: string[]
29: }>()
30: 
31: const emit = defineEmits<{
32:   (e: 'select', componentName: string): void
33: }>()
34: 
35: const search = ref('')
36: 
37: const filteredComponentNames = computed(() =>
38:   props.componentNames.filter((name) => name.toLowerCase().includes(search.value.toLowerCase())),
39: )
40: </script>
```

## File: apps/main-app/components/dev/ComponentPlayground.vue
```vue
  1: <template>
  2:   <div class="component-playground">
  3:     <DevComponentList
  4:       :component-names="availableComponentNames"
  5:       @select="selectComponent"
  6:     />
  7:     <div class="main-area">
  8:       <DevPreviewArea
  9:         v-if="false"
 10:         :component="selectedComponentName.component"
 11:         :props="props"
 12:         :state="state"
 13:         @event="logEvent"
 14:       />
 15:       <DevPropsEditor
 16:         :props="props"
 17:         @update:props="updateProps"
 18:       />
 19:       <DevStateManager
 20:         v-if="hasState"
 21:         :state="state"
 22:         @update:state="updateState"
 23:       />
 24:       <DevEventLogger :events="events" />
 25:       <DevResponsiveTester @change="setViewportSize" />
 26:       <DevCodePreview
 27:         :component="selectedComponent"
 28:         :props="props"
 29:         :state="state"
 30:       />
 31:     </div>
 32:   </div>
 33: </template>
 34: 
 35: <script setup lang="ts">
 36: const availableComponentNames = ref<string[]>([])
 37: const selectedComponentName = ref<string | null>(null)
 38: const props = ref({})
 39: const state = ref({})
 40: const events = ref([])
 41: const hasState = computed(() => Object.keys(state.value).length > 0)
 42: 
 43: onMounted(async () => {
 44:   // Dynamically get all component names
 45:   const componentContext = import.meta.glob('~/components/**/*.vue')
 46:   availableComponentNames.value = Object.keys(componentContext).map((key) => {
 47:     return key.split('/').pop()?.replace('.vue', '') || ''
 48:   })
 49:   if (availableComponentNames.value.length > 0) {
 50:     selectComponent(availableComponentNames.value[0])
 51:   }
 52: })
 53: 
 54: const selectComponent = (component) => {
 55:   selectedComponentName.value = component
 56:   props.value = getDefaultProps(component)
 57:   state.value = getInitialState(component)
 58:   events.value = []
 59: }
 60: 
 61: const updateProps = (newProps) => {
 62:   props.value = newProps
 63: }
 64: 
 65: const updateState = (newState) => {
 66:   state.value = newState
 67: }
 68: 
 69: const logEvent = (event) => {
 70:   events.value.push({
 71:     name: event.name,
 72:     payload: event.payload,
 73:     timestamp: new Date(),
 74:   })
 75: }
 76: 
 77: const previewAreaSize = ref({ width: '100%', height: '300px' })
 78: 
 79: const setViewportSize = (size: 'mobile' | 'tablet' | 'desktop') => {
 80:   switch (size) {
 81:     case 'mobile':
 82:       previewAreaSize.value = { width: '375px', height: '667px' }
 83:       break
 84:     case 'tablet':
 85:       previewAreaSize.value = { width: '768px', height: '1024px' }
 86:       break
 87:     case 'desktop':
 88:     default:
 89:       previewAreaSize.value = { width: '100%', height: '600px' }
 90:       break
 91:   }
 92: }
 93: 
 94: const getDefaultProps = (component: any) => {
 95:   const defaultProps: Record<string, any> = {}
 96:   if (component.props) {
 97:     Object.entries(component.props).forEach(([key, value]: [string, any]) => {
 98:       if (value.default !== undefined) {
 99:         defaultProps[key] = typeof value.default === 'function' ? value.default() : value.default
100:       } else if (value.type) {
101:         // Provide sensible defaults based on prop type
102:         switch (value.type) {
103:           case String:
104:             defaultProps[key] = ''
105:             break
106:           case Number:
107:             defaultProps[key] = 0
108:             break
109:           case Boolean:
110:             defaultProps[key] = false
111:             break
112:           case Array:
113:             defaultProps[key] = []
114:             break
115:           case Object:
116:             defaultProps[key] = {}
117:             break
118:           // Add more types as needed
119:         }
120:       }
121:     })
122:   }
123:   return defaultProps
124: }
125: 
126: const getInitialState = (component: any) => {
127:   const initialState: Record<string, any> = {}
128:   if (component.setup) {
129:     // This is a basic approach and might not work for all components
130:     // A more robust solution would involve analyzing the setup function
131:     const setupResult = component.setup()
132:     Object.entries(setupResult).forEach(([key, value]: [string, any]) => {
133:       if (value.value !== undefined) {
134:         // Assume it's a ref
135:         initialState[key] = value.value
136:       } else if (typeof value === 'function') {
137:         // Assume it's a computed property or method, skip it
138:       } else {
139:         // Assume it's a plain value
140:         initialState[key] = value
141:       }
142:     })
143:   }
144:   return initialState
145: }
146: </script>
147: 
148: <style scoped>
149: .component-playground {
150:   display: flex;
151:   height: 100vh;
152: }
153: 
154: .main-area {
155:   flex-grow: 1;
156:   display: grid;
157:   grid-template-columns: 1fr 1fr;
158:   grid-template-rows: auto 1fr 1fr;
159:   gap: 1rem;
160:   padding: 1rem;
161: }
162: </style>
```

## File: apps/main-app/components/dev/EventLogger.vue
```vue
 1: <template>
 2:   <div class="event-logger">
 3:     <h3>Event Log</h3>
 4:     <ul>
 5:       <li
 6:         v-for="(event, index) in events"
 7:         :key="index"
 8:       >
 9:         <strong>{{ event.name }}</strong>
10:         <span>{{ formatTimestamp(event.timestamp) }}</span>
11:         <pre>{{ JSON.stringify(event.payload, null, 2) }}</pre>
12:       </li>
13:     </ul>
14:   </div>
15: </template>
16: 
17: <script setup lang="ts">
18: import { defineProps } from 'vue'
19: 
20: interface Event {
21:   name: string
22:   payload: any
23:   timestamp: Date
24: }
25: 
26: defineProps<{
27:   events: Event[]
28: }>()
29: 
30: const formatTimestamp = (timestamp: Date) => {
31:   return new Intl.DateTimeFormat('en-US', {
32:     hour: '2-digit',
33:     minute: '2-digit',
34:     second: '2-digit',
35:     fractionalSecondDigits: 3,
36:   }).format(timestamp)
37: }
38: </script>
39: 
40: <style scoped>
41: .event-logger {
42:   height: 300px;
43:   overflow-y: auto;
44:   border: 1px solid #ccc;
45:   border-radius: 4px;
46:   padding: 10px;
47: }
48: 
49: ul {
50:   list-style-type: none;
51:   padding: 0;
52: }
53: 
54: li {
55:   margin-bottom: 10px;
56:   border-bottom: 1px solid #eee;
57:   padding-bottom: 10px;
58: }
59: 
60: strong {
61:   color: #333;
62: }
63: 
64: span {
65:   color: #666;
66:   font-size: 0.8em;
67:   margin-left: 10px;
68: }
69: 
70: pre {
71:   background-color: #f5f5f5;
72:   padding: 5px;
73:   border-radius: 4px;
74:   font-size: 0.9em;
75:   overflow-x: auto;
76: }
77: </style>
```

## File: apps/main-app/components/dev/Helpers.vue
```vue
 1: <template>
 2:   <div class="space-y-4 p-4">
 3:     <PrimeButton
 4:       :pt="{ root: 'px-2 py-1 text-sm' }"
 5:       severity="danger"
 6:       @click="clearState"
 7:     >
 8:       Nuxt State
 9:     </PrimeButton>
10:     <PrimeButton
11:       :pt="{ root: 'px-2 py-1 text-sm' }"
12:       severity="danger"
13:       label="Nuxt Data"
14:       @click="clearData"
15:     />
16:     <PrimeButton
17:       :pt="{ root: 'px-2 py-1 text-sm' }"
18:       severity="danger"
19:       label="Ref Nuxt Data"
20:       @click="refreshData"
21:     />
22:     <PrimeButton
23:       :pt="{ root: 'px-2 py-1 text-sm' }"
24:       severity="danger"
25:       label="Reload App"
26:       @click="reloadApp"
27:     />
28:     <PrimeButton
29:       :pt="{ root: 'px-2 py-1 text-sm' }"
30:       severity="danger"
31:       label="Reset Pinia"
32:       @click="resetAllStores"
33:     />
34:   </div>
35: </template>
36: 
37: <script setup lang="ts">
38: import { ref } from 'vue'
39: import { getActivePinia } from 'pinia'
40: import type { Store, Pinia } from 'pinia'
41: import { clearNuxtState, clearNuxtData, refreshNuxtData, reloadNuxtApp } from '#app'
42: 
43: interface ExtendedPinia extends Pinia {
44:   _s: Map<string, Store>
45: }
46: 
47: const isRefreshing = ref(false)
48: 
49: const clearState = () => {
50:   clearNuxtState()
51: }
52: 
53: const clearData = () => {
54:   clearNuxtData()
55: }
56: 
57: const refreshData = async () => {
58:   isRefreshing.value = true
59:   try {
60:     await refreshNuxtData()
61:   } finally {
62:     isRefreshing.value = false
63:   }
64: }
65: 
66: const reloadApp = () => {
67:   reloadNuxtApp()
68: }
69: 
70: const resetPinia = (): Record<string | 'all', () => void> => {
71:   const pinia = getActivePinia() as ExtendedPinia
72: 
73:   if (!pinia) {
74:     throw new Error('There are no stores')
75:   }
76: 
77:   const resetStores: Record<string, () => void> = {}
78: 
79:   pinia._s.forEach((store, name) => {
80:     resetStores[name] = () => store.$reset()
81:   })
82: 
83:   resetStores.all = () => pinia._s.forEach((store) => store.$reset())
84:   return resetStores
85: }
86: 
87: const resetAllStores = () => {
88:   const stores = resetPinia()
89:   stores.all()
90: }
91: </script>
92: 
93: <style scoped></style>
```

## File: apps/main-app/components/dev/PreviewArea.vue
```vue
 1: <!-- PreviewArea.vue -->
 2: <template>
 3:   <div class="preview-area">
 4:     <component
 5:       :is="component"
 6:       v-bind="props"
 7:       v-on="eventHandlers"
 8:     />
 9:   </div>
10: </template>
11: 
12: <script setup lang="ts">
13: import { computed } from 'vue'
14: 
15: const props = defineProps<{
16:   component: any
17:   props: Record<string, any>
18:   state: Record<string, any>
19: }>()
20: 
21: const emit = defineEmits<{
22:   (e: 'event', eventName: string, eventData: any): void
23: }>()
24: 
25: const eventHandlers = computed(() => {
26:   return Object.keys(props.component.emits || {}).reduce(
27:     (acc, eventName) => {
28:       acc[eventName] = (eventData: any) => emit('event', eventName, eventData)
29:       return acc
30:     },
31:     {} as Record<string, (eventData: any) => void>,
32:   )
33: })
34: </script>
35: 
36: <style scoped>
37: .preview-area {
38:   padding: 20px;
39:   border: 1px solid #ccc;
40:   border-radius: 4px;
41:   overflow: auto;
42: }
43: </style>
```

## File: apps/main-app/components/dev/PropsEditor.vue
```vue
 1: <template>
 2:   <div class="props-editor">
 3:     <h3>Props</h3>
 4:     <div
 5:       v-for="(value, key) in props"
 6:       :key="key"
 7:     >
 8:       <label>{{ key }}</label>
 9:       <input
10:         :value="value"
11:         :type="getInputType(value)"
12:         @input="updateProp(key, $event.target.value)"
13:       />
14:     </div>
15:   </div>
16: </template>
17: 
18: <script setup lang="ts">
19: import { computed } from 'vue'
20: 
21: const props = defineProps<{
22:   props: Record<string, any>
23: }>()
24: 
25: const emit = defineEmits<{
26:   (e: 'update:props', props: Record<string, any>): void
27: }>()
28: 
29: const updateProp = (key: string, value: any) => {
30:   emit('update:props', { ...props.props, [key]: value })
31: }
32: 
33: const getInputType = (value: any) => {
34:   switch (typeof value) {
35:     case 'number':
36:       return 'number'
37:     case 'boolean':
38:       return 'checkbox'
39:     default:
40:       return 'text'
41:   }
42: }
43: </script>
```

## File: apps/main-app/components/dev/ResponsiveTester.vue
```vue
 1: <template>
 2:   <div class="responsive-tester">
 3:     <button @click="$emit('change', 'mobile')"> Mobile </button>
 4:     <button @click="$emit('change', 'tablet')"> Tablet </button>
 5:     <button @click="$emit('change', 'desktop')"> Desktop </button>
 6:   </div>
 7: </template>
 8: 
 9: <script setup lang="ts">
10: defineEmits<{
11:   (e: 'change', size: 'mobile' | 'tablet' | 'desktop'): void
12: }>()
13: </script>
14: 
15: <style scoped>
16: .responsive-tester {
17:   display: flex;
18:   gap: 10px;
19:   margin-bottom: 10px;
20: }
21: 
22: button {
23:   padding: 5px 10px;
24:   background-color: #f0f0f0;
25:   border: 1px solid #ccc;
26:   border-radius: 4px;
27:   cursor: pointer;
28: }
29: 
30: button:hover {
31:   background-color: #e0e0e0;
32: }
33: </style>
```

## File: apps/main-app/components/dev/Settings.vue
```vue
 1: <script setup lang="ts">
 2: import { ref, reactive } from 'vue'
 3: import { useRuntimeConfig } from '#app'
 4: 
 5: const config = useRuntimeConfig()
 6: const { $devHelper } = useNuxtApp()
 7: 
 8: const showControls = ref(false)
 9: const features = reactive({ ...config.public.devHelper.features })
10: 
11: const updateFeature = (feature: string) => {
12:   $devHelper.toggleFeature(feature, features[feature])
13: }
14: 
15: const formatFeatureName = (feature: string) => {
16:   return feature
17:     .split(/(?=[A-Z])/)
18:     .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
19:     .join(' ')
20: }
21: 
22: const closeControls = () => {
23:   showControls.value = false
24: }
25: </script>
26: 
27: <template>
28:   <div class="foreground rounded-lg shadow-lg">
29:     <div class="border-color border-b px-4 py-3">
30:       <h3 class="text-lg font-medium"> Error Logging Controls </h3>
31:     </div>
32:     <div class="px-4 py-3">
33:       <div class="space-y-3">
34:         <div
35:           v-for="(enabled, feature) in features"
36:           :key="feature"
37:           class="flex items-center"
38:         >
39:           <PrimeCheckbox
40:             :id="feature"
41:             v-model="features[feature]"
42:             :binary="true"
43:             class="mr-3"
44:             @change="updateFeature(feature)"
45:           />
46:           <label
47:             :for="feature"
48:             class="cursor-pointer text-sm"
49:             >{{ formatFeatureName(feature) }}</label
50:           >
51:         </div>
52:       </div>
53:     </div>
54:   </div>
55: </template>
```

## File: apps/main-app/components/dev/StateManager.vue
```vue
 1: <template>
 2:   <div class="state-manager">
 3:     <h3>State</h3>
 4:     <div
 5:       v-for="(value, key) in state"
 6:       :key="key"
 7:     >
 8:       <label>{{ key }}</label>
 9:       <input
10:         :value="value"
11:         @input="updateState(key, $event.target.value)"
12:       />
13:     </div>
14:   </div>
15: </template>
16: 
17: <script setup lang="ts">
18: const props = defineProps<{
19:   state: Record<string, any>
20: }>()
21: 
22: const emit = defineEmits<{
23:   (e: 'update:state', state: Record<string, any>): void
24: }>()
25: 
26: const updateState = (key: string, value: any) => {
27:   emit('update:state', { ...props.state, [key]: value })
28: }
29: </script>
```

## File: apps/main-app/components/folder/FolderForm.vue
```vue
  1: <template>
  2:   <form
  3:     class="flex flex-col gap-8"
  4:     @submit.prevent="handleSubmit"
  5:   >
  6:     <div>
  7:       <label class="block text-sm font-medium">Name</label>
  8:       <PrimeInputText
  9:         v-model="formData.name"
 10:         type="text"
 11:         class="mt-1 block w-full rounded-md"
 12:         required
 13:       />
 14:     </div>
 15: 
 16:     <div class="flex items-center gap-4">
 17:       <label class="block text-sm font-medium">Color</label>
 18:       <div class="mt-1 flex items-center gap-2">
 19:         <PrimeColorPicker v-model="formData.color" />
 20:         <span class="text-sm">{{ formData.color }}</span>
 21:       </div>
 22: 
 23:       <label class="flex items-center">
 24:         <PrimeCheckbox
 25:           v-model="formData.is_favorite"
 26:           :binary="true"
 27:         />
 28:         <span class="ml-2 text-sm">Add to favorites</span>
 29:       </label>
 30: 
 31:       <label class="flex items-center">
 32:         <PrimeCheckbox
 33:           v-model="formData.is_default"
 34:           :binary="true"
 35:         />
 36:         <span class="ml-2 text-sm">Set as default</span>
 37:       </label>
 38:     </div>
 39: 
 40:     <div class="flex justify-between">
 41:       <PrimeButton
 42:         v-if="folder"
 43:         type="button"
 44:         severity="danger"
 45:         @click="$emit('delete')"
 46:       >
 47:         Delete Folder
 48:       </PrimeButton>
 49:       <div
 50:         v-else
 51:         class="flex-grow"
 52:       />
 53: 
 54:       <div class="flex gap-2">
 55:         <PrimeButton
 56:           type="button"
 57:           severity="secondary"
 58:           @click="$emit('cancel')"
 59:         >
 60:           Cancel
 61:         </PrimeButton>
 62:         <PrimeButton type="submit">
 63:           {{ folder ? 'Save Changes' : 'Create Folder' }}
 64:         </PrimeButton>
 65:       </div>
 66:     </div>
 67:   </form>
 68: </template>
 69: 
 70: <script setup lang="ts">
 71: import type { Folder } from '~/types/folder'
 72: 
 73: const props = defineProps<{
 74:   folder?: Folder
 75: }>()
 76: 
 77: const emit = defineEmits<{
 78:   (e: 'submit', data: Partial<Folder>): void
 79:   (e: 'cancel'): void
 80:   (e: 'delete'): void
 81: }>()
 82: 
 83: const formData = ref(
 84:   props.folder
 85:     ? {
 86:         ...props.folder,
 87:         color: props.folder.color.startsWith('#') ? props.folder.color : `#${props.folder.color}`,
 88:       }
 89:     : {
 90:         name: '',
 91:         color: '#94A3B8',
 92:         is_favorite: false,
 93:         is_default: false,
 94:       },
 95: )
 96: 
 97: const handleSubmit = () => {
 98:   const color = formData.value.color.startsWith('#')
 99:     ? formData.value.color
100:     : `#${formData.value.color}`
101: 
102:   emit('submit', {
103:     name: formData.value.name,
104:     color,
105:     is_favorite: formData.value.is_favorite,
106:     is_default: formData.value.is_default,
107:   })
108: }
109: </script>
```

## File: apps/main-app/components/folder/FolderItem.vue
```vue
 1: <!-- FolderItem.vue -->
 2: <template>
 3:   <div
 4:     :class="[
 5:       'group flex items-center px-2 py-1.5 rounded-md cursor-pointer',
 6:       isSelected ? 'border' : 'hover:border-primary-950 border border-color foreground',
 7:     ]"
 8:     :style="{ paddingLeft: `${depth * 1.5 + 0.5}rem` }"
 9:   >
10:     <div class="flex-1 flex items-center min-w-0">
11:       <div
12:         class="w-2 h-2 rounded-full mr-2"
13:         :style="{ backgroundColor: folder.color }"
14:       />
15:       <Icon
16:         v-if="folder.is_favorite"
17:         name="mdi:star"
18:         class="w-4 h-4 text-yellow-400 mr-1"
19:       />
20:       <span class="truncate">{{ folder.name }}</span>
21:       <span
22:         v-if="folder.is_default"
23:         class="ml-2 px-1.5 py-0.5 text-xs rounded-full bg-primary-900"
24:       >
25:         Default
26:       </span>
27:     </div>
28: 
29:     <div class="flex items-center gap-1 opacity-0 group-hover:opacity-100">
30:       <button
31:         class="p-1"
32:         @click.stop="$emit('edit', folder)"
33:       >
34:         <Icon
35:           name="mdi:pencil"
36:           class="w-4 h-4"
37:         />
38:       </button>
39:       <button
40:         v-if="!folder.is_default"
41:         class="p-1 hover:text-red-600"
42:         @click.stop="$emit('delete', folder)"
43:       >
44:         <Icon
45:           name="mdi:trash"
46:           class="w-4 h-4"
47:         />
48:       </button>
49:     </div>
50:   </div>
51: 
52:   <div v-if="folder.children?.length">
53:     <FolderItem
54:       v-for="child in folder.children"
55:       :key="child.id"
56:       :folder="child"
57:       :depth="depth + 1"
58:       :selected-id="selectedId"
59:       @select="$emit('select', $event)"
60:       @edit="$emit('edit', $event)"
61:       @delete="$emit('delete', $event)"
62:     />
63:   </div>
64: </template>
65: 
66: <script setup lang="ts">
67: import type { Folder } from '../../types/bookmarks'
68: 
69: const props = defineProps<{
70:   folder: Folder
71:   depth?: number
72:   selectedId?: string
73: }>()
74: 
75: defineEmits<{
76:   (e: 'select' | 'edit' | 'delete', folder: Folder): void
77: }>()
78: 
79: const isSelected = computed(() => props.folder.id === props.selectedId)
80: </script>
```

## File: apps/main-app/components/folder/FolderTree.vue
```vue
  1: <!-- FolderTree.vue -->
  2: <script setup lang="ts">
  3: const { folders, flatFolders, getFavorites, createFolder } = useFolderSystem()
  4: const { checkFeatureLimit, getFeatureUsage, getUpgradeMessage } = usePlan()
  5: 
  6: const canCreateFolder = computed(() => {
  7:   return checkFeatureLimit('BOOKMARK_FOLDERS', folders.value.length)
  8: })
  9: 
 10: const folderUsage = computed(() => getFeatureUsage('BOOKMARK_FOLDERS', folders.value.length))
 11: 
 12: const showNewFolderModal = ref(false)
 13: const selectedFolderId = ref<string | null>(null)
 14: 
 15: const selectFolder = (folder: Folder) => {
 16:   selectedFolderId.value = folder.id
 17: }
 18: 
 19: const handleNewFolder = () => {
 20:   createNewFolder()
 21: }
 22: 
 23: const newFolder = ref({
 24:   name: '',
 25:   parent_id: null,
 26:   color: '#94A3B8',
 27:   is_favorite: false,
 28:   is_default: false,
 29: })
 30: 
 31: const createNewFolder = async () => {
 32:   await createFolder(newFolder.value)
 33:   showNewFolderModal.value = false
 34:   newFolder.value = {
 35:     name: '',
 36:     parent_id: null,
 37:     color: '#94A3B8',
 38:     is_favorite: false,
 39:     is_default: false,
 40:   }
 41: }
 42: </script>
 43: 
 44: <template>
 45:   <div class="space-y-2">
 46:     <div class="mt-4">
 47:       <button
 48:         v-if="canCreateFolder"
 49:         class="w-full flex items-center justify-center px-4 py-2 text-sm font-medium border border-color bg-primary-500 rounded-md"
 50:         @click="showNewFolderModal = true"
 51:       >
 52:         <Icon
 53:           name="mdi:plus"
 54:           class="w-4 h-4 mr-2"
 55:         />
 56:         New Folder
 57:         <span
 58:           v-if="!folderUsage.isUnlimited"
 59:           class="ml-1"
 60:         >
 61:           ({{ folderUsage.used }}/{{ folderUsage.limit }})
 62:         </span>
 63:       </button>
 64:       <div
 65:         v-else
 66:         class="text-sm p-3 rounded-md"
 67:       >
 68:         <p>You've reached the folder limit.</p>
 69:         <NuxtLink
 70:           to="/premium"
 71:           class="text-primary-600 hover:text-primary-700 font-medium"
 72:         >
 73:           {{ getUpgradeMessage('BOOKMARK_FOLDERS') }}
 74:         </NuxtLink>
 75:       </div>
 76:     </div>
 77: 
 78:     <div
 79:       v-if="getFavorites.length"
 80:       class="mb-4"
 81:     >
 82:       <h3 class="font-medium mb-2">Favorites</h3>
 83:       <div class="space-y-1">
 84:         <FolderItem
 85:           v-for="folder in getFavorites"
 86:           :key="folder.id"
 87:           :folder="folder"
 88:           @select="selectFolder"
 89:         />
 90:       </div>
 91:     </div>
 92: 
 93:     <!-- Folder Tree -->
 94:     <div class="space-y-1">
 95:       <FolderItem
 96:         v-for="folder in folders"
 97:         :key="folder.id"
 98:         :folder="folder"
 99:         @select="selectFolder"
100:       />
101:     </div>
102: 
103:     <!-- New Folder Dialog -->
104:     <PrimeDialog
105:       v-model:visible="showNewFolderModal"
106:       modal
107:       header="New Folder"
108:       :style="{ width: '90vw', maxWidth: '500px' }"
109:     >
110:       <!-- Main Content -->
111:       <span class="block mb-4">Create a new folder to organize your bookmarks.</span>
112: 
113:       <form
114:         class="space-y-4"
115:         @submit.prevent="handleNewFolder"
116:       >
117:         <div class="flex items-center gap-4 mb-4">
118:           <label
119:             for="folderName"
120:             class="font-semibold w-24"
121:             >Name</label
122:           >
123:           <PrimeInputText
124:             id="folderName"
125:             v-model="newFolder.name"
126:             class="flex-auto"
127:             required
128:             autofocus
129:           />
130:         </div>
131: 
132:         <div class="flex items-center gap-4 mb-4">
133:           <label
134:             for="parentFolder"
135:             class="font-semibold w-24"
136:             >Parent</label
137:           >
138:           <PrimeSelect
139:             id="parentFolder"
140:             v-model="newFolder.parent_id"
141:             :options="flatFolders"
142:             option-label="name"
143:             option-value="id"
144:             placeholder="Select a parent folder"
145:             class="flex-auto"
146:           />
147:         </div>
148: 
149:         <div class="flex items-center gap-4 mb-4">
150:           <label
151:             for="folderColor"
152:             class="font-semibold w-24"
153:             >Color</label
154:           >
155:           <div class="flex items-center gap-2 flex-auto">
156:             <input
157:               id="folderColor"
158:               v-model="newFolder.color"
159:               type="color"
160:               class="h-8 w-8 rounded cursor-pointer"
161:             />
162:             <span class="text-sm">{{ newFolder.color }}</span>
163:           </div>
164:         </div>
165: 
166:         <div class="flex items-center gap-4">
167:           <label class="flex items-center flex-1">
168:             <PrimeCheckbox
169:               v-model="newFolder.is_favorite"
170:               :binary="true"
171:             />
172:             <span class="ml-2">Add to favorites</span>
173:           </label>
174: 
175:           <label class="flex items-center flex-1">
176:             <PrimeCheckbox
177:               v-model="newFolder.is_default"
178:               :binary="true"
179:             />
180:             <span class="ml-2">Set as default</span>
181:           </label>
182:         </div>
183:       </form>
184: 
185:       <!-- Footer -->
186:       <template #footer>
187:         <PrimeButton
188:           label="Cancel"
189:           class="p-button-text"
190:           severity="secondary"
191:           @click="showNewFolderModal = false"
192:         />
193:         <PrimeButton
194:           label="Create"
195:           @click="handleNewFolder"
196:         />
197:       </template>
198:     </PrimeDialog>
199:   </div>
200: </template>
```

## File: apps/main-app/components/form/FormPassword.vue
```vue
 1: <script setup lang="ts">
 2: interface Props {
 3:   modelValue: string
 4:   id?: string
 5:   suggestions?: string[]
 6:   invalid?: boolean
 7:   placeholder?: string
 8:   disabled?: boolean
 9:   required?: boolean
10:   inputClass?: string
11:   label?: string
12:   mediumRegex?: string
13:   strongRegex?: string
14:   feedback?: boolean
15: }
16: 
17: const props = withDefaults(defineProps<Props>(), {
18:   label: undefined,
19:   id: 'password',
20:   suggestions: () => [
21:     'At least one lowercase',
22:     'At least one uppercase',
23:     'At least one numeric',
24:     'Minimum 6 characters',
25:   ],
26:   invalid: false,
27:   feedback: true,
28:   placeholder: undefined,
29:   disabled: false,
30:   required: false,
31:   inputClass: 'w-full',
32:   mediumRegex:
33:     '^(((?=.*[a-z])(?=.*[A-Z]))|((?=.*[a-z])(?=.*[0-9]))|((?=.*[A-Z])(?=.*[0-9])))(?=.{6,})',
34:   strongRegex: '^(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9])(?=.{8,})',
35: })
36: 
37: const emit = defineEmits<{
38:   (e: 'update:modelValue', value: string): void
39: }>()
40: 
41: const onPasswordChange = (value: string) => {
42:   emit('update:modelValue', value)
43: }
44: </script>
45: 
46: <template>
47:   <label
48:     v-if="label"
49:     :for="id"
50:     >{{ label }}</label
51:   >
52:   <PrimePassword
53:     :id="id"
54:     class="w-full"
55:     :input-class="inputClass"
56:     :feedback="props.feedback"
57:     :model-value="modelValue"
58:     :invalid="invalid"
59:     :disabled="disabled"
60:     :required="required"
61:     :placeholder="placeholder"
62:     :label="props.label"
63:     @update:model-value="onPasswordChange"
64:   >
65:     <template #footer>
66:       <PrimeDivider />
67:       <p class="mt-2"> Suggestions </p>
68:       <ul
69:         class="ml-2 mt-0 pl-2"
70:         style="line-height: 1.5"
71:       >
72:         <li
73:           v-for="suggestion in props.suggestions"
74:           :key="suggestion"
75:         >
76:           {{ suggestion }}
77:         </li>
78:       </ul>
79:     </template>
80:   </PrimePassword>
81: </template>
82: 
83: <style scoped></style>
```

## File: apps/main-app/components/nav/NavAppTop.vue
```vue
  1: <script setup lang="ts">
  2: const router = useRouter()
  3: const userStore = useCurrentUser()
  4: const toast = useNotification()
  5: const supabase = useSupabaseClient()
  6: const { profile, isAdmin } = storeToRefs(userStore)
  7: const { aeAdminUrl, aeLoginUrl, aeAuthUrl } = useRuntimeConfig().public
  8: 
  9: const profileMenu = ref(null)
 10: const toggleMenu = (e) => {
 11:   profileMenu.value?.toggle(e)
 12: }
 13: 
 14: const items = computed(() => {
 15:   const menuItems = [
 16:     {
 17:       label: 'Settings',
 18:       command: () => router.push('/profile/settings/profile'),
 19:     },
 20:     {
 21:       label: 'Logout',
 22:       command: signOut,
 23:     },
 24:   ]
 25: 
 26:   if (isAdmin.value) {
 27:     menuItems.splice(2, 0, {
 28:       label: 'Admin',
 29:       command: () => navigateTo(aeAdminUrl, { external: true }),
 30:     })
 31:   }
 32: 
 33:   return menuItems
 34: })
 35: 
 36: const signOut = async () => {
 37:   const { error } = await supabase.auth.signOut()
 38: 
 39:   if (error) {
 40:     console.error(error.message)
 41:     toast.error({ summary: 'Could not log out', message: error.message })
 42:   } else {
 43:     return navigateTo(String(`${aeAuthUrl}${aeLoginUrl}`), { external: true })
 44:   }
 45: }
 46: 
 47: const loading = useLoadingStore()
 48: const isLoading = computed(() => loading.isLoading('currentUser'))
 49: 
 50: const avatarUrl = ref(null)
 51: 
 52: watch(
 53:   profile,
 54:   (newProfile) => {
 55:     avatarUrl.value = newProfile?.avatar || '/defaults/avatar.jpg'
 56:   },
 57:   { immediate: true },
 58: )
 59: 
 60: const logError = (error) => {
 61:   console.log('Error loading image, default image rendered', error)
 62: }
 63: 
 64: // !todo: show a back button on tablet and below, left of nav.
 65: // !todo: add styling to profileMenu nav to make it full screen on tablet and below
 66: </script>
 67: 
 68: <template>
 69:   <div
 70:     class="foreground border-color sticky left-0 top-0 z-50 flex min-h-[60px] w-full flex-row items-center justify-between gap-4 border-b px-4 py-1"
 71:   >
 72:     <!-- start -->
 73:     <div class="flex items-center gap-4">
 74:       <IBNavHamburger />
 75:       <IBBreadcrumbs class="hidden text-sm lg:block" />
 76:     </div>
 77:     <!-- center -->
 78:     <div class="flex w-full max-w-[70%] gap-4 px-4 py-2 lg:max-w-xl" />
 79:     <!-- end -->
 80:     <ClientOnly>
 81:       <div
 82:         v-if="isLoading || !profile?.user_role"
 83:         class="flex items-center justify-end gap-4"
 84:       >
 85:         <PrimeSkeleton class="min-h-4 min-w-10 rounded-md" />
 86:         <PrimeSkeleton
 87:           :pt="{
 88:             root: 'min-w-10 min-h-10 rounded-full',
 89:           }"
 90:         />
 91:       </div>
 92:       <div
 93:         v-else-if="profile?.user_role"
 94:         class="flex items-center justify-center gap-4"
 95:       >
 96:         <!-- <AppThemeToggle v-slot="{ toggle, isDark }">
 97:           <Icon
 98:             :name="isDark ? 'heroicons:sun' : 'heroicons:moon'"
 99:             class="cursor-pointer"
100:                       size="24px"
101: 
102:             @click="toggle"
103:           />
104:         </AppThemeToggle> -->
105:         <PrimeTag v-if="profile.user_role">
106:           {{ profile.user_role }}
107:         </PrimeTag>
108:         <PrimeAvatar
109:           v-if="avatarUrl"
110:           :image="avatarUrl"
111:           size="normal"
112:           shape="circle"
113:           class="cursor-pointer"
114:           aria-haspopup="true"
115:           aria-controls="overlay_menu"
116:           crossorigin="anonymous"
117:           @error="logError"
118:           @click="toggleMenu"
119:         />
120:         <PrimeMenu
121:           id="overlay_menu"
122:           ref="profileMenu"
123:           :model="items"
124:           :popup="true"
125:         />
126:       </div>
127:     </ClientOnly>
128:   </div>
129: </template>
```

## File: apps/main-app/components/nav/NavMobiBottom.vue
```vue
 1: // components/nav/NavMobiBottom.vue
 2: <script setup lang="ts">
 3: const { appLinks } = usePages()
 4: 
 5: // Function to get main navigation items from categories
 6: const mainNavItems = computed(() => {
 7:   // For mobile, we'll show:
 8:   // 1. Home from 'main' category
 9:   // 2. Feed from 'news' category
10:   // 3. Profile links
11:   const items = []
12: 
13:   // Get home from main
14:   const mainCategory = appLinks.value.find((cat) => cat.id === 'main')
15:   if (mainCategory?.items?.[0]) {
16:     items.push(mainCategory.items[0])
17:   }
18: 
19:   // Get feed from news
20:   const newsCategory = appLinks.value.find((cat) => cat.id === 'news')
21:   if (newsCategory?.items?.[0]) {
22:     items.push(newsCategory.items[0])
23:   }
24: 
25:   // Get profile section
26:   const profileCategory = appLinks.value.find((cat) => cat.id === 'profile')
27:   if (profileCategory?.items?.[0]) {
28:     // Add first profile item (or you can create a specific profile route)
29:     items.push({
30:       id: profileCategory.items[0].id,
31:       label: 'Profile',
32:       slug: '/profile',
33:       icon: 'mdi:account-circle-outline',
34:     })
35:   }
36: 
37:   return items
38: })
39: 
40: // Active route handling
41: const route = useRoute()
42: const isActive = (slug: string) => {
43:   if (slug === '/') {
44:     return route.path === '/'
45:   }
46:   return route.path.startsWith(slug)
47: }
48: </script>
49: 
50: <template>
51:   <div
52:     class="fixed bottom-0 left-0 flex-row w-full items-center justify-between foreground p-2 h-[var(--mobi-bottom-nav-height)] border-t border-color"
53:   >
54:     <ul class="flex flex-row items-center justify-center w-full h-full">
55:       <li
56:         v-for="item in mainNavItems"
57:         :key="item.id"
58:         class="flex items-center justify-center w-full h-full cursor-pointer"
59:       >
60:         <NuxtLink
61:           :to="item.slug"
62:           class="flex flex-col justify-center items-center gap-1 px-2"
63:           :class="{ 'text-primary-500': isActive(item.slug) }"
64:         >
65:           <ClientOnly>
66:             <Icon
67:               :name="item.icon"
68:               size="24px"
69:             />
70:             <span class="text-xs">{{ item.label }}</span>
71:           </ClientOnly>
72:         </NuxtLink>
73:       </li>
74:     </ul>
75:   </div>
76: </template>
77: 
78: <style scoped>
79: .router-link-active {
80:   @apply text-primary-500;
81: }
82: 
83: /* Optional: Add transition for active state */
84: .router-link-active .icon {
85:   @apply transform scale-110 transition-transform;
86: }
87: </style>
```

## File: apps/main-app/components/nav/NavMobiSlideover.vue
```vue
 1: <template>
 2:   <div>
 3:     <PrimeButton
 4:       variant="link"
 5:       :padded="false"
 6:       @click="isOpen = true"
 7:     >
 8:       <Icon
 9:         name="mdi:menu"
10:         class="text-white"
11:         size="24px"
12:       />
13:     </PrimeButton>
14:     <PrimeDrawer v-model:visible="isOpen">
15:       <div class="border-color border-r">
16:         <div class="foreground flex w-full items-center justify-between p-8">
17:           <NuxtLink
18:             class="flex items-center gap-4"
19:             to="/"
20:             @click="isOpen = false"
21:           >
22:             <div class="flex aspect-square rounded-full bg-white p-2">
23:               <IBImage
24:                 :img="{
25:                   src: '/astronera-logo.jpg',
26:                   alt: 'Astron Era Logo',
27:                 }"
28:                 class="h-8 w-8 md:h-12 md:w-12"
29:               />
30:             </div>
31:             <h3 class="text-xl"> AstronEra </h3>
32:           </NuxtLink>
33:           <PrimeButton
34:             variant="solid"
35:             icon="mdi:chevron-left"
36:             @click="isOpen = false"
37:           >
38:             Return
39:           </PrimeButton>
40:         </div>
41:         <div v-show="links">
42:           <NuxtLink
43:             v-for="link in links"
44:             :key="link.id"
45:             :to="link.slug"
46:             class="border-color flex w-full items-center justify-end border-b px-8 py-3 text-sm font-medium"
47:             @click="isOpen = false"
48:           >
49:             {{ link.name }}
50:             <Icon
51:               :name="getIcon(link.name)"
52:               class="ml-2"
53:               size="24px"
54:             />
55:           </NuxtLink>
56:         </div>
57:       </div>
58:     </PrimeDrawer>
59:   </div>
60: </template>
61: 
62: <script setup lang="ts">
63: const isOpen = ref(false)
64: 
65: const getIcon = (val: string) => {
66:   if (val === 'Contact') return 'material-symbols:info'
67:   if (val === 'About') return 'material-symbols:call'
68:   if (val === 'Preview') return 'material-symbols:globe-asia'
69:   if (val === 'Team') return 'material-symbols:emoji-people'
70:   if (val === 'Blog') return 'material-symbols:article'
71:   if (val === 'Community') return 'material-symbols:groups-rounded'
72:   if (val === 'Conference') return 'mdi:presentation'
73: }
74: 
75: defineProps({
76:   links: {
77:     type: Array as PropType<object[]>,
78:     required: true,
79:   },
80: })
81: </script>
82: 
83: <style scoped></style>
```

## File: apps/main-app/components/news/NewsCard.vue
```vue
  1: <script setup lang="ts">
  2: import { useTimeAgo } from '@vueuse/core'
  3: import { ref, onMounted } from 'vue'
  4: 
  5: export interface NewsCardT {
  6:   id: string
  7:   title: string
  8:   description: string
  9:   authorName: string
 10:   published_at?: string
 11:   featured_image: string
 12:   created_at: string
 13:   url: string
 14:   comments: number
 15:   score?: number
 16: }
 17: 
 18: interface Props {
 19:   news: NewsCardT
 20: }
 21: 
 22: const props = defineProps<Props>()
 23: const voteStore = useVoteStore()
 24: 
 25: const { isNewsBookmarked, toggleBookmark } = useBookmarks()
 26: 
 27: const showModal = ref(false)
 28: const modalContent = ref('')
 29: const currentVote = ref<number | null>(null)
 30: const score = ref(props.news.score || 0)
 31: const bookmarked = computed(() => isNewsBookmarked.value(props.news.id))
 32: 
 33: const handleBookmark = async () => {
 34:   try {
 35:     await toggleBookmark({
 36:       id: props.news.id,
 37:       type: 'news',
 38:       title: props.news.title,
 39:       thumbnail: props.news.featured_image,
 40:       url: props.news.url,
 41:     })
 42:   } catch (error) {
 43:     console.error('Error handling bookmark:', error)
 44:   }
 45: }
 46: 
 47: const displayScore = computed(() => {
 48:   const currentScore = voteStore.getScore(props.news.id) ?? score.value
 49: 
 50:   // Only show negative numbers if user has downvoted
 51:   if (currentScore < 0 && currentVote.value !== -1) {
 52:     return 0
 53:   }
 54:   return currentScore
 55: })
 56: 
 57: const readTime = computed(() => {
 58:   // Calculate read time based on content length
 59:   // This is a placeholder, replace with actual logic
 60:   return '2m read time'
 61: })
 62: 
 63: onMounted(async () => {
 64:   try {
 65:     if (voteStore.getScore(props.news.id) == null)
 66:       voteStore.setVotes(props.news.id, props.news.score || 0)
 67:   } catch (error) {
 68:     console.error('Error fetching vote status:', error)
 69:   }
 70: })
 71: 
 72: const handleVoteChange = ({ change }: { voteType: number | null; change: number }) => {
 73:   score.value += change
 74: }
 75: 
 76: const openModal = (feature: string) => {
 77:   modalContent.value = `The ${feature} feature is coming soon! Stay tuned for updates.`
 78:   showModal.value = true
 79: }
 80: </script>
 81: 
 82: <template>
 83:   <div class="rounded-lg relative border border-color">
 84:     <div class="p-4 flex flex-col justify-between h-full">
 85:       <div>
 86:         <div class="flex items-center gap-2 mb-2">
 87:           <NuxtImg
 88:             :src="`https://picsum.photos/24/24?random=${news.id}`"
 89:             alt="Author"
 90:             class="w-6 h-6 rounded-full"
 91:             width="24"
 92:             height="24"
 93:           />
 94:           <span class="text-sm">{{ news.authorName }}</span>
 95:         </div>
 96:         <h2 class="text-xl font-bold mb-2">{{ news.title }}</h2>
 97:         <div class="flex items-center text-sm mb-4">
 98:           <span>{{ useTimeAgo(news.published_at ?? news.created_at).value }}</span>
 99:           <span class="mx-2">•</span>
100:           <span>{{ readTime }}</span>
101:         </div>
102:       </div>
103:       <div>
104:         <div class="mb-4">
105:           <NuxtImg
106:             :provider="!!news.featured_image && 'supabase'"
107:             :src="news.featured_image || 'fallback-news.jpg'"
108:             :alt="news.title"
109:             class="w-full h-auto rounded-lg"
110:             width="400"
111:             height="200"
112:           />
113:         </div>
114:         <div class="flex items-center justify-between">
115:           <div class="flex items-center gap-4">
116:             <div class="flex items-center justify-center bg-primary-950 py-1 px-2 rounded-xl">
117:               <VoteButton
118:                 :content-id="news.id"
119:                 direction="up"
120:                 :initial-vote-type="currentVote"
121:                 @vote-change="handleVoteChange"
122:               />
123:               <span class="text-sm font-medium pl-1 pr-2">{{ displayScore }}</span>
124:               <VoteButton
125:                 :content-id="news.id"
126:                 direction="down"
127:                 :initial-vote-type="currentVote"
128:                 @vote-change="handleVoteChange"
129:               />
130:             </div>
131:             <button
132:               class="flex items-center gap-2 text-sm hover:text-gray-600"
133:               @click="openModal('Comments')"
134:             >
135:               <Icon
136:                 name="mdi:comment-outline"
137:                 size="20px"
138:               />
139:               <span>{{ news.comments }}</span>
140:             </button>
141:           </div>
142:           <div class="flex items-center gap-4">
143:             <button
144:               class="hover:text-gray-600"
145:               @click="handleBookmark"
146:             >
147:               <Icon
148:                 :name="bookmarked ? 'mdi:bookmark' : 'mdi:bookmark-outline'"
149:                 size="20px"
150:                 :class="{ 'text-primary-500': bookmarked }"
151:               />
152:             </button>
153:             <NuxtLink
154:               :to="news.url"
155:               target="_blank"
156:               rel="noopener noreferrer nofollow"
157:               class="hover:text-gray-600"
158:             >
159:               <Icon
160:                 name="mdi:link-variant"
161:                 size="20px"
162:               />
163:             </NuxtLink>
164:           </div>
165:         </div>
166:       </div>
167:     </div>
168:   </div>
169: 
170:   <PrimeDialog
171:     v-model:visible="showModal"
172:     modal
173:     header="Coming Soon"
174:     :style="{ width: '50vw' }"
175:   >
176:     <p>{{ modalContent }}</p>
177:   </PrimeDialog>
178: </template>
```

## File: apps/main-app/components/news/NewsCardSkeleton.vue
```vue
 1: <template>
 2:   <div class="border-b border-color">
 3:     <div class="p-6 flex gap-4">
 4:       <PrimeSkeleton
 5:         :pt="{
 6:           root: 'max-w-16 min-h-16 rounded-full',
 7:         }"
 8:       />
 9:     </div>
10:     <div class="overflow-hidden w-full">
11:       <PrimeSkeleton class="w-full min-h-[220px] rounded-md" />
12:     </div>
13:     <div class="flex flex-col gap-4 p-4">
14:       <PrimeSkeleton class="w-32 h-4 rounded-md" />
15:       <PrimeSkeleton class="max-w-64 h-4 rounded-md" />
16:       <PrimeSkeleton class="max-w-32 h-4 rounded-md" />
17:       <div class="w-full flex justify-end p-2">
18:         <PrimeSkeleton class="max-w-32 min-h-12 rounded-md" />
19:       </div>
20:     </div>
21:   </div>
22: </template>
23: 
24: <script setup lang="ts"></script>
25: 
26: <style scoped></style>
```

## File: apps/main-app/components/news/NewsModal.vue
```vue
  1: <template>
  2:   <div class="foreground relative h-full w-full">
  3:     <div
  4:       class="background sticky left-0 top-0 z-20 flex h-auto w-full items-center justify-between px-4 py-2"
  5:     >
  6:       <h3 class="lg:text-lg text-sm font-semibold">
  7:         {{ posts[currentIndex].title }}
  8:       </h3>
  9:       <div class="flex items-center gap-2">
 10:         <PrimeButton
 11:           to="https://tailwindcss.com/docs/content"
 12:           target="_blank"
 13:           icon="material-symbols:chrome-reader-mode-rounded"
 14:           class="flex items-center justify-end lg:after:content-['Full_Article']"
 15:         />
 16:         <PrimeButton
 17:           icon="mdi:close"
 18:           variant="link"
 19:           @click="$emit('closeNewsModal')"
 20:         />
 21:       </div>
 22:     </div>
 23:     <div class="grid h-full w-full grid-cols-1 gap-4 overflow-scroll py-4 xl:grid-cols-4">
 24:       <div class="grid grid-cols-2 gap-4 xl:col-start-4">
 25:         <NewsNavigationButton
 26:           :condition="nextIndex <= posts.length - 1"
 27:           :is-prev="true"
 28:           :post="posts[nextIndex]"
 29:           :handle-click="nextPost"
 30:         />
 31:         <NewsNavigationButton
 32:           :condition="previousIndex >= 0"
 33:           :post="posts[previousIndex]"
 34:           :handle-click="previousPost"
 35:         />
 36:       </div>
 37:       <div
 38:         v-if="posts[currentIndex].media"
 39:         class="col-start-1 lg:mt-0 xl:col-span-3 xl:row-span-2 xl:row-start-1"
 40:       >
 41:         <LazyImageCarousel
 42:           :media="posts[currentIndex].media"
 43:           class="w-full"
 44:         />
 45:       </div>
 46:       <div
 47:         v-else
 48:         class="col-start-1 overflow-hidden xl:col-span-3 xl:row-span-2 xl:row-start-1"
 49:       >
 50:         <IBImageWithFallback
 51:           :image="undefined"
 52:           :options="{ width: 100, height: 60, quality: 50, sizes: undefined }"
 53:         />
 54:       </div>
 55:       <div class="flex flex-col gap-4">
 56:         <ul class="space-y-2 px-4 pb-8">
 57:           <li
 58:             v-for="sum in posts[currentIndex].summary[summaryLevel]"
 59:             :key="sum"
 60:             class="flex items-start gap-2"
 61:           >
 62:             <Icon
 63:               name="mdi:star"
 64:               class="mt-[3px] flex-shrink-0 text-yellow-500"
 65:               size="18px"
 66:             />
 67:             <p class="flex-grow text-sm leading-snug">
 68:               {{ sum }}
 69:             </p>
 70:           </li>
 71:         </ul>
 72:       </div>
 73:     </div>
 74:   </div>
 75: </template>
 76: 
 77: <script setup lang="ts">
 78: import type { NewsCardT } from '@/types/news'
 79: 
 80: defineProps({
 81:   posts: {
 82:     type: Array as () => NewsCardT[],
 83:     required: true,
 84:   },
 85:   currentIndex: {
 86:     type: Number,
 87:     required: true,
 88:   },
 89:   summaryLevel: {
 90:     type: String,
 91:     required: true,
 92:   },
 93:   nextIndex: {
 94:     type: Number,
 95:     required: true,
 96:   },
 97:   previousIndex: {
 98:     type: Number,
 99:     required: true,
100:   },
101:   nextPost: {
102:     type: Function,
103:     required: true,
104:   },
105:   previousPost: {
106:     type: Function,
107:     required: true,
108:   },
109: })
110: </script>
```

## File: apps/main-app/components/news/NewsNavigationButton.vue
```vue
 1: <template>
 2:   <PrimeButton
 3:     v-if="condition"
 4:     class="background flex items-center justify-center rounded-md hover:text-primary-500"
 5:     variant="none"
 6:     :padded="false"
 7:     @click="handleClick"
 8:   >
 9:     <div
10:       class="flex items-center justify-center gap-2 p-2 text-sm font-normal"
11:       :class="isPrev ? 'flex-row text-right' : 'flex-row-reverse text-left'"
12:     >
13:       <Icon
14:         :name="isPrev ? 'mdi:chevron-left' : 'mdi:chevron-right'"
15:         class="flex-shrink-0"
16:         size="24px"
17:       />
18:       {{ post.title.substring(0, 54) }}...
19:     </div>
20:   </PrimeButton>
21: </template>
22: 
23: <script setup lang="ts">
24: import type { NewsCardT } from '@/types/news'
25: 
26: defineProps({
27:   condition: {
28:     type: Boolean,
29:     required: true,
30:   },
31:   isPrev: {
32:     type: Boolean,
33:     default: false,
34:   },
35:   post: {
36:     type: Object as () => NewsCardT,
37:     required: true,
38:   },
39:   handleClick: {
40:     type: Function,
41:     required: true,
42:   },
43: })
44: </script>
```

## File: apps/main-app/components/news/NewsSummaryLevel.vue
```vue
 1: <script setup lang="ts">
 2: const summaryLevels = [
 3:   [
 4:     {
 5:       label: 'Beginner',
 6:       value: 'beginner',
 7:       click: () => news.changeSummaryLevel('beginner'),
 8:     },
 9:   ],
10:   [
11:     {
12:       label: 'Intermediate',
13:       value: 'intermediate',
14:       click: () => news.changeSummaryLevel('intermediate'),
15:     },
16:   ],
17:   [
18:     {
19:       label: 'Expert',
20:       value: 'expert',
21:       click: () => news.changeSummaryLevel('expert'),
22:     },
23:   ],
24: ]
25: 
26: const selectedLevel = ref('beginner')
27: </script>
28: 
29: <template>
30:   <div class="flex w-full gap-2">
31:     <PrimeButton @click="news.scrapeBlogs"> Scrape Blogs </PrimeButton>
32:     <PrimeButton @click="storeImage"> Store Image </PrimeButton>
33:     <PrimeButton @click="news.getBlogs"> Get Blogs </PrimeButton>
34:     <div class="mb-4 flex w-full justify-end gap-2">
35:       <PrimeSelect
36:         v-model="selectedLevel"
37:         :options="summaryLevels"
38:         option-label="label"
39:         placeholder="Choose Summary Level"
40:         checkmark
41:         :highlight-on-select="false"
42:         mode="hover"
43:         :popper="{ placement: 'bottom-start' }"
44:       >
45:         <PrimeButton
46:           color="white"
47:           :label="news.summaryLevel"
48:           trailing-icon="heroicons:chevron-down-20-solid"
49:         />
50:       </PrimeSelect>
51:     </div>
52:   </div>
53: </template>
```

## File: apps/main-app/components/newsletter/NewsletterBasic.vue
```vue
 1: <template>
 2:   <div class="flex justify-center w-full pb-4 mt-10 lg:w-1/2 lg:mt-0 lg:justify-end lg:pb-0">
 3:     <div class="w-10/12 lg:w-1/2">
 4:       <h1 class="mb-6 text-lg font-semibold tracking-wide text-center text-white lg:text-left">
 5:         Subscribe to our Newsletter
 6:       </h1>
 7:       <div class="flex justify-center">
 8:         <div class="relative flex items-center justify-center w-full rounded-2xl">
 9:           <input
10:             id="email"
11:             type="email"
12:             required="true"
13:             placeholder="Your Email"
14:             aria-label="email"
15:             class="w-full h-12 pl-4 text-xs text-gray-700 placeholder-gray-600 bg-transparent rounded-lg lg:h-16 sm:text-base focus:outline-none"
16:           />
17:           <button
18:             type="submit"
19:             class="absolute inset-y-0 right-0 h-full px-2 py-2 text-xs font-medium transition duration-150 ease-in-out border-l border-gray-300 rounded focus:outline-none lg:text-base text-primary-700 sm:px-6 lg:py-4"
20:           >
21:             Subscribe
22:           </button>
23:         </div>
24:       </div>
25:     </div>
26:   </div>
27: </template>
```

## File: apps/main-app/components/notification/Notification.vue
```vue
 1: <script setup lang="ts">
 2: const getIconName = (severity: string) => {
 3:   switch (severity) {
 4:     case 'success':
 5:       return 'mdi:check-circle'
 6:     case 'error':
 7:       return 'mdi:close-circle'
 8:     case 'info':
 9:       return 'mdi:information'
10:     case 'warn':
11:       return 'mdi:alert-circle'
12:     default:
13:       return 'mdi:information'
14:   }
15: }
16: 
17: // :pt="{
18: //       content: 'border border-color rounded-md shadow-md flex'
19: //     }"
20: </script>
21: 
22: <template>
23:   <PrimeToast
24:     position="bottom-right"
25:     group="cta"
26:   >
27:     <template #container="{ message, closeCallback }">
28:       <section class="flex w-full items-start justify-start gap-3 rounded-md p-3 shadow-md">
29:         <Icon :name="getIconName(message.severity)" />
30:         <div class="flex w-full flex-col items-start justify-start gap-2">
31:           <p class="m-0 text-base font-semibold">
32:             {{ message.summary }}
33:           </p>
34:           <p class="m-0 text-base">
35:             {{ message.detail }}
36:           </p>
37:           <div class="mt-2">
38:             <p class="text-lg foreground rounded-md px-3 py-1 font-bold text-white">
39:               Premium Plan Coming Soon!
40:             </p>
41:             <!-- <NuxtLink :to="message.link">
42:                 <PrimeButton>{{ message.buttonText }}</PrimeButton>
43:               </NuxtLink> -->
44:           </div>
45:         </div>
46:         <PrimeButton
47:           severity="contrast"
48:           @click="closeCallback"
49:         >
50:           <Icon name="mdi:close" />
51:         </PrimeButton>
52:       </section>
53:     </template>
54:   </PrimeToast>
55: </template>
56: 
57: <style scoped></style>
```

## File: apps/main-app/components/onboarding/Account.vue
```vue
 1: <template>
 2:   <form @submit.prevent="handleSubmit">
 3:     <div class="p-fluid" />
 4:     <div class="mt-4">
 5:       <PrimeButton
 6:         type="button"
 7:         label="Previous"
 8:         class="p-button-secondary mr-2"
 9:         @click="$emit('prev')"
10:       />
11:       <PrimeButton
12:         type="submit"
13:         label="Submit"
14:       />
15:     </div>
16:   </form>
17: </template>
18: 
19: <script setup lang="ts">
20: const { form, errors, validateAndUpdate, accountDetailsSchema } = useOnboarding()
21: 
22: const handleSubmit = () => {
23:   if (validateAndUpdate(accountDetailsSchema)) {
24:     // Submit the form data to your API
25:     console.log('Form submitted:', form)
26:   }
27: }
28: 
29: const emit = defineEmits(['prev'])
30: </script>
```

## File: apps/main-app/components/onboarding/Interests.vue
```vue
 1: <template>
 2:   <div class="p-4">
 3:     <h2 class="text-2xl font-bold mb-4"> Select Your Interests </h2>
 4:     <form @submit.prevent="handleSubmit">
 5:       <div class="p-fluid">
 6:         <div class="p-field">
 7:           <label for="interests">Astronomy and Space Tech Interests</label>
 8:           <PrimeMultiSelect
 9:             id="interests"
10:             v-model="selectedInterests"
11:             :options="interestOptions"
12:             option-label="name"
13:             placeholder="Select your interests"
14:             :filter="true"
15:             :class="{ 'p-invalid': errors.interests }"
16:           />
17:           <small
18:             v-if="errors.interests"
19:             class="p-error"
20:             >{{ errors.interests }}</small
21:           >
22:         </div>
23:       </div>
24:       <PrimeButton
25:         type="submit"
26:         label="Save Interests"
27:         class="mt-4"
28:       />
29:     </form>
30:   </div>
31: </template>
32: 
33: <script setup lang="ts">
34: import { z } from 'zod'
35: 
36: const interestOptions = [
37:   { name: 'Astrophysics' },
38:   { name: 'Cosmology' },
39:   { name: 'Planetary Science' },
40:   { name: 'Exoplanets' },
41:   { name: 'Astrobiology' },
42:   { name: 'Radio Astronomy' },
43:   { name: 'Stellar Evolution' },
44:   { name: 'Galactic Astronomy' },
45:   { name: 'Black Holes' },
46:   { name: 'Dark Matter and Dark Energy' },
47:   { name: 'Space Exploration' },
48:   { name: 'Rocket Propulsion' },
49:   { name: 'Satellite Technology' },
50:   { name: 'Space Telescopes' },
51:   { name: 'Gravitational Waves' },
52:   { name: 'Solar Physics' },
53:   { name: 'Astrochemistry' },
54:   { name: 'Astrogeology' },
55:   { name: 'Space Weather' },
56:   { name: 'Astronomical Instrumentation' },
57:   { name: 'Extragalactic Astronomy' },
58:   { name: 'Astroparticle Physics' },
59:   { name: 'Spacecraft Engineering' },
60:   { name: 'Space Medicine' },
61:   { name: 'Asteroids and Comets' },
62: ]
63: 
64: const selectedInterests = ref([])
65: const errors = ref({})
66: 
67: const interestsSchema = z.object({
68:   interests: z.array(z.object({ name: z.string() })).min(1, 'Please select at least one interest'),
69: })
70: 
71: const handleSubmit = () => {
72:   const result = interestsSchema.safeParse({ interests: selectedInterests.value })
73:   if (result.success) {
74:     // Clear any previous errors
75:     errors.value = {}
76:     // Submit the interests to your API
77:     console.log('Interests submitted:', selectedInterests.value)
78:     // You can add your API call here
79:   } else {
80:     // Update errors
81:     errors.value = result.error.flatten().fieldErrors
82:   }
83: }
84: </script>
```

## File: apps/main-app/components/onboarding/Professional.vue
```vue
 1: <template>
 2:   <form @submit.prevent="handleSubmit">
 3:     <div class="p-fluid">
 4:       <div class="p-field">
 5:         <label for="occupation">Occupation</label>
 6:         <PrimeSelect
 7:           id="occupation"
 8:           v-model="form.occupation"
 9:           :options="occupationOptions"
10:           option-label="name"
11:           option-value="value"
12:           placeholder="Select an occupation"
13:           :class="{ 'p-invalid': errors.occupation }"
14:         />
15:         <small
16:           v-if="errors.occupation"
17:           class="p-error"
18:           >{{ errors.occupation }}</small
19:         >
20:       </div>
21:       <div class="p-field">
22:         <label for="organization">Organization</label>
23:         <PrimeInputText
24:           id="organization"
25:           v-model="form.organization"
26:           :class="{ 'p-invalid': errors.organization }"
27:         />
28:         <small
29:           v-if="errors.organization"
30:           class="p-error"
31:           >{{ errors.organization }}</small
32:         >
33:       </div>
34:       <div class="p-field">
35:         <label for="experience">Years of Experience</label>
36:         <PrimeInputNumber
37:           id="experience"
38:           v-model="form.experience"
39:           :min="0"
40:           :max="100"
41:           :class="{ 'p-invalid': errors.experience }"
42:         />
43:         <small
44:           v-if="errors.experience"
45:           class="p-error"
46:           >{{ errors.experience }}</small
47:         >
48:       </div>
49:     </div>
50:     <div class="mt-4">
51:       <PrimeButton
52:         type="button"
53:         label="Previous"
54:         class="p-button-secondary mr-2"
55:         @click="$emit('prev')"
56:       />
57:       <PrimeButton
58:         type="submit"
59:         label="Next"
60:       />
61:     </div>
62:   </form>
63: </template>
64: 
65: <script setup lang="ts">
66: const { form, errors, validateAndUpdate, professionalInfoSchema } = useOnboarding()
67: 
68: const occupationOptions = [
69:   { name: 'Astronomer', value: 'astronomer' },
70:   { name: 'Astrophysicist', value: 'astrophysicist' },
71:   { name: 'Space Engineer', value: 'space_engineer' },
72:   { name: 'Planetary Scientist', value: 'planetary_scientist' },
73:   { name: 'Other', value: 'other' },
74: ]
75: 
76: const handleSubmit = () => {
77:   if (validateAndUpdate(professionalInfoSchema)) {
78:     emit('next')
79:   }
80: }
81: 
82: const emit = defineEmits(['next', 'prev'])
83: </script>
```

## File: apps/main-app/components/post/PostCard.vue
```vue
 1: <template>
 2:   <div
 3:     v-for="article in store.articles"
 4:     :key="article.id"
 5:     class="group grid origin-left scale-x-0 animate-swipe-in grid-rows-4 overflow-hidden rounded-md shadow-sm"
 6:   >
 7:     <IBImage
 8:       :img="{
 9:         src: s.image.single({
10:           bucket: 'articles',
11:           folderPath: `${article.id}`,
12:           file: article.id,
13:           isPrivate: false,
14:         }),
15:         alt: article.title,
16:         loading: 'lazy',
17:       }"
18:     />
19:     <div
20:       class="relative col-span-1 col-start-1 row-span-2 row-start-3 w-full transition-all duration-500 ease-in-out"
21:     >
22:       <div class="foreground absolute bottom-0 w-full p-8">
23:         <NuxtLink :to="`/news/article/${article.id}`">
24:           <button
25:             class="absolute left-0 right-0 top-[-20px] mx-auto h-[40px] w-[80%] rounded-md bg-[#440439] px-8 font-bold shadow-lg before:content-['Category'] group-hover:before:content-['Read_more']"
26:           />
27:         </NuxtLink>
28:         <h1 class="pb-4 text-2xl font-semibold">
29:           {{ article.title }}
30:         </h1>
31:         <p
32:           class="h-[0px] overflow-hidden text-sm transition-all duration-500 ease-in-out group-hover:h-[100px]"
33:         >
34:           {{ article.body }}
35:         </p>
36:         <!-- <p class="mt-4 text-sm"> {{ article.publisheAt }}</p> -->
37:       </div>
38:     </div>
39:   </div>
40: </template>
41: 
42: <script setup lang="ts">
43: const store = useArticlesStore()
44: const s = useStorage()
45: await store.getArticles()
46: // const p = useArticlesStore()
47: </script>
48: 
49: <style scoped></style>
```

## File: apps/main-app/components/research/ResearchCard.vue
```vue
 1: <template>
 2:   <div class="rounded-md border border-color background flex flex-col justify-between">
 3:     <div>
 4:       <div class="space-y-3 p-4">
 5:         <div class="flex gap-2">
 6:           <span class="text-sm w-auto">
 7:             {{ useTimeAgo(research.published_at ?? research.created_at).value }}
 8:           </span>
 9:         </div>
10:         <h4 class="text-balance text-xl"> {{ research.title.slice(0, 120) }}... </h4>
11:         <p
12:           v-if="research.description"
13:           class="text-sm"
14:         >
15:           {{ research.description.slice(0, 360) }}...
16:         </p>
17:       </div>
18:     </div>
19:     <div class="p-4 flex justify-end items-center">
20:       <NuxtLink
21:         :to="`${research.url}v${research.version}`"
22:         target="_blank"
23:         rel="noopener"
24:       >
25:         <PrimeButton
26:           label="Read on Axive"
27:           size="small"
28:           outlined
29:         />
30:       </NuxtLink>
31:     </div>
32:   </div>
33: </template>
34: 
35: <script setup lang="ts">
36: import type { NewsCardT } from '@/types/news'
37: 
38: defineProps({
39:   research: {
40:     type: Object as () => NewsCardT,
41:     required: true,
42:   },
43:   // summaryLevel: {
44:   //   type: String,
45:   //   required: true
46:   // }
47: })
48: </script>
```

## File: apps/main-app/components/search/SearchBar.vue
```vue
 1: <script setup lang="ts">
 2: const props = defineProps<{
 3:   selectedPrompt?: string
 4:   systemPrompt?: string
 5: }>()
 6: 
 7: const chatStore = useChatStore()
 8: const { question, isLoading } = storeToRefs(chatStore)
 9: 
10: watch(
11:   () => props.selectedPrompt,
12:   (newPrompt) => {
13:     if (newPrompt) {
14:       question.value = newPrompt
15:     }
16:   },
17: )
18: 
19: const submitQuestion = async () => {
20:   if (question.value.trim()) {
21:     await chatStore.submitQuestion({
22:       question: question.value,
23:       systemPrompt: props.systemPrompt,
24:     })
25:     question.value = ''
26:   }
27: }
28: </script>
29: 
30: <template>
31:   <div class="w-full">
32:     <div class="mx-auto flex w-full max-w-3xl items-center">
33:       <div
34:         class="foreground border-color flex w-full items-center rounded-lg border px-2 py-1 pr-2"
35:       >
36:         <!-- <PrimeButton
37:           rounded
38:           :pt="{ root: 'p-5 flex justify-center items-center relative' }"
39:           severity="secondary"
40:         >
41:           <Icon
42:             :name="textSearchType === 'fts' ? 'mdi:card-text-outline' : 'mdi:format-list-numbered'"
43:             class="absolute"
44:                       size="24px"
45: 
46:           />
47:         </PrimeButton> -->
48:         <PrimeTextarea
49:           ref="messageInput"
50:           v-model="question"
51:           auto-resize
52:           placeholder="Ask Your Question..."
53:           class="flex resize-none max-h-[120px] w-full items-center justify-center bg-transparent px-4 py-2 outline-none"
54:           :pt="{ root: 'border-none' }"
55:           @keyup.enter="submitQuestion"
56:         />
57:         <PrimeButton
58:           pt:root:class="p-0"
59:           link
60:           @click="submitQuestion"
61:         >
62:           <Icon
63:             :name="isLoading ? 'mdi:loading' : 'mdi:send'"
64:             class="font-bold text-primary-500"
65:             size="24px"
66:             :class="isLoading ? 'animate-spin' : ''"
67:           />
68:         </PrimeButton>
69:       </div>
70:     </div>
71:   </div>
72: </template>
73: 
74: <style scoped></style>
```

## File: apps/main-app/components/supa/Download.vue
```vue
 1: <template>
 2:   <div class="w-full h-full p-12 example-avatar">
 3:     <button @click="tester"> clicker </button>
 4:     <p>{{ files }}</p>
 5:     <button
 6:       class="p-6 mt-4 bg-red-200"
 7:       @click="tester2"
 8:     >
 9:       clicker2
10:     </button>
11:     <p>{{ files2 }}</p>
12:   </div>
13: </template>
14: 
15: <script setup>
16: const files = ref(null)
17: const files2 = ref(null)
18: 
19: const tester = async () => {
20:   const { data, error } = await download.folder('9465747a-47a0-46ac-93a7-5151e62b8eff', true)
21:   if (error) {
22:     return console.error(error)
23:   }
24:   files.value = data
25: }
26: 
27: const tester2 = async () => {
28:   const { data, error } = await download.avatar('9465747a-47a0-46ac-93a7-5151e62b8eff', true)
29:   if (error) {
30:     return console.error(error)
31:   }
32:   files2.value = data
33: }
34: </script>
35: 
36: <style scoped></style>
```

## File: apps/main-app/components/supa/Realtime.vue
```vue
 1: <template>
 2:   <div class="flex items-center justify-center w-full h-full p-12 rounded-md shadow-md">
 3:     <div
 4:       v-for="t in store"
 5:       :key="t.id"
 6:     >
 7:       <p> realtime: {{ t }} </p>
 8:     </div>
 9:   </div>
10: </template>
11: 
12: <script setup lang="ts">
13: const { table, store } = useRealtime()
14: 
15: table.single()
16: </script>
17: 
18: <style scoped></style>
```

## File: apps/main-app/components/supa/Upload.vue
```vue
  1: <script setup lang="ts">
  2: const props = defineProps({
  3:   uploadType: {
  4:     type: String as PropType<string>,
  5:     required: true,
  6:   },
  7: })
  8: 
  9: const imageInput = ref(null) // template ref for file input
 10: const selectedFile = ref(null)
 11: const imageSrc = ref(null)
 12: const img = ref(null)
 13: const cropper = ref({})
 14: const destination = ref(null)
 15: 
 16: const fileReader = new FileReader()
 17: fileReader.onload = (event) => {
 18:   imageSrc.value = event.target.result
 19: }
 20: 
 21: const handleImageCropped = () => {
 22:   cropper.value
 23:     .getCroppedCanvas({
 24:       width: 180,
 25:       height: 180,
 26:     })
 27:     .toBlob((blob) => {
 28:       upload.avatar({ file: blob, userId, type: props.uploadType }) // !todo auth user, get id
 29:     }, 'image/png')
 30:   selectedFile.value = null
 31: }
 32: const fileChanged = (e) => {
 33:   const files = e.target.files || e.dataTransfer.files
 34:   if (files.length) {
 35:     selectedFile.value = files[0]
 36:   }
 37: }
 38: 
 39: const fileCleared = (_) => {
 40:   selectedFile.value = null
 41: }
 42: 
 43: onMounted(() => {})
 44: 
 45: onUnmounted(() => {})
 46: 
 47: watchEffect(() => {
 48:   if (selectedFile.value) {
 49:     fileReader.readAsDataURL(selectedFile.value)
 50:   } else {
 51:     imageSrc.value = null
 52:   }
 53: })
 54: 
 55: watch(
 56:   imageSrc,
 57:   () => {
 58:     if (imageSrc.value) {
 59:       cropper.value.replace(imageSrc.value)
 60:     }
 61:   },
 62:   {
 63:     flush: 'post', // watch runs after component updates
 64:   },
 65: )
 66: </script>
 67: 
 68: <template>
 69:   <div class="flex flex-col items-center justify-center w-full h-full gap-4 example-avatar">
 70:     <div
 71:       v-show="imageSrc"
 72:       class="object-fill w-1/2 mx-auto my-4 border-4 rounded-full aspect-ratio border-stone-700"
 73:     >
 74:       <img
 75:         :src="destination"
 76:         class="block w-full rounded-full"
 77:       />
 78:     </div>
 79:     <div
 80:       v-show="imageSrc"
 81:       class="object-fill w-1/2 mx-auto my-2 aspect-ratio"
 82:     >
 83:       <img
 84:         ref="img"
 85:         class="block w-full max-w-full pb-4 aspect-auto"
 86:         :src="imageSrc"
 87:       />
 88:     </div>
 89:     <div class="flex content-end justify-center w-full py-2 mt-2 rounded-md">
 90:       <PrimeButton
 91:         v-if="!imageSrc"
 92:         color="primary"
 93:         @click="imageInput.click()"
 94:       >
 95:         <slot />
 96:       </PrimeButton>
 97:       <PrimeButton
 98:         v-else
 99:         color="primary"
100:         class="w-32 mx-2"
101:         @click="handleImageCropped"
102:       >
103:         Update
104:       </PrimeButton>
105:       <PrimeButton
106:         v-if="imageSrc"
107:         color="primary"
108:         class="w-32 mx-2"
109:         @click="fileCleared"
110:       >
111:         Cancel
112:       </PrimeButton>
113:       <input
114:         ref="imageInput"
115:         type="file"
116:         accept=".jpg,.jpeg,.png"
117:         class="py-4"
118:         :style="{ display: 'none' }"
119:         @change="fileChanged"
120:       />
121:     </div>
122:   </div>
123: </template>
124: 
125: <style scoped>
126: .preview {
127:   border: 5px solid #292929;
128:   overflow: hidden;
129:   width: 50px;
130:   height: 50px;
131: }
132: 
133: .example-avatar .avatar-upload .rounded-circle {
134:   width: 200px;
135:   height: 200px;
136: }
137: 
138: .example-avatar .text-center .btn {
139:   margin: 0 0.5rem;
140: }
141: 
142: .example-avatar .avatar-edit-image {
143:   max-width: 100%;
144: }
145: 
146: .example-avatar .drop-active {
147:   top: 0;
148:   bottom: 0;
149:   right: 0;
150:   left: 0;
151:   position: fixed;
152:   z-index: 9999;
153:   opacity: 0.6;
154:   text-align: center;
155:   background: #000;
156: }
157: 
158: .example-avatar .drop-active h3 {
159:   margin: -0.5em 0 0;
160:   position: absolute;
161:   top: 50%;
162:   left: 0;
163:   right: 0;
164:   -webkit-transform: translateY(-50%);
165:   -ms-transform: translateY(-50%);
166:   transform: translateY(-50%);
167:   font-size: 40px;
168:   color: #fff;
169:   padding: 0;
170: }
171: </style>
```

## File: apps/main-app/components/user/settings/UserSettingsCard.vue
```vue
 1: <script setup lang="ts">
 2: import type { TitleType } from '~/types/content'
 3: 
 4: defineProps({
 5:   title: {
 6:     type: Object as PropType<TitleType>,
 7:     required: true,
 8:   },
 9: })
10: </script>
11: 
12: <template>
13:   <PrimeCard>
14:     <template #title>
15:       <div>
16:         <h2 class="text-2xl font-semibold">
17:           {{ title.main }}
18:         </h2>
19:         <span class="text-base">{{ title.subtitle }}</span>
20:       </div>
21:     </template>
22:     <template #content>
23:       <div class="flex flex-col">
24:         <slot />
25:       </div>
26:     </template>
27:     <template #footer>
28:       <!-- feedback section? -->
29:     </template>
30:   </PrimeCard>
31: </template>
32: 
33: <style scoped></style>
```

## File: apps/main-app/components/user/settings/UserSettingsItem.vue
```vue
 1: <script setup lang="ts">
 2: defineProps({
 3:   item: {
 4:     type: Object,
 5:     required: true,
 6:   },
 7: })
 8: </script>
 9: 
10: <template>
11:   <div
12:     class="flex flex-col md:flex-row gap-4 md:gap-8 w-full h-auto border-color py-4 justify-between border-y"
13:   >
14:     <div class="flex flex-col gap-4 justify-start max-w-48 w-full">
15:       <div class="space-y-2 w-full">
16:         <p class="text-lg font-bold">
17:           {{ item.label }}
18:         </p>
19:         <p class="text-sm">
20:           {{ item.tip }}
21:         </p>
22:       </div>
23:     </div>
24:     <div class="w-full">
25:       <slot />
26:     </div>
27:   </div>
28: </template>
29: 
30: <style scoped></style>
```

## File: apps/main-app/components/vote/VoteAnimate.vue
```vue
  1: <script setup lang="ts">
  2: import { ref } from 'vue'
  3: 
  4: interface Props {
  5:   direction?: 'up' | 'down' | 'none'
  6:   showParticles?: boolean
  7:   contentId: string
  8: }
  9: 
 10: const props = withDefaults(defineProps<Props>(), {
 11:   direction: 'none',
 12:   showParticles: false,
 13: })
 14: 
 15: const isAnimating = ref(false)
 16: 
 17: const createParticles = () => {
 18:   // Debug logging
 19:   console.log('Creating particles for ID:', props.contentId)
 20: 
 21:   const element = document.querySelector(`#vote-animate-${props.contentId}`)
 22:   if (!element) {
 23:     console.warn('Target element not found:', `#vote-animate-${props.contentId}`)
 24:     return
 25:   }
 26: 
 27:   const rect = element.getBoundingClientRect()
 28:   console.log('Element position:', rect)
 29: 
 30:   const particles = 5
 31:   const particleClass = `particle-${props.contentId}`
 32: 
 33:   // Remove any existing particles first
 34:   document.querySelectorAll(`.${particleClass}`).forEach((el) => el.remove())
 35: 
 36:   for (let i = 0; i < particles; i++) {
 37:     const particle = document.createElement('div')
 38:     particle.className = particleClass
 39: 
 40:     // Position particle at button center
 41:     const startX = rect.left + rect.width / 2
 42:     const startY = rect.top + rect.height / 2
 43: 
 44:     // Calculate random angle and distance
 45:     const angle = Math.random() * Math.PI * 2
 46:     const distance = 30 + Math.random() * 20 // 30-50px distance
 47: 
 48:     // Calculate end position
 49:     const endX = startX + Math.cos(angle) * distance
 50:     const endY = startY + Math.sin(angle) * distance
 51: 
 52:     // Set initial position
 53:     particle.style.cssText = `
 54:       position: fixed;
 55:       left: ${startX}px;
 56:       top: ${startY}px;
 57:       width: 8px;
 58:       height: 8px;
 59:       background-color: #3B82F6;
 60:       border-radius: 50%;
 61:       pointer-events: none;
 62:       z-index: 9999;
 63:       transform-origin: center center;
 64:     `
 65: 
 66:     document.body.appendChild(particle)
 67: 
 68:     // Force a reflow
 69:     void particle.offsetWidth
 70: 
 71:     // Add animation styles
 72:     particle.style.transition = 'all 500ms ease-out'
 73:     particle.style.transform = 'translate(0, 0) scale(1)'
 74:     particle.style.opacity = '1'
 75: 
 76:     // Animate to end position
 77:     requestAnimationFrame(() => {
 78:       particle.style.transform = `translate(${endX - startX}px, ${endY - startY}px) scale(0)`
 79:       particle.style.opacity = '0'
 80:     })
 81: 
 82:     // Cleanup
 83:     setTimeout(() => {
 84:       if (particle.parentElement) {
 85:         particle.parentElement.removeChild(particle)
 86:       }
 87:     }, 1000)
 88:   }
 89: }
 90: 
 91: const triggerAnimation = () => {
 92:   console.log('Animation triggered, showParticles:', props.showParticles)
 93:   isAnimating.value = true
 94: 
 95:   if (props.showParticles) {
 96:     createParticles()
 97:   }
 98: 
 99:   setTimeout(() => {
100:     isAnimating.value = false
101:   }, 300)
102: }
103: 
104: defineExpose({ triggerAnimation })
105: </script>
106: 
107: <template>
108:   <div
109:     :id="`vote-animate-${contentId}`"
110:     :class="{
111:       'animation-wrapper': true,
112:       'scale-animation': isAnimating,
113:       'translate-up': isAnimating && direction === 'up',
114:       'translate-down': isAnimating && direction === 'down',
115:     }"
116:   >
117:     <slot />
118:   </div>
119: </template>
120: 
121: <style>
122: .animation-wrapper {
123:   display: inline-flex;
124:   position: relative;
125:   transition: transform 0.2s ease;
126: }
127: 
128: .scale-animation {
129:   animation: popAnimation 300ms ease-in-out;
130: }
131: 
132: .translate-up {
133:   transform: translateY(-2px);
134: }
135: 
136: .translate-down {
137:   transform: translateY(2px);
138: }
139: 
140: @keyframes popAnimation {
141:   0% {
142:     transform: scale(1);
143:   }
144:   50% {
145:     transform: scale(1.15);
146:   }
147:   100% {
148:     transform: scale(1);
149:   }
150: }
151: </style>
```

## File: apps/main-app/components/vote/VoteButton.vue
```vue
 1: <script setup lang="ts">
 2: // components/VoteButton.vue
 3: import { computed, ref } from 'vue'
 4: 
 5: interface Props {
 6:   contentId: string
 7:   contentType?: string
 8:   count?: number
 9:   direction: 'up' | 'down'
10: }
11: 
12: const props = withDefaults(defineProps<Props>(), {
13:   contentType: 'news',
14:   count: 0,
15: })
16: 
17: const emit = defineEmits<{
18:   (e: 'vote-change', value: { voteType: number | null; change: number }): void
19: }>()
20: 
21: const voteStore = useVoteStore()
22: const notification = useNotification()
23: const animationRef = ref()
24: 
25: const currentVoteType = computed(() => voteStore.getVoteType(props.contentId))
26: const isPending = computed(() => voteStore.isVotePending(props.contentId))
27: 
28: const isActive = computed(() => {
29:   return props.direction === 'up' ? currentVoteType.value === 1 : currentVoteType.value === -1
30: })
31: 
32: onMounted(async () => {
33:   await voteStore.fetchUserVotes()
34: })
35: 
36: const handleVote = async () => {
37:   if (isPending.value) return
38: 
39:   const voteType = props.direction === 'up' ? 1 : -1
40: 
41:   // Trigger animation
42:   animationRef.value?.triggerAnimation()
43: 
44:   try {
45:     const result = await voteStore.submitVote(props.contentId, voteType, notification)
46:     if (result) {
47:       emit('vote-change', {
48:         voteType: voteStore.getVoteType(props.contentId),
49:         change: result.change,
50:       })
51:     }
52:   } catch (error) {
53:     console.error('Vote error:', error)
54:   }
55: }
56: </script>
57: 
58: <template>
59:   <VoteAnimate
60:     ref="animationRef"
61:     :direction="direction"
62:     :show-particles="direction === 'up'"
63:     :content-id="contentId"
64:   >
65:     <button
66:       class="p-1 rounded-md flex transition-all duration-200 disabled:opacity-50 disabled:cursor-not-allowed"
67:       :class="[
68:         'hover:bg-gray-100 dark:hover:bg-gray-800',
69:         {
70:           'text-green-500 hover:text-green-600 hover:bg-green-50 dark:hover:bg-green-900/20':
71:             direction === 'up' && isActive,
72:           'text-red-500 hover:text-red-600 hover:bg-red-50 dark:hover:bg-red-900/20':
73:             direction === 'down' && isActive,
74:           'text-gray-700 dark:text-gray-300 hover:text-gray-600 dark:hover:text-gray-400':
75:             !isActive,
76:         },
77:       ]"
78:       :disabled="isPending"
79:       @click="handleVote"
80:     >
81:       <Icon
82:         :name="direction === 'up' ? 'mdi:arrow-up' : 'mdi:arrow-down'"
83:         class="flex transition-transform duration-200"
84:         size="20px"
85:         :class="{ 'scale-125': isActive }"
86:       />
87:     </button>
88:   </VoteAnimate>
89: </template>
90: 
91: <style>
92: /* Only keeping minimal required custom CSS for the scale transition */
93: .scale-125 {
94:   transform: scale(1.25);
95: }
96: </style>
```

## File: apps/main-app/components/AppBackButton.vue
```vue
 1: <script setup lang="ts"></script>
 2: 
 3: <template>
 4:   <div class="background flex items-center justify-center gap-2 rounded-md p-2">
 5:     <NuxtLink to="/">
 6:       <PrimeButton label="Go back"> Go Home </PrimeButton>
 7:     </NuxtLink>
 8:     <!-- <AppThemeToggle v-slot="{ toggle, isDark }">
 9:       <Icon
10:         :name="isDark ? 'heroicons:sun' : 'heroicons:moon'"
11:         class="cursor-pointer"
12:                       size="24px"
13: 
14:         @click="toggle"
15:       />
16:     </AppThemeToggle> -->
17:   </div>
18: </template>
19: 
20: <style scoped></style>
```

## File: apps/main-app/components/ConfirmationDialog.vue
```vue
 1: <template>
 2:   <PrimeConfirmDialog>
 3:     <template #message="slotProps">
 4:       <div class="flex items-start gap-3">
 5:         <Icon
 6:           v-if="slotProps.message?.icon"
 7:           :name="slotProps.message.icon"
 8:           class="text-2xl"
 9:         />
10:         <p>{{ slotProps.message?.message }}</p>
11:       </div>
12:     </template>
13:   </PrimeConfirmDialog>
14: </template>
```

## File: apps/main-app/components/DeleteConfirmation.vue
```vue
 1: <script setup lang="ts">
 2: const props = defineProps<{
 3:   show: boolean
 4:   itemName?: string
 5: }>()
 6: 
 7: const emit = defineEmits<{
 8:   (e: 'confirm'): void
 9:   (e: 'cancel'): void
10: }>()
11: </script>
12: 
13: <template>
14:   <PrimeDialog
15:     v-model:visible="show"
16:     modal
17:     header="Confirm Delete"
18:     :style="{ width: '90vw', maxWidth: '400px' }"
19:   >
20:     <p>Are you sure you want to delete {{ itemName || 'this item' }}?</p>
21:     <template #footer>
22:       <PrimeButton
23:         label="Cancel"
24:         class="p-button-text"
25:         @click="$emit('cancel')"
26:       />
27:       <PrimeButton
28:         label="Delete"
29:         class="p-button-danger"
30:         @click="$emit('confirm')"
31:       />
32:     </template>
33:   </PrimeDialog>
34: </template>
```

## File: apps/main-app/components/FuzzySearch.vue
```vue
 1: <script setup lang="ts">
 2: import Fuse from 'fuse.js'
 3: import type { FuseResult, IFuseOptions } from 'fuse.js'
 4: 
 5: interface Props<T> {
 6:   modelValue: string
 7:   placeholder?: string
 8:   data: T[]
 9:   fuseOptions?: IFuseOptions<T>
10:   debounceMs?: number
11: }
12: 
13: const props = withDefaults(defineProps<Props<any>>(), {
14:   placeholder: 'Search...',
15:   debounceMs: 300,
16:   fuseOptions: () => ({
17:     threshold: 0.3,
18:     shouldSort: true,
19:   }),
20: })
21: 
22: const emit = defineEmits<{
23:   'update:modelValue': [value: string]
24:   'results': [results: FuseResult<any>[]]
25: }>()
26: 
27: const searchValue = computed({
28:   get: () => props.modelValue,
29:   set: (value) => emit('update:modelValue', value),
30: })
31: 
32: // Debounced search function
33: const debouncedSearch = useDebounceFn((query: string) => {
34:   if (!query.trim()) {
35:     emit('results', [])
36:     return
37:   }
38: 
39:   const fuse = new Fuse(props.data, props.fuseOptions)
40:   const results = fuse.search(query)
41:   emit('results', results)
42: }, props.debounceMs)
43: 
44: // Watch for changes in search value or data
45: watch(
46:   [() => searchValue.value, () => props.data],
47:   ([newQuery]) => {
48:     debouncedSearch(newQuery)
49:   },
50:   { immediate: true },
51: )
52: </script>
53: 
54: <template>
55:   <div class="relative flex-1 w-full">
56:     <PrimeIconField class="w-full">
57:       <PrimeInputText
58:         v-model="searchValue"
59:         :placeholder="placeholder"
60:         class="w-full !pr-10"
61:       />
62:       <Icon
63:         name="mdi:magnify"
64:         class="text-gray-400 absolute right-3 top-1/2 -translate-y-1/2"
65:       />
66:     </PrimeIconField>
67:   </div>
68: </template>
```

## File: apps/main-app/components/PaymentButton.vue
```vue
 1: <template>
 2:   <div class="card background rounded-lg p-4 shadow-lg">
 3:     <h2 class="mb-4 text-2xl font-bold"> Monthly Test Plan </h2>
 4:     <div class="relative h-32 w-32 overflow-hidden rounded-full bg-white p-2">
 5:       <NuxtImg
 6:         src="/astronera-logo.jpg"
 7:         alt="Acme Corp Logo"
 8:         class="h-full w-full"
 9:       />
10:     </div>
11:     <p class="mb-4"> Subscribe to our monthly plan for exclusive benefits! </p>
12:     <PrimeButton
13:       label="Pay Now"
14:       icon="pi pi-credit-card"
15:       :loading="loading"
16:       :disabled="!isRazorpayLoaded"
17:       @click="handlePayment"
18:     />
19:   </div>
20: </template>
21: 
22: <script setup lang="ts">
23: const config = useRuntimeConfig()
24: const loading = ref(false)
25: const isRazorpayLoaded = ref(false)
26: 
27: const razorpayOptions = {
28:   key: 'rzp_test_lV0OE0NDIg6Hr6',
29:   subscription_id: 'sub_OmnXoFCi6bQSlj',
30:   name: 'Professional',
31:   description: 'Monthly Professional Plan',
32:   image: '/astronera-logo.jpg',
33:   handler: function (response: any) {
34:     console.log('Payment ID:', response.razorpay_payment_id)
35:     console.log('Subscription ID:', response.razorpay_subscription_id)
36:     console.log('Signature:', response.razorpay_signature)
37:     // Here you can add logic to verify the payment on your server
38:   },
39:   prefill: {
40:     name: 'Gaurav Kumar',
41:     email: 'gaurav.kumar@example.com',
42:     contact: '+919876543210',
43:   },
44:   notes: {
45:     note_key_1: 'Tea. Earl Grey. Hot',
46:     note_key_2: 'Make it so.',
47:   },
48:   theme: {
49:     color: '#F37254',
50:   },
51: }
52: 
53: let rzp: any
54: 
55: useHead({
56:   script: [
57:     {
58:       src: 'https://checkout.razorpay.com/v1/checkout.js',
59:       async: true,
60:       onload: () => {
61:         isRazorpayLoaded.value = true
62:         rzp = new (window as any).Razorpay(razorpayOptions)
63:       },
64:     },
65:   ],
66: })
67: 
68: const handlePayment = () => {
69:   if (!isRazorpayLoaded.value) {
70:     console.error('Razorpay is not loaded yet')
71:     return
72:   }
73:   loading.value = true
74:   rzp.open()
75:   loading.value = false
76: }
77: </script>
78: 
79: <style scoped>
80: /* Add any additional styles here */
81: </style>
```

## File: apps/main-app/components/UploadCropper.vue
```vue
  1: <script setup lang="ts">
  2: import type { CropperResult, ImageTransforms } from 'vue-advanced-cropper'
  3: import { Cropper, Preview } from 'vue-advanced-cropper'
  4: import 'vue-advanced-cropper/dist/style.css'
  5: import { useNotification } from '../../../layers/crud/composables/notification'
  6: import { useCurrentUser } from '../../../layers/crud/composables/user.current.store'
  7: import { useFileUpload } from '#imports'
  8: 
  9: type CropperConfigTypes = 'avatar' | 'default'
 10: 
 11: const MAX_FILE_SIZE = 5 * 1024 * 1024 // 5 MB
 12: const emit = defineEmits(['profile-pic-update'])
 13: const uploadInput = ref(null as HTMLInputElement | null)
 14: const image = ref<string>('')
 15: 
 16: const props = defineProps({
 17:   cropperType: {
 18:     type: String as PropType<CropperConfigTypes>,
 19:     required: true,
 20:   },
 21:   bucket: {
 22:     type: String,
 23:     required: false,
 24:     default: 'profile',
 25:   },
 26:   path: {
 27:     type: String,
 28:     required: true,
 29:   },
 30:   requireCropping: {
 31:     type: Boolean,
 32:     default: true,
 33:   },
 34: })
 35: 
 36: const config = computed(() => cropperConfigs[props.cropperType])
 37: 
 38: export interface CropperConfig {
 39:   name: string
 40:   minHeight: number
 41:   minWidth: number
 42:   maxHeight?: number
 43:   maxWidth?: number
 44:   stencilComponent?: string
 45:   canvas: {
 46:     minWidth: number
 47:     minHeight: number
 48:     maxWidth: number
 49:     maxHeight: number
 50:   }
 51:   stencilSize?: {
 52:     width: number
 53:     height: number
 54:   }
 55:   stencilProps: {
 56:     handlers?: Record<string, any>
 57:     movable: boolean
 58:     resizable?: boolean
 59:     aspectRatio?: number
 60:   }
 61: }
 62: 
 63: const cropperConfigs: Record<CropperConfigTypes, CropperConfig> = {
 64:   default: {
 65:     name: 'Default',
 66:     minWidth: 160,
 67:     minHeight: 160,
 68:     canvas: {
 69:       minHeight: 0,
 70:       minWidth: 0,
 71:       maxHeight: 480,
 72:       maxWidth: 480,
 73:     },
 74:     stencilProps: {
 75:       aspectRatio: 1,
 76:       movable: true,
 77:     },
 78:   },
 79:   avatar: {
 80:     name: 'avatar',
 81:     minHeight: 160,
 82:     minWidth: 160,
 83:     canvas: {
 84:       minHeight: 0,
 85:       minWidth: 0,
 86:       maxHeight: 480,
 87:       maxWidth: 480,
 88:     },
 89:     stencilProps: {
 90:       aspectRatio: 1,
 91:       movable: true,
 92:     },
 93:   },
 94: }
 95: const { uploadFile, isUploading, uploadProgress } = useFileUpload()
 96: const userStore = useCurrentUser()
 97: const { profile } = storeToRefs(userStore)
 98: const toast = useNotification()
 99: 
100: // Checks & Utils
101: type Compression = 'lossy' | 'lossless' | 'alpha' | 'animation'
102: function checkWebpFeature(feature: Compression): Promise<boolean> {
103:   return new Promise((resolve) => {
104:     const kTestImages = {
105:       lossy: 'UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA',
106:       lossless: 'UklGRhoAAABXRUJQVlA4TA0AAAAvAAAAEAcQERGIiP4HAA==',
107:       alpha:
108:         'UklGRkoAAABXRUJQVlA4WAoAAAAQAAAAAAAAAAAAQUxQSAwAAAARBxAR/Q9ERP8DAABWUDggGAAAABQBAJ0BKgEAAQAAAP4AAA3AAP7mtQAAAA==',
109:       animation:
110:         'UklGRlIAAABXRUJQVlA4WAoAAAASAAAAAAAAAAAAQU5JTQYAAAD/////AABBTk1GJgAAAAAAAAAAAAAAAAAAAGQAAABWUDhMDQAAAC8AAAAQBxAREYiI/gcA',
111:     }
112: 
113:     const img = new Image()
114:     img.onload = () => resolve(true)
115:     img.onerror = () => resolve(false)
116:     img.src = 'data:image/webp;base64,' + kTestImages[feature]
117:   })
118: }
119: 
120: const webpSupport = ref(false)
121: onMounted(async () => {
122:   for (const feature of ['lossy', 'lossless', 'alpha', 'animation'] as Compression[]) {
123:     const result = await checkWebpFeature(feature)
124:     if (result) {
125:       webpSupport.value = true
126:       break
127:     }
128:   }
129: })
130: 
131: async function uploadImage(blob: Blob) {
132:   try {
133:     const supabase = useSupabaseClient()
134: 
135:     const result = await uploadFile(new File([blob], 'image.webp', { type: 'image/webp' }), {
136:       bucket: props.bucket,
137:       fileType: 'image',
138:       userId: profile.value.id,
139:       serverSideOptimize: true,
140:       maxWidth: 1200,
141:       maxHeight: 1200,
142:       quality: 90,
143:       format: 'webp',
144:       maxFileSize: MAX_FILE_SIZE,
145:       allowedMimeTypes: ['image/jpeg', 'image/jpg', 'image/png', 'image/webp'],
146:       replace: props.cropperType === 'avatar',
147:       onProgress: (progress) => {
148:         console.log(`Upload progress: ${progress}%`)
149:       },
150:     })
151: 
152:     if (props.cropperType === 'avatar') {
153:       emit('profile-pic-update', result.publicUrl)
154:     }
155: 
156:     return result
157:   } catch (error: any) {
158:     setError(`Failed to upload image: ${error.message}`)
159:     throw error
160:   }
161: }
162: 
163: // Cropper
164: const cropper = ref(null as typeof Cropper | null)
165: const crop = async (toggleModalOpen: () => void) => {
166:   if (!cropper.value) {
167:     setError('No cropper instance in crop function.')
168:     toggleModalOpen()
169:     return
170:   }
171: 
172:   const { canvas } = cropper.value.getResult()
173:   if (!canvas) {
174:     setError('Cropper failed to get canvas')
175:     toggleModalOpen()
176:     return
177:   }
178: 
179:   const exportMimeType = webpSupport.value ? 'image/webp' : 'image/jpeg'
180: 
181:   canvas.toBlob(
182:     async (blob) => {
183:       if (!blob) {
184:         setError('Failed to convert canvas to blob.')
185:         return
186:       }
187:       try {
188:         await uploadImage(blob)
189:         toggleModalOpen()
190:       } catch (error) {
191:         console.error('Error uploading cropped image:', error)
192:       }
193:     },
194:     exportMimeType,
195:     0.9,
196:   )
197: }
198: 
199: async function handleFileChange(e: Event, toggleModalOpen: () => void) {
200:   const input = e.target as HTMLInputElement
201:   if (!input.files?.length) return
202: 
203:   const file = input.files[0]
204: 
205:   if (!validateFileSize(file.size)) {
206:     return
207:   }
208: 
209:   try {
210:     if (props.requireCropping) {
211:       image.value = await readFileAsDataURL(file)
212:       if (!(await checkImageDimensions(image.value, props.cropperType))) {
213:         return
214:       }
215:       toggleModalOpen()
216:     } else {
217:       await uploadImage(file)
218:     }
219:   } catch (error: any) {
220:     setError(`An error occurred while processing the file: ${error.message}`)
221:   } finally {
222:     if (input) input.value = ''
223:   }
224: }
225: 
226: const preview = reactive<CropperResult>({
227:   image: {
228:     width: 0,
229:     height: 0,
230:     transforms: {} as ImageTransforms,
231:     src: null,
232:   },
233:   visibleArea: {
234:     width: 0,
235:     height: 0,
236:     left: 0,
237:     top: 0,
238:   },
239:   coordinates: {
240:     left: 0,
241:     top: 0,
242:     width: 0,
243:     height: 0,
244:   },
245: })
246: 
247: function onChange({ coordinates, image, canvas }: CropperResult) {
248:   // realtime changes in the cropper
249:   if (!coordinates || !image) return
250: 
251:   preview.coordinates = coordinates
252:   preview.image = image
253: }
254: 
255: // original file
256: type CropperConfigDimensions = {
257:   [key in CropperConfigTypes]: { minWidth: number; minHeight: number }
258: }
259: 
260: function checkImageDimensions(imageSrc: string, cropperType: CropperConfigTypes): Promise<boolean> {
261:   const dimensions: CropperConfigDimensions = {
262:     default: { minWidth: 800, minHeight: 600 },
263:     avatar: { minWidth: 160, minHeight: 160 },
264:   }
265: 
266:   return new Promise((resolve) => {
267:     const img = new Image()
268:     img.onload = () => {
269:       const { minWidth, minHeight } = dimensions[cropperType]
270:       console.log('cropper mins', minHeight, minWidth, img.width, img.height)
271:       if (img.width >= minWidth && img.height >= minHeight) {
272:         resolve(true)
273:       } else {
274:         setError(
275:           `Image dimensions must be at least ${minWidth}x${minHeight}px for ${cropperType}. (dimensions ${img.width}x${img.height})`,
276:         )
277:         resolve(false)
278:       }
279:     }
280:     img.onerror = () => {
281:       setError('Failed to load image for dimension check.')
282:       resolve(false)
283:     }
284:     img.src = imageSrc
285:   })
286: }
287: 
288: function readFileAsDataURL(file: File): Promise<string> {
289:   return new Promise((resolve, reject) => {
290:     const reader = new FileReader()
291:     reader.onload = () => resolve(reader.result as string)
292:     reader.onerror = () => reject(reader.error)
293:     reader.onerror = () => {
294:       setError(`Failed to read the file: ${reader.error?.message}`)
295:       reject(new Error(`Failed to read the file: ${reader.error?.message}`))
296:     }
297: 
298:     reader.readAsDataURL(file)
299:   })
300: }
301: 
302: function validateFileSize(fileSize: number): boolean {
303:   if (fileSize > MAX_FILE_SIZE) {
304:     setError('File is too large. Please select a file smaller than 5MB.')
305:     return false
306:   }
307:   return true
308: }
309: 
310: const setError = (error: string) => {
311:   toast.error({
312:     summary: 'Error',
313:     message: error,
314:   })
315: }
316: </script>
317: 
318: <template>
319:   <div class="space-y-24">
320:     <IBModal>
321:       <template #button="{ toggleModalOpen }">
322:         <label
323:           v-ripple
324:           :for="`myFile-${cropperType}`"
325:           class="border-color bg-primary rounded-lg border px-2 py-1 text-sm"
326:         >
327:           Upload {{ cropperType }}
328:         </label>
329:         <input
330:           :id="`myFile-${cropperType}`"
331:           ref="uploadInput"
332:           type="file"
333:           accept="image/jpg, image/jpeg, image/png, image/webp"
334:           name="filename"
335:           class="hidden"
336:           @change="handleFileChange($event, toggleModalOpen)"
337:         />
338:       </template>
339:       <template #modal:header>
340:         <h2 class="text-xl font-semibold"> Crop your image </h2>
341:       </template>
342:       <template #modal:default>
343:         <Cropper
344:           v-if="requireCropping"
345:           ref="cropper"
346:           :src="image"
347:           :min-width="config.minWidth"
348:           :min-height="config.minHeight"
349:           :canvas="config.canvas"
350:           :stencil-props="config.stencilProps"
351:           :debounce="false"
352:           @change="onChange"
353:           @error="setError('error loading image')"
354:         />
355:         <div
356:           v-else-if="isUploading"
357:           class="text-center"
358:         >
359:           <p>Uploading: {{ uploadProgress }}%</p>
360:           <PrimeProgressBar :value="uploadProgress" />
361:         </div>
362:       </template>
363:       <template #modal:footer="{ toggleModalOpen }">
364:         <div
365:           v-if="requireCropping"
366:           class="flex items-center justify-center gap-4"
367:         >
368:           <p>Image preview</p>
369:           <Preview
370:             v-if="preview.image && config.minWidth"
371:             class="rounded-full"
372:             :width="Math.floor(config.minWidth / 3)"
373:             :height="Math.floor(config.minHeight / 3)"
374:             :image="preview.image"
375:             :coordinates="preview.coordinates"
376:           />
377:           <PrimeButton
378:             :disabled="isUploading"
379:             @click="crop(toggleModalOpen)"
380:           >
381:             {{ isUploading ? 'Uploading...' : 'Crop & Upload' }}
382:           </PrimeButton>
383:         </div>
384:       </template>
385:     </IBModal>
386:   </div>
387: </template>
388: 
389: <style scoped></style>
```

## File: apps/main-app/composables/companies/companies.store.ts
```typescript
 1: import { useLogger } from '@ib/logger'
 2: import type { FetchInput } from '#imports'
 3: 
 4: type CompanyType = {
 5:   id: number
 6:   name: string
 7:   address: string
 8:   city: string
 9:   state: string
10:   zip: string
11:   phone: string
12:   email: string
13:   website: string
14:   created_at: string
15:   updated_at: string
16: }
17: 
18: // What will I need for database?
19: // Addresses table
20: // id SERIAL PRIMARY KEY,
21: // street1 VARCHAR(255) NOT NULL,
22: // street2 VARCHAR(255),
23: // city VARCHAR(100) NOT NULL,
24: // state VARCHAR(100),
25: // postal_code VARCHAR(20),
26: // country VARCHAR(100) NOT NULL,
27: // location GEOGRAPHY(POINT, 4326)
28: 
29: // Countries table:
30: // id SERIAL PRIMARY KEY,
31: // name VARCHAR(100) UNIQUE NOT NULL
32: 
33: // Cities Table:
34: // id SERIAL PRIMARY KEY,
35: // name VARCHAR(100) NOT NULL,
36: // country_id INTEGER NOT NULL,
37: // CONSTRAINT fk_country FOREIGN KEY (country_id) REFERENCES countries(id)
38: 
39: // Companies table
40: // {
41: // id: number
42: // name: string
43: 
44: //
45: //
46: //
47: // }
48: 
49: export const useCompaniesStore = defineStore('companiesStore', () => {
50:   const companies = ref([] as CompanyType[])
51:   const logger = useLogger('companiesStore')
52:   const baseFetch = useBaseFetch()
53: 
54:   async function loadCompanies(input: FetchInput) {
55:     logger.info('loadCompanies start')
56:     try {
57:       const data = await baseFetch.fetchPaginatedData(input)
58:       console.log('loadCompanies return', data)
59:       if (!data) {
60:         return
61:       }
62:       logger.info(`returned ${data.length} companies`)
63:       companies.value.push(...data)
64:     } catch (error) {
65:       logger.error('Failed to load companies:', error)
66:     }
67:   }
68: 
69:   async function insertCompany(newCompany) {
70:     try {
71:       const { data, error } = await $fetch('/api/companies/insert/single', {
72:         method: 'POST',
73:         headers: useRequestHeaders(['cookie']),
74:         body: JSON.stringify({
75:           newData: newCompany,
76:           dto: 'insert:company:full',
77:         }),
78:       })
79: 
80:       if (error) {
81:         throw createError(`error inserting company: ${error.value}`)
82:       }
83: 
84:       logger.info(`Company ${data.name} inserted successfully`)
85:     } catch (error) {
86:       logger.error(`Error inserting company ${newCompany.name}:`, error)
87:     }
88:   }
89: 
90:   // const companyById = () => {
91:   //   return (id: number) => companies.value.find((company: CompanyType) => company.id === id)
92:   // }
93: 
94:   return {
95:     companies,
96:     loadCompanies,
97:     insertCompany,
98:   }
99: })
```

## File: apps/main-app/composables/events/events.store.ts
```typescript
 1: import { useLogger } from '@ib/logger'
 2: import type { FetchInput } from '#imports'
 3: import type { EventType } from '@/types/events'
 4: 
 5: export const useEventsStore = defineStore('eventsStore', () => {
 6:   const events = ref([] as EventType[])
 7:   const logger = useLogger('eventsStore')
 8:   const baseFetch = useBaseFetch()
 9: 
10:   async function loadEvents(input: FetchInput) {
11:     logger.info('loadEvents start')
12:     try {
13:       const data = await baseFetch.fetchPaginatedData(input)
14: 
15:       if (!data) {
16:         return
17:       }
18:       logger.info(`returned ${data.length} events`)
19:       events.value.push(...data)
20:     } catch (error) {
21:       console.error('Failed to load events:', error)
22:     }
23:   }
24: 
25:   // const eventById = () => {
26:   //   return (id: number) => events.value.find((event: EventType) => event.id === id)
27:   // }
28: 
29:   return {
30:     events,
31:     loadEvents,
32:   }
33: })
```

## File: apps/main-app/composables/news/news.store.ts
```typescript
 1: import { useLogger } from '@ib/logger'
 2: import type { FetchInput } from '#imports'
 3: 
 4: export const useNewsStore = defineStore('newsStore', () => {
 5:   const logger = useLogger('newsStore')
 6:   const baseFetch = useBaseFetch()
 7: 
 8:   const news = ref([])
 9: 
10:   async function loadNews(input: FetchInput) {
11:     logger.info('loadNews start')
12:     try {
13:       const data = await baseFetch.fetchPaginatedData(input)
14: 
15:       logger.info('returned data', data)
16:       if (!data) {
17:         return
18:       }
19: 
20:       news.value.push(...data)
21:     } catch (error) {
22:       logger.error('Failed to load news:', error)
23:     }
24:   }
25: 
26:   // const countDuplicateIds = (data) => {
27:   //   const ids = data.map((item) => item.id)
28:   //   const uniqueIds = new Set(ids)
29:   //   return ids.length - uniqueIds.size
30:   // }
31: 
32:   return {
33:     news,
34:     loadNews,
35:   }
36: })
```

## File: apps/main-app/composables/users/user-settings.store.ts
```typescript
 1: type SettingsKey = 'usersStore' | 'storeNews'
 2: 
 3: export const useUserSettingsStore = defineStore('settingsStore', () => {
 4:   const settings = ref({} as Settings)
 5: 
 6:   function toggleSettings(key: SettingsKey) {
 7:     settings.value[key] = !settings.value[key]
 8:   }
 9: 
10:   function isSettingsOn(key: SettingsKey) {
11:     return !settings.value[key]
12:   }
13: 
14:   return {
15:     settings,
16:     toggleSettings,
17:     isSettingsOn,
18:   }
19: })
20: 
21: if (import.meta.hot) {
22:   import.meta.hot.accept(acceptHMRUpdate(useUserSettingsStore, import.meta.hot))
23: }
```

## File: apps/main-app/composables/users/user.admin.composable.ts
```typescript
  1: import { useLogger } from '@ib/logger'
  2: import { emailUnvalidatedUserSchema } from '../../../auth-service/types/auth'
  3: import type { UserRowType } from '~/types/users'
  4: 
  5: interface NewUser {
  6:   email: string
  7:   password: string
  8: }
  9: 
 10: const DOMAIN_KEY = 'useAdmin'
 11: 
 12: export function useAdmin() {
 13:   const errors = useBaseError()
 14:   const log = useLogger(DOMAIN_KEY)
 15:   const utils = useUtils()
 16:   const client = useSupabaseClient()
 17:   const toast = useNotification()
 18:   const createdUsers = ref([] as NewUser[])
 19: 
 20:   const register = async ({ email, password }: { email: string; password: string }) => {
 21:     const { data, error } = await client.auth.signUp({
 22:       email,
 23:       password,
 24:     })
 25:     if (error) {
 26:       throw createError({
 27:         statusCode: 401,
 28:         message: error.message,
 29:       })
 30:     }
 31: 
 32:     const validatedUser = emailUnvalidatedUserSchema.safeParse(data.user)
 33: 
 34:     if (!validatedUser.success) {
 35:       throw createError(validatedUser.error)
 36:     }
 37: 
 38:     return validatedUser.data
 39:   }
 40: 
 41:   async function addProfilePicture(userId: string, file: File) {
 42:     try {
 43:       const { data, error } = await client.storage
 44:         .from('profile-public')
 45:         .upload(`${userId}/avatar/${file.name}`, file)
 46:       if (error) {
 47:         throw createError(
 48:           `Error uploading profile picture for user with ID ${userId}: ${error.message}`,
 49:         )
 50:       }
 51:       console.log(`Profile picture uploaded successfully for user with ID ${userId}`)
 52:     } catch (error) {
 53:       console.error(`Error uploading profile picture for user with ID ${userId}:`, error)
 54:     }
 55:   }
 56: 
 57:   async function registerManyUsers() {
 58:     const users: UserRowType[] = []
 59:     for (const user of users) {
 60:       // Extract the given name and surname
 61:       const givenName = user.given_name.charAt(0).toUpperCase() + user.given_name.slice(1)
 62:       const surname = user.surname.charAt(0).toUpperCase() + user.surname.slice(1)
 63: 
 64:       // Construct the password
 65:       const password = `${givenName}${surname}12345$`
 66: 
 67:       // Register the user
 68:       try {
 69:         // const newUser = await register({ email: user.email, password })
 70:         // we handle user profile creation with a database trigger
 71:         // now seed the database with the user data
 72:         // createdUsers.value.push({ email: user.email, password })
 73: 
 74:         // Locate the profile image file based on the user's given name and surname
 75:         const imageName = `${givenName.toLowerCase()}-${surname.toLowerCase()}.jpg`
 76:         const imagePath = `/data/seed/avatars/${imageName}` // Adjust the path as necessary
 77:         const imageFile = new File([await fetch(imagePath).then((r) => r.blob())], imageName, {
 78:           type: 'image/jpeg',
 79:         })
 80: 
 81:         console.log('file exists', imageFile.size)
 82:         // Upload the profile image
 83:         await addProfilePicture(newUser.id, imageFile)
 84: 
 85:         // update user profile with data
 86:         await updateSingle(user, newUser.id)
 87:       } catch (error) {
 88:         console.error(`Failed to register user with email ${user.email}:`, error)
 89:       }
 90:     }
 91:   }
 92: 
 93:   async function updateUser(newData: any, oldData: any) {
 94:     log.info(`Updating user with email ${newData.email}`)
 95:     // we should first parse the data to check if anything has changed and then filter out any undefined values
 96:     try {
 97:       const { noDataUpdated, data: updatedData } = utils.wasRowDataUpdated(newData, oldData)
 98: 
 99:       if (noDataUpdated) {
100:         log.info('No changes detected, no update necessary')
101:         return
102:       }
103: 
104:       const response = await $fetch('/api/users/update', {
105:         method: 'POST',
106:         body: {
107:           data: updatedData,
108:           id: newData.id,
109:         },
110:       })
111: 
112:       const data = errors.server({
113:         response,
114:         devOnly: false,
115:         showSuccess: true,
116:         devMessage: `Error updating user with email ${newData.email}`,
117:         userMessage: `There was an error updating user with email ${newData.email}`,
118:       })
119: 
120:       log.info(`User with email ${data.email} updated successfully`)
121:       toast.success({
122:         summary: 'Success',
123:         message: `User with email ${data.email} updated successfully`,
124:       })
125: 
126:       // maybe update state here
127:     } catch (error) {
128:       errors.client({
129:         error,
130:         devOnly: false,
131:         devMessage: `Error updating user with email ${newData.email}`,
132:         userMessage: `There was an error updating user with email ${newData.email}`,
133:       })
134:     }
135:   }
136: 
137:   return {
138:     registerManyUsers,
139:     updateUser,
140:     createdUsers,
141:   }
142: }
```

## File: apps/main-app/composables/category-tags.store.ts
```typescript
 1: import { z } from 'zod'
 2: import { useLogger } from '@ib/logger'
 3: 
 4: const CategorySchema = z.object({
 5:   id: z.number(),
 6:   name: z.string(),
 7:   body: z.string().nullish(),
 8:   created_at: z.string().optional(),
 9:   updated_at: z.string().optional(),
10: })
11: 
12: const TagSchema = z.object({
13:   id: z.number(),
14:   name: z.string(),
15:   body: z.string().nullish(),
16:   created_at: z.string().optional(),
17:   updated_at: z.string().optional(),
18: })
19: 
20: type Category = z.infer<typeof CategorySchema>
21: type Tag = z.infer<typeof TagSchema>
22: 
23: export const useCategoryTagStore = defineStore('categoryTagStore', () => {
24:   const logger = useLogger('categoryTagStore')
25:   const categories = ref<Category[]>([])
26:   const tags = ref<Tag[]>([])
27:   const localStorage = useBaseLocalStorage()
28:   const errors = useBaseError()
29: 
30:   const client = useSupabaseClient()
31: 
32:   async function getCategories() {
33:     try {
34:       categories.value = await localStorage.getCachedOrFetch('astronera-categories', async () => {
35:         const { data, error } = await client.from('categories').select('id, name')
36:         if (error) throw error
37:         return z.array(CategorySchema).parse(data)
38:       })
39:     } catch (error) {
40:       logger.error('Error fetching categories:', error)
41:       errors.server({
42:         error,
43:         devOnly: true,
44:         devMessage: 'Error Fetching Categories from DB',
45:         userMessage: 'There was an error getting Categories from the database',
46:       })
47:     }
48:   }
49: 
50:   async function getTags() {
51:     try {
52:       tags.value = await localStorage.getCachedOrFetch('astronera-tags', async () => {
53:         const { data, error } = await client.from('tags').select('id, name')
54:         if (error) throw error
55:         return z.array(TagSchema).parse(data)
56:       })
57:     } catch (error) {
58:       logger.error('Error fetching tags:', error)
59:       errors.server({
60:         error,
61:         devOnly: true,
62:         devMessage: 'Error Fetching Tags from DB',
63:         userMessage: 'There was an error getting Tags from the database',
64:       })
65:     }
66:   }
67: 
68:   const getCategoryName = computed(
69:     () => (categoryId: number) =>
70:       categories.value.find((category) => category.id === categoryId)?.name,
71:   )
72: 
73:   const getTagName = computed(
74:     () => (tagId: number) => tags.value.find((tag) => tag.id === tagId)?.name,
75:   )
76: 
77:   return {
78:     categories,
79:     tags,
80:     getCategories,
81:     getTags,
82:     getCategoryName,
83:     getTagName,
84:     clearAllCaches: localStorage.clearAllCaches,
85:   }
86: })
87: 
88: if (import.meta.hot) {
89:   import.meta.hot.accept(acceptHMRUpdate(useCategoryTagStore, import.meta.hot))
90: }
```

## File: apps/main-app/composables/chat.store.ts
```typescript
  1: import { z } from 'zod'
  2: import { useLogger } from '@ib/logger'
  3: 
  4: const ChatCompletionSchema = z.object({
  5:   id: z.string(),
  6:   object: z.string(),
  7:   created: z.number(),
  8:   model: z.string(),
  9:   system_fingerprint: z.string(),
 10:   choices: z.array(
 11:     z.object({
 12:       index: z.number(),
 13:       message: z.object({
 14:         role: z.string(),
 15:         content: z.string(),
 16:       }),
 17:       finish_reason: z.string(),
 18:       logprobs: z.null(),
 19:     }),
 20:   ),
 21:   usage: z.object({
 22:     prompt_tokens: z.number(),
 23:     completion_tokens: z.number(),
 24:     total_tokens: z.number(),
 25:     prompt_time: z.number(),
 26:     completion_time: z.number(),
 27:     total_time: z.number(),
 28:   }),
 29:   x_groq: z.object({
 30:     id: z.string(),
 31:   }),
 32: })
 33: 
 34: type Chat = z.infer<typeof ChatCompletionSchema>
 35: 
 36: export const useChatStore = defineStore('chatStore', () => {
 37:   const { fetch } = useBaseFetch()
 38:   const loading = useLoadingStore()
 39:   const client = useSupabaseClient()
 40:   const errors = useBaseError()
 41: 
 42:   const domainKey = 'chat'
 43:   const logger = useLogger(domainKey)
 44: 
 45:   const chat = ref({} as Chat)
 46:   const messages = ref<Array<{ role: 'user' | 'assistant' | 'system'; content: string }>>([])
 47: 
 48:   const question = ref('' as string)
 49: 
 50:   // function handleNavigation() {
 51:   //   const route = useRoute()
 52:   //   if (route.path === '/ask') {
 53:   //     return
 54:   //   }
 55:   //   navigateTo('/ask')
 56:   // }
 57: 
 58:   async function insertSearchData(userId: string) {
 59:     const response = await client
 60:       .from('searches')
 61:       .insert({
 62:         input: question.value,
 63:         created_at: new Date().toISOString(),
 64:         user_id: userId,
 65:       })
 66:       .select()
 67: 
 68:     return errors.server({
 69:       response,
 70:       devOnly: true,
 71:       devMessage: 'error inserting search data',
 72:       userMessage: 'something went wrong when inserting search data',
 73:     })
 74:   }
 75: 
 76:   async function insertResponseData(searchId: number, questionResponseData: Chat) {
 77:     const response = await client.from('responses').insert({
 78:       search_id: searchId,
 79:       output: questionResponseData.choices[0]?.message?.content,
 80:       created_at: new Date().toISOString(),
 81:     })
 82:     return errors.server({
 83:       response,
 84:       devOnly: true,
 85:       devMessage: 'error inserting response data',
 86:       userMessage: 'something went wrong when inserting response data',
 87:     })
 88:   }
 89: 
 90:   function addMessage(role: 'user' | 'assistant' | 'system', content: string) {
 91:     messages.value.push({ role, content })
 92:   }
 93: 
 94:   async function submitQuestion(args: { question: string; systemPrompt: string }) {
 95:     console.log('searchMessage', args)
 96: 
 97:     if (loading.isLoading(domainKey)) {
 98:       return null
 99:     }
100: 
101:     loading.setLoading(domainKey, true)
102: 
103:     try {
104:       addMessage('user', args.question)
105: 
106:       const messageHistory = messages.value.slice(-5) // Get last 5 messages
107: 
108:       const formattedMessages = [
109:         ...(args.systemPrompt ? [{ role: 'system', content: args.systemPrompt }] : []),
110:         ...messageHistory,
111:       ]
112: 
113:       const questionResponse = await fetch('/api/ai/ask', {
114:         method: 'POST',
115:         body: JSON.stringify({
116:           messages: formattedMessages,
117:         }),
118:         headers: {
119:           'Content-Type': 'application/json',
120:         },
121:       })
122: 
123:       const questionResponseData: Chat = errors.server({
124:         response: questionResponse,
125:         devOnly: true,
126:         devMessage: 'error fetching question response',
127:         userMessage: 'something went wrong when fetching question response',
128:       })
129: 
130:       addMessage('assistant', questionResponseData.choices[0]?.message?.content)
131: 
132:       // const search = await insertSearchData(userId)
133:       // insertResponseData(search[0].id, questionResponseData)
134:     } catch (error) {
135:       console.error('Error submitting question and handling response:', error)
136:     } finally {
137:       await loading.setLoadingInterval(domainKey, false, 1000)
138:     }
139:   }
140: 
141:   return {
142:     isLoading: computed(() => loading.isLoading(domainKey)),
143:     chat,
144:     question,
145:     messages,
146:     addMessage,
147:     submitQuestion,
148:   }
149: })
150: 
151: if (import.meta.hot) {
152:   import.meta.hot.accept(acceptHMRUpdate(useChatStore, import.meta.hot))
153: }
```

## File: apps/main-app/composables/chunks.store.ts
```typescript
  1: import { useLogger } from '@ib/logger'
  2: 
  3: interface BaseNotification {
  4:   summary: string
  5:   message: string
  6: }
  7: 
  8: export const useChunksStore = defineStore('chunksStore', () => {
  9:   const log = useLogger('chunksStore')
 10:   const toast = useNotification()
 11:   const client = useSupabaseClient()
 12: 
 13:   const chunks = ref<any[]>([])
 14: 
 15:   async function flagChunk(chunkId: number, is_flagged: boolean) {
 16:     console.log('flagChunk:', chunkId, is_flagged)
 17:     try {
 18:       const { data, error } = await client
 19:         .from('research_embeddings')
 20:         .update({ is_flagged: !is_flagged })
 21:         .eq('id', chunkId)
 22:         .select()
 23: 
 24:       console.log('flagChunk: res', data, error)
 25:       if (error) {
 26:         throw new Error(error.message)
 27:       }
 28: 
 29:       if (!data || data.length === 0) {
 30:         return
 31:       }
 32: 
 33:       const updatedChunk = data[0]
 34: 
 35:       if (updatedChunk.is_flagged) {
 36:         flaggedChunks.value.push(updatedChunk)
 37:         chunks.value = chunks.value.filter((chunk: any) => chunk.id !== updatedChunk.id)
 38:       } else {
 39:         flaggedChunks.value = flaggedChunks.value.filter(
 40:           (chunk: any) => chunk.id !== updatedChunk.id,
 41:         )
 42:         chunks.value.push(updatedChunk)
 43:       }
 44:     } catch (error: any) {
 45:       throw new Error(error.message)
 46:     }
 47:   }
 48: 
 49:   const flaggedChunks = ref<any[]>([])
 50:   async function fetchChunks(isFlagged: boolean = false, maxChunks: number = 100) {
 51:     try {
 52:       let query = client
 53:         .from('research_embeddings')
 54:         .select('id, research_id, chunk, url, is_flagged')
 55:         .eq('is_flagged', isFlagged)
 56:         .range(0, maxChunks)
 57:       console.log('working 1')
 58: 
 59:       if (isFlagged) {
 60:         query = query.order('updated_at', { ascending: false })
 61:       } else {
 62:         console.log('working 2')
 63:         query = query.order('created_at', { ascending: false })
 64:       }
 65: 
 66:       const { data, error } = await query
 67:       console.log('working 3', data, error)
 68: 
 69:       if (error) {
 70:         throw new Error(error.message)
 71:       }
 72: 
 73:       if (isFlagged) {
 74:         flaggedChunks.value.push(...data)
 75:       } else {
 76:         chunks.value.push(...data)
 77:       }
 78:     } catch (error: any) {
 79:       log.error('fetchChunks:', error)
 80:       throw new Error(error.message)
 81:     }
 82:   }
 83: 
 84:   const similarChunks = ref<any[]>([])
 85:   interface SimilarDocs {
 86:     search: string
 87:     searchType: 'fts' | 'vector'
 88:     matchThreshold?: number
 89:     matchCount?: number
 90:   }
 91: 
 92:   async function fetchSimilarDocuments({
 93:     search,
 94:     searchType,
 95:     matchThreshold = 0.41,
 96:     matchCount = 25,
 97:   }: SimilarDocs) {
 98:     try {
 99:       const userId = useCookie('userId').value!
100:       let response
101: 
102:       if (searchType === 'vector') {
103:         response = await client.functions.invoke('openai', {
104:           method: 'POST',
105:           body: {
106:             query: search,
107:             match_threshold: matchThreshold,
108:             match_count: matchCount,
109:             user_id: userId,
110:           },
111:         })
112: 
113:         if (!response.data) {
114:           return
115:         }
116:       } else {
117:         const formattedSearch = search.replaceAll(' ', ' & ')
118:         response = await client.from('research').select().textSearch('fts', formattedSearch)
119:       }
120: 
121:       similarChunks.value.push(...response.data)
122:     } catch (error: any) {
123:       throw new Error(error.message)
124:     }
125:   }
126: 
127:   async function deleteChunk(chunkId: number) {
128:     log.info('deleteChunk:', chunkId)
129:     try {
130:       const { error } = await client.from('research_embeddings').delete().eq('id', chunkId)
131: 
132:       console.log('deleteChunk: res', error)
133:       if (error) {
134:         throw new Error(error.message)
135:       }
136: 
137:       flaggedChunks.value = flaggedChunks.value.filter((chunk: any) => chunk.id !== chunkId)
138:       toast.info({ summary: 'Chunk Deleted', message: 'The chunk has been deleted' })
139:     } catch (error: any) {
140:       toast.error({ summary: 'Error Deleting Chunk', message: error.message })
141:       throw new Error(error.message)
142:     }
143:   }
144: 
145:   function cleanText(text: string) {
146:     // Regular expression to match the pattern [chars(num/char/|)]
147:     const withoutPlaceholders = text.replace(/\[research_.*?\([^\)]+\)\]/g, '')
148: 
149:     return withoutPlaceholders
150:       .replace(/undefined/g, '')
151:       .replace(/ ,/g, ',')
152:       .replace(/ ,/g, '')
153:       .replace(/ :/g, ':')
154:       .replace(/ \./g, '.')
155:       .replace(/ ;/g, ';')
156:       .replace(/ \(/g, '(')
157:       .replace(/ \)/g, ')')
158:       .replace(/\s+/g, ' ')
159:       .trim()
160:   }
161: 
162:   return {
163:     flagChunk,
164:     fetchChunks,
165:     fetchSimilarDocuments,
166:     deleteChunk,
167:     cleanText,
168:     chunks,
169:     similarChunks,
170:     flaggedChunks,
171:   }
172: })
173: 
174: if (import.meta.hot) {
175:   import.meta.hot.accept(acceptHMRUpdate(useChunksStore, import.meta.hot))
176: }
```

## File: apps/main-app/composables/feedback.store.ts
```typescript
 1: import { useLogger } from '@ib/logger'
 2: 
 3: export const useFeedbackStore = defineStore('feedbackStore', () => {
 4:   const { fetch } = useBaseFetch()
 5:   const storeKey = 'feedbacks'
 6:   const logger = useLogger(storeKey)
 7:   const loading = useLoadingStore()
 8:   const toast = useNotification()
 9: 
10:   async function submitFeedback(newFeedback: any) {
11:     console.log('newFeedback', newFeedback)
12: 
13:     if (loading.isLoading(storeKey)) {
14:       return null
15:     }
16: 
17:     loading.setLoading(storeKey, true)
18: 
19:     try {
20:       const response = await fetch('/api/feedback/insert/single', {
21:         method: 'POST',
22:         body: newFeedback,
23:       })
24: 
25:       toast.info({ summary: 'Feedback Sent', message: response.message })
26:     } catch (error: any) {
27:       toast.error({ summary: 'Feedback Not Sent', message: error.message })
28:       logger.error('Error submitting question and handling response:', error)
29:     } finally {
30:       await loading.setLoadingInterval(storeKey, false, 1000)
31:     }
32:   }
33: 
34:   return {
35:     submitFeedback,
36:   }
37: })
38: 
39: if (import.meta.hot) {
40:   import.meta.hot.accept(acceptHMRUpdate(useFeedbackStore, import.meta.hot))
41: }
```

## File: apps/main-app/composables/onboarding.composable.ts
```typescript
 1: import { ref, reactive } from 'vue'
 2: import type { ZodSchema, z } from 'zod'
 3: 
 4: const accountDetailsSchema = z.object({
 5:   dateOfBirth: z.date().max(new Date(), 'Date of birth cannot be in the future'),
 6: })
 7: 
 8: const professionalInfoSchema = z.object({
 9:   occupation: z.string().min(1, 'Please select an occupation'),
10:   organization: z.string().min(2, 'Organization name must be at least 2 characters'),
11:   experience: z
12:     .number()
13:     .min(0, 'Experience cannot be negative')
14:     .max(100, 'Experience cannot exceed 100 years'),
15: })
16: 
17: export interface SignupForm {
18:   dateOfBirth: Date | null
19:   occupation: string
20:   organization: string
21:   experience: number | null
22:   interests: string[]
23: }
24: 
25: export function useOnboarding() {
26:   const form = reactive<SignupForm>({
27:     dateOfBirth: null,
28:     occupation: '',
29:     organization: '',
30:     experience: null,
31:     interests: [],
32:   })
33: 
34:   const errors = reactive<Partial<Record<keyof SignupForm, string>>>({})
35: 
36:   const validateAndUpdate = (schema: ZodSchema) => {
37:     const result = schema.safeParse(form)
38:     if (result.success) {
39:       Object.keys(errors).forEach((key) => delete errors[key as keyof SignupForm])
40:       return true
41:     } else {
42:       result.error.issues.forEach((issue) => {
43:         errors[issue.path[0] as keyof SignupForm] = issue.message
44:       })
45:       return false
46:     }
47:   }
48: 
49:   return {
50:     form,
51:     errors,
52:     validateAndUpdate,
53:     professionalInfoSchema,
54:     accountDetailsSchema,
55:   }
56: }
```

## File: apps/main-app/composables/useBookmarkManager.ts
```typescript
 1: // useBookmarkManager.ts
 2: import type { Folder } from '../types/bookmarks'
 3: 
 4: export const useBookmarkManager = () => {
 5:   const selectedBookmarks = ref<string[]>([])
 6:   const showMoveModal = ref(false)
 7:   const targetFolderId = ref<string | null>(null)
 8:   const { moveBookmarks, fetchBookmarks } = useBookmarks()
 9: 
10:   const toggleBookmarkSelection = (bookmarkId: string) => {
11:     const index = selectedBookmarks.value.indexOf(bookmarkId)
12:     if (index === -1) {
13:       selectedBookmarks.value.push(bookmarkId)
14:     } else {
15:       selectedBookmarks.value.splice(index, 1)
16:     }
17:   }
18: 
19:   const handleMoveBookmarks = async () => {
20:     if (!targetFolderId.value) return
21: 
22:     await moveBookmarks(selectedBookmarks.value, targetFolderId.value)
23:     selectedBookmarks.value = []
24:     showMoveModal.value = false
25:     targetFolderId.value = null
26:   }
27: 
28:   const handleDeleteBookmark = async (bookmarkId: string | string[]) => {
29:     const ids = Array.isArray(bookmarkId) ? bookmarkId : [bookmarkId]
30: 
31:     await Promise.all(
32:       ids.map((id) =>
33:         $fetch(`/api/bookmarks/${id}`, {
34:           method: 'DELETE',
35:         }),
36:       ),
37:     )
38: 
39:     await fetchBookmarks({})
40:     selectedBookmarks.value = selectedBookmarks.value.filter((id) => !ids.includes(id))
41:   }
42: 
43:   const handleNewFolder = async (folderData: Partial<Folder>) => {
44:     const { createFolder } = useFolderSystem()
45:     return await createFolder(folderData)
46:   }
47: 
48:   const handleMoveSubmit = async (targetFolder: Folder) => {
49:     targetFolderId.value = targetFolder.id
50:     await handleMoveBookmarks()
51:   }
52: 
53:   return {
54:     selectedBookmarks,
55:     showMoveModal,
56:     targetFolderId,
57:     toggleBookmarkSelection,
58:     handleMoveBookmarks,
59:     handleDeleteBookmark,
60:     handleNewFolder,
61:     handleMoveSubmit,
62:   }
63: }
```

## File: apps/main-app/composables/useBookmarks.ts
```typescript
  1: // useBookmarks.ts
  2: import Fuse from 'fuse.js'
  3: 
  4: interface BookmarkContent {
  5:   id: string
  6:   type: string
  7:   title: string
  8:   description?: string
  9:   thumbnail?: string
 10:   url?: string
 11: }
 12: 
 13: interface BookmarkParams {
 14:   content_type?: string
 15:   folder_id?: string
 16:   include_subfolders?: boolean
 17: }
 18: 
 19: interface Bookmark {
 20:   id: string
 21:   user_id: string
 22:   folder_id: string | null
 23:   content_type: string
 24:   content_id: string
 25:   metadata: {
 26:     title: string
 27:     description?: string
 28:     thumbnail?: string
 29:     url?: string
 30:   }
 31:   created_at: string
 32:   folder?: {
 33:     id: string
 34:     name: string
 35:     color: string
 36:     is_favorite: boolean
 37:   }
 38: }
 39: 
 40: export const useBookmarks = () => {
 41:   const bookmarks = ref<Bookmark[]>([])
 42:   const bookmarkCache = new Map<string, boolean>()
 43:   const error = ref<string | null>(null)
 44: 
 45:   const loading = ref(false)
 46:   const { getDefaultFolder } = useFolderSystem()
 47: 
 48:   const updateCache = (
 49:     item: { content_type: string; content_id: string } | null,
 50:     isBookmarked: boolean,
 51:     data?: Bookmark,
 52:   ) => {
 53:     if (!item) return
 54:     if (data) {
 55:       bookmarks.value.push(data)
 56:     } else if (!data && !isBookmarked) {
 57:       const index = bookmarks.value.findIndex(
 58:         (bookmark) =>
 59:           bookmark.content_id === item.content_id && bookmark.content_type === item.content_type,
 60:       )
 61:       if (index > -1) {
 62:         bookmarks.value.splice(index, 1)
 63:       }
 64:     }
 65: 
 66:     const cacheKey = `${item.content_type}:${item.content_id}`
 67:     bookmarkCache.set(cacheKey, isBookmarked)
 68:   }
 69: 
 70:   const updateBatchCache = (
 71:     items: Array<{ content_type: string; content_id: string }>,
 72:     isBookmarked: boolean,
 73:   ) => {
 74:     items.forEach((item) => updateCache(item, isBookmarked))
 75:   }
 76: 
 77:   const init = async () => {
 78:     const session = await useSupabaseSession()
 79:     if (session.value) {
 80:       await fetchBookmarks({})
 81:     }
 82:   }
 83: 
 84:   const isNewsBookmarked = computed(() => {
 85:     return (newsId: string) => {
 86:       // Check if this news ID exists in our bookmarks
 87:       return bookmarks.value.some(
 88:         (bookmark) => bookmark.content_id === newsId && bookmark.content_type === 'news',
 89:       )
 90:     }
 91:   })
 92: 
 93:   const fetchBookmarks = async (params: BookmarkParams) => {
 94:     loading.value = true
 95:     error.value = null
 96: 
 97:     try {
 98:       // Get last month of bookmarks by default if no specific params
 99: 
100:       const defaultParams = {
101:         content_type: 'news',
102:         created_at: 'gte.' + new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString(),
103:         ...params,
104:       }
105: 
106:       const response = await $fetch('/api/bookmarks', {
107:         params: {
108:           params: defaultParams,
109:           include_subfolders: true,
110:         },
111:       })
112: 
113:       bookmarks.value = response.data || []
114: 
115:       // Update cache with current bookmarks
116:       updateBatchCache(
117:         bookmarks.value.map((bookmark) => ({
118:           content_type: bookmark.content_type,
119:           content_id: bookmark.content_id,
120:         })),
121:         true,
122:       )
123:     } catch (e) {
124:       error.value = 'Failed to fetch bookmarks'
125:       bookmarks.value = []
126:     } finally {
127:       loading.value = false
128:     }
129:   }
130: 
131:   // Update toggleBookmark to use the new cache function
132:   const toggleBookmark = async (content: BookmarkContent) => {
133:     const { getDefaultFolder } = useFolderSystem()
134: 
135:     const response = await $fetch('/api/bookmarks/toggle', {
136:       method: 'POST',
137:       body: {
138:         content_id: content.id,
139:         content_type: content.type,
140:         folder_id: getDefaultFolder.value?.id,
141:         metadata: {
142:           title: content.title,
143:           description: content.description,
144:           thumbnail: content.thumbnail,
145:           url: content.url,
146:         },
147:       },
148:     })
149: 
150:     const isBookmarked = response.bookmarked ?? false
151:     updateCache(
152:       {
153:         content_type: content.type,
154:         content_id: content.id,
155:       },
156:       isBookmarked,
157:       response.data,
158:     )
159: 
160:     return response.data
161:   }
162: 
163:   // Update isBookmarked to use the new cache function
164:   const isBookmarked = async (contentId: string, contentType: string = 'news') => {
165:     const cacheKey = `${contentType}:${contentId}`
166: 
167:     if (bookmarkCache.has(cacheKey)) {
168:       return bookmarkCache.get(cacheKey)
169:     }
170: 
171:     const response = await $fetch('/api/bookmarks/check', {
172:       params: { content_id: contentId, content_type: contentType },
173:     })
174: 
175:     updateCache(
176:       {
177:         content_type: contentType,
178:         content_id: contentId,
179:       },
180:       !!response.data,
181:     )
182: 
183:     return !!response.data
184:   }
185: 
186:   const createBookmark = async (content: BookmarkContent, folderId?: string) => {
187:     const folder_id = folderId || getDefaultFolder.value?.id
188: 
189:     const response = await $fetch('/api/bookmarks/create', {
190:       method: 'POST',
191:       body: {
192:         content_id: content.id,
193:         content_type: content.type,
194:         folder_id,
195:         metaresponse: {
196:           title: content.title,
197:           description: content.description,
198:           thumbnail: content.thumbnail,
199:         },
200:       },
201:     })
202:     return response.data
203:   }
204: 
205:   const moveBookmarks = async (bookmarkIds: string[], targetFolderId: string) => {
206:     const response = await $fetch('/api/bookmarks/move', {
207:       method: 'PATCH',
208:       body: {
209:         bookmarkIds,
210:         targetFolderId,
211:       },
212:     })
213: 
214:     await fetchBookmarks({})
215: 
216:     return response.data
217:   }
218: 
219:   const searchBookmarks = (query: string) => {
220:     const fuse = new Fuse(bookmarks.value, {
221:       keys: ['metadata.title', 'metadata.description'],
222:       threshold: 0.3,
223:     })
224: 
225:     return fuse.search(query)
226:   }
227: 
228:   const clearCache = () => bookmarkCache.clear()
229: 
230:   onMounted(() => {
231:     init()
232:   })
233: 
234:   return {
235:     bookmarks,
236:     loading,
237:     init,
238:     fetchBookmarks,
239: 
240:     searchBookmarks,
241:     toggleBookmark,
242:     createBookmark,
243:     moveBookmarks,
244:     isNewsBookmarked,
245:     isBookmarked,
246:   }
247: }
```

## File: apps/main-app/composables/useBookmarkView.ts
```typescript
 1: // useBookmarkView.ts
 2: import type { Folder } from '../types/bookmarks'
 3: 
 4: export const useBookmarkView = () => {
 5:   const viewMode = ref<'grid' | 'list'>('grid')
 6:   const searchQuery = ref('')
 7:   const includeSubfolders = ref(true)
 8:   const showFolderPanel = ref(false)
 9:   const showNewFolderModal = ref(false)
10:   const currentFolder = ref<Folder | null>(null)
11: 
12:   const handleFolderSelect = async (folder: Folder) => {
13:     currentFolder.value = folder
14:     const { fetchBookmarks } = useBookmarks()
15:     await fetchBookmarks({
16:       folder_id: folder.id,
17:       include_subfolders: includeSubfolders.value,
18:     })
19: 
20:     // On mobile, close the folder panel after selection
21:     if (import.meta.client && window.innerWidth < 768) {
22:       showFolderPanel.value = false
23:     }
24:   }
25: 
26:   const toggleFolderPanel = () => {
27:     showFolderPanel.value = !showFolderPanel.value
28:   }
29: 
30:   const debouncedSearch = useDebounceFn((query: string) => {
31:     // Implement search logic here
32:     console.log('Searching:', query)
33:   }, 300)
34: 
35:   watch(searchQuery, (newQuery) => {
36:     debouncedSearch(newQuery)
37:   })
38: 
39:   return {
40:     viewMode,
41:     searchQuery,
42:     includeSubfolders,
43:     showFolderPanel,
44:     showNewFolderModal,
45:     currentFolder,
46:     handleFolderSelect,
47:     toggleFolderPanel,
48:   }
49: }
```

## File: apps/main-app/composables/useFolderSystem.ts
```typescript
  1: import { useErrorHandler } from '@ib/logger'
  2: import type { Folder } from '~/types/folder'
  3: 
  4: export const useFolderSystem = () => {
  5:   const folders = ref<Folder[]>([])
  6:   const loading = ref(false)
  7:   const errorHandler = useErrorHandler('FolderSystem')
  8: 
  9:   const fetchFolders = async () => {
 10:     loading.value = true
 11:     try {
 12:       const response = await $fetch('/api/folders')
 13:       const data = errorHandler.handleFetchError({
 14:         response,
 15:         devMessage: 'Failed to fetch folders',
 16:         userMessage: 'Unable to load folders',
 17:       })
 18:       folders.value = data || []
 19:     } catch (error) {
 20:       errorHandler.handleError(error, {
 21:         context: 'fetchFolders',
 22:         userMessage: 'Failed to load folders',
 23:       })
 24:       folders.value = []
 25:     } finally {
 26:       loading.value = false
 27:     }
 28:   }
 29: 
 30:   const createFolder = async (folder: Partial<Folder>) => {
 31:     loading.value = true
 32:     try {
 33:       const response = await $fetch('/api/folders', {
 34:         method: 'POST',
 35:         body: folder,
 36:       })
 37:       const data = errorHandler.handleFetchError({
 38:         response,
 39:         devMessage: 'Failed to create folder',
 40:         userMessage: 'Unable to create folder',
 41:       })
 42:       if (data) {
 43:         await fetchFolders()
 44:       }
 45:       return data
 46:     } catch (error) {
 47:       errorHandler.handleError(error, {
 48:         context: 'createFolder',
 49:         userMessage: 'Failed to create folder',
 50:       })
 51:       return null
 52:     } finally {
 53:       loading.value = false
 54:     }
 55:   }
 56: 
 57:   const updateFolder = async (folderId: string, updates: Partial<Folder>) => {
 58:     loading.value = true
 59:     try {
 60:       const response = await $fetch(`/api/folders/${folderId}`, {
 61:         method: 'PATCH',
 62:         body: updates,
 63:       })
 64:       const data = errorHandler.handleFetchError({
 65:         response,
 66:         devMessage: `Failed to update folder ${folderId}`,
 67:         userMessage: 'Unable to update folder',
 68:       })
 69:       if (data) {
 70:         await fetchFolders()
 71:       }
 72:       return data
 73:     } catch (error) {
 74:       errorHandler.handleError(error, {
 75:         context: 'updateFolder',
 76:         userMessage: 'Failed to update folder',
 77:       })
 78:       return null
 79:     } finally {
 80:       loading.value = false
 81:     }
 82:   }
 83: 
 84:   const deleteFolder = async (folderId: string) => {
 85:     loading.value = true
 86:     try {
 87:       const response = await $fetch(`/api/folders/${folderId}`, {
 88:         method: 'DELETE',
 89:       })
 90:       const data = errorHandler.handleFetchError({
 91:         response,
 92:         devMessage: `Failed to delete folder ${folderId}`,
 93:         userMessage: 'Unable to delete folder',
 94:       })
 95:       if (data !== null) {
 96:         await fetchFolders()
 97:       }
 98:       return true
 99:     } catch (error) {
100:       errorHandler.handleError(error, {
101:         context: 'deleteFolder',
102:         userMessage: 'Failed to delete folder',
103:       })
104:       return false
105:     } finally {
106:       loading.value = false
107:     }
108:   }
109: 
110:   // Initialize folders
111:   onMounted(() => {
112:     fetchFolders()
113:   })
114: 
115:   // Computed properties for convenience
116:   const getDefaultFolder = computed(() => folders.value.find((f) => f.is_default) || null)
117:   const getFavorites = computed(() => folders.value.filter((f) => f.is_favorite) || [])
118: 
119:   return {
120:     folders,
121:     loading,
122:     fetchFolders,
123:     createFolder,
124:     updateFolder,
125:     deleteFolder,
126:     getDefaultFolder,
127:     getFavorites,
128:   }
129: }
```

## File: apps/main-app/composables/usePages.ts
```typescript
  1: import { ref } from 'vue'
  2: 
  3: export interface PageType {
  4:   id: string
  5:   label: string
  6:   slug: string
  7:   icon: string
  8:   children?: PageType[]
  9: }
 10: 
 11: export interface NavigationCategory {
 12:   id: string
 13:   label: string
 14:   items: PageType[]
 15: }
 16: 
 17: const navigationCategories = ref([
 18:   {
 19:     id: 'main',
 20:     label: 'Main',
 21:     items: [
 22:       {
 23:         id: 1,
 24:         label: 'Home',
 25:         slug: '/',
 26:         icon: 'material-symbols:home-rounded',
 27:       },
 28:     ],
 29:   },
 30:   {
 31:     id: 'news',
 32:     label: 'News',
 33:     items: [
 34:       {
 35:         id: '2',
 36:         label: 'Feed',
 37:         slug: '/news',
 38:         icon: 'mdi:newspaper-variant-outline',
 39:       },
 40:       {
 41:         id: '3',
 42:         label: '+ Create Feed',
 43:         slug: '/feed/add',
 44:         icon: 'mdi:plus',
 45:       },
 46:     ],
 47:   },
 48:   {
 49:     id: 'profile',
 50:     label: 'Profile',
 51:     items: [
 52:       {
 53:         id: 4,
 54:         label: 'Upvoted',
 55:         slug: '/profile/votes/upvoted',
 56:         icon: 'mdi:arrow-up-bold',
 57:       },
 58:       {
 59:         id: 5,
 60:         label: 'Downvoted',
 61:         slug: '/profile/votes/downvoted',
 62:         icon: 'mdi:arrow-down-bold',
 63:       },
 64:       {
 65:         id: 6,
 66:         label: 'Bookmarks',
 67:         slug: '/profile/bookmarks',
 68:         icon: 'mdi:bookmark-outline',
 69:       },
 70:     ],
 71:   },
 72: ] as NavigationCategory[])
 73: 
 74: export default function usePages() {
 75:   const client = useSupabaseClient()
 76:   const { profile } = useCurrentUser()
 77: 
 78:   const addFeed = (id: string, label: string) => {
 79:     const newsCategory = navigationCategories.value.find((cat) => cat.id === 'news')
 80: 
 81:     if (!newsCategory.items.some((item) => item.id === id)) {
 82:       newsCategory.items.push({
 83:         id,
 84:         label,
 85:         slug: `/feed/${id}`,
 86:         icon: 'mdi:newspaper-variant-multiple-outline',
 87:       })
 88:     }
 89:   }
 90: 
 91:   const deleteFeed = (feedId: string) => {
 92:     const newsCategory = navigationCategories.value.find((cat) => cat.id === 'news')
 93:     const index = newsCategory.items.findIndex((item) => item.id == feedId)
 94: 
 95:     if (index > -1) {
 96:       newsCategory.items.splice(index, 1)
 97:     }
 98:   }
 99: 
100:   const initializeFeeds = () => {
101:     if (profile.id) {
102:       const toast = useNotification()
103:       client
104:         .from('feeds')
105:         .select('id, name')
106:         .eq('user_id', profile.id)
107:         .then(({ data, error }) => {
108:           if (error) {
109:             toast.error({
110:               summary: 'Failed to get custom feeds',
111:               message: 'Could not get custom feeds',
112:             })
113:             return
114:           }
115: 
116:           // Add custom feeds to the News category
117:           const newsCategory = navigationCategories.value.find((cat) => cat.id === 'news')
118:           if (newsCategory) {
119:             data.forEach((feed) => {
120:               if (!newsCategory.items.some((item) => item.id === feed.id)) {
121:                 newsCategory.items.push({
122:                   id: feed.id,
123:                   label: feed.name,
124:                   slug: `/feed/${feed.id}`,
125:                   icon: 'mdi:newspaper-variant-multiple-outline',
126:                 })
127:               }
128:             })
129:           }
130:         })
131:     }
132:   }
133: 
134:   onMounted(initializeFeeds)
135: 
136:   return {
137:     appLinks: navigationCategories,
138:     addFeed,
139:     deleteFeed,
140:   }
141: }
```

## File: apps/main-app/composables/usePayments.ts
```typescript
 1: import { ref } from 'vue'
 2: import { useRuntimeConfig } from '#app'
 3: 
 4: export const usePayments = (provider: 'razorpay' | 'stripe') => {
 5:   const config = useRuntimeConfig()
 6:   const isLoading = ref(false)
 7:   const error = ref(null)
 8: 
 9:   const initializePayment = async (options: any) => {
10:     isLoading.value = true
11:     error.value = null
12: 
13:     try {
14:       if (provider === 'razorpay') {
15:         const razorpay = new (window as any).Razorpay({
16:           key: 'rzp_test_lV0OE0NDIg6Hr6',
17:           ...options,
18:         })
19:         razorpay.open()
20:       } else if (provider === 'stripe') {
21:         // Placeholder for Stripe implementation
22:         console.log('Stripe payment initialization', options)
23:       }
24:     } catch (error: any) {
25:       console.error(`Error initializing payment with ${provider}:`, error)
26:     } finally {
27:       isLoading.value = false
28:     }
29:   }
30: 
31:   const createOrder = async (planId: string) => {
32:     isLoading.value = true
33:     error.value = null
34: 
35:     try {
36:       const response = await $fetch(`/api/payment/${provider}/create-order`, {
37:         method: 'POST',
38:         body: { plan_id: planId },
39:       })
40:       return response
41:     } catch (error) {
42:       console.error(`Error creating order with ${provider}:`, error)
43:     } finally {
44:       isLoading.value = false
45:     }
46:   }
47: 
48:   const verifyPayment = async (paymentData: any) => {
49:     isLoading.value = true
50:     error.value = null
51: 
52:     try {
53:       const response = await $fetch(`/api/payment/${provider}/verify-payment`, {
54:         method: 'POST',
55:         body: paymentData,
56:       })
57:       return response
58:     } catch (error: any) {
59:       console.error(`Error verifying payment with ${provider}:`, error)
60:     } finally {
61:       isLoading.value = false
62:     }
63:   }
64: 
65:   const fetchSubscription = async () => {
66:     isLoading.value = true
67:     error.value = null
68: 
69:     try {
70:       const response = await $fetch(`/api/payment/${provider}/subscription`)
71:       return response
72:     } catch (error: any) {
73:       console.error(`Error verifying payment with ${provider}:`, error)
74:     } finally {
75:       isLoading.value = false
76:     }
77:   }
78: 
79:   return {
80:     isLoading,
81:     error,
82:     initializePayment,
83:     createOrder,
84:     verifyPayment,
85:     fetchSubscription,
86:   }
87: }
```

## File: apps/main-app/composables/usePlan.ts
```typescript
 1: import { FEATURES } from '#shared/constants'
 2: 
 3: // composables/usePlan.ts
 4: export enum PlanType {
 5:   FREE = 'free',
 6:   PRO = 'pro',
 7: }
 8: 
 9: export interface PlanFeature {
10:   name: string
11:   limit: {
12:     [PlanType.FREE]: number
13:     [PlanType.PRO]: number
14:   }
15:   description: string
16:   comingSoon?: boolean
17: }
18: 
19: export const usePlan = () => {
20:   // For now, we'll assume everyone is on free plan
21:   // Later this can be updated based on your auth/subscription system
22:   const userPlan = ref<PlanType>(PlanType.FREE)
23: 
24:   // Utility functions
25:   const getFeatureLimit = (featureKey: keyof typeof FEATURES) => {
26:     return FEATURES[featureKey].limit[userPlan.value]
27:   }
28: 
29:   const isFeatureAvailable = (featureKey: keyof typeof FEATURES) => {
30:     const feature = FEATURES[featureKey]
31:     return !feature.comingSoon && getFeatureLimit(featureKey) !== 0
32:   }
33: 
34:   const checkFeatureLimit = async (
35:     featureKey: keyof typeof FEATURES,
36:     currentCount: number,
37:   ): Promise<boolean> => {
38:     const limit = getFeatureLimit(featureKey)
39:     return limit === -1 || currentCount < limit
40:   }
41: 
42:   const getUpgradeMessage = (featureKey: keyof typeof FEATURES) => {
43:     const feature = FEATURES[featureKey]
44:     if (userPlan.value === PlanType.FREE) {
45:       return feature.limit.pro === -1
46:         ? `Upgrade to Pro for unlimited ${feature.name}`
47:         : `Upgrade to Pro for up to ${feature.limit.pro} ${feature.name}`
48:     }
49:     return ''
50:   }
51: 
52:   // This can be used to show remaining quota
53:   const getFeatureUsage = (featureKey: keyof typeof FEATURES, currentCount: number) => {
54:     const limit = getFeatureLimit(featureKey)
55:     return {
56:       used: currentCount,
57:       limit,
58:       remaining: limit === -1 ? -1 : limit - currentCount,
59:       isUnlimited: limit === -1,
60:     }
61:   }
62: 
63:   return {
64:     FEATURES,
65:     userPlan,
66:     getFeatureLimit,
67:     isFeatureAvailable,
68:     checkFeatureLimit,
69:     getUpgradeMessage,
70:     getFeatureUsage,
71:   }
72: }
```

## File: apps/main-app/composables/usePWA.ts
```typescript
 1: export const usePWA = () => {
 2:   const nuxtApp = useNuxtApp()
 3:   const { $pwaState, $pwaActions } = nuxtApp
 4: 
 5:   if (!$pwaState || !$pwaActions) {
 6:     throw new Error('PWA plugin not installed')
 7:   }
 8: 
 9:   return {
10:     // States
11:     isInstallable: $pwaState.isInstallable,
12:     isUpdateAvailable: $pwaState.isUpdateAvailable,
13:     isOfflineReady: $pwaState.isOfflineReady,
14:     isPWAInstalled: $pwaState.isPWAInstalled,
15:     hasError: $pwaState.hasError,
16:     isActivated: $pwaState.isActivated,
17: 
18:     // Actions
19:     install: $pwaActions.install,
20:     update: $pwaActions.update,
21:     cancelInstall: $pwaActions.cancelInstall,
22:     cancelUpdate: $pwaActions.cancelUpdate,
23:   }
24: }
```

## File: apps/main-app/composables/useVotesStore.ts
```typescript
  1: // stores/useVoteStore.ts
  2: import { defineStore } from 'pinia'
  3: import { ref, computed } from 'vue'
  4: 
  5: interface VoteResponse {
  6:   success: boolean
  7:   action: 'voted' | 'removed'
  8: }
  9: 
 10: export const useVoteStore = defineStore('votes', () => {
 11:   // State
 12:   const votes = ref<Record<string, number>>({})
 13:   const userVotes = ref<Record<string, number>>({})
 14:   const pendingVotes = ref<Record<string, Promise<VoteResponse>>>({})
 15:   const isLoading = ref(false)
 16:   const error = ref<Error | null>(null)
 17: 
 18:   // Getters
 19:   const getVoteType = computed(() => {
 20:     return (contentId: string): number | null => userVotes.value[contentId] ?? null
 21:   })
 22: 
 23:   const getScore = computed(() => {
 24:     return (contentId: string): number | null => votes.value[contentId] ?? null
 25:   })
 26: 
 27:   const isVotePending = computed(() => {
 28:     return (contentId: string): boolean => !!pendingVotes.value[contentId]
 29:   })
 30: 
 31:   // Actions
 32:   const fetchUserVotes = async () => {
 33:     if (isLoading.value) return
 34: 
 35:     isLoading.value = true
 36:     error.value = null
 37: 
 38:     try {
 39:       const response = await $fetch('/api/votes/user')
 40:       userVotes.value = response.votes
 41:     } catch (err) {
 42:       console.error('Error fetching votes:', err)
 43:       error.value = err as Error
 44:       throw err
 45:     } finally {
 46:       isLoading.value = false
 47:     }
 48:   }
 49: 
 50:   const fetchVotedPosts = async (voteType: 1 | -1) => {
 51:     try {
 52:       const response = await $fetch(`/api/votes/user/${voteType}`)
 53:       return response
 54:     } catch (err) {
 55:       console.error('Error fetching voted posts:', err)
 56:       error.value = err as Error
 57:       throw err
 58:     }
 59:   }
 60: 
 61:   const setVotes = (contentId: string, score: number) => {
 62:     votes.value[contentId] = score
 63:   }
 64: 
 65:   const submitVote = async (
 66:     contentId: string,
 67:     voteType: number,
 68:     { success: successNotify, error: errorNotify }: ReturnType<typeof useNotification>,
 69:   ) => {
 70:     // Check for pending vote
 71:     if (pendingVotes.value[contentId]) {
 72:       return
 73:     }
 74: 
 75:     const currentVote = getVoteType.value(contentId)
 76:     const isRemoving = currentVote === voteType
 77:     const oldVote = currentVote
 78: 
 79:     try {
 80:       // Create the vote promise
 81:       pendingVotes.value[contentId] = $fetch(`/api/votes/news/${contentId}`, {
 82:         method: 'POST',
 83:         body: { voteType },
 84:       })
 85: 
 86:       // Optimistically update UI
 87:       userVotes.value = {
 88:         ...userVotes.value,
 89:         [contentId]: isRemoving ? null : voteType,
 90:       }
 91: 
 92:       // Wait for the response
 93:       const response = await pendingVotes.value[contentId]
 94: 
 95:       // Show success notification
 96:       successNotify({
 97:         summary: 'Vote Recorded',
 98:         message: `Successfully ${response.action === 'removed' ? 'removed vote' : 'voted'}`,
 99:       })
100: 
101:       // Calculate score change
102:       let change = 0
103:       if (isRemoving) {
104:         change = -voteType
105:       } else {
106:         change = oldVote ? voteType * 2 : voteType
107:       }
108:       const newVotes = votes.value[contentId] + change
109: 
110:       votes.value = {
111:         ...votes.value,
112:         [contentId]: newVotes,
113:       }
114: 
115:       return { success: true, change }
116:     } catch (err: any) {
117:       // Revert optimistic update
118:       userVotes.value = {
119:         ...userVotes.value,
120:         [contentId]: oldVote,
121:       }
122: 
123:       // Handle specific error cases
124:       if (err.statusCode === 401) {
125:         errorNotify({
126:           summary: 'Authentication Required',
127:           message: 'Please log in to vote',
128:         })
129:       } else {
130:         errorNotify({
131:           summary: 'Vote Failed',
132:           message: 'Unable to record your vote. Please try again.',
133:         })
134:       }
135: 
136:       throw err
137:     } finally {
138:       // Clean up pending vote
139:       delete pendingVotes.value[contentId]
140:     }
141:   }
142: 
143:   return {
144:     // State
145:     votes,
146:     userVotes,
147:     isLoading,
148:     error,
149: 
150:     // Getters
151:     setVotes,
152:     getScore,
153:     getVoteType,
154:     isVotePending,
155: 
156:     // Actions
157:     fetchUserVotes,
158:     submitVote,
159:     fetchVotedPosts, // Added this to the returned object
160:   }
161: })
```

## File: apps/main-app/docs/uuid.md
```markdown
 1: We use UUID 1 Because it stores timestamps along with the file, we also want to discourage LOTs of
 2: user generated content, we just want the premium content, which can be achived by restricting users
 3: to 1 post per day.
 4: 
 5: ### UUID Version 1 Details:
 6: 
 7: - **Timestamp-Based**: Incorporates the current time and date as part of the UUID itself, meaning
 8:   that each UUID is not only unique but also time-ordered.
 9: - **Structure**: Contains a 60-bit timestamp (the number of 100-nanosecond intervals since October
10:   15, 1582), a 14-bit clock sequence (for uniqueness if the clock is set backwards or if there are
11:   multiple UUIDs generated at the same timestamp), and a 48-bit node identifier (usually the MAC
12:   address of the machine generating the UUID).
13: 
14: ### Benefits of Using UUID Version 1 for Images:
15: 
16: 1. **Traceability**: Each image file can be traced back to its exact creation time from its UUID,
17:    without needing additional metadata fields.
18: 2. **Sorting and Retrieval**: Images can be sorted or retrieved based on their creation times
19:    directly from their UUIDs, facilitating chronological organization and access.
20: 3. **Scalability and Uniqueness**: Provides a high level of uniqueness and is suitable for
21:    distributed systems, ensuring that UUIDs generated from different machines at the same time are
22:    distinct.
23: 
24: ### Example of UUID Version 1:
25: 
26: ```javascript
27: import { v1 as uuidv1 } from 'uuid'
28: 
29: // Generate a UUID with embedded timestamp
30: const imageUUID = uuidv1()
31: console.log(imageUUID) // Outputs: '2c5ea4c0-4067-11e9-8bad-9b1deb4d3b7d'
32: ```
33: 
34: ### Usage for All Images:
35: 
36: If you choose UUID version 1 for all image types (avatars, posts, covers), you ensure consistency
37: across your file naming conventions and take full advantage of the built-in timestamp feature for
38: all your image-related assets.
39: 
40: In summary, UUID version 1 is an excellent choice for your scenario where timestamp information is
41: crucial, and it aligns well with your needs for both organizational and technical efficiency.
```

## File: apps/main-app/layouts/app-settings.vue
```vue
 1: <script setup lang="ts">
 2: const user = useCurrentUser()
 3: 
 4: const settingsRoutes = computed(() => [
 5:   {
 6:     key: 'settings-account',
 7:     label: 'Account Profile',
 8:     url: '/profile/settings/profile',
 9:     icon: 'material-symbols:home',
10:     visible: true,
11:     disabled: false,
12:   },
13:   {
14:     key: 'settings-password',
15:     label: 'Update Password',
16:     url: '/profile/settings/password',
17:     icon: 'material-symbols:key',
18:     visible: user.profile?.providers.includes('email'),
19:     disabled: false,
20:   },
21:   // {
22:   //   key: 'settings-payments',
23:   //   label: 'Payments',
24:   //   url: '/profile/settings/payments',
25:   //   icon: 'mdi:credit-card',
26:   //   visible: true,
27:   //   disabled: false,
28:   // },
29:   {
30:     key: 'settings-notifications',
31:     label: 'Notifications',
32:     url: '/profile/settings/notifications',
33:     icon: 'material-symbols:notifications',
34:     visible: true,
35:     disabled: true,
36:   },
37: ])
38: </script>
39: 
40: <template>
41:   <div class="flex flex-col h-screen">
42:     <NuxtLayout name="app">
43:       <AppBackButton class="rounded-none !justify-start !items-start" />
44:       <div class="overflow-auto h-screen flex flex-col p-4 bg-black md:flex-row md:gap-8 lg:p-8">
45:         <PrimeMenu
46:           :model="settingsRoutes"
47:           :pt="{
48:             root: 'border-none !bg-transparent relative md:w-64',
49:             list: 'md:sticky md:top-8 flex md:flex-col justify-left !w-full items-center md:justify-end md:items-end overflow-auto',
50:             item: 'w-full',
51:           }"
52:           :pt-options="{ mergeSections: true, mergeProps: true }"
53:         >
54:           <template #item="{ item }">
55:             <NuxtLink
56:               v-if="item.url && !item.disabled"
57:               v-ripple
58:               :to="item.url"
59:               exact-active-class="bg-primary-950 text-white w-full"
60:               class="flex w-full justify-between gap-2 rounded-md px-3 py-2"
61:             >
62:               <span class="text-nowrap md:mr-4">{{ item.label }}</span>
63:               <div class="hidden md:block">
64:                 <Icon
65:                   v-if="item.icon"
66:                   :name="item.icon"
67:                 />
68:               </div>
69:             </NuxtLink>
70:           </template>
71:         </PrimeMenu>
72:         <div class="flex-grow">
73:           <slot />
74:         </div>
75:       </div>
76:     </NuxtLayout>
77:   </div>
78: </template>
79: 
80: <style scoped></style>
```

## File: apps/main-app/layouts/default.vue
```vue
 1: <script setup lang="ts">
 2: const { appLinks } = usePages()
 3: const { isSidebarOpen, isMobileSidebarOpen, isMobile } = useNavigation()
 4: </script>
 5: 
 6: <template>
 7:   <div class="w-full h-screen flex background relative overflow-hidden lg:py-4 lg:pr-4">
 8:     <IBSideNav
 9:       v-model:is-sidebar-open="isSidebarOpen"
10:       v-model:is-mobile-sidebar-open="isMobileSidebarOpen"
11:       :categories="appLinks"
12:       :is-mobile="isMobile"
13:     />
14:     <div
15:       class="w-full h-full pb-[var(--mobi-bottom-nav-height)] lg:pb-0 relative flex flex-col rounded-lg overflow-hidden"
16:     >
17:       <NavAppTop />
18:       <div class="overflow-y-scroll h-full foreground">
19:         <div class="h-full">
20:           <slot />
21:         </div>
22:       </div>
23:     </div>
24:     <NavMobiBottom class="lg:hidden" />
25:   </div>
26: </template>
```

## File: apps/main-app/middleware/auth.global.ts
```typescript
 1: import { defineNuxtRouteMiddleware, navigateTo, useNuxtApp } from '#app'
 2: import { useRuntimeConfig, useSupabaseClient } from '#imports'
 3: 
 4: export default defineNuxtRouteMiddleware(async (to) => {
 5:   const config = useRuntimeConfig()
 6:   const { $formbricks } = useNuxtApp()
 7: 
 8:   console.log('AUTH_MIDDLEWARE', $formbricks)
 9: 
10:   const { aeLoginUrl, aeAuthUrl } = config.public
11:   const supabase = useSupabaseClient()
12: 
13:   // List of public routes that don't require authentication
14:   const publicRoutes = ['/auth-callback']
15: 
16:   if (publicRoutes.includes(to.path)) {
17:     return // Allow access to public routes without checking auth
18:   }
19: 
20:   const { data, error } = await supabase.auth.getSession()
21: 
22:   if (error || !data.session) {
23:     console.log('USER_NOT_LOGGED_IN', `${aeAuthUrl}${aeLoginUrl}`)
24:     return navigateTo(String(`${aeAuthUrl}${aeLoginUrl}`), { external: true })
25:   } else {
26:     console.log('USER_LOGGED_IN', data.session, $formbricks)
27:     // $formbricks.setUserId(data.session.user.id)
28:   }
29: })
```

## File: apps/main-app/middleware/isCurrentUser.ts
```typescript
1: export default defineNuxtRouteMiddleware((to, from) => {
2:   const user = useSupabaseUser()
3: 
4:   if (!!to.params.id && to.params.id !== user.value.id) {
5:     const newPath = to.fullPath.replace(to.params.id, user.value.id)
6:     return navigateTo(newPath)
7:   }
8: })
```

## File: apps/main-app/pages/feed/[feed].vue
```vue
  1: <script setup lang="ts">
  2: const route = useRoute()
  3: const feedId = computed(() => String(route.params.feed))
  4: const { deleteFeed } = usePages()
  5: 
  6: const { store: categoriesStore } = useSelectData('feed_categories', {
  7:   columns: 'id, feed_id, categories(id, name)',
  8:   filters: {
  9:     feed_id: { eq: feedId.value },
 10:   },
 11:   orderBy: { column: 'created_at', ascending: false },
 12:   initialFetch: true,
 13: })
 14: 
 15: const removeFeed = async () => {
 16:   const { deleteData, isDeleting } = useDeleteData('feeds')
 17:   await deleteData(feedId.value)
 18: 
 19:   if (!isDeleting.value) {
 20:     deleteFeed(feedId.value)
 21:     navigateTo('/')
 22:   }
 23: }
 24: 
 25: const { items: proxyCategories } = storeToRefs(categoriesStore)
 26: 
 27: const categories = computed(() => proxyCategories.value.map((item) => toRaw(item).categories))
 28: 
 29: const news = ref([])
 30: const newsStore = ref(null)
 31: const loadMoreFunc = ref(null)
 32: 
 33: const domainKey = 'news'
 34: 
 35: watch(
 36:   categories,
 37:   (newCategories) => {
 38:     if (newCategories.length) {
 39:       news.value = []
 40: 
 41:       const { store, loadMore, refresh } = useSelectData<News>('news', {
 42:         columns:
 43:           'id, title, body, published_at, created_at, description, category_id, author, url, keywords, featured_image, company_id, companies(*)',
 44:         filters: {
 45:           category_id: { in: newCategories.map((category) => category.id) },
 46:         },
 47:         orderBy: { column: 'created_at', ascending: false },
 48:         initialFetch: true,
 49:       })
 50: 
 51:       newsStore.value = store
 52:       loadMoreFunc.value = loadMore
 53: 
 54:       // Update news when store items change
 55:       watch(
 56:         () => store.items,
 57:         (newItems) => {
 58:           news.value = newItems.map((item) => toRaw(item))
 59:         },
 60:         { immediate: true },
 61:       )
 62:     } else {
 63:       news.value = []
 64:       newsStore.value = null
 65:       loadMoreFunc.value = null
 66:     }
 67:   },
 68:   { immediate: true },
 69: )
 70: 
 71: const loading = useLoadingStore()
 72: const isLoading = computed(() => loading.isLoading(domainKey))
 73: </script>
 74: 
 75: <template>
 76:   <div class="p-2">
 77:     <PrimeButton
 78:       v-for="(category, index) in categories"
 79:       :key="index"
 80:       color="primary"
 81:       :aria-label="category.name"
 82:       :label="category.name"
 83:       size="small"
 84:       class="m-1"
 85:     />
 86:     <div>
 87:       <IBInfiniteScroll @update:scroll-end="loadMoreFunc && loadMoreFunc()">
 88:         <div
 89:           class="mx-auto w-full grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 md:col-start-2 gap-4 md:gap-8 p-4 md:p-8 max-w-[940px]"
 90:         >
 91:           <NewsCard
 92:             v-for="(item, i) in news"
 93:             :key="`news-post-${item.id}`"
 94:             :news="item"
 95:           />
 96:           <NewsCardSkeleton v-show="isLoading" />
 97:         </div>
 98:       </IBInfiniteScroll>
 99:     </div>
100:     <PrimeButton
101:       label="Delete feed"
102:       class="bg-red-800"
103:       @click="removeFeed"
104:     />
105:   </div>
106: </template>
107: 
108: <style scoped></style>
```

## File: apps/main-app/pages/feed/add.vue
```vue
  1: <script setup lang="ts">
  2: import Fuse from 'fuse.js'
  3: 
  4: const { addFeed } = usePages()
  5: 
  6: const { store, loadMore, refresh, isSelecting } = useSelectData('categories', {
  7:   columns: 'id, name',
  8:   orderBy: { column: 'name', ascending: true },
  9:   limit: 100,
 10:   initialFetch: true,
 11: })
 12: 
 13: const name = ref('')
 14: const search = ref('')
 15: const fuseInstance = ref<Fuse<any> | null>(null)
 16: 
 17: const { items: proxyCategories } = storeToRefs(store)
 18: 
 19: const initializeSelection = () => {
 20:   proxyCategories.value = proxyCategories.value.map((item) => ({
 21:     ...item,
 22:     selected: false,
 23:   }))
 24: }
 25: 
 26: watchEffect(() => {
 27:   if (proxyCategories.value.length > 0) {
 28:     initializeSelection()
 29:     fuseInstance.value = new Fuse(proxyCategories.value, {
 30:       keys: ['name'],
 31:       threshold: 0.3,
 32:       distance: 100,
 33:       ignoreLocation: true,
 34:       shouldSort: true,
 35:     })
 36:   }
 37: })
 38: 
 39: const toggleSelect = (id: string) => {
 40:   const category = proxyCategories.value.find((item) => item.id === id)
 41:   if (category) {
 42:     category.selected = !category.selected
 43:   }
 44: }
 45: 
 46: const onSearch = () => {
 47:   if (!search.value || search.value.trim().length < 2) {
 48:     return proxyCategories.value
 49:   }
 50: 
 51:   if (fuseInstance.value) {
 52:     const results = fuseInstance.value.search(search.value.trim())
 53:     return results.map((result) => ({
 54:       ...result.item,
 55:       selected: proxyCategories.value.find((cat) => cat.id === result.item.id)?.selected || false,
 56:     }))
 57:   }
 58: 
 59:   return proxyCategories.value
 60: }
 61: 
 62: const categories = computed(() => onSearch())
 63: 
 64: const selectedCategories = computed(() => proxyCategories.value.filter((cat) => cat.selected))
 65: 
 66: const save = async () => {
 67:   const toast = useNotification()
 68:   const selected = selectedCategories.value
 69: 
 70:   if (!name.value) {
 71:     toast.error({ summary: 'Feed name cannot be empty', message: 'Please enter a feed name' })
 72:     return
 73:   }
 74: 
 75:   if (!selected.length) {
 76:     toast.error({ summary: 'No categories selected', message: 'Please select some categories' })
 77:     return
 78:   }
 79: 
 80:   const { profile } = useCurrentUser()
 81:   const client = useSupabaseClient()
 82: 
 83:   if (profile?.id) {
 84:     const user_id = profile.id
 85:     const feed = { user_id, name: name.value }
 86:     try {
 87:       const { data, error, status } = await client.from('feeds').insert(feed).select('id')
 88: 
 89:       if (!error) {
 90:         const feed_id = data[0].id
 91:         const res = await Promise.all(
 92:           selected.map((category) =>
 93:             client.from('feed_categories').insert({ feed_id, category_id: category.id }),
 94:           ),
 95:         )
 96: 
 97:         if (res.every(({ error }) => !error)) {
 98:           toast.success({
 99:             summary: 'Feed created successfully',
100:             message: `${name.value} was created successfully`,
101:           })
102:           addFeed(data[0].id, name.value)
103:         } else {
104:           res.forEach(
105:             ({ error }) =>
106:               error && toast.error({ summary: 'Could not create feed', message: error.message }),
107:           )
108:         }
109:       } else {
110:         toast.error({ summary: 'Could not create feed', message: error.message })
111:       }
112:     } catch (error) {
113:       toast.error({ summary: 'Could not create feed', message: error })
114:     }
115:   } else {
116:     toast.error({ summary: 'User Not Authenticated', message: 'Please login again' })
117:   }
118: }
119: 
120: const discard = () => {
121:   name.value = ''
122:   search.value = ''
123:   proxyCategories.value.forEach((item) => (item.selected = false))
124: }
125: 
126: const removeSelected = (id: string) => {
127:   const category = proxyCategories.value.find((item) => item.id === id)
128:   if (category) {
129:     category.selected = false
130:   }
131: }
132: 
133: const selectedItems = computed({
134:   get: () => selectedCategories.value,
135:   set: () => {}, // We handle removal through the removeSelected method
136: })
137: 
138: definePageMeta({
139:   name: 'Add Feed',
140: })
141: </script>
142: 
143: <template>
144:   <div class="mx-auto p-4">
145:     <!-- Header -->
146:     <div class="mb-6">
147:       <h1 class="text-2xl font-semibold mb-2">Create New Feed</h1>
148:       <p class="text-gray-500">Select categories to include in your feed</p>
149:     </div>
150: 
151:     <!-- Main Layout -->
152:     <div class="grid grid-cols-1 gap-6">
153:       <!-- Top Panel - Input and Selected Categories -->
154:       <PrimeCard class="bg-gray-900">
155:         <template #content>
156:           <div class="grid grid-cols-12 gap-4">
157:             <!-- Feed Name Input -->
158:             <div class="col-span-12 md:col-span-4">
159:               <PrimeFloatLabel>
160:                 <PrimeInputText
161:                   id="feedname"
162:                   v-model="name"
163:                   class="w-full"
164:                   required
165:                 />
166:                 <label for="feedname">Enter feed name</label>
167:               </PrimeFloatLabel>
168:             </div>
169: 
170:             <!-- Action Buttons -->
171:             <div class="col-span-12 md:col-span-8 flex items-center gap-2 justify-end">
172:               <PrimeSelect
173:                 v-model="selectedItems"
174:                 :options="selectedCategories"
175:                 placeholder="No categories selected"
176:                 option-label="name"
177:                 :close-on-select="false"
178:                 multiple
179:                 class="w-full"
180:               >
181:                 <template #header>
182:                   <div class="px-4 py-2 text-gray-400 text-sm font-medium">
183:                     Selected Categories
184:                   </div>
185:                 </template>
186:                 <template #value="{ value }">
187:                   <div class="flex items-center gap-2">
188:                     <span class="text-gray-300">{{
189:                       value?.length
190:                         ? `${value.length} categories selected`
191:                         : 'No categories selected'
192:                     }}</span>
193:                     <PrimeBadge
194:                       v-if="value?.length"
195:                       :value="value.length"
196:                       severity="info"
197:                     />
198:                   </div>
199:                 </template>
200:                 <template #option="{ option }">
201:                   <div class="flex items-center justify-between w-full px-2 py-1">
202:                     <span>{{ option.name }}</span>
203:                     <button
204:                       class="text-gray-400 hover:text-red-500 p-1 rounded-full hover:bg-gray-700/50"
205:                       @click.stop="removeSelected(option.id)"
206:                     >
207:                       <Icon
208:                         name="mdi:close"
209:                         size="16px"
210:                       />
211:                     </button>
212:                   </div>
213:                 </template>
214:               </PrimeSelect>
215:               <PrimeButton
216:                 label="Save"
217:                 :disabled="!name || !selectedCategories.length"
218:                 class="flex shrink-0"
219:                 @click="save"
220:               />
221:               <button
222:                 class="p-2 hover:bg-gray-800 rounded-full transition-colors"
223:                 @click="discard"
224:               >
225:                 <Icon
226:                   name="mdi:trash-can-outline"
227:                   size="22px"
228:                   class="text-red-500"
229:                 />
230:               </button>
231:             </div>
232:             <!-- Search -->
233:             <div class="col-span-12">
234:               <PrimeFloatLabel>
235:                 <PrimeInputText
236:                   id="search"
237:                   v-model="search"
238:                   class="w-full"
239:                 />
240:                 <label for="search">Search categories</label>
241:               </PrimeFloatLabel>
242:             </div>
243:           </div>
244:         </template>
245:       </PrimeCard>
246: 
247:       <!-- Search and Categories -->
248:       <PrimeCard class="bg-gray-900">
249:         <template #content>
250:           <!-- Categories Grid -->
251:           <PrimeProgressSpinner
252:             v-if="proxyCategories.length === 0"
253:             class="w-8 h-8 mx-auto"
254:           />
255:           <div
256:             v-else
257:             class="h-[500px] overflow-y-auto custom-scrollbar"
258:           >
259:             <div class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-2">
260:               <PrimeButton
261:                 v-for="category in categories"
262:                 :key="category.id"
263:                 :label="category.name"
264:                 :outlined="!category.selected"
265:                 size="small"
266:                 class="whitespace-normal h-auto py-2 justify-start"
267:                 @click="toggleSelect(category.id)"
268:               />
269:             </div>
270:           </div>
271:         </template>
272:       </PrimeCard>
273:     </div>
274:   </div>
275: </template>
276: 
277: <style scoped>
278: :deep(.p-card) {
279:   background: transparent;
280: }
281: 
282: :deep(.p-button) {
283:   justify-content: flex-start;
284: }
285: 
286: :deep(.p-inputtext) {
287:   width: 100%;
288:   background: theme('colors.gray.800');
289: }
290: 
291: :deep(.p-dropdown),
292: :deep(.p-multiselect) {
293:   background: theme('colors.gray.800');
294:   border-color: theme('colors.gray.700');
295: }
296: 
297: :deep(.p-dropdown-panel),
298: :deep(.p-multiselect-panel) {
299:   background: theme('colors.gray.800');
300:   border-color: theme('colors.gray.700');
301: }
302: 
303: :deep(.p-dropdown-item),
304: :deep(.p-multiselect-item) {
305:   color: theme('colors.gray.300');
306: }
307: 
308: :deep(.p-dropdown-item:hover),
309: :deep(.p-multiselect-item:hover) {
310:   background: theme('colors.gray.700');
311: }
312: 
313: .custom-scrollbar {
314:   scrollbar-width: thin;
315:   scrollbar-color: theme('colors.gray.600') theme('colors.gray.800');
316: }
317: 
318: .custom-scrollbar::-webkit-scrollbar {
319:   width: 8px;
320: }
321: 
322: .custom-scrollbar::-webkit-scrollbar-track {
323:   background: theme('colors.gray.800');
324:   border-radius: 4px;
325: }
326: 
327: .custom-scrollbar::-webkit-scrollbar-thumb {
328:   background-color: theme('colors.gray.600');
329:   border-radius: 4px;
330: }
331: 
332: :deep(.p-float-label) {
333:   display: block;
334: }
335: 
336: :deep(.p-float-label input:focus) ~ label,
337: :deep(.p-float-label input.p-filled) ~ label {
338:   background: theme('colors.gray.900');
339:   padding: 0 4px;
340: }
341: </style>
```

## File: apps/main-app/pages/news/index.vue
```vue
 1: <script setup lang="ts">
 2: // !todo:critical - add summaries for news articles
 3: // !todo:high - allow news to toggle summary level
 4: // !todo:bug:critical - infinite scroll is loading duplicate posts with pagination, probably a supabase issue
 5: const { init: initBookmarks } = useBookmarks()
 6: 
 7: const domainKey = 'news'
 8: const { store, loadMore, refresh } = useSelectData<News>('news', {
 9:   columns:
10:     'id, title, body, published_at, created_at, description, category_id, author, url, keywords, featured_image, company_id, companies(*), score',
11:   filters: {
12:     // content_status: { eq: 'draft' },
13:     body: { neq: 'null' },
14:   },
15:   orderBy: { column: 'created_at', ascending: false },
16:   initialFetch: true,
17:   pagination: { page: 1, limit: 20 },
18: })
19: 
20: const { items: proxyNews } = storeToRefs(store)
21: 
22: const news = computed(() => proxyNews.value.map((item) => toRaw(item)))
23: 
24: console.log('news', news)
25: 
26: const loading = useLoadingStore()
27: const isLoading = computed(() => loading.isLoading(domainKey))
28: 
29: onMounted(async () => {
30:   await initBookmarks()
31: })
32: 
33: // Add this to refresh bookmarks after route changes
34: const route = useRoute()
35: watch(
36:   () => route.path,
37:   async () => {
38:     await initBookmarks()
39:   },
40: )
41: 
42: definePageMeta({
43:   name: 'News',
44: })
45: </script>
46: 
47: <template>
48:   <div>
49:     <IBInfiniteScroll @update:scroll-end="loadMore()">
50:       <div
51:         class="mx-auto w-full grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 md:col-start-2 gap-4 md:gap-8 p-4 md:p-8 max-w-[940px]"
52:       >
53:         <div class="col-span-full w-full justify-between flex">
54:           <PrimeButton @click="refresh()"> Feed Categories </PrimeButton>
55:           <PrimeButton
56:             link
57:             @click="refresh()"
58:           >
59:             Feed Settings
60:           </PrimeButton>
61:         </div>
62:         <NewsCard
63:           v-for="(item, i) in news"
64:           :key="`news-post-${i}`"
65:           :news="item"
66:         />
67:         <NewsCardSkeleton v-show="isLoading" />
68:       </div>
69:     </IBInfiniteScroll>
70:   </div>
71: </template>
72: 
73: <style scoped></style>
```

## File: apps/main-app/pages/profile/settings/password.vue
```vue
  1: <script setup lang="ts">
  2: const schema = [
  3:   {
  4:     id: 'new_password',
  5:     label: 'New Password',
  6:     tip: 'New password must be at least 6 characters long',
  7:     placeholder: 'Your new password',
  8:     value: ref(''),
  9:     type: 'password',
 10:   },
 11:   {
 12:     id: 'confirm_new_password',
 13:     label: 'Confirm Password',
 14:     tip: 'Please confirm your new password',
 15:     placeholder: 'Confirm Your password',
 16:     value: ref(''),
 17:     type: 'password',
 18:   },
 19: ]
 20: 
 21: const currentUser = useCurrentUser()
 22: const toast = useNotification()
 23: 
 24: const {
 25:   store: userProfile,
 26:   loadMore,
 27:   refresh,
 28: } = await useSelectData<User>('user_profiles', {
 29:   columns: 'id, given_name, surname, email, avatar, dob, username',
 30:   filters: { id: { eq: currentUser.profile.id } },
 31:   initialFetch: true,
 32:   limit: 1,
 33: })
 34: 
 35: async function handlePasswordUpdate() {
 36:   const supabase = useSupabaseClient()
 37:   const { new_password, confirm_new_password } = schema.reduce(
 38:     (acc, field) => ({ ...acc, [field.id]: field.value.value }),
 39:     {
 40:       new_password: '',
 41:       confirm_new_password: '',
 42:     },
 43:   )
 44: 
 45:   if (new_password !== confirm_new_password) {
 46:     toast.error({
 47:       summary: "Passwords Don't Match",
 48:       message: "The two passwords entered don't match",
 49:     })
 50:     return
 51:   }
 52: 
 53:   const { error } = await supabase.auth.updateUser({ password: new_password })
 54: 
 55:   if (error) {
 56:     toast.error({ summary: 'Could Not Update Password', message: error.message })
 57:   } else {
 58:     toast.success({
 59:       summary: 'Successfully Updated Password',
 60:       message: 'Your password was updated',
 61:     })
 62:   }
 63: }
 64: 
 65: definePageMeta({
 66:   layoutTransition: false,
 67:   name: 'Password',
 68:   layout: 'app-settings',
 69: })
 70: 
 71: const settings = reactive({
 72:   password: '',
 73:   new_password: '',
 74:   confirm_new_password: '',
 75: })
 76: 
 77: const isPasswordUpdatable = computed(() =>
 78:   currentUser.profile ? currentUser.profile?.providers.includes('email') : false,
 79: )
 80: </script>
 81: 
 82: <template>
 83:   <div>
 84:     <UserSettingsCard
 85:       :title="{
 86:         main: 'Update Password',
 87:         subtitle: 'Change your password here',
 88:       }"
 89:     >
 90:       <div v-if="isPasswordUpdatable">
 91:         <UserSettingsItem
 92:           v-for="item in schema"
 93:           :key="item.id"
 94:           :item="item"
 95:         >
 96:           <FormPassword
 97:             :id="item.id"
 98:             v-model="item.value.value"
 99:             :feedback="item.id !== 'confirm_new_password'"
100:             :required="true"
101:           />
102:         </UserSettingsItem>
103:         <div class="flex justify-start pt-12">
104:           <PrimeButton
105:             label="Update Password"
106:             @click="handlePasswordUpdate"
107:           />
108:         </div>
109:       </div>
110:       <PrimeMessage
111:         v-else-if="currentUser.profile"
112:         severity="info"
113:       >
114:         You used {{ currentUser.profile.provider }} to authenticate
115:       </PrimeMessage>
116:     </UserSettingsCard>
117:   </div>
118: </template>
```

## File: apps/main-app/pages/profile/settings/payments.vue
```vue
 1: <script setup lang="ts">
 2: import { ref } from 'vue'
 3: 
 4: const { isLoading, error, initializePayment, createOrder, verifyPayment, fetchSubscription }
 5:   = usePayments('razorpay')
 6: 
 7: const result = ref(null as any)
 8: 
 9: const handleCreateOrder = async () => {
10:   result.value = await createOrder('plan_OmmnufyFh3id2P')
11: }
12: 
13: const handleInitializePayment = async () => {
14:   const order = await createOrder('plan_OmmnufyFh3id2P')
15:   if (order) {
16:     await initializePayment({
17:       amount: order.amount,
18:       currency: order.currency,
19:       order_id: order.id,
20:       handler: handleVerifyPayment,
21:     })
22:   }
23: }
24: 
25: const handleVerifyPayment = async (response: any) => {
26:   result.value = await verifyPayment(response)
27: }
28: 
29: const handleFetchSubscription = async () => {
30:   result.value = await fetchSubscription()
31: }
32: 
33: useHead({
34:   script: [
35:     {
36:       src: 'https://checkout.razorpay.com/v1/checkout.js',
37:       defer: true,
38:     },
39:   ],
40: })
41: 
42: definePageMeta({
43:   layoutTransition: false,
44:   name: 'Payments',
45:   layout: 'app-settings',
46: })
47: </script>
48: 
49: <template>
50:   <UserSettingsCard
51:     :title="{
52:       main: 'Payment Settings',
53:       subtitle: 'Manage your subscription and payment options',
54:     }"
55:   >
56:     <div class="flex gap-4 items-center">
57:       <PrimeButton
58:         :loading="isLoading"
59:         @click="handleCreateOrder"
60:       >
61:         Create Order
62:       </PrimeButton>
63:       <PaymentButton />
64:       <PrimeButton
65:         :loading="isLoading"
66:         @click="handleInitializePayment"
67:       >
68:         Initialize Payment
69:       </PrimeButton>
70:       <PrimeButton
71:         :loading="isLoading"
72:         @click="handleVerifyPayment"
73:       >
74:         Verify Payment
75:       </PrimeButton>
76:       <PrimeButton
77:         :loading="isLoading"
78:         @click="handleFetchSubscription"
79:       >
80:         Fetch Subscription
81:       </PrimeButton>
82:     </div>
83: 
84:     <div
85:       v-if="error"
86:       class="mt-4 text-red-500"
87:     >
88:       {{ error }}
89:     </div>
90: 
91:     <div
92:       v-if="result"
93:       class="mt-4"
94:     >
95:       <pre>{{ JSON.stringify(result, null, 2) }}</pre>
96:     </div>
97:   </UserSettingsCard>
98: </template>
```

## File: apps/main-app/pages/profile/settings/profile.vue
```vue
  1: <script setup lang="ts">
  2: import { z } from 'zod'
  3: import { useFileUpload } from '#imports'
  4: 
  5: const schema = [
  6:   {
  7:     value: 'given_name',
  8:     label: 'Given Name',
  9:     tip: 'Your first name',
 10:     placeholder: 'Your first name',
 11:     type: 'text',
 12:   },
 13:   {
 14:     value: 'surname',
 15:     label: 'Surname',
 16:     tip: 'Your last name',
 17:     placeholder: 'Your last name',
 18:     type: 'text',
 19:   },
 20:   {
 21:     value: 'email',
 22:     label: 'Email',
 23:     tip: 'Contact support to update your email',
 24:     placeholder: 'Your email address',
 25:     type: 'email',
 26:     disabled: true,
 27:   },
 28:   {
 29:     value: 'username',
 30:     label: 'Username',
 31:     tip: 'Contact support to update your username',
 32:     placeholder: 'Your username',
 33:     type: 'username',
 34:     disabled: true,
 35:   },
 36: ]
 37: 
 38: const SettingsAccountValidation = z.object({
 39:   given_name: z.string().min(1, 'Given Name is required'),
 40:   surname: z.string().min(1, 'Surname is required'),
 41:   username: z.string(),
 42:   email: z.string().email(),
 43:   introduction: z.string().min(240, 'At least 240 characters required').optional(),
 44:   quote: z.string().min(10, 'At least 10 characters required').optional(),
 45: })
 46: 
 47: const currentUser = useCurrentUser()
 48: 
 49: const profileCopy = ref({})
 50: 
 51: onMounted(() => {
 52:   profileCopy.value = { ...currentUser.profile }
 53: })
 54: 
 55: const updateProfileImage = (newImage: string) => {
 56:   const avatar = `${newImage}?v=${Date.now()}`
 57:   currentUser.updateProfile({ avatar })
 58:   profileCopy.value.avatar = avatar
 59: }
 60: 
 61: definePageMeta({
 62:   layoutTransition: false,
 63:   name: 'Profile',
 64:   layout: 'app-settings',
 65: })
 66: </script>
 67: 
 68: <template>
 69:   <div>
 70:     <UserSettingsCard
 71:       v-if="currentUser"
 72:       :title="{
 73:         main: 'Account Profile',
 74:         subtitle: 'Update your account information',
 75:       }"
 76:     >
 77:       <div class="relative w-full max-w-[1200px]">
 78:         <div
 79:           class="left-16 flex h-32 w-32 items-center justify-center overflow-hidden rounded-full bg-red-50"
 80:         >
 81:           <PrimeAvatar
 82:             v-if="profileCopy && profileCopy.avatar"
 83:             :image="profileCopy.avatar"
 84:             shape="circle"
 85:             class="w-full h-full cursor-pointer"
 86:             aria-haspopup="true"
 87:             aria-controls="overlay_menu"
 88:             crossorigin="anonymous"
 89:           />
 90:           <UploadCropper
 91:             cropper-type="avatar"
 92:             class="absolute bottom-0 z-20"
 93:             bucket="profile-public"
 94:             @profile-pic-update="updateProfileImage"
 95:           />
 96:         </div>
 97:       </div>
 98: 
 99:       <div class="pt-24">
100:         <UserSettingsItem
101:           v-for="item in schema"
102:           :key="item.value"
103:           :item="item"
104:         >
105:           <div class="w-full">
106:             <PrimeInputText
107:               v-model="profileCopy[item.value]"
108:               class="w-96"
109:               :type="item.type"
110:               :disabled="item.disabled"
111:               :placeholder="profileCopy[item.value] || item.placeholder"
112:             />
113:           </div>
114:         </UserSettingsItem>
115:         <div class="flex py-8 gap-2">
116:           <PrimeButton
117:             class="text-white"
118:             @click="currentUser.updateProfile(profileCopy)"
119:           >
120:             Save changes
121:           </PrimeButton>
122:         </div>
123:       </div>
124:     </UserSettingsCard>
125:   </div>
126: </template>
```

## File: apps/main-app/pages/profile/votes/[type].vue
```vue
 1: <script setup lang="ts">
 2: import { ref, computed } from 'vue'
 3: 
 4: const route = useRoute()
 5: const voteStore = useVoteStore()
 6: 
 7: const voteString = computed(() => route.params.type)
 8: const voteType = computed(() => (voteString.value === 'upvoted' ? 1 : -1))
 9: const posts = ref([])
10: const isLoading = ref(false)
11: 
12: const fetchVotedPosts = async () => {
13:   isLoading.value = true
14:   try {
15:     posts.value = await voteStore.fetchVotedPosts(voteType.value)
16:   } catch (error) {
17:     console.error('Error fetching voted posts:', error)
18:   } finally {
19:     isLoading.value = false
20:   }
21: }
22: 
23: // Initialize vote store if needed
24: onMounted(async () => {
25:   if (Object.keys(voteStore.votes).length === 0) {
26:     await voteStore.fetchUserVotes()
27:   }
28:   fetchVotedPosts()
29: })
30: 
31: // Update posts when route type changes
32: watch(() => voteString, fetchVotedPosts)
33: </script>
34: 
35: <template>
36:   <div class="p-4 md:p-8">
37:     <h1 class="text-2xl font-bold pb-4 md:pb-8 text-center">
38:       {{ voteString === 'upvoted' ? 'Upvoted' : 'Downvoted' }} Posts
39:     </h1>
40: 
41:     <div
42:       v-if="isLoading"
43:       class="flex justify-center py-8"
44:     >
45:       <PrimeSpinner />
46:     </div>
47: 
48:     <div
49:       v-else-if="posts.length === 0"
50:       class="text-center py-8"
51:     >
52:       No posts found
53:     </div>
54: 
55:     <div
56:       v-else
57:       class="mx-auto w-full grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 md:col-start-2 gap-4 md:gap-8 max-w-[940px]"
58:     >
59:       <NewsCard
60:         v-for="post in posts"
61:         :key="post.id"
62:         :news="post"
63:       />
64:     </div>
65:   </div>
66: </template>
```

## File: apps/main-app/pages/profile/bookmarks.vue
```vue
  1: <script setup lang="ts">
  2: import type { FuseResult } from 'fuse.js'
  3: import type { Folder } from '~/composables/useFolderSystem'
  4: 
  5: const { getFeatureUsage } = usePlan()
  6: const { folders, loading: foldersLoading } = useFolderSystem()
  7: const { bookmarks, loading: bookmarksLoading, fetchBookmarks } = useBookmarks()
  8: const {
  9:   selectedBookmarks,
 10:   showMoveModal,
 11:   handleNewFolder,
 12:   handleMoveSubmit,
 13:   handleDeleteBookmark,
 14: } = useBookmarkManager()
 15: 
 16: const {
 17:   viewMode,
 18:   searchQuery,
 19:   includeSubfolders,
 20:   showFolderPanel,
 21:   showNewFolderModal,
 22:   currentFolder,
 23:   handleFolderSelect,
 24:   toggleFolderPanel,
 25: } = useBookmarkView()
 26: 
 27: const folderUsage = computed(() => getFeatureUsage('BOOKMARK_FOLDERS', folders.value.length))
 28: const displayedBookmarks = ref<typeof bookmarks.value>([])
 29: 
 30: const toggleSelection = (id: string) => {
 31:   const index = selectedBookmarks.value.indexOf(id)
 32:   if (index === -1) {
 33:     selectedBookmarks.value.push(id)
 34:   } else {
 35:     selectedBookmarks.value.splice(index, 1)
 36:   }
 37: }
 38: 
 39: const clearSelection = () => {
 40:   selectedBookmarks.value = []
 41: }
 42: 
 43: const handleBulkDelete = async () => {
 44:   if (!selectedBookmarks.value.length) return
 45:   await handleDeleteBookmark(selectedBookmarks.value)
 46:   clearSelection()
 47: }
 48: 
 49: // Search configuration
 50: const searchFuseOptions = {
 51:   keys: ['metadata.title', 'metadata.description', 'metadata.author'],
 52:   threshold: 0.3,
 53:   shouldSort: true,
 54: }
 55: 
 56: // Handle search results
 57: const handleSearchResults = (results: FuseResult<any>[]) => {
 58:   if (results.length === 0 && !searchQuery.value) {
 59:     displayedBookmarks.value = bookmarks.value
 60:   } else {
 61:     displayedBookmarks.value = results.map((result) => result.item)
 62:   }
 63: }
 64: 
 65: const loading = computed(() => foldersLoading.value || bookmarksLoading.value)
 66: 
 67: onMounted(async () => {
 68:   const session = await useSupabaseSession()
 69:   if (session.value) {
 70:     await fetchBookmarks({})
 71:   }
 72: })
 73: 
 74: // Update initial display when bookmarks change
 75: watch(
 76:   () => bookmarks.value,
 77:   (newBookmarks) => {
 78:     if (!searchQuery.value) {
 79:       displayedBookmarks.value = newBookmarks
 80:     }
 81:   },
 82:   { immediate: true },
 83: )
 84: </script>
 85: 
 86: <template>
 87:   <div class="min-h-screen p-4 space-y-4">
 88:     <BookmarkViewFolder v-if="!searchQuery" />
 89: 
 90:     <!-- Simplified toolbar without left hamburger -->
 91:     <PrimeToolbar
 92:       class="sticky top-0 z-40"
 93:       :pt="{
 94:         start: 'flex-grow',
 95:       }"
 96:     >
 97:       <template #start>
 98:         <div class="w-full max-w-xl">
 99:           <FuzzySearch
100:             v-model="searchQuery"
101:             :data="bookmarks"
102:             :fuse-options="searchFuseOptions"
103:             placeholder="Search bookmarks..."
104:             class="w-full"
105:             @results="handleSearchResults"
106:           />
107:         </div>
108:       </template>
109: 
110:       <template #end>
111:         <div class="flex items-center gap-4">
112:           <!-- Selection Actions -->
113:           <template v-if="selectedBookmarks.length > 0">
114:             <span class="text-sm text-gray-600">{{ selectedBookmarks.length }} selected</span>
115:             <PrimeButton
116:               severity="danger"
117:               size="small"
118:               @click="handleBulkDelete"
119:             >
120:               Delete
121:             </PrimeButton>
122:             <PrimeButton
123:               size="small"
124:               @click="showMoveModal = true"
125:             >
126:               Move to Folder
127:             </PrimeButton>
128:             <PrimeButton
129:               size="small"
130:               text
131:               @click="clearSelection"
132:             >
133:               Clear
134:             </PrimeButton>
135:           </template>
136: 
137:           <!-- Regular Actions -->
138:           <template v-else>
139:             <PrimeCheckbox
140:               v-if="currentFolder"
141:               v-model="includeSubfolders"
142:               :binary="true"
143:               label="Include subfolders"
144:             />
145:           </template>
146:         </div>
147:       </template>
148:     </PrimeToolbar>
149: 
150:     <div class="flex">
151:       <!-- Main Content -->
152:       <div class="flex-1 overflow-auto">
153:         <div class="max-w-7xl mx-auto space-y-6">
154:           <!-- Current Folder Info -->
155:           <div
156:             v-if="currentFolder"
157:             class="flex items-center gap-2"
158:           >
159:             <div
160:               class="w-3 h-3 rounded-full"
161:               :style="{ backgroundColor: currentFolder.color }"
162:             />
163:             <h2 class="text-xl font-semibold">{{ currentFolder.name }}</h2>
164:             <Icon
165:               v-if="currentFolder.is_favorite"
166:               name="mdi:star"
167:               class="text-yellow-400"
168:             />
169:           </div>
170: 
171:           <!-- Loading State -->
172:           <div
173:             v-if="loading"
174:             class="flex items-center justify-center h-64"
175:           >
176:             <PrimeProgressSpinner />
177:           </div>
178: 
179:           <!-- Bookmarks Grid -->
180:           <div
181:             v-else
182:             class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4"
183:           >
184:             <TransitionGroup
185:               enter-active-class="transition-all duration-300 ease-out"
186:               enter-from-class="opacity-0 transform scale-95"
187:               enter-to-class="opacity-100 transform scale-100"
188:               leave-active-class="transition-all duration-200 ease-in"
189:               leave-from-class="opacity-100 transform scale-100"
190:               leave-to-class="opacity-0 transform scale-95"
191:             >
192:               <div
193:                 v-for="bookmark in displayedBookmarks"
194:                 :key="bookmark.id"
195:                 class="relative group flex"
196:               >
197:                 <div
198:                   class="absolute w-full h-10 inset-0 z-10 flex items-start justify-end p-2 bg-black/5"
199:                   :class="
200:                     selectedBookmarks.includes(bookmark.id)
201:                       ? 'opacity-100'
202:                       : 'opacity-0 group-hover:opacity-100 transition-opacity'
203:                   "
204:                 >
205:                   <PrimeCheckbox
206:                     :model-value="selectedBookmarks.includes(bookmark.id)"
207:                     :binary="true"
208:                     @update:model-value="toggleSelection(bookmark.id)"
209:                   />
210:                 </div>
211: 
212:                 <NewsCard
213:                   :news="{
214:                     id: bookmark.content_id,
215:                     title: bookmark.metadata.title,
216:                     description: bookmark.metadata.description,
217:                     authorName: bookmark.metadata.author || 'Unknown',
218:                     featured_image: bookmark.metadata.thumbnail,
219:                     url: bookmark.metadata.url,
220:                     comments: 0,
221:                     score: 0,
222:                   }"
223:                   :class="{ 'opacity-75': selectedBookmarks.includes(bookmark.id) }"
224:                 />
225:               </div>
226:             </TransitionGroup>
227:           </div>
228: 
229:           <!-- Empty State -->
230:           <div
231:             v-if="!loading && (!displayedBookmarks || displayedBookmarks.length === 0)"
232:             class="flex flex-col items-center justify-center h-64 text-gray-500"
233:           >
234:             <Icon
235:               name="mdi:bookmark-outline"
236:               size="48"
237:             />
238:             <p class="mt-4 text-lg">No bookmarks found</p>
239:             <p class="text-sm">
240:               {{
241:                 searchQuery ? 'Try a different search term' : 'Start by bookmarking some articles'
242:               }}
243:             </p>
244:           </div>
245:         </div>
246:       </div>
247:     </div>
248: 
249:     <PrimeDialog
250:       v-model:visible="showMoveModal"
251:       modal
252:       header="Move Bookmark"
253:       :style="{ width: '90vw', maxWidth: '500px' }"
254:     >
255:       <BookmarkFormMove
256:         :folders="folders"
257:         :selected-folder="currentFolder"
258:         @submit="(folder: Folder) => handleMoveSubmit(folder)"
259:         @cancel="showMoveModal = false"
260:       />
261:     </PrimeDialog>
262:   </div>
263: </template>
264: 
265: <style scoped>
266: @media (min-width: 768px) {
267:   :deep(.p-drawer) {
268:     position: relative;
269:     height: 100%;
270:     transform: none !important;
271:   }
272: 
273:   :deep(.p-drawer-mask) {
274:     display: none;
275:   }
276: }
277: </style>
```

## File: apps/main-app/pages/profile/index.vue
```vue
 1: <template>
 2:   <div> WIP</div>
 3: </template>
 4: 
 5: <script setup lang="ts">
 6: definePageMeta({
 7:   layoutTransition: false,
 8:   name: 'Profile',
 9: })
10: </script>
11: 
12: <style scoped></style>
```

## File: apps/main-app/pages/ask.vue
```vue
  1: <script setup lang="ts">
  2: interface ChatAgent {
  3:   id: number
  4:   name: string
  5:   features: string[]
  6:   systemMessage: string
  7:   enabled: boolean
  8:   starterPrompts: string[]
  9: }
 10: 
 11: interface Message {
 12:   role: 'user' | 'assistant'
 13:   content: string
 14: }
 15: 
 16: const agents: ChatAgent[] = [
 17:   {
 18:     id: 1,
 19:     name: 'Astronomy Communicator',
 20:     features: [
 21:       'Break down complex astronomy concepts',
 22:       'Explain in an engaging, Carl Sagan-inspired style',
 23:       'Make astronomy accessible to all',
 24:     ],
 25:     systemMessage:
 26:       'You are an enthusiastic astronomy science communicator who can break down even the most complex topics into something easy to understand. Channel the spirit of Carl Sagan in your explanations, using vivid imagery and relatable analogies. Your goal is to inspire wonder and curiosity about the cosmos in every interaction.',
 27:     enabled: true,
 28:     starterPrompts: [
 29:       'Can you explain black holes in a way that would captivate a 10-year-old?',
 30:       "What's the most mind-blowing fact about our universe that you can share?",
 31:       "How would you describe the concept of light-years to someone who's never heard of it before?",
 32:     ],
 33:   },
 34:   {
 35:     id: 2,
 36:     name: 'Space Tech Analyst',
 37:     features: [
 38:       'Research astronomy and space tech companies',
 39:       'Provide insights for job seekers and competitors',
 40:       'Analyze company profiles and trends',
 41:     ],
 42:     systemMessage:
 43:       'You are an astronomy and space tech company researcher. Your database contains information on numerous companies in the field. Your role is to answer questions about these companies, help users find potential employers, and perform competitor analysis. Provide detailed, factual information and insightful comparisons when asked.',
 44:     enabled: true,
 45:     starterPrompts: [
 46:       'What are the top 3 companies currently leading in commercial space flight, and how do they compare?',
 47:       "I'm an aerospace engineer looking for job opportunities. Which companies should I be watching?",
 48:       'Can you provide a brief analysis of the current trends in the satellite industry?',
 49:     ],
 50:   },
 51:   {
 52:     id: 3,
 53:     name: 'Space News Reporter',
 54:     features: [
 55:       'Report on latest astronomy and space news',
 56:       'Provide expert analysis on recent developments',
 57:       'Offer context and implications of news stories',
 58:     ],
 59:     systemMessage:
 60:       'You are an expert news reporter specializing in astronomy and space news. Your knowledge is based on a constantly updated database of news articles. When asked, provide the latest developments in the field, offer expert analysis, and explain the significance of recent news stories. Your reporting should be accurate, engaging, and informative.',
 61:     enabled: true,
 62:     starterPrompts: [
 63:       "What's the most significant space exploration news from the past week?",
 64:       'Can you give me an update on the latest developments in the search for exoplanets?',
 65:       'What are the potential implications of the most recent Mars rover discoveries?',
 66:     ],
 67:   },
 68:   {
 69:     id: 4,
 70:     name: 'Astronomy Fact Generator',
 71:     features: [
 72:       'Share random, fascinating astronomy facts',
 73:       'Cover a wide range of astronomical topics',
 74:       'Provide brief, engaging explanations',
 75:     ],
 76:     systemMessage:
 77:       'You are an astronomy fact generator. Your purpose is to share interesting and fun facts about astronomy and space. When prompted, randomly select a topic from your vast knowledge base and provide a fascinating fact along with a brief, engaging explanation. Your facts should spark curiosity and encourage further exploration of astronomical topics.',
 78:     enabled: true,
 79:     starterPrompts: [
 80:       "Tell me an interesting fact about Saturn's rings.",
 81:       'Share a mind-blowing fact about the scale of the universe.',
 82:       "What's a surprising fact about stars that most people don't know?",
 83:     ],
 84:   },
 85:   {
 86:     id: 5,
 87:     name: 'Research Assistant',
 88:     features: [
 89:       'Find relevant astronomy papers',
 90:       'Summarize key findings',
 91:       'Suggest related research',
 92:     ],
 93:     systemMessage:
 94:       'You are a research assistant specializing in astronomy and astrophysics. Your role is to help users find relevant scientific papers, summarize key findings, and suggest related research. Provide concise, accurate information and guide users towards valuable resources in their area of interest.',
 95:     enabled: false,
 96:     starterPrompts: [
 97:       'Can you find recent papers on dark matter detection methods?',
 98:       'What are the key findings from the latest research on exoplanet atmospheres?',
 99:       "I'm interested in radio astronomy. What are some fundamental papers I should read to get started?",
100:     ],
101:   },
102:   {
103:     id: 6,
104:     name: 'Space Station Life Simulator',
105:     features: [
106:       'Describe daily routines in space',
107:       'Explain space-specific challenges',
108:       'Simulate space station experiences',
109:     ],
110:     systemMessage:
111:       'You are a Space Station Life Simulator, an expert on daily life and challenges of living in space. Your role is to provide accurate, detailed, and engaging descriptions of life aboard a space station, drawing from real astronaut experiences and scientific knowledge.',
112:     enabled: true,
113:     starterPrompts: [
114:       "What's the most challenging aspect of personal hygiene in space?",
115:       "Describe a typical 'day' for an astronaut on the International Space Station.",
116:       'How do astronauts exercise in zero gravity, and why is it so important?',
117:     ],
118:   },
119:   {
120:     id: 7,
121:     name: 'Dark Matter & Energy Theorist',
122:     features: [
123:       'Explain current dark matter theories',
124:       'Discuss dark energy research',
125:       'Explore implications for the universe',
126:     ],
127:     systemMessage:
128:       'You are a Dark Matter & Energy Theorist, well-versed in current theories and research on these mysterious components of the universe. Your goal is to explain complex concepts in an understandable way, discuss ongoing research, and explore the implications for our understanding of the universe.',
129:     enabled: true,
130:     starterPrompts: [
131:       "What's the strongest evidence we have for the existence of dark matter?",
132:       'How does dark energy affect the expansion of the universe?',
133:       'What are some alternative theories to dark matter and dark energy?',
134:     ],
135:   },
136:   {
137:     id: 8,
138:     name: 'Rocket Science Explainer',
139:     features: [
140:       'Break down rocket propulsion basics',
141:       'Explain different types of rockets',
142:       'Discuss challenges in rocketry',
143:     ],
144:     systemMessage:
145:       'You are a Rocket Science Explainer, adept at breaking down the principles of rocketry and propulsion systems. Your role is to make complex rocket science concepts accessible to a general audience, explaining how rockets work and the challenges involved in space launch systems.',
146:     enabled: true,
147:     starterPrompts: [
148:       'Can you explain how a rocket generates thrust in simple terms?',
149:       'What are the main differences between liquid and solid fuel rockets?',
150:       "What's the concept behind reusable rockets, and why are they important?",
151:     ],
152:   },
153:   {
154:     id: 9,
155:     name: 'Astrobiology Specialist',
156:     features: [
157:       'Discuss potential for extraterrestrial life',
158:       'Explain habitable zone concepts',
159:       'Describe astrobiology research methods',
160:     ],
161:     systemMessage:
162:       'You are an Astrobiology Specialist, focusing on the potential for life in the universe and related research. Your role is to discuss the conditions necessary for life, explain current research in astrobiology, and explore the implications of potentially finding life beyond Earth.',
163:     enabled: true,
164:     starterPrompts: [
165:       'What are the key factors that make a planet potentially habitable?',
166:       'How do scientists search for signs of life on other planets?',
167:       'What would be the implications if we found microbial life on Mars?',
168:     ],
169:   },
170:   {
171:     id: 10,
172:     name: 'Cosmic Calendar Creator',
173:     features: [
174:       'Inform about upcoming astronomical events',
175:       'Explain significance of celestial phenomena',
176:       'Provide viewing tips for events',
177:     ],
178:     systemMessage:
179:       'You are a Cosmic Calendar Creator, an expert on upcoming astronomical events and phenomena. Your role is to inform users about interesting celestial events, explain their significance, and provide tips on how to best observe or appreciate these cosmic occurrences.',
180:     enabled: true,
181:     starterPrompts: [
182:       'What are the most exciting astronomical events coming up in the next month?',
183:       'Can you explain what causes a solar eclipse and when the next one will be visible?',
184:       'How can I best prepare to view the next meteor shower?',
185:     ],
186:   },
187:   {
188:     id: 11,
189:     name: 'Astrophotography Coach',
190:     features: [
191:       'Offer tips for capturing celestial images',
192:       'Explain astrophotography equipment',
193:       'Provide post-processing guidance',
194:     ],
195:     systemMessage:
196:       'You are an Astrophotography Coach, skilled in the art and science of capturing stunning astronomical images. Your role is to offer tips and techniques for astrophotography, explain equipment choices, and provide guidance on image processing to help users create beautiful cosmic photographs.',
197:     enabled: true,
198:     starterPrompts: [
199:       "What's the best way to start astrophotography on a budget?",
200:       'Can you explain the technique of stacking in astrophotography?',
201:       'What settings should I use to photograph the Milky Way?',
202:     ],
203:   },
204:   {
205:     id: 12,
206:     name: 'Space Mission Planner',
207:     features: [
208:       'Explain space mission planning stages',
209:       'Discuss challenges in space exploration',
210:       'Describe different types of space missions',
211:     ],
212:     systemMessage:
213:       'You are a Space Mission Planner, an expert in the complexities of planning and executing space missions. Your role is to help users understand the various stages of mission planning, the challenges involved, and the different types of missions undertaken in space exploration.',
214:     enabled: true,
215:     starterPrompts: [
216:       'What are the key stages in planning a mission to Mars?',
217:       'How do space agencies choose landing sites for planetary missions?',
218:       'What are the main challenges in planning a long-duration space mission?',
219:     ],
220:   },
221:   {
222:     id: 13,
223:     name: 'Cosmic Scale Visualizer',
224:     features: [
225:       'Provide comparisons for cosmic scales',
226:       'Explain distances in space',
227:       'Visualize sizes of celestial objects',
228:     ],
229:     systemMessage:
230:       'You are a Cosmic Scale Visualizer, adept at helping users comprehend the vast distances and sizes in the universe. Your role is to provide relatable comparisons, explain cosmic distances in understandable terms, and help visualize the scale of celestial objects and cosmic structures.',
231:     enabled: true,
232:     starterPrompts: [
233:       'Can you explain the size of our solar system using a relatable analogy?',
234:       'How can we visualize the distance to the nearest star beyond our Sun?',
235:       "What's a good way to understand the scale of the Milky Way galaxy?",
236:     ],
237:   },
238: ]
239: 
240: const chatStore = useChatStore()
241: 
242: definePageMeta({ name: 'Q&A' })
243: 
244: const selectedAgent = ref(null as ChatAgent | null)
245: const message = ref('')
246: const conversation = ref<Message[]>([])
247: const selectedStarterPrompts = ref([] as string[])
248: 
249: const selectAgent = (agent: ChatAgent) => {
250:   if (agent.enabled) {
251:     selectedAgent.value = selectedAgent.value?.id === agent.id ? null : agent
252:     selectedStarterPrompts.value = selectedAgent.value?.starterPrompts || []
253:     conversation.value = []
254:   }
255: }
256: 
257: const closeAgent = () => {
258:   selectedAgent.value = null
259:   selectedStarterPrompts.value = []
260:   conversation.value = []
261: }
262: 
263: const selectPrompt = (prompt: string) => {
264:   message.value = prompt
265:   selectedStarterPrompts.value = []
266: }
267: 
268: const responsiveOptions = ref([
269:   {
270:     breakpoint: '1199px',
271:     numVisible: 3,
272:     numScroll: 3,
273:   },
274:   {
275:     breakpoint: '991px',
276:     numVisible: 2,
277:     numScroll: 2,
278:   },
279:   {
280:     breakpoint: '767px',
281:     numVisible: 1,
282:     numScroll: 1,
283:   },
284: ])
285: </script>
286: 
287: <template>
288:   <div class="flex h-[calc(100vh-32px)] flex-col">
289:     <div
290:       class="mx-auto grid h-full max-w-[1000px] grid-cols-1 overflow-scroll p-4 md:grid-cols-[1fr_minmax(200px,700px)_1fr]"
291:     >
292:       <div class="w-full md:col-span-3 md:col-start-1 md:row-start-1">
293:         <div class="space-y-2 pb-6 text-center">
294:           <h1 class="text-5xl font-semibold"> Galactic Guide </h1>
295:           <div class="flex gap-2 pt-2">
296:             <PrimeMessage
297:               severity="info"
298:               class="flex w-full justify-center"
299:             >
300:               3 question limit per 30 min
301:             </PrimeMessage>
302:             <PrimeMessage
303:               severity="warn"
304:               class="flex w-full justify-center"
305:             >
306:               Always validate answers.
307:             </PrimeMessage>
308:           </div>
309:         </div>
310:         <PrimeCarousel
311:           :value="agents"
312:           :num-visible="3"
313:           :num-scroll="3"
314:           :responsive-options="responsiveOptions"
315:         >
316:           <template #item="slotProps">
317:             <div
318:               class="m-2 rounded border border-color p-4"
319:               :class="{
320:                 'cursor-pointer transition-shadow hover:shadow-lg': slotProps.data.enabled,
321:                 'opacity-50': !slotProps.data.enabled,
322:               }"
323:               @click="slotProps.data.enabled && selectAgent(slotProps.data)"
324:             >
325:               <div class="mb-4 font-medium">
326:                 {{ slotProps.data.name }}
327:               </div>
328:               <div class="mb-4">
329:                 <ul class="list-disc pl-5">
330:                   <li
331:                     v-for="feature in slotProps.data.features"
332:                     :key="feature"
333:                     class="text-sm"
334:                   >
335:                     {{ feature }}
336:                   </li>
337:                 </ul>
338:               </div>
339:               <div class="flex items-center justify-between">
340:                 <PrimeTag
341:                   :value="slotProps.data.enabled ? 'Enabled' : 'Disabled'"
342:                   :severity="slotProps.data.enabled ? 'success' : 'danger'"
343:                 />
344: 
345:                 <PrimeTag
346:                   v-if="selectedAgent?.id === slotProps.data.id"
347:                   value="Selected"
348:                   severity="info"
349:                 />
350:               </div>
351:             </div>
352:           </template>
353:         </PrimeCarousel>
354:       </div>
355:       <div
356:         class="mx-auto flex h-full w-full flex-col justify-between gap-4 md:col-start-2 md:row-start-2 xl:gap-8"
357:       >
358:         <div
359:           v-if="chatStore.messages.length"
360:           class="space-y-4 pb-4 xl:space-y-8 xl:pb-8"
361:         >
362:           <div
363:             v-for="(msg, index) in chatStore.messages"
364:             :key="index"
365:             :class="msg.role"
366:           >
367:             <p class="pb-2 pl-2">
368:               <strong class="pb-4">{{ msg.role === 'user' ? 'You' : 'Assistant' }}</strong>
369:             </p>
370:             <div class="w-full rounded-md bg-primary-950 p-4 text-surface-300">
371:               <MDC
372:                 :value="msg.content"
373:                 class="prose prose-invert"
374:               />
375:             </div>
376:           </div>
377:         </div>
378:       </div>
379:     </div>
380: 
381:     <!-- Fixed Bottom Bar -->
382: 
383:     <div class="foreground border-color flex-shrink-0 border-t p-4">
384:       <div class="mx-auto max-w-[600px]">
385:         <div
386:           v-if="selectedStarterPrompts.length"
387:           class="space-y-2 pb-2"
388:         >
389:           <div class="flex justify-center items-center">
390:             <p class="text-center flex-grow font-semibold"> Example Questions </p>
391:             <PrimeButton
392:               severity="secondary"
393:               class="text-end ml-auto text-white font-semibold"
394:               @click="closeAgent"
395:             >
396:               X
397:             </PrimeButton>
398:           </div>
399:           <PrimeButton
400:             v-for="prompt in selectedStarterPrompts"
401:             :key="prompt"
402:             severity="secondary"
403:             outlined
404:             class="mb-2 mr-2 flex w-full items-start justify-start text-left"
405:             @click="selectPrompt(prompt)"
406:           >
407:             {{ prompt }}
408:           </PrimeButton>
409:         </div>
410:         <SearchBar
411:           :selected-prompt="message"
412:           :system-prompt="selectedAgent?.systemMessage"
413:         />
414:       </div>
415:     </div>
416:   </div>
417: </template>
418: 
419: <style scoped></style>
```

## File: apps/main-app/pages/auth-callback.vue
```vue
 1: // pages/auth-callback.vue
 2: <template>
 3:   <div class="w-full h-full flex justify-center items-center">Authenticating...</div>
 4: </template>
 5: 
 6: <script setup lang="ts">
 7: import { useRoute, useRouter } from 'vue-router'
 8: import { useSupabaseClient } from '#imports'
 9: 
10: const route = useRoute()
11: const router = useRouter()
12: const supabase = useSupabaseClient()
13: 
14: const isProcessing = ref(false)
15: 
16: const handleAuth = async () => {
17:   if (isProcessing.value) return
18:   isProcessing.value = true
19: 
20:   const code = route.query.code as string
21: 
22:   if (!code) {
23:     console.error('No code found in URL')
24:     router.push('/login')
25:     return
26:   }
27: 
28:   try {
29:     const { data, error } = await supabase.auth.getSession()
30: 
31:     if (error) throw error
32: 
33:     if (data.session) {
34:       console.log('Session established:', data.session)
35:       router.push('/')
36:     } else {
37:       throw new Error('No session established')
38:     }
39:   } catch (error) {
40:     console.error('Error during authentication:', error)
41:     router.push('/login')
42:   } finally {
43:     isProcessing.value = false
44:   }
45: }
46: 
47: onMounted(() => {
48:   handleAuth()
49: })
50: </script>
```

## File: apps/main-app/pages/companies.vue
```vue
 1: <script setup lang="ts">
 2: const domainKey = 'companies'
 3: const { store, loadMore } = await useSelectData<Companies>('companies', {
 4:   columns:
 5:     'id, name, description, logo_url, url, scrape_frequency, founding_year, created_at, updated_at, is_government, category_id, social_media_id, scrape_rating, content_status, scraped_at, keywords',
 6:   filters: { content_status: { eq: 'draft' } },
 7:   orderBy: { column: 'created_at', ascending: false },
 8:   initialFetch: true,
 9:   pagination: { page: 1, limit: 20 },
10: })
11: 
12: const { items: companies } = storeToRefs(store)
13: 
14: const loading = useLoadingStore()
15: const isLoading = computed(() => loading.isLoading(domainKey))
16: 
17: definePageMeta({ name: 'Companies' })
18: </script>
19: 
20: <template>
21:   <div>
22:     <IBInfiniteScroll @update:scroll-end="loadMore">
23:       <div class="grid grid-cols-1 md:grid-cols-[1fr_minmax(200px,480px)_1fr]">
24:         <div class="mx-auto flex w-full max-w-sm flex-col md:col-start-2">
25:           <CompanyCard
26:             v-for="(company, i) in companies"
27:             :key="`companies-post-${i}`"
28:             :company="company"
29:           />
30:           <CompanyCardSkeleton v-show="isLoading" />
31:         </div>
32:         <IBAdvertisement />
33:       </div>
34:     </IBInfiniteScroll>
35:   </div>
36: </template>
```

## File: apps/main-app/pages/events.vue
```vue
 1: <script setup lang="ts">
 2: const domainKey = 'events'
 3: const eventsStore = useEventsStore()
 4: const { events } = storeToRefs(eventsStore)
 5: 
 6: const haveEvents = computed(() => events.value !== null && events.value.length > 0)
 7: 
 8: const fetchInput = ref({
 9:   domainKey,
10:   endpoint: '/api/events/select/cards',
11:   criteria: {
12:     dto: 'select:events:card',
13:   },
14: }) as Ref<FetchInput>
15: 
16: watchEffect(() => {
17:   if (haveEvents.value === false) {
18:     console.log('Fetching events')
19:     eventsStore.loadEvents(fetchInput.value)
20:   }
21: })
22: 
23: const loading = useLoadingStore()
24: const isLoading = computed(() => loading.isLoading(domainKey))
25: 
26: definePageMeta({ name: 'Events' })
27: </script>
28: 
29: <template>
30:   <div>
31:     <IBInfiniteScroll
32:       :domain-key="domainKey"
33:       :pagination="{
34:         page: 1,
35:         limit: 20,
36:       }"
37:       @update:scroll-end="eventsStore.loadEvents(fetchInput)"
38:     >
39:       <div
40:         v-if="haveEvents"
41:         class="grid grid-cols-1 md:grid-cols-2 md:gap-4 lg:grid-cols-3 xl:grid-cols-4 xl:gap-8"
42:       >
43:         <EventCard
44:           v-for="(event, i) in events"
45:           :key="`events-post-${i}`"
46:           :events="event"
47:         />
48:       </div>
49:       <div
50:         v-else
51:         class="grid grid-cols-1 md:grid-cols-2 md:gap-4 lg:grid-cols-3 2xl:grid-cols-4 2xl:gap-8"
52:       >
53:         <div class="foreground space-y-1 rounded-md p-8 shadow-md">
54:           <h3 class="pb-4 text-xl font-semibold"> No events to show, check back soon. </h3>
55:           <p>
56:             We have regularly scheduled events and are in the process of getting this page working.
57:           </p>
58:         </div>
59:       </div>
60:     </IBInfiniteScroll>
61:   </div>
62: </template>
```

## File: apps/main-app/pages/index.vue
```vue
 1: <script setup lang="ts">
 2: definePageMeta({
 3:   name: 'AstroTribe',
 4: })
 5: 
 6: const userStore = useCurrentUser()
 7: const { profile } = storeToRefs(userStore)
 8: 
 9: const comingSoon = [
10:   'Adding all major companies',
11:   'Adding all major news sources',
12:   'Improving the quality of news/company data',
13:   'AI generated Weekly/Monthly newsletter',
14: ]
15: </script>
16: 
17: <template>
18:   <div
19:     class="grid w-full grid-cols-1 gap-4 p-0 md:grid-cols-2 md:p-4 lg:grid-cols-3 xl:gap-8 xl:p-8"
20:   >
21:     <PrimeCard
22:       class="border-color border"
23:       :pt="{ body: 'justify-between h-full' }"
24:       :pt-options="{ mergeProps: true, mergeSections: true }"
25:     >
26:       <template #content>
27:         <h1 class="pb-4 text-2xl font-semibold"> Welcome {{ profile?.given_name ?? '' }} 👋 </h1>
28:         <h3 class="text-primary-600 pb-4 text-lg font-semibold">
29:           AstroTribe Is Currently In Open Alpha
30:         </h3>
31:         <p>
32:           This means we have limited functionality for now, but be sure to check back often as we
33:           will roll out new features regularly!
34:         </p>
35:       </template>
36:     </PrimeCard>
37:     <PrimeCard class="border-color border">
38:       <template #content>
39:         <div class="space-y-4">
40:           <h3 class="text-xl font-semibold"> Latest News </h3>
41:           <p class="text-base text-slate-200">
42:             Stay current with leading government space agencies and private sector companies from
43:             around the globe.
44:           </p>
45:         </div>
46:       </template>
47:       <template #footer>
48:         <NuxtLink to="/news">
49:           <PrimeButton outlined> Explore Now </PrimeButton>
50:         </NuxtLink>
51:       </template>
52:     </PrimeCard>
53:     <!-- <PrimeCard
54:       class="border-color border"
55:       :pt="{ body: 'justify-between h-full' }"
56:       :pt-options="{ mergeProps: true, mergeSections: true }"
57:     >
58:       <template #content>
59:         <div class="space-y-4">
60:           <h3 class="text-xl font-semibold"> Companies </h3>
61:           <p class="text-base text-slate-200">
62:             Follow the companies that will take us to the Moon, Mars, and beyond. India is our first
63:             focus, then we go global!
64:           </p>
65:         </div>
66:       </template>
67:       <template #footer>
68:         <NuxtLink to="/companies">
69:           <PrimeButton outlined> Search Companies </PrimeButton>
70:         </NuxtLink>
71:       </template>
72:     </PrimeCard> -->
73: 
74:     <div class="row-span-2 space-y-4 md:col-start-2 md:row-start-1 lg:col-start-3">
75:       <PrimeMessage severity="info"> What we're working on </PrimeMessage>
76:       <ul>
77:         <li
78:           v-for="item in comingSoon"
79:           :key="item"
80:           class="py-2"
81:         >
82:           <Icon
83:             name="mdi:chevron-right"
84:             size="16px"
85:             class="text-primary-500"
86:           />
87:           <span class="pl-2">{{ item }}</span>
88:         </li>
89:       </ul>
90:       <IBFeedback cta="Have an idea? We would love to hear it!" />
91:     </div>
92:   </div>
93: </template>
94: 
95: <style scoped></style>
```

## File: apps/main-app/pages/offline.vue
```vue
 1: <template>
 2:   <div class="flex flex-col items-center justify-center p-4 h-full">
 3:     <div class="max-w-md w-full text-center space-y-6">
 4:       <div class="flex justify-center">
 5:         <Icon
 6:           name="material-symbols:wifi-off"
 7:           class="w-20 h-20"
 8:         />
 9:       </div>
10: 
11:       <h1 class="text-3xl font-bold"> No Internet Connection </h1>
12: 
13:       <div class="space-y-4">
14:         <p class="">
15:           The page you're trying to access requires an internet connection. Please check your
16:           connection and try again.
17:         </p>
18: 
19:         <Button
20:           class="inline-flex items-center px-4 py-2 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
21:           @click="reload"
22:         >
23:           Try Again
24:         </Button>
25:       </div>
26: 
27:       <div class="text-sm">
28:         <p>Some features may still be available offline</p>
29:       </div>
30:     </div>
31:   </div>
32: </template>
33: 
34: <script setup lang="ts">
35: const { $isOffline } = useNuxtApp()
36: 
37: // Watch for online status changes
38: watch($isOffline, (offline) => {
39:   if (!offline) {
40:     // Optionally reload when connection is restored
41:     window.location.reload()
42:   }
43: })
44: 
45: const reload = () => {
46:   window.location.reload()
47: }
48: </script>
```

## File: apps/main-app/pages/onboarding.vue
```vue
 1: <template>
 2:   <div class="p-4">
 3:     <h1 class="mb-4 text-3xl font-bold"> Complete Your Profile </h1>
 4:     <PrimeStepper
 5:       v-model:value="activeStep"
 6:       linear
 7:     >
 8:       <PrimeStepList>
 9:         <PrimeStep value="1"> Personal Info </PrimeStep>
10:         <PrimeStep value="2"> Professional Info </PrimeStep>
11:         <PrimeStep value="3"> Interests </PrimeStep>
12:       </PrimeStepList>
13:       <PrimeStepPanels>
14:         <PrimeStepPanel value="1">
15:           <OnboardingAccount @next="nextStep" />
16:         </PrimeStepPanel>
17:         <PrimeStepPanel value="2">
18:           <OnboardingProfessional
19:             @next="nextStep"
20:             @prev="prevStep"
21:           />
22:         </PrimeStepPanel>
23:         <PrimeStepPanel value="3">
24:           <OnboardingInterests
25:             @prev="prevStep"
26:             @submit="handleSubmit"
27:           />
28:         </PrimeStepPanel>
29:       </PrimeStepPanels>
30:     </PrimeStepper>
31:   </div>
32: </template>
33: 
34: <script setup lang="ts">
35: const activeStep = ref('1')
36: const { form } = useOnboarding()
37: 
38: const nextStep = () => {
39:   activeStep.value = String(Number(activeStep.value) + 1)
40: }
41: 
42: const prevStep = () => {
43:   activeStep.value = String(Number(activeStep.value) - 1)
44: }
45: 
46: const handleSubmit = () => {
47:   console.log('Form submitted:', form)
48:   // You can add your API call here
49: }
50: </script>
```

## File: apps/main-app/pages/research.vue
```vue
 1: <script setup lang="ts">
 2: const researchStore = useResearchStore()
 3: const domainKey = 'research'
 4: 
 5: const { research } = storeToRefs(researchStore)
 6: const haveResearch = computed(() => research.value !== null && research.value.length > 0)
 7: 
 8: const fetchInput = ref({
 9:   domainKey,
10:   endpoint: '/api/research/select/cards',
11:   criteria: {
12:     dto: 'select:research:card',
13:   },
14: })
15: 
16: watchEffect(() => {
17:   if (haveResearch.value === false) {
18:     console.log('Fetching research')
19:     researchStore.loadResearch(fetchInput.value)
20:   }
21: })
22: 
23: console.log('research', research)
24: 
25: definePageMeta({
26:   name: 'Research',
27: })
28: </script>
29: 
30: <template>
31:   <div class="relative flex h-full w-full flex-col">
32:     <!-- <SummaryLevel /> -->
33:     <IBInfiniteScroll
34:       :domain-key="domainKey"
35:       :pagination="{
36:         page: 1,
37:         limit: 20,
38:       }"
39:       @update:scroll-end="researchStore.loadResearch('select:venue:card')"
40:     >
41:       <div class="mx-auto grid grid-cols-1 md:grid-cols-2 md:gap-4 xl:grid-cols-3 xl:gap-8">
42:         <ResearchCard
43:           v-for="(item, index) in research"
44:           :key="`research-post-${index}`"
45:           :research="item"
46:         />
47:       </div>
48:     </IBInfiniteScroll>
49:   </div>
50: </template>
```

## File: apps/main-app/plugins/formbricks.client.ts
```typescript
 1: import formbricks from '@formbricks/js'
 2: 
 3: export default defineNuxtPlugin((nuxtApp) => {
 4:   const { formbricksHost, formbricksEnvironment } = nuxtApp.$config.public
 5: 
 6:   if (typeof window !== 'undefined') {
 7:     formbricks.init({
 8:       environmentId: formbricksEnvironment,
 9:       apiHost: formbricksHost,
10:     })
11:   }
12: 
13:   console.log('Formbricks initialized', formbricks)
14:   // Make formbricks available throughout the app
15:   nuxtApp.provide('formbricks', formbricks)
16: 
17:   // Register route change handler
18:   nuxtApp.hook('page:finish', () => {
19:     if (typeof formbricks !== 'undefined') {
20:       formbricks.registerRouteChange()
21:     }
22:   })
23: })
```

## File: apps/main-app/plugins/pwa.client.ts
```typescript
 1: export default defineNuxtPlugin(() => {
 2:   const notification = useNotification()
 3:   const isOffline = ref(!navigator.onLine)
 4:   const { $pwa } = useNuxtApp()
 5: 
 6:   if (import.meta.dev && import.meta.client) {
 7:     console.log('Development mode: Cleaning up service workers...')
 8: 
 9:     if ('serviceWorker' in navigator) {
10:       navigator.serviceWorker
11:         .getRegistrations()
12:         .then((registrations) => {
13:           registrations.forEach((registration) => {
14:             registration.unregister()
15:             console.log('Service worker unregistered:', registration.scope)
16:           })
17:         })
18:         .catch((error) => {
19:           console.error('Service worker cleanup failed:', error)
20:         })
21:     }
22:   }
23: 
24:   if (import.meta.client) {
25:     // Handle online/offline status
26:     window.addEventListener('online', () => {
27:       isOffline.value = false
28:       notification.success({
29:         summary: 'Connection Restored',
30:         message: 'Your internet connection has been restored',
31:       })
32:     })
33: 
34:     window.addEventListener('offline', () => {
35:       isOffline.value = true
36:       notification.warn({
37:         summary: 'Offline Mode',
38:         message: 'You are currently offline. Some features may be limited',
39:       })
40:     })
41: 
42:     // PWA functionality
43:     if ($pwa) {
44:       // Handle offline ready
45:       watch(
46:         () => $pwa.offlineReady.value,
47:         (ready) => {
48:           if (ready) {
49:             notification.success({
50:               summary: 'App Ready',
51:               message: 'Content has been cached for offline use',
52:             })
53:           }
54:         },
55:       )
56: 
57:       // Handle updates
58:       watch(
59:         () => $pwa.needRefresh.value,
60:         (needRefresh) => {
61:           if (needRefresh) {
62:             notification.info({
63:               summary: 'Update Available',
64:               message: 'Click here to update to the latest version',
65:             })
66:           }
67:         },
68:       )
69:     }
70:   }
71: 
72:   return {
73:     provide: {
74:       isOffline: readonly(isOffline),
75:     },
76:   }
77: })
```

## File: apps/main-app/server/api/ai/ask.ts
```typescript
 1: import { useLogger } from '@ib/logger'
 2: import { openAI } from '~/server/utils/openai/callOpenAI'
 3: import { serverSupabaseUser } from '#supabase/server'
 4: 
 5: const log = useLogger('API:ASK')
 6: 
 7: export default defineEventHandler({
 8:   onRequest: [rateLimiter],
 9:   onBeforeResponse: [],
10:   handler: async (event) => {
11:     const { messages } = await readBody(event)
12: 
13:     if (!Array.isArray(messages) || messages.length === 0) {
14:       return {
15:         statusCode: 400,
16:         error: {
17:           message: 'messages must be a non-empty array',
18:         },
19:       }
20:     }
21: 
22:     const isValidMessage = (msg) =>
23:       msg &&
24:       typeof msg === 'object' &&
25:       ['system', 'user', 'assistant'].includes(msg.role) &&
26:       typeof msg.content === 'string'
27: 
28:     if (!messages.every(isValidMessage)) {
29:       return {
30:         statusCode: 400,
31:         error: {
32:           message: 'Invalid message format',
33:         },
34:       }
35:     }
36: 
37:     console.log('messages', messages)
38: 
39:     try {
40:       const user = await serverSupabaseUser(event)
41:       let chatCompletion
42: 
43:       const plan = user?.app_metadata?.plan
44: 
45:       if (plan === 'free') {
46:         console.log('getGroqChatCompletion')
47:         chatCompletion = await getGroqChatCompletion(messages)
48:       } else if (plan === 'pro' || plan === 'expert') {
49:         console.log('openAI.createChatCompletion')
50:         chatCompletion = openAI.createChatCompletion(messages)
51:       } else {
52:         log.warn('no user plan', plan)
53:       }
54: 
55:       return {
56:         error: null,
57:         statusCode: 200,
58:         data: chatCompletion || '',
59:       }
60:     } catch (error) {
61:       log.error('error', error)
62:       return {
63:         data: null,
64:         error,
65:         statusCode: 500,
66:       }
67:     }
68:   },
69: })
```

## File: apps/main-app/server/api/bookmarks/[id].delete.ts
```typescript
 1: import { serverSupabaseUser, serverSupabaseClient } from '#supabase/server'
 2: 
 3: // server/api/bookmarks/[id].delete.ts
 4: export default defineEventHandler(async (event) => {
 5:   const user = await serverSupabaseUser(event)
 6:   const bookmarkId = event.context.params.id
 7: 
 8:   if (!user) {
 9:     throw createError({
10:       statusCode: 401,
11:       message: 'Unauthorized',
12:     })
13:   }
14: 
15:   const supabase = await serverSupabaseClient(event)
16: 
17:   const { error } = await supabase
18:     .from('bookmarks')
19:     .delete()
20:     .eq('id', bookmarkId)
21:     .eq('user_id', user.id)
22: 
23:   if (error) {
24:     throw createError({
25:       statusCode: 500,
26:       message: 'Failed to delete bookmark',
27:     })
28:   }
29: 
30:   return { success: true }
31: })
```

## File: apps/main-app/server/api/bookmarks/index.ts
```typescript
  1: import { serverSupabaseUser, serverSupabaseClient } from '#supabase/server'
  2: 
  3: // server/api/bookmarks/index.ts
  4: export default defineEventHandler(async (event) => {
  5:   try {
  6:     const { content_type = 'news', folder_id = null, include_subfolders = false } = getQuery(event)
  7:     const user = await serverSupabaseUser(event)
  8:     const supabase = await serverSupabaseClient(event)
  9: 
 10:     if (!user) {
 11:       throw createError({
 12:         statusCode: 401,
 13:         message: 'Unauthorized',
 14:       })
 15:     }
 16: 
 17:     // Simplify the query first to debug
 18:     let query = supabase
 19:       .from('bookmarks')
 20:       .select(
 21:         `
 22:           *,
 23:           folder:folder_id (
 24:             id,
 25:             name,
 26:             color,
 27:             path,
 28:             is_favorite
 29:           )
 30:         `,
 31:       )
 32:       .eq('user_id', user.id)
 33:       .eq('content_type', content_type)
 34: 
 35:     if (folder_id) {
 36:       if (include_subfolders) {
 37:         const { data: folderPath } = await supabase
 38:           .from('bookmark_folders')
 39:           .select('path')
 40:           .eq('id', folder_id)
 41:           .single()
 42: 
 43:         if (folderPath) {
 44:           const { data: subFolders } = await supabase
 45:             .from('bookmark_folders')
 46:             .select('id')
 47:             .eq('user_id', user.id)
 48:             .like('path', `${folderPath.path}%`)
 49: 
 50:           const folderIds = subFolders?.map((f) => f.id) || []
 51:           query = query.in('folder_id', [folder_id, ...folderIds])
 52:         }
 53:       } else {
 54:         query = query.eq('folder_id', folder_id)
 55:       }
 56:     }
 57: 
 58:     const { data, error } = await query
 59: 
 60:     if (error) {
 61:       console.error('Supabase query error:', error)
 62:       throw createError({
 63:         statusCode: 500,
 64:         message: error.message,
 65:       })
 66:     }
 67: 
 68:     // If we got the bookmarks, now get the news content
 69:     if (data && data.length > 0) {
 70:       const contentIds = data.map((b) => b.content_id)
 71:       const { data: newsData, error: newsError } = await supabase
 72:         .from('news')
 73:         .select('*')
 74:         .in('id', contentIds)
 75: 
 76:       if (newsError) {
 77:         console.error('News fetch error:', newsError)
 78:         throw createError({
 79:           statusCode: 500,
 80:           message: newsError.message,
 81:         })
 82:       }
 83: 
 84:       // Merge the news data with bookmarks
 85:       const enrichedBookmarks = data.map((bookmark) => {
 86:         const newsItem = newsData?.find((n) => n.id === bookmark.content_id)
 87:         return {
 88:           ...bookmark,
 89:           news: newsItem,
 90:         }
 91:       })
 92: 
 93:       return { data: enrichedBookmarks }
 94:     }
 95: 
 96:     return { data: data || [] }
 97:   } catch (error) {
 98:     console.error('Error in bookmark endpoint:', error)
 99:     throw error
100:   }
101: })
```

## File: apps/main-app/server/api/bookmarks/move.patch.ts
```typescript
 1: import { serverSupabaseUser, serverSupabaseClient } from '#supabase/server'
 2: 
 3: export default defineEventHandler(async (event: H3Event) => {
 4:   const user = await serverSupabaseUser(event)
 5: 
 6:   if (!user) {
 7:     return createError({
 8:       status: 401,
 9:       message: 'Unauthorized',
10:     })
11:   }
12: 
13:   const supabase = await serverSupabaseClient(event)
14:   const { bookmarkIds, targetFolderId } = await readBody(event)
15: 
16:   return await supabase
17:     .from('bookmarks')
18:     .update({ folder_id: targetFolderId })
19:     .in('id', bookmarkIds)
20:     .eq('user_id', user.id)
21: })
```

## File: apps/main-app/server/api/bookmarks/toggle.ts
```typescript
 1: import { serverSupabaseUser, serverSupabaseClient } from '#supabase/server'
 2: 
 3: export default defineEventHandler(async (event) => {
 4:   const body = await readBody(event)
 5:   const user = await serverSupabaseUser(event)
 6:   const { content_id, content_type, metadata } = body
 7: 
 8:   if (!user) {
 9:     return createError({
10:       status: 401,
11:       message: 'Unauthorized',
12:     })
13:   }
14: 
15:   const supabase = await serverSupabaseClient(event)
16: 
17:   // Check if bookmark exists
18:   const { data: existing } = await supabase
19:     .from('bookmarks')
20:     .select('id')
21:     .eq('user_id', user.id)
22:     .eq('content_id', content_id)
23:     .eq('content_type', content_type)
24:     .maybeSingle()
25: 
26:   if (existing) {
27:     // Remove bookmark
28:     const { error: deleteError } = await supabase
29:       .from('bookmarks')
30:       .delete()
31:       .match({ id: existing.id })
32: 
33:     if (deleteError) {
34:       throw createError({
35:         statusCode: 500,
36:         message: 'Failed to remove bookmark',
37:       })
38:     }
39: 
40:     return {
41:       bookmarked: false,
42:     }
43:   }
44: 
45:   // Get default folder if needed
46:   let folder_id = null
47:   const { data: defaultFolder } = await supabase
48:     .from('bookmark_folders')
49:     .select('id')
50:     .eq('user_id', user.id)
51:     .eq('is_default', true)
52:     .single()
53: 
54:   if (defaultFolder) {
55:     folder_id = defaultFolder.id
56:   }
57: 
58:   // Create new bookmark
59:   const { data: newBookmark, error: bookError } = await supabase
60:     .from('bookmarks')
61:     .insert({
62:       user_id: user.id,
63:       content_id,
64:       content_type,
65:       folder_id,
66:       metadata: {
67:         ...metadata,
68:         bookmarked_at: new Date().toISOString(),
69:       },
70:     })
71:     .select()
72:     .single()
73: 
74:   if (bookError) {
75:     throw createError({
76:       statusCode: 500,
77:       message: 'Failed to create bookmark',
78:     })
79:   }
80: 
81:   return {
82:     bookmarked: true,
83:     data: newBookmark,
84:   }
85: })
```

## File: apps/main-app/server/api/folders/[id].delete.ts
```typescript
 1: // server/api/folders/[id].delete.ts
 2: import type { H3Event } from 'h3'
 3: import { serverSupabaseUser, serverSupabaseClient } from '#supabase/server'
 4: 
 5: export default defineEventHandler(async (event: H3Event) => {
 6:   try {
 7:     const user = await serverSupabaseUser(event)
 8:     if (!user) {
 9:       throw createError({ statusCode: 401, message: 'Unauthorized' })
10:     }
11: 
12:     const supabase = await serverSupabaseClient(event)
13:     const id = event.context.params.id
14: 
15:     // Check if this is the default folder
16:     const { data: folder } = await supabase
17:       .from('bookmark_folders')
18:       .select('is_default')
19:       .eq('id', id)
20:       .single()
21: 
22:     if (folder?.is_default) {
23:       throw createError({
24:         statusCode: 400,
25:         message: 'Cannot delete the default folder',
26:       })
27:     }
28: 
29:     // Delete the folder
30:     const { error } = await supabase
31:       .from('bookmark_folders')
32:       .delete()
33:       .eq('id', id)
34:       .eq('user_id', user.id)
35: 
36:     if (error) throw error
37:     return { success: true }
38:   } catch (err) {
39:     console.error('Folder Delete Error:', err)
40:     throw createError({
41:       statusCode: err.statusCode || 500,
42:       message: err.message || 'Internal server error',
43:     })
44:   }
45: })
```

## File: apps/main-app/server/api/folders/[id].patch.ts
```typescript
 1: // server/api/folders/[id].patch.ts
 2: import type { H3Event } from 'h3'
 3: import { serverSupabaseUser, serverSupabaseClient } from '#supabase/server'
 4: 
 5: export default defineEventHandler(async (event: H3Event) => {
 6:   try {
 7:     const user = await serverSupabaseUser(event)
 8:     if (!user) {
 9:       throw createError({ statusCode: 401, message: 'Unauthorized' })
10:     }
11: 
12:     const supabase = await serverSupabaseClient(event)
13:     const id = event.context.params.id
14:     const updates = await readBody(event)
15: 
16:     // Validate updates
17:     if (updates.name !== undefined && !updates.name.trim()) {
18:       throw createError({
19:         statusCode: 400,
20:         message: 'Folder name cannot be empty',
21:       })
22:     }
23: 
24:     const { data, error } = await supabase
25:       .from('bookmark_folders')
26:       .update(updates)
27:       .eq('id', id)
28:       .eq('user_id', user.id)
29:       .select()
30:       .single()
31: 
32:     if (error) throw error
33:     return { data }
34:   } catch (err) {
35:     console.error('Folder Update Error:', err)
36:     throw createError({
37:       statusCode: err.statusCode || 500,
38:       message: err.message || 'Internal server error',
39:     })
40:   }
41: })
```

## File: apps/main-app/server/api/folders/index.ts
```typescript
 1: // server/api/folders/index.ts
 2: import type { H3Event } from 'h3'
 3: import { serverSupabaseUser, serverSupabaseClient } from '#supabase/server'
 4: 
 5: export default defineEventHandler(async (event: H3Event) => {
 6:   try {
 7:     const user = await serverSupabaseUser(event)
 8:     if (!user) {
 9:       throw createError({ statusCode: 401, message: 'Unauthorized' })
10:     }
11: 
12:     const supabase = await serverSupabaseClient(event)
13: 
14:     // GET /api/folders
15:     if (event.method === 'GET') {
16:       const { data, error } = await supabase
17:         .from('bookmark_folders')
18:         .select('*')
19:         .eq('user_id', user.id)
20:         .order('position')
21: 
22:       if (error) throw error
23:       return { data }
24:     }
25: 
26:     // POST /api/folders
27:     if (event.method === 'POST') {
28:       const body = await readBody(event)
29: 
30:       // Validate required fields
31:       if (!body.name?.trim()) {
32:         throw createError({
33:           statusCode: 400,
34:           message: 'Folder name is required',
35:         })
36:       }
37: 
38:       // Get current folder count
39:       const { count } = await supabase
40:         .from('bookmark_folders')
41:         .select('*', { count: 'exact' })
42:         .eq('user_id', user.id)
43: 
44:       // Validate feature limit
45:       await validateFeatureLimit(event, 'BOOKMARK_FOLDERS', count || 0)
46: 
47:       // Insert new folder
48:       const { data, error: insertError } = await supabase
49:         .from('bookmark_folders')
50:         .insert({
51:           ...body,
52:           user_id: user.id,
53:           position: count || 0,
54:         })
55:         .select()
56:         .single()
57: 
58:       if (insertError) throw insertError
59:       return { data }
60:     }
61: 
62:     throw createError({ statusCode: 405, message: 'Method not allowed' })
63:   } catch (err) {
64:     console.error('Folder API Error:', err)
65:     throw createError({
66:       statusCode: err.statusCode || 500,
67:       message: err.message || 'Internal server error',
68:     })
69:   }
70: })
```

## File: apps/main-app/server/api/payment/[provider]/create-order.ts
```typescript
 1: // server/api/payment/[provider]/create-order.post.ts
 2: import { useRuntimeConfig } from '#imports'
 3: import { generateServerToken } from '~/server/utils/generateServerToken'
 4: 
 5: export default defineEventHandler(async (event) => {
 6:   const provider = getRouterParam(event, 'provider')
 7:   const body = await readBody(event)
 8:   const config = useRuntimeConfig().public
 9: 
10:   console.log('provider:', provider)
11: 
12:   let backendUrl = config.scraperUrl
13:   if (provider === 'razorpay') {
14:     console.log('provider is razorpay')
15:     backendUrl = backendUrl.concat('/api/customer/subscription/create')
16:   } else if (provider === 'stripe') {
17:     backendUrl = backendUrl.concat('/api/customer/subscription/create')
18:   } else {
19:     throw createError({
20:       statusCode: 400,
21:       statusMessage: 'Invalid payment provider',
22:     })
23:   }
24: 
25:   console.log('backendUrl:', backendUrl)
26: 
27:   const token = generateServerToken()
28: 
29:   try {
30:     const response = await $fetch(backendUrl, {
31:       method: 'POST',
32:       body,
33:       headers: {
34:         Authorization: `Bearer ${token}`,
35:       },
36:     })
37: 
38:     return response
39:   } catch (error) {
40:     console.error(`Error creating order with ${provider}:`, error)
41:     throw createError({
42:       statusCode: 500,
43:       statusMessage: `Failed to create order with ${provider}`,
44:     })
45:   }
46: })
```

## File: apps/main-app/server/api/payment/[provider]/subscription.get.ts
```typescript
 1: import { useRuntimeConfig } from '#imports'
 2: import { generateServerToken } from '~/server/utils/generateServerToken'
 3: 
 4: export default defineEventHandler(async (event) => {
 5:   const provider = getRouterParam(event, 'provider')
 6:   const config = useRuntimeConfig().public
 7: 
 8:   const backendUrl = config.scraperUrl
 9:   if (provider === 'razorpay') {
10:     backendUrl.concat('/api/customer/subscription')
11:   } else if (provider === 'stripe') {
12:     backendUrl.concat('/api/customer/subscription')
13:   } else {
14:     throw createError({
15:       statusCode: 400,
16:       statusMessage: 'Invalid payment provider',
17:     })
18:   }
19: 
20:   const token = generateServerToken()
21: 
22:   try {
23:     const response = await $fetch(backendUrl, {
24:       headers: {
25:         Authorization: `Bearer ${token}`,
26:       },
27:     })
28:     return response
29:   } catch (error) {
30:     console.error(`Error fetching subscription from ${provider}:`, error)
31:     throw createError({
32:       statusCode: 500,
33:       statusMessage: `Failed to fetch subscription from ${provider}`,
34:     })
35:   }
36: })
```

## File: apps/main-app/server/api/payment/[provider]/verify-payment.post.ts
```typescript
 1: // server/api/payment/[provider]/verify-payment.post.ts
 2: import { useRuntimeConfig } from '#imports'
 3: import { generateServerToken } from '~/server/utils/generateServerToken'
 4: 
 5: export default defineEventHandler(async (event) => {
 6:   const provider = getRouterParam(event, 'provider')
 7:   const body = await readBody(event)
 8:   const config = useRuntimeConfig().public
 9: 
10:   const backendUrl = config.scraperUrl
11:   if (provider === 'razorpay') {
12:     backendUrl.concat('/api/customer/subscription/verify-payment')
13:   } else if (provider === 'stripe') {
14:     backendUrl.concat('/api/customer/subscription/verify-payment')
15:   } else {
16:     throw createError({
17:       statusCode: 400,
18:       statusMessage: 'Invalid payment provider',
19:     })
20:   }
21: 
22:   const token = generateServerToken()
23: 
24:   try {
25:     const response = await $fetch(backendUrl, {
26:       method: 'POST',
27:       body,
28:       headers: {
29:         Authorization: `Bearer ${token}`,
30:       },
31:     })
32:     return response
33:   } catch (error) {
34:     console.error(`Error verifying payment with ${provider}:`, error)
35:     throw createError({
36:       statusCode: 500,
37:       statusMessage: `Failed to verify payment with ${provider}`,
38:     })
39:   }
40: })
```

## File: apps/main-app/server/api/users/update.post.ts
```typescript
 1: import { serverSupabaseClient } from '#supabase/server'
 2: 
 3: export default defineEventHandler(async (event) => {
 4:   try {
 5:     const body = await readBody(event)
 6: 
 7:     const supabase = await serverSupabaseClient(event)
 8: 
 9:     const { data } = await supabase.auth.getUser()
10:     const { user } = data
11: 
12:     if (user && user.email) {
13:       const response = await supabase.from('user_profiles').update(body).eq('id', user.id)
14: 
15:       if (response.error) {
16:         return {
17:           error: response.error,
18:           data: [],
19:           status: 500,
20:           message: 'Error Updating User',
21:         }
22:       } else {
23:         return {
24:           error: null,
25:           data: [],
26:           status: 200,
27:           message: 'User Updated',
28:         }
29:       }
30:     }
31: 
32:     return {
33:       error: null,
34:       data: [],
35:       status: 500,
36:       message: 'Something went wrong',
37:     }
38:   } catch (error) {
39:     return {
40:       error,
41:       data: [],
42:       status: 500,
43:       message: 'Error',
44:     }
45:   }
46: })
```

## File: apps/main-app/server/api/votes/[contentType]/[id].get.ts
```typescript
 1: import { serverSupabaseClient, serverSupabaseUser } from '#supabase/server'
 2: 
 3: export default defineEventHandler(async (event) => {
 4:   const client = await serverSupabaseClient(event)
 5:   const user = await serverSupabaseUser(event)
 6: 
 7:   if (!user) {
 8:     throw createError({
 9:       statusCode: 401,
10:       message: 'Unauthorized',
11:     })
12:   }
13: 
14:   const { contentType, id } = event.context.params
15: 
16:   try {
17:     const { data, error } = await client
18:       .from('votes')
19:       .select('vote_type')
20:       .match({
21:         content_type: contentType,
22:         content_id: id,
23:         user_id: user.id,
24:       })
25:       .single()
26: 
27:     if (error && error.code !== 'PGRST116') throw error
28: 
29:     return {
30:       voteType: data?.vote_type || null,
31:     }
32:   } catch (error) {
33:     console.error('Get vote error:', error)
34:     throw createError({
35:       statusCode: 500,
36:       message: 'Failed to get vote status',
37:     })
38:   }
39: })
```

## File: apps/main-app/server/api/votes/[contentType]/[id].post.ts
```typescript
 1: import { serverSupabaseClient, serverSupabaseUser } from '#supabase/server'
 2: 
 3: export default defineEventHandler(async (event) => {
 4:   const client = await serverSupabaseClient(event)
 5:   const user = await serverSupabaseUser(event)
 6: 
 7:   if (!user) {
 8:     throw createError({
 9:       statusCode: 401,
10:       message: 'Unauthorized',
11:     })
12:   }
13: 
14:   const { contentType, id } = event.context.params
15:   const { voteType } = await readBody(event)
16: 
17:   // Validate content type (only news for now)
18:   if (contentType !== 'news') {
19:     throw createError({
20:       statusCode: 400,
21:       message: 'Invalid content type',
22:     })
23:   }
24: 
25:   // Validate vote type
26:   if (![1, -1].includes(voteType)) {
27:     throw createError({
28:       statusCode: 400,
29:       message: 'Invalid vote type',
30:     })
31:   }
32: 
33:   try {
34:     // Handle vote removal if same vote type is sent
35:     const { data: existingVote } = await client
36:       .from('votes')
37:       .select('vote_type')
38:       .match({
39:         content_type: contentType,
40:         content_id: id,
41:         user_id: user.id,
42:       })
43:       .single()
44: 
45:     if (existingVote?.vote_type === voteType) {
46:       // Remove the vote if it's the same type
47:       const { error } = await client.from('votes').delete().match({
48:         content_type: contentType,
49:         content_id: id,
50:         user_id: user.id,
51:       })
52: 
53:       if (error) throw error
54:       return { success: true, action: 'removed' }
55:     }
56: 
57:     // Insert or update the vote
58:     const { error } = await client.from('votes').upsert(
59:       {
60:         content_type: contentType,
61:         content_id: id,
62:         user_id: user.id,
63:         vote_type: voteType,
64:       },
65:       {
66:         onConflict: 'content_type,content_id,user_id',
67:       },
68:     )
69: 
70:     if (error) throw error
71:     return { success: true, action: 'voted' }
72:   } catch (error) {
73:     console.error('Vote error:', error)
74:     throw createError({
75:       statusCode: 500,
76:       message: 'Failed to process vote',
77:     })
78:   }
79: })
```

## File: apps/main-app/server/api/votes/user/[voteType].get.ts
```typescript
 1: import { serverSupabaseClient, serverSupabaseUser } from '#supabase/server'
 2: 
 3: export default defineEventHandler(async (event) => {
 4:   const client = await serverSupabaseClient(event)
 5:   const user = await serverSupabaseUser(event)
 6: 
 7:   if (!user) {
 8:     throw createError({
 9:       statusCode: 401,
10:       message: 'Unauthorized',
11:     })
12:   }
13: 
14:   const voteType = parseInt(event.context.params.voteType) // 1 for upvotes, -1 for downvotes
15: 
16:   if (![1, -1].includes(voteType)) {
17:     throw createError({
18:       statusCode: 400,
19:       message: 'Invalid vote type',
20:     })
21:   }
22: 
23:   try {
24:     const { data, error } = await client
25:       .from('votes')
26:       .select('content_id')
27:       .eq('content_type', 'news')
28:       .eq('user_id', user.id)
29:       .eq('vote_type', voteType)
30: 
31:     if (error) throw error
32: 
33:     // Get the actual news items
34:     const { data: news, error: newsError } = await client
35:       .from('news')
36:       .select('*')
37:       .in(
38:         'id',
39:         data.map((v) => v.content_id),
40:       )
41:       .order('created_at', { ascending: false })
42: 
43:     if (newsError) throw newsError
44: 
45:     return news
46:   } catch (error) {
47:     console.error('Get voted news error:', error)
48:     throw createError({
49:       statusCode: 500,
50:       message: 'Failed to get voted news',
51:     })
52:   }
53: })
```

## File: apps/main-app/server/api/votes/user.get.ts
```typescript
 1: import { serverSupabaseClient, serverSupabaseUser } from '#supabase/server'
 2: 
 3: export default defineEventHandler(async (event) => {
 4:   const client = await serverSupabaseClient(event)
 5:   const user = await serverSupabaseUser(event)
 6: 
 7:   if (!user) {
 8:     throw createError({
 9:       statusCode: 401,
10:       message: 'Unauthorized',
11:     })
12:   }
13: 
14:   try {
15:     const { data, error } = await client
16:       .from('votes')
17:       .select('content_id, vote_type')
18:       .eq('content_type', 'news')
19:       .eq('user_id', user.id)
20: 
21:     if (error) throw error
22: 
23:     // Transform into a more efficient lookup object
24:     const voteLookup = data.reduce(
25:       (acc, vote) => {
26:         acc[vote.content_id] = vote.vote_type
27:         return acc
28:       },
29:       {} as Record<string, number>,
30:     )
31: 
32:     return {
33:       votes: voteLookup,
34:     }
35:   } catch (error) {
36:     console.error('Get votes error:', error)
37:     throw createError({
38:       statusCode: 500,
39:       message: 'Failed to get votes',
40:     })
41:   }
42: })
```

## File: apps/main-app/server/api/webhook/database.ts
```typescript
1: export default defineEventHandler(async (event) => {
2:   const data = await readBody(event)
3: 
4:   console.log('SUPABASE DB WEBHOOK EVENT', data)
5: })
```

## File: apps/main-app/server/api/upload.ts
```typescript
  1: import crypto from 'crypto'
  2: import { defineEventHandler, createError } from 'h3'
  3: import { PDFDocument } from 'pdf-lib'
  4: import lame from 'node-lame'
  5: import ffmpeg from 'fluent-ffmpeg'
  6: import { serverSupabaseClient } from '#supabase/server'
  7: 
  8: // Base optimizer interface
  9: interface FileOptimizer {
 10:   optimize(
 11:     buffer: Buffer,
 12:     options: any,
 13:   ): Promise<{
 14:     data: Buffer
 15:     extension: string
 16:     mimeType: string
 17:   }>
 18: }
 19: 
 20: // Image optimizer using Sharp
 21: // class ImageOptimizer implements FileOptimizer {
 22: //   async optimize(buffer: Buffer, options: any) {
 23: //     const { maxWidth = 1920, maxHeight = 1080, quality = 80 } = options
 24: //     const optimized = await sharp(buffer)
 25: //       .resize(maxWidth, maxHeight, { fit: 'inside', withoutEnlargement: true })
 26: //       .webp({ quality })
 27: //       .toBuffer()
 28: //     return { data: optimized, extension: 'webp', mimeType: 'image/webp' }
 29: //   }
 30: // }
 31: 
 32: // PDF optimizer using pdf-lib
 33: class PDFOptimizer implements FileOptimizer {
 34:   async optimize(buffer: Buffer, options: any) {
 35:     const pdfDoc = await PDFDocument.load(buffer)
 36:     // Implement PDF optimization logic here
 37:     const optimized = await pdfDoc.save({ useObjectStreams: false })
 38:     return { data: Buffer.from(optimized), extension: 'pdf', mimeType: 'application/pdf' }
 39:   }
 40: }
 41: 
 42: class VideoOptimizer implements FileOptimizer {
 43:   async optimize(buffer: Buffer, options: any) {
 44:     const {
 45:       maxWidth = 1920,
 46:       maxHeight = 1080,
 47:       videoBitrate = '1000k',
 48:       audioBitrate = '128k',
 49:     } = options
 50: 
 51:     return new Promise((resolve, reject) => {
 52:       ffmpeg()
 53:         .input(buffer)
 54:         .videoFilters(
 55:           `scale='min(${maxWidth},iw)':min'(${maxHeight},ih)':force_original_aspect_ratio=decrease`,
 56:         )
 57:         .videoBitrate(videoBitrate)
 58:         .audioBitrate(audioBitrate)
 59:         .toFormat('mp4')
 60:         .on('end', (stdout, stderr) => {
 61:           resolve({ data: stdout, extension: 'mp4', mimeType: 'video/mp4' })
 62:         })
 63:         .on('error', reject)
 64:         .pipe()
 65:     })
 66:   }
 67: }
 68: 
 69: class AudioOptimizer implements FileOptimizer {
 70:   async optimize(buffer: Buffer, options: any) {
 71:     const { bitrate = 128 } = options
 72: 
 73:     const encoder = new lame.Lame({
 74:       output: 'buffer',
 75:       bitrate: bitrate,
 76:     }).setBuffer(buffer)
 77: 
 78:     const encodedBuffer = await encoder.encode()
 79:     return { data: encodedBuffer, extension: 'mp3', mimeType: 'audio/mpeg' }
 80:   }
 81: }
 82: 
 83: // Optimizer factory
 84: class OptimizerFactory {
 85:   private optimizers: Map<string, FileOptimizer> = new Map()
 86: 
 87:   register(mimeType: string, optimizer: FileOptimizer) {
 88:     this.optimizers.set(mimeType, optimizer)
 89:   }
 90: 
 91:   getOptimizer(mimeType: string): FileOptimizer | undefined {
 92:     return this.optimizers.get(mimeType)
 93:   }
 94: }
 95: 
 96: // Create and configure the optimizer factory
 97: const optimizerFactory = new OptimizerFactory()
 98: // optimizerFactory.register('image', new ImageOptimizer())
 99: optimizerFactory.register('application/pdf', new PDFOptimizer())
100: optimizerFactory.register('video', new VideoOptimizer())
101: optimizerFactory.register('audio', new AudioOptimizer())
102: 
103: export default defineEventHandler(async (event) => {
104:   console.log('File optimization and upload eventHandler')
105:   const form = await readMultipartFormData(event)
106:   if (!form?.length) {
107:     throw createError({ statusCode: 400, statusMessage: 'No form data provided' })
108:   }
109: 
110:   const userId = form.find((item) => item.name === 'userId')?.data.toString()
111:   const fileType = form.find((item) => item.name === 'fileType')?.data.toString()
112:   const bucket = form.find((item) => item.name === 'bucket')?.data.toString()
113:   const path = form.find((item) => item.name === 'path')?.data.toString()
114:   const optimizationOptions = JSON.parse(
115:     form.find((item) => item.name === 'optimizationOptions')?.data.toString() || '{}',
116:   )
117: 
118:   const file = form.find((item) => item.name === 'file')
119:   if (!file) {
120:     throw createError({ statusCode: 400, statusMessage: 'No file provided' })
121:   }
122: 
123:   if (!userId || !fileType || !bucket || !path) {
124:     throw createError({ statusCode: 400, statusMessage: 'Missing required parameters' })
125:   }
126: 
127:   const fileName = `${fileType}-${crypto.randomUUID()}`
128:   const mimeType = file.type || 'application/octet-stream'
129: 
130:   console.log('Processing file:', userId, fileType, fileName, mimeType)
131: 
132:   try {
133:     let optimizedFile: Buffer
134:     let finalExtension: string
135:     let finalMimeType: string
136: 
137:     const optimizerKey = mimeType.split('/')[0]
138:     const optimizer
139:       = optimizerFactory.getOptimizer(optimizerKey) || optimizerFactory.getOptimizer(mimeType)
140: 
141:     if (optimizer) {
142:       const result = await optimizer.optimize(file.data, optimizationOptions)
143:       optimizedFile = result.data
144:       finalExtension = result.extension
145:       finalMimeType = result.mimeType
146:     } else {
147:       console.log('No optimizer found for this file type, uploading as-is')
148:       optimizedFile = file.data
149:       finalExtension = mimeType.split('/')[1]
150:       finalMimeType = mimeType
151:     }
152: 
153:     const client = await serverSupabaseClient(event)
154:     const { error } = await client.storage
155:       .from(bucket)
156:       .upload(`${path}/${fileName}.${finalExtension}`, optimizedFile, {
157:         contentType: finalMimeType,
158:         cacheControl: '3600',
159:         upsert: true,
160:       })
161: 
162:     if (error) {
163:       throw createError({ statusCode: 500, statusMessage: error.message })
164:     }
165: 
166:     // If this is a profile-related upload, update the user_profiles table
167:     if (bucket === 'user-profiles' && ['avatar', 'cover-photo'].includes(fileType)) {
168:       const { error: updateError, data } = await client
169:         .from('user_profiles')
170:         .update({ [fileType]: `${fileName}.${finalExtension}` })
171:         .eq('id', userId)
172:         .select()
173: 
174:       if (updateError) {
175:         console.error('Error updating user profile:', updateError)
176:       } else {
177:         console.log('User profile updated:', data)
178:       }
179:     }
180: 
181:     return {
182:       statusCode: 200,
183:       body: JSON.stringify({
184:         message: 'File successfully uploaded and optimized',
185:         fileName: `${fileName}.${finalExtension}`,
186:       }),
187:     }
188:   } catch (error: any) {
189:     console.error('Error processing file:', error)
190:     throw createError({ statusCode: 500, statusMessage: error.message })
191:   }
192: })
```

## File: apps/main-app/server/middleware/feature-limit.ts
```typescript
 1: import { handleFeatureLimitError } from '../utils/errors'
 2: import { validateFeatureLimit } from '../utils/featureLimits'
 3: import { serverSupabaseUser, serverSupabaseClient } from '#supabase/server'
 4: 
 5: export default defineEventHandler(async (event) => {
 6:   // Only check POST requests
 7:   if (event.method !== 'POST') return
 8: 
 9:   // Get the path to determine which feature to check
10:   const path = getRequestPath(event)
11: 
12:   // Map endpoints to features
13:   const featureMap: Record<string, string> = {
14:     '/api/bookmarks': 'BOOKMARKS',
15:     '/api/folders': 'BOOKMARK_FOLDERS',
16:   }
17: 
18:   const feature = featureMap[path]
19:   if (!feature) return // Not a feature-limited endpoint
20: 
21:   try {
22:     const user = await serverSupabaseUser(event)
23: 
24:     if (!user) {
25:       throw createError({
26:         statusCode: 401,
27:         message: 'Unauthorized',
28:       })
29:     }
30: 
31:     const supabase = await serverSupabaseClient(event)
32: 
33:     // Get the table name from the path
34:     const table = path.split('/')[2] // 'bookmarks' or 'folders'
35: 
36:     // Check current count
37:     const { count } = await supabase
38:       .from(table)
39:       .select('*', { count: 'exact' })
40:       .eq('user_id', user.id)
41: 
42:     await validateFeatureLimit(event, feature, count ?? 0)
43:   } catch (error) {
44:     handleFeatureLimitError(error)
45:   }
46: })
```

## File: apps/main-app/server/plugins/error-handler.ts
```typescript
 1: // server/plugins/error-handler.ts
 2: import { useLoggerAsync, ErrorType } from '@ib/logger'
 3: import type { H3Error } from 'h3'
 4: 
 5: interface ApiResponse {
 6:   error?: {
 7:     code: typeof ErrorType
 8:     message: string
 9:     details?: any
10:   }
11:   status: number
12: }
13: 
14: export default defineNitroPlugin((nitro) => {
15:   nitro.hooks.hook('error', async (error: Error, { event }) => {
16:     const isDev = useRuntimeConfig().public.nodeEnv === 'development'
17:     const logger = await useLoggerAsync('nitro:error')
18: 
19:     // Extract API response from error.data if it exists, or create a new one
20:     const apiResponse: ApiResponse = (error.data as ApiResponse) || {
21:       error: {
22:         code: error.statusCode === 404 ? ErrorType.SERVER_ERROR : ErrorType.SERVER_ERROR,
23:         message: error.message || 'An unexpected error occurred',
24:         details: isDev
25:           ? {
26:               name: error.name,
27:               cause: error.cause,
28:               stack: error.stack,
29:             }
30:           : undefined,
31:       },
32:       status: error.statusCode || 500,
33:     }
34: 
35:     if (event) {
36:       // Log the error with full context
37:       logger.error(`[${event.path}] ${event.method} Error:`, {
38:         code: apiResponse.error?.code,
39:         statusCode: error.statusCode,
40:         message: error.message,
41:         name: error.name,
42:         cause: isDev ? error.cause : undefined,
43:         stack: isDev ? error.stack : undefined,
44:       })
45: 
46:       // Set response
47:       event.node.res.statusCode = apiResponse.status
48:       event.node.res.setHeader('Content-Type', 'application/json')
49: 
50:       // Send sanitized response
51:       const safeResponse = {
52:         ...apiResponse,
53:         error: isDev
54:           ? apiResponse.error
55:           : {
56:               code: apiResponse.error?.code,
57:               message: apiResponse.error?.message,
58:             },
59:       }
60: 
61:       event.node.res.end(JSON.stringify(safeResponse))
62:     } else {
63:       // Log error even if no event context
64:       logger.error('Unhandled Server Error:', {
65:         code: apiResponse.error?.code,
66:         statusCode: error.statusCode,
67:         message: error.message,
68:         name: error.name,
69:         cause: isDev ? error.cause : undefined,
70:         stack: isDev ? error.stack : undefined,
71:       })
72:     }
73:   })
74: })
```

## File: apps/main-app/server/utils/openai/callOpenAI.ts
```typescript
 1: import openAiClient from './openaiClient'
 2: 
 3: type CallOpenAIConfig = {
 4:   temperature?: number // Controls randomness: lower is more deterministic.
 5:   max_tokens?: number // Maximum number of tokens to generate.
 6:   top_p?: number // Nucleus sampling: higher allows more diversity.
 7: }
 8: 
 9: // Asynchronous function to call the OpenAI API with specified parameters.
10: 
11: interface OpenAIInput {
12:   prompt: string
13:   systemMessage: string
14:   config?: CallOpenAIConfig
15: }
16: 
17: const createChatCompletion = async ({ prompt, systemMessage, config }: OpenAIInput) => {
18:   try {
19:     // Make an API call to OpenAI's chat completion endpoint.
20:     const response = await openAiClient.chat.completions.create({
21:       model: 'gpt-3.5-turbo', // Specifies the model to use.
22:       messages: [
23:         // An array of messages that precedes the function call.
24:         { role: 'system', content: systemMessage },
25:         { role: 'user', content: prompt },
26:       ],
27:       temperature: config?.temperature || 0.5,
28:       max_tokens: config?.max_tokens || 600,
29:       top_p: config?.top_p || 0.7,
30:     })
31: 
32:     return response
33:   } catch (error: any) {
34:     console.error('Error calling OpenAI API', error)
35:     throw createError({ message: error.message || 'Failed to call OpenAI API' })
36:   }
37: }
38: 
39: export const openAI = {
40:   createChatCompletion,
41: }
```

## File: apps/main-app/server/utils/openai/openaiClient.ts
```typescript
1: import OpenAI from 'openai/index.mjs'
2: 
3: const openaiClient = new OpenAI({
4:   organization: process.env.OPENAI_ORG_ID,
5:   project: process.env.OPENAI_PROJECT_ID,
6: })
7: 
8: export default openaiClient
```

## File: apps/main-app/server/utils/storage/storageSupabase.ts
```typescript
  1: type FileType = 'venue-logo' | 'venue-featured-image' | 'venue-images' | 'user-avatar'
  2: 
  3: const defaultFileOptions: Record<FileType, string> = {
  4:   'venue-logo': 'logo.jpg',
  5:   'venue-featured-image': 'featured-image.jpg',
  6:   'venue-images': 'images/',
  7:   'user-avatar': 'avatar.jpg',
  8: }
  9: 
 10: type BucketKey = 'profile-public' | 'posts' | 'venues'
 11: 
 12: const selectBucket: Record<FileType, BucketKey> = {
 13:   'venue-logo': 'venues',
 14:   'venue-images': 'venues',
 15:   'venue-featured-image': 'venues',
 16:   'user-avatar': 'profile-public',
 17: }
 18: 
 19: interface UrlConstructorOptions {
 20:   baseURL: string
 21:   bucket: BucketKey
 22:   file: string | null
 23:   folderPath: string
 24:   fileType: FileType
 25:   isPrivate?: boolean
 26:   transform?: {
 27:     width?: number
 28:     height?: number
 29:     fit?: 'contain' | 'cover' | 'fill'
 30:     quality?: number
 31:   } | null
 32: }
 33: 
 34: const stringIsNull = (value: any): boolean =>
 35:   value === null || value === undefined || value === '' || value.length === 0
 36: 
 37: export const constructUrl = (options: UrlConstructorOptions) => {
 38:   const {
 39:     baseURL,
 40:     bucket,
 41:     file,
 42:     folderPath,
 43:     fileType,
 44:     isPrivate = false,
 45:     transform = null,
 46:   } = options
 47: 
 48:   if (stringIsNull(file)) {
 49:     console.log('No file provided, using default file for', fileType)
 50:     return `images/defaults/${defaultFileOptions[fileType]}`
 51:   }
 52: 
 53:   if (file && file.startsWith('http')) {
 54:     return file
 55:   }
 56: 
 57:   const filePath = `${folderPath}/${file}`
 58:   const accessType = isPrivate ? 'private' : 'public'
 59:   const path = transform
 60:     ? `/render/image/${accessType}/${bucket}/${filePath}`
 61:     : `/storage/v1/object/${accessType}/${bucket}/${filePath}`
 62:   const url = new URL(path, baseURL)
 63: 
 64:   if (transform) {
 65:     Object.entries(transform).forEach(([key, value]) => {
 66:       if (value !== undefined) {
 67:         url.searchParams.append(key, value.toString())
 68:       }
 69:     })
 70:   }
 71: 
 72:   return url.href
 73: }
 74: 
 75: export interface GetImageUrlOptions
 76:   extends Omit<UrlConstructorOptions, 'baseURL' | 'bucket' | 'isPrivate' | 'folderPath'> {
 77:   data: any
 78: }
 79: 
 80: function getFileProperty(fileType: FileType, data: any) {
 81:   switch (fileType) {
 82:     case 'user-avatar':
 83:       return {
 84:         file: data.avatar,
 85:         fileCategory: 'avatar',
 86:       }
 87:     default:
 88:       throw createError({ message: 'Invalid fileType in getFileProperty' })
 89:   }
 90: }
 91: 
 92: function formatImageInput(fileType: FileType, data: any) {
 93:   const { file, fileCategory } = getFileProperty(fileType, data)
 94:   return {
 95:     bucket: selectBucket[fileType],
 96:     folderPath: `${data.id}/${fileCategory}`,
 97:     isPrivate: false,
 98:     file,
 99:   }
100: }
101: 
102: export const getImageURL = ({ data, fileType, transform }: GetImageUrlOptions): string => {
103:   const baseURL = useRuntimeConfig().public.supabaseUrl
104:   const { bucket, folderPath, isPrivate, file } = formatImageInput(fileType, data)
105:   if (!baseURL) {
106:     throw createError({
107:       message: 'baseURL not defined in getImageURL',
108:     })
109:   }
110: 
111:   if (!fileType) {
112:     throw createError({ message: 'fileType is required in constructUrl' })
113:   }
114: 
115:   return constructUrl({
116:     baseURL,
117:     bucket,
118:     file,
119:     fileType,
120:     folderPath,
121:     isPrivate,
122:     transform,
123:   })
124: }
125: 
126: export interface GetStorageImagesOptions extends Omit<UrlConstructorOptions, 'baseURL' | 'file'> {}
127: 
128: // export async function getStorageImages(options: GetStorageImagesOptions): Promise<string[]> {
129: //   const { bucket, fileType, folderPath, isPrivate, transform } = options
130: //   const baseURL = useRuntimeConfig().public.supabaseUrl
131: //   if (!bucket || !folderPath) {
132: //     console.error('Bucket and folder are required parameters')
133: //     return []
134: //   }
135: 
136: //   const images: string[] = []
137: 
138: //   const { data, error } = await client.storage.from(bucket).list(folderPath)
139: 
140: //   if (error) {
141: //     console.error(`Error fetching images from ${bucket}:`, error)
142: //     return []
143: //   }
144: 
145: //   if (!data || data.length === 0) {
146: //     console.info(`No data returned from Supabase for bucket ${bucket}`)
147: 
148: //     // use constructUrl to create a default image URL
149: //     const defaultUrlOptions: UrlConstructorOptions = {
150: //       baseURL,
151: //       bucket,
152: //       file: null,
153: //       folderPath: '',
154: //       fileType,
155: //       isPrivate
156: //     }
157: //     return [constructUrl(defaultUrlOptions)]
158: //   }
159: 
160: //   // If you want to store full URLs
161: //   await data.forEach((file: FileObject) => {
162: //     if (!file.name.startsWith('.')) {
163: //       // use constructUrl to create image URLs
164: //       const urlOptions: UrlConstructorOptions = {
165: //         baseURL,
166: //         bucket,
167: //         file: file.name,
168: //         folderPath,
169: //         fileType,
170: //         isPrivate,
171: //         transform
172: //       }
173: //       images.push(constructUrl(urlOptions))
174: //     }
175: //   })
176: 
177: //   return images
178: // }
```

## File: apps/main-app/server/utils/agents.ts
```typescript
 1: export const agents = [
 2:   {
 3:     id: 1,
 4:     name: 'Research Assistant',
 5:     features: ['Find Papers', 'Bullet two'],
 6:     systemMessage: 'This is an example base prompt',
 7:   },
 8:   {
 9:     id: 2,
10:     name: 'Summarizer',
11:     features: ['Summarize all content consicely', 'Bullet two'],
12:     systemMessage: 'This is an example base prompt',
13:   },
14: ]
```

## File: apps/main-app/server/utils/errors.ts
```typescript
 1: export const handleFeatureLimitError = (error: any) => {
 2:   // Feature limit errors
 3:   if (error.statusCode === 403) {
 4:     throw createError({
 5:       statusCode: 403,
 6:       message: error.message || 'Feature limit reached',
 7:       data: {
 8:         code: 'FEATURE_LIMIT_REACHED',
 9:       },
10:     })
11:   }
12: 
13:   // Auth errors
14:   if (error.statusCode === 401) {
15:     throw createError({
16:       statusCode: 401,
17:       message: 'Authentication required',
18:       data: {
19:         code: 'AUTH_REQUIRED',
20:       },
21:     })
22:   }
23: 
24:   // Validation errors
25:   if (error.statusCode === 400) {
26:     throw createError({
27:       statusCode: 400,
28:       message: error.message || 'Invalid request',
29:       data: {
30:         code: 'VALIDATION_ERROR',
31:       },
32:     })
33:   }
34: 
35:   // Default error
36:   throw createError({
37:     statusCode: error.statusCode || 500,
38:     message: error.message || 'An unexpected error occurred',
39:     data: {
40:       code: 'INTERNAL_SERVER_ERROR',
41:     },
42:   })
43: }
```

## File: apps/main-app/server/utils/featureLimits.ts
```typescript
 1: import { FEATURES } from '#shared/constants'
 2: 
 3: enum PlanType {
 4:   FREE = 'free',
 5:   PRO = 'pro',
 6: }
 7: 
 8: export const validateFeatureLimit = async (
 9:   event: H3Event,
10:   feature: string,
11:   currentCount: number,
12: ) => {
13:   // For now, assume free plan
14:   const userPlan = PlanType.FREE
15: 
16:   const limit = FEATURES[feature].limit[userPlan]
17: 
18:   if (limit !== -1 && currentCount >= limit) {
19:     throw createError({
20:       statusCode: 403,
21:       message: `You have reached the ${FEATURES[feature].name.toLowerCase()} limit for your plan.`,
22:     })
23:   }
24: }
```

## File: apps/main-app/server/utils/formatter.ts
```typescript
 1: import { z } from 'zod'
 2: 
 3: // use .default("") to set defaults, I think this makes more sense than setting defaults in the database
 4: // can add a .catch(catchValue) value to set a value if the parsing fails
 5: 
 6: const uuid = z.string().uuid()
 7: const string = z.string()
 8: const stringNullish = z.string().nullish()
 9: const stringNull = z.string().nullable()
10: const stringOptional = z.string().optional()
11: 
12: export const datetimeOffset = (
13:   errorMsg: string = 'Invalid datetime string! Must be UTC.',
14:   offset?: boolean,
15: ) => ({
16:   optional: z
17:     .string()
18:     .datetime({ message: errorMsg, offset: offset ?? true })
19:     .optional(),
20:   nullish: z
21:     .string()
22:     .datetime({ message: errorMsg, offset: offset ?? true })
23:     .nullish(),
24: })
25: 
26: export const formatAvatarUrl = (user: any) => {
27:   return getImageURL({
28:     fileType: 'user-avatar',
29:     data: user,
30:   })
31: }
32: 
33: export type UserDTOKey = 'select:user:card' | 'select:user:profile' | 'select:user:settings'
34: 
35: export function roleIconMapping(role: AppRoleEnum): string {
36:   switch (role) {
37:     case 'admin':
38:       return 'material-symbols:shield-lock' // ADMIN
39:     case 'moderator':
40:       return 'material-symbols:manage-accounts' // MODERATOR
41:     case 'mentor':
42:       return 'mdi:account-school' // MENTOR
43:     case 'astroguide':
44:       return 'mdi:telescope' // ASTROGUIDE
45:     case 'user':
46:       return 'material-symbols:account-circle' // USER
47:     default:
48:       return 'material-symbols:account-circle' // DEFAULT
49:   }
50: }
51: 
52: export const formatDob = (date: string) => new Date(date).toISOString()
53: 
54: // todo:easy:1 add moderator to role table in supabase
55: 
56: // logic:med:med:4 - create a set of rules for formatting data to and from the database, add to DTOs
57: export const rules = {
58:   toDB: {
59:     uuid,
60:     string,
61:     stringNullish,
62:     stringNull,
63:     stringOptional,
64:     datetimeOffset,
65:   },
66:   toClient: {
67:     uuid: (userData: any) => uuid.parse(userData),
68:     string: (userData: any) => string.parse(userData),
69:     stringNullish: (userData: any) => stringNullish.parse(userData),
70:     stringNull: (userData: any) => stringNull.parse(userData),
71:     stringOptional: (userData: any) => stringOptional.parse(userData),
72:   },
73: }
```

## File: apps/main-app/server/utils/generateServerToken.ts
```typescript
 1: import jwt from 'jsonwebtoken'
 2: import { useRuntimeConfig } from '#imports'
 3: 
 4: export function generateServerToken() {
 5:   const config = useRuntimeConfig()
 6:   return jwt.sign({ sender: 'AstronEra' }, config.scraperKey, {
 7:     algorithm: 'HS256',
 8:     expiresIn: '1h',
 9:   })
10: }
```

## File: apps/main-app/server/utils/groqClient.ts
```typescript
 1: import { Groq } from 'groq-sdk/index.mjs'
 2: 
 3: const groq = new Groq({
 4:   apiKey: process.env.GROQ_API_KEY,
 5: })
 6: 
 7: interface AgentInput {
 8:   message: string
 9:   systemPrompt: string
10: }
11: 
12: interface Message {
13:   role: 'user' | 'assistant'
14:   content: string
15: }
16: 
17: export async function getGroqChatCompletion(messages: Message[]) {
18:   return await groq.chat.completions.create({
19:     messages: messages,
20:     model: 'llama3-70b-8192',
21:     // Controls randomness: lowering results in less random completions.
22:     // As the temperature approaches zero, the model will become
23:     // deterministic and repetitive.
24:     temperature: 0.3,
25: 
26:     // The maximum number of tokens to generate. Requests can use up to
27:     // 2048 tokens shared between prompt and completion.
28:     max_tokens: 1500,
29:     // Controls diversity via nucleus sampling: 0.5 means half of all
30:     // likelihood-weighted options are considered.
31:     top_p: 0.6,
32: 
33:     // A stop sequence is a predefined or user-specified text string that
34:     // signals an AI to stop generating content, ensuring its responses
35:     // remain focused and concise. Examples include punctuation marks and
36:     // markers like "[end]".
37:     // stop: 'None',
38: 
39:     // If set, partial message deltas will be sent.
40:     // streaming is not supported in JSON mode
41:     stream: false,
42:     // Enable JSON mode by setting the response format
43:     // response_format: { type: 'json_object' }
44:   })
45: }
```

## File: apps/main-app/server/utils/rateLimiter.ts
```typescript
 1: import { serverSupabaseUser } from '#supabase/server'
 2: 
 3: type PlanKey = 'free' | 'basic' | 'intermediate' | 'premium'
 4: type FeatureKey = 'ask'
 5: 
 6: const rateLimitConfig = {
 7:   free: {
 8:     ask: {
 9:       interval: 1800000,
10:       maxRequests: 3,
11:     },
12:   },
13:   basic: {
14:     ask: {
15:       interval: 1800000,
16:       maxRequests: 10,
17:     },
18:   },
19:   intermediate: {
20:     ask: {
21:       interval: 1800000,
22:       maxRequests: 20,
23:     },
24:   },
25:   premium: {
26:     ask: {
27:       interval: 1800000,
28:       maxRequests: 30,
29:     },
30:   },
31: }
32: 
33: // consider using   const ip = getRequestIP(event); // "192.0.2.0"
34: // consider using   const userAgent = getRequestHeader(event, 'user-agent');
35: // consider using   const referer = getRequestHeader(event, 'referer');
36: // getRequestFingerprint(event, opts) instead of correlation-id
37: 
38: // this can probably be improved once we have role based access implmented
39: // all info can be appended to the event.context object
40: 
41: interface RateLimitInfo {
42:   requestCount: number
43:   expiresAt: number
44: }
45: 
46: const getFeatureFromPath = (path: string): FeatureKey => {
47:   const feature = path.split('/').pop()?.split('?')[0] as FeatureKey
48:   console.log('getFeatureFromPath', feature)
49:   return feature
50: }
51: 
52: export async function rateLimiter() {
53:   const event = useEvent()
54:   const feature = getFeatureFromPath(event.path)
55:   const user = await serverSupabaseUser(event)
56: 
57:   if (!user) {
58:     throw createError({ message: 'User not found, You must be logged in to use this endpoint' })
59:   }
60:   const userPlan = (user?.app_metadata.plan as PlanKey) ?? 'free'
61:   const storage = useStorage('session')
62:   const storageKey = `rateLimit:endpoint:${userPlan}:${user?.id}`
63:   const settings = rateLimitConfig[userPlan][feature]
64: 
65:   let rateLimit = await storage.getItem<RateLimitInfo>(storageKey)
66:   if (!rateLimit || rateLimit.expiresAt < Date.now()) {
67:     console.info('Rate limit not found, or it has expired')
68:     rateLimit = {
69:       requestCount: 1,
70:       expiresAt: Date.now() + settings.interval,
71:     }
72:   }
73: 
74:   if (rateLimit.requestCount > settings.maxRequests) {
75:     throw createError({
76:       statusCode: 429,
77:       statusMessage: `Exceeded ${feature.charAt(0).toUpperCase()}${feature.slice(1)} Limits`,
78:       message: `You have exceeded your limit of ${settings.maxRequests}
79:        requests in the last ${settings.interval / 60000} minutes`,
80:     })
81:   }
82: 
83:   rateLimit.requestCount++
84: 
85:   await storage.setItem(storageKey, rateLimit)
86: }
```

## File: apps/main-app/server/utils/validator.ts
```typescript
 1: import type { H3Event } from 'h3'
 2: import type { AnyZodObject } from 'zod'
 3: 
 4: export async function validateBody(event: H3Event, parser: AnyZodObject) {
 5:   const validatedBody = await readValidatedBody(event, parser.safeParse)
 6: 
 7:   if (!validatedBody.success) {
 8:     throw createError({
 9:       statusCode: 422,
10:       statusMessage: 'Unprocessable Entity: Feedback Format',
11:       message: JSON.stringify(validatedBody.error.errors),
12:     })
13:   }
14: 
15:   return validatedBody.data
16: }
```

## File: apps/main-app/shared/constants.ts
```typescript
 1: export const FEATURES = {
 2:   BOOKMARK_FOLDERS: {
 3:     name: 'Bookmark Folders',
 4:     limit: {
 5:       free: 2,
 6:       pro: -1, // unlimited
 7:     },
 8:     description: 'Organize your bookmarks into folders',
 9:   },
10:   BOOKMARKS: {
11:     name: 'Bookmarks',
12:     limit: {
13:       free: 100,
14:       pro: -1,
15:     },
16:     description: 'Save articles for later',
17:   },
18:   CUSTOM_FOLDER_COLORS: {
19:     name: 'Custom Folder Colors',
20:     limit: {
21:       free: 0,
22:       pro: -1,
23:     },
24:     description: 'Personalize your folders with custom colors',
25:     comingSoon: true,
26:   },
27: } as const
```

## File: apps/main-app/shared/index.ts
```typescript
1: export * from './constants'
```

## File: apps/main-app/tasks/setup-posthog.md
```markdown
  1: # PostHog Setup Guide for A/B Testing and Analytics
  2: 
  3: ## 1. Initial Setup
  4: 
  5: 1. Sign up for a PostHog account if you haven't already.
  6: 2. Create a new project for your application.
  7: 3. Get your project API key from the project settings.
  8: 
  9: ## 2. Install PostHog in Your Nuxt Application
 10: 
 11: 1. Install the PostHog client library:
 12:    ```
 13:    npm install posthog-js
 14:    ```
 15: 2. Set up the PostHog plugin in your Nuxt app as we discussed earlier.
 16: 
 17: ## 3. Configure Event Capture
 18: 
 19: 1. In the PostHog dashboard, go to "Data Management" > "Events".
 20: 2. Create event definitions for each of your main event types (e.g., "User Acquisition",
 21:    "Onboarding", "User Engagement", etc.).
 22: 3. For each event, define properties that you expect to capture.
 23: 
 24: ## 4. Set Up Properties
 25: 
 26: 1. Go to "Data Management" > "Properties".
 27: 2. Define and describe the properties you'll be using across different events.
 28: 
 29: ## 5. Create Dashboards
 30: 
 31: 1. Go to "Dashboards" and create a new dashboard for each main category:
 32:    - User Acquisition Dashboard
 33:    - Onboarding Dashboard
 34:    - User Engagement Dashboard
 35:    - Content Performance Dashboard
 36:    - Job Market Activity Dashboard
 37:    - Technical Performance Dashboard
 38: 2. In each dashboard, add relevant charts and metrics based on the events and properties you've
 39:    defined.
 40: 
 41: ## 6. Set Up Funnels
 42: 
 43: 1. Go to "Product Analytics" > "Funnels".
 44: 2. Create funnels for important user journeys, such as:
 45:    - Sign-up process
 46:    - Onboarding steps
 47:    - Job application process
 48: 
 49: ## 7. Configure Cohorts
 50: 
 51: 1. Go to "Persons & Cohorts" > "Cohorts".
 52: 2. Create cohorts based on user behaviors or properties, such as:
 53:    - Active users (daily, weekly, monthly)
 54:    - Users who have completed onboarding
 55:    - Job seekers vs. employers
 56: 
 57: ## 8. Set Up A/B Testing (Experiments)
 58: 
 59: 1. Go to "Experiments" in the PostHog dashboard.
 60: 2. Click "New Experiment" to create a new A/B test.
 61: 3. Define your experiment:
 62:    - Name: Choose a descriptive name (e.g., "Homepage CTA Button Color")
 63:    - Description: Explain the purpose and hypothesis of the experiment
 64:    - Feature Flag: Create a new feature flag or select an existing one
 65:    - Variants: Define your control and variant(s) (e.g., "blue" and "green")
 66:    - Goal Metrics: Select the events that will determine the success of your experiment
 67: 4. Set the percentage of users who will be part of the experiment.
 68: 5. Launch the experiment when ready.
 69: 
 70: ## 9. Configure Feature Flags
 71: 
 72: 1. Go to "Feature Flags" in the PostHog dashboard.
 73: 2. Create feature flags for each feature or component you want to A/B test.
 74: 3. Set up the distribution of these flags (e.g., 50% see version A, 50% see version B).
 75: 
 76: ## 10. Set Up Alerts
 77: 
 78: 1. Go to "Alerts" in the PostHog dashboard.
 79: 2. Set up alerts for important metrics or events, such as:
 80:    - Sudden drop in user engagement
 81:    - Spike in error rates
 82:    - Reaching a certain number of job applications
 83: 
 84: ## 11. Configure Data Management
 85: 
 86: 1. Go to "Data Management" > "Aggregation".
 87: 2. Set up aggregation queries for complex metrics that require data processing.
 88: 
 89: ## 12. Set Up User Identification
 90: 
 91: 1. Ensure your `identifyUser` function in the analytics composable is correctly calling PostHog's
 92:    identify method.
 93: 2. In PostHog, go to "Data Management" > "Persons" to verify that user data is being correctly
 94:    associated.
 95: 
 96: ## 13. Test Your Setup
 97: 
 98: 1. Use your application with the analytics and A/B testing composables implemented.
 99: 2. Check the PostHog dashboard to ensure events are being captured correctly.
100: 3. Verify that your A/B tests are running as expected.
101: 4. Make sure your dashboards are populating with real data.
102: 
103: ## 14. Implement Consent Management (if necessary)
104: 
105: 1. If you're operating in regions with strict privacy laws (e.g., GDPR), set up a consent management
106:    system.
107: 2. Use the `opt_in_capturing()` and `opt_out_capturing()` methods provided by PostHog in your
108:    consent management flow.
109: 
110: Remember to regularly review and refine your analytics setup as your application evolves and your
111: data needs change.
```

## File: apps/main-app/types/bookmarks.ts
```typescript
 1: // types/bookmark.ts
 2: export interface BookmarkContent {
 3:   id: string
 4:   type: string
 5:   title: string
 6:   description?: string
 7:   thumbnail?: string
 8:   url?: string
 9:   created_at?: string
10:   authorName?: string
11: }
12: 
13: export interface BookmarkParams {
14:   content_type?: string
15:   folder_id?: string
16:   include_subfolders?: boolean
17: }
18: 
19: export interface Bookmark {
20:   id: string
21:   user_id: string
22:   folder_id: string | null
23:   content_type: string
24:   content_id: string
25:   metadata: {
26:     title: string
27:     description?: string
28:     thumbnail?: string
29:     url?: string
30:     created_at?: string
31:     authorName?: string
32:   }
33:   created_at: string
34:   folder?: {
35:     id: string
36:     name: string
37:     color: string
38:     is_favorite: boolean
39:     path?: string
40:   }
41: }
42: 
43: export interface Folder {
44:   id: string
45:   name: string
46:   color: string
47:   parent_id: string | null
48:   is_default: boolean
49:   is_favorite: boolean
50:   position: number
51:   path: string
52:   children?: Folder[]
53: }
```

## File: apps/main-app/types/folder.ts
```typescript
 1: export interface Folder {
 2:   id: string
 3:   name: string
 4:   color: string
 5:   parent_id: string | null
 6:   is_default: boolean
 7:   is_favorite: boolean
 8:   position: number
 9:   path: string
10:   children?: Folder[]
11: }
```

## File: apps/main-app/types/toasts.ts
```typescript
 1: import { z } from 'zod'
 2: 
 3: export const ToastActionSchema = z.object({
 4:   variant: z.string(),
 5:   color: z.string(),
 6:   label: z.string(),
 7: })
 8: 
 9: export const ToastSchema = z.object({
10:   id: z.union([z.string(), z.number()]),
11:   title: z.string(),
12:   description: z.string().optional(),
13:   icon: z.string().optional(),
14:   color: z.string().optional(),
15:   timeout: z.number().optional(),
16:   ui: z.unknown().optional(),
17:   avatar: z.unknown().optional(),
18:   closeButton: z.unknown().optional(),
19:   actions: z.array(ToastActionSchema).optional(),
20:   callback: z.function().optional(),
21: })
22: 
23: export const ToastStateSchema = z.object({
24:   toasts: z.array(ToastSchema),
25: })
26: 
27: export type ToastType = z.infer<typeof ToastSchema>
28: export type ToastActionType = z.infer<typeof ToastActionSchema>
29: export type ToastStateType = z.infer<typeof ToastStateSchema>
```

## File: apps/main-app/app.config.ts
```typescript
1: // This supports HMR
2: export default defineAppConfig({
3:   title: 'AstronEra - AstroTribe',
4: })
```

## File: apps/main-app/app.vue
```vue
 1: <script setup lang="ts">
 2: const catTagStore = useCategoryTagStore()
 3: const currentUser = useCurrentUser()
 4: 
 5: onMounted(async () => {
 6:   document.documentElement.classList.add('dark')
 7:   await catTagStore.getCategories()
 8:   await catTagStore.getTags()
 9: })
10: 
11: useHead({
12:   htmlAttrs: {
13:     lang: 'en',
14:   },
15:   meta: [
16:     {
17:       name: 'viewport',
18:       content: 'width=device-width, initial-scale=1',
19:     },
20:   ],
21:   link: [
22:     {
23:       rel: 'icon',
24:       type: 'image/png',
25:       href: '/favicon.png',
26:     },
27:   ],
28: })
29: </script>
30: 
31: <template>
32:   <div class="h-full w-full">
33:     <NuxtLoadingIndicator />
34:     <Head>
35:       <link rel="manifest" href="/manifest.webmanifest" />
36:     </Head>
37:     <NuxtPwaAssets />
38:     <NuxtLayout>
39:       <NuxtPage />
40:     </NuxtLayout>
41:     <PrimeToast position="bottom-right" />
42:     <!-- <Notification /> -->
43:   </div>
44: </template>
45: 
46: <style>
47: html {
48:   margin: 0;
49:   padding: 0;
50: }
51: 
52: #__nuxt {
53:   width: 100%;
54:   height: 100%;
55:   padding: 0;
56:   margin: 0;
57: }
58: 
59: .layout-enter-active,
60: .layout-leave-active {
61:   transition: all 0.4s;
62: }
63: 
64: .layout-enter-from,
65: .layout-leave-to {
66:   opacity: 0;
67:   filter: blur(1rem);
68: }
69: </style>
```

## File: apps/main-app/error.vue
```vue
 1: <template>
 2:   <div class="flex h-auto items-center justify-center foreground min-h-screen">
 3:     <div class="max-w-md rounded-lg p-8 shadow-lg background">
 4:       <h1 class="mb-4 text-3xl font-bold text-red-600"> An error occurred </h1>
 5:       <p class="text-lg mb-4">
 6:         {{ error.message }}
 7:       </p>
 8:       <p class="mb-2 text-sm text-gray-600"> Error ID: {{ error.errorId }} </p>
 9:       <p
10:         v-if="error.stack"
11:         class="mb-4 overflow-auto text-xs text-gray-500"
12:       >
13:         <strong>Stack trace:</strong><br />
14:         {{ error.stack }}
15:       </p>
16:       <div class="flex justify-between">
17:         <button
18:           v-if="error.retryAction"
19:           class="rounded bg-blue-500 px-4 py-2 text-white hover:bg-blue-600"
20:           @click="retryAction"
21:         >
22:           Retry
23:         </button>
24:         <button
25:           class="rounded bg-gray-300 px-4 py-2 text-gray-800 hover:bg-gray-400"
26:           @click="goHome"
27:         >
28:           Go to Home
29:         </button>
30:       </div>
31:     </div>
32:   </div>
33: </template>
34: 
35: <script setup lang="ts">
36: const props = defineProps({
37:   error: Object,
38: })
39: 
40: const retryAction = () => {
41:   if (props.error.retryAction) {
42:     props.error.retryAction()
43:   }
44: }
45: 
46: const goHome = () => {
47:   clearError({ redirect: '/' })
48: }
49: </script>
```

## File: apps/main-app/nuxt.config.ts
```typescript
  1: import { fileURLToPath } from 'url'
  2: import { dirname, join, resolve } from 'path'
  3: import { defineNuxtConfig } from 'nuxt/config'
  4: import runtimeConfig from '../../shared-runtime.config'
  5: 
  6: const currentDir = dirname(fileURLToPath(import.meta.url))
  7: 
  8: export default defineNuxtConfig({
  9:   workspaceDir: '../../',
 10:   srcDir: '.',
 11:   extends: ['../../layers/base', '../../layers/auth', '../../layers/crud', '../../layers/advert'],
 12: 
 13:   vite: {
 14:     optimizeDeps: {
 15:       exclude: ['fsevents'],
 16:     },
 17:   },
 18: 
 19:   build: {
 20:     transpile: ['@formbricks/js'],
 21:   },
 22: 
 23:   plugins: [{ src: '~/plugins/formbricks.client.ts' }],
 24: 
 25:   debug: true,
 26: 
 27:   modules: [
 28:     'nuxt-tiptap-editor',
 29:     '@nuxt/devtools',
 30:     '@vueuse/nuxt',
 31:     '@nuxt/image',
 32:     '@pinia/nuxt',
 33:     '@nuxt/icon',
 34:     '@nuxt/eslint',
 35:     '@nuxtjs/tailwindcss',
 36:     '@nuxtjs/mdc',
 37:     '@primevue/nuxt-module',
 38:     '@vite-pwa/nuxt',
 39:   ],
 40: 
 41:   experimental: {
 42:     asyncContext: true,
 43:   },
 44: 
 45:   tailwindcss: {
 46:     configPath: `${currentDir}/tailwind.config.ts`,
 47:     cssPath: [`${currentDir}/assets/css/tailwind.css`, { injectPosition: 0 }],
 48:     exposeConfig: true,
 49:     viewer: true,
 50:   },
 51: 
 52:   primevue: {
 53:     importPT: { from: resolve(currentDir, '../../theme/index.js') },
 54:     autoImport: true,
 55:     components: {
 56:       prefix: 'Prime',
 57:       include: '*',
 58:       exclude: ['Editor'],
 59:     },
 60: 
 61:     composables: {
 62:       include: '*',
 63:     },
 64: 
 65:     options: {
 66:       ripple: true,
 67:       unstyled: true,
 68:       theme: {
 69:         options: {
 70:           cssLayer: true,
 71:         },
 72:       },
 73:     },
 74:   },
 75: 
 76:   image: {
 77:     format: ['webp', 'jpg'],
 78:   },
 79: 
 80:   tiptap: {
 81:     prefix: 'Tiptap',
 82:   },
 83: 
 84:   pwa: {
 85:     registerType: 'autoUpdate',
 86:     manifest: false, // We'll use our own manifest file
 87:     workbox: {
 88:       navigateFallback: '/offline',
 89:       globPatterns: ['**/*.{js,css,html,ico,png,svg}'],
 90:       cleanupOutdatedCaches: true,
 91:       runtimeCaching: [
 92:         {
 93:           urlPattern: /^\/api\//,
 94:           handler: 'NetworkFirst',
 95:         },
 96:       ],
 97:     },
 98:     client: {
 99:       installPrompt: true,
100:     },
101:   },
102: 
103:   alias: {
104:     '#shared': fileURLToPath(new URL('./shared', import.meta.url)),
105:   },
106: 
107:   // Add proper MIME type handling
108:   nitro: {
109:     routeRules: {
110:       '/manifest.webmanifest': {
111:         headers: {
112:           'Content-Type': 'application/manifest+json',
113:           'Cache-Control': 'public, max-age=0',
114:         },
115:       },
116:       '/api/bookmarks/**': {
117:         appMiddleware: ['feature-limit'],
118:       },
119:       '/api/folders/**': {
120:         appMiddleware: ['feature-limit'],
121:       },
122:     },
123:     alias: {
124:       '#shared': fileURLToPath(new URL('./shared', import.meta.url)),
125:     },
126:   },
127: 
128:   ...runtimeConfig,
129: })
```

## File: apps/main-app/prompt-app-download.ts
```typescript
 1: function isMobileDevice() {
 2:   return /Mobi|Android|iPhone/i.test(navigator.userAgent)
 3: }
 4: 
 5: let deferredPrompt
 6: 
 7: window.addEventListener('beforeinstallprompt', (e) => {
 8:   // Prevent the mini-infobar from appearing on mobile
 9:   e.preventDefault()
10:   // Stash the event so it can be triggered later
11:   deferredPrompt = e
12: 
13:   // Check if the device is mobile
14:   if (isMobileDevice()) {
15:     // Show your custom install button or prompt
16:     showInstallButton()
17:   }
18: })
19: 
20: function showInstallButton() {
21:   // Display your custom install UI for mobile users
22:   const installButton = document.getElementById('install-button')
23:   installButton.style.display = 'block'
24: 
25:   installButton.addEventListener('click', async () => {
26:     // Hide the install button
27:     installButton.style.display = 'none'
28: 
29:     // Show the install prompt
30:     deferredPrompt.prompt()
31: 
32:     // Wait for the user to respond to the prompt
33:     const { outcome } = await deferredPrompt.userChoice
34:     if (outcome === 'accepted') {
35:       console.log('User accepted the install prompt')
36:     } else {
37:       console.log('User dismissed the install prompt')
38:     }
39:     deferredPrompt = null
40:   })
41: }
```

## File: apps/main-app/README.md
```markdown
  1: <h1 align="center" style="margin-top: 0px;">AstroTribe</h1>
  2: <!-- <p align="center" style="margin-bottom: 0px !important;">
  3:   <img width="200" src="https://github.com/Drew-Macgibbon/design-portfolio/blob/main/public/readme/doom-logo.png" align="center">
  4: </p> -->
  5: <p align="center" >The AstroTribe App is a social network for astronomers and wannabe astronomers around the globe.</p>
  6: 
  7: <p align="center">
  8:   <a href="https://astronera.org/">Production</a> --- |  .  | --- <a href="https://astrotribe.vercel.app/">Development</a>
  9: </p>
 10: 
 11: We're currently working towards an open beta release. If you'd like to be notified when we launch,
 12: register your interest [here](https://astrotribe.vercel.app/register)
 13: 
 14: ### Contributing:
 15: 
 16: Clone the `develop` Branch Create your Feature Branch `git checkout -b feature/amazing-feature` Open
 17: a Pull Request against `develop` when the feature is ready for review
 18: 
 19: ### Development Setup:
 20: 
 21: supabase: http://localhost:54323/project/default
 22: 
 23: #### Find Work:
 24: 
 25: ##### Domain / Category
 26: 
 27: 1. **`infra:` Infrastructure & Foundations**
 28: 
 29:    - **Scope**: This domain encompasses all backend infrastructure elements critical to application
 30:      functionality. It includes the management of server environments, authentication systems,
 31:      application programming interfaces (APIs), data storage solutions, logging systems, and any
 32:      other foundational services or protocols that support application operations.
 33:    - **Example Tasks**: Set up secure authentication methods, optimize API performance, implement
 34:      comprehensive logging systems, and configure cloud storage solutions.
 35: 
 36: 2. **`logic:` Business Logic & Processing**
 37: 
 38:    - **Scope**: Focuses on the core functionality that users interact with directly. This domain
 39:      includes the creation and maintenance of the operational logic that drives the application's
 40:      primary features—from user inputs leading to actions (like button clicks) to data processing
 41:      and output formatting.
 42:    - **Example Tasks**: Develop a new feature that formats user data for reports, refactor
 43:      validation logic to enhance security, create storage procedures for user inputs.
 44: 
 45: 3. **`design:` User Interface & Experience Design**
 46: 
 47:    - **Scope**: Dedicated to the aesthetic and functional design of user interfaces and the
 48:      underlying software architecture. This domain covers everything from UI/UX design for improved
 49:      user interaction to strategic database and software architecture planning for efficient data
 50:      management and flow.
 51:    - **Example Tasks**: Redesign the user interface for enhanced usability, create a responsive
 52:      design for mobile platforms, plan and model a new database schema for scalability.
 53: 
 54: 4. **`test:` Quality Assurance & Testing**
 55: 
 56:    - **Scope**: Ensures that all features operate as intended before they reach end-users. This
 57:      domain involves developing and maintaining a robust testing framework, including unit tests,
 58:      integration tests, system tests, and ensuring new functionalities are covered as they are
 59:      developed.
 60:    - **Example Tasks**: Write integration tests for a new API endpoint, update existing tests to
 61:      cover recent changes in business logic, automate regression testing scenarios.
 62: 
 63: 5. **`bug:` Issue Resolution & Debugging**
 64:    - **Scope**: A cross-domain responsibility focused on identifying, tracking, and resolving bugs
 65:      throughout the application. This domain ensures that issues are promptly addressed to maintain
 66:      the integrity and performance of the application across all other domains.
 67:    - **Example Tasks**: Fix a critical bug affecting user login, resolve a recurring error in data
 68:      formatting, debug a performance issue in database queries.
 69: 
 70: ##### Search for Jobs
 71: 
 72: Key = category | priority | difficulty | time estimate
 73: 
 74: <!-- // teams work in small groups on single feature end to end -->
 75: 
 76: **Remove '~' from your search, it's for doc search exclusion**
 77: 
 78: ```ts
 79: // Frontend Work
 80: //
 81: // ~infra:low:easy:1 - Routine Check: Perform daily server status check.
 82: // ~logic:med:med:2 - Update Rollout: Deploy new software updates to the server cluster.
 83: // ~design:high:challenge:4 - Infrastructure Overhaul: Redesign the network architecture for increased efficiency.
 84: // ~test:urgent:hard:8 - Disaster Recovery: Implement immediate fixes following a critical system failure.
 85: // ~bug:critical:extreme:12 - Full System Rebuild: Reconstruct server environment and restore all critical services post-major outage.
 86: ```
 87: 
 88: **Backend uses a ! prefix**
 89: 
 90: ```ts
 91: // Backend Work (! prefix)
 92: //
 93: // ~!infra:low:easy:1
 94: ```
 95: 
 96: **Database uses # for comments**
 97: 
 98: ```bash
 99: # Database Work (# for comments)
100: #
101: # ~infra:low:easy:1
102: ```
103: 
104: #### Stack
105: 
106: - Nuxt
107: - Vercel
108: - Supabase
109: 
110: #### Links
111: 
112: - Dev Site: https://astrotribe-git-develop-incubrain.vercel.app
113: 
114: #### Supabase:
115: 
116: install supabase locally if you don't have it already.
117: 
118: ```bash
119: brew install supabase/tap/supabase
120: ```
121: 
122: ```bash
123: // make sure docker is open
124: // download the images
125: supabase start
126: //
127: supabase login
128: // link the local project to production
129: supabase link --project-ref <project-id>
130: // pull down the database
131: supabase db pull
132: ```
133: 
134: #### Migrations:
135: 
136: ```bash
137: // create a migration based on changes made in local studio
138: supabase db diff -f new_employee
139: // reset db to verify changes
140: supabase db reset
141: ```
142: 
143: <!-- 11:28 battery full -->
```

## File: apps/main-app/tailwind.config.ts
```typescript
 1: import { fileURLToPath } from 'url'
 2: import { dirname, resolve } from 'path'
 3: import type { Config } from 'tailwindcss'
 4: import baseConfig from '../../tailwind.config.base'
 5: 
 6: const currentDir = dirname(fileURLToPath(import.meta.url))
 7: 
 8: const config: Partial<Config> = {
 9:   presets: [baseConfig],
10:   theme: {
11:     extend: {
12:       // Add app-specific extensions here
13:     },
14:   },
15:   content: [resolve(currentDir, '**/*.{js,vue,ts}'), '../../theme/**/*.{js,css,ts}'],
16: }
17: 
18: export default config
```

## File: layers/advert/.playground/app.config.ts
```typescript
1: export default defineAppConfig({
2:   myLayer: {
3:     name: 'My amazing Nuxt layer (overwritten)'
4:   }
5: })
```

## File: layers/advert/.playground/nuxt.config.ts
```typescript
1: export default defineNuxtConfig({
2:   extends: ['..'],
3:   modules: ['@nuxt/eslint']
4: })
```

## File: layers/advert/components/Advertisement.vue
```vue
  1: <script setup lang="ts">
  2: import { useStorage } from '@vueuse/core'
  3: import advertisements from '../assets/advertisements.json'
  4: 
  5: const showAds = ref(false)
  6: const userShowAds = useStorage('userShowAds', true)
  7: 
  8: interface Advertisement {
  9:   id: number
 10:   title: string
 11:   description: string
 12:   imageUrl: string
 13:   link: string
 14:   active: boolean
 15: }
 16: 
 17: interface AdMetric {
 18:   adId: number
 19:   impressions: number
 20:   clicks: number
 21:   uniqueViews: number // Changed to number
 22:   deviceType: string
 23:   viewTimes: number[]
 24: }
 25: 
 26: const activeAds = ref<Advertisement[]>([])
 27: const adMetrics = useStorage<Record<number, AdMetric>>('adMetrics', {})
 28: const viewedAds = useStorage<Set<number>>('viewedAds', new Set())
 29: const sendInterval = 10000 // 10 seconds
 30: 
 31: const loadActiveAds = () => {
 32:   activeAds.value = advertisements.filter((ad) => ad.active).slice(0, 3)
 33: }
 34: 
 35: const getDeviceType = () => {
 36:   const userAgent = navigator.userAgent
 37:   if (/mobile/i.test(userAgent)) return 'Mobile'
 38:   if (/tablet/i.test(userAgent)) return 'Tablet'
 39:   return 'Desktop'
 40: }
 41: 
 42: const trackImpression = (adId: number) => {
 43:   if (!adMetrics.value[adId]) {
 44:     adMetrics.value[adId] = {
 45:       adId,
 46:       impressions: 0,
 47:       clicks: 0,
 48:       uniqueViews: 0,
 49:       deviceType: getDeviceType(),
 50:       viewTimes: [],
 51:     }
 52:   }
 53:   adMetrics.value[adId].impressions++
 54:   adMetrics.value[adId].viewTimes.push(Date.now())
 55: 
 56:   // Increment uniqueViews only if it's the first time this ad is viewed
 57:   if (!viewedAds.value.has(adId)) {
 58:     adMetrics.value[adId].uniqueViews++
 59:     viewedAds.value.add(adId)
 60:   }
 61: }
 62: 
 63: const trackInteraction = (adId: number) => {
 64:   if (adMetrics.value[adId]) {
 65:     adMetrics.value[adId].clicks++
 66:   }
 67: }
 68: 
 69: const sendMetrics = async () => {
 70:   const metricsToSend = JSON.parse(JSON.stringify(adMetrics.value))
 71: 
 72:   try {
 73:     // Send metrics to admin server (not implemented)
 74:     await $fetch('/api/advertisement/metrics', {
 75:       method: 'POST',
 76:       body: { metrics: metricsToSend },
 77:     })
 78: 
 79:     console.log('Metrics sent successfully')
 80:     // Clear the local metrics after successful send
 81:     adMetrics.value = {}
 82:   } catch (error) {
 83:     console.error('Failed to send metrics:', error)
 84:   }
 85: }
 86: 
 87: const intervalId = ref(null as NodeJS.Timeout | null)
 88: onMounted(() => {
 89:   intervalId.value = setInterval(sendMetrics, sendInterval)
 90:   loadActiveAds()
 91:   activeAds.value.forEach((ad) => trackImpression(ad.id))
 92: })
 93: 
 94: watch(
 95:   activeAds,
 96:   (newAds) => {
 97:     newAds.forEach((ad) => trackImpression(ad.id))
 98:   },
 99:   { deep: true },
100: )
101: 
102: onUnmounted(() => {
103:   clearInterval(intervalId.value!)
104:   sendMetrics() // Send any remaining metrics before unmounting
105: })
106: </script>
107: 
108: <template>
109:   <aside class="mx-auto min-h-72 w-72 space-y-4 p-4">
110:     <div class="mb-4 flex items-center justify-between">
111:       <label
112:         for="show-ads-toggle"
113:         class="pr-2 text-sm"
114:       >
115:         Toggle Ads
116:       </label>
117:       <PrimeToggleSwitch
118:         v-model="showAds"
119:         input-id="show-ads-toggle"
120:       />
121:     </div>
122:     <div
123:       v-for="ad in activeAds"
124:       :key="ad.id"
125:       class="border-color overflow-hidden rounded-lg"
126:       :class="!showAds ? '' : 'border'"
127:     >
128:       <a
129:         :href="showAds ? ad.link : undefined"
130:         target="_blank"
131:         rel="noopener noreferrer"
132:         class="block h-full w-full"
133:         :class="{ invisible: !showAds }"
134:         @click="trackInteraction(ad.id)"
135:       >
136:         <div class="max-h-72 w-full">
137:           <NuxtImg
138:             v-if="showAds"
139:             :src="ad.imageUrl"
140:             :alt="ad.title"
141:             class="w-full object-cover"
142:           />
143:         </div>
144:         <div class="p-4">
145:           <h3
146:             v-if="showAds"
147:             class="text-lg font-semibold"
148:           >
149:             {{ ad.title }}
150:           </h3>
151:           <p
152:             v-if="showAds"
153:             class="text-sm"
154:           >
155:             {{ ad.description }}
156:           </p>
157:         </div>
158:       </a>
159:     </div>
160:   </aside>
161: </template>
```

## File: layers/advert/plugins/error-handler.ts
```typescript
 1: import { useErrorHandler } from '@ib/logger'
 2: 
 3: export default defineNuxtPlugin((nuxtApp) => {
 4:   const { handleError } = useErrorHandler()
 5: 
 6:   // Set up global error handlers
 7:   if (import.meta.client) {
 8:     window.addEventListener('error', (event) => {
 9:       handleError(event.error, 'Uncaught Exception')
10:     })
11: 
12:     window.addEventListener('unhandledrejection', (event) => {
13:       handleError(event.reason, 'Unhandled Promise Rejection')
14:     })
15:   }
16: })
```

## File: layers/advert/plugins/sentry.server.ts
```typescript
1: export default defineNuxtPlugin(() => {
2:   const environment = useRuntimeConfig().public.nodeEnv
3: })
```

## File: layers/advert/server/api/advertisement/metrics.get.ts
```typescript
 1: import { promises as fs } from 'fs'
 2: import { resolve } from 'path'
 3: import { defineEventHandler } from 'h3'
 4: 
 5: interface AdMetric {
 6:   adId: number
 7:   impressions: number
 8:   clicks: number
 9:   uniqueViews: number
10:   deviceType: string
11:   viewTimes: number[]
12: }
13: 
14: const adMetricsFilePath = resolve(process.cwd(), 'data', 'advertising', 'metrics.json')
15: 
16: export default defineEventHandler(async (event) => {
17:   try {
18:     const data = await fs.readFile(adMetricsFilePath, 'utf-8')
19:     const metrics: AdMetric[] = JSON.parse(data)
20: 
21:     // Calculate additional metrics
22:     const processedMetrics = Object.values(metrics).map((metric: AdMetric) => {
23:       const ctr = metric.impressions > 0 ? (metric.clicks / metric.impressions) * 100 : 0
24:       const frequency = metric.impressions / metric.uniqueViews
25:       const timeOfDay = metric.viewTimes.map((time) => new Date(time).getHours())
26: 
27:       return {
28:         ...metric,
29:         ctr: ctr.toFixed(2) + '%',
30:         frequency: frequency.toFixed(2),
31:         timeOfDay: timeOfDay.reduce(
32:           (acc, hour) => {
33:             acc[hour] = (acc[hour] || 0) + 1
34:             return acc
35:           },
36:           {} as Record<number, number>,
37:         ),
38:       }
39:     })
40: 
41:     return processedMetrics
42:   } catch (error) {
43:     console.error('Error reading ad metrics:', error)
44:     throw createError({
45:       statusCode: 500,
46:       statusMessage: 'Failed to read ad metrics',
47:     })
48:   }
49: })
```

## File: layers/advert/server/api/advertisement/metrics.post.ts
```typescript
 1: import { promises as fs } from 'fs'
 2: import { resolve } from 'path'
 3: import { defineEventHandler, readBody } from 'h3'
 4: 
 5: const adMetricsFilePath = resolve(process.cwd(), 'data', 'advertising', 'metrics.json')
 6: 
 7: interface AdMetric {
 8:   adId: number
 9:   impressions: number
10:   clicks: number
11:   uniqueViews: number
12:   deviceType: string
13:   viewTimes: number[]
14: }
15: 
16: let batchedMetrics: Record<number, AdMetric> = {}
17: let lastWriteTime = Date.now()
18: const WRITE_INTERVAL = 60000 // 1 minute
19: 
20: const writeMetricsToFile = async () => {
21:   try {
22:     let existingMetrics: Record<number, AdMetric> = {}
23:     try {
24:       const data = await fs.readFile(adMetricsFilePath, 'utf-8')
25:       existingMetrics = JSON.parse(data)
26:     } catch (error) {
27:       console.warn('No existing ad metrics found:', error)
28:       // File doesn't exist yet, start with empty object
29:     }
30: 
31:     // Merge batched metrics with existing metrics
32:     for (const [adId, metric] of Object.entries(batchedMetrics)) {
33:       if (!existingMetrics[adId]) {
34:         existingMetrics[adId] = metric
35:       } else {
36:         existingMetrics[adId].impressions += metric.impressions
37:         existingMetrics[adId].clicks += metric.clicks
38:         existingMetrics[adId].uniqueViews += metric.uniqueViews
39:         existingMetrics[adId].viewTimes.push(...metric.viewTimes)
40:       }
41:     }
42: 
43:     await fs.writeFile(adMetricsFilePath, JSON.stringify(existingMetrics, null, 2), 'utf-8')
44:     batchedMetrics = {} // Clear batched metrics after writing
45:     lastWriteTime = Date.now()
46:   } catch (error) {
47:     console.error('Error writing ad metrics:', error)
48:   }
49: }
50: 
51: export default defineEventHandler(async (event) => {
52:   const body = await readBody(event)
53:   const { metrics } = body as { metrics: Record<number, AdMetric> }
54: 
55:   if (!metrics) {
56:     return { success: false, message: 'No ad metrics received' }
57:   }
58: 
59:   console.log('Received ad metrics:', metrics)
60:   // Merge incoming metrics with batched metrics
61:   for (const [adId, metric] of Object.entries(metrics)) {
62:     if (!batchedMetrics[adId]) {
63:       batchedMetrics[adId] = metric
64:     } else {
65:       batchedMetrics[adId].impressions += metric.impressions
66:       batchedMetrics[adId].clicks += metric.clicks
67:       batchedMetrics[adId].uniqueViews += metric.uniqueViews
68:       batchedMetrics[adId].viewTimes.push(...metric.viewTimes)
69:     }
70:   }
71: 
72:   // Check if it's time to write to file
73:   if (Date.now() - lastWriteTime > WRITE_INTERVAL) {
74:     await writeMetricsToFile()
75:   }
76: 
77:   return { success: true, message: 'Ad metrics received and batched' }
78: })
```

## File: layers/advert/nuxt.config.ts
```typescript
1: import { defineNuxtConfig } from 'nuxt/config'
2: 
3: export default defineNuxtConfig({
4:   workspaceDir: '../../',
5:   srcDir: '.',
6: })
```

## File: layers/auth/.playground/app.config.ts
```typescript
1: export default defineAppConfig({
2:   myLayer: {
3:     name: 'My amazing Nuxt layer (overwritten)'
4:   }
5: })
```

## File: layers/auth/.playground/nuxt.config.ts
```typescript
1: export default defineNuxtConfig({
2:   extends: ['..'],
3:   modules: ['@nuxt/eslint']
4: })
```

## File: layers/auth/composables/user.current.store.ts
```typescript
  1: import { useLogger } from '@ib/logger'
  2: 
  3: const DOMAIN_KEY = 'currentUser'
  4: 
  5: export const useCurrentUser = defineStore(DOMAIN_KEY, () => {
  6:   const authUrl = useRuntimeConfig().public.aeAuthUrl
  7:   const logger = useLogger(DOMAIN_KEY)
  8:   const errors = useBaseError()
  9:   const loading = useLoadingStore()
 10:   const { fetch } = useBaseFetch()
 11:   const userId = useCookie('userId')
 12:   const user = useSupabaseUser()
 13: 
 14:   // check:critical - user should only be able to fetch their own full profile
 15:   // check:critical - user should only be able to update their own profile
 16:   // todo:high - allow user to update their profile info
 17:   // todo:med - merge currentUser and profile into one, store all required data everything in their session
 18:   // assign Posthog identify
 19: 
 20:   console.log('user', user.value)
 21: 
 22:   const profile = computed(() => ({
 23:     id: user.value?.id,
 24:     given_name: user.value?.user_metadata?.given_name,
 25:     email_confirmed_at: user.value?.email_confirmed_at,
 26:     confirmation_sent_at: user.value?.confirmation_sent_at,
 27:     confirmed_at: user.value?.confirmed_at,
 28:     created_at: user.value?.created_at,
 29:     surname: user.value?.user_metadata?.surname,
 30:     last_sign_in_at: user.value?.last_sign_in_at,
 31:     email: user.value?.email,
 32:     providers: user.value?.app_metadata.providers,
 33:     avatar: user.value?.user_metadata.avatar || user.value?.user_metadata.avatar_url,
 34:     provider: user.value?.provider,
 35:     user_role: user.value?.app_metadata?.role,
 36:     user_plan: user.value?.app_metadata?.plan,
 37:   }))
 38: 
 39:   // extract as util func
 40:   function hasValueChanged(newValue: any, currentValue: any): boolean {
 41:     console.log('hasValueChanged', newValue, currentValue)
 42:     if (
 43:       typeof newValue === 'string' ||
 44:       typeof newValue === 'boolean' ||
 45:       typeof newValue === 'number'
 46:     ) {
 47:       return newValue !== currentValue
 48:     } else if (Array.isArray(newValue)) {
 49:       return JSON.stringify(newValue) !== JSON.stringify(currentValue)
 50:     } else if (typeof newValue === 'object' && newValue !== null) {
 51:       return JSON.stringify(newValue) !== JSON.stringify(currentValue)
 52:     } else {
 53:       return newValue !== currentValue
 54:     }
 55:   }
 56: 
 57:   function cleanDataForUpdate(newData: any, previousData: any) {
 58:     const updatedData: any = {}
 59:     for (const key in newData) {
 60:       if (
 61:         Object.hasOwnProperty.call(newData, key) &&
 62:         hasValueChanged(newData[key], previousData[key])
 63:       ) {
 64:         updatedData[key] = newData[key]
 65:       }
 66:     }
 67: 
 68:     return { data: updatedData, noDataUpdated: Object.keys(updatedData).length === 0 }
 69:   }
 70: 
 71:   async function updateProfile(newData: any, isMock: boolean = false) {
 72:     logger.info('Starting updateProfile function', { newData, isMock })
 73:     const updatedData: any = {}
 74:     const toast = useNotification()
 75: 
 76:     logger.debug('Cleaning data for update')
 77:     // Compare newData with fullProfile and only include changed values
 78:     const { noDataUpdated, data } = cleanDataForUpdate(newData, profile.value)
 79: 
 80:     if (noDataUpdated) {
 81:       logger.info('No changes detected, no update necessary')
 82:       return
 83:     }
 84: 
 85:     logger.debug('Changes detected', { changedData: data })
 86: 
 87:     try {
 88:       logger.info('Sending update request to server')
 89:       let response
 90:       if (isMock) {
 91:         logger.info('Using mock API call')
 92:         // response = await mockApiCall(data)
 93:       } else {
 94:         response = await $fetch('/api/users/update', {
 95:           method: 'POST',
 96:           body: JSON.stringify(data),
 97:         })
 98:       }
 99:       logger.debug('Received response from server', { response })
100: 
101:       const validData = errors.server({
102:         response,
103:         devOnly: false,
104:         devMessage: 'Error updating user profile',
105:         userMessage: 'There was an error updating your profile after action',
106:       })
107: 
108:       if (response.error) {
109:         toast.error({ summary: 'Could not update profile', message: response.error.message })
110:         return
111:       } else {
112:         toast.success({
113:           summary: 'Profile updated successfully',
114:           message: 'Your profile was updated',
115:         })
116:       }
117: 
118:       logger.info('Successfully validated server response', { validData })
119: 
120:       // update state
121:       logger.debug('Updating user profile state')
122:       for (const key in data) {
123:         if (Object.hasOwnProperty.call(data, key)) {
124:           profile.value[key] = data[key]
125:           logger.debug(`Updating profile field: ${key}`, {
126:             newValue: data[key],
127:           })
128:         }
129:       }
130:       logger.info('Profile update completed successfully')
131:     } catch (error) {
132:       logger.error('Error occurred during profile update', { error })
133:       throw error // Re-throw the error for the caller to handle
134:     }
135:   }
136: 
137:   // Test function
138:   async function testUpdateProfile() {
139:     const testCases = [
140:       { name: 'John Doe', email: 'john@example.com' },
141:       { name: 'Jane Doe', email: 'error@example.com' }, // This will trigger an error
142:       {}, // This should result in no update
143:     ]
144: 
145:     for (const testCase of testCases) {
146:       try {
147:         console.log('Testing with data:', testCase)
148:         await updateProfile(testCase, true) // Use mock API
149:         console.log('Test passed successfully')
150:       } catch (error) {
151:         console.error('Test failed:', error.message)
152:       }
153:       console.log('---')
154:     }
155:   }
156: 
157:   type FileType = 'avatar'
158:   async function uploadImage(fileType: FileType, blob: Blob) {
159:     // currentFileName is the current file name in the database eg. avatar-drew-macgibbon.jpg
160:     const formData = new FormData()
161:     formData.append('file', blob)
162: 
163:     const response = await $fetch('/api/users/insert/image', {
164:       method: 'POST',
165:       body: formData,
166:       params: {
167:         fileType,
168:         userId: userId.value,
169:       },
170:     })
171: 
172:     console.log('fileName', response)
173: 
174:     const fileName = errors.server({
175:       response,
176:       devOnly: false,
177:       devMessage: `Error uploading ${fileType} image`,
178:       userMessage: `There was an error uploading your ${fileType}`,
179:     })
180: 
181:     let newData = {}
182: 
183:     console.log('fileName', fileName)
184: 
185:     if (fileType === 'avatar') {
186:       newData = {
187:         avatar: fileName,
188:       }
189:     }
190: 
191:     updateProfile(newData)
192:   }
193: 
194:   // first check if the user has an avatar in their profile
195:   // if not, check if the user has an avatar in their identities
196:   // cycle through identities check identities_data for picture
197: 
198:   return {
199:     haveUserSession: computed(() => !!profile.value),
200:     isAdmin: computed(
201:       () => profile.value?.user_role === 'admin' || profile.value?.user_role === 'super_admin',
202:     ),
203:     registeredWithProvider: computed(() => profile.value?.provider),
204:     profile,
205:     uploadImage,
206:     updateProfile,
207:     testUpdateProfile,
208:   }
209: })
210: 
211: if (import.meta.hot) {
212:   import.meta.hot.accept(acceptHMRUpdate(useCurrentUser, import.meta.hot))
213: }
```

## File: layers/auth/server/middleware/cors.ts
```typescript
 1: import { defineEventHandler, getRequestHeader, setResponseHeaders } from 'h3'
 2: 
 3: export default defineEventHandler((event) => {
 4:   const allowedDomains = ['astronera.org', 'up.railway.app', 'rlwy.net', 'localhost']
 5: 
 6:   const origin = getRequestHeader(event, 'origin') || ''
 7: 
 8:   const isAllowedOrigin = allowedDomains.some(
 9:     (domain) =>
10:       origin.startsWith('http://localhost:') || // Allow any localhost port
11:       origin.endsWith(`.${domain}`) || // Allow all subdomains
12:       origin === `https://${domain}`, // Allow apex domain
13:   )
14: 
15:   if (isAllowedOrigin || process.env.NODE_ENV !== 'production') {
16:     setResponseHeaders(event, {
17:       'Access-Control-Allow-Methods': 'GET,HEAD,PUT,PATCH,POST,DELETE',
18:       'Access-Control-Allow-Origin': origin,
19:       'Access-Control-Allow-Credentials': 'true',
20:       'Access-Control-Allow-Headers': 'Content-Type, Authorization, X-Requested-With',
21:       'Access-Control-Expose-Headers': 'Content-Length, X-JSON',
22:     })
23:   }
24: 
25:   console.log('CORS', origin, isAllowedOrigin)
26: 
27:   if (event.method === 'OPTIONS') {
28:     event.node.res.statusCode = 204
29:     event.node.res.statusMessage = 'No Content.'
30:     return 'OK'
31:   }
32: })
```

## File: layers/auth/nuxt.config.ts
```typescript
 1: import { fileURLToPath } from 'url'
 2: import { dirname, join, resolve } from 'path'
 3: import { defineNuxtConfig } from 'nuxt/config'
 4: import tsconfigPaths from 'vite-tsconfig-paths'
 5: 
 6: const currentDir = dirname(fileURLToPath(import.meta.url))
 7: 
 8: console.log('Node Env:', process.env.NODE_ENV)
 9: 
10: export default defineNuxtConfig({
11:   workspaceDir: '../../',
12:   srcDir: '.',
13: 
14:   modules: ['@nuxtjs/supabase'],
15: 
16:   supabase: {
17:     redirect: false,
18:     clientOptions: {
19:       auth: {
20:         flowType: 'pkce',
21:         detectSessionInUrl: true,
22:         persistSession: true,
23:         autoRefreshToken: true,
24:       },
25:     },
26:     cookieOptions: {
27:       domain:
28:         process.env.NODE_ENV === 'production'
29:           ? 'astronera.org' // This will work for all subdomains
30:           : 'localhost',
31:       maxAge: 60 * 60 * 8,
32:       path: '/',
33:       sameSite: 'lax',
34:       secure: process.env.NODE_ENV === 'production' ? true : false,
35:     },
36:     cookieName: 'sb',
37:   },
38: })
```

## File: layers/base/.playground/app.config.ts
```typescript
1: export default defineAppConfig({
2:   myLayer: {
3:     name: 'My amazing Nuxt layer (overwritten)',
4:   },
5: })
```

## File: layers/base/.playground/nuxt.config.ts
```typescript
1: export default defineNuxtConfig({
2:   extends: ['..'],
3:   modules: ['@nuxt/eslint'],
4: })
```

## File: layers/base/components/image/ImageHero.vue
```vue
 1: <script setup lang="ts">
 2: import type { TitleType, ImageType } from '../../types/content'
 3: 
 4: defineProps({
 5:   fit: {
 6:     type: String,
 7:     default: 'cover',
 8:   },
 9:   objectPosition: {
10:     type: String,
11:     default: 'center',
12:   },
13:   title: {
14:     type: Object as () => TitleType,
15:     required: true,
16:   },
17:   img: {
18:     type: Object as () => ImageType,
19:     required: true,
20:   },
21: })
22: 
23: // consider turning the images into short videos using AI
24: // consider using mix-blend-mode for cool text effect with video
25: </script>
26: 
27: <template>
28:   <div class="relative flex items-center justify-center">
29:     <IBImage
30:       :img="{
31:         src: img.src,
32:         alt: img.alt,
33:         width: img.width,
34:         height: img.height,
35:       }"
36:       :class="`w-full object-${fit} ${objectPosition} h-screen`"
37:     />
38:     <div
39:       class="absolute z-10 flex flex-col items-center justify-center gap-8 px-4 text-white lg:flex-row lg:gap-16 xl:px-8"
40:     >
41:       <slot />
42:       <div class="flex flex-col gap-4">
43:         <h2
44:           :class="`rounded-md bg-black/30 px-4 py-1 text-3xl font-bold shadow-xl lg:text-5xl xl:px-8 text-${title.centered ? 'center' : 'left'}`"
45:         >
46:           {{ title.main }}
47:         </h2>
48:         <p
49:           v-if="title.subtitle"
50:           :class="`inline-block w-auto max-w-2xl rounded-sm px-4 pb-4 text-xl font-semibold lg:text-3xl xl:px-8 text-${title.centered ? 'center' : 'left'}`"
51:         >
52:           {{ title.subtitle }}
53:         </p>
54:       </div>
55:     </div>
56:     <div class="absolute left-0 top-0 h-full w-full bg-black/50" />
57:   </div>
58: </template>
59: 
60: <style scoped></style>
```

## File: layers/base/components/image/ImageWithFallback.vue
```vue
 1: <script setup lang="ts">
 2: interface Image {
 3:   src: string
 4:   alt: string | null
 5:   caption: string | null
 6:   credit: string | null
 7: }
 8: 
 9: interface Options {
10:   width: number
11:   height: number
12:   sizes: string | undefined | null
13:   quality: number | undefined | null
14: }
15: 
16: defineProps({
17:   image: {
18:     type: Object as () => Image | undefined,
19:     default: undefined,
20:   },
21:   options: {
22:     type: Object as () => Options | undefined,
23:     default: () => ({
24:       width: 50,
25:       height: 50,
26:       sizes: null,
27:       quality: 80,
28:     }),
29:   },
30: })
31: </script>
32: 
33: <template>
34:   <div class="relative h-full w-full overflow-hidden rounded-md object-cover">
35:     <IBImage
36:       :img="{
37:         src: image?.src || 'hero-image.jpg',
38:         alt: image?.alt || 'this is a default fallback for when an image is not present',
39:         width: options?.width || 60,
40:         height: options?.height || 37,
41:         quality: options?.quality || 80,
42:       }"
43:       class="h-full w-full object-cover"
44:     />
45:     <div
46:       v-if="!image?.src"
47:       class="absolute left-0 top-0 z-50 flex h-full w-full items-center justify-center bg-black/40"
48:     >
49:       <h3 class="foreground rounded-lg px-3 py-1 text-base"> NO IMAGE </h3>
50:     </div>
51:   </div>
52: </template>
```

## File: layers/base/components/Background.vue
```vue
 1: <template>
 2:   <canvas
 3:     ref="canvas"
 4:     class="w-full h-full"
 5:   />
 6: </template>
 7: 
 8: <script setup lang="ts">
 9: const CANVAS_WIDTH = computed(() => (window ? window.innerWidth : 0))
10: const CANVAS_HEIGHT = computed(() => (window ? window.innerHeight + 800 : 0))
11: const STAR_COUNT = 300 // Number of stars
12: const COLORS = ['#ffffff', '#ffcccb', '#add8e6'] // White, red, blue
13: 
14: // Refs
15: const canvas = ref<HTMLCanvasElement | null>(null)
16: let ctx: CanvasRenderingContext2D | null = null
17: let animationFrameId: number
18: 
19: // Utility function to get random number within a range
20: function getRandom(min: number, max: number): number {
21:   return Math.random() * (max - min) + min
22: }
23: 
24: // Create stars array
25: const stars = Array.from({ length: STAR_COUNT }, () => ({
26:   x: getRandom(0, CANVAS_WIDTH.value),
27:   y: getRandom(0, CANVAS_HEIGHT.value),
28:   radius: getRandom(0.5, 2),
29:   color: COLORS[Math.floor(Math.random() * COLORS.length)],
30:   speed: 0.01, // Speed of movement
31:   initialX: 0,
32:   initialY: 0,
33: }))
34: 
35: // Initialize star positions
36: stars.forEach((star) => {
37:   star.initialX = star.x
38:   star.initialY = star.y
39: })
40: 
41: // Draw stars on canvas
42: function drawStars() {
43:   if (!ctx) {
44:     return
45:   }
46: 
47:   ctx.clearRect(0, 0, CANVAS_WIDTH.value, CANVAS_HEIGHT.value)
48: 
49:   stars.forEach((star) => {
50:     ctx.beginPath()
51:     ctx.arc(star.x, star.y, star.radius, 0, 2 * Math.PI, false)
52:     ctx.fillStyle = star.color
53:     ctx.shadowColor = star.color
54:     ctx.shadowBlur = 8
55:     ctx.fill()
56:     ctx.closePath()
57: 
58:     // Update star position to follow an inverted arc path
59:     star.x -= star.speed
60:     star.y =
61:       star.initialY - Math.sin((star.x / CANVAS_WIDTH.value) * Math.PI) * (CANVAS_HEIGHT.value / 4)
62: 
63:     // Wrap stars around edges
64:     if (star.x < 0) {
65:       star.x = CANVAS_WIDTH.value
66:       star.initialY = getRandom(0, CANVAS_HEIGHT.value)
67:     }
68:   })
69: 
70:   // Request next animation frame
71:   animationFrameId = requestAnimationFrame(drawStars)
72: }
73: 
74: // Set up canvas and start animation
75: onMounted(() => {
76:   if (canvas.value) {
77:     canvas.value.width = CANVAS_WIDTH.value
78:     canvas.value.height = CANVAS_HEIGHT.value
79:     ctx = canvas.value.getContext('2d')
80:     if (ctx) {
81:       ctx.fillStyle = 'black'
82:       ctx.fillRect(0, 0, CANVAS_WIDTH.value, CANVAS_HEIGHT.value)
83:       drawStars()
84:     }
85:   }
86: })
87: 
88: // Clean up animation on component unmount
89: onBeforeUnmount(() => {
90:   cancelAnimationFrame(animationFrameId)
91: })
92: </script>
93: 
94: <style scoped>
95: canvas {
96:   width: 100vw;
97:   height: 120vh;
98: }
99: </style>
```

## File: layers/base/components/Breadcrumbs.vue
```vue
 1: <script lang="ts" setup>
 2: const route = useRoute()
 3: 
 4: const generateBreadcrumbs = (path: string) => {
 5:   const pathParts = path.split('/').filter(Boolean)
 6:   let currentPath = ''
 7:   return pathParts.map((part) => {
 8:     currentPath += `/${part}`
 9:     return {
10:       to: currentPath,
11:       label: part.charAt(0).toUpperCase() + part.slice(1),
12:       ariaLabel: part.charAt(0).toUpperCase() + part.slice(1),
13:     }
14:   })
15: }
16: 
17: const links = computed(() => generateBreadcrumbs(route.path))
18: 
19: // Prepare links by filtering and adjusting labels
20: const formattedLinks = computed(() => {
21:   if (!links.value) return []
22:   console.log('Formatting links', links.value)
23:   return links.value
24:     .map((link) => {
25:       if (!link) return null // Skip if link is undefined or null
26: 
27:       // Filter out the home link if in app route
28:       if (link.to === '/') {
29:         console.log('Filtering out home link', link)
30:         return null
31:       }
32: 
33:       // Special handling for the 'astrotribe' path
34:       if (link.to === '/') {
35:         return { ...link, label: 'Home', ariaLabel: 'Home' }
36:       }
37: 
38:       if (link.to === '/ask') {
39:         return { ...link, label: 'Q&A', ariaLabel: 'Q&A' }
40:       }
41: 
42:       return link // Return unmodified link
43:     })
44:     .filter(Boolean) // Remove null entries
45: })
46: </script>
47: 
48: <template>
49:   <PrimeBreadcrumb
50:     v-if="formattedLinks.length"
51:     :model="formattedLinks"
52:     :pt="{
53:       root: 'foreground p-0 flex items-center justify-start',
54:       menu: '!mb-0',
55:     }"
56:   >
57:     <template #item="{ item }">
58:       <NuxtLink :to="item.to">
59:         <span
60:           class="text-primary font-semibold"
61:           :class="item.current ? 'link-active' : ''"
62:         >
63:           {{ item.label }}
64:         </span>
65:       </NuxtLink>
66:     </template>
67:   </PrimeBreadcrumb>
68: </template>
69: 
70: <style></style>
```

## File: layers/base/components/Glass.vue
```vue
  1: <script setup lang="ts">
  2: const uniqueId = useId()
  3: 
  4: const tailwindColors = [
  5:   'slate',
  6:   'gray',
  7:   'zinc',
  8:   'neutral',
  9:   'stone',
 10:   'red',
 11:   'orange',
 12:   'amber',
 13:   'yellow',
 14:   'lime',
 15:   'green',
 16:   'emerald',
 17:   'teal',
 18:   'cyan',
 19:   'sky',
 20:   'blue',
 21:   'indigo',
 22:   'violet',
 23:   'purple',
 24:   'fuchsia',
 25:   'pink',
 26:   'rose',
 27:   'primary', // Assuming you have a custom 'primary' color
 28: ] as const
 29: 
 30: type TailwindColor = (typeof tailwindColors)[number]
 31: 
 32: const props = defineProps({
 33:   color: { type: String as PropType<TailwindColor>, default: 'slate' },
 34:   bgOpacity: { type: Number, default: 20 },
 35:   gradientOpacity: { type: Number, default: 10 },
 36:   blurIntensity: { type: String, default: 'md' },
 37:   disableHover: { type: Boolean, default: false },
 38:   padding: { type: String, default: '6' },
 39:   loading: { type: Boolean, default: false },
 40:   ariaLabel: { type: String, default: 'Glass card' },
 41: })
 42: 
 43: const cardRef = ref<HTMLElement | null>(null)
 44: const gravityAreaRef = ref<HTMLElement | null>(null)
 45: 
 46: const {
 47:   handleMouseMove,
 48:   handleMouseLeave,
 49:   cardStyle,
 50:   spotlightStyle,
 51:   bgClasses,
 52:   borderClasses,
 53:   textClasses,
 54:   gradientClasses,
 55:   hoverClasses,
 56: } = useGlassCard(props, uniqueId)
 57: </script>
 58: 
 59: <template>
 60:   <div
 61:     :id="uniqueId"
 62:     class="relative"
 63:   >
 64:     <div
 65:       ref="gravityAreaRef"
 66:       class="pointer-events-none absolute -inset-[30%] z-0"
 67:     ></div>
 68:     <div
 69:       ref="cardRef"
 70:       :class="[
 71:         'glass-card relative overflow-hidden rounded-md shadow-xl',
 72:         'ring-2 ring-inset ring-white/10',
 73:         `backdrop-blur-${blurIntensity}`,
 74:         `p-${padding}`,
 75:         bgClasses,
 76:         borderClasses,
 77:         textClasses,
 78:         ...hoverClasses,
 79:       ]"
 80:       :style="cardStyle"
 81:       role="region"
 82:       :aria-label="ariaLabel"
 83:       @mousemove="(e) => handleMouseMove(e)"
 84:       @mouseleave="handleMouseLeave"
 85:     >
 86:       <div class="glass-card-content relative z-20">
 87:         <slot name="header"></slot>
 88:         <slot></slot>
 89:       </div>
 90:       <div
 91:         :class="['absolute inset-0 z-10 h-full w-full bg-gradient-to-br', gradientClasses]"
 92:       ></div>
 93:       <div
 94:         class="glass-effect"
 95:         :style="spotlightStyle"
 96:       ></div>
 97:       <div
 98:         v-if="loading"
 99:         class="animate-shimmer absolute inset-0 bg-gradient-to-r from-transparent via-white/10 to-transparent"
100:       ></div>
101:     </div>
102:   </div>
103: </template>
104: 
105: <style scoped>
106: .glass-card {
107:   transition: all 0.3s ease;
108: }
109: 
110: .glass-effect {
111:   position: absolute;
112:   inset: 0;
113:   pointer-events: none;
114:   transition: opacity 0.2s;
115: }
116: 
117: .glass-card-content {
118:   transition: transform 0.3s ease;
119: }
120: 
121: .glass-card:hover .glass-card-content {
122:   transform: translateY(-5px);
123: }
124: 
125: @keyframes shimmer {
126:   0% {
127:     transform: translateX(-100%);
128:   }
129:   100% {
130:     transform: translateX(100%);
131:   }
132: }
133: 
134: .animate-shimmer {
135:   animation: shimmer 1.5s infinite;
136: }
137: 
138: .spotlight {
139:   backdrop-filter: blur(2px) contrast(1.2);
140:   mix-blend-mode: overlay;
141: }
142: </style>
```

## File: layers/base/components/GlobalTimer.vue
```vue
  1: <script setup lang="ts">
  2: const isVisible = ref(true)
  3: const isTracking = ref(false)
  4: const elapsedTime = ref(0)
  5: const currentTask = ref('')
  6: let timer: NodeJS.Timeout | null = null
  7: let startTime: number
  8: let pausedTime = 0
  9: 
 10: function startTimer() {
 11:   if (!import.meta.client) return
 12: 
 13:   if (!isTracking.value) {
 14:     isTracking.value = true
 15:     startTime = Date.now() - pausedTime
 16:     timer = setInterval(() => {
 17:       elapsedTime.value = Math.floor((Date.now() - startTime) / 1000)
 18:     }, 1000)
 19:   }
 20: }
 21: 
 22: function pauseTimer() {
 23:   if (isTracking.value) {
 24:     isTracking.value = false
 25:     if (timer) {
 26:       clearInterval(timer)
 27:       timer = null
 28:     }
 29:     pausedTime = Date.now() - startTime
 30:   }
 31: }
 32: 
 33: function stopTimer() {
 34:   isTracking.value = false
 35:   isVisible.value = false
 36:   if (timer) {
 37:     clearInterval(timer)
 38:     timer = null
 39:   }
 40:   elapsedTime.value = 0
 41:   pausedTime = 0
 42:   currentTask.value = ''
 43: }
 44: 
 45: function showTimer(taskTitle: string) {
 46:   currentTask.value = taskTitle
 47:   isVisible.value = true
 48:   startTimer()
 49: }
 50: 
 51: function formatTime(seconds: number) {
 52:   const hours = Math.floor(seconds / 3600)
 53:   const minutes = Math.floor((seconds % 3600) / 60)
 54:   const secs = seconds % 60
 55:   return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`
 56: }
 57: 
 58: onUnmounted(() => {
 59:   if (timer) clearInterval(timer)
 60: })
 61: 
 62: defineExpose({
 63:   showTimer,
 64:   stopTimer,
 65: })
 66: </script>
 67: 
 68: <template>
 69:   <div
 70:     v-if="isVisible"
 71:     class="flex items-center gap-2 rounded-lg bg-gray-800 p-2 text-white shadow-lg"
 72:   >
 73:     <div class="text-sm font-bold">
 74:       {{ currentTask }}
 75:     </div>
 76:     <div class="text-xl"> ⏱️ {{ formatTime(elapsedTime) }} </div>
 77:     <div class="flex space-x-2">
 78:       <PrimeButton
 79:         v-if="!isTracking"
 80:         size="small"
 81:         class="rounded-full bg-green-500 p-2 hover:bg-green-600"
 82:         @click="startTimer"
 83:       >
 84:         <Icon
 85:           name="mdi:play"
 86:           size="24px"
 87:         />
 88:       </PrimeButton>
 89:       <PrimeButton
 90:         v-else
 91:         size="small"
 92:         class="rounded-full bg-yellow-500 p-2 hover:bg-yellow-600"
 93:         @click="pauseTimer"
 94:       >
 95:         <Icon
 96:           name="mdi:pause"
 97:           size="24px"
 98:         />
 99:       </PrimeButton>
100:       <PrimeButton
101:         size="small"
102:         class="rounded-full bg-red-500 p-2 hover:bg-red-600"
103:         @click="stopTimer"
104:       >
105:         <Icon
106:           name="mdi:stop"
107:           size="24px"
108:         />
109:       </PrimeButton>
110:     </div>
111:   </div>
112: </template>
```

## File: layers/base/components/Grid.vue
```vue
1: <script setup lang="ts"></script>
2: 
3: <template>
4:   <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 2xl:grid-cols-4 md:gap-4 xl:gap-8">
5:     <slot />
6:   </div>
7: </template>
8: 
9: <style scoped></style>
```

## File: layers/base/components/HelloWorld.vue
```vue
 1: <script setup lang="ts">
 2: const { myLayer } = useAppConfig()
 3: </script>
 4: 
 5: <template>
 6:   <div>
 7:     <h1>Hello World!</h1>
 8:     <pre>{{ myLayer }}</pre>
 9:   </div>
10: </template>
```

## File: layers/base/components/HoverCard.vue
```vue
 1: <script setup lang="ts">
 2: const enableHoverEffect = ref(false)
 3: const hoverPosition = ref(null as null | 'up' | 'down') // 'up', 'center', or 'down'
 4: 
 5: function checkHoverPosition(event) {
 6:   if (!enableHoverEffect.value) {
 7:     return // Do nothing if hover effects are disabled
 8:   }
 9:   const rect = event.target.getBoundingClientRect()
10:   const halfScreen = window.innerHeight / 2
11:   if (rect.top < halfScreen) {
12:     console.log('top')
13:     // If the card is in the top third, expand downwards
14:     hoverPosition.value = 'down'
15:   } else {
16:     console.log('bottom')
17:     // If the card is in the bottom third, expand upwards
18:     hoverPosition.value = 'up'
19:   }
20: }
21: 
22: const checkScreenSize = () => {
23:   enableHoverEffect.value = window.innerWidth >= 1024 // Tailwind's 'lg' breakpoint
24: }
25: 
26: const paddingSize = computed(() => (window.innerWidth >= 1280 ? 32 : 16))
27: 
28: onMounted(() => {
29:   window.addEventListener('resize', checkScreenSize)
30:   checkScreenSize()
31:   return () => window.removeEventListener('resize', checkScreenSize)
32: })
33: 
34: // ui:med:easy:1 - if there is only one card in the grid row, we need to set min h of 100% to prevent the card from collapsing
35: </script>
36: 
37: <template>
38:   <div
39:     class="group relative hover:z-50"
40:     @mouseenter="checkHoverPosition"
41:     @mouseleave="hoverPosition = null"
42:   >
43:     <div
44:       :class="[
45:         'transition-all duration-300 delay-200 p-4 border-b-2 md:border border-color overflow-hidden background',
46:         'flex flex-col gap-4 w-full h-full md:rounded-md md:shadow-md',
47:         {
48:           'lg:group-hover:absolute': enableHoverEffect && !!hoverPosition,
49:           'top-0': enableHoverEffect && hoverPosition === 'down',
50:           'bottom-0': enableHoverEffect && hoverPosition === 'up',
51:         },
52:       ]"
53:       :style="{
54:         height: enableHoverEffect && !!hoverPosition ? `calc(200% + ${paddingSize}px)` : '100%',
55:       }"
56:     >
57:       <slot></slot>
58:     </div>
59:   </div>
60: </template>
61: 
62: <style scoped>
63: /* Extra styles if needed */
64: </style>
```

## File: layers/base/components/Image.vue
```vue
 1: <script lang="ts" setup>
 2: const uuid = useId()
 3: 
 4: const props = defineProps({
 5:   img: {
 6:     type: Object,
 7:     required: true,
 8:   },
 9:   noShrink: {
10:     type: Boolean,
11:     default: false,
12:   },
13: })
14: 
15: const imageUrl = ref(null)
16: 
17: watch(
18:   () => props.img.src,
19:   (newVal) => {
20:     imageUrl.value = newVal
21:   },
22:   { immediate: true },
23: )
24: 
25: function loadFallbackImage(error: Error) {
26:   console.error('Image loading error:', error)
27:   imageUrl.value = `images/defaults/${props.img.type ?? 'fallback'}.jpg`
28: }
29: </script>
30: 
31: <template>
32:   <NuxtImg
33:     v-if="imageUrl"
34:     :key="`image-${uuid}`"
35:     v-bind="$attrs"
36:     :src="imageUrl"
37:     :alt="img.alt"
38:     :width="img.width"
39:     :height="img.height"
40:     :format="img.format"
41:     :quality="img.quality"
42:     :loading="img.loading"
43:     crossorigin="anonymous"
44:     :class="{ 'flex shrink-0': !noShrink }"
45:     @error="loadFallbackImage"
46:   />
47: </template>
```

## File: layers/base/components/InfiniteScroll.vue
```vue
 1: <script setup lang="ts">
 2: const emit = defineEmits(['update:scrollEnd'])
 3: const scrollContainer = ref<HTMLElement | null>(null)
 4: const observer = ref<IntersectionObserver | null>(null)
 5: 
 6: onMounted(() => {
 7:   if ('IntersectionObserver' in window) {
 8:     observer.value = new IntersectionObserver(
 9:       (entries) => {
10:         if (entries[0].isIntersecting) {
11:           emit('update:scrollEnd')
12:         }
13:       },
14:       {
15:         root: null,
16:         rootMargin: '200px', // Load more content when within 200px of the bottom
17:         threshold: 0.1, // Trigger when at least 10% of the target is visible
18:       },
19:     )
20: 
21:     if (scrollContainer.value) {
22:       observer.value.observe(scrollContainer.value)
23:     }
24:   } else {
25:     // Fallback for browsers that don't support IntersectionObserver
26:     window.addEventListener('scroll', handleScroll)
27:   }
28: })
29: 
30: onUnmounted(() => {
31:   if (observer.value && scrollContainer.value) {
32:     observer.value.unobserve(scrollContainer.value)
33:   }
34:   window.removeEventListener('scroll', handleScroll)
35: })
36: 
37: const handleScroll = () => {
38:   if (scrollContainer.value) {
39:     const rect = scrollContainer.value.getBoundingClientRect()
40:     if (rect.top <= window.innerHeight) {
41:       emit('update:scrollEnd')
42:     }
43:   }
44: }
45: </script>
46: 
47: <template>
48:   <div>
49:     <slot />
50:     <div
51:       ref="scrollContainer"
52:       class="h-10 bg-transparent"
53:       aria-hidden="true"
54:     />
55:   </div>
56: </template>
```

## File: layers/base/components/Loader.vue
```vue
 1: <script setup lang="ts">
 2: const loaderWidth = ref('100%')
 3: const loaderHeight = ref('100%')
 4: 
 5: defineProps({
 6:   width: {
 7:     type: String,
 8:     default: '100%',
 9:   },
10:   height: {
11:     type: String,
12:     default: '100%',
13:   },
14: })
15: </script>
16: 
17: <template>
18:   <div
19:     class="skeleton-loader"
20:     :style="{ width: loaderWidth, height: loaderHeight }"
21:   ></div>
22: </template>
23: 
24: <style scoped>
25: .skeleton-loader {
26:   background-color: #f3f3f3;
27:   animation: skeleton-loading 1s infinite linear;
28: }
29: 
30: @keyframes skeleton-loading {
31:   0% {
32:     background-position: -200px 0;
33:   }
34:   100% {
35:     background-position: 200px 0;
36:   }
37: }
38: </style>
```

## File: layers/base/components/Modal.vue
```vue
 1: <script setup lang="ts">
 2: const isOpen = ref(false)
 3: 
 4: const toggleModalOpen = () => {
 5:   isOpen.value = !isOpen.value
 6: }
 7: 
 8: const options = ref({
 9:   isOpen,
10:   toggleModalOpen,
11: })
12: </script>
13: 
14: <template>
15:   <div>
16:     <slot
17:       name="button"
18:       v-bind="options"
19:     />
20:     <PrimeDialog
21:       v-model:visible="isOpen"
22:       modal
23:       :pt="{
24:         root: 'max-w-2xl w-full',
25:         content: 'w-full aspect-square',
26:       }"
27:       :pt-options="{ mergeProps: true, mergeSections: true }"
28:     >
29:       <template #header>
30:         <slot name="modal:header" />
31:       </template>
32:       <slot name="modal:default" />
33:       <template #footer>
34:         <slot
35:           name="modal:footer"
36:           v-bind="options"
37:         />
38:       </template>
39:     </PrimeDialog>
40:   </div>
41: </template>
42: 
43: <style scoped></style>
```

## File: layers/base/components/NavHamburger.vue
```vue
 1: <!-- components/nav/NavHamburger.vue -->
 2: <template>
 3:   <button
 4:     class="md:hidden p-2 hover:bg-gray-800 rounded-lg transition-colors flex"
 5:     @click="toggleMobileNav"
 6:   >
 7:     <Icon
 8:       :name="isMobileSidebarOpen ? 'mdi:close' : 'mdi:menu'"
 9:       size="24px"
10:     />
11:   </button>
12: </template>
13: 
14: <script setup lang="ts">
15: const { isMobileSidebarOpen } = useNavigation()
16: 
17: const toggleMobileNav = () => {
18:   isMobileSidebarOpen.value = !isMobileSidebarOpen.value
19: }
20: </script>
```

## File: layers/base/components/NewLabel.vue
```vue
 1: <script setup lang="ts">
 2: const props = defineProps({
 3:   date: {
 4:     type: String,
 5:     required: true,
 6:   },
 7:   maxAge: {
 8:     type: Number,
 9:     required: true,
10:   },
11: })
12: 
13: const isWithinNumberOfDays = computed(() => {
14:   const currentDate = new Date()
15:   const itemDate = new Date(props.date)
16:   const differenceInDays = Math.floor(
17:     (currentDate.getTime() - itemDate.getTime()) / (1000 * 3600 * 24),
18:   )
19:   return differenceInDays <= props.maxAge
20: })
21: </script>
22: 
23: <template>
24:   <PrimeTag
25:     v-if="isWithinNumberOfDays"
26:     severity="success"
27:     value="NEW"
28:   />
29: </template>
```

## File: layers/base/components/Pagination.vue
```vue
 1: <script setup>
 2: import { onMounted, ref } from 'vue'
 3: import { useRoute } from 'vue-router'
 4: 
 5: // todo:high:1 - implement and test on component
 6: 
 7: const route = useRoute()
 8: const slug = route.params.slug // Dynamic slug based on the current route
 9: const items = ref([])
10: const currentPage = ref(1)
11: 
12: // Store and restore pagination state using session storage
13: const sessionStorageKey = `pagination-${slug}`
14: 
15: function restoreState() {
16:   const savedState = sessionStorage.getItem(sessionStorageKey)
17:   if (savedState) {
18:     const state = JSON.parse(savedState)
19:     currentPage.value = state.currentPage
20:     items.value = state.items
21:   }
22: }
23: 
24: function storeState() {
25:   const state = {
26:     currentPage: currentPage.value,
27:     items: items.value,
28:   }
29:   sessionStorage.setItem(sessionStorageKey, JSON.stringify(state))
30: }
31: 
32: async function fetchItems() {
33:   // Placeholder function to simulate fetching items
34:   const newItems = [{ id: Date.now(), content: `Item ${currentPage.value}` }]
35:   items.value.push(...newItems)
36:   currentPage.value += 1
37:   storeState()
38: }
39: 
40: function loadMore() {
41:   fetchItems()
42: }
43: 
44: onMounted(() => {
45:   restoreState()
46:   if (items.value.length === 0) {
47:     fetchItems()
48:   }
49: })
50: </script>
51: 
52: <template>
53:   <div>
54:     <ul v-if="items.length">
55:       <li
56:         v-for="item in items"
57:         :key="item.id"
58:       >
59:         {{ item.content }}
60:       </li>
61:     </ul>
62:     <button @click="loadMore"> Load More </button>
63:   </div>
64: </template>
```

## File: layers/base/components/Popover.vue
```vue
 1: <script setup lang="ts">
 2: const props = defineProps({
 3:   buttonLabel: { type: String, required: true },
 4: })
 5: 
 6: const popover = ref(null)
 7: 
 8: const toggle = (event) => {
 9:   popover.value?.toggle(event)
10: }
11: </script>
12: 
13: <template>
14:   <div>
15:     <PrimeButton
16:       type="button"
17:       size="small"
18:       severity="secondary"
19:       :label="buttonLabel"
20:       @click="toggle"
21:     />
22:     <PrimePopover ref="popover">
23:       <slot></slot>
24:     </PrimePopover>
25:   </div>
26: </template>
27: 
28: <style scoped></style>
```

## File: layers/base/components/Resizable.vue
```vue
 1: <script lang="ts" setup>
 2: const props = defineProps<{
 3:   slots: Record<string, string>
 4: }>()
 5: 
 6: const container = ref<HTMLElement | null>(null)
 7: const resizer = ref<HTMLElement | null>(null)
 8: const sizes = ref<number[]>([1, 1])
 9: 
10: const startResize = (e: MouseEvent) => {
11:   e.preventDefault()
12:   window.addEventListener('mousemove', resize)
13:   window.addEventListener('mouseup', stopResize)
14: }
15: 
16: const resize = (e: MouseEvent) => {
17:   if (!container.value) return
18:   const containerRect = container.value.getBoundingClientRect()
19:   const newLeftWidth = e.clientX - containerRect.left
20:   const containerWidth = containerRect.width
21: 
22:   sizes.value = [newLeftWidth / containerWidth, 1 - newLeftWidth / containerWidth]
23: }
24: 
25: const stopResize = () => {
26:   window.removeEventListener('mousemove', resize)
27:   window.removeEventListener('mouseup', stopResize)
28: }
29: 
30: onMounted(() => {
31:   if (resizer.value) {
32:     resizer.value.addEventListener('mousedown', startResize)
33:   }
34: })
35: 
36: onUnmounted(() => {
37:   if (resizer.value) {
38:     resizer.value.removeEventListener('mousedown', startResize)
39:   }
40:   window.removeEventListener('mousemove', resize)
41:   window.removeEventListener('mouseup', stopResize)
42: })
43: </script>
44: 
45: <template>
46:   <div
47:     ref="container"
48:     class="relative flex h-full w-full"
49:   >
50:     <div
51:       v-for="(componentId, index) in Object.values(slots)"
52:       :key="componentId"
53:       :class="['overflow-auto', index === 0 ? 'pr-4' : 'pl-4']"
54:       :style="{ flex: sizes[index] }"
55:     >
56:       <slot :name="componentId"></slot>
57:     </div>
58:     <div
59:       ref="resizer"
60:       class="w-2 cursor-col-resize bg-gray-200 hover:bg-gray-300"
61:       @mousedown="startResize"
62:     ></div>
63:   </div>
64: </template>
65: 
66: <style scoped>
67: /* Add any additional styles here */
68: </style>
```

## File: layers/base/components/Sidebar.vue
```vue
 1: <script setup lang="ts">
 2: const isSideVisible = ref(true)
 3: </script>
 4: 
 5: <template>
 6:   <div class="top-0 space-y-4 p-8 md:sticky">
 7:     <div class="flex flex-col justify-center md:justify-start">
 8:       <div class="flex gap-4">
 9:         <!-- <PrimeToggleButton
10:           v-model="isSideVisible"
11:           on-label="Hide"
12:           off-label="Show"
13:         >
14:           <Icon :name="isSideVisible ? 'mdi:eye' : 'mdi:sun'" />
15:         </PrimeToggleButton> -->
16:         <!-- <Transition name="slide-fade">
17:           <PrimeMessage
18:             v-show="isSideVisible"
19:             severity="info"
20:             :pt="{ root: '', text: 'text-sm text-left' }"
21:           >
22:             Filters Coming Soon
23:           </PrimeMessage>
24:         </Transition> -->
25:       </div>
26:     </div>
27:   </div>
28: </template>
29: 
30: <style scoped>
31: /*
32:   Enter and leave animations can use different
33:   durations and timing functions.
34: */
35: .slide-fade-enter-active {
36:   transition: all 0.3s ease-out;
37: }
38: 
39: .slide-fade-leave-active {
40:   transition: all 0.8s cubic-bezier(1, 0.5, 0.8, 1);
41: }
42: 
43: .slide-fade-enter-from,
44: .slide-fade-leave-to {
45:   transform: translateX(-20px);
46:   opacity: 0;
47: }
48: 
49: .slide-top-enter-active {
50:   transition: all 0.3s ease-out;
51: }
52: 
53: .slide-top-leave-active {
54:   transition: all 0.8s cubic-bezier(1, 0.5, 0.8, 1);
55: }
56: 
57: .slide-top-enter-from,
58: .slide-top-leave-to {
59:   transform: translateY(-20px);
60:   opacity: 0;
61: }
62: </style>
```

## File: layers/base/components/SideNav.vue
```vue
  1: <script setup lang="ts">
  2: const props = defineProps({
  3:   categories: {
  4:     type: Array,
  5:     required: true,
  6:   },
  7:   showDevHelpers: {
  8:     type: Boolean,
  9:     default: false,
 10:   },
 11:   isMobile: {
 12:     type: Boolean,
 13:     default: false,
 14:   },
 15:   isSidebarOpen: {
 16:     type: Boolean,
 17:     required: true,
 18:   },
 19:   isMobileSidebarOpen: {
 20:     type: Boolean,
 21:     required: true,
 22:   },
 23: })
 24: 
 25: const route = useRoute()
 26: const emit = defineEmits(['update:isSidebarOpen', 'update:isMobileSidebarOpen'])
 27: // Handle navigation - close mobile nav when navigating
 28: const handleNavigation = () => {
 29:   if (props.isMobile) {
 30:     emit('update:isMobileSidebarOpen', false)
 31:   }
 32: }
 33: 
 34: // Watch route changes to close mobile nav
 35: watch(
 36:   () => route.path,
 37:   () => {
 38:     if (props.isMobile) {
 39:       emit('update:isMobileSidebarOpen', false)
 40:     }
 41:   },
 42: )
 43: </script>
 44: 
 45: <template>
 46:   <div class="relative z-50">
 47:     <!-- Mobile Overlay -->
 48:     <div
 49:       v-if="isMobile"
 50:       class="fixed inset-0 z-[90] bg-black/50 transition-opacity duration-300"
 51:       :class="
 52:         isMobileSidebarOpen ? 'opacity-100 pointer-events-auto' : 'opacity-0 pointer-events-none'
 53:       "
 54:       @click="$emit('update:isMobileSidebarOpen', false)"
 55:     />
 56:     <div
 57:       class="flex flex-col background text-gray-300 shadow-lg transition-all duration-300 group"
 58:       :class="[
 59:         // Shared styles
 60:         'h-full',
 61: 
 62:         // Mobile styles
 63:         isMobile && [
 64:           'fixed left-0 top-0 bottom-0 z-[100]',
 65:           'w-[70vw]',
 66:           isMobileSidebarOpen ? 'translate-x-0' : '-translate-x-full',
 67:         ],
 68: 
 69:         // Desktop styles
 70:         !isMobile && ['relative', 'md:translate-x-0', isSidebarOpen ? 'md:w-60' : 'md:w-14'],
 71:       ]"
 72:     >
 73:       <!-- Toggle button (desktop only) -->
 74:       <button
 75:         v-if="!isMobile"
 76:         class="absolute !z-[1000] -right-3 top-24 hidden h-6 w-6 -translate-y-1/2 items-center justify-center rounded-full bg-primary-600 text-gray-300 transition-opacity duration-300 hover:bg-primary-400 group-hover:opacity-100 md:flex"
 77:         :class="[
 78:           'z-[110]', // Ensure button is above other elements
 79:           isSidebarOpen ? 'opacity-0' : 'opacity-100',
 80:         ]"
 81:         :title="isSidebarOpen ? 'Collapse sidebar' : 'Expand sidebar'"
 82:         @click="$emit('update:isSidebarOpen', !isSidebarOpen)"
 83:       >
 84:         <Icon
 85:           :name="isSidebarOpen ? 'mdi:chevron-left' : 'mdi:chevron-right'"
 86:           size="12px"
 87:         />
 88:       </button>
 89: 
 90:       <div class="flex h-full flex-col overflow-hidden">
 91:         <!-- Logo -->
 92:         <div
 93:           class="flex items-center px-4 py-3 transition-all duration-300"
 94:           :class="isMobile || isSidebarOpen ? 'gap-3' : 'justify-center'"
 95:         >
 96:           <div
 97:             class="flex items-center justify-center rounded-md border bg-white transition-all duration-300 delay-150"
 98:             :class="isMobile || isSidebarOpen ? 'h-10 w-10' : 'h-6 w-6'"
 99:           >
100:             <NuxtLink
101:               to="/"
102:               class="flex h-full w-full items-center justify-center"
103:             >
104:               <IBImage
105:                 :img="{ src: '/astronera-logo.jpg', width: 36, height: 36 }"
106:                 class="h-full w-full transition-all duration-300"
107:                 :class="isMobile || isSidebarOpen ? 'p-0.5' : 'p-1'"
108:                 no-shrink
109:               />
110:             </NuxtLink>
111:           </div>
112:           <Transition
113:             enter-active-class="transition-all duration-150 ease-out"
114:             leave-active-class="transition-all duration-150 ease-in"
115:             enter-from-class="opacity-0 -translate-x-4"
116:             leave-to-class="opacity-0 -translate-x-4"
117:           >
118:             <div
119:               v-if="isMobile || isSidebarOpen"
120:               class="flex cursor-pointer flex-col items-start justify-center text-sm font-bold uppercase leading-none tracking-normal"
121:             >
122:               Astron
123:               <strong class="font-extrabold text-primary-400">Era</strong>
124:             </div>
125:           </Transition>
126:         </div>
127: 
128:         <!-- Navigation Categories - always expanded on mobile -->
129:         <nav class="flex-1 space-y-4 px-2 py-4">
130:           <div
131:             v-for="category in categories"
132:             :key="category.id"
133:             class="space-y-1"
134:           >
135:             <div
136:               v-if="isMobile || isSidebarOpen"
137:               class="px-2 text-xs font-semibold uppercase text-gray-400"
138:             >
139:               {{ category.label }}
140:             </div>
141:             <ul>
142:               <li
143:                 v-for="item in category.items"
144:                 :key="item.slug"
145:               >
146:                 <NuxtLink
147:                   :to="item.slug"
148:                   class="flex items-center rounded-lg px-2 py-2 text-sm font-medium hover:bg-primary-700"
149:                   :class="{ 'bg-primary-800': route.path === item.slug }"
150:                   @click="handleNavigation"
151:                 >
152:                   <Icon
153:                     :name="item.icon"
154:                     size="20px"
155:                     class="mr-3 flex-shrink-0"
156:                   />
157:                   <span v-if="isMobile || isSidebarOpen">{{ item.label }}</span>
158:                 </NuxtLink>
159:               </li>
160:             </ul>
161:           </div>
162:         </nav>
163:       </div>
164:     </div>
165:   </div>
166: </template>
167: 
168: <style>
169: .transition-transform {
170:   transition-property: transform, width, height;
171: }
172: </style>
```

## File: layers/base/components/SocialBlock.vue
```vue
 1: <script setup lang="ts">
 2: interface Socials {
 3:   [key: string]: string
 4: }
 5: 
 6: const props = defineProps({
 7:   socials: {
 8:     type: Object as PropType<Socials>,
 9:     required: true,
10:   },
11:   size: {
12:     type: String,
13:     default: '24px',
14:   },
15: })
16: 
17: const socialIcon = (platform: string) => {
18:   switch (platform) {
19:     case 'linkedin':
20:       return 'mdi:linkedin'
21:     case 'youtube':
22:       return 'mdi:youtube'
23:     case 'instagram':
24:       return 'mdi:instagram'
25:     case 'facebook':
26:       return 'mdi:facebook'
27:     case 'twitter':
28:       return 'mdi:twitter'
29:     default:
30:       return ''
31:   }
32: }
33: 
34: const formattedSocials = computed(() => {
35:   if (!props.socials) return []
36:   return Object.entries(props.socials).map(([platform, url]) => {
37:     return {
38:       platform: platform.split('_')[0],
39:       url,
40:       icon: socialIcon(platform.split('_')[0]),
41:     }
42:   })
43: })
44: </script>
45: 
46: <template>
47:   <div
48:     v-if="formattedSocials.length > 0"
49:     class="flex gap-2"
50:   >
51:     <a
52:       v-for="social in formattedSocials"
53:       :key="`${social.platform}-icon`"
54:       class="flex cursor-pointer items-center"
55:       target="_blank"
56:       :href="social.url"
57:     >
58:       <Icon
59:         :name="social.icon"
60:         :size="size"
61:       />
62:     </a>
63:   </div>
64: </template>
65: 
66: <style scoped></style>
```

## File: layers/base/components/TabView.vue
```vue
 1: <script setup lang="ts">
 2: interface Tab {
 3:   title: string
 4:   slotName: string
 5:   value: string
 6: }
 7: 
 8: defineProps<{
 9:   tabs: Tab[]
10: }>()
11: </script>
12: 
13: <template>
14:   <PrimeTabs
15:     value="0"
16:     class="h-full"
17:     scrollable
18:     :pt="{
19:       root: 'w-full h-full',
20:     }"
21:     :pt-options="{ mergeSections: true }"
22:   >
23:     <PrimeTabList
24:       :pt="{
25:         root: 'gap-4 sticky top-0 left-0 z-50 flex text-nowrap flex-grow w-full overflow-scroll bg-black no-scrollbar border-b border-color',
26:       }"
27:       :pt-options="{ mergeSections: true, mergeProps: true }"
28:     >
29:       <PrimeTab
30:         v-for="tab in tabs"
31:         :key="tab.title"
32:         :value="tab.value"
33:         :pt="{
34:           root: ({ context }) => ({
35:             class: [
36:               'text-nowrap px-6 py-4 border-x border-color h-full',
37:               { 'bg-primary-900': context.active },
38:             ],
39:           }),
40:         }"
41:         :pt-options="{ mergeSections: true, mergeProps: true }"
42:       >
43:         {{ tab.title }}
44:       </PrimeTab>
45:     </PrimeTabList>
46:     <PrimeTabPanel
47:       v-for="tab in tabs"
48:       :key="`tab-index-${tab.title}`"
49:       :value="tab.value"
50:       :pt="{
51:         root: 'overflow-scroll h-full',
52:       }"
53:       :pt-options="{ mergeProps: true, mergeSections: true }"
54:     >
55:       <slot :name="tab.slotName" />
56:     </PrimeTabPanel>
57:   </PrimeTabs>
58: </template>
59: 
60: <style></style>
```

## File: layers/base/components/YT.client.vue
```vue
 1: <template>
 2:   <div id="player"></div>
 3: </template>
 4: 
 5: <script setup lang="ts">
 6: const player = ref(null)
 7: 
 8: onMounted(() => {
 9:   // Load the YouTube IFrame API dynamically if it's not already loaded
10:   if (!window.YT) {
11:     // Check if YT object is already present
12:     const tag = document.createElement('script')
13:     tag.src = 'https://www.youtube.com/iframe_api'
14:     const firstScriptTag = document.getElementsByTagName('script')[0]
15:     firstScriptTag.parentNode.insertBefore(tag, firstScriptTag)
16: 
17:     // Define the callback globally to initialize player when API is ready
18:     window.onYouTubeIframeAPIReady = initializePlayer
19:   } else {
20:     // Initialize the player immediately if YT is already loaded
21:     initializePlayer()
22:   }
23: })
24: 
25: function initializePlayer() {
26:   // Make sure the YT object and YT.Player are defined
27:   if (typeof YT !== 'undefined' && YT.Player) {
28:     player.value = new YT.Player('player', {
29:       // Ensure the element ID matches your template
30:       height: '390',
31:       width: '640',
32:       listType: 'user_uploads',
33:       list: 'Fireship', // Make sure 'Fireship' is a correct videoId or replace it with a valid one
34:       events: {
35:         onReady: onPlayerReady,
36:       },
37:     })
38:   }
39: }
40: 
41: function onPlayerReady(event) {
42:   event.target.playVideo()
43: }
44: 
45: onBeforeUnmount(() => {
46:   if (player.value) {
47:     player.value.destroy()
48:   }
49: })
50: </script>
```

## File: layers/base/composables/utils/arrays.ts
```typescript
1: export const removeDuplicates = <T>(arr: T[]): T[] => [...new Set(arr)]
2: 
3: export const sortBy = <T, K extends keyof T>(arr: T[], key: K): T[] =>
4:   arr.sort((a, b) => (a[key] > b[key] ? 1 : a[key] < b[key] ? -1 : 0))
```

## File: layers/base/composables/utils/hasValueChanged.ts
```typescript
 1: export function deepEqual(obj1: any, obj2: any): boolean {
 2:   if (obj1 === obj2) {
 3:     return true
 4:   }
 5: 
 6:   if (typeof obj1 !== 'object' || typeof obj2 !== 'object' || obj1 === null || obj2 === null) {
 7:     return false
 8:   }
 9: 
10:   if (Array.isArray(obj1) && Array.isArray(obj2)) {
11:     if (obj1.length !== obj2.length) {
12:       return false
13:     }
14:     for (let i = 0; i < obj1.length; i++) {
15:       if (!deepEqual(obj1[i], obj2[i])) {
16:         return false
17:       }
18:     }
19:     return true
20:   }
21: 
22:   if (Array.isArray(obj1) || Array.isArray(obj2)) {
23:     return false // One is an array, the other is not
24:   }
25: 
26:   const keys1 = Object.keys(obj1)
27:   const keys2 = Object.keys(obj2)
28: 
29:   if (keys1.length !== keys2.length) {
30:     return false
31:   }
32: 
33:   for (const key of keys1) {
34:     if (!keys2.includes(key) || !deepEqual(obj1[key], obj2[key])) {
35:       return false
36:     }
37:   }
38: 
39:   return true
40: }
41: 
42: export function hasValueChanged(newValue: any, currentValue: any): boolean {
43:   if (
44:     typeof newValue === 'string'
45:     || typeof newValue === 'boolean'
46:     || typeof newValue === 'number'
47:     || newValue === null
48:   ) {
49:     return newValue !== currentValue
50:   }
51: 
52:   if (Array.isArray(newValue) || typeof newValue === 'object') {
53:     return !deepEqual(newValue, currentValue)
54:   }
55: 
56:   return newValue !== currentValue
57: }
58: 
59: interface UpdateData {
60:   [key: string]: any
61: }
62: 
63: interface CleanDataResult {
64:   data: UpdateData
65:   noDataUpdated: boolean
66: }
67: 
68: export function wasRowDataUpdated(newData: UpdateData, previousData: UpdateData): CleanDataResult {
69:   const updatedData: UpdateData = {}
70: 
71:   Object.entries(newData).forEach(([key, value]) => {
72:     if (hasValueChanged(value, previousData[key])) {
73:       updatedData[key] = value
74:     }
75:   })
76: 
77:   return { data: updatedData, noDataUpdated: Object.keys(updatedData).length === 0 }
78: }
```

## File: layers/base/composables/utils/objects.ts
```typescript
1: export const pluck = <T, K extends keyof T>(objs: T[], key: K): T[K][] =>
2:   objs.map((obj) => obj[key])
```

## File: layers/base/composables/utils/strings.ts
```typescript
 1: export const slugify = (str: string): string => {
 2:   str = str.replace(/^\s+|\s+$/g, '')
 3:   str = str.toLowerCase()
 4: 
 5:   const from
 6:     = 'ÁÄÂÀÃÅČÇĆĎÉĚËÈÊẼĔȆÍÌÎÏŇÑÓÖÒÔÕØŘŔŠŤÚŮÜÙÛÝŸŽáäâàãåčçćďéěëèêẽĕȇíìîïňñóöòôõøðřŕšťúůüùûýÿžþÞĐđßÆa·/_,:;'
 7:   const to
 8:     = 'AAAAAACCCDEEEEEEEEIIIINNOOOOOORRSTUUUUUYYZaaaaaacccdeeeeeeeeiiiinnooooooorrstuuuuuyyzbBDdBAa------'
 9:   for (let i = 0, l = from.length; i < l; i++) {
10:     str = str.replace(new RegExp(from.charAt(i), 'g'), to.charAt(i))
11:   }
12: 
13:   str = str
14:     .replace(/[^a-z0-9 -]/g, '')
15:     .replace(/\s+/g, '-')
16:     .replace(/-+/g, '-')
17:   return str
18: }
19: 
20: export function upperCaseFirstLetter(str: string): string {
21:   const firstLetter = str.slice(0, 1)
22:   return firstLetter.toUpperCase() + str.substring(1)
23: }
24: 
25: export const stringIsNull = (value: any): boolean =>
26:   value === null || value === undefined || value === '' || value.length === 0
```

## File: layers/base/composables/utils/time.ts
```typescript
 1: export function toDateObject(inputDate = '2022-03-01T10:30:00-05:00') {
 2:   // !todo - add support for internationalization
 3:   // !todo - add support for dynamic length
 4:   const length = 'short'
 5:   // convert date to local time
 6:   const date = new Date(inputDate.toLocaleString())
 7: 
 8:   const formattedDate = new Intl.DateTimeFormat('en-US', {
 9:     weekday: length,
10:     year: 'numeric',
11:     month: length,
12:     day: 'numeric',
13:     hour: 'numeric',
14:     minute: 'numeric',
15:     timeZoneName: length,
16:   }).format(date)
17: 
18:   const dateArray = formattedDate.split(', ')
19: 
20:   return {
21:     weekday: dateArray[0],
22:     month: dateArray[1].split(' ')[0],
23:     day: dateArray[1].split(' ')[1],
24:     time: dateArray[3].split(' ')[0],
25:     ampm: dateArray[3].split(' ')[1],
26:     timezone: dateArray[3].split(' ')[2],
27:     year: dateArray[2],
28:   }
29: }
30: 
31: export function lastSeen(lastSeenTimestamp: string): string {
32:   const now = new Date()
33:   const lastSeen = new Date(lastSeenTimestamp)
34:   const secondsSinceLastSeen = Math.round((now.getTime() - lastSeen.getTime()) / 1000)
35: 
36:   if (secondsSinceLastSeen < 60) {
37:     return `${secondsSinceLastSeen} second${secondsSinceLastSeen === 1 ? '' : 's'} ago`
38:   }
39: 
40:   const minutesSinceLastSeen = Math.round(secondsSinceLastSeen / 60)
41: 
42:   if (minutesSinceLastSeen < 60) {
43:     return `${minutesSinceLastSeen} minute${minutesSinceLastSeen === 1 ? '' : 's'} ago`
44:   }
45: 
46:   const hoursSinceLastSeen = Math.round(minutesSinceLastSeen / 60)
47: 
48:   if (hoursSinceLastSeen < 24) {
49:     return `${hoursSinceLastSeen} hour${hoursSinceLastSeen === 1 ? '' : 's'} ago`
50:   }
51: 
52:   const daysSinceLastSeen = Math.round(hoursSinceLastSeen / 24)
53:   return `${daysSinceLastSeen} day${daysSinceLastSeen === 1 ? '' : 's'} ago`
54: }
```

## File: layers/base/composables/ab-test.ts
```typescript
 1: import type { DefineComponent } from 'vue'
 2: 
 3: export enum TestGoal {
 4:   SignUp = 'sign_up',
 5:   Purchase = 'purchase',
 6:   FeatureUsage = 'feature_usage',
 7:   TimeOnPage = 'time_on_page',
 8:   ClickThroughRate = 'click_through_rate',
 9: }
10: 
11: interface ABTestVariant<T> {
12:   name: string
13:   value: T
14: }
15: 
16: interface ABTestConfig<T> {
17:   experimentName: string
18:   variants: ABTestVariant<T>[]
19:   defaultVariant: ABTestVariant<T>
20:   goals: TestGoal[]
21: }
22: 
23: export function useABTest<T>({ experimentName, variants, defaultVariant, goals }: ABTestConfig<T>) {
24:   const { $posthog } = useNuxtApp()
25: 
26:   const selectedVariant = ref<ABTestVariant<T>>(defaultVariant)
27: 
28:   // Use PostHog's experiment feature to get the variant
29:   const variantName = $posthog.getFeatureFlag(experimentName)
30:   selectedVariant.value = variants.find((v) => v.name === variantName) || defaultVariant
31: 
32:   // Capture experiment exposure
33:   $posthog.capture('$experiment_started', {
34:     experiment: experimentName,
35:     variant: selectedVariant.value.name,
36:     goals: goals,
37:   })
38: 
39:   const value = computed(() => selectedVariant.value.value)
40: 
41:   // Function to track goal completion
42:   const trackGoal = (goal: TestGoal, properties: Record<string, any> = {}) => {
43:     $posthog.capture(goal, {
44:       ...properties,
45:       $experiment_name: experimentName,
46:       $variant: selectedVariant.value.name,
47:     })
48:   }
49: 
50:   return {
51:     variant: selectedVariant,
52:     value,
53:     trackGoal,
54:   }
55: }
56: 
57: // Helper function for component-based A/B tests
58: type ComponentVariant = ABTestVariant<DefineComponent<any, any, any>>
59: 
60: export function useComponentABTest(config: ABTestConfig<DefineComponent<any, any, any>>) {
61:   const { variant, trackGoal } = useABTest(config)
62: 
63:   const TestComponent = computed(() => ({
64:     render() {
65:       return h(variant.value.value.component)
66:     },
67:   }))
68: 
69:   return {
70:     TestComponent,
71:     trackGoal,
72:   }
73: }
```

## File: layers/base/composables/analytics.ts
```typescript
  1: import { ref, onMounted, onUnmounted } from 'vue'
  2: import { useRoute } from 'vue-router'
  3: 
  4: export enum UserAcquisitionMetric {
  5:   SignUpConversion = 'sign_up_conversion',
  6:   DemoRequest = 'demo_request',
  7:   ContactFormSubmission = 'contact_form_submission',
  8:   FeaturePageEngagement = 'feature_page_engagement',
  9:   BlogTraffic = 'blog_traffic',
 10: }
 11: 
 12: export enum OnboardingMetric {
 13:   StartRate = 'start_rate',
 14:   StepCompletion = 'step_completion',
 15:   DropOff = 'drop_off',
 16:   CompletionTime = 'completion_time',
 17: }
 18: 
 19: export enum UserEngagementMetric {
 20:   SessionDuration = 'session_duration',
 21:   ActionsPerSession = 'actions_per_session',
 22:   VisitFrequency = 'visit_frequency',
 23:   FeatureAdoption = 'feature_adoption',
 24: }
 25: 
 26: export enum ContentPerformanceMetric {
 27:   ArticleView = 'article_view',
 28:   ReadTime = 'read_time',
 29:   Share = 'share',
 30:   Like = 'like',
 31:   Comment = 'comment',
 32: }
 33: 
 34: export enum JobMarketMetric {
 35:   JobListing = 'job_listing',
 36:   JobView = 'job_view',
 37:   JobApplication = 'job_application',
 38:   CompanyProfileCreation = 'company_profile_creation',
 39:   CompanyFollow = 'company_follow',
 40: }
 41: 
 42: export enum TechnicalPerformanceMetric {
 43:   PageLoadTime = 'page_load_time',
 44:   APIResponseTime = 'api_response_time',
 45:   ErrorRate = 'error_rate',
 46:   Uptime = 'uptime',
 47: }
 48: 
 49: export type ContentType = 'blog_post' | 'news_article' | 'company_profile' | 'job_listing'
 50: 
 51: export type ErrorType = 'javascript_error' | 'api_error' | '404_error'
 52: 
 53: export interface AnalyticsEventProperties {
 54:   [key: string]: any
 55: }
 56: 
 57: export function useAnalytics() {
 58:   const { $posthog } = useNuxtApp()
 59:   const route = useRoute()
 60:   const pageEnterTime = ref(Date.now())
 61: 
 62:   const trackEvent = (eventName: string, properties?: AnalyticsEventProperties) => {
 63:     $posthog.capture(eventName, properties)
 64:   }
 65: 
 66:   const trackPageView = (properties?: AnalyticsEventProperties) => {
 67:     const timeSpent = Date.now() - pageEnterTime.value
 68:     $posthog.capture('$pageview', {
 69:       path: route.path,
 70:       title: document.title,
 71:       timeSpent,
 72:       ...properties,
 73:     })
 74:     pageEnterTime.value = Date.now()
 75:   }
 76: 
 77:   const identifyUser = (userId: string, properties?: AnalyticsEventProperties) => {
 78:     $posthog.identify(userId, properties)
 79:   }
 80: 
 81:   const trackError = (errorType: ErrorType, errorDetails: string, componentName?: string) => {
 82:     $posthog.capture('Error Occurred', {
 83:       errorType,
 84:       errorDetails,
 85:       componentName,
 86:     })
 87:   }
 88: 
 89:   const trackUserAcquisition = (
 90:     metric: UserAcquisitionMetric,
 91:     properties?: AnalyticsEventProperties,
 92:   ) => {
 93:     $posthog.capture(`User Acquisition - ${metric}`, properties)
 94:   }
 95: 
 96:   const trackOnboarding = (metric: OnboardingMetric, properties?: AnalyticsEventProperties) => {
 97:     $posthog.capture(`Onboarding - ${metric}`, properties)
 98:   }
 99: 
100:   const trackUserEngagement = (
101:     metric: UserEngagementMetric,
102:     properties?: AnalyticsEventProperties,
103:   ) => {
104:     $posthog.capture(`User Engagement - ${metric}`, properties)
105:   }
106: 
107:   const trackContentPerformance = (
108:     metric: ContentPerformanceMetric,
109:     contentType: ContentType,
110:     properties?: AnalyticsEventProperties,
111:   ) => {
112:     $posthog.capture(`Content Performance - ${contentType} - ${metric}`, properties)
113:   }
114: 
115:   const trackJobMarketActivity = (
116:     metric: JobMarketMetric,
117:     properties?: AnalyticsEventProperties,
118:   ) => {
119:     $posthog.capture(`Job Market - ${metric}`, properties)
120:   }
121: 
122:   const trackTechnicalPerformance = (
123:     metric: TechnicalPerformanceMetric,
124:     value: number,
125:     properties?: AnalyticsEventProperties,
126:   ) => {
127:     $posthog.capture(`Technical Performance - ${metric}`, { value, ...properties })
128:   }
129: 
130:   // Session tracking
131:   onMounted(() => {
132:     trackPageView()
133:     $posthog.capture('Session Started')
134:   })
135: 
136:   onUnmounted(() => {
137:     trackPageView()
138:     $posthog.capture('Session Ended', {
139:       sessionDuration: Date.now() - pageEnterTime.value,
140:     })
141:   })
142: 
143:   return {
144:     trackEvent,
145:     trackPageView,
146:     identifyUser,
147:     trackUserAcquisition,
148:     trackOnboarding,
149:     trackUserEngagement,
150:     trackContentPerformance,
151:     trackJobMarketActivity,
152:     trackTechnicalPerformance,
153:     trackError,
154:   }
155: }
156: 
157: // import {
158: //   UserAcquisitionMetric,
159: //   OnboardingMetric,
160: //   UserEngagementMetric,
161: //   ContentPerformanceMetric,
162: //   JobMarketMetric,
163: //   TechnicalPerformanceMetric,
164: //   ContentType,
165: //   ErrorType
166: // } from '~/types/analytics'
167: 
168: // const {
169: //   trackUserAcquisition,
170: //   trackOnboarding,
171: //   trackUserEngagement,
172: //   trackContentPerformance,
173: //   trackJobMarketActivity,
174: //   trackTechnicalPerformance,
175: //   trackError
176: // } = useAnalytics()
177: 
178: // // Track a sign-up conversion
179: // trackUserAcquisition(UserAcquisitionMetric.SignUpConversion, { source: 'organic' })
180: 
181: // // Track an onboarding step completion
182: // trackOnboarding(OnboardingMetric.StepCompletion, { step: 'personal_info', timeSpent: 120 })
183: 
184: // // Track a feature adoption
185: // trackUserEngagement(UserEngagementMetric.FeatureAdoption, { feature: 'job_search' })
186: 
187: // // Track a blog post share
188: // trackContentPerformance(ContentPerformanceMetric.Share, 'blog_post', { postId: '123', platform: 'twitter' })
189: 
190: // // Track a job application
191: // trackJobMarketActivity(JobMarketMetric.JobApplication, { jobId: '456', companyId: '789' })
192: 
193: // // Track page load time
194: // trackTechnicalPerformance(TechnicalPerformanceMetric.PageLoadTime, performance.now())
195: 
196: // // Track an error
197: // trackError(ErrorType.APIError, 'Failed to fetch job listings', 'JobSearchComponent')
```

## File: layers/base/composables/glass-card.ts
```typescript
  1: interface GlassCardProps {
  2:   color: string
  3:   bgOpacity: number
  4:   gradientOpacity: number
  5:   blurIntensity: string
  6:   disableHover: boolean
  7:   padding: string
  8:   loading: boolean
  9:   ariaLabel: string
 10: }
 11: 
 12: const cardStates = reactive<Record<string, any>>({})
 13: 
 14: export function useGlassCard(props: GlassCardProps, uniqueId: string) {
 15:   if (!cardStates[uniqueId]) {
 16:     cardStates[uniqueId] = {
 17:       tiltFactor: 0,
 18:       mouseX: 0,
 19:       mouseY: 0,
 20:       isOutside: true,
 21:       cardWidth: 0,
 22:       cardHeight: 0,
 23:     }
 24:   }
 25: 
 26:   const state = cardStates[uniqueId]
 27: 
 28:   const handleMouseMove = (event: MouseEvent) => {
 29:     const cardElement = document.getElementById(uniqueId)?.querySelector('.glass-card')
 30:     if (!cardElement) return
 31: 
 32:     const cardRect = cardElement.getBoundingClientRect()
 33: 
 34:     state.cardWidth = cardRect.width
 35:     state.cardHeight = cardRect.height
 36: 
 37:     const gravityArea = 100 // pixels around the card
 38:     const x = event.clientX - cardRect.left
 39:     const y = event.clientY - cardRect.top
 40: 
 41:     // Check if the mouse is within the gravity field
 42:     if (
 43:       x >= -gravityArea &&
 44:       x <= cardRect.width + gravityArea &&
 45:       y >= -gravityArea &&
 46:       y <= cardRect.height + gravityArea
 47:     ) {
 48:       state.mouseX = x
 49:       state.mouseY = y
 50:       state.isOutside = false
 51: 
 52:       // Calculate distance from the edge of the card
 53:       const distanceX = Math.max(0, -x, x - cardRect.width)
 54:       const distanceY = Math.max(0, -y, y - cardRect.height)
 55:       const distance = Math.sqrt(distanceX * distanceX + distanceY * distanceY)
 56: 
 57:       // Calculate tilt factor
 58:       if (x >= 0 && x <= cardRect.width && y >= 0 && y <= cardRect.height) {
 59:         state.tiltFactor = 1 // Cursor is directly over the card
 60:       } else {
 61:         // Smooth transition in the gravity area
 62:         state.tiltFactor = Math.max(0, 1 - distance / gravityArea)
 63:       }
 64:     } else {
 65:       state.tiltFactor = 0
 66:       state.isOutside = true
 67:     }
 68:   }
 69: 
 70:   const handleMouseLeave = () => {
 71:     state.tiltFactor = 0
 72:     state.isOutside = true
 73:   }
 74: 
 75:   const cardStyle = computed(() => {
 76:     if (state.isOutside) return {}
 77: 
 78:     const maxTilt = 4 // maximum tilt in degrees
 79: 
 80:     // Use cardWidth and cardHeight from state instead of getting them from cardRef
 81:     const centerX = state.cardWidth / 2
 82:     const centerY = state.cardHeight / 2
 83: 
 84:     const tiltY = ((state.mouseX - centerX) / centerX) * maxTilt * state.tiltFactor
 85:     const tiltX = ((centerY - state.mouseY) / centerY) * maxTilt * state.tiltFactor
 86: 
 87:     return {
 88:       transform: `perspective(1000px) rotateX(${tiltX}deg) rotateY(${tiltY}deg)`,
 89:       transition: state.isOutside ? 'transform 0.3s ease-out' : 'none',
 90:     }
 91:   })
 92: 
 93:   const spotlightColor = computed(() => {
 94:     const hue = (state.mouseX / state.cardWidth) * 360
 95:     return `hsl(${hue}, 100%, 70%)`
 96:   })
 97: 
 98:   const spotlightStyle = computed(() => {
 99:     if (state.isOutside) return { opacity: 0 }
100: 
101:     const spotlightSize = 300 // Fixed 300px radius
102:     const opacity = 0.07 + state.tiltFactor * 0.08
103: 
104:     return {
105:       background: `
106:       radial-gradient(circle ${spotlightSize}px at ${state.mouseX}px ${state.mouseY}px, 
107:       ${spotlightColor.value}, 
108:       transparent 70%),
109:       radial-gradient(circle ${spotlightSize * 0.8}px at ${state.mouseX}px ${state.mouseY}px, 
110:       ${spotlightColor.value}, 
111:       transparent 70%)
112:     `,
113:       opacity: opacity,
114:       transition: 'opacity 0.3s ease-out',
115:       mixBlendMode: 'soft-light',
116:     }
117:   })
118: 
119:   const bgClasses = computed(() => [
120:     `bg-${props.color}-950/${props.bgOpacity}`,
121:     `hover:bg-${props.color}-900/${props.bgOpacity + 10}`,
122:   ])
123: 
124:   const borderClasses = computed(() => [
125:     'border',
126:     'border-color',
127:     `hover:border-${props.color}-400/40`,
128:   ])
129: 
130:   const textClasses = computed(() => [`text-${props.color}-100`])
131: 
132:   const gradientClasses = computed(() => [
133:     `from-${props.color}-100/${props.gradientOpacity}`,
134:     `to-${props.color}-500/${props.gradientOpacity}`,
135:   ])
136: 
137:   const hoverClasses = computed(() =>
138:     props.disableHover
139:       ? []
140:       : ['hover:shadow-2xl', `hover:bg-${props.color}-800/${props.bgOpacity + 10}`],
141:   )
142: 
143:   return {
144:     handleMouseMove,
145:     handleMouseLeave,
146:     cardStyle,
147:     spotlightStyle,
148:     bgClasses,
149:     borderClasses,
150:     textClasses,
151:     gradientClasses,
152:     hoverClasses,
153:   }
154: }
```

## File: layers/base/composables/metrics.ts
```typescript
 1: function roundToNDecimalPlaces(value: number, n: number): number {
 2:   return Number(value.toFixed(n))
 3: }
 4: 
 5: function calculateMedian(arr: number[]): number {
 6:   const sorted = arr.slice().sort((a, b) => a - b)
 7:   const mid = Math.floor(sorted.length / 2)
 8:   return sorted.length % 2 !== 0 ? sorted[mid] : (sorted[mid - 1] + sorted[mid]) / 2
 9: }
10: 
11: function calculateStandardDeviation(valuesArray: number[]): number {
12:   const mean = valuesArray.reduce((a, b) => a + b) / valuesArray.length
13:   return Math.sqrt(
14:     valuesArray.map((x) => Math.pow(x - mean, 2)).reduce((a, b) => a + b) / valuesArray.length,
15:   )
16: }
17: 
18: function calculateMean(arr: number[]): number {
19:   return arr.reduce((a, b) => a + b) / arr.length
20: }
21: 
22: function calculateVariance(arr: number[]): number {
23:   const mean = calculateMean(arr)
24:   return arr.reduce((sum, value) => sum + Math.pow(value - mean, 2), 0) / arr.length
25: }
26: 
27: function calculateRange(arr: number[]): number {
28:   return Math.max(...arr) - Math.min(...arr)
29: }
30: 
31: function calculateSum(arr: number[]): number {
32:   return arr.reduce((a, b) => a + b, 0)
33: }
34: 
35: function calculateMode(arr: number[]): number | number[] {
36:   const frequency: { [key: number]: number } = {}
37:   let maxFreq = 0
38:   let modes: number[] = []
39: 
40:   arr.forEach((value) => {
41:     frequency[value] = (frequency[value] || 0) + 1
42:     if (frequency[value] > maxFreq) {
43:       maxFreq = frequency[value]
44:       modes = [value]
45:     } else if (frequency[value] === maxFreq) {
46:       modes.push(value)
47:     }
48:   })
49: 
50:   return modes.length === 1 ? modes[0] : modes
51: }
52: 
53: function calculateMin(arr: number[]): number {
54:   return Math.min(...arr)
55: }
56: 
57: function calculateMax(arr: number[]): number {
58:   return Math.max(...arr)
59: }
60: 
61: function calculatePercentile(arr: number[], percentile: number): number {
62:   if (percentile < 0 || percentile > 100) {
63:     throw new Error('Percentile must be between 0 and 100')
64:   }
65:   const sorted = arr.slice().sort((a, b) => a - b)
66:   const index = (percentile / 100) * (sorted.length - 1)
67:   const lower = Math.floor(index)
68:   const upper = lower + 1
69:   const weight = index % 1
70: 
71:   if (upper >= sorted.length) {
72:     return sorted[lower]
73:   }
74: 
75:   return sorted[lower] * (1 - weight) + sorted[upper] * weight
76: }
77: 
78: export function useBaseMetrics() {
79:   return {
80:     format: {
81:       roundToN: roundToNDecimalPlaces,
82:     },
83:     calculate: {
84:       median: calculateMedian,
85:       standardDeviation: calculateStandardDeviation,
86:       mean: calculateMean,
87:       variance: calculateVariance,
88:       range: calculateRange,
89:       sum: calculateSum,
90:       mode: calculateMode,
91:       min: calculateMin,
92:       max: calculateMax,
93:       percentile: calculatePercentile,
94:     },
95:   }
96: }
```

## File: layers/base/composables/modal.ts
```typescript
 1: export function useModal() {
 2:   // was used for news modals at one point
 3:   const currentPost = computed(() => news.value[currentIndex.value])
 4:   const nextPost = computed(() => news.value[nextIndex.value])
 5:   const previousPost = computed(() => news.value[previousIndex.value])
 6:   const isModalOpen = ref(false)
 7:   const currentIndex = ref(0)
 8:   const previousIndex = computed(() => (currentIndex.value > 0 ? currentIndex.value - 1 : 0))
 9:   const nextIndex = computed(() =>
10:     currentIndex.value < news.value.length - 1 ? currentIndex.value + 1 : currentIndex.value,
11:   )
12: 
13:   const toggleModal = (postIndex?: number) => {
14:     isModalOpen.value = !isModalOpen.value
15:     if (postIndex !== undefined) {
16:       currentIndex.value = postIndex
17:     }
18:   }
19: 
20:   const next = () => {
21:     if (currentIndex.value < news.value.length - 1) {
22:       currentIndex.value++
23:     }
24:   }
25: 
26:   const previous = () => {
27:     if (currentIndex.value > 0) {
28:       currentIndex.value--
29:     }
30:   }
31: }
```

## File: layers/base/composables/notification.ts
```typescript
 1: import type { useToast } from 'primevue/usetoast'
 2: 
 3: interface BaseNotification {
 4:   summary: string
 5:   message: string
 6: }
 7: 
 8: export function useNotification() {
 9:   const nuxtApp = useNuxtApp()
10:   const getToast: typeof useToast = () => nuxtApp.vueApp.config.globalProperties.$toast
11:   const toast = getToast()
12: 
13:   const success = ({ summary, message }: BaseNotification) => {
14:     toast.add({
15:       severity: 'success',
16:       summary: `Success: ${summary}`,
17:       detail: message,
18:       life: 5000,
19:       closable: true,
20:     })
21:   }
22: 
23:   const error = ({ summary, message }: BaseNotification) => {
24:     toast.add({
25:       severity: 'error',
26:       summary: `Error: ${summary}`,
27:       detail: message,
28:       life: 0,
29:       closable: true,
30:     })
31:   }
32: 
33:   const info = ({ summary, message }: BaseNotification) => {
34:     toast.add({
35:       severity: 'info',
36:       summary: `Info: ${summary}`,
37:       detail: message,
38:       life: 5000,
39:       closable: true,
40:     })
41:   }
42: 
43:   const warn = ({ summary, message }: BaseNotification) => {
44:     toast.add({
45:       severity: 'warn',
46:       summary: `Warning: ${summary}`,
47:       detail: message,
48:       life: 5000,
49:       closable: true,
50:     })
51:   }
52: 
53:   const feature = ({ summary, message }: BaseNotification) => {
54:     toast.add({
55:       severity: 'warn',
56:       group: 'cta',
57:       summary: summary,
58:       detail: message,
59:       life: 0,
60:       closable: true,
61:     })
62:   }
63: 
64:   return {
65:     success,
66:     error,
67:     info,
68:     warn,
69:     feature,
70:   }
71: }
```

## File: layers/base/composables/settings.store.ts
```typescript
 1: type SettingsKey = 'usersStore' | 'storeNews'
 2: 
 3: export const useSettingsStore = defineStore('settingsStore', () => {
 4:   const settings = ref({} as Settings)
 5:   const summaryLevel = ref('beginner' as SummaryLevel)
 6: 
 7:   function toggleSettings(key: SettingsKey) {
 8:     settings.value[key] = !settings.value[key]
 9:   }
10: 
11:   function isSettingsOn(key: SettingsKey) {
12:     return !settings.value[key]
13:   }
14: 
15:   const changeSummaryLevel = (level: 'beginner' | 'intermediate' | 'expert') => {
16:     summaryLevel.value = level
17:   }
18: 
19:   return {
20:     toggleSettings,
21:     isSettingsOn,
22:   }
23: })
24: 
25: if (import.meta.hot) {
26:   import.meta.hot.accept(acceptHMRUpdate(useSettingsStore, import.meta.hot))
27: }
```

## File: layers/base/composables/social.store.ts
```typescript
  1: import { useLogger } from '@ib/logger'
  2: 
  3: export const useSocialStore = defineStore('settingsStore', () => {
  4:   const errors = useBaseError()
  5:   const logger = useLogger('useSocialStore')
  6:   const { fetch } = useBaseFetch()
  7: 
  8:   const youtube = ref({})
  9:   async function getYoutubeAnalytics(channelName: string) {
 10:     logger.info(`getting youtube analytics for ${channelName}`)
 11:     const response = await fetch('/api/social/youtube/analytics', {
 12:       method: 'GET',
 13:       query: {
 14:         channelName,
 15:       },
 16:     })
 17: 
 18:     const data = errors.server({
 19:       response,
 20:       devOnly: false,
 21:       devMessage: 'error getting youtube analytics',
 22:       userMessage: 'something went wrong when getting youtube analytics',
 23:     })
 24: 
 25:     youtube.value = data
 26:   }
 27: 
 28:   const instagram = ref<any>(null)
 29:   async function getInstagramAnalytics(userId: string) {
 30:     const logger = useLogger('getInstagramAnalytics')
 31:     logger.info(`Fetching Instagram analytics for ${userId}`)
 32:     try {
 33:       const response = await $fetch(`/api/social/instagram/analytics?userId=${userId}`, {
 34:         method: 'GET',
 35:       })
 36: 
 37:       const data = errors.server({
 38:         response,
 39:         devOnly: false,
 40:         devMessage: 'Error getting Instagram analytics',
 41:         userMessage: 'Something went wrong when getting Instagram analytics',
 42:       })
 43: 
 44:       instagram.value = data
 45:     } catch (error) {
 46:       errors.client({
 47:         error,
 48:         devOnly: false,
 49:         devMessage: 'Error getting Instagram analytics',
 50:         userMessage: 'Something went wrong when getting Instagram analytics',
 51:       })
 52:     }
 53:   }
 54: 
 55:   const linkedin = ref<any>(null)
 56:   async function getLinkedInAnalytics(postId: string) {
 57:     const logger = useLogger('getLinkedInAnalytics')
 58:     logger.info(`Fetching LinkedIn analytics for post ${postId}`)
 59:     try {
 60:       const response = await $fetch(`/api/social/linkedin/analytics?postId=${postId}`, {
 61:         method: 'GET',
 62:       })
 63: 
 64:       const data = errors.server({
 65:         response,
 66:         devOnly: false,
 67:         devMessage: 'Error getting LinkedIn analytics',
 68:         userMessage: 'Something went wrong when getting LinkedIn analytics',
 69:       })
 70: 
 71:       linkedin.value = data
 72:     } catch (error) {
 73:       errors.client({
 74:         error,
 75:         devOnly: false,
 76:         devMessage: 'Error getting LinkedIn analytics',
 77:         userMessage: 'Something went wrong when getting LinkedIn analytics',
 78:       })
 79:     }
 80:   }
 81: 
 82:   const twitter = ref<any>(null)
 83:   async function getTwitterAnalytics(postId: string) {
 84:     const logger = useLogger('getTwitterAnalytics')
 85:     logger.info(`Fetching Twitter analytics for post ${postId}`)
 86:     try {
 87:       const response = await fetch(`/api/social/twitter/analytics?postId=${postId}`, {
 88:         method: 'GET',
 89:       })
 90: 
 91:       const data = errors.server({
 92:         response,
 93:         devOnly: false,
 94:         devMessage: 'Error getting Twitter analytics',
 95:         userMessage: 'Something went wrong when getting Twitter analytics',
 96:       })
 97: 
 98:       twitter.value = data
 99:     } catch (error) {
100:       errors.client({
101:         error,
102:         devOnly: false,
103:         devMessage: 'Error getting Twitter analytics',
104:         userMessage: 'Something went wrong when getting Twitter analytics',
105:       })
106:     }
107:   }
108: 
109:   return {
110:     youtube,
111:     getYoutubeAnalytics,
112:     //
113:     instagram,
114:     getInstagramAnalytics,
115:     //
116:     linkedin,
117:     getLinkedInAnalytics,
118:     //
119:     twitter,
120:     getTwitterAnalytics,
121:   }
122: })
123: 
124: if (import.meta.hot) {
125:   import.meta.hot.accept(acceptHMRUpdate(useSocialStore, import.meta.hot))
126: }
```

## File: layers/base/composables/useMediaQuery.ts
```typescript
 1: // composables/useMediaQuery.ts
 2: export const useMediaQuery = (query: string) => {
 3:   const matches = ref(false)
 4: 
 5:   if (import.meta.client) {
 6:     const mediaQuery = window.matchMedia(query)
 7:     matches.value = mediaQuery.matches
 8: 
 9:     const handler = (event: MediaQueryListEvent) => {
10:       matches.value = event.matches
11:     }
12: 
13:     // Watch for changes
14:     mediaQuery.addEventListener('change', handler)
15: 
16:     // Cleanup
17:     onUnmounted(() => {
18:       mediaQuery.removeEventListener('change', handler)
19:     })
20:   }
21: 
22:   return matches
23: }
```

## File: layers/base/composables/useNavigation.ts
```typescript
 1: // composables/useNavigation.ts
 2: export const useNavigation = () => {
 3:   const isSidebarOpen = useState('nav-sidebar-open', () => true)
 4:   const isMobileSidebarOpen = useState('nav-mobile-sidebar-open', () => false)
 5: 
 6:   // Create our own media query composable
 7:   const isMobile = useMediaQuery('(max-width: 768px)')
 8: 
 9:   // Close mobile nav on route changes
10:   const route = useRoute()
11:   
12:   watch(
13:     () => route.path,
14:     () => {
15:       isMobileSidebarOpen.value = false
16:     },
17:   )
18: 
19:   return {
20:     isSidebarOpen,
21:     isMobileSidebarOpen,
22:     isMobile,
23:   }
24: }
```

## File: layers/base/composables/utils.ts
```typescript
 1: import { wasRowDataUpdated } from './utils/hasValueChanged'
 2: import * as time from './utils/time'
 3: import * as strings from './utils/strings'
 4: import * as objects from './utils/objects'
 5: import * as arrays from './utils/arrays'
 6: 
 7: export function useUtils() {
 8:   return {
 9:     wasRowDataUpdated,
10:     time: {
11:       format: time.toDateObject,
12:       lastSeen: time.lastSeen,
13:     },
14:     strings: {
15:       firstUpper: strings.upperCaseFirstLetter,
16:       slugify: strings.slugify,
17:     },
18:     arrays: {
19:       removeDuplicates: arrays.removeDuplicates,
20:       sortBy: arrays.sortBy,
21:     },
22:     objects: {
23:       pluck: objects.pluck,
24:     },
25:   }
26: }
```

## File: layers/base/plugins/error-handler.ts
```typescript
 1: import { useErrorHandler } from '@ib/logger'
 2: 
 3: export default defineNuxtPlugin((nuxtApp) => {
 4:   const { handleError } = useErrorHandler()
 5: 
 6:   // Set up global error handlers
 7:   if (import.meta.client) {
 8:     window.addEventListener('error', (event) => {
 9:       handleError(event.error, 'Uncaught Exception')
10:     })
11: 
12:     window.addEventListener('unhandledrejection', (event) => {
13:       handleError(event.reason, 'Unhandled Promise Rejection')
14:     })
15:   }
16: })
```

## File: layers/base/plugins/posthog.client.ts
```typescript
 1: import posthog from 'posthog-js'
 2: 
 3: export default defineNuxtPlugin((nuxtApp) => {
 4:   const env = nuxtApp.$config.public
 5:   const env2 = useRuntimeConfig().public
 6: 
 7:   console.log('ENV Key:', env, env2)
 8:   console.log('NODE_ENV:', import.meta.env.NODE_ENV)
 9: 
10:   const posthogKey = env.posthogKey || env2.posthogKey
11:   const posthogUrl = env.posthogUrl || env2.posthogUrl
12: 
13:   // Initialize PostHog
14:   posthog.init(posthogKey, {
15:     api_host: posthogUrl,
16:     autocapture: false, // Disable autocapture as we'll handle events manually
17:     capture_pageview: false, // We'll capture pageviews manually for more control
18:     persistence: 'localStorage+cookie',
19:     // bootstrap: {
20:     //   distinctID: runtimeConfig.public.posthogDistinctId // Set this in your runtime config if you have a user ID
21:     // },
22:     loaded: (posthog) => {
23:       // This function is called once PostHog is loaded
24:       if (import.meta.env.NODE_ENV === 'development') {
25:         // Log to console in development mode
26:         posthog.debug()
27:       }
28:     },
29:   })
30: 
31:   // Capture page views
32:   nuxtApp.hook('page:finish', () => {
33:     posthog.capture('$pageview')
34:   })
35: 
36:   // Expose PostHog instance and utility functions
37:   return {
38:     provide: {
39:       posthog: {
40:         // Expose the raw PostHog instance
41:         raw: posthog,
42: 
43:         // Utility function to capture events
44:         capture: (eventName: string, properties?: Record<string, any>) => {
45:           posthog.capture(eventName, properties)
46:         },
47: 
48:         // Utility function for A/B testing
49:         getFeatureFlag: (flagName: string, defaultValue?: any) => {
50:           return posthog.getFeatureFlag(flagName, defaultValue)
51:         },
52: 
53:         // Utility function to identify users
54:         identify: (distinctId: string, properties?: Record<string, any>) => {
55:           posthog.identify(distinctId, properties)
56:         },
57: 
58:         // Utility function to reset user identity
59:         reset: () => {
60:           posthog.reset()
61:         },
62: 
63:         // Utility function to opt in/out of tracking
64:         optIn: () => {
65:           posthog.opt_in_capturing()
66:         },
67:         optOut: () => {
68:           posthog.opt_out_capturing()
69:         },
70: 
71:         // Utility function for registering super properties
72:         register: (properties: Record<string, any>) => {
73:           posthog.register(properties)
74:         },
75: 
76:         // Utility function for registering one-time super properties
77:         registerOnce: (properties: Record<string, any>) => {
78:           posthog.register_once(properties)
79:         },
80:       },
81:     },
82:   }
83: })
```

## File: layers/base/plugins/sentry.client.ts
```typescript
 1: import * as Sentry from '@sentry/vue'
 2: import { defineNuxtPlugin } from '#app'
 3: 
 4: export default defineNuxtPlugin((nuxtApp) => {
 5:   const app = nuxtApp.vueApp
 6:   const router = useRouter()
 7: 
 8:   Sentry.init({
 9:     app,
10:     dsn: 'https://eec364410b024a5a837f60e00d367513@o1175094.ingest.sentry.io/4504389151621120',
11:     integrations: [Sentry.browserTracingIntegration({ router }), Sentry.replayIntegration()],
12:     tracesSampleRate: process.env.NODE_ENV === 'production' ? 0.2 : 1.0,
13:     tracePropagationTargets: ['localhost', /^https:\/\/yourserver\.io\/api/],
14:     replaysSessionSampleRate: 0.1,
15:     replaysOnErrorSampleRate: 1.0,
16:     attachProps: true,
17:     trackComponents: true,
18:   })
19: 
20:   // Sentry.setUser(useSupabaseUser())
21:   Sentry.setTag('environment', process.env.NODE_ENV)
22: })
```

## File: layers/base/types/content.ts
```typescript
 1: import { z } from 'zod'
 2: 
 3: export const titleSchema = z.object({
 4:   centered: z.boolean().optional(),
 5:   label: z.string().optional(),
 6:   main: z.string(),
 7:   subtitle: z.string().optional(),
 8: })
 9: 
10: export const faqSchema = z.object({
11:   label: z.string(),
12:   description: z.string(),
13: })
14: 
15: export const imageSchema = z.object({
16:   src: z.string(),
17:   alt: z.string(),
18:   width: z.number().optional(),
19:   height: z.number().optional(),
20: })
21: 
22: export type ImageType = z.infer<typeof imageSchema>
23: export type TitleType = z.infer<typeof titleSchema>
24: export type FaqType = z.infer<typeof faqSchema>
```

## File: layers/base/types/database.ts
```typescript
 1: import type { Tables } from '../../../supabase/schema.gen'
 2: 
 3: export type RowUser = Tables<'user_profiles'>
 4: export type RowUserFollowers = Tables<'user_followers'>
 5: export type RowRole = Tables<'roles'>
 6: export type RowRegisterInterest = Tables<'register_interest'>
 7: 
 8: export type RowCategory = Tables<'categories'>
 9: export type RowTag = Tables<'tags'>
10: 
11: export type RowNews = Tables<'news'>
12: export type RowNewsTag = Tables<'news_tags'>
13: 
14: export type RowEmbedding = Tables<'embeddings'>
15: 
16: export type RowPaper = Tables<'papers'>
17: 
18: type ArrayToUnion<A> = A extends readonly (infer T)[] ? T : never
19: 
20: const userCardKeys = [
21:   'id',
22:   'given_name',
23:   'surname',
24:   'username',
25:   'avatar',
26:   'followed_count',
27:   'followers_count',
28:   'plan',
29: ] as const
30: 
31: export type UserCard = Pick<RowUser, ArrayToUnion<typeof userCardKeys>>
```

## File: layers/base/types/index.ts
```typescript
1: export * from './users'
2: export * from './other-type-file'
```

## File: layers/base/types/users.ts
```typescript
 1: // don't forget to add to this file if you make any changes in the database
 2: import * as z from 'zod'
 3: 
 4: export const LocationSchema = z.object({
 5:   id: z.number(),
 6:   created_at: z.string().optional(),
 7:   city: z.string(),
 8:   country: z.string(),
 9:   state: z.string(),
10:   address: z.string().nullable(),
11:   latitude: z.number().optional().nullable(),
12:   longitude: z.number().optional().nullable(),
13: })
14: 
15: export const UserRoleSchema = z.object({
16:   id: z.number(),
17:   name: z.string().nullable(),
18:   body: z.string().nullable().optional(),
19:   created_at: z.string().optional(),
20:   icon: z.string(),
21: })
22: 
23: export const IdName = z.object({
24:   id: z.number(),
25:   name: z.string(),
26: })
27: 
28: export const UserSkillSchema = z.object({
29:   id: z.number(),
30:   title: z.string().nullable(),
31:   body: z.string().nullable().optional(),
32:   total_endorsements: z.number(),
33:   admin_rating: z.number().nullable(),
34:   avg_rating: z.number().nullable(),
35:   created_at: z.string().optional(),
36: })
37: 
38: export const UserSocialSchema = z.object({
39:   id: z.number(),
40:   url: z.string(),
41:   platform: z.string(),
42:   username: z.string(),
43: })
44: 
45: export const UserBasicSchema = z.object({
46:   id: z.string(),
47:   given_name: z.string(),
48:   surname: z.string().nullable(),
49:   username: z.string().nullable(),
50:   avatar: z.string().nullable(),
51:   introduction: z.string().nullable(),
52:   followers_count: z.number().nullable(),
53:   followed_count: z.number().nullable(),
54:   is_following: z.boolean().nullable(),
55:   role: z.number(),
56: })
57: 
58: export const UserFullSchema = UserBasicSchema.extend({
59:   email: z.string(),
60:   dob: z.string().nullable(),
61:   gender_id: z.number().nullable(),
62:   created_at: z.string(),
63:   updated_at: z.string().nullable(),
64:   quote: z.string().nullable(),
65: })
66: 
67: export const UserRowSchema = z.object({
68:   given_name: z.string(),
69:   email: z.string(),
70:   surname: z.string().nullable(),
71:   username: z.string().nullable(),
72:   avatar: z.string().nullable(),
73:   introduction: z.string().nullable(),
74:   plan: z.string().nullish(),
75:   dob: z.string().nullable(),
76:   quote: z.string().nullable(),
77:   gender_id: z.number().nullable(),
78: })
79: 
80: export const UserRolesSchema = z.array(UserRoleSchema)
81: 
82: export type UserType = z.infer<typeof UserBasicSchema>
83: export type UserFullType = z.infer<typeof UserFullSchema>
84: export type UserRoleType = z.infer<typeof UserRoleSchema>
85: export type UserRowType = z.infer<typeof UserRowSchema>
86: export type UserSocialType = z.infer<typeof UserSocialSchema>
```

## File: layers/base/nuxt.config.ts
```typescript
 1: import { defineNuxtConfig } from 'nuxt/config'
 2: 
 3: export default defineNuxtConfig({
 4:   workspaceDir: '../../',
 5:   srcDir: '.',
 6: 
 7:   icon: {
 8:     serverBundle: {
 9:       collections: ['material-symbols', 'mdi'],
10:     },
11:   },
12: 
13:   eslint: {
14:     checker: true,
15:   },
16: 
17:   image: {
18:     providers: {
19:       supabase: {
20:         provider: '../../layers/base/supabase-provider.ts',
21:         options: {
22:           baseURL: process.env.NUXT_PUBLIC_SUPABASE_URL,
23:         },
24:       },
25:     },
26:     presets: {
27:       original: {
28:         modifiers: {
29:           width: 1920,
30:           height: 1080,
31:         },
32:       },
33:       mobile: {
34:         modifiers: {
35:           width: 768,
36:           height: 1024,
37:         },
38:       },
39:       thumbnail: {
40:         modifiers: {
41:           width: 300,
42:           height: 200,
43:         },
44:       },
45:     },
46:   },
47: 
48:   components: [
49:     {
50:       path: './components',
51:       pathPrefix: false,
52:       prefix: 'IB',
53:       global: true,
54:     },
55:   ],
56: })
```

## File: layers/base/supabase-provider.ts
```typescript
 1: export function getImage(
 2:   src,
 3:   {
 4:     modifiers = { width: null, height: null, format: null },
 5:     baseURL = process.env.NUXT_PUBLIC_SUPABASE_URL,
 6:   } = {},
 7: ) {
 8:   const { width, height, format } = modifiers
 9:   const [_, bucket, sizeName, imageFileName] = src.split('/')
10: 
11:   // Determine target size
12:   let targetSizeName = sizeName
13:   if (width && height) {
14:     if (width <= 300 && height <= 200) {
15:       targetSizeName = 'thumbnail'
16:     } else if (width <= 768 && height <= 1024) {
17:       targetSizeName = 'mobile'
18:     } else {
19:       targetSizeName = 'original'
20:     }
21:   }
22: 
23:   const imageNameWithoutExt = imageFileName.split('.')[0]
24:   const imageFormat = format || imageFileName.split('.')[1] || 'jpg'
25: 
26:   return {
27:     url: `${baseURL}/storage/v1/object/public/${bucket}/${targetSizeName}/${imageNameWithoutExt}.${imageFormat}`,
28:   }
29: }
```

## File: layers/crud/.playground/app.config.ts
```typescript
1: export default defineAppConfig({
2:   myLayer: {
3:     name: 'My amazing Nuxt layer (overwritten)'
4:   }
5: })
```

## File: layers/crud/.playground/nuxt.config.ts
```typescript
1: export default defineNuxtConfig({
2:   extends: ['..'],
3:   modules: ['@nuxt/eslint']
4: })
```

## File: layers/crud/components/Feedback.vue
```vue
  1: <script setup lang="ts">
  2: import { z } from 'zod'
  3: 
  4: const feedbackStore = useFeedbackStore()
  5: 
  6: defineProps({
  7:   cta: {
  8:     type: String,
  9:     required: true,
 10:     default: 'How could we improve?',
 11:   },
 12: })
 13: 
 14: interface FeedbackType {
 15:   name: string
 16:   value: string
 17: }
 18: 
 19: const feedbackTypes = [
 20:   { name: 'Bug Report', value: 'bug_report' },
 21:   { name: 'Feature Request', value: 'feature_request' },
 22:   { name: 'User Interface Issue', value: 'user_interface_issue' },
 23:   { name: 'Performance Issue', value: 'performance_issue' },
 24:   { name: 'Documentation', value: 'documentation' },
 25: ]
 26: 
 27: const route = useRoute()
 28: const { userId } = useCurrentUser()
 29: 
 30: const initialFeedback = () => ({
 31:   user_id: userId,
 32:   page_identifier: route.fullPath,
 33:   feedback_type: null,
 34:   message: '',
 35:   device_info: '',
 36:   content_status: 'new',
 37: })
 38: 
 39: const feedback = ref(initialFeedback())
 40: 
 41: const messagePlaceholder = computed(() => {
 42:   if (!feedback.value.feedback_type) {
 43:     return 'Please select a feedback type first'
 44:   }
 45: 
 46:   const type = feedback.value.feedback_type
 47:   if (!type) return ''
 48: 
 49:   switch (type.value) {
 50:     case 'bug_report':
 51:       return 'Describe the bug in detail...'
 52:     case 'feature_request':
 53:       return 'Describe the feature you would like to see...'
 54:     case 'user_interface_issue':
 55:       return 'What UI issue did you encounter?'
 56:     case 'performance_issue':
 57:       return 'Describe the performance issue...'
 58:     case 'documentation':
 59:       return 'What documentation issue did you find?'
 60:     default:
 61:       return 'Enter your message'
 62:   }
 63: })
 64: 
 65: const isMessageDisabled = computed(() => !feedback.value.feedback_type)
 66: 
 67: const messageLength = z.string().min(10)
 68: 
 69: const isMessageInvalid = computed(() => !messageLength.safeParse(feedback.value.message).success)
 70: 
 71: const resetFeedback = () => {
 72:   feedback.value = initialFeedback()
 73: }
 74: 
 75: const submitFeedback = async () => {
 76:   await feedbackStore.submitFeedback(feedback.value)
 77:   resetFeedback()
 78: }
 79: </script>
 80: 
 81: <template>
 82:   <div class="w-52">
 83:     <h2 class="text-lg mb-4 text-left font-bold">
 84:       {{ cta }}
 85:     </h2>
 86:     <form
 87:       class="w-52 space-y-4"
 88:       @submit.prevent="submitFeedback"
 89:     >
 90:       <PrimeSelect
 91:         v-model="feedback.feedback_type"
 92:         :pt="{ root: 'flex text-left pl-1' }"
 93:         :pt-options="{ mergeProps: true, mergeSections: true }"
 94:         :options="feedbackTypes"
 95:         option-label="name"
 96:         placeholder="Feedback Type"
 97:       />
 98:       <PrimeTextarea
 99:         v-show="feedback.feedback_type"
100:         v-model="feedback.message"
101:         class="w-full"
102:         :rows="5"
103:         :placeholder="messagePlaceholder"
104:         :disabled="isMessageDisabled"
105:         :invalid="isMessageInvalid"
106:       />
107:       <div>
108:         <PrimeButton
109:           v-show="feedback.feedback_type"
110:           class="flex w-full justify-between"
111:           :disabled="isMessageInvalid"
112:           :outlined="isMessageInvalid"
113:           @click="submitFeedback"
114:         >
115:           Submit Feedback
116:           <Icon name="mdi:send" />
117:         </PrimeButton>
118:       </div>
119:     </form>
120:   </div>
121: </template>
122: 
123: <style scoped></style>
```

## File: layers/crud/components/Upload.vue
```vue
 1: <script setup lang="ts">
 2: // const toast = useNotification()
 3: 
 4: const props = defineProps({
 5:   name: {
 6:     type: String,
 7:     required: true,
 8:   },
 9:   url: {
10:     type: String,
11:     required: true,
12:   },
13:   multiple: {
14:     type: Boolean,
15:     default: false,
16:   },
17:   accept: {
18:     type: String,
19:     default: '',
20:   },
21:   maxFileSize: {
22:     type: Number,
23:     default: 1000000,
24:   },
25: })
26: 
27: const onAdvancedUpload = () => {
28:   toast.success({ summary: 'File Uploaded', message: `${props.name} files uploaded` })
29: }
30: </script>
31: 
32: <template>
33:   <PrimeCard>
34:     <template #content>
35:       <PrimeFileUpload
36:         :name="name"
37:         :multiple="multiple"
38:         :accept="accept"
39:         :url="url"
40:         :max-file-size="maxFileSize"
41:         @upload="onAdvancedUpload()"
42:       >
43:         <template #empty>
44:           <p>Drag and drop files to here to upload.</p>
45:         </template>
46:       </PrimeFileUpload>
47:     </template>
48:   </PrimeCard>
49: </template>
```

## File: layers/crud/composables/audit.ts
```typescript
  1: export enum AuditLogLevel {
  2:   INFO = 'INFO',
  3:   WARNING = 'WARNING',
  4:   ERROR = 'ERROR',
  5:   CRITICAL = 'CRITICAL',
  6: }
  7: 
  8: export interface AuditLogEntry {
  9:   userId: string
 10:   action: string
 11:   details: any
 12:   level: AuditLogLevel
 13:   timestamp: string
 14:   ipAddress?: string
 15:   userAgent?: string
 16:   resourceId?: string
 17:   resourceType?: string
 18: }
 19: 
 20: interface AuditLogOptions {
 21:   level?: AuditLogLevel
 22:   resourceId?: string
 23:   resourceType?: string
 24:   skipDB?: boolean
 25: }
 26: 
 27: export function useAuditLog() {
 28:   const supabase = useSupabaseClient()
 29:   const user = useSupabaseUser()
 30:   const config = useRuntimeConfig()
 31: 
 32:   const logEvent = async (action: string, details: any, options: AuditLogOptions = {}) => {
 33:     const userId = user.value?.id || 'anonymous'
 34:     const timestamp = new Date().toISOString()
 35:     const level = options.level || AuditLogLevel.INFO
 36: 
 37:     const logEntry: AuditLogEntry = {
 38:       userId,
 39:       action,
 40:       details,
 41:       level,
 42:       timestamp,
 43:       ipAddress: useRequestHeaders(['x-forwarded-for'])['x-forwarded-for'] || '',
 44:       userAgent: useRequestHeaders(['user-agent'])['user-agent'] || '',
 45:       resourceId: options.resourceId,
 46:       resourceType: options.resourceType,
 47:     }
 48: 
 49:     // Remove any sensitive information from the log entry
 50:     sanitizeLogEntry(logEntry)
 51: 
 52:     // Log to console in development
 53:     if (import.meta.dev) {
 54:       console.log('Audit Log:', logEntry)
 55:     }
 56: 
 57:     if (!options.skipDB) {
 58:       try {
 59:         const { error } = await supabase.from('audit_logs').insert(logEntry)
 60: 
 61:         if (error) {
 62:           console.error('Error logging audit event to database:', error)
 63:         }
 64:       } catch (error) {
 65:         console.error('Error logging audit event to database:', error)
 66:       }
 67:     }
 68: 
 69:     // If configured, send logs to an external service
 70:     if (config.public.EXTERNAL_LOGGING_SERVICE) {
 71:       try {
 72:         await $fetch(config.public.EXTERNAL_LOGGING_SERVICE, {
 73:           method: 'POST',
 74:           body: JSON.stringify(logEntry),
 75:         })
 76:       } catch (error) {
 77:         console.error('Error sending log to external service:', error)
 78:       }
 79:     }
 80:   }
 81: 
 82:   const sanitizeLogEntry = (logEntry: AuditLogEntry) => {
 83:     // Remove sensitive information like passwords, tokens, etc.
 84:     if (logEntry.details && typeof logEntry.details === 'object') {
 85:       const sensitiveFields = ['password', 'token', 'secret', 'credit_card']
 86:       for (const field of sensitiveFields) {
 87:         if (field in logEntry.details) {
 88:           logEntry.details[field] = '[REDACTED]'
 89:         }
 90:       }
 91:     }
 92:   }
 93: 
 94:   const getAuditLogs = async (
 95:     filters: Partial<AuditLogEntry>,
 96:     pagination: { page: number, pageSize: number },
 97:   ) => {
 98:     let query = supabase.from('audit_logs').select('*')
 99: 
100:     // Apply filters
101:     Object.entries(filters).forEach(([key, value]) => {
102:       if (value !== undefined) {
103:         query = query.eq(key, value)
104:       }
105:     })
106: 
107:     // Apply pagination
108:     const { data, error, count } = await query
109:       .range(pagination.page * pagination.pageSize, (pagination.page + 1) * pagination.pageSize - 1)
110:       .order('timestamp', { ascending: false })
111: 
112:     if (error) {
113:       console.error('Error fetching audit logs:', error)
114:       throw error
115:     }
116: 
117:     return { logs: data, totalCount: count }
118:   }
119: 
120:   return {
121:     logEvent,
122:     getAuditLogs,
123:     AuditLogLevel,
124:   }
125: }
```

## File: layers/crud/composables/delete.ts
```typescript
 1: import { useErrorHandler, AppError, ErrorSeverity, ErrorType, useLogger } from '@ib/logger'
 2: import { useRateLimit } from './rate-limit'
 3: import { useHttpHandler } from './http-handler'
 4: import { getOrCreateStore } from './main.store'
 5: 
 6: export function useDeleteData<T extends { id: string | number }>(
 7:   tableName: string,
 8:   options: {
 9:     validateDelete?: (id: string | number) => boolean | Promise<boolean>
10:     refreshRelated?: () => Promise<void>
11:     rateLimitMs?: number
12:     auditLog?: (action: string, details: any) => Promise<void>
13:   } = {},
14: ) {
15:   const { remove } = useHttpHandler()
16:   const { handleError } = useErrorHandler()
17:   const logger = useLogger('useDeleteData')
18:   const store = getOrCreateStore<T>(tableName)()
19:   const { checkRateLimit } = useRateLimit()
20:   const isDeleting: Ref<boolean> = ref(false)
21:   let lastDeleteTime = 0
22: 
23:   const deleteData = async (id: string | number | (string | number)[]) => {
24:     isDeleting.value = true
25:     const startTime = Date.now()
26: 
27:     const deleteSingle = async (itemId: string | number): Promise<void> => {
28:       try {
29:         // Rate limiting
30:         if (options.rateLimitMs) {
31:           await checkRateLimit('useDeleteData', { limitMs: options.rateLimitMs })
32:         }
33: 
34:         // Validation
35:         if (options.validateDelete && !(await options.validateDelete(itemId))) {
36:           throw new AppError({
37:             type: ErrorType.VALIDATION_ERROR,
38:             message: 'Delete validation failed',
39:             severity: ErrorSeverity.MEDIUM,
40:             context: 'Data Validation',
41:           })
42:         }
43: 
44:         // Optimistic delete
45:         store.removeItem(itemId)
46: 
47:         // Perform the delete
48:         await remove(tableName, itemId)
49: 
50:         // Refresh related data if needed
51:         if (options.refreshRelated) {
52:           await options.refreshRelated()
53:         }
54: 
55:         // Audit logging
56:         if (options.auditLog) {
57:           await options.auditLog('DELETE', { tableName, id: itemId })
58:         }
59: 
60:         lastDeleteTime = Date.now()
61:       } catch (error: any) {
62:         // Revert optimistic delete
63:         const oldItem = store.getItemById(itemId)
64:         if (oldItem) {
65:           store.addItems([oldItem])
66:         }
67:         throw error
68:       }
69:     }
70: 
71:     try {
72:       if (Array.isArray(id)) {
73:         await Promise.all(id.map(deleteSingle))
74:       } else {
75:         await deleteSingle(id)
76:       }
77:     } catch (error: any) {
78:       handleError(error, 'Error deleting data')
79:       throw error
80:     } finally {
81:       isDeleting.value = false
82:     }
83:   }
84: 
85:   return {
86:     deleteData,
87:     isDeleting,
88:   }
89: }
```

## File: layers/crud/composables/fetch.ts
```typescript
  1: import { useLogger } from '@ib/logger'
  2: import type { FilterBy, DBTable } from '../server/utils/base.interface'
  3: import type { DomainKey } from './pagination.store'
  4: import { useCookie, useRequestHeaders } from '#imports'
  5: import type { FetchResult } from '#app'
  6: 
  7: export interface FetchInput {
  8:   domainKey: DomainKey
  9:   endpoint: string
 10:   pagination?: {
 11:     page: number
 12:     limit: number
 13:   }
 14:   criteria: {
 15:     dto: string
 16:     filterBy?: FilterBy<DBTable>
 17:   }
 18: }
 19: 
 20: function getDataStructure(obj: any): any {
 21:   if (Array.isArray(obj)) {
 22:     return obj.length > 0 ? [getDataStructure(obj[0])] : []
 23:   } else if (typeof obj === 'object' && obj !== null) {
 24:     const structure: Record<string, any> = {}
 25:     for (const key in obj) {
 26:       structure[key] = getDataStructure(obj[key])
 27:     }
 28:     return structure
 29:   } else {
 30:     return typeof obj
 31:   }
 32: }
 33: 
 34: export function useBaseFetch() {
 35:   const errors = useBaseError()
 36:   const paginationStore = usePaginationStore()
 37:   const loading = useLoadingStore()
 38:   const logger = useLogger('useBaseFetch')
 39:   const apiDataStore = useApiDataStore()
 40: 
 41:   const fetch = $fetch.create({
 42:     retryStatusCodes: [408, 409, 425, 500, 502, 503, 504],
 43:     headers: {
 44:       'X-USER-ID': useCookie('userId').value ?? 'no-user-id',
 45:       'cookie': useRequestHeaders(['cookie']).cookie ?? '',
 46:     },
 47:     onResponseError({ error, response, request, options }) {
 48:       console.error('onResponseError', response, response._data, error)
 49:     },
 50:     async onResponse({ request, response, options }) {
 51:       const url = request.toString()
 52:       const structure = getDataStructure(response._data)
 53:       console.log('Captured data structure for:', url, structure)
 54:       apiDataStore.setData(url, structure)
 55:     },
 56:   })
 57: 
 58:   async function fetchPaginatedData(params: FetchInput) {
 59:     const { domainKey, endpoint, criteria } = params
 60: 
 61:     if (loading.isLoading(domainKey)) {
 62:       return null
 63:     }
 64: 
 65:     if (paginationStore.isDataFinished(domainKey)) {
 66:       return null
 67:     }
 68: 
 69:     if (!paginationStore.getPagination(domainKey)) {
 70:       return null
 71:     }
 72: 
 73:     loading.setLoading(domainKey, true)
 74: 
 75:     try {
 76:       logger.info('fetchPaginatedData for', domainKey, endpoint, criteria)
 77:       const response = await fetch(endpoint, {
 78:         method: 'POST',
 79:         params: {
 80:           ...criteria,
 81:           pagination: paginationStore.getPaginationRange(domainKey),
 82:         },
 83:       })
 84: 
 85:       console.log('fetchPaginatedData RESPONSE', response)
 86: 
 87:       const data = errors.server({
 88:         response,
 89:         devOnly: false,
 90:         userMessage: `Sorry there was an error getting ${domainKey} from ${endpoint}`,
 91:         devMessage: `fetchPaginatedData errored selecting paginated ${domainKey} data from ${endpoint}`,
 92:       })
 93: 
 94:       if (!data || !data.length || data.length < paginationStore.getPagination(domainKey)!.limit) {
 95:         paginationStore.setDataFinished(domainKey)
 96:       }
 97: 
 98:       await loading.setLoadingInterval(domainKey, false, 1500)
 99:       paginationStore.incrementPagination(domainKey)
100: 
101:       return data
102:     } catch (error) {
103:       errors.client({
104:         error,
105:         devOnly: false,
106:         userMessage: `Sorry there was an error getting ${domainKey} from ${endpoint}`,
107:         devMessage: `fetchPaginatedData error for ${domainKey}`,
108:       })
109:     }
110:   }
111: 
112:   return {
113:     fetchPaginatedData,
114:     fetch,
115:   }
116: }
```

## File: layers/crud/composables/http-handler.ts
```typescript
  1: import type { PostgrestResponse, PostgrestError } from '@supabase/supabase-js'
  2: import {
  3:   useErrorHandler,
  4:   ErrorType,
  5:   useLogger,
  6:   ErrorSeverity,
  7:   AppError,
  8:   mapErrorSeverity,
  9:   mapErrorType,
 10:   retryableStatusCodes,
 11: } from '@ib/logger'
 12: import { getOrCreateStore } from './main.store'
 13: import { usePaginationStore, type PaginationType } from './pagination.store'
 14: 
 15: type FilterOperator =
 16:   | 'eq'
 17:   | 'neq'
 18:   | 'gt'
 19:   | 'gte'
 20:   | 'lt'
 21:   | 'lte'
 22:   | 'like'
 23:   | 'ilike'
 24:   | 'is'
 25:   | 'in'
 26:   | 'contains'
 27:   | 'containedBy'
 28:   | 'overlaps'
 29:   | 'textSearch'
 30:   | 'match'
 31:   | 'not'
 32:   | 'or'
 33:   | 'and'
 34:   | 'rangeGt'
 35:   | 'rangeGte'
 36:   | 'rangeLt'
 37:   | 'rangeLte'
 38:   | 'rangeAdjacent'
 39: 
 40: type FilterOptionValue = string | number | boolean | null | any[] | Record<string, unknown>
 41: 
 42: type FilterOption = {
 43:   [K in FilterOperator]?: K extends 'not'
 44:     ? FilterOption
 45:     : K extends 'or' | 'and'
 46:       ? string
 47:       : FilterOptionValue
 48: }
 49: 
 50: type Filters = Record<string, FilterOption>
 51: 
 52: interface SelectOptions<T> {
 53:   columns?: keyof T | Array<keyof T> | string
 54:   filters?: Filters
 55:   range?: { from: number; to: number }
 56:   order?: { column: keyof T; ascending: boolean }
 57: }
 58: 
 59: function applyFilter(query: any, column: string, filter: FilterOption): any {
 60:   const [operator, value] = Object.entries(filter)[0]
 61:   switch (operator) {
 62:     case 'eq':
 63:       return query.eq(column, value)
 64:     case 'neq':
 65:       return query.neq(column, value)
 66:     case 'gt':
 67:       return query.gt(column, value)
 68:     case 'gte':
 69:       return query.gte(column, value)
 70:     case 'lt':
 71:       return query.lt(column, value)
 72:     case 'lte':
 73:       return query.lte(column, value)
 74:     case 'like':
 75:       return query.like(column, value)
 76:     case 'ilike':
 77:       return query.ilike(column, value)
 78:     case 'is':
 79:       return query.is(column, value)
 80:     case 'in':
 81:       return query.in(column, value as any[])
 82:     case 'contains':
 83:       return query.contains(column, value)
 84:     case 'containedBy':
 85:       return query.containedBy(column, value)
 86:     case 'rangeGt':
 87:       return query.rangeGt(column, value)
 88:     case 'rangeGte':
 89:       return query.rangeGte(column, value)
 90:     case 'rangeLt':
 91:       return query.rangeLt(column, value)
 92:     case 'rangeLte':
 93:       return query.rangeLte(column, value)
 94:     case 'rangeAdjacent':
 95:       return query.rangeAdjacent(column, value)
 96:     case 'overlaps':
 97:       return query.overlaps(column, value)
 98:     case 'textSearch':
 99:       return query.textSearch(column, value as string, { config: 'english' })
100:     case 'match':
101:       return query.match(column, value as Record<string, unknown>)
102:     case 'not':
103:       return applyFilter(query.not(), column, value as FilterOption)
104:     case 'or':
105:       return query.or(value as string)
106:     case 'and':
107:       return query.and(value as string)
108:     default:
109:       console.warn(`Unsupported filter operator: ${operator}`)
110:       return query
111:   }
112: }
113: 
114: export function useHttpHandler() {
115:   const supabase = useSupabaseClient()
116:   const { handleError } = useErrorHandler()
117:   const logger = useLogger('HttpHandler')
118: 
119:   async function handleDatabaseOperation<T>(
120:     operation: () => Promise<PostgrestResponse<T>>,
121:     context: string,
122:     maxRetries: number = 3,
123:   ): Promise<T> {
124:     let retries = 0
125:     while (retries < maxRetries) {
126:       try {
127:         const response = await operation()
128:         // logger.debug(`${context} response:`, response)
129: 
130:         if (response.error) {
131:           throw response.error
132:         }
133:         return response.data as T
134:       } catch (error: unknown) {
135:         retries++
136:         logger.warn(`${context} failed. Attempt ${retries} of ${maxRetries}`)
137: 
138:         const pgError = error as PostgrestError
139:         const errorType = mapErrorType(pgError)
140:         const errorSeverity = mapErrorSeverity(pgError)
141: 
142:         if (
143:           retries >= maxRetries ||
144:           !Object.keys(retryableStatusCodes).includes(pgError.code?.toString() || '')
145:         ) {
146:           const appError = new AppError({
147:             type: errorType,
148:             message:
149:               pgError.message ||
150:               retryableStatusCodes[pgError.code as keyof typeof retryableStatusCodes] ||
151:               'Database operation failed',
152:             severity: errorSeverity,
153:             code: pgError.code,
154:             context: context,
155:             pgError: pgError.details || pgError.hint || pgError.message,
156:             operation: context,
157:           })
158:           throw handleError(appError)
159:         }
160: 
161:         // Exponential backoff with jitter
162:         const backoffTime = Math.min(1000 * 2 ** retries + Math.random() * 1000, 10000)
163:         await new Promise((resolve) => setTimeout(resolve, backoffTime))
164:       }
165:     }
166:     throw new Error('Max retries reached')
167:   }
168: 
169:   async function insert<T>(
170:     tableName: string,
171:     data: T,
172:     options: { columns?: string } = {},
173:   ): Promise<T> {
174:     return handleDatabaseOperation(
175:       async () =>
176:         await supabase
177:           .from(tableName)
178:           .insert(data)
179:           .select(options.columns || '*'),
180:       `Insert into ${tableName}`,
181:     )
182:   }
183: 
184:   async function update<T>(
185:     tableName: string,
186:     id: string | number,
187:     data: Partial<T>,
188:     options: { columns?: string } = {},
189:   ): Promise<T> {
190:     return handleDatabaseOperation(
191:       async () =>
192:         await supabase
193:           .from(tableName)
194:           .update(data)
195:           .eq('id', id)
196:           .select(options.columns || '*'),
197:       `Update ${tableName}`,
198:     )
199:   }
200: 
201:   async function remove(tableName: string, id: string | number): Promise<void> {
202:     await handleDatabaseOperation(
203:       async () => await supabase.from(tableName).delete().eq('id', id),
204:       `Delete from ${tableName}`,
205:     )
206:   }
207: 
208:   async function select<T>(tableName: string, options: SelectOptions<T> = {}): Promise<T[]> {
209:     let query = supabase.from(tableName).select(options.columns || '*')
210: 
211:     if (options.filters) {
212:       Object.entries(options.filters).forEach(([column, filterOption]) => {
213:         query = applyFilter(query, column, filterOption)
214:       })
215:     }
216: 
217:     if (options.range) {
218:       query = query.range(options.range.from, options.range.to)
219:     }
220: 
221:     if (options.order) {
222:       query = query.order(options.order.column, { ascending: options.order.ascending })
223:     }
224: 
225:     return handleDatabaseOperation(() => query, `Select from ${tableName}`)
226:   }
227: 
228:   return {
229:     insert,
230:     update,
231:     remove,
232:     select,
233:   }
234: }
```

## File: layers/crud/composables/insert.ts
```typescript
  1: import { useErrorHandler, AppError, ErrorType, ErrorSeverity, useLogger } from '@ib/logger'
  2: import { useHttpHandler } from './http-handler'
  3: import { getOrCreateStore } from './main.store'
  4: import { useRateLimit } from './rate-limit'
  5: 
  6: type InsertError =
  7:   | 'VALIDATION_ERROR'
  8:   | 'NETWORK_ERROR'
  9:   | 'SERVER_ERROR'
 10:   | 'RATE_LIMIT_ERROR'
 11:   | 'DUPLICATE_ERROR'
 12: 
 13: export function useInsertData<T extends { id: string | number }>(
 14:   tableName: string,
 15:   options: {
 16:     columns?: string
 17:     validateData?: (data: T) => boolean | Promise<boolean>
 18:     maxRetries?: number
 19:     refreshRelated?: () => Promise<void>
 20:     transformData?: (data: T) => T
 21:     onError?: (error: InsertError, details: any) => void
 22:     rateLimitMs?: number
 23:     auditLog?: (action: string, details: any) => Promise<void>
 24:     generateClientId?: () => string | number
 25:   } = {},
 26: ) {
 27:   const supabase = useSupabaseClient()
 28:   const { insert } = useHttpHandler()
 29:   const { handleError } = useErrorHandler()
 30:   const log = useLogger('useInsertData')
 31:   const store = getOrCreateStore<T>(tableName)()
 32:   const { checkRateLimit } = useRateLimit()
 33:   const isInserting: Ref<boolean> = ref(false)
 34:   let lastInsertTime = 0
 35: 
 36:   const insertData = async (data: T | T[]) => {
 37:     isInserting.value = true
 38:     const startTime = Date.now()
 39: 
 40:     const insertSingle = async (item: T): Promise<T> => {
 41:       try {
 42:         // Rate limiting
 43:         if (options.rateLimitMs) {
 44:           await checkRateLimit('useInsertData', { limitMs: options.rateLimitMs })
 45:         }
 46: 
 47:         // Validation
 48:         if (options.validateData && !(await options.validateData(item))) {
 49:           throw new AppError({
 50:             type: ErrorType.VALIDATION_ERROR,
 51:             message: 'Data validation failed',
 52:             severity: ErrorSeverity.MEDIUM,
 53:             context: 'Data Validation',
 54:           })
 55:         }
 56: 
 57:         // Data transformation
 58:         const transformedData = options.transformData ? options.transformData(item) : item
 59: 
 60:         // Generate client-side ID if needed
 61:         if (options.generateClientId && !transformedData.id) {
 62:           transformedData.id = options.generateClientId()
 63:         }
 64: 
 65:         // Optimistic insert
 66:         store.addItems([transformedData])
 67: 
 68:         // Perform the insert
 69:         const result = await insert(tableName, transformedData, { columns: options.columns })
 70: 
 71:         // Update store with actual server data
 72:         store.updateItem(result)
 73: 
 74:         // Refresh related data if needed
 75:         if (options.refreshRelated) {
 76:           await options.refreshRelated()
 77:         }
 78: 
 79:         // Audit logging
 80:         if (options.auditLog) {
 81:           await options.auditLog('INSERT', { tableName, newData: result })
 82:         }
 83: 
 84:         lastInsertTime = Date.now()
 85:         return result
 86:       } catch (error: any) {
 87:         // Revert optimistic insert
 88:         store.removeItem(item.id)
 89:         throw error // error handler in the HTTP handler deals with this
 90:       }
 91:     }
 92: 
 93:     try {
 94:       if (Array.isArray(data)) {
 95:         const results = await Promise.all(data.map(insertSingle))
 96:         isInserting.value = false
 97:         return results
 98:       } else {
 99:         const result = await insertSingle(data)
100:         isInserting.value = false
101:         return result
102:       }
103:     } catch (error: any) {
104:       handleError(error, 'Error inserting data')
105:       throw error // Re-throw to allow caller to handle if needed
106:     } finally {
107:       isInserting.value = false
108:     }
109:   }
110: 
111:   return {
112:     insertData,
113:     isInserting,
114:   }
115: }
```

## File: layers/crud/composables/loading.store.ts
```typescript
 1: import type { DomainKey } from './pagination.store'
 2: 
 3: type Loaders = {
 4:   [K in DomainKey]?: boolean
 5: }
 6: 
 7: export const useLoadingStore = defineStore('storeLoading', () => {
 8:   const loaders = ref({} as Loaders)
 9: 
10:   function setLoading(key: DomainKey, isLoading: boolean) {
11:     loaders.value[key] = isLoading
12:   }
13: 
14:   async function setLoadingInterval(key: DomainKey, isLoading: boolean, time: number) {
15:     await new Promise<void>((resolve) => {
16:       setTimeout(() => {
17:         setLoading(key, isLoading)
18:         resolve()
19:       }, time)
20:     })
21:   }
22: 
23:   function isLoading(key: DomainKey) {
24:     return !!loaders.value[key]
25:   }
26: 
27:   return {
28:     setLoadingInterval,
29:     setLoading,
30:     isLoading,
31:   }
32: })
33: 
34: if (import.meta.hot) {
35:   import.meta.hot.accept(acceptHMRUpdate(useLoadingStore, import.meta.hot))
36: }
```

## File: layers/crud/composables/local-storage.ts
```typescript
 1: import { useLogger } from '@ib/logger'
 2: 
 3: const CACHE_DURATION = 24 * 60 * 60 * 1000 // 24 hours in milliseconds
 4: const CACHE_VERSION = '1.0' // Increment this when data structure changes
 5: 
 6: const LocalStorageEnum = {
 7:   CATEGORIES: 'astronera-categories',
 8:   TAGS: 'astronera-tags',
 9: } as const
10: 
11: type LocalStorageKey = (typeof LocalStorageEnum)[keyof typeof LocalStorageEnum]
12: 
13: interface CachedData<T> {
14:   version: string
15:   timestamp: number
16:   data: T
17: }
18: 
19: export function useBaseLocalStorage() {
20:   const logger = useLogger('localStorage')
21: 
22:   function getCacheKey(key: LocalStorageKey): string {
23:     return `${key}-${CACHE_VERSION}`
24:   }
25: 
26:   function clearCache(key: LocalStorageKey): void {
27:     localStorage.removeItem(getCacheKey(key))
28:     logger.debug(`Cleared cache for: ${key}`)
29:   }
30: 
31:   function clearAllCaches(): void {
32:     Object.values(LocalStorageEnum).forEach(clearCache)
33:     logger.debug('Cleared all caches')
34:   }
35: 
36:   function getFromCache<T>(key: LocalStorageKey): T | null {
37:     const cacheKey = getCacheKey(key)
38:     const cachedItem = localStorage.getItem(cacheKey)
39: 
40:     if (!cachedItem) {
41:       logger.debug(`No cached data found for: ${key}`)
42:       return null
43:     }
44: 
45:     try {
46:       const parsedData = JSON.parse(cachedItem) as CachedData<T>
47:       const currentTime = Date.now()
48: 
49:       if (
50:         currentTime - parsedData.timestamp <= CACHE_DURATION &&
51:         parsedData.version === CACHE_VERSION
52:       ) {
53:         logger.debug(`Retrieved valid cached data for: ${key}`)
54:         return parsedData.data
55:       } else {
56:         logger.debug(`Cached data for ${key} is outdated or version mismatch`)
57:         clearCache(key)
58:         return null
59:       }
60:     } catch (error) {
61:       logger.error(`Error parsing cached data for ${key}:`, error)
62:       clearCache(key)
63:       return null
64:     }
65:   }
66: 
67:   function setCache<T>(key: LocalStorageKey, data: T): void {
68:     const cacheKey = getCacheKey(key)
69:     const cacheData: CachedData<T> = {
70:       version: CACHE_VERSION,
71:       timestamp: Date.now(),
72:       data,
73:     }
74:     localStorage.setItem(cacheKey, JSON.stringify(cacheData))
75:     logger.debug(`Cached data for: ${key}`)
76:   }
77: 
78:   async function getCachedOrFetch<T>(key: LocalStorageKey, fetchFn: () => Promise<T>): Promise<T> {
79:     const cachedData = getFromCache<T>(key)
80:     if (cachedData) return cachedData
81: 
82:     try {
83:       const fetchedData = await fetchFn()
84:       setCache(key, fetchedData)
85:       return fetchedData
86:     } catch (error) {
87:       logger.error(`Error fetching data for ${key}:`, error)
88:       throw error
89:     }
90:   }
91: 
92:   return {
93:     getFromCache,
94:     setCache,
95:     clearCache,
96:     clearAllCaches,
97:     getCachedOrFetch,
98:   }
99: }
```

## File: layers/crud/composables/main.store.ts
```typescript
 1: import { defineStore } from 'pinia'
 2: import { type Ref, ref } from 'vue'
 3: import type { DomainKey } from './pagination.store'
 4: 
 5: export function createBaseStore<T extends object>(domainKey: DomainKey) {
 6:   return defineStore(`${domainKey}Store`, () => {
 7:     const items = ref<T[]>([]) as Ref<T[]>
 8:     const itemsMap = computed(() => new Map(items.value.map((item) => [item.id, item])))
 9: 
10:     function setItems(newItems: T[]) {
11:       items.value = newItems
12:     }
13: 
14:     function addItems(newItems: T[]) {
15:       const newItemsMap = new Map(newItems.map((item) => [item.id, item]))
16:       items.value = [...items.value.filter((item) => !newItemsMap.has(item.id)), ...newItems]
17:     }
18: 
19:     function updateItem(updatedItem: T) {
20:       const index = items.value.findIndex((item) => item.id === updatedItem.id)
21:       if (index !== -1) {
22:         items.value[index] = { ...items.value[index], ...updatedItem }
23:       } else {
24:         items.value.push(updatedItem)
25:       }
26:     }
27: 
28:     function removeItem(id: string | number) {
29:       items.value = items.value.filter((item) => item.id !== id)
30:     }
31: 
32:     function clearItems() {
33:       items.value = []
34:     }
35: 
36:     function getItemById(id: string | number) {
37:       return itemsMap.value.get(id)
38:     }
39: 
40:     return {
41:       items,
42:       itemsMap,
43:       setItems,
44:       addItems,
45:       updateItem,
46:       removeItem,
47:       clearItems,
48:       getItemById,
49:     }
50:   })
51: }
52: 
53: const storeCache: Partial<Record<DomainKey, ReturnType<typeof createBaseStore>>> = {}
54: 
55: export function getOrCreateStore<T>(domainKey: DomainKey) {
56:   if (!storeCache[domainKey]) {
57:     storeCache[domainKey] = createBaseStore<T>(domainKey)
58:   }
59:   return storeCache[domainKey] as ReturnType<typeof createBaseStore<T>>
60: }
```

## File: layers/crud/composables/notification.ts
```typescript
 1: import type { useToast } from 'primevue/usetoast'
 2: 
 3: interface BaseNotification {
 4:   summary: string
 5:   message: string
 6: }
 7: 
 8: export function useNotification() {
 9:   const nuxtApp = useNuxtApp()
10:   const getToast: typeof useToast = () => nuxtApp.vueApp.config.globalProperties.$toast
11:   const toast = getToast()
12: 
13:   const success = ({ summary, message }: BaseNotification) => {
14:     toast.add({
15:       severity: 'success',
16:       summary: `Success: ${summary}`,
17:       detail: message,
18:       life: 5000,
19:       closable: true,
20:     })
21:   }
22: 
23:   const error = ({ summary, message }: BaseNotification) => {
24:     toast.add({
25:       severity: 'error',
26:       summary: `Error: ${summary}`,
27:       detail: message,
28:       life: 0,
29:       closable: true,
30:     })
31:   }
32: 
33:   const info = ({ summary, message }: BaseNotification) => {
34:     toast.add({
35:       severity: 'info',
36:       summary: `Info: ${summary}`,
37:       detail: message,
38:       life: 5000,
39:       closable: true,
40:     })
41:   }
42: 
43:   const warn = ({ summary, message }: BaseNotification) => {
44:     toast.add({
45:       severity: 'warn',
46:       summary: `Warning: ${summary}`,
47:       detail: message,
48:       life: 5000,
49:       closable: true,
50:     })
51:   }
52: 
53:   const feature = ({ summary, message }: BaseNotification) => {
54:     toast.add({
55:       severity: 'warn',
56:       group: 'cta',
57:       summary: summary,
58:       detail: message,
59:       life: 0,
60:       closable: true,
61:     })
62:   }
63: 
64:   return {
65:     success,
66:     error,
67:     info,
68:     warn,
69:     feature,
70:   }
71: }
```

## File: layers/crud/composables/pagination.store.ts
```typescript
 1: import { useLogger } from '@ib/logger'
 2: 
 3: export type DomainKey =
 4:   | 'users'
 5:   | 'news'
 6:   | 'events'
 7:   | 'venues'
 8:   | 'research'
 9:   | 'companies'
10:   | 'chats'
11:   | 'feedbacks'
12:   | 'currentUser'
13:   | 'chat'
14:   | 'auth'
15: 
16: export type PaginationType = {
17:   page: number
18:   limit: number
19: }
20: 
21: export interface PaginationInput {
22:   domainKey: DomainKey
23:   pagination: PaginationType
24:   force?: boolean
25: }
26: 
27: export const usePaginationStore = defineStore('paginationStore', () => {
28:   const logger = useLogger('paginationStore')
29:   const stores = reactive({} as Record<DomainKey, Ref<{ page: number; limit: number }>>)
30:   const dataFinished = ref({} as Record<DomainKey, boolean>)
31: 
32:   function initPagination(input: PaginationInput) {
33:     if (!stores[input.domainKey] || input.force) {
34:       // -1 for supabase because it is 0 indexed
35:       console.log('initPagination', input.force)
36:       stores[input.domainKey] = {
37:         page: input.pagination.page,
38:         limit: input.pagination.limit - 1,
39:       }
40:     }
41:   }
42: 
43:   function getPagination(domainKey: DomainKey) {
44:     if (!stores[domainKey]) {
45:       logger.warn(`Pagination settings for '${domainKey}' is not initialized.`)
46:       return null
47:     }
48: 
49:     return stores[domainKey]
50:   }
51: 
52:   function getPaginationRange(domainKey: DomainKey) {
53:     const pagination = getPagination(domainKey)
54:     if (pagination) {
55:       logger.info('getPaginationRange', pagination.limit, (pagination.page - 1) * pagination.limit)
56:       return {
57:         from: (pagination.page - 1) * pagination.limit,
58:         to: pagination.limit * pagination.page,
59:       }
60:     }
61:     return undefined
62:   }
63: 
64:   function incrementPagination(domainKey: DomainKey) {
65:     const currentPagination = getPagination(domainKey)
66:     if (currentPagination) {
67:       currentPagination.page++
68:     } else {
69:       logger.warn(`Attempted to increment pagination for an uninitialized store '${domainKey}'.`)
70:     }
71:   }
72: 
73:   function setDataFinished(domainKey: DomainKey) {
74:     if (stores[domainKey]) {
75:       dataFinished.value[domainKey] = true
76:     }
77:   }
78: 
79:   const isDataFinished = (domainKey: DomainKey) => dataFinished.value[domainKey]
80: 
81:   return {
82:     stores,
83:     isDataFinished,
84:     setDataFinished,
85:     initPagination,
86:     getPagination,
87:     incrementPagination,
88:     getPaginationRange,
89:   }
90: })
```

## File: layers/crud/composables/rate-limit.ts
```typescript
 1: interface RateLimitOptions {
 2:   limitMs: number
 3: }
 4: 
 5: export function useRateLimit() {
 6:   const lastActionTimes = ref<Map<string, number>>(new Map())
 7: 
 8:   const checkRateLimit = async (action: string, options: RateLimitOptions): Promise<void> => {
 9:     const now = Date.now()
10:     const lastActionTime = lastActionTimes.value.get(action) || 0
11:     const timeElapsed = now - lastActionTime
12: 
13:     if (timeElapsed < options.limitMs) {
14:       const waitTime = options.limitMs - timeElapsed
15:       await new Promise((resolve) => setTimeout(resolve, waitTime))
16:     }
17: 
18:     lastActionTimes.value.set(action, Date.now())
19:   }
20: 
21:   return {
22:     checkRateLimit,
23:   }
24: }
```

## File: layers/crud/composables/select.ts
```typescript
  1: import { useErrorHandler, AppError, ErrorType, ErrorSeverity, useLogger } from '@ib/logger'
  2: import { useHttpHandler } from './http-handler'
  3: import { getOrCreateStore } from './main.store'
  4: import { usePaginationStore, type PaginationType } from './pagination.store'
  5: import { useRateLimit } from './rate-limit'
  6: 
  7: export function useSelectData<T extends { id: string | number }>(
  8:   tableName: string,
  9:   options: {
 10:     columns?: string
 11:     filters?: Record<string, any>
 12:     orderBy?: { column: string; ascending?: boolean }
 13:     initialFetch?: boolean
 14:     pagination?: PaginationType
 15:     limit?: number
 16:     refreshRelated?: () => Promise<void>
 17:     rateLimitMs?: number
 18:     auditLog?: (action: string, details: any) => Promise<void>
 19:   } = {},
 20: ) {
 21:   const { select } = useHttpHandler()
 22:   const { handleError } = useErrorHandler()
 23:   const logger = useLogger('useSelectData')
 24:   const store = getOrCreateStore<T>(tableName)()
 25:   const { checkRateLimit } = useRateLimit()
 26: 
 27:   const isSelecting: Ref<boolean> = ref(false)
 28:   let lastSelectTime = 0
 29: 
 30:   let paginationStore: ReturnType<typeof usePaginationStore> | null = null
 31: 
 32:   if (options.pagination) {
 33:     paginationStore = usePaginationStore()
 34:     paginationStore.initPagination({
 35:       domainKey: tableName,
 36:       pagination: options.pagination,
 37:       force: true,
 38:     })
 39:   }
 40: 
 41:   const fetchData = async (forceFetch = false) => {
 42:     isSelecting.value = true
 43:     const startTime = Date.now()
 44: 
 45:     try {
 46:       // Rate limiting
 47:       if (options.rateLimitMs && !forceFetch) {
 48:         await checkRateLimit('useSelectData', { limitMs: options.rateLimitMs })
 49:       }
 50: 
 51:       const queryOptions: any = {
 52:         columns: options.columns || '*',
 53:         filters: options.filters,
 54:       }
 55: 
 56:       if (options.orderBy) {
 57:         queryOptions.order = {
 58:           column: options.orderBy.column,
 59:           ascending: options.orderBy.ascending ?? true,
 60:         }
 61:       }
 62: 
 63:       if (paginationStore) {
 64:         const pagination = paginationStore.getPaginationRange(tableName)
 65:         if (pagination) {
 66:           console.log('pagination', pagination)
 67:           queryOptions.range = pagination
 68:         } else {
 69:           throw new AppError({
 70:             type: ErrorType.VALIDATION_ERROR,
 71:             message: `Pagination not initialized for ${tableName}`,
 72:             severity: ErrorSeverity.MEDIUM,
 73:             context: 'Data Fetching',
 74:           })
 75:         }
 76:       } else if (options.limit) {
 77:         queryOptions.range = { from: 0, to: options.limit - 1 }
 78:       }
 79: 
 80:       const result = await select<T>(tableName, queryOptions)
 81:       console.log('Fetch result:', result)
 82: 
 83:       // Audit logging
 84:       if (options.auditLog) {
 85:         await options.auditLog('SELECT', { tableName, options: queryOptions })
 86:       }
 87: 
 88:       lastSelectTime = Date.now()
 89:       return result
 90:     } catch (error: any) {
 91:       handleError(error, 'Error selecting data')
 92:       throw error
 93:     } finally {
 94:       isSelecting.value = false
 95:     }
 96:   }
 97: 
 98:   const loadMore = async () => {
 99:     if (paginationStore) {
100:       console.log('loading more data')
101:       const newData = await fetchData()
102:       if (newData.length === 0) {
103:         paginationStore.setDataFinished(tableName)
104:       } else {
105:         store.addItems(newData)
106:         paginationStore.incrementPagination(tableName)
107:       }
108:     } else {
109:       const data = await fetchData()
110:       store.setItems(data)
111:     }
112: 
113:     // Refresh related data if needed
114:     if (options.refreshRelated) {
115:       await options.refreshRelated()
116:     }
117:   }
118: 
119:   const refresh = async () => {
120:     if (paginationStore) {
121:       paginationStore.initPagination({
122:         domainKey: tableName,
123:         pagination: options.pagination!,
124:         force: true,
125:       })
126:     }
127:     store.clearItems()
128:     await loadMore()
129:   }
130: 
131:   if (options.initialFetch) {
132:     loadMore()
133:   }
134: 
135:   return {
136:     store,
137:     loadMore,
138:     refresh,
139:     isSelecting,
140:   }
141: }
```

## File: layers/crud/composables/settings.store.ts
```typescript
 1: type SettingsKey = 'usersStore' | 'storeNews'
 2: 
 3: export const useSettingsStore = defineStore('settingsStore', () => {
 4:   const settings = ref({} as Settings)
 5:   const summaryLevel = ref('beginner' as SummaryLevel)
 6: 
 7:   function toggleSettings(key: SettingsKey) {
 8:     settings.value[key] = !settings.value[key]
 9:   }
10: 
11:   function isSettingsOn(key: SettingsKey) {
12:     return !settings.value[key]
13:   }
14: 
15:   const changeSummaryLevel = (level: 'beginner' | 'intermediate' | 'expert') => {
16:     summaryLevel.value = level
17:   }
18: 
19:   return {
20:     toggleSettings,
21:     isSettingsOn,
22:   }
23: })
24: 
25: if (import.meta.hot) {
26:   import.meta.hot.accept(acceptHMRUpdate(useSettingsStore, import.meta.hot))
27: }
```

## File: layers/crud/composables/update.ts
```typescript
 1: import { useErrorHandler, AppError, ErrorSeverity, ErrorType, useLogger } from '@ib/logger'
 2: import { useHttpHandler } from './http-handler'
 3: import { getOrCreateStore } from './main.store'
 4: import { useRateLimit } from './rate-limit'
 5: 
 6: export function useUpdateData<T extends { id: string | number }>(
 7:   tableName: string,
 8:   options: {
 9:     columns?: string
10:     validateData?: (data: Partial<T>) => boolean | Promise<boolean>
11:     refreshRelated?: () => Promise<void>
12:     transformData?: (data: Partial<T>) => Partial<T>
13:     rateLimitMs?: number
14:     auditLog?: (action: string, details: any) => Promise<void>
15:   } = {},
16: ) {
17:   const { update } = useHttpHandler()
18:   const { handleError } = useErrorHandler()
19:   const logger = useLogger('useUpdateData')
20:   const store = getOrCreateStore<T>(tableName)()
21:   const { checkRateLimit } = useRateLimit()
22: 
23:   const isUpdating: Ref<boolean> = ref(false)
24:   let lastUpdateTime = 0
25: 
26:   const updateData = async (id: string | number, data: Partial<T>) => {
27:     isUpdating.value = true
28:     const startTime = Date.now()
29:     let oldData: T | undefined = undefined
30: 
31:     try {
32:       // Rate limiting
33:       if (options.rateLimitMs) {
34:         await checkRateLimit('useUpdateData', { limitMs: options.rateLimitMs })
35:       }
36: 
37:       // Validation
38:       if (options.validateData && !(await options.validateData(data))) {
39:         throw new AppError({
40:           type: ErrorType.VALIDATION_ERROR,
41:           message: 'Data validation failed',
42:           severity: ErrorSeverity.MEDIUM,
43:           context: 'Data Validation',
44:         })
45:       }
46: 
47:       // Data transformation
48:       const transformedData = options.transformData ? options.transformData(data) : data
49: 
50:       // Optimistic update
51:       oldData = store.getItemById(id)
52:       if (!oldData) {
53:         throw new AppError({
54:           type: ErrorType.NOT_FOUND_ERROR,
55:           message: 'Item not found in store',
56:           severity: ErrorSeverity.MEDIUM,
57:           context: 'Data Update',
58:         })
59:       }
60:       store.updateItem({ ...oldData, ...transformedData, id })
61: 
62:       // Perform the update
63:       const result = await update(tableName, id, transformedData, { columns: options.columns })
64: 
65:       // Update store with actual server data
66:       store.updateItem(result)
67: 
68:       // Refresh related data if needed
69:       if (options.refreshRelated) {
70:         await options.refreshRelated()
71:       }
72: 
73:       // Audit logging
74:       if (options.auditLog) {
75:         await options.auditLog('UPDATE', { tableName, id, oldData, newData: result })
76:       }
77: 
78:       lastUpdateTime = Date.now()
79:       return result
80:     } catch (error: any) {
81:       // Revert optimistic update
82:       if (oldData) {
83:         store.updateItem(oldData)
84:       }
85:       handleError(error, 'Error updating data')
86:       throw error
87:     } finally {
88:       isUpdating.value = false
89:     }
90:   }
91: 
92:   return {
93:     updateData,
94:     isUpdating,
95:   }
96: }
```

## File: layers/crud/composables/upload.ts
```typescript
  1: import { v4 as uuidv4 } from 'uuid'
  2: import { useErrorHandler, AppError, ErrorType, ErrorSeverity, useLogger } from '@ib/logger'
  3: import { useRateLimit } from './rate-limit'
  4: 
  5: type FileType = 'profile' | 'document' | 'image' | 'video' | 'audio' | 'other'
  6: 
  7: interface UploadOptions {
  8:   bucket: string
  9:   path: string
 10:   fileType: FileType
 11:   userId?: string
 12:   metadata?: Record<string, string>
 13:   optimizeImage?: boolean
 14:   maxWidth?: number
 15:   maxHeight?: number
 16:   quality?: number
 17:   format?: 'jpeg' | 'jpg' | 'png' | 'webp'
 18:   rateLimitMs?: number
 19:   auditLog?: (action: string, details: any) => Promise<void>
 20:   onProgress?: (progress: number) => void
 21:   maxFileSize?: number
 22:   allowedMimeTypes?: string[]
 23:   serverSideOptimize?: boolean
 24:   useServerUpload?: boolean
 25:   replace?: boolean
 26: }
 27: 
 28: interface UploadResult {
 29:   path: string
 30:   publicUrl: string
 31:   size: number
 32:   mimeType: string
 33:   metadata: Record<string, string>
 34: }
 35: 
 36: export function useFileUpload() {
 37:   const supabase = useSupabaseClient()
 38:   const { handleError } = useErrorHandler()
 39:   const { checkRateLimit } = useRateLimit()
 40:   const isUploading: Ref<boolean> = ref(false)
 41:   const uploadProgress: Ref<number> = ref(0)
 42:   const lastUploadTime = ref(0)
 43:   const uploadQueue: Ref<File[]> = ref([])
 44:   const currentUpload: Ref<File | null> = ref(null)
 45: 
 46:   const isProcessing = computed(() => uploadQueue.value.length > 0 || currentUpload.value !== null)
 47: 
 48:   const getFilePath = (fileName: string, options: UploadOptions): string => {
 49:     const { bucket, path, fileType, userId, replace } = options
 50:     const timestamp = new Date().toISOString().replace(/[-:]/g, '').split('.')[0]
 51:     const uniqueId = uuidv4().slice(0, 8)
 52:     const userPath = userId ? `${userId}/` : ''
 53:     return `${bucket}/${fileType}/${userPath}${path || ''}/${replace ? '' : `${timestamp}_${uniqueId}_`}${fileName}`
 54:   }
 55: 
 56:   const validateFile = (file: File, options: UploadOptions): void => {
 57:     if (options.maxFileSize && file.size > options.maxFileSize) {
 58:       throw new AppError({
 59:         type: ErrorType.VALIDATION_ERROR,
 60:         message: `File size exceeds the maximum allowed size of ${options.maxFileSize} bytes`,
 61:         severity: ErrorSeverity.MEDIUM,
 62:         context: 'File Upload',
 63:       })
 64:     }
 65: 
 66:     if (options.allowedMimeTypes && !options.allowedMimeTypes.includes(file.type)) {
 67:       throw new AppError({
 68:         type: ErrorType.VALIDATION_ERROR,
 69:         message: `File type ${file.type} is not allowed`,
 70:         severity: ErrorSeverity.MEDIUM,
 71:         context: 'File Upload',
 72:       })
 73:     }
 74:   }
 75: 
 76:   const serverSideUpload = async (file: File, options: UploadOptions): Promise<UploadResult> => {
 77:     const formData = new FormData()
 78:     formData.append('file', file)
 79:     formData.append('userId', options.userId || '')
 80:     formData.append('fileType', options.fileType)
 81:     formData.append('bucket', options.bucket)
 82:     formData.append('path', options.path)
 83:     formData.append(
 84:       'optimizationOptions',
 85:       JSON.stringify({
 86:         maxWidth: options.maxWidth,
 87:         maxHeight: options.maxHeight,
 88:         quality: options.quality,
 89:         format: options.format,
 90:       }),
 91:     )
 92: 
 93:     const response = await $fetch('/api/upload', {
 94:       method: 'POST',
 95:       body: formData,
 96:       onUploadProgress: (progressEvent) => {
 97:         if (progressEvent.total) {
 98:           const progress = Math.round((progressEvent.loaded * 100) / progressEvent.total)
 99:           uploadProgress.value = progress
100:           options.onProgress?.(progress)
101:         }
102:       },
103:     })
104: 
105:     if (!response || !response.fileName) {
106:       throw new Error('Failed to upload file on server')
107:     }
108: 
109:     const publicUrl = supabase.storage.from(options.bucket).getPublicUrl(response.fileName)
110:       .data.publicUrl
111: 
112:     return {
113:       path: response.fileName,
114:       publicUrl,
115:       size: file.size,
116:       mimeType: file.type,
117:       metadata: {
118:         originalName: file.name,
119:         ...options.metadata,
120:       },
121:     }
122:   }
123: 
124:   const uploadFile = async (file: File, options: UploadOptions): Promise<UploadResult> => {
125:     isUploading.value = true
126:     uploadProgress.value = 0
127:     currentUpload.value = file
128: 
129:     try {
130:       validateFile(file, options)
131: 
132:       // Rate limiting
133:       if (options.rateLimitMs) {
134:         await checkRateLimit('fileUpload', { limitMs: options.rateLimitMs })
135:       }
136: 
137:       let result: UploadResult
138: 
139:       if (options.useServerUpload) {
140:         result = await serverSideUpload(file, options)
141:       } else {
142:         const filePath = getFilePath(file.name, options)
143:         const { data, error } = await supabase.storage.from(options.bucket).upload(filePath, file, {
144:           cacheControl: '3600',
145:           upsert: options.replace,
146:           contentType: file.type,
147:         })
148: 
149:         if (error) {
150:           throw new AppError({
151:             type: ErrorType.UPLOAD_ERROR,
152:             message: `Error uploading file: ${error.message}`,
153:             severity: ErrorSeverity.HIGH,
154:             context: 'File Upload',
155:           })
156:         }
157: 
158:         const {
159:           data: { publicUrl },
160:         } = supabase.storage.from(options.bucket).getPublicUrl(data.path)
161: 
162:         result = {
163:           path: data.path,
164:           publicUrl,
165:           size: file.size,
166:           mimeType: file.type,
167:           metadata: {
168:             originalName: file.name,
169:             ...options.metadata,
170:           },
171:         }
172:       }
173: 
174:       lastUploadTime.value = Date.now()
175: 
176:       return result
177:     } catch (error: any) {
178:       handleError(error, 'Error uploading file')
179:       throw error
180:     } finally {
181:       isUploading.value = false
182:       uploadProgress.value = 100
183:       currentUpload.value = null
184:       processQueue()
185:     }
186:   }
187: 
188:   const processQueue = async () => {
189:     if (uploadQueue.value.length > 0 && !isUploading.value) {
190:       const nextFile = uploadQueue.value.shift()
191:       if (nextFile) {
192:         await uploadFile(nextFile, {
193:           bucket: 'default',
194:           path: 'uploads',
195:           fileType: 'other',
196:         })
197:       }
198:     }
199:   }
200: 
201:   const queueUpload = (file: File, options: UploadOptions) => {
202:     uploadQueue.value.push(file)
203:     processQueue()
204:   }
205: 
206:   const cancelUpload = () => {
207:     if (currentUpload.value) {
208:       // Implement cancellation logic here
209:       // This might involve aborting the Supabase upload if possible
210:       currentUpload.value = null
211:       isUploading.value = false
212:       uploadProgress.value = 0
213:     }
214:   }
215: 
216:   const clearQueue = () => {
217:     uploadQueue.value = []
218:   }
219: 
220:   return {
221:     uploadFile,
222:     queueUpload,
223:     cancelUpload,
224:     clearQueue,
225:     isUploading,
226:     isProcessing,
227:     uploadProgress,
228:     currentUpload,
229:     uploadQueue,
230:   }
231: }
```

## File: layers/crud/composables/useApiDataStore.ts
```typescript
 1: // stores/apiData.ts
 2: import { defineStore } from 'pinia'
 3: import { ref } from 'vue'
 4: 
 5: interface ApiDataStructure {
 6:   [key: string]: any
 7: }
 8: 
 9: export const useApiDataStore = defineStore('apiData', () => {
10:   const apiData = ref<ApiDataStructure>({})
11: 
12:   const setData = (url: string, data: any): void => {
13:     apiData.value[url] = data
14:   }
15: 
16:   const getData = (url: string): any => {
17:     return apiData.value[url]
18:   }
19: 
20:   const clearData = (): void => {
21:     apiData.value = {}
22:   }
23: 
24:   return {
25:     apiData,
26:     setData,
27:     getData,
28:     clearData,
29:   }
30: })
```

## File: layers/crud/composables/useBaseError.ts
```typescript
  1: import { useLogger } from '@ib/logger'
  2: 
  3: interface ErrorMessage {
  4:   userMessage: string // User-friendly error message if needed
  5:   devMessage: string // Make bugfixing easy!
  6:   error: any
  7: }
  8: 
  9: interface ErrorServer extends Omit<ErrorMessage, 'error'> {
 10:   devOnly: boolean // default true - don't show toasts in production
 11:   featureRelated?: boolean // default false - log to feature-specific log
 12:   response: { data: any; error: any }
 13: }
 14: 
 15: interface ErrorClient extends ErrorMessage {
 16:   isServer?: boolean // default false
 17:   featureRelated?: boolean // default false - log to feature-specific log
 18:   devOnly: boolean
 19: }
 20: 
 21: export function useBaseError() {
 22:   // !todo:med:easy - add prefix to base error
 23: 
 24:   // const toast = useNotification()
 25:   const logger = useLogger('useBaseError')
 26:   const isAdmin = useRuntimeConfig().public.nodeEnv === 'development'
 27: 
 28:   // function handleErrorWithCodes(error: any) {
 29:   //   switch (error.statusCode) {
 30:   //     case 429:
 31:   //       toast.feature({
 32:   //         summary: error.statusMessage,
 33:   //         message: error.message,
 34:   //       })
 35:   //       break
 36:   //     case 403:
 37:   //       toast.error({
 38:   //         summary: error.statusMessage,
 39:   //         message: error.message,
 40:   //       })
 41:   //       break
 42:   //     default:
 43:   //       console.error('Unhandled feature error:', error)
 44:   //   }
 45:   // }
 46: 
 47:   function formatErrorMessage({ userMessage, devMessage, error }: ErrorMessage) {
 48:     const devError = `${devMessage}: ${JSON.stringify(error)}`
 49:     logger.error(devError)
 50:     const userError = userMessage || 'An unexpected error occurred. Please try again later.'
 51:     return isAdmin ? devError : userError
 52:   }
 53: 
 54:   function handleError({
 55:     userMessage,
 56:     devMessage,
 57:     devOnly = true,
 58:     isServer = false,
 59:     error,
 60:   }: ErrorClient) {
 61:     // Determine the appropriate user message
 62:     const errorMessage = formatErrorMessage({ error, userMessage, devMessage })
 63: 
 64:     // Add an error toast notification with an option to retry if an action is provided
 65: 
 66:     // Handle critical errors specifically if needed
 67:     if (!devOnly || isAdmin) {
 68:       // toast.error({
 69:       //   summary: 'Error',
 70:       //   message: errorMessage,
 71:       // })
 72:       // Here you could navigate to an error page, log out the user, etc.
 73:       console.error('Handling critical error for:', devMessage)
 74:     }
 75: 
 76:     throw createError({
 77:       message: `${isServer ? 'SERVER' : 'CLIENT'} ERROR: ${errorMessage}`,
 78:     })
 79:   }
 80: 
 81:   function handleServerError({ response, devMessage, devOnly, userMessage }: ErrorServer) {
 82:     if (response.error) {
 83:       console.log('FeatError', response.error)
 84:       handleError({
 85:         error: response.error,
 86:         devOnly,
 87:         userMessage,
 88:         isServer: true,
 89:         devMessage,
 90:       })
 91:     } else if (response.data) {
 92:       logger.info(`Successfully fetched ${response.data.length} items`)
 93:       return response.data
 94:     }
 95:     logger.info('Nothing returned from database')
 96:     return null
 97:   }
 98: 
 99:   return {
100:     server: handleServerError,
101:     client: handleError,
102:   }
103: }
```

## File: layers/crud/composables/user.current.store.ts
```typescript
  1: import { useLogger } from '@ib/logger'
  2: 
  3: const DOMAIN_KEY = 'currentUser'
  4: 
  5: export const useCurrentUser = defineStore(DOMAIN_KEY, () => {
  6:   const authUrl = useRuntimeConfig().public.aeAuthUrl
  7:   const logger = useLogger(DOMAIN_KEY)
  8:   const errors = useBaseError()
  9:   const loading = useLoadingStore()
 10:   const { fetch } = useBaseFetch()
 11:   const userId = useCookie('userId')
 12:   const user = useSupabaseUser()
 13: 
 14:   // check:critical - user should only be able to fetch their own full profile
 15:   // check:critical - user should only be able to update their own profile
 16:   // todo:high - allow user to update their profile info
 17:   // todo:med - merge currentUser and profile into one, store all required data everything in their session
 18:   // assign Posthog identify
 19: 
 20:   console.log('user', user.value)
 21: 
 22:   const profile = computed(() => ({
 23:     id: user.value?.id,
 24:     given_name: user.value?.user_metadata?.given_name,
 25:     email_confirmed_at: user.value?.email_confirmed_at,
 26:     confirmation_sent_at: user.value?.confirmation_sent_at,
 27:     confirmed_at: user.value?.confirmed_at,
 28:     created_at: user.value?.created_at,
 29:     surname: user.value?.user_metadata?.surname,
 30:     last_sign_in_at: user.value?.last_sign_in_at,
 31:     email: user.value?.email,
 32:     providers: user.value?.app_metadata.providers,
 33:     avatar: user.value?.user_metadata.avatar ?? user.value?.user_metadata.avatar_url,
 34:     provider: user.value?.provider,
 35:     user_role: user.value?.app_metadata?.role,
 36:     user_plan: user.value?.app_metadata?.plan,
 37:   }))
 38: 
 39:   // extract as util func
 40:   function hasValueChanged(newValue: any, currentValue: any): boolean {
 41:     console.log('hasValueChanged', newValue, currentValue)
 42:     if (
 43:       typeof newValue === 'string' ||
 44:       typeof newValue === 'boolean' ||
 45:       typeof newValue === 'number'
 46:     ) {
 47:       return newValue !== currentValue
 48:     } else if (Array.isArray(newValue)) {
 49:       return JSON.stringify(newValue) !== JSON.stringify(currentValue)
 50:     } else if (typeof newValue === 'object' && newValue !== null) {
 51:       return JSON.stringify(newValue) !== JSON.stringify(currentValue)
 52:     } else {
 53:       return newValue !== currentValue
 54:     }
 55:   }
 56: 
 57:   function cleanDataForUpdate(newData: any, previousData: any) {
 58:     const updatedData: any = {}
 59:     for (const key in newData) {
 60:       if (
 61:         Object.hasOwnProperty.call(newData, key) &&
 62:         hasValueChanged(newData[key], previousData[key])
 63:       ) {
 64:         updatedData[key] = newData[key]
 65:       }
 66:     }
 67: 
 68:     return { data: updatedData, noDataUpdated: Object.keys(updatedData).length === 0 }
 69:   }
 70: 
 71:   async function updateProfile(newData: any, isMock: boolean = false) {
 72:     logger.info('Starting updateProfile function', { newData, isMock })
 73:     const updatedData: any = {}
 74: 
 75:     logger.debug('Cleaning data for update')
 76:     // Compare newData with fullProfile and only include changed values
 77:     const { noDataUpdated, data } = cleanDataForUpdate(newData, profile.value)
 78: 
 79:     if (noDataUpdated) {
 80:       logger.info('No changes detected, no update necessary')
 81:       return
 82:     }
 83: 
 84:     logger.debug('Changes detected', { changedData: data })
 85: 
 86:     try {
 87:       logger.info('Sending update request to server')
 88:       let response
 89:       if (isMock) {
 90:         logger.info('Using mock API call')
 91:         // response = await mockApiCall(data)
 92:       } else {
 93:         response = await $fetch('/api/users/update', {
 94:           method: 'POST',
 95:           body: JSON.stringify(data),
 96:         })
 97:       }
 98:       logger.debug('Received response from server', { response })
 99: 
100:       const validData = errors.server({
101:         response,
102:         devOnly: false,
103:         devMessage: 'Error updating user profile',
104:         userMessage: 'There was an error updating your profile after action',
105:       })
106: 
107:       logger.info('Successfully validated server response', { validData })
108: 
109:       // update state
110:       logger.debug('Updating user profile state')
111:       for (const key in validData[0]) {
112:         if (Object.hasOwnProperty.call(validData[0], key)) {
113:           logger.debug(`Updating profile field: ${key}`, {
114:             newValue: validData[0][key],
115:           })
116:         }
117:       }
118:       logger.info('Profile update completed successfully')
119:     } catch (error) {
120:       logger.error('Error occurred during profile update', { error })
121:       throw error // Re-throw the error for the caller to handle
122:     }
123:   }
124: 
125:   // Test function
126:   async function testUpdateProfile() {
127:     const testCases = [
128:       { name: 'John Doe', email: 'john@example.com' },
129:       { name: 'Jane Doe', email: 'error@example.com' }, // This will trigger an error
130:       {}, // This should result in no update
131:     ]
132: 
133:     for (const testCase of testCases) {
134:       try {
135:         console.log('Testing with data:', testCase)
136:         await updateProfile(testCase, true) // Use mock API
137:         console.log('Test passed successfully')
138:       } catch (error) {
139:         console.error('Test failed:', error.message)
140:       }
141:       console.log('---')
142:     }
143:   }
144: 
145:   type FileType = 'avatar'
146:   async function uploadImage(fileType: FileType, blob: Blob) {
147:     // currentFileName is the current file name in the database eg. avatar-drew-macgibbon.jpg
148:     const formData = new FormData()
149:     formData.append('file', blob)
150: 
151:     const response = await $fetch('/api/users/insert/image', {
152:       method: 'POST',
153:       body: formData,
154:       params: {
155:         fileType,
156:         userId: userId.value,
157:       },
158:     })
159: 
160:     console.log('fileName', response)
161: 
162:     const fileName = errors.server({
163:       response,
164:       devOnly: false,
165:       devMessage: `Error uploading ${fileType} image`,
166:       userMessage: `There was an error uploading your ${fileType}`,
167:     })
168: 
169:     let newData = {}
170: 
171:     console.log('fileName', fileName)
172: 
173:     if (fileType === 'avatar') {
174:       newData = {
175:         avatar: fileName,
176:       }
177:     }
178: 
179:     updateProfile(newData)
180:   }
181: 
182:   // first check if the user has an avatar in their profile
183:   // if not, check if the user has an avatar in their identities
184:   // cycle through identities check identities_data for picture
185: 
186:   return {
187:     haveUserSession: computed(() => !!profile.value),
188:     isAdmin: computed(
189:       () => profile.value?.user_role === 'admin' || profile.value?.user_role === 'super_admin',
190:     ),
191:     registeredWithProvider: computed(() => profile.value?.provider),
192:     profile,
193:     uploadImage,
194:     updateProfile,
195:     testUpdateProfile,
196:   }
197: })
198: 
199: if (import.meta.hot) {
200:   import.meta.hot.accept(acceptHMRUpdate(useCurrentUser, import.meta.hot))
201: }
```

## File: layers/crud/server/utils/base.interface.ts
```typescript
 1: type DBTable = keyof Database['public']['Tables'] & keyof Database['public']['Views']
 2: type DBColumns<T extends DBTable> = keyof Tables<T>
 3: type TableSpecificColumns<T extends DBTable> = Partial<DBColumns<T>>
 4: 
 5: // full list of filters here: https://postgrest.org/en/v12/references/api/tables_views.html#operators
 6: 
 7: type FilterKey =
 8:   | 'eq'
 9:   | 'match'
10:   | 'neq'
11:   | 'not'
12:   | 'gte'
13:   | 'gt'
14:   | 'lt'
15:   | 'lte'
16:   | 'like'
17:   | 'ilike'
18:   | 'is'
19:   | 'in'
20:   | 'contains'
21:   | 'containedBy'
22:   | 'rangeGt'
23:   | 'rangeGte'
24:   | 'rangeLt'
25:   | 'rangeLte'
26:   | 'rangeAdjacent'
27:   | 'overlaps'
28:   | 'textSearch'
29: 
30: interface Pagination {
31:   page?: number
32:   limit?: number
33:   from: number
34:   to: number
35: }
36: 
37: export type GenericReturn<T> = Promise<T[] | T | null>
38: 
39: export type TableKey = keyof Database['public']['Tables'] | keyof Database['public']['Views']
40: 
41: export type FilterBy<T extends DBTable> = {
42:   columnName: TableSpecificColumns<T>
43:   operator: FilterKey
44:   value: string | boolean | number
45: }
46: 
47: type OrderBy<T extends DBTable> = {
48:   columnNames: TableSpecificColumns<T>[]
49:   ascending: boolean
50:   referenceTable?: string
51: }
52: 
53: type Conflict = {
54:   onConflict: string[]
55:   ignoreDuplicates: boolean
56:   count?: 'exact' | 'planned' | 'estimated'
57:   defaultToNull?: boolean
58: }
59: 
60: // todo: refactor to have options under select/insert/update/delete
61: // for instance we can group limit, pagination, selectStatement all under select
62: export interface BaseOperationInput<T, K extends DBTable> {
63:   tableName: K
64:   data?: T | T[]
65:   selectStatement?: string
66:   filterBy?: FilterBy<K> | false
67:   orderBy?: OrderBy<K> | false
68:   pagination?: Pagination | false
69:   limit?: number
70:   isSingle?: boolean
71:   isReturned?: boolean
72:   conflict?: Conflict
73: }
74: 
75: export interface SelectInput<T, K extends DBTable> extends BaseOperationInput<T, K> {
76:   selectStatement: string
77: }
78: 
79: export interface InsertInput<T, K extends DBTable> extends BaseOperationInput<T, K> {
80:   data: T | T[]
81: }
82: 
83: export interface UpsertInput<T, K extends DBTable> extends BaseOperationInput<T, K> {
84:   data: T | T[]
85:   conflict: Conflict
86: }
87: 
88: export interface UpdateInput<T, K extends DBTable> extends BaseOperationInput<T, K> {
89:   data: T | T[]
90:   filterBy: FilterBy<K>
91: }
92: 
93: export interface DeleteInput<T, K extends DBTable> extends BaseOperationInput<T, K> {
94:   data: T | T[]
95:   filterBy: FilterBy<K>
96: }
97: 
98: export type { Database, Tables, DBTable }
```

## File: layers/crud/nuxt.config.ts
```typescript
 1: export default defineNuxtConfig({
 2:   modules: ['@nuxtjs/supabase'],
 3: 
 4:   supabase: {
 5:     redirect: false,
 6:     clientOptions: {
 7:       auth: {
 8:         flowType: 'pkce',
 9:         detectSessionInUrl: true,
10:         persistSession: true,
11:         autoRefreshToken: true,
12:       },
13:     },
14:     cookieName: 'sb',
15:   },
16: })
```

## File: libs/logger/src/environment.d.ts
```typescript
 1: // src/environment.d.ts
 2: 
 3: declare global {
 4:   // Add Nuxt runtime config types
 5:   interface RuntimeConfig {
 6:     public: {
 7:       nodeEnv?: string
 8:       [key: string]: any
 9:     }
10:     [key: string]: any
11:   }
12: 
13:   // Add useRuntimeConfig function type
14:   type UseRuntimeConfig = () => RuntimeConfig
15: 
16:   const useRuntimeConfig: UseRuntimeConfig | undefined
17: }
18: 
19: export interface ImportMetaEnv {
20:   MODE: string
21:   DEV: boolean
22:   PROD: boolean
23:   [key: string]: any
24: }
25: 
26: export interface ImportMeta {
27:   url: string
28:   env: ImportMetaEnv
29:   readonly hot?: {
30:     accept: () => void
31:     dispose: () => void
32:     invalidate: () => void
33:     [key: string]: any
34:   }
35: }
36: 
37: export {}
```

## File: libs/logger/src/environment.ts
```typescript
 1: // src/environment.ts
 2: export const getEnvironment = () => {
 3:   // Check for Node.js environment more safely
 4:   const isNode = (() => {
 5:     try {
 6:       return typeof globalThis.process !== 'undefined' && !!globalThis.process?.versions?.node
 7:     } catch {
 8:       return false
 9:     }
10:   })()
11: 
12:   // Check for browser environment
13:   const isBrowser = (() => {
14:     try {
15:       return typeof window !== 'undefined'
16:     } catch {
17:       return false
18:     }
19:   })()
20: 
21:   // Check for development mode across different environments
22:   const isDev = (() => {
23:     try {
24:       // For Nuxt specific environment
25:       if (typeof globalThis.useRuntimeConfig === 'function') {
26:         const config = globalThis.useRuntimeConfig()
27:         return config.public.nodeEnv === 'development'
28:       }
29: 
30:       // Fallback checks
31:       return Boolean(
32:         import.meta?.env?.DEV ||
33:           import.meta?.env?.MODE === 'development' ||
34:           (typeof process !== 'undefined' && process.env.NODE_ENV === 'development'),
35:       )
36:     } catch {
37:       return false
38:     }
39:   })()
40: 
41:   return {
42:     isNode,
43:     isBrowser,
44:     isDev,
45:   }
46: }
```

## File: libs/logger/src/error-interface.ts
```typescript
  1: export interface ErrorMessage {
  2:   userMessage: string // User-friendly error message if needed
  3:   devMessage: string // Make bugfixing easy!
  4:   error: any
  5: }
  6: 
  7: export interface ErrorServer extends Omit<ErrorMessage, 'error'> {
  8:   featureRelated?: boolean // default false - log to feature-specific log
  9:   response: { data: any; error: any }
 10: }
 11: 
 12: // Retryable status codes with descriptions
 13: export const retryableStatusCodes: { [key: number]: string } = {
 14:   408: 'Request Timeout - The server timed out waiting for the request.',
 15:   409: 'Conflict - The request could not be completed due to a conflict with the current state of the target resource.',
 16:   425: 'Too Early - The server is unwilling to risk processing a request that might be replayed.',
 17:   500: 'Internal Server Error - The server encountered an unexpected condition that prevented it from fulfilling the request.',
 18:   502: 'Bad Gateway - The server, while acting as a gateway or proxy, received an invalid response from an inbound server.',
 19:   503: 'Service Unavailable - The server is currently unable to handle the request due to temporary overloading or maintenance of the server.',
 20:   504: 'Gateway Timeout - The server, while acting as a gateway or proxy, did not receive a timely response from an upstream server.',
 21: }
 22: 
 23: export enum ErrorSeverity {
 24:   LOW = 'low',
 25:   MEDIUM = 'medium',
 26:   HIGH = 'high',
 27:   CRITICAL = 'critical',
 28: }
 29: 
 30: export enum ErrorType {
 31:   UPLOAD_ERROR = 'UPLOAD_ERROR',
 32:   CONNECTION_ERROR = 'CONNECTION_ERROR',
 33:   AUTHENTICATION_ERROR = 'AUTHENTICATION_ERROR',
 34:   UNIQUE_VIOLATION = 'UNIQUE_VIOLATION',
 35:   FOREIGN_KEY_VIOLATION = 'FOREIGN_KEY_VIOLATION',
 36:   NOT_NULL_VIOLATION = 'NOT_NULL_VIOLATION',
 37:   CONSTRAINT_ERROR = 'CONSTRAINT_ERROR',
 38:   UNDEFINED_TABLE = 'UNDEFINED_TABLE',
 39:   UNDEFINED_PARAMETER = 'UNDEFINED_PARAMETER',
 40:   SYNTAX_ERROR = 'SYNTAX_ERROR',
 41:   DUPLICATE_ALIAS = 'DUPLICATE_ALIAS',
 42:   UNDEFINED_COLUMN = 'UNDEFINED_COLUMN',
 43:   DATA_EXCEPTION = 'DATA_EXCEPTION',
 44:   SERIALIZATION_FAILURE = 'SERIALIZATION_FAILURE',
 45:   DEADLOCK_DETECTED = 'DEADLOCK_DETECTED',
 46:   INSUFFICIENT_RESOURCES = 'INSUFFICIENT_RESOURCES',
 47:   RATE_LIMIT_ERROR = 'RATE_LIMIT_ERROR',
 48:   SERVER_ERROR = 'SERVER_ERROR',
 49:   UNKNOWN_ERROR = 'UNKNOWN_ERROR',
 50:   VALIDATION_ERROR = 'VALIDATION_ERROR',
 51:   NOT_FOUND_ERROR = 'NOT_FOUND_ERROR',
 52:   NETWORK_ERROR = 'NETWORK_ERROR',
 53: }
 54: 
 55: // Types
 56: export interface ErrorDetails {
 57:   type: ErrorType
 58:   message: string
 59:   severity: ErrorSeverity
 60:   stack?: string
 61:   code?: string | number
 62:   context?: string
 63:   pgError?: string
 64:   operation?: string
 65:   originalError?: any
 66: }
 67: 
 68: export interface ErrorHandlerOptions {
 69:   context?: string
 70:   userMessage?: string
 71:   devMessage?: string
 72:   throwError?: boolean
 73: }
 74: 
 75: export interface FetchErrorResponse {
 76:   data?: any
 77:   error?: any
 78: }
 79: 
 80: export function mapErrorSeverity(error: any): ErrorSeverity {
 81:   if (error.status >= 500) return ErrorSeverity.CRITICAL
 82:   if (error.status === 429) return ErrorSeverity.HIGH
 83: 
 84:   // Connection errors are critical
 85:   if (error.code?.startsWith('08')) return ErrorSeverity.CRITICAL
 86: 
 87:   // Authentication errors are high severity
 88:   if (error.code?.startsWith('28')) return ErrorSeverity.HIGH
 89: 
 90:   // Constraint violations are high severity
 91:   if (error.code?.startsWith('23')) return ErrorSeverity.HIGH
 92: 
 93:   // Query errors are medium severity
 94:   if (error.code?.startsWith('42')) return ErrorSeverity.MEDIUM
 95: 
 96:   // Data exceptions are medium severity
 97:   if (error.code?.startsWith('22')) return ErrorSeverity.MEDIUM
 98: 
 99:   // Transaction errors are high severity
100:   if (error.code === '40001' || error.code === '40P01') return ErrorSeverity.HIGH
101: 
102:   // System errors are critical
103:   if (error.code?.startsWith('53')) return ErrorSeverity.CRITICAL
104: 
105:   // Default to medium severity for unknown errors
106:   return ErrorSeverity.MEDIUM
107: }
108: 
109: export function mapErrorType(error: any): ErrorType {
110:   // Connection errors
111:   if (
112:     error.code === '08000' ||
113:     error.code === '08003' ||
114:     error.code === '08006' ||
115:     error.code === '08001' ||
116:     error.code === '08004'
117:   ) {
118:     return ErrorType.CONNECTION_ERROR
119:   }
120: 
121:   // Authentication errors
122:   if (error.code === '28000' || error.code === '28P01') {
123:     return ErrorType.AUTHENTICATION_ERROR
124:   }
125: 
126:   // Constraint violations
127:   if (error.code === '23505') return ErrorType.UNIQUE_VIOLATION
128:   if (error.code === '23503') return ErrorType.FOREIGN_KEY_VIOLATION
129:   if (error.code === '23502') return ErrorType.NOT_NULL_VIOLATION
130:   if (error.code?.startsWith('23') && !['23505', '23503', '23502'].includes(error.code))
131:     return ErrorType.CONSTRAINT_ERROR
132: 
133:   // Query errors
134:   if (error.code === '42P01') return ErrorType.UNDEFINED_TABLE
135:   if (error.code === '42P02') return ErrorType.UNDEFINED_PARAMETER
136:   if (error.code === '42601') return ErrorType.SYNTAX_ERROR
137:   if (error.code === '42P07') return ErrorType.DUPLICATE_ALIAS
138:   if (error.code === '42703') return ErrorType.UNDEFINED_COLUMN
139: 
140:   // Data errors
141:   if (error.code?.startsWith('22')) return ErrorType.DATA_EXCEPTION
142: 
143:   // Transaction errors
144:   if (error.code === '40001') return ErrorType.SERIALIZATION_FAILURE
145:   if (error.code === '40P01') return ErrorType.DEADLOCK_DETECTED
146: 
147:   // System errors
148:   if (
149:     error.code === '53000' ||
150:     error.code === '53100' ||
151:     error.code === '53200' ||
152:     error.code === '53300'
153:   ) {
154:     return ErrorType.INSUFFICIENT_RESOURCES
155:   }
156: 
157:   // HTTP-specific errors
158:   if (error.status === 429) return ErrorType.RATE_LIMIT_ERROR
159:   if (error.status >= 500) return ErrorType.SERVER_ERROR
160: 
161:   // Catch-all for unspecified errors
162:   return ErrorType.UNKNOWN_ERROR
163: }
164: 
165: export interface LogLevels {
166:   error: 0
167:   warn: 1
168:   info: 2
169:   http: 3
170:   verbose: 4
171:   debug: 5
172:   silly: 6
173: }
174: 
175: export class AppError extends Error {
176:   details: ErrorDetails
177: 
178:   constructor(details: ErrorDetails) {
179:     super(details.message)
180:     this.details = details
181:     this.name = 'AppError'
182:   }
183: }
184: 
185: export interface Logger {
186:   error: (message: string, ...args: any[]) => void
187:   warn: (message: string, ...args: any[]) => void
188:   info: (message: string, ...args: any[]) => void
189:   verbose: (message: string, ...args: any[]) => void
190:   debug: (message: string, ...args: any[]) => void
191:   silly: (message: string, ...args: any[]) => void
192:   http: (message: string, ...args: any[]) => void
193: }
```

## File: libs/logger/src/handler.ts
```typescript
  1: // utils/error-handler.ts
  2: import { createLogger } from './logger'
  3: import { getEnvironment } from './environment'
  4: import {
  5:   ErrorType,
  6:   ErrorSeverity,
  7:   AppError,
  8:   mapErrorType,
  9:   mapErrorSeverity,
 10:   retryableStatusCodes,
 11:   type ErrorHandlerOptions,
 12:   type FetchErrorResponse,
 13: } from './error-interface'
 14: 
 15: export class ErrorHandler {
 16:   private logger
 17:   private env = getEnvironment()
 18: 
 19:   constructor(private context = 'ErrorHandler') {
 20:     this.logger = createLogger(context)
 21:   }
 22: 
 23:   private determineErrorType(error: any): ErrorType {
 24:     if (error instanceof AppError) return error.details.type
 25:     return mapErrorType(error)
 26:   }
 27: 
 28:   private determineSeverity(error: any): ErrorSeverity {
 29:     if (error instanceof AppError) return error.details.severity
 30:     return mapErrorSeverity(error)
 31:   }
 32: 
 33:   private formatErrorMessage(options: {
 34:     userMessage?: string
 35:     devMessage: string
 36:     error: any
 37:   }): string {
 38:     const { userMessage, devMessage, error } = options
 39:     const devError = `${devMessage}: ${JSON.stringify(error)}`
 40:     this.logger.error(devError)
 41:     return this.env.isDev ? devError : userMessage || 'An unexpected error occurred'
 42:   }
 43: 
 44:   private normalizeError(error: Error | AppError, context?: string): AppError {
 45:     if (error instanceof AppError) {
 46:       return error
 47:     }
 48: 
 49:     const errorType = this.determineErrorType(error)
 50:     const severity = this.determineSeverity(error)
 51: 
 52:     return new AppError({
 53:       type: errorType,
 54:       message: error.message,
 55:       severity,
 56:       stack: error.stack,
 57:       context,
 58:       code: (error as any).code,
 59:       pgError: (error as any).details || (error as any).hint,
 60:       operation: context,
 61:       originalError: error,
 62:     })
 63:   }
 64: 
 65:   private getErrorStatusCode(errorType: ErrorType): number {
 66:     switch (errorType) {
 67:       case ErrorType.AUTHENTICATION_ERROR:
 68:         return 401
 69:       case ErrorType.VALIDATION_ERROR:
 70:         return 400
 71:       case ErrorType.NOT_FOUND_ERROR:
 72:         return 404
 73:       case ErrorType.RATE_LIMIT_ERROR:
 74:         return 429
 75:       case ErrorType.CONSTRAINT_ERROR:
 76:       case ErrorType.UNIQUE_VIOLATION:
 77:       case ErrorType.FOREIGN_KEY_VIOLATION:
 78:         return 409
 79:       default:
 80:         return 500
 81:     }
 82:   }
 83: 
 84:   handleError(error: Error | AppError, options: ErrorHandlerOptions = {}) {
 85:     const appError = this.normalizeError(error, options.context)
 86: 
 87:     this.logger.error(`${appError.details.type}: ${appError.message}`, {
 88:       ...appError.details,
 89:       stack: this.env.isDev ? appError.stack : undefined,
 90:     })
 91: 
 92:     // Handle server-side errors
 93:     if (this.env.isNode) {
 94:       const errorMessage = this.formatErrorMessage({
 95:         userMessage: options.userMessage || appError.message,
 96:         devMessage: options.devMessage || appError.details.type,
 97:         error: appError,
 98:       })
 99: 
100:       if (options.throwError) {
101:         const serverError = new Error()
102:         serverError.message = `SERVER ERROR: ${errorMessage}`
103:         ;(serverError as any).statusCode = this.getErrorStatusCode(appError.details.type)
104:         ;(serverError as any).statusMessage = appError.message
105:         ;(serverError as any).data = {
106:           error: {
107:             type: appError.details.type,
108:             message: appError.message,
109:             severity: appError.details.severity,
110:             details: this.env.isDev ? appError.details : undefined,
111:           },
112:         }
113:         throw serverError
114:       }
115:     }
116: 
117:     // Handle critical errors
118:     if (appError.details.severity === ErrorSeverity.CRITICAL) {
119:       // Add critical error handling logic
120:       this.handleCriticalError(appError)
121:     }
122: 
123:     return appError
124:   }
125: 
126:   handleFetchError({
127:     response,
128:     devMessage,
129:     userMessage,
130:   }: {
131:     response: FetchErrorResponse
132:     devMessage: string
133:     userMessage?: string
134:   }) {
135:     if (response.error) {
136:       this.logger.error(`FETCH Error: ${response.error}`)
137:       return this.handleError(response.error, { userMessage, devMessage })
138:     }
139: 
140:     if (response.data) {
141:       this.logger.info(
142:         `Successfully fetched ${Array.isArray(response.data) ? response.data.length : 1} items`,
143:       )
144:       return response.data
145:     }
146: 
147:     this.logger.info('Nothing returned from fetch')
148:     return this.handleError(new Error('No data found'), {
149:       userMessage: 'Resource not found',
150:       devMessage: 'Fetch returned empty response',
151:     })
152:   }
153: 
154:   handleDBError(response: FetchErrorResponse, context: string) {
155:     if (response.error) {
156:       return this.handleError(response.error, {
157:         context,
158:         devMessage: `Database error in ${context}`,
159:         userMessage: 'Database operation failed',
160:       })
161:     }
162:     return response.data
163:   }
164: 
165:   private handleCriticalError(error: AppError) {
166:     // Implement critical error handling
167:     this.logger.error('CRITICAL ERROR:', error.details)
168:     // Could trigger alerts, notifications, etc.
169:   }
170: }
171: 
172: // Factory function
173: export function createErrorHandler(context = 'ErrorHandler') {
174:   const handler = new ErrorHandler(context)
175: 
176:   return {
177:     handleError: handler.handleError.bind(handler),
178:     handleFetchError: handler.handleFetchError.bind(handler),
179:     handleDBError: handler.handleDBError.bind(handler),
180:   }
181: }
182: 
183: // Convenience function for framework integration
184: export const useErrorHandler = (context = 'ErrorHandler') => {
185:   return createErrorHandler(context)
186: }
```

## File: libs/logger/src/logger.ts
```typescript
  1: // utils/logger.ts
  2: import { createConsola } from 'consola'
  3: import type { ConsolaInstance } from 'consola'
  4: import type { Logger, LogLevels } from './error-interface'
  5: import { getEnvironment } from './environment'
  6: 
  7: export class BaseLogger implements Logger {
  8:   protected logger: ConsolaInstance | Logger
  9:   protected env = getEnvironment()
 10: 
 11:   constructor(tag = '') {
 12:     this.logger = createConsola({
 13:       level: this.env.isDev ? 10 : 3,
 14:       formatOptions: {
 15:         date: this.env.isNode,
 16:         colors: true,
 17:       },
 18:     }).withTag(tag.toUpperCase())
 19:   }
 20: 
 21:   error(message: string, ...args: any[]) {
 22:     this.logger.error(message, ...args)
 23:   }
 24: 
 25:   warn(message: string, ...args: any[]) {
 26:     this.logger.warn(message, ...args)
 27:   }
 28: 
 29:   info(message: string, ...args: any[]) {
 30:     this.logger.info(message, ...args)
 31:   }
 32: 
 33:   verbose(message: string, ...args: any[]) {
 34:     if (this.env.isDev) {
 35:       this.logger.verbose(message, ...args)
 36:     }
 37:   }
 38: 
 39:   debug(message: string, ...args: any[]) {
 40:     if (this.env.isDev) {
 41:       this.logger.debug(message, ...args)
 42:     }
 43:   }
 44: 
 45:   silly(message: string, ...args: any[]) {
 46:     if (this.env.isDev) {
 47:       this.logger.info(message, ...args)
 48:     }
 49:   }
 50: 
 51:   http(message: string, ...args: any[]) {
 52:     this.logger.info(message, ...args)
 53:   }
 54: }
 55: 
 56: let winstonPackage: typeof import('winston') | undefined = undefined
 57: 
 58: export class NodeLogger extends BaseLogger {
 59:   private winstonLogger: any
 60: 
 61:   constructor(tag = '') {
 62:     super(tag)
 63: 
 64:     if (this.env.isNode) {
 65:       this.initWinston(tag).catch((err) => {
 66:         this.logger.error('Failed to initialize Winston:', err)
 67:       })
 68:     }
 69:   }
 70: 
 71:   private async initWinston(tag: string) {
 72:     try {
 73:       if (!winstonPackage) {
 74:         winstonPackage = await import('winston')
 75:       }
 76: 
 77:       const format = winstonPackage.format.combine(
 78:         winstonPackage.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss:ms' }),
 79:         winstonPackage.format.cli(),
 80:         winstonPackage.format.printf(
 81:           (info) => `${info['timestamp']} ${info.level}: [${tag}] ${info.message}`,
 82:         ),
 83:       )
 84: 
 85:       this.winstonLogger = winstonPackage.createLogger({
 86:         levels: {
 87:           error: 0,
 88:           warn: 1,
 89:           info: 2,
 90:           http: 3,
 91:           verbose: 4,
 92:           debug: 5,
 93:           silly: 6,
 94:         },
 95:         level: this.env.isDev ? 'silly' : 'info',
 96:         format,
 97:         transports: [
 98:           new winstonPackage.transports.Console(),
 99:           ...(this.env.isDev
100:             ? []
101:             : [
102:                 new winstonPackage.transports.File({
103:                   filename: './data/logs/error.log',
104:                   level: 'error',
105:                 }),
106:                 new winstonPackage.transports.File({
107:                   filename: './data/logs/combined.log',
108:                 }),
109:               ]),
110:         ],
111:       })
112:     } catch (err) {
113:       this.logger.warn('Winston not available, falling back to console logger')
114:     }
115:   }
116: 
117:   override error(message: string, ...args: any[]) {
118:     if (this.winstonLogger) {
119:       this.winstonLogger.error(message, ...args)
120:     } else {
121:       super.error(message, ...args)
122:     }
123:   }
124: 
125:   override warn(message: string, ...args: any[]) {
126:     if (this.winstonLogger) {
127:       this.winstonLogger.warn(message, ...args)
128:     } else {
129:       super.warn(message, ...args)
130:     }
131:   }
132: 
133:   override info(message: string, ...args: any[]) {
134:     if (this.winstonLogger) {
135:       this.winstonLogger.info(message, ...args)
136:     } else {
137:       super.info(message, ...args)
138:     }
139:   }
140: 
141:   override verbose(message: string, ...args: any[]) {
142:     if (this.winstonLogger && this.env.isDev) {
143:       this.winstonLogger.verbose(message, ...args)
144:     } else {
145:       super.verbose(message, ...args)
146:     }
147:   }
148: 
149:   override debug(message: string, ...args: any[]) {
150:     if (this.winstonLogger && this.env.isDev) {
151:       this.winstonLogger.debug(message, ...args)
152:     } else {
153:       super.debug(message, ...args)
154:     }
155:   }
156: 
157:   override silly(message: string, ...args: any[]) {
158:     if (this.winstonLogger && this.env.isDev) {
159:       this.winstonLogger.silly(message, ...args)
160:     } else {
161:       super.silly(message, ...args)
162:     }
163:   }
164: 
165:   override http(message: string, ...args: any[]) {
166:     if (this.winstonLogger) {
167:       this.winstonLogger.http(message, ...args)
168:     } else {
169:       super.http(message, ...args)
170:     }
171:   }
172: }
173: 
174: // Factory function to create the appropriate logger
175: export const createLogger = (tag = '') => {
176:   const env = getEnvironment()
177:   return env.isNode ? new NodeLogger(tag) : new BaseLogger(tag)
178: }
179: 
180: // Async version for when we want to ensure Winston is loaded
181: export const createLoggerAsync = async (tag = '') => {
182:   const logger = createLogger(tag)
183:   if (logger instanceof NodeLogger) {
184:     // Wait for Winston to initialize if needed
185:     await new Promise((resolve) => setTimeout(resolve, 100))
186:   }
187:   return logger
188: }
189: 
190: // Framework-specific wrappers if needed
191: export const useLogger = (tag = '') => {
192:   return createLogger(tag)
193: }
194: 
195: export const useLoggerAsync = async (tag = '') => {
196:   return await createLoggerAsync(tag)
197: }
```

## File: libs/logger/index.d.ts
```typescript
1: import type { Consola } from 'consola'
2: 
3: export * from './src/environment.d'
4: 
5: export function useLogger(tag?: string): Consola
```

## File: libs/logger/index.ts
```typescript
1: export * from './src/logger'
2: export * from './src/handler'
3: export * from './src/error-interface'
```

## File: shared-runtime.config.ts
```typescript
 1: import { config } from 'dotenv'
 2: 
 3: config()
 4: 
 5: export default defineNuxtConfig({
 6:   runtimeConfig: {
 7:     public: {
 8:       strapiUrl: process.env.NUXT_PUBLIC_STRAPI_URL,
 9:       formbricksEnvironment: process.env.NUXT_PUBLIC_FORMBRICKS_ENVIRONMENT,
10:       formbricksHost: process.env.NUXT_PUBLIC_FORMBRICKS_HOST,
11:       supabaseUrl: process.env.NUXT_PUBLIC_SUPABASE_URL,
12:       supabaseKey: process.env.NUXT_PUBLIC_SUPABASE_KEY,
13:       aeAuthUrl: process.env.NUXT_PUBLIC_AE_AUTH_URL,
14:       aeLoginUrl: process.env.NUXT_PUBLIC_AE_LOGIN_URL,
15:       aeAppUrl: process.env.NUXT_PUBLIC_AE_APP_URL,
16:       aeAdminUrl: process.env.NUXT_PUBLIC_AE_ADMIN_URL,
17:       aeMonitoringUrl: process.env.NUXT_PUBLIC_AE_MONITORING_URL,
18:       aeWebsiteUrl: process.env.NUXT_PUBLIC_AE_WEBSITE_URL,
19:       nodeEnv: process.env.NUXT_PUBLIC_NODE_ENV,
20:       logLevel: process.env.NUXT_PUBLIC_LOG_LEVEL,
21:       posthogKey: process.env.NUXT_PUBLIC_POSTHOG_KEY,
22:       posthogUrl: process.env.NUXT_PUBLIC_POSTHOG_URL,
23:       studioTokens: process.env.NUXT_PUBLIC_STUDIO_TOKENS,
24:       scraperUrl: process.env.NUXT_PUBLIC_SCRAPER_URL,
25:       devHelper: {
26:         enabled: true,
27:         features: {
28:           networkErrorClassifier: true,
29:           infiniteLoopDetector: true,
30:           unhandledPromiseRejectionTracker: true,
31:           environmentConsistencyChecker: true,
32:         },
33:       },
34:     },
35:     strapiUrl: process.env.NUXT_STRAPI_URL,
36:     supabaseServiceKey: process.env.NUXT_SUPABASE_SERVICE_KEY,
37:     googleApiKey: process.env.NUXT_GOOGLE_API_KEY,
38:     nasaApiKey: process.env.NUXT_NASA_API_KEY,
39:     openaiApiKey: process.env.NUXT_OPENAI_API_KEY,
40:     openaiOrg: process.env.NUXT_OPENAI_ORG,
41:     redisFlushKey: process.env.NUXT_REDIS_FLUSH_KEY,
42:     scraperKey: process.env.NUXT_SCRAPER_KEY,
43:     razorpayKey: process.env.NUXT_RAZORPAY_KEY,
44:     razorpaySecret: process.env.NUXT_RAZORPAY_SECRET,
45:     razorpayTestKey: process.env.NUXT_RAZORPAY_TEST_KEY,
46:     razorpayTestSecret: process.env.NUXT_RAZORPAY_TEST_SECRET,
47:   },
48: })
```
