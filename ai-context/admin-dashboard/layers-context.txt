This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-11-21T14:47:21.468Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>

<additional_info>

For more information about Repomix, visit: https://github.com/yamadashy/repomix
</additional_info>

</file_summary>

<repository_structure>
layers/
  advert/
    .playground/
      app.config.ts
      nuxt.config.ts
    components/
      Advertisement.vue
    plugins/
      error-handler.ts
      sentry.server.ts
    server/
      api/
        advertisement/
          metrics.get.ts
          metrics.post.ts
    nuxt.config.ts
  auth/
    .playground/
      app.config.ts
      nuxt.config.ts
    composables/
      user.current.store.ts
    server/
      middleware/
        cors.ts
    nuxt.config.ts
  base/
    .playground/
      app.config.ts
      nuxt.config.ts
    components/
      image/
        ImageHero.vue
        ImageWithFallback.vue
      Background.vue
      Breadcrumbs.vue
      Glass.vue
      GlobalTimer.vue
      Grid.vue
      HelloWorld.vue
      HoverCard.vue
      Image.vue
      InfiniteScroll.vue
      Loader.vue
      Modal.vue
      NavHamburger.vue
      NewLabel.vue
      Pagination.vue
      Popover.vue
      Resizable.vue
      Sidebar.vue
      SideNav.vue
      SocialBlock.vue
      TabView.vue
      YT.client.vue
    composables/
      utils/
        arrays.ts
        hasValueChanged.ts
        objects.ts
        strings.ts
        time.ts
      ab-test.ts
      analytics.ts
      glass-card.ts
      metrics.ts
      modal.ts
      notification.ts
      settings.store.ts
      social.store.ts
      useMediaQuery.ts
      useNavigation.ts
      utils.ts
    plugins/
      error-handler.ts
      posthog.client.ts
      sentry.client.ts
    types/
      content.ts
      database.ts
      index.ts
      users.ts
    nuxt.config.ts
    supabase-provider.ts
  crud/
    .playground/
      app.config.ts
      nuxt.config.ts
    components/
      Feedback.vue
      Upload.vue
    composables/
      audit.ts
      delete.ts
      fetch.ts
      http-handler.ts
      insert.ts
      loading.store.ts
      local-storage.ts
      main.store.ts
      notification.ts
      pagination.store.ts
      rate-limit.ts
      select.ts
      settings.store.ts
      update.ts
      upload.ts
      useApiDataStore.ts
      useBaseError.ts
      user.current.store.ts
    server/
      utils/
        base.interface.ts
    nuxt.config.ts
</repository_structure>

<repository_files>
This section contains the contents of the repository's files.

<file path="layers/advert/.playground/app.config.ts">
export default defineAppConfig({
  myLayer: {
    name: 'My amazing Nuxt layer (overwritten)'
  }
})
</file>

<file path="layers/advert/.playground/nuxt.config.ts">
export default defineNuxtConfig({
  extends: ['..'],
  modules: ['@nuxt/eslint']
})
</file>

<file path="layers/advert/components/Advertisement.vue">
<script setup lang="ts">
import { useStorage } from '@vueuse/core'
import advertisements from '../assets/advertisements.json'

const showAds = ref(false)
const userShowAds = useStorage('userShowAds', true)

interface Advertisement {
  id: number
  title: string
  description: string
  imageUrl: string
  link: string
  active: boolean
}

interface AdMetric {
  adId: number
  impressions: number
  clicks: number
  uniqueViews: number // Changed to number
  deviceType: string
  viewTimes: number[]
}

const activeAds = ref<Advertisement[]>([])
const adMetrics = useStorage<Record<number, AdMetric>>('adMetrics', {})
const viewedAds = useStorage<Set<number>>('viewedAds', new Set())
const sendInterval = 10000 // 10 seconds

const loadActiveAds = () => {
  activeAds.value = advertisements.filter((ad) => ad.active).slice(0, 3)
}

const getDeviceType = () => {
  const userAgent = navigator.userAgent
  if (/mobile/i.test(userAgent)) return 'Mobile'
  if (/tablet/i.test(userAgent)) return 'Tablet'
  return 'Desktop'
}

const trackImpression = (adId: number) => {
  if (!adMetrics.value[adId]) {
    adMetrics.value[adId] = {
      adId,
      impressions: 0,
      clicks: 0,
      uniqueViews: 0,
      deviceType: getDeviceType(),
      viewTimes: [],
    }
  }
  adMetrics.value[adId].impressions++
  adMetrics.value[adId].viewTimes.push(Date.now())

  // Increment uniqueViews only if it's the first time this ad is viewed
  if (!viewedAds.value.has(adId)) {
    adMetrics.value[adId].uniqueViews++
    viewedAds.value.add(adId)
  }
}

const trackInteraction = (adId: number) => {
  if (adMetrics.value[adId]) {
    adMetrics.value[adId].clicks++
  }
}

const sendMetrics = async () => {
  const metricsToSend = JSON.parse(JSON.stringify(adMetrics.value))

  try {
    // Send metrics to admin server (not implemented)
    await $fetch('/api/advertisement/metrics', {
      method: 'POST',
      body: { metrics: metricsToSend },
    })

    console.log('Metrics sent successfully')
    // Clear the local metrics after successful send
    adMetrics.value = {}
  } catch (error) {
    console.error('Failed to send metrics:', error)
  }
}

const intervalId = ref(null as NodeJS.Timeout | null)
onMounted(() => {
  intervalId.value = setInterval(sendMetrics, sendInterval)
  loadActiveAds()
  activeAds.value.forEach((ad) => trackImpression(ad.id))
})

watch(
  activeAds,
  (newAds) => {
    newAds.forEach((ad) => trackImpression(ad.id))
  },
  { deep: true },
)

onUnmounted(() => {
  clearInterval(intervalId.value!)
  sendMetrics() // Send any remaining metrics before unmounting
})
</script>

<template>
  <aside class="mx-auto min-h-72 w-72 space-y-4 p-4">
    <div class="mb-4 flex items-center justify-between">
      <label
        for="show-ads-toggle"
        class="pr-2 text-sm"
      >
        Toggle Ads
      </label>
      <PrimeToggleSwitch
        v-model="showAds"
        input-id="show-ads-toggle"
      />
    </div>
    <div
      v-for="ad in activeAds"
      :key="ad.id"
      class="border-color overflow-hidden rounded-lg"
      :class="!showAds ? '' : 'border'"
    >
      <a
        :href="showAds ? ad.link : undefined"
        target="_blank"
        rel="noopener noreferrer"
        class="block h-full w-full"
        :class="{ invisible: !showAds }"
        @click="trackInteraction(ad.id)"
      >
        <div class="max-h-72 w-full">
          <NuxtImg
            v-if="showAds"
            :src="ad.imageUrl"
            :alt="ad.title"
            class="w-full object-cover"
          />
        </div>
        <div class="p-4">
          <h3
            v-if="showAds"
            class="text-lg font-semibold"
          >
            {{ ad.title }}
          </h3>
          <p
            v-if="showAds"
            class="text-sm"
          >
            {{ ad.description }}
          </p>
        </div>
      </a>
    </div>
  </aside>
</template>
</file>

<file path="layers/advert/plugins/error-handler.ts">
import { useErrorHandler } from '@ib/logger'

export default defineNuxtPlugin((nuxtApp) => {
  const { handleError } = useErrorHandler()

  // Set up global error handlers
  if (import.meta.client) {
    window.addEventListener('error', (event) => {
      handleError(event.error, 'Uncaught Exception')
    })

    window.addEventListener('unhandledrejection', (event) => {
      handleError(event.reason, 'Unhandled Promise Rejection')
    })
  }
})
</file>

<file path="layers/advert/plugins/sentry.server.ts">
export default defineNuxtPlugin(() => {
  const environment = useRuntimeConfig().public.nodeEnv
})
</file>

<file path="layers/advert/server/api/advertisement/metrics.get.ts">
import { promises as fs } from 'fs'
import { resolve } from 'path'
import { defineEventHandler } from 'h3'

interface AdMetric {
  adId: number
  impressions: number
  clicks: number
  uniqueViews: number
  deviceType: string
  viewTimes: number[]
}

const adMetricsFilePath = resolve(process.cwd(), 'data', 'advertising', 'metrics.json')

export default defineEventHandler(async (event) => {
  try {
    const data = await fs.readFile(adMetricsFilePath, 'utf-8')
    const metrics: AdMetric[] = JSON.parse(data)

    // Calculate additional metrics
    const processedMetrics = Object.values(metrics).map((metric: AdMetric) => {
      const ctr = metric.impressions > 0 ? (metric.clicks / metric.impressions) * 100 : 0
      const frequency = metric.impressions / metric.uniqueViews
      const timeOfDay = metric.viewTimes.map((time) => new Date(time).getHours())

      return {
        ...metric,
        ctr: ctr.toFixed(2) + '%',
        frequency: frequency.toFixed(2),
        timeOfDay: timeOfDay.reduce(
          (acc, hour) => {
            acc[hour] = (acc[hour] || 0) + 1
            return acc
          },
          {} as Record<number, number>,
        ),
      }
    })

    return processedMetrics
  } catch (error) {
    console.error('Error reading ad metrics:', error)
    throw createError({
      statusCode: 500,
      statusMessage: 'Failed to read ad metrics',
    })
  }
})
</file>

<file path="layers/advert/server/api/advertisement/metrics.post.ts">
import { promises as fs } from 'fs'
import { resolve } from 'path'
import { defineEventHandler, readBody } from 'h3'

const adMetricsFilePath = resolve(process.cwd(), 'data', 'advertising', 'metrics.json')

interface AdMetric {
  adId: number
  impressions: number
  clicks: number
  uniqueViews: number
  deviceType: string
  viewTimes: number[]
}

let batchedMetrics: Record<number, AdMetric> = {}
let lastWriteTime = Date.now()
const WRITE_INTERVAL = 60000 // 1 minute

const writeMetricsToFile = async () => {
  try {
    let existingMetrics: Record<number, AdMetric> = {}
    try {
      const data = await fs.readFile(adMetricsFilePath, 'utf-8')
      existingMetrics = JSON.parse(data)
    } catch (error) {
      console.warn('No existing ad metrics found:', error)
      // File doesn't exist yet, start with empty object
    }

    // Merge batched metrics with existing metrics
    for (const [adId, metric] of Object.entries(batchedMetrics)) {
      if (!existingMetrics[adId]) {
        existingMetrics[adId] = metric
      } else {
        existingMetrics[adId].impressions += metric.impressions
        existingMetrics[adId].clicks += metric.clicks
        existingMetrics[adId].uniqueViews += metric.uniqueViews
        existingMetrics[adId].viewTimes.push(...metric.viewTimes)
      }
    }

    await fs.writeFile(adMetricsFilePath, JSON.stringify(existingMetrics, null, 2), 'utf-8')
    batchedMetrics = {} // Clear batched metrics after writing
    lastWriteTime = Date.now()
  } catch (error) {
    console.error('Error writing ad metrics:', error)
  }
}

export default defineEventHandler(async (event) => {
  const body = await readBody(event)
  const { metrics } = body as { metrics: Record<number, AdMetric> }

  if (!metrics) {
    return { success: false, message: 'No ad metrics received' }
  }

  console.log('Received ad metrics:', metrics)
  // Merge incoming metrics with batched metrics
  for (const [adId, metric] of Object.entries(metrics)) {
    if (!batchedMetrics[adId]) {
      batchedMetrics[adId] = metric
    } else {
      batchedMetrics[adId].impressions += metric.impressions
      batchedMetrics[adId].clicks += metric.clicks
      batchedMetrics[adId].uniqueViews += metric.uniqueViews
      batchedMetrics[adId].viewTimes.push(...metric.viewTimes)
    }
  }

  // Check if it's time to write to file
  if (Date.now() - lastWriteTime > WRITE_INTERVAL) {
    await writeMetricsToFile()
  }

  return { success: true, message: 'Ad metrics received and batched' }
})
</file>

<file path="layers/advert/nuxt.config.ts">
import { defineNuxtConfig } from 'nuxt/config'

export default defineNuxtConfig({
  workspaceDir: '../../',
  srcDir: '.',
})
</file>

<file path="layers/auth/.playground/app.config.ts">
export default defineAppConfig({
  myLayer: {
    name: 'My amazing Nuxt layer (overwritten)'
  }
})
</file>

<file path="layers/auth/.playground/nuxt.config.ts">
export default defineNuxtConfig({
  extends: ['..'],
  modules: ['@nuxt/eslint']
})
</file>

<file path="layers/auth/composables/user.current.store.ts">
import { useLogger } from '@ib/logger'

const DOMAIN_KEY = 'currentUser'

export const useCurrentUser = defineStore(DOMAIN_KEY, () => {
  const authUrl = useRuntimeConfig().public.aeAuthUrl
  const logger = useLogger(DOMAIN_KEY)
  const errors = useBaseError()
  const loading = useLoadingStore()
  const { fetch } = useBaseFetch()
  const userId = useCookie('userId')
  const user = useSupabaseUser()

  // check:critical - user should only be able to fetch their own full profile
  // check:critical - user should only be able to update their own profile
  // todo:high - allow user to update their profile info
  // todo:med - merge currentUser and profile into one, store all required data everything in their session
  // assign Posthog identify

  console.log('user', user.value)

  const profile = computed(() => ({
    id: user.value?.id,
    given_name: user.value?.user_metadata?.given_name,
    email_confirmed_at: user.value?.email_confirmed_at,
    confirmation_sent_at: user.value?.confirmation_sent_at,
    confirmed_at: user.value?.confirmed_at,
    created_at: user.value?.created_at,
    surname: user.value?.user_metadata?.surname,
    last_sign_in_at: user.value?.last_sign_in_at,
    email: user.value?.email,
    providers: user.value?.app_metadata.providers,
    avatar: user.value?.user_metadata.avatar || user.value?.user_metadata.avatar_url,
    provider: user.value?.provider,
    user_role: user.value?.app_metadata?.role,
    user_plan: user.value?.app_metadata?.plan,
  }))

  // extract as util func
  function hasValueChanged(newValue: any, currentValue: any): boolean {
    console.log('hasValueChanged', newValue, currentValue)
    if (
      typeof newValue === 'string' ||
      typeof newValue === 'boolean' ||
      typeof newValue === 'number'
    ) {
      return newValue !== currentValue
    } else if (Array.isArray(newValue)) {
      return JSON.stringify(newValue) !== JSON.stringify(currentValue)
    } else if (typeof newValue === 'object' && newValue !== null) {
      return JSON.stringify(newValue) !== JSON.stringify(currentValue)
    } else {
      return newValue !== currentValue
    }
  }

  function cleanDataForUpdate(newData: any, previousData: any) {
    const updatedData: any = {}
    for (const key in newData) {
      if (
        Object.hasOwnProperty.call(newData, key) &&
        hasValueChanged(newData[key], previousData[key])
      ) {
        updatedData[key] = newData[key]
      }
    }

    return { data: updatedData, noDataUpdated: Object.keys(updatedData).length === 0 }
  }

  async function updateProfile(newData: any, isMock: boolean = false) {
    logger.info('Starting updateProfile function', { newData, isMock })
    const updatedData: any = {}
    const toast = useNotification()

    logger.debug('Cleaning data for update')
    // Compare newData with fullProfile and only include changed values
    const { noDataUpdated, data } = cleanDataForUpdate(newData, profile.value)

    if (noDataUpdated) {
      logger.info('No changes detected, no update necessary')
      return
    }

    logger.debug('Changes detected', { changedData: data })

    try {
      logger.info('Sending update request to server')
      let response
      if (isMock) {
        logger.info('Using mock API call')
        // response = await mockApiCall(data)
      } else {
        response = await $fetch('/api/users/update', {
          method: 'POST',
          body: JSON.stringify(data),
        })
      }
      logger.debug('Received response from server', { response })

      const validData = errors.server({
        response,
        devOnly: false,
        devMessage: 'Error updating user profile',
        userMessage: 'There was an error updating your profile after action',
      })

      if (response.error) {
        toast.error({ summary: 'Could not update profile', message: response.error.message })
        return
      } else {
        toast.success({
          summary: 'Profile updated successfully',
          message: 'Your profile was updated',
        })
      }

      logger.info('Successfully validated server response', { validData })

      // update state
      logger.debug('Updating user profile state')
      for (const key in data) {
        if (Object.hasOwnProperty.call(data, key)) {
          profile.value[key] = data[key]
          logger.debug(`Updating profile field: ${key}`, {
            newValue: data[key],
          })
        }
      }
      logger.info('Profile update completed successfully')
    } catch (error) {
      logger.error('Error occurred during profile update', { error })
      throw error // Re-throw the error for the caller to handle
    }
  }

  // Test function
  async function testUpdateProfile() {
    const testCases = [
      { name: 'John Doe', email: 'john@example.com' },
      { name: 'Jane Doe', email: 'error@example.com' }, // This will trigger an error
      {}, // This should result in no update
    ]

    for (const testCase of testCases) {
      try {
        console.log('Testing with data:', testCase)
        await updateProfile(testCase, true) // Use mock API
        console.log('Test passed successfully')
      } catch (error) {
        console.error('Test failed:', error.message)
      }
      console.log('---')
    }
  }

  type FileType = 'avatar'
  async function uploadImage(fileType: FileType, blob: Blob) {
    // currentFileName is the current file name in the database eg. avatar-drew-macgibbon.jpg
    const formData = new FormData()
    formData.append('file', blob)

    const response = await $fetch('/api/users/insert/image', {
      method: 'POST',
      body: formData,
      params: {
        fileType,
        userId: userId.value,
      },
    })

    console.log('fileName', response)

    const fileName = errors.server({
      response,
      devOnly: false,
      devMessage: `Error uploading ${fileType} image`,
      userMessage: `There was an error uploading your ${fileType}`,
    })

    let newData = {}

    console.log('fileName', fileName)

    if (fileType === 'avatar') {
      newData = {
        avatar: fileName,
      }
    }

    updateProfile(newData)
  }

  // first check if the user has an avatar in their profile
  // if not, check if the user has an avatar in their identities
  // cycle through identities check identities_data for picture

  return {
    haveUserSession: computed(() => !!profile.value),
    isAdmin: computed(
      () => profile.value?.user_role === 'admin' || profile.value?.user_role === 'super_admin',
    ),
    registeredWithProvider: computed(() => profile.value?.provider),
    profile,
    uploadImage,
    updateProfile,
    testUpdateProfile,
  }
})

if (import.meta.hot) {
  import.meta.hot.accept(acceptHMRUpdate(useCurrentUser, import.meta.hot))
}
</file>

<file path="layers/auth/server/middleware/cors.ts">
import { defineEventHandler, getRequestHeader, setResponseHeaders } from 'h3'

export default defineEventHandler((event) => {
  const allowedDomains = ['astronera.org', 'up.railway.app', 'rlwy.net', 'localhost']

  const origin = getRequestHeader(event, 'origin') || ''

  const isAllowedOrigin = allowedDomains.some(
    (domain) =>
      origin.startsWith('http://localhost:') || // Allow any localhost port
      origin.endsWith(`.${domain}`) || // Allow all subdomains
      origin === `https://${domain}`, // Allow apex domain
  )

  if (isAllowedOrigin || process.env.NODE_ENV !== 'production') {
    setResponseHeaders(event, {
      'Access-Control-Allow-Methods': 'GET,HEAD,PUT,PATCH,POST,DELETE',
      'Access-Control-Allow-Origin': origin,
      'Access-Control-Allow-Credentials': 'true',
      'Access-Control-Allow-Headers': 'Content-Type, Authorization, X-Requested-With',
      'Access-Control-Expose-Headers': 'Content-Length, X-JSON',
    })
  }

  console.log('CORS', origin, isAllowedOrigin)

  if (event.method === 'OPTIONS') {
    event.node.res.statusCode = 204
    event.node.res.statusMessage = 'No Content.'
    return 'OK'
  }
})
</file>

<file path="layers/auth/nuxt.config.ts">
import { fileURLToPath } from 'url'
import { dirname, join, resolve } from 'path'
import { defineNuxtConfig } from 'nuxt/config'
import tsconfigPaths from 'vite-tsconfig-paths'

const currentDir = dirname(fileURLToPath(import.meta.url))

console.log('Node Env:', process.env.NODE_ENV)

export default defineNuxtConfig({
  workspaceDir: '../../',
  srcDir: '.',

  modules: ['@nuxtjs/supabase'],

  supabase: {
    redirect: false,
    clientOptions: {
      auth: {
        flowType: 'pkce',
        detectSessionInUrl: true,
        persistSession: true,
        autoRefreshToken: true,
      },
    },
    cookieOptions: {
      domain:
        process.env.NODE_ENV === 'production'
          ? 'astronera.org' // This will work for all subdomains
          : 'localhost',
      maxAge: 60 * 60 * 8,
      path: '/',
      sameSite: 'lax',
      secure: process.env.NODE_ENV === 'production' ? true : false,
    },
    cookieName: 'sb',
  },
})
</file>

<file path="layers/base/.playground/app.config.ts">
export default defineAppConfig({
  myLayer: {
    name: 'My amazing Nuxt layer (overwritten)',
  },
})
</file>

<file path="layers/base/.playground/nuxt.config.ts">
export default defineNuxtConfig({
  extends: ['..'],
  modules: ['@nuxt/eslint'],
})
</file>

<file path="layers/base/components/image/ImageHero.vue">
<script setup lang="ts">
import type { TitleType, ImageType } from '../../types/content'

defineProps({
  fit: {
    type: String,
    default: 'cover',
  },
  objectPosition: {
    type: String,
    default: 'center',
  },
  title: {
    type: Object as () => TitleType,
    required: true,
  },
  img: {
    type: Object as () => ImageType,
    required: true,
  },
})

// consider turning the images into short videos using AI
// consider using mix-blend-mode for cool text effect with video
</script>

<template>
  <div class="relative flex items-center justify-center">
    <IBImage
      :img="{
        src: img.src,
        alt: img.alt,
        width: img.width,
        height: img.height,
      }"
      :class="`w-full object-${fit} ${objectPosition} h-screen`"
    />
    <div
      class="absolute z-10 flex flex-col items-center justify-center gap-8 px-4 text-white lg:flex-row lg:gap-16 xl:px-8"
    >
      <slot />
      <div class="flex flex-col gap-4">
        <h2
          :class="`rounded-md bg-black/30 px-4 py-1 text-3xl font-bold shadow-xl lg:text-5xl xl:px-8 text-${title.centered ? 'center' : 'left'}`"
        >
          {{ title.main }}
        </h2>
        <p
          v-if="title.subtitle"
          :class="`inline-block w-auto max-w-2xl rounded-sm px-4 pb-4 text-xl font-semibold lg:text-3xl xl:px-8 text-${title.centered ? 'center' : 'left'}`"
        >
          {{ title.subtitle }}
        </p>
      </div>
    </div>
    <div class="absolute left-0 top-0 h-full w-full bg-black/50" />
  </div>
</template>

<style scoped></style>
</file>

<file path="layers/base/components/image/ImageWithFallback.vue">
<script setup lang="ts">
interface Image {
  src: string
  alt: string | null
  caption: string | null
  credit: string | null
}

interface Options {
  width: number
  height: number
  sizes: string | undefined | null
  quality: number | undefined | null
}

defineProps({
  image: {
    type: Object as () => Image | undefined,
    default: undefined,
  },
  options: {
    type: Object as () => Options | undefined,
    default: () => ({
      width: 50,
      height: 50,
      sizes: null,
      quality: 80,
    }),
  },
})
</script>

<template>
  <div class="relative h-full w-full overflow-hidden rounded-md object-cover">
    <IBImage
      :img="{
        src: image?.src || 'hero-image.jpg',
        alt: image?.alt || 'this is a default fallback for when an image is not present',
        width: options?.width || 60,
        height: options?.height || 37,
        quality: options?.quality || 80,
      }"
      class="h-full w-full object-cover"
    />
    <div
      v-if="!image?.src"
      class="absolute left-0 top-0 z-50 flex h-full w-full items-center justify-center bg-black/40"
    >
      <h3 class="foreground rounded-lg px-3 py-1 text-base"> NO IMAGE </h3>
    </div>
  </div>
</template>
</file>

<file path="layers/base/components/Background.vue">
<template>
  <canvas
    ref="canvas"
    class="w-full h-full"
  />
</template>

<script setup lang="ts">
const CANVAS_WIDTH = computed(() => (window ? window.innerWidth : 0))
const CANVAS_HEIGHT = computed(() => (window ? window.innerHeight + 800 : 0))
const STAR_COUNT = 300 // Number of stars
const COLORS = ['#ffffff', '#ffcccb', '#add8e6'] // White, red, blue

// Refs
const canvas = ref<HTMLCanvasElement | null>(null)
let ctx: CanvasRenderingContext2D | null = null
let animationFrameId: number

// Utility function to get random number within a range
function getRandom(min: number, max: number): number {
  return Math.random() * (max - min) + min
}

// Create stars array
const stars = Array.from({ length: STAR_COUNT }, () => ({
  x: getRandom(0, CANVAS_WIDTH.value),
  y: getRandom(0, CANVAS_HEIGHT.value),
  radius: getRandom(0.5, 2),
  color: COLORS[Math.floor(Math.random() * COLORS.length)],
  speed: 0.01, // Speed of movement
  initialX: 0,
  initialY: 0,
}))

// Initialize star positions
stars.forEach((star) => {
  star.initialX = star.x
  star.initialY = star.y
})

// Draw stars on canvas
function drawStars() {
  if (!ctx) {
    return
  }

  ctx.clearRect(0, 0, CANVAS_WIDTH.value, CANVAS_HEIGHT.value)

  stars.forEach((star) => {
    ctx.beginPath()
    ctx.arc(star.x, star.y, star.radius, 0, 2 * Math.PI, false)
    ctx.fillStyle = star.color
    ctx.shadowColor = star.color
    ctx.shadowBlur = 8
    ctx.fill()
    ctx.closePath()

    // Update star position to follow an inverted arc path
    star.x -= star.speed
    star.y =
      star.initialY - Math.sin((star.x / CANVAS_WIDTH.value) * Math.PI) * (CANVAS_HEIGHT.value / 4)

    // Wrap stars around edges
    if (star.x < 0) {
      star.x = CANVAS_WIDTH.value
      star.initialY = getRandom(0, CANVAS_HEIGHT.value)
    }
  })

  // Request next animation frame
  animationFrameId = requestAnimationFrame(drawStars)
}

// Set up canvas and start animation
onMounted(() => {
  if (canvas.value) {
    canvas.value.width = CANVAS_WIDTH.value
    canvas.value.height = CANVAS_HEIGHT.value
    ctx = canvas.value.getContext('2d')
    if (ctx) {
      ctx.fillStyle = 'black'
      ctx.fillRect(0, 0, CANVAS_WIDTH.value, CANVAS_HEIGHT.value)
      drawStars()
    }
  }
})

// Clean up animation on component unmount
onBeforeUnmount(() => {
  cancelAnimationFrame(animationFrameId)
})
</script>

<style scoped>
canvas {
  width: 100vw;
  height: 120vh;
}
</style>
</file>

<file path="layers/base/components/Breadcrumbs.vue">
<script lang="ts" setup>
const route = useRoute()

const generateBreadcrumbs = (path: string) => {
  const pathParts = path.split('/').filter(Boolean)
  let currentPath = ''
  return pathParts.map((part) => {
    currentPath += `/${part}`
    return {
      to: currentPath,
      label: part.charAt(0).toUpperCase() + part.slice(1),
      ariaLabel: part.charAt(0).toUpperCase() + part.slice(1),
    }
  })
}

const links = computed(() => generateBreadcrumbs(route.path))

// Prepare links by filtering and adjusting labels
const formattedLinks = computed(() => {
  if (!links.value) return []
  console.log('Formatting links', links.value)
  return links.value
    .map((link) => {
      if (!link) return null // Skip if link is undefined or null

      // Filter out the home link if in app route
      if (link.to === '/') {
        console.log('Filtering out home link', link)
        return null
      }

      // Special handling for the 'astrotribe' path
      if (link.to === '/') {
        return { ...link, label: 'Home', ariaLabel: 'Home' }
      }

      if (link.to === '/ask') {
        return { ...link, label: 'Q&A', ariaLabel: 'Q&A' }
      }

      return link // Return unmodified link
    })
    .filter(Boolean) // Remove null entries
})
</script>

<template>
  <PrimeBreadcrumb
    v-if="formattedLinks.length"
    :model="formattedLinks"
    :pt="{
      root: 'foreground p-0 flex items-center justify-start',
      menu: '!mb-0',
    }"
  >
    <template #item="{ item }">
      <NuxtLink :to="item.to">
        <span
          class="text-primary font-semibold"
          :class="item.current ? 'link-active' : ''"
        >
          {{ item.label }}
        </span>
      </NuxtLink>
    </template>
  </PrimeBreadcrumb>
</template>

<style></style>
</file>

<file path="layers/base/components/Glass.vue">
<script setup lang="ts">
const uniqueId = useId()

const tailwindColors = [
  'slate',
  'gray',
  'zinc',
  'neutral',
  'stone',
  'red',
  'orange',
  'amber',
  'yellow',
  'lime',
  'green',
  'emerald',
  'teal',
  'cyan',
  'sky',
  'blue',
  'indigo',
  'violet',
  'purple',
  'fuchsia',
  'pink',
  'rose',
  'primary', // Assuming you have a custom 'primary' color
] as const

type TailwindColor = (typeof tailwindColors)[number]

const props = defineProps({
  color: { type: String as PropType<TailwindColor>, default: 'slate' },
  bgOpacity: { type: Number, default: 20 },
  gradientOpacity: { type: Number, default: 10 },
  blurIntensity: { type: String, default: 'md' },
  disableHover: { type: Boolean, default: false },
  padding: { type: String, default: '6' },
  loading: { type: Boolean, default: false },
  ariaLabel: { type: String, default: 'Glass card' },
})

const cardRef = ref<HTMLElement | null>(null)
const gravityAreaRef = ref<HTMLElement | null>(null)

const {
  handleMouseMove,
  handleMouseLeave,
  cardStyle,
  spotlightStyle,
  bgClasses,
  borderClasses,
  textClasses,
  gradientClasses,
  hoverClasses,
} = useGlassCard(props, uniqueId)
</script>

<template>
  <div
    :id="uniqueId"
    class="relative"
  >
    <div
      ref="gravityAreaRef"
      class="pointer-events-none absolute -inset-[30%] z-0"
    ></div>
    <div
      ref="cardRef"
      :class="[
        'glass-card relative overflow-hidden rounded-md shadow-xl',
        'ring-2 ring-inset ring-white/10',
        `backdrop-blur-${blurIntensity}`,
        `p-${padding}`,
        bgClasses,
        borderClasses,
        textClasses,
        ...hoverClasses,
      ]"
      :style="cardStyle"
      role="region"
      :aria-label="ariaLabel"
      @mousemove="(e) => handleMouseMove(e)"
      @mouseleave="handleMouseLeave"
    >
      <div class="glass-card-content relative z-20">
        <slot name="header"></slot>
        <slot></slot>
      </div>
      <div
        :class="['absolute inset-0 z-10 h-full w-full bg-gradient-to-br', gradientClasses]"
      ></div>
      <div
        class="glass-effect"
        :style="spotlightStyle"
      ></div>
      <div
        v-if="loading"
        class="animate-shimmer absolute inset-0 bg-gradient-to-r from-transparent via-white/10 to-transparent"
      ></div>
    </div>
  </div>
</template>

<style scoped>
.glass-card {
  transition: all 0.3s ease;
}

.glass-effect {
  position: absolute;
  inset: 0;
  pointer-events: none;
  transition: opacity 0.2s;
}

.glass-card-content {
  transition: transform 0.3s ease;
}

.glass-card:hover .glass-card-content {
  transform: translateY(-5px);
}

@keyframes shimmer {
  0% {
    transform: translateX(-100%);
  }
  100% {
    transform: translateX(100%);
  }
}

.animate-shimmer {
  animation: shimmer 1.5s infinite;
}

.spotlight {
  backdrop-filter: blur(2px) contrast(1.2);
  mix-blend-mode: overlay;
}
</style>
</file>

<file path="layers/base/components/GlobalTimer.vue">
<script setup lang="ts">
const isVisible = ref(true)
const isTracking = ref(false)
const elapsedTime = ref(0)
const currentTask = ref('')
let timer: NodeJS.Timeout | null = null
let startTime: number
let pausedTime = 0

function startTimer() {
  if (!import.meta.client) return

  if (!isTracking.value) {
    isTracking.value = true
    startTime = Date.now() - pausedTime
    timer = setInterval(() => {
      elapsedTime.value = Math.floor((Date.now() - startTime) / 1000)
    }, 1000)
  }
}

function pauseTimer() {
  if (isTracking.value) {
    isTracking.value = false
    if (timer) {
      clearInterval(timer)
      timer = null
    }
    pausedTime = Date.now() - startTime
  }
}

function stopTimer() {
  isTracking.value = false
  isVisible.value = false
  if (timer) {
    clearInterval(timer)
    timer = null
  }
  elapsedTime.value = 0
  pausedTime = 0
  currentTask.value = ''
}

function showTimer(taskTitle: string) {
  currentTask.value = taskTitle
  isVisible.value = true
  startTimer()
}

function formatTime(seconds: number) {
  const hours = Math.floor(seconds / 3600)
  const minutes = Math.floor((seconds % 3600) / 60)
  const secs = seconds % 60
  return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`
}

onUnmounted(() => {
  if (timer) clearInterval(timer)
})

defineExpose({
  showTimer,
  stopTimer,
})
</script>

<template>
  <div
    v-if="isVisible"
    class="flex items-center gap-2 rounded-lg bg-gray-800 p-2 text-white shadow-lg"
  >
    <div class="text-sm font-bold">
      {{ currentTask }}
    </div>
    <div class="text-xl"> ⏱️ {{ formatTime(elapsedTime) }} </div>
    <div class="flex space-x-2">
      <PrimeButton
        v-if="!isTracking"
        size="small"
        class="rounded-full bg-green-500 p-2 hover:bg-green-600"
        @click="startTimer"
      >
        <Icon
          name="mdi:play"
          size="24px"
        />
      </PrimeButton>
      <PrimeButton
        v-else
        size="small"
        class="rounded-full bg-yellow-500 p-2 hover:bg-yellow-600"
        @click="pauseTimer"
      >
        <Icon
          name="mdi:pause"
          size="24px"
        />
      </PrimeButton>
      <PrimeButton
        size="small"
        class="rounded-full bg-red-500 p-2 hover:bg-red-600"
        @click="stopTimer"
      >
        <Icon
          name="mdi:stop"
          size="24px"
        />
      </PrimeButton>
    </div>
  </div>
</template>
</file>

<file path="layers/base/components/Grid.vue">
<script setup lang="ts"></script>

<template>
  <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 2xl:grid-cols-4 md:gap-4 xl:gap-8">
    <slot />
  </div>
</template>

<style scoped></style>
</file>

<file path="layers/base/components/HelloWorld.vue">
<script setup lang="ts">
const { myLayer } = useAppConfig()
</script>

<template>
  <div>
    <h1>Hello World!</h1>
    <pre>{{ myLayer }}</pre>
  </div>
</template>
</file>

<file path="layers/base/components/HoverCard.vue">
<script setup lang="ts">
const enableHoverEffect = ref(false)
const hoverPosition = ref(null as null | 'up' | 'down') // 'up', 'center', or 'down'

function checkHoverPosition(event) {
  if (!enableHoverEffect.value) {
    return // Do nothing if hover effects are disabled
  }
  const rect = event.target.getBoundingClientRect()
  const halfScreen = window.innerHeight / 2
  if (rect.top < halfScreen) {
    console.log('top')
    // If the card is in the top third, expand downwards
    hoverPosition.value = 'down'
  } else {
    console.log('bottom')
    // If the card is in the bottom third, expand upwards
    hoverPosition.value = 'up'
  }
}

const checkScreenSize = () => {
  enableHoverEffect.value = window.innerWidth >= 1024 // Tailwind's 'lg' breakpoint
}

const paddingSize = computed(() => (window.innerWidth >= 1280 ? 32 : 16))

onMounted(() => {
  window.addEventListener('resize', checkScreenSize)
  checkScreenSize()
  return () => window.removeEventListener('resize', checkScreenSize)
})

// ui:med:easy:1 - if there is only one card in the grid row, we need to set min h of 100% to prevent the card from collapsing
</script>

<template>
  <div
    class="group relative hover:z-50"
    @mouseenter="checkHoverPosition"
    @mouseleave="hoverPosition = null"
  >
    <div
      :class="[
        'transition-all duration-300 delay-200 p-4 border-b-2 md:border border-color overflow-hidden background',
        'flex flex-col gap-4 w-full h-full md:rounded-md md:shadow-md',
        {
          'lg:group-hover:absolute': enableHoverEffect && !!hoverPosition,
          'top-0': enableHoverEffect && hoverPosition === 'down',
          'bottom-0': enableHoverEffect && hoverPosition === 'up',
        },
      ]"
      :style="{
        height: enableHoverEffect && !!hoverPosition ? `calc(200% + ${paddingSize}px)` : '100%',
      }"
    >
      <slot></slot>
    </div>
  </div>
</template>

<style scoped>
/* Extra styles if needed */
</style>
</file>

<file path="layers/base/components/Image.vue">
<script lang="ts" setup>
const uuid = useId()

const props = defineProps({
  img: {
    type: Object,
    required: true,
  },
  noShrink: {
    type: Boolean,
    default: false,
  },
})

const imageUrl = ref(null)

watch(
  () => props.img.src,
  (newVal) => {
    imageUrl.value = newVal
  },
  { immediate: true },
)

function loadFallbackImage(error: Error) {
  console.error('Image loading error:', error)
  imageUrl.value = `images/defaults/${props.img.type ?? 'fallback'}.jpg`
}
</script>

<template>
  <NuxtImg
    v-if="imageUrl"
    :key="`image-${uuid}`"
    v-bind="$attrs"
    :src="imageUrl"
    :alt="img.alt"
    :width="img.width"
    :height="img.height"
    :format="img.format"
    :quality="img.quality"
    :loading="img.loading"
    crossorigin="anonymous"
    :class="{ 'flex shrink-0': !noShrink }"
    @error="loadFallbackImage"
  />
</template>
</file>

<file path="layers/base/components/InfiniteScroll.vue">
<script setup lang="ts">
const emit = defineEmits(['update:scrollEnd'])
const scrollContainer = ref<HTMLElement | null>(null)
const observer = ref<IntersectionObserver | null>(null)

onMounted(() => {
  if ('IntersectionObserver' in window) {
    observer.value = new IntersectionObserver(
      (entries) => {
        if (entries[0].isIntersecting) {
          emit('update:scrollEnd')
        }
      },
      {
        root: null,
        rootMargin: '200px', // Load more content when within 200px of the bottom
        threshold: 0.1, // Trigger when at least 10% of the target is visible
      },
    )

    if (scrollContainer.value) {
      observer.value.observe(scrollContainer.value)
    }
  } else {
    // Fallback for browsers that don't support IntersectionObserver
    window.addEventListener('scroll', handleScroll)
  }
})

onUnmounted(() => {
  if (observer.value && scrollContainer.value) {
    observer.value.unobserve(scrollContainer.value)
  }
  window.removeEventListener('scroll', handleScroll)
})

const handleScroll = () => {
  if (scrollContainer.value) {
    const rect = scrollContainer.value.getBoundingClientRect()
    if (rect.top <= window.innerHeight) {
      emit('update:scrollEnd')
    }
  }
}
</script>

<template>
  <div>
    <slot />
    <div
      ref="scrollContainer"
      class="h-10 bg-transparent"
      aria-hidden="true"
    />
  </div>
</template>
</file>

<file path="layers/base/components/Loader.vue">
<script setup lang="ts">
const loaderWidth = ref('100%')
const loaderHeight = ref('100%')

defineProps({
  width: {
    type: String,
    default: '100%',
  },
  height: {
    type: String,
    default: '100%',
  },
})
</script>

<template>
  <div
    class="skeleton-loader"
    :style="{ width: loaderWidth, height: loaderHeight }"
  ></div>
</template>

<style scoped>
.skeleton-loader {
  background-color: #f3f3f3;
  animation: skeleton-loading 1s infinite linear;
}

@keyframes skeleton-loading {
  0% {
    background-position: -200px 0;
  }
  100% {
    background-position: 200px 0;
  }
}
</style>
</file>

<file path="layers/base/components/Modal.vue">
<script setup lang="ts">
const isOpen = ref(false)

const toggleModalOpen = () => {
  isOpen.value = !isOpen.value
}

const options = ref({
  isOpen,
  toggleModalOpen,
})
</script>

<template>
  <div>
    <slot
      name="button"
      v-bind="options"
    />
    <PrimeDialog
      v-model:visible="isOpen"
      modal
      :pt="{
        root: 'max-w-2xl w-full',
        content: 'w-full aspect-square',
      }"
      :pt-options="{ mergeProps: true, mergeSections: true }"
    >
      <template #header>
        <slot name="modal:header" />
      </template>
      <slot name="modal:default" />
      <template #footer>
        <slot
          name="modal:footer"
          v-bind="options"
        />
      </template>
    </PrimeDialog>
  </div>
</template>

<style scoped></style>
</file>

<file path="layers/base/components/NavHamburger.vue">
<!-- components/nav/NavHamburger.vue -->
<template>
  <button
    class="md:hidden p-2 hover:bg-gray-800 rounded-lg transition-colors flex"
    @click="toggleMobileNav"
  >
    <Icon
      :name="isMobileSidebarOpen ? 'mdi:close' : 'mdi:menu'"
      size="24px"
    />
  </button>
</template>

<script setup lang="ts">
const { isMobileSidebarOpen } = useNavigation()

const toggleMobileNav = () => {
  isMobileSidebarOpen.value = !isMobileSidebarOpen.value
}
</script>
</file>

<file path="layers/base/components/NewLabel.vue">
<script setup lang="ts">
const props = defineProps({
  date: {
    type: String,
    required: true,
  },
  maxAge: {
    type: Number,
    required: true,
  },
})

const isWithinNumberOfDays = computed(() => {
  const currentDate = new Date()
  const itemDate = new Date(props.date)
  const differenceInDays = Math.floor(
    (currentDate.getTime() - itemDate.getTime()) / (1000 * 3600 * 24),
  )
  return differenceInDays <= props.maxAge
})
</script>

<template>
  <PrimeTag
    v-if="isWithinNumberOfDays"
    severity="success"
    value="NEW"
  />
</template>
</file>

<file path="layers/base/components/Pagination.vue">
<script setup>
import { onMounted, ref } from 'vue'
import { useRoute } from 'vue-router'

// todo:high:1 - implement and test on component

const route = useRoute()
const slug = route.params.slug // Dynamic slug based on the current route
const items = ref([])
const currentPage = ref(1)

// Store and restore pagination state using session storage
const sessionStorageKey = `pagination-${slug}`

function restoreState() {
  const savedState = sessionStorage.getItem(sessionStorageKey)
  if (savedState) {
    const state = JSON.parse(savedState)
    currentPage.value = state.currentPage
    items.value = state.items
  }
}

function storeState() {
  const state = {
    currentPage: currentPage.value,
    items: items.value,
  }
  sessionStorage.setItem(sessionStorageKey, JSON.stringify(state))
}

async function fetchItems() {
  // Placeholder function to simulate fetching items
  const newItems = [{ id: Date.now(), content: `Item ${currentPage.value}` }]
  items.value.push(...newItems)
  currentPage.value += 1
  storeState()
}

function loadMore() {
  fetchItems()
}

onMounted(() => {
  restoreState()
  if (items.value.length === 0) {
    fetchItems()
  }
})
</script>

<template>
  <div>
    <ul v-if="items.length">
      <li
        v-for="item in items"
        :key="item.id"
      >
        {{ item.content }}
      </li>
    </ul>
    <button @click="loadMore"> Load More </button>
  </div>
</template>
</file>

<file path="layers/base/components/Popover.vue">
<script setup lang="ts">
const props = defineProps({
  buttonLabel: { type: String, required: true },
})

const popover = ref(null)

const toggle = (event) => {
  popover.value?.toggle(event)
}
</script>

<template>
  <div>
    <PrimeButton
      type="button"
      size="small"
      severity="secondary"
      :label="buttonLabel"
      @click="toggle"
    />
    <PrimePopover ref="popover">
      <slot></slot>
    </PrimePopover>
  </div>
</template>

<style scoped></style>
</file>

<file path="layers/base/components/Resizable.vue">
<script lang="ts" setup>
const props = defineProps<{
  slots: Record<string, string>
}>()

const container = ref<HTMLElement | null>(null)
const resizer = ref<HTMLElement | null>(null)
const sizes = ref<number[]>([1, 1])

const startResize = (e: MouseEvent) => {
  e.preventDefault()
  window.addEventListener('mousemove', resize)
  window.addEventListener('mouseup', stopResize)
}

const resize = (e: MouseEvent) => {
  if (!container.value) return
  const containerRect = container.value.getBoundingClientRect()
  const newLeftWidth = e.clientX - containerRect.left
  const containerWidth = containerRect.width

  sizes.value = [newLeftWidth / containerWidth, 1 - newLeftWidth / containerWidth]
}

const stopResize = () => {
  window.removeEventListener('mousemove', resize)
  window.removeEventListener('mouseup', stopResize)
}

onMounted(() => {
  if (resizer.value) {
    resizer.value.addEventListener('mousedown', startResize)
  }
})

onUnmounted(() => {
  if (resizer.value) {
    resizer.value.removeEventListener('mousedown', startResize)
  }
  window.removeEventListener('mousemove', resize)
  window.removeEventListener('mouseup', stopResize)
})
</script>

<template>
  <div
    ref="container"
    class="relative flex h-full w-full"
  >
    <div
      v-for="(componentId, index) in Object.values(slots)"
      :key="componentId"
      :class="['overflow-auto', index === 0 ? 'pr-4' : 'pl-4']"
      :style="{ flex: sizes[index] }"
    >
      <slot :name="componentId"></slot>
    </div>
    <div
      ref="resizer"
      class="w-2 cursor-col-resize bg-gray-200 hover:bg-gray-300"
      @mousedown="startResize"
    ></div>
  </div>
</template>

<style scoped>
/* Add any additional styles here */
</style>
</file>

<file path="layers/base/components/Sidebar.vue">
<script setup lang="ts">
const isSideVisible = ref(true)
</script>

<template>
  <div class="top-0 space-y-4 p-8 md:sticky">
    <div class="flex flex-col justify-center md:justify-start">
      <div class="flex gap-4">
        <!-- <PrimeToggleButton
          v-model="isSideVisible"
          on-label="Hide"
          off-label="Show"
        >
          <Icon :name="isSideVisible ? 'mdi:eye' : 'mdi:sun'" />
        </PrimeToggleButton> -->
        <!-- <Transition name="slide-fade">
          <PrimeMessage
            v-show="isSideVisible"
            severity="info"
            :pt="{ root: '', text: 'text-sm text-left' }"
          >
            Filters Coming Soon
          </PrimeMessage>
        </Transition> -->
      </div>
    </div>
  </div>
</template>

<style scoped>
/*
  Enter and leave animations can use different
  durations and timing functions.
*/
.slide-fade-enter-active {
  transition: all 0.3s ease-out;
}

.slide-fade-leave-active {
  transition: all 0.8s cubic-bezier(1, 0.5, 0.8, 1);
}

.slide-fade-enter-from,
.slide-fade-leave-to {
  transform: translateX(-20px);
  opacity: 0;
}

.slide-top-enter-active {
  transition: all 0.3s ease-out;
}

.slide-top-leave-active {
  transition: all 0.8s cubic-bezier(1, 0.5, 0.8, 1);
}

.slide-top-enter-from,
.slide-top-leave-to {
  transform: translateY(-20px);
  opacity: 0;
}
</style>
</file>

<file path="layers/base/components/SideNav.vue">
<script setup lang="ts">
const props = defineProps({
  categories: {
    type: Array,
    required: true,
  },
  showDevHelpers: {
    type: Boolean,
    default: false,
  },
  isMobile: {
    type: Boolean,
    default: false,
  },
  isSidebarOpen: {
    type: Boolean,
    required: true,
  },
  isMobileSidebarOpen: {
    type: Boolean,
    required: true,
  },
})

const route = useRoute()
const emit = defineEmits(['update:isSidebarOpen', 'update:isMobileSidebarOpen'])
// Handle navigation - close mobile nav when navigating
const handleNavigation = () => {
  if (props.isMobile) {
    emit('update:isMobileSidebarOpen', false)
  }
}

// Watch route changes to close mobile nav
watch(
  () => route.path,
  () => {
    if (props.isMobile) {
      emit('update:isMobileSidebarOpen', false)
    }
  },
)
</script>

<template>
  <div class="relative z-50">
    <!-- Mobile Overlay -->
    <div
      v-if="isMobile"
      class="fixed inset-0 z-[90] bg-black/50 transition-opacity duration-300"
      :class="
        isMobileSidebarOpen ? 'opacity-100 pointer-events-auto' : 'opacity-0 pointer-events-none'
      "
      @click="$emit('update:isMobileSidebarOpen', false)"
    />
    <div
      class="flex flex-col background text-gray-300 shadow-lg transition-all duration-300 group"
      :class="[
        // Shared styles
        'h-full',

        // Mobile styles
        isMobile && [
          'fixed left-0 top-0 bottom-0 z-[100]',
          'w-[70vw]',
          isMobileSidebarOpen ? 'translate-x-0' : '-translate-x-full',
        ],

        // Desktop styles
        !isMobile && ['relative', 'md:translate-x-0', isSidebarOpen ? 'md:w-60' : 'md:w-14'],
      ]"
    >
      <!-- Toggle button (desktop only) -->
      <button
        v-if="!isMobile"
        class="absolute !z-[1000] -right-3 top-24 hidden h-6 w-6 -translate-y-1/2 items-center justify-center rounded-full bg-primary-600 text-gray-300 transition-opacity duration-300 hover:bg-primary-400 group-hover:opacity-100 md:flex"
        :class="[
          'z-[110]', // Ensure button is above other elements
          isSidebarOpen ? 'opacity-0' : 'opacity-100',
        ]"
        :title="isSidebarOpen ? 'Collapse sidebar' : 'Expand sidebar'"
        @click="$emit('update:isSidebarOpen', !isSidebarOpen)"
      >
        <Icon
          :name="isSidebarOpen ? 'mdi:chevron-left' : 'mdi:chevron-right'"
          size="12px"
        />
      </button>

      <div class="flex h-full flex-col overflow-hidden">
        <!-- Logo -->
        <div
          class="flex items-center px-4 py-3 transition-all duration-300"
          :class="isMobile || isSidebarOpen ? 'gap-3' : 'justify-center'"
        >
          <div
            class="flex items-center justify-center rounded-md border bg-white transition-all duration-300 delay-150"
            :class="isMobile || isSidebarOpen ? 'h-10 w-10' : 'h-6 w-6'"
          >
            <NuxtLink
              to="/"
              class="flex h-full w-full items-center justify-center"
            >
              <IBImage
                :img="{ src: '/astronera-logo.jpg', width: 36, height: 36 }"
                class="h-full w-full transition-all duration-300"
                :class="isMobile || isSidebarOpen ? 'p-0.5' : 'p-1'"
                no-shrink
              />
            </NuxtLink>
          </div>
          <Transition
            enter-active-class="transition-all duration-150 ease-out"
            leave-active-class="transition-all duration-150 ease-in"
            enter-from-class="opacity-0 -translate-x-4"
            leave-to-class="opacity-0 -translate-x-4"
          >
            <div
              v-if="isMobile || isSidebarOpen"
              class="flex cursor-pointer flex-col items-start justify-center text-sm font-bold uppercase leading-none tracking-normal"
            >
              Astron
              <strong class="font-extrabold text-primary-400">Era</strong>
            </div>
          </Transition>
        </div>

        <!-- Navigation Categories - always expanded on mobile -->
        <nav class="flex-1 space-y-4 px-2 py-4">
          <div
            v-for="category in categories"
            :key="category.id"
            class="space-y-1"
          >
            <div
              v-if="isMobile || isSidebarOpen"
              class="px-2 text-xs font-semibold uppercase text-gray-400"
            >
              {{ category.label }}
            </div>
            <ul>
              <li
                v-for="item in category.items"
                :key="item.slug"
              >
                <NuxtLink
                  :to="item.slug"
                  class="flex items-center rounded-lg px-2 py-2 text-sm font-medium hover:bg-primary-700"
                  :class="{ 'bg-primary-800': route.path === item.slug }"
                  @click="handleNavigation"
                >
                  <Icon
                    :name="item.icon"
                    size="20px"
                    class="mr-3 flex-shrink-0"
                  />
                  <span v-if="isMobile || isSidebarOpen">{{ item.label }}</span>
                </NuxtLink>
              </li>
            </ul>
          </div>
        </nav>
      </div>
    </div>
  </div>
</template>

<style>
.transition-transform {
  transition-property: transform, width, height;
}
</style>
</file>

<file path="layers/base/components/SocialBlock.vue">
<script setup lang="ts">
interface Socials {
  [key: string]: string
}

const props = defineProps({
  socials: {
    type: Object as PropType<Socials>,
    required: true,
  },
  size: {
    type: String,
    default: '24px',
  },
})

const socialIcon = (platform: string) => {
  switch (platform) {
    case 'linkedin':
      return 'mdi:linkedin'
    case 'youtube':
      return 'mdi:youtube'
    case 'instagram':
      return 'mdi:instagram'
    case 'facebook':
      return 'mdi:facebook'
    case 'twitter':
      return 'mdi:twitter'
    default:
      return ''
  }
}

const formattedSocials = computed(() => {
  if (!props.socials) return []
  return Object.entries(props.socials).map(([platform, url]) => {
    return {
      platform: platform.split('_')[0],
      url,
      icon: socialIcon(platform.split('_')[0]),
    }
  })
})
</script>

<template>
  <div
    v-if="formattedSocials.length > 0"
    class="flex gap-2"
  >
    <a
      v-for="social in formattedSocials"
      :key="`${social.platform}-icon`"
      class="flex cursor-pointer items-center"
      target="_blank"
      :href="social.url"
    >
      <Icon
        :name="social.icon"
        :size="size"
      />
    </a>
  </div>
</template>

<style scoped></style>
</file>

<file path="layers/base/components/TabView.vue">
<script setup lang="ts">
interface Tab {
  title: string
  slotName: string
  value: string
}

defineProps<{
  tabs: Tab[]
}>()
</script>

<template>
  <PrimeTabs
    value="0"
    class="h-full"
    scrollable
    :pt="{
      root: 'w-full h-full',
    }"
    :pt-options="{ mergeSections: true }"
  >
    <PrimeTabList
      :pt="{
        root: 'gap-4 sticky top-0 left-0 z-50 flex text-nowrap flex-grow w-full overflow-scroll bg-black no-scrollbar border-b border-color',
      }"
      :pt-options="{ mergeSections: true, mergeProps: true }"
    >
      <PrimeTab
        v-for="tab in tabs"
        :key="tab.title"
        :value="tab.value"
        :pt="{
          root: ({ context }) => ({
            class: [
              'text-nowrap px-6 py-4 border-x border-color h-full',
              { 'bg-primary-900': context.active },
            ],
          }),
        }"
        :pt-options="{ mergeSections: true, mergeProps: true }"
      >
        {{ tab.title }}
      </PrimeTab>
    </PrimeTabList>
    <PrimeTabPanel
      v-for="tab in tabs"
      :key="`tab-index-${tab.title}`"
      :value="tab.value"
      :pt="{
        root: 'overflow-scroll h-full',
      }"
      :pt-options="{ mergeProps: true, mergeSections: true }"
    >
      <slot :name="tab.slotName" />
    </PrimeTabPanel>
  </PrimeTabs>
</template>

<style></style>
</file>

<file path="layers/base/components/YT.client.vue">
<template>
  <div id="player"></div>
</template>

<script setup lang="ts">
const player = ref(null)

onMounted(() => {
  // Load the YouTube IFrame API dynamically if it's not already loaded
  if (!window.YT) {
    // Check if YT object is already present
    const tag = document.createElement('script')
    tag.src = 'https://www.youtube.com/iframe_api'
    const firstScriptTag = document.getElementsByTagName('script')[0]
    firstScriptTag.parentNode.insertBefore(tag, firstScriptTag)

    // Define the callback globally to initialize player when API is ready
    window.onYouTubeIframeAPIReady = initializePlayer
  } else {
    // Initialize the player immediately if YT is already loaded
    initializePlayer()
  }
})

function initializePlayer() {
  // Make sure the YT object and YT.Player are defined
  if (typeof YT !== 'undefined' && YT.Player) {
    player.value = new YT.Player('player', {
      // Ensure the element ID matches your template
      height: '390',
      width: '640',
      listType: 'user_uploads',
      list: 'Fireship', // Make sure 'Fireship' is a correct videoId or replace it with a valid one
      events: {
        onReady: onPlayerReady,
      },
    })
  }
}

function onPlayerReady(event) {
  event.target.playVideo()
}

onBeforeUnmount(() => {
  if (player.value) {
    player.value.destroy()
  }
})
</script>
</file>

<file path="layers/base/composables/utils/arrays.ts">
export const removeDuplicates = <T>(arr: T[]): T[] => [...new Set(arr)]

export const sortBy = <T, K extends keyof T>(arr: T[], key: K): T[] =>
  arr.sort((a, b) => (a[key] > b[key] ? 1 : a[key] < b[key] ? -1 : 0))
</file>

<file path="layers/base/composables/utils/hasValueChanged.ts">
export function deepEqual(obj1: any, obj2: any): boolean {
  if (obj1 === obj2) {
    return true
  }

  if (typeof obj1 !== 'object' || typeof obj2 !== 'object' || obj1 === null || obj2 === null) {
    return false
  }

  if (Array.isArray(obj1) && Array.isArray(obj2)) {
    if (obj1.length !== obj2.length) {
      return false
    }
    for (let i = 0; i < obj1.length; i++) {
      if (!deepEqual(obj1[i], obj2[i])) {
        return false
      }
    }
    return true
  }

  if (Array.isArray(obj1) || Array.isArray(obj2)) {
    return false // One is an array, the other is not
  }

  const keys1 = Object.keys(obj1)
  const keys2 = Object.keys(obj2)

  if (keys1.length !== keys2.length) {
    return false
  }

  for (const key of keys1) {
    if (!keys2.includes(key) || !deepEqual(obj1[key], obj2[key])) {
      return false
    }
  }

  return true
}

export function hasValueChanged(newValue: any, currentValue: any): boolean {
  if (
    typeof newValue === 'string'
    || typeof newValue === 'boolean'
    || typeof newValue === 'number'
    || newValue === null
  ) {
    return newValue !== currentValue
  }

  if (Array.isArray(newValue) || typeof newValue === 'object') {
    return !deepEqual(newValue, currentValue)
  }

  return newValue !== currentValue
}

interface UpdateData {
  [key: string]: any
}

interface CleanDataResult {
  data: UpdateData
  noDataUpdated: boolean
}

export function wasRowDataUpdated(newData: UpdateData, previousData: UpdateData): CleanDataResult {
  const updatedData: UpdateData = {}

  Object.entries(newData).forEach(([key, value]) => {
    if (hasValueChanged(value, previousData[key])) {
      updatedData[key] = value
    }
  })

  return { data: updatedData, noDataUpdated: Object.keys(updatedData).length === 0 }
}
</file>

<file path="layers/base/composables/utils/objects.ts">
export const pluck = <T, K extends keyof T>(objs: T[], key: K): T[K][] =>
  objs.map((obj) => obj[key])
</file>

<file path="layers/base/composables/utils/strings.ts">
export const slugify = (str: string): string => {
  str = str.replace(/^\s+|\s+$/g, '')
  str = str.toLowerCase()

  const from
    = 'ÁÄÂÀÃÅČÇĆĎÉĚËÈÊẼĔȆÍÌÎÏŇÑÓÖÒÔÕØŘŔŠŤÚŮÜÙÛÝŸŽáäâàãåčçćďéěëèêẽĕȇíìîïňñóöòôõøðřŕšťúůüùûýÿžþÞĐđßÆa·/_,:;'
  const to
    = 'AAAAAACCCDEEEEEEEEIIIINNOOOOOORRSTUUUUUYYZaaaaaacccdeeeeeeeeiiiinnooooooorrstuuuuuyyzbBDdBAa------'
  for (let i = 0, l = from.length; i < l; i++) {
    str = str.replace(new RegExp(from.charAt(i), 'g'), to.charAt(i))
  }

  str = str
    .replace(/[^a-z0-9 -]/g, '')
    .replace(/\s+/g, '-')
    .replace(/-+/g, '-')
  return str
}

export function upperCaseFirstLetter(str: string): string {
  const firstLetter = str.slice(0, 1)
  return firstLetter.toUpperCase() + str.substring(1)
}

export const stringIsNull = (value: any): boolean =>
  value === null || value === undefined || value === '' || value.length === 0
</file>

<file path="layers/base/composables/utils/time.ts">
export function toDateObject(inputDate = '2022-03-01T10:30:00-05:00') {
  // !todo - add support for internationalization
  // !todo - add support for dynamic length
  const length = 'short'
  // convert date to local time
  const date = new Date(inputDate.toLocaleString())

  const formattedDate = new Intl.DateTimeFormat('en-US', {
    weekday: length,
    year: 'numeric',
    month: length,
    day: 'numeric',
    hour: 'numeric',
    minute: 'numeric',
    timeZoneName: length,
  }).format(date)

  const dateArray = formattedDate.split(', ')

  return {
    weekday: dateArray[0],
    month: dateArray[1].split(' ')[0],
    day: dateArray[1].split(' ')[1],
    time: dateArray[3].split(' ')[0],
    ampm: dateArray[3].split(' ')[1],
    timezone: dateArray[3].split(' ')[2],
    year: dateArray[2],
  }
}

export function lastSeen(lastSeenTimestamp: string): string {
  const now = new Date()
  const lastSeen = new Date(lastSeenTimestamp)
  const secondsSinceLastSeen = Math.round((now.getTime() - lastSeen.getTime()) / 1000)

  if (secondsSinceLastSeen < 60) {
    return `${secondsSinceLastSeen} second${secondsSinceLastSeen === 1 ? '' : 's'} ago`
  }

  const minutesSinceLastSeen = Math.round(secondsSinceLastSeen / 60)

  if (minutesSinceLastSeen < 60) {
    return `${minutesSinceLastSeen} minute${minutesSinceLastSeen === 1 ? '' : 's'} ago`
  }

  const hoursSinceLastSeen = Math.round(minutesSinceLastSeen / 60)

  if (hoursSinceLastSeen < 24) {
    return `${hoursSinceLastSeen} hour${hoursSinceLastSeen === 1 ? '' : 's'} ago`
  }

  const daysSinceLastSeen = Math.round(hoursSinceLastSeen / 24)
  return `${daysSinceLastSeen} day${daysSinceLastSeen === 1 ? '' : 's'} ago`
}
</file>

<file path="layers/base/composables/ab-test.ts">
import type { DefineComponent } from 'vue'

export enum TestGoal {
  SignUp = 'sign_up',
  Purchase = 'purchase',
  FeatureUsage = 'feature_usage',
  TimeOnPage = 'time_on_page',
  ClickThroughRate = 'click_through_rate',
}

interface ABTestVariant<T> {
  name: string
  value: T
}

interface ABTestConfig<T> {
  experimentName: string
  variants: ABTestVariant<T>[]
  defaultVariant: ABTestVariant<T>
  goals: TestGoal[]
}

export function useABTest<T>({ experimentName, variants, defaultVariant, goals }: ABTestConfig<T>) {
  const { $posthog } = useNuxtApp()

  const selectedVariant = ref<ABTestVariant<T>>(defaultVariant)

  // Use PostHog's experiment feature to get the variant
  const variantName = $posthog.getFeatureFlag(experimentName)
  selectedVariant.value = variants.find((v) => v.name === variantName) || defaultVariant

  // Capture experiment exposure
  $posthog.capture('$experiment_started', {
    experiment: experimentName,
    variant: selectedVariant.value.name,
    goals: goals,
  })

  const value = computed(() => selectedVariant.value.value)

  // Function to track goal completion
  const trackGoal = (goal: TestGoal, properties: Record<string, any> = {}) => {
    $posthog.capture(goal, {
      ...properties,
      $experiment_name: experimentName,
      $variant: selectedVariant.value.name,
    })
  }

  return {
    variant: selectedVariant,
    value,
    trackGoal,
  }
}

// Helper function for component-based A/B tests
type ComponentVariant = ABTestVariant<DefineComponent<any, any, any>>

export function useComponentABTest(config: ABTestConfig<DefineComponent<any, any, any>>) {
  const { variant, trackGoal } = useABTest(config)

  const TestComponent = computed(() => ({
    render() {
      return h(variant.value.value.component)
    },
  }))

  return {
    TestComponent,
    trackGoal,
  }
}
</file>

<file path="layers/base/composables/analytics.ts">
import { ref, onMounted, onUnmounted } from 'vue'
import { useRoute } from 'vue-router'

export enum UserAcquisitionMetric {
  SignUpConversion = 'sign_up_conversion',
  DemoRequest = 'demo_request',
  ContactFormSubmission = 'contact_form_submission',
  FeaturePageEngagement = 'feature_page_engagement',
  BlogTraffic = 'blog_traffic',
}

export enum OnboardingMetric {
  StartRate = 'start_rate',
  StepCompletion = 'step_completion',
  DropOff = 'drop_off',
  CompletionTime = 'completion_time',
}

export enum UserEngagementMetric {
  SessionDuration = 'session_duration',
  ActionsPerSession = 'actions_per_session',
  VisitFrequency = 'visit_frequency',
  FeatureAdoption = 'feature_adoption',
}

export enum ContentPerformanceMetric {
  ArticleView = 'article_view',
  ReadTime = 'read_time',
  Share = 'share',
  Like = 'like',
  Comment = 'comment',
}

export enum JobMarketMetric {
  JobListing = 'job_listing',
  JobView = 'job_view',
  JobApplication = 'job_application',
  CompanyProfileCreation = 'company_profile_creation',
  CompanyFollow = 'company_follow',
}

export enum TechnicalPerformanceMetric {
  PageLoadTime = 'page_load_time',
  APIResponseTime = 'api_response_time',
  ErrorRate = 'error_rate',
  Uptime = 'uptime',
}

export type ContentType = 'blog_post' | 'news_article' | 'company_profile' | 'job_listing'

export type ErrorType = 'javascript_error' | 'api_error' | '404_error'

export interface AnalyticsEventProperties {
  [key: string]: any
}

export function useAnalytics() {
  const { $posthog } = useNuxtApp()
  const route = useRoute()
  const pageEnterTime = ref(Date.now())

  const trackEvent = (eventName: string, properties?: AnalyticsEventProperties) => {
    $posthog.capture(eventName, properties)
  }

  const trackPageView = (properties?: AnalyticsEventProperties) => {
    const timeSpent = Date.now() - pageEnterTime.value
    $posthog.capture('$pageview', {
      path: route.path,
      title: document.title,
      timeSpent,
      ...properties,
    })
    pageEnterTime.value = Date.now()
  }

  const identifyUser = (userId: string, properties?: AnalyticsEventProperties) => {
    $posthog.identify(userId, properties)
  }

  const trackError = (errorType: ErrorType, errorDetails: string, componentName?: string) => {
    $posthog.capture('Error Occurred', {
      errorType,
      errorDetails,
      componentName,
    })
  }

  const trackUserAcquisition = (
    metric: UserAcquisitionMetric,
    properties?: AnalyticsEventProperties,
  ) => {
    $posthog.capture(`User Acquisition - ${metric}`, properties)
  }

  const trackOnboarding = (metric: OnboardingMetric, properties?: AnalyticsEventProperties) => {
    $posthog.capture(`Onboarding - ${metric}`, properties)
  }

  const trackUserEngagement = (
    metric: UserEngagementMetric,
    properties?: AnalyticsEventProperties,
  ) => {
    $posthog.capture(`User Engagement - ${metric}`, properties)
  }

  const trackContentPerformance = (
    metric: ContentPerformanceMetric,
    contentType: ContentType,
    properties?: AnalyticsEventProperties,
  ) => {
    $posthog.capture(`Content Performance - ${contentType} - ${metric}`, properties)
  }

  const trackJobMarketActivity = (
    metric: JobMarketMetric,
    properties?: AnalyticsEventProperties,
  ) => {
    $posthog.capture(`Job Market - ${metric}`, properties)
  }

  const trackTechnicalPerformance = (
    metric: TechnicalPerformanceMetric,
    value: number,
    properties?: AnalyticsEventProperties,
  ) => {
    $posthog.capture(`Technical Performance - ${metric}`, { value, ...properties })
  }

  // Session tracking
  onMounted(() => {
    trackPageView()
    $posthog.capture('Session Started')
  })

  onUnmounted(() => {
    trackPageView()
    $posthog.capture('Session Ended', {
      sessionDuration: Date.now() - pageEnterTime.value,
    })
  })

  return {
    trackEvent,
    trackPageView,
    identifyUser,
    trackUserAcquisition,
    trackOnboarding,
    trackUserEngagement,
    trackContentPerformance,
    trackJobMarketActivity,
    trackTechnicalPerformance,
    trackError,
  }
}

// import {
//   UserAcquisitionMetric,
//   OnboardingMetric,
//   UserEngagementMetric,
//   ContentPerformanceMetric,
//   JobMarketMetric,
//   TechnicalPerformanceMetric,
//   ContentType,
//   ErrorType
// } from '~/types/analytics'

// const {
//   trackUserAcquisition,
//   trackOnboarding,
//   trackUserEngagement,
//   trackContentPerformance,
//   trackJobMarketActivity,
//   trackTechnicalPerformance,
//   trackError
// } = useAnalytics()

// // Track a sign-up conversion
// trackUserAcquisition(UserAcquisitionMetric.SignUpConversion, { source: 'organic' })

// // Track an onboarding step completion
// trackOnboarding(OnboardingMetric.StepCompletion, { step: 'personal_info', timeSpent: 120 })

// // Track a feature adoption
// trackUserEngagement(UserEngagementMetric.FeatureAdoption, { feature: 'job_search' })

// // Track a blog post share
// trackContentPerformance(ContentPerformanceMetric.Share, 'blog_post', { postId: '123', platform: 'twitter' })

// // Track a job application
// trackJobMarketActivity(JobMarketMetric.JobApplication, { jobId: '456', companyId: '789' })

// // Track page load time
// trackTechnicalPerformance(TechnicalPerformanceMetric.PageLoadTime, performance.now())

// // Track an error
// trackError(ErrorType.APIError, 'Failed to fetch job listings', 'JobSearchComponent')
</file>

<file path="layers/base/composables/glass-card.ts">
interface GlassCardProps {
  color: string
  bgOpacity: number
  gradientOpacity: number
  blurIntensity: string
  disableHover: boolean
  padding: string
  loading: boolean
  ariaLabel: string
}

const cardStates = reactive<Record<string, any>>({})

export function useGlassCard(props: GlassCardProps, uniqueId: string) {
  if (!cardStates[uniqueId]) {
    cardStates[uniqueId] = {
      tiltFactor: 0,
      mouseX: 0,
      mouseY: 0,
      isOutside: true,
      cardWidth: 0,
      cardHeight: 0,
    }
  }

  const state = cardStates[uniqueId]

  const handleMouseMove = (event: MouseEvent) => {
    const cardElement = document.getElementById(uniqueId)?.querySelector('.glass-card')
    if (!cardElement) return

    const cardRect = cardElement.getBoundingClientRect()

    state.cardWidth = cardRect.width
    state.cardHeight = cardRect.height

    const gravityArea = 100 // pixels around the card
    const x = event.clientX - cardRect.left
    const y = event.clientY - cardRect.top

    // Check if the mouse is within the gravity field
    if (
      x >= -gravityArea &&
      x <= cardRect.width + gravityArea &&
      y >= -gravityArea &&
      y <= cardRect.height + gravityArea
    ) {
      state.mouseX = x
      state.mouseY = y
      state.isOutside = false

      // Calculate distance from the edge of the card
      const distanceX = Math.max(0, -x, x - cardRect.width)
      const distanceY = Math.max(0, -y, y - cardRect.height)
      const distance = Math.sqrt(distanceX * distanceX + distanceY * distanceY)

      // Calculate tilt factor
      if (x >= 0 && x <= cardRect.width && y >= 0 && y <= cardRect.height) {
        state.tiltFactor = 1 // Cursor is directly over the card
      } else {
        // Smooth transition in the gravity area
        state.tiltFactor = Math.max(0, 1 - distance / gravityArea)
      }
    } else {
      state.tiltFactor = 0
      state.isOutside = true
    }
  }

  const handleMouseLeave = () => {
    state.tiltFactor = 0
    state.isOutside = true
  }

  const cardStyle = computed(() => {
    if (state.isOutside) return {}

    const maxTilt = 4 // maximum tilt in degrees

    // Use cardWidth and cardHeight from state instead of getting them from cardRef
    const centerX = state.cardWidth / 2
    const centerY = state.cardHeight / 2

    const tiltY = ((state.mouseX - centerX) / centerX) * maxTilt * state.tiltFactor
    const tiltX = ((centerY - state.mouseY) / centerY) * maxTilt * state.tiltFactor

    return {
      transform: `perspective(1000px) rotateX(${tiltX}deg) rotateY(${tiltY}deg)`,
      transition: state.isOutside ? 'transform 0.3s ease-out' : 'none',
    }
  })

  const spotlightColor = computed(() => {
    const hue = (state.mouseX / state.cardWidth) * 360
    return `hsl(${hue}, 100%, 70%)`
  })

  const spotlightStyle = computed(() => {
    if (state.isOutside) return { opacity: 0 }

    const spotlightSize = 300 // Fixed 300px radius
    const opacity = 0.07 + state.tiltFactor * 0.08

    return {
      background: `
      radial-gradient(circle ${spotlightSize}px at ${state.mouseX}px ${state.mouseY}px, 
      ${spotlightColor.value}, 
      transparent 70%),
      radial-gradient(circle ${spotlightSize * 0.8}px at ${state.mouseX}px ${state.mouseY}px, 
      ${spotlightColor.value}, 
      transparent 70%)
    `,
      opacity: opacity,
      transition: 'opacity 0.3s ease-out',
      mixBlendMode: 'soft-light',
    }
  })

  const bgClasses = computed(() => [
    `bg-${props.color}-950/${props.bgOpacity}`,
    `hover:bg-${props.color}-900/${props.bgOpacity + 10}`,
  ])

  const borderClasses = computed(() => [
    'border',
    'border-color',
    `hover:border-${props.color}-400/40`,
  ])

  const textClasses = computed(() => [`text-${props.color}-100`])

  const gradientClasses = computed(() => [
    `from-${props.color}-100/${props.gradientOpacity}`,
    `to-${props.color}-500/${props.gradientOpacity}`,
  ])

  const hoverClasses = computed(() =>
    props.disableHover
      ? []
      : ['hover:shadow-2xl', `hover:bg-${props.color}-800/${props.bgOpacity + 10}`],
  )

  return {
    handleMouseMove,
    handleMouseLeave,
    cardStyle,
    spotlightStyle,
    bgClasses,
    borderClasses,
    textClasses,
    gradientClasses,
    hoverClasses,
  }
}
</file>

<file path="layers/base/composables/metrics.ts">
function roundToNDecimalPlaces(value: number, n: number): number {
  return Number(value.toFixed(n))
}

function calculateMedian(arr: number[]): number {
  const sorted = arr.slice().sort((a, b) => a - b)
  const mid = Math.floor(sorted.length / 2)
  return sorted.length % 2 !== 0 ? sorted[mid] : (sorted[mid - 1] + sorted[mid]) / 2
}

function calculateStandardDeviation(valuesArray: number[]): number {
  const mean = valuesArray.reduce((a, b) => a + b) / valuesArray.length
  return Math.sqrt(
    valuesArray.map((x) => Math.pow(x - mean, 2)).reduce((a, b) => a + b) / valuesArray.length,
  )
}

function calculateMean(arr: number[]): number {
  return arr.reduce((a, b) => a + b) / arr.length
}

function calculateVariance(arr: number[]): number {
  const mean = calculateMean(arr)
  return arr.reduce((sum, value) => sum + Math.pow(value - mean, 2), 0) / arr.length
}

function calculateRange(arr: number[]): number {
  return Math.max(...arr) - Math.min(...arr)
}

function calculateSum(arr: number[]): number {
  return arr.reduce((a, b) => a + b, 0)
}

function calculateMode(arr: number[]): number | number[] {
  const frequency: { [key: number]: number } = {}
  let maxFreq = 0
  let modes: number[] = []

  arr.forEach((value) => {
    frequency[value] = (frequency[value] || 0) + 1
    if (frequency[value] > maxFreq) {
      maxFreq = frequency[value]
      modes = [value]
    } else if (frequency[value] === maxFreq) {
      modes.push(value)
    }
  })

  return modes.length === 1 ? modes[0] : modes
}

function calculateMin(arr: number[]): number {
  return Math.min(...arr)
}

function calculateMax(arr: number[]): number {
  return Math.max(...arr)
}

function calculatePercentile(arr: number[], percentile: number): number {
  if (percentile < 0 || percentile > 100) {
    throw new Error('Percentile must be between 0 and 100')
  }
  const sorted = arr.slice().sort((a, b) => a - b)
  const index = (percentile / 100) * (sorted.length - 1)
  const lower = Math.floor(index)
  const upper = lower + 1
  const weight = index % 1

  if (upper >= sorted.length) {
    return sorted[lower]
  }

  return sorted[lower] * (1 - weight) + sorted[upper] * weight
}

export function useBaseMetrics() {
  return {
    format: {
      roundToN: roundToNDecimalPlaces,
    },
    calculate: {
      median: calculateMedian,
      standardDeviation: calculateStandardDeviation,
      mean: calculateMean,
      variance: calculateVariance,
      range: calculateRange,
      sum: calculateSum,
      mode: calculateMode,
      min: calculateMin,
      max: calculateMax,
      percentile: calculatePercentile,
    },
  }
}
</file>

<file path="layers/base/composables/modal.ts">
export function useModal() {
  // was used for news modals at one point
  const currentPost = computed(() => news.value[currentIndex.value])
  const nextPost = computed(() => news.value[nextIndex.value])
  const previousPost = computed(() => news.value[previousIndex.value])
  const isModalOpen = ref(false)
  const currentIndex = ref(0)
  const previousIndex = computed(() => (currentIndex.value > 0 ? currentIndex.value - 1 : 0))
  const nextIndex = computed(() =>
    currentIndex.value < news.value.length - 1 ? currentIndex.value + 1 : currentIndex.value,
  )

  const toggleModal = (postIndex?: number) => {
    isModalOpen.value = !isModalOpen.value
    if (postIndex !== undefined) {
      currentIndex.value = postIndex
    }
  }

  const next = () => {
    if (currentIndex.value < news.value.length - 1) {
      currentIndex.value++
    }
  }

  const previous = () => {
    if (currentIndex.value > 0) {
      currentIndex.value--
    }
  }
}
</file>

<file path="layers/base/composables/notification.ts">
import type { useToast } from 'primevue/usetoast'

interface BaseNotification {
  summary: string
  message: string
}

export function useNotification() {
  const nuxtApp = useNuxtApp()
  const getToast: typeof useToast = () => nuxtApp.vueApp.config.globalProperties.$toast
  const toast = getToast()

  const success = ({ summary, message }: BaseNotification) => {
    toast.add({
      severity: 'success',
      summary: `Success: ${summary}`,
      detail: message,
      life: 5000,
      closable: true,
    })
  }

  const error = ({ summary, message }: BaseNotification) => {
    toast.add({
      severity: 'error',
      summary: `Error: ${summary}`,
      detail: message,
      life: 0,
      closable: true,
    })
  }

  const info = ({ summary, message }: BaseNotification) => {
    toast.add({
      severity: 'info',
      summary: `Info: ${summary}`,
      detail: message,
      life: 5000,
      closable: true,
    })
  }

  const warn = ({ summary, message }: BaseNotification) => {
    toast.add({
      severity: 'warn',
      summary: `Warning: ${summary}`,
      detail: message,
      life: 5000,
      closable: true,
    })
  }

  const feature = ({ summary, message }: BaseNotification) => {
    toast.add({
      severity: 'warn',
      group: 'cta',
      summary: summary,
      detail: message,
      life: 0,
      closable: true,
    })
  }

  return {
    success,
    error,
    info,
    warn,
    feature,
  }
}
</file>

<file path="layers/base/composables/settings.store.ts">
type SettingsKey = 'usersStore' | 'storeNews'

export const useSettingsStore = defineStore('settingsStore', () => {
  const settings = ref({} as Settings)
  const summaryLevel = ref('beginner' as SummaryLevel)

  function toggleSettings(key: SettingsKey) {
    settings.value[key] = !settings.value[key]
  }

  function isSettingsOn(key: SettingsKey) {
    return !settings.value[key]
  }

  const changeSummaryLevel = (level: 'beginner' | 'intermediate' | 'expert') => {
    summaryLevel.value = level
  }

  return {
    toggleSettings,
    isSettingsOn,
  }
})

if (import.meta.hot) {
  import.meta.hot.accept(acceptHMRUpdate(useSettingsStore, import.meta.hot))
}
</file>

<file path="layers/base/composables/social.store.ts">
import { useLogger } from '@ib/logger'

export const useSocialStore = defineStore('settingsStore', () => {
  const errors = useBaseError()
  const logger = useLogger('useSocialStore')
  const { fetch } = useBaseFetch()

  const youtube = ref({})
  async function getYoutubeAnalytics(channelName: string) {
    logger.info(`getting youtube analytics for ${channelName}`)
    const response = await fetch('/api/social/youtube/analytics', {
      method: 'GET',
      query: {
        channelName,
      },
    })

    const data = errors.server({
      response,
      devOnly: false,
      devMessage: 'error getting youtube analytics',
      userMessage: 'something went wrong when getting youtube analytics',
    })

    youtube.value = data
  }

  const instagram = ref<any>(null)
  async function getInstagramAnalytics(userId: string) {
    const logger = useLogger('getInstagramAnalytics')
    logger.info(`Fetching Instagram analytics for ${userId}`)
    try {
      const response = await $fetch(`/api/social/instagram/analytics?userId=${userId}`, {
        method: 'GET',
      })

      const data = errors.server({
        response,
        devOnly: false,
        devMessage: 'Error getting Instagram analytics',
        userMessage: 'Something went wrong when getting Instagram analytics',
      })

      instagram.value = data
    } catch (error) {
      errors.client({
        error,
        devOnly: false,
        devMessage: 'Error getting Instagram analytics',
        userMessage: 'Something went wrong when getting Instagram analytics',
      })
    }
  }

  const linkedin = ref<any>(null)
  async function getLinkedInAnalytics(postId: string) {
    const logger = useLogger('getLinkedInAnalytics')
    logger.info(`Fetching LinkedIn analytics for post ${postId}`)
    try {
      const response = await $fetch(`/api/social/linkedin/analytics?postId=${postId}`, {
        method: 'GET',
      })

      const data = errors.server({
        response,
        devOnly: false,
        devMessage: 'Error getting LinkedIn analytics',
        userMessage: 'Something went wrong when getting LinkedIn analytics',
      })

      linkedin.value = data
    } catch (error) {
      errors.client({
        error,
        devOnly: false,
        devMessage: 'Error getting LinkedIn analytics',
        userMessage: 'Something went wrong when getting LinkedIn analytics',
      })
    }
  }

  const twitter = ref<any>(null)
  async function getTwitterAnalytics(postId: string) {
    const logger = useLogger('getTwitterAnalytics')
    logger.info(`Fetching Twitter analytics for post ${postId}`)
    try {
      const response = await fetch(`/api/social/twitter/analytics?postId=${postId}`, {
        method: 'GET',
      })

      const data = errors.server({
        response,
        devOnly: false,
        devMessage: 'Error getting Twitter analytics',
        userMessage: 'Something went wrong when getting Twitter analytics',
      })

      twitter.value = data
    } catch (error) {
      errors.client({
        error,
        devOnly: false,
        devMessage: 'Error getting Twitter analytics',
        userMessage: 'Something went wrong when getting Twitter analytics',
      })
    }
  }

  return {
    youtube,
    getYoutubeAnalytics,
    //
    instagram,
    getInstagramAnalytics,
    //
    linkedin,
    getLinkedInAnalytics,
    //
    twitter,
    getTwitterAnalytics,
  }
})

if (import.meta.hot) {
  import.meta.hot.accept(acceptHMRUpdate(useSocialStore, import.meta.hot))
}
</file>

<file path="layers/base/composables/useMediaQuery.ts">
// composables/useMediaQuery.ts
export const useMediaQuery = (query: string) => {
  const matches = ref(false)

  if (import.meta.client) {
    const mediaQuery = window.matchMedia(query)
    matches.value = mediaQuery.matches

    const handler = (event: MediaQueryListEvent) => {
      matches.value = event.matches
    }

    // Watch for changes
    mediaQuery.addEventListener('change', handler)

    // Cleanup
    onUnmounted(() => {
      mediaQuery.removeEventListener('change', handler)
    })
  }

  return matches
}
</file>

<file path="layers/base/composables/useNavigation.ts">
// composables/useNavigation.ts
export const useNavigation = () => {
  const isSidebarOpen = useState('nav-sidebar-open', () => true)
  const isMobileSidebarOpen = useState('nav-mobile-sidebar-open', () => false)

  // Create our own media query composable
  const isMobile = useMediaQuery('(max-width: 768px)')

  // Close mobile nav on route changes
  const route = useRoute()
  
  watch(
    () => route.path,
    () => {
      isMobileSidebarOpen.value = false
    },
  )

  return {
    isSidebarOpen,
    isMobileSidebarOpen,
    isMobile,
  }
}
</file>

<file path="layers/base/composables/utils.ts">
import { wasRowDataUpdated } from './utils/hasValueChanged'
import * as time from './utils/time'
import * as strings from './utils/strings'
import * as objects from './utils/objects'
import * as arrays from './utils/arrays'

export function useUtils() {
  return {
    wasRowDataUpdated,
    time: {
      format: time.toDateObject,
      lastSeen: time.lastSeen,
    },
    strings: {
      firstUpper: strings.upperCaseFirstLetter,
      slugify: strings.slugify,
    },
    arrays: {
      removeDuplicates: arrays.removeDuplicates,
      sortBy: arrays.sortBy,
    },
    objects: {
      pluck: objects.pluck,
    },
  }
}
</file>

<file path="layers/base/plugins/error-handler.ts">
import { useErrorHandler } from '@ib/logger'

export default defineNuxtPlugin((nuxtApp) => {
  const { handleError } = useErrorHandler()

  // Set up global error handlers
  if (import.meta.client) {
    window.addEventListener('error', (event) => {
      handleError(event.error, 'Uncaught Exception')
    })

    window.addEventListener('unhandledrejection', (event) => {
      handleError(event.reason, 'Unhandled Promise Rejection')
    })
  }
})
</file>

<file path="layers/base/plugins/posthog.client.ts">
import posthog from 'posthog-js'

export default defineNuxtPlugin((nuxtApp) => {
  const env = nuxtApp.$config.public
  const env2 = useRuntimeConfig().public

  console.log('ENV Key:', env, env2)
  console.log('NODE_ENV:', import.meta.env.NODE_ENV)

  const posthogKey = env.posthogKey || env2.posthogKey
  const posthogUrl = env.posthogUrl || env2.posthogUrl

  // Initialize PostHog
  posthog.init(posthogKey, {
    api_host: posthogUrl,
    autocapture: false, // Disable autocapture as we'll handle events manually
    capture_pageview: false, // We'll capture pageviews manually for more control
    persistence: 'localStorage+cookie',
    // bootstrap: {
    //   distinctID: runtimeConfig.public.posthogDistinctId // Set this in your runtime config if you have a user ID
    // },
    loaded: (posthog) => {
      // This function is called once PostHog is loaded
      if (import.meta.env.NODE_ENV === 'development') {
        // Log to console in development mode
        posthog.debug()
      }
    },
  })

  // Capture page views
  nuxtApp.hook('page:finish', () => {
    posthog.capture('$pageview')
  })

  // Expose PostHog instance and utility functions
  return {
    provide: {
      posthog: {
        // Expose the raw PostHog instance
        raw: posthog,

        // Utility function to capture events
        capture: (eventName: string, properties?: Record<string, any>) => {
          posthog.capture(eventName, properties)
        },

        // Utility function for A/B testing
        getFeatureFlag: (flagName: string, defaultValue?: any) => {
          return posthog.getFeatureFlag(flagName, defaultValue)
        },

        // Utility function to identify users
        identify: (distinctId: string, properties?: Record<string, any>) => {
          posthog.identify(distinctId, properties)
        },

        // Utility function to reset user identity
        reset: () => {
          posthog.reset()
        },

        // Utility function to opt in/out of tracking
        optIn: () => {
          posthog.opt_in_capturing()
        },
        optOut: () => {
          posthog.opt_out_capturing()
        },

        // Utility function for registering super properties
        register: (properties: Record<string, any>) => {
          posthog.register(properties)
        },

        // Utility function for registering one-time super properties
        registerOnce: (properties: Record<string, any>) => {
          posthog.register_once(properties)
        },
      },
    },
  }
})
</file>

<file path="layers/base/plugins/sentry.client.ts">
import * as Sentry from '@sentry/vue'
import { defineNuxtPlugin } from '#app'

export default defineNuxtPlugin((nuxtApp) => {
  const app = nuxtApp.vueApp
  const router = useRouter()

  Sentry.init({
    app,
    dsn: 'https://eec364410b024a5a837f60e00d367513@o1175094.ingest.sentry.io/4504389151621120',
    integrations: [Sentry.browserTracingIntegration({ router }), Sentry.replayIntegration()],
    tracesSampleRate: process.env.NODE_ENV === 'production' ? 0.2 : 1.0,
    tracePropagationTargets: ['localhost', /^https:\/\/yourserver\.io\/api/],
    replaysSessionSampleRate: 0.1,
    replaysOnErrorSampleRate: 1.0,
    attachProps: true,
    trackComponents: true,
  })

  // Sentry.setUser(useSupabaseUser())
  Sentry.setTag('environment', process.env.NODE_ENV)
})
</file>

<file path="layers/base/types/content.ts">
import { z } from 'zod'

export const titleSchema = z.object({
  centered: z.boolean().optional(),
  label: z.string().optional(),
  main: z.string(),
  subtitle: z.string().optional(),
})

export const faqSchema = z.object({
  label: z.string(),
  description: z.string(),
})

export const imageSchema = z.object({
  src: z.string(),
  alt: z.string(),
  width: z.number().optional(),
  height: z.number().optional(),
})

export type ImageType = z.infer<typeof imageSchema>
export type TitleType = z.infer<typeof titleSchema>
export type FaqType = z.infer<typeof faqSchema>
</file>

<file path="layers/base/types/database.ts">
import type { Tables } from '../../../supabase/schema.gen'

export type RowUser = Tables<'user_profiles'>
export type RowUserFollowers = Tables<'user_followers'>
export type RowRole = Tables<'roles'>
export type RowRegisterInterest = Tables<'register_interest'>

export type RowCategory = Tables<'categories'>
export type RowTag = Tables<'tags'>

export type RowNews = Tables<'news'>
export type RowNewsTag = Tables<'news_tags'>

export type RowEmbedding = Tables<'embeddings'>

export type RowPaper = Tables<'papers'>

type ArrayToUnion<A> = A extends readonly (infer T)[] ? T : never

const userCardKeys = [
  'id',
  'given_name',
  'surname',
  'username',
  'avatar',
  'followed_count',
  'followers_count',
  'plan',
] as const

export type UserCard = Pick<RowUser, ArrayToUnion<typeof userCardKeys>>
</file>

<file path="layers/base/types/index.ts">
export * from './users'
export * from './other-type-file'
</file>

<file path="layers/base/types/users.ts">
// don't forget to add to this file if you make any changes in the database
import * as z from 'zod'

export const LocationSchema = z.object({
  id: z.number(),
  created_at: z.string().optional(),
  city: z.string(),
  country: z.string(),
  state: z.string(),
  address: z.string().nullable(),
  latitude: z.number().optional().nullable(),
  longitude: z.number().optional().nullable(),
})

export const UserRoleSchema = z.object({
  id: z.number(),
  name: z.string().nullable(),
  body: z.string().nullable().optional(),
  created_at: z.string().optional(),
  icon: z.string(),
})

export const IdName = z.object({
  id: z.number(),
  name: z.string(),
})

export const UserSkillSchema = z.object({
  id: z.number(),
  title: z.string().nullable(),
  body: z.string().nullable().optional(),
  total_endorsements: z.number(),
  admin_rating: z.number().nullable(),
  avg_rating: z.number().nullable(),
  created_at: z.string().optional(),
})

export const UserSocialSchema = z.object({
  id: z.number(),
  url: z.string(),
  platform: z.string(),
  username: z.string(),
})

export const UserBasicSchema = z.object({
  id: z.string(),
  given_name: z.string(),
  surname: z.string().nullable(),
  username: z.string().nullable(),
  avatar: z.string().nullable(),
  introduction: z.string().nullable(),
  followers_count: z.number().nullable(),
  followed_count: z.number().nullable(),
  is_following: z.boolean().nullable(),
  role: z.number(),
})

export const UserFullSchema = UserBasicSchema.extend({
  email: z.string(),
  dob: z.string().nullable(),
  gender_id: z.number().nullable(),
  created_at: z.string(),
  updated_at: z.string().nullable(),
  quote: z.string().nullable(),
})

export const UserRowSchema = z.object({
  given_name: z.string(),
  email: z.string(),
  surname: z.string().nullable(),
  username: z.string().nullable(),
  avatar: z.string().nullable(),
  introduction: z.string().nullable(),
  plan: z.string().nullish(),
  dob: z.string().nullable(),
  quote: z.string().nullable(),
  gender_id: z.number().nullable(),
})

export const UserRolesSchema = z.array(UserRoleSchema)

export type UserType = z.infer<typeof UserBasicSchema>
export type UserFullType = z.infer<typeof UserFullSchema>
export type UserRoleType = z.infer<typeof UserRoleSchema>
export type UserRowType = z.infer<typeof UserRowSchema>
export type UserSocialType = z.infer<typeof UserSocialSchema>
</file>

<file path="layers/base/nuxt.config.ts">
import { defineNuxtConfig } from 'nuxt/config'

export default defineNuxtConfig({
  workspaceDir: '../../',
  srcDir: '.',

  icon: {
    serverBundle: {
      collections: ['material-symbols', 'mdi'],
    },
  },

  eslint: {
    checker: true,
  },

  image: {
    providers: {
      supabase: {
        provider: '../../layers/base/supabase-provider.ts',
        options: {
          baseURL: process.env.NUXT_PUBLIC_SUPABASE_URL,
        },
      },
    },
    presets: {
      original: {
        modifiers: {
          width: 1920,
          height: 1080,
        },
      },
      mobile: {
        modifiers: {
          width: 768,
          height: 1024,
        },
      },
      thumbnail: {
        modifiers: {
          width: 300,
          height: 200,
        },
      },
    },
  },

  components: [
    {
      path: './components',
      pathPrefix: false,
      prefix: 'IB',
      global: true,
    },
  ],
})
</file>

<file path="layers/base/supabase-provider.ts">
export function getImage(
  src,
  {
    modifiers = { width: null, height: null, format: null },
    baseURL = process.env.NUXT_PUBLIC_SUPABASE_URL,
  } = {},
) {
  const { width, height, format } = modifiers
  const [_, bucket, sizeName, imageFileName] = src.split('/')

  // Determine target size
  let targetSizeName = sizeName
  if (width && height) {
    if (width <= 300 && height <= 200) {
      targetSizeName = 'thumbnail'
    } else if (width <= 768 && height <= 1024) {
      targetSizeName = 'mobile'
    } else {
      targetSizeName = 'original'
    }
  }

  const imageNameWithoutExt = imageFileName.split('.')[0]
  const imageFormat = format || imageFileName.split('.')[1] || 'jpg'

  return {
    url: `${baseURL}/storage/v1/object/public/${bucket}/${targetSizeName}/${imageNameWithoutExt}.${imageFormat}`,
  }
}
</file>

<file path="layers/crud/.playground/app.config.ts">
export default defineAppConfig({
  myLayer: {
    name: 'My amazing Nuxt layer (overwritten)'
  }
})
</file>

<file path="layers/crud/.playground/nuxt.config.ts">
export default defineNuxtConfig({
  extends: ['..'],
  modules: ['@nuxt/eslint']
})
</file>

<file path="layers/crud/components/Feedback.vue">
<script setup lang="ts">
import { z } from 'zod'

const feedbackStore = useFeedbackStore()

defineProps({
  cta: {
    type: String,
    required: true,
    default: 'How could we improve?',
  },
})

interface FeedbackType {
  name: string
  value: string
}

const feedbackTypes = [
  { name: 'Bug Report', value: 'bug_report' },
  { name: 'Feature Request', value: 'feature_request' },
  { name: 'User Interface Issue', value: 'user_interface_issue' },
  { name: 'Performance Issue', value: 'performance_issue' },
  { name: 'Documentation', value: 'documentation' },
]

const route = useRoute()
const { userId } = useCurrentUser()

const initialFeedback = () => ({
  user_id: userId,
  page_identifier: route.fullPath,
  feedback_type: null,
  message: '',
  device_info: '',
  content_status: 'new',
})

const feedback = ref(initialFeedback())

const messagePlaceholder = computed(() => {
  if (!feedback.value.feedback_type) {
    return 'Please select a feedback type first'
  }

  const type = feedback.value.feedback_type
  if (!type) return ''

  switch (type.value) {
    case 'bug_report':
      return 'Describe the bug in detail...'
    case 'feature_request':
      return 'Describe the feature you would like to see...'
    case 'user_interface_issue':
      return 'What UI issue did you encounter?'
    case 'performance_issue':
      return 'Describe the performance issue...'
    case 'documentation':
      return 'What documentation issue did you find?'
    default:
      return 'Enter your message'
  }
})

const isMessageDisabled = computed(() => !feedback.value.feedback_type)

const messageLength = z.string().min(10)

const isMessageInvalid = computed(() => !messageLength.safeParse(feedback.value.message).success)

const resetFeedback = () => {
  feedback.value = initialFeedback()
}

const submitFeedback = async () => {
  await feedbackStore.submitFeedback(feedback.value)
  resetFeedback()
}
</script>

<template>
  <div class="w-52">
    <h2 class="text-lg mb-4 text-left font-bold">
      {{ cta }}
    </h2>
    <form
      class="w-52 space-y-4"
      @submit.prevent="submitFeedback"
    >
      <PrimeSelect
        v-model="feedback.feedback_type"
        :pt="{ root: 'flex text-left pl-1' }"
        :pt-options="{ mergeProps: true, mergeSections: true }"
        :options="feedbackTypes"
        option-label="name"
        placeholder="Feedback Type"
      />
      <PrimeTextarea
        v-show="feedback.feedback_type"
        v-model="feedback.message"
        class="w-full"
        :rows="5"
        :placeholder="messagePlaceholder"
        :disabled="isMessageDisabled"
        :invalid="isMessageInvalid"
      />
      <div>
        <PrimeButton
          v-show="feedback.feedback_type"
          class="flex w-full justify-between"
          :disabled="isMessageInvalid"
          :outlined="isMessageInvalid"
          @click="submitFeedback"
        >
          Submit Feedback
          <Icon name="mdi:send" />
        </PrimeButton>
      </div>
    </form>
  </div>
</template>

<style scoped></style>
</file>

<file path="layers/crud/components/Upload.vue">
<script setup lang="ts">
// const toast = useNotification()

const props = defineProps({
  name: {
    type: String,
    required: true,
  },
  url: {
    type: String,
    required: true,
  },
  multiple: {
    type: Boolean,
    default: false,
  },
  accept: {
    type: String,
    default: '',
  },
  maxFileSize: {
    type: Number,
    default: 1000000,
  },
})

const onAdvancedUpload = () => {
  toast.success({ summary: 'File Uploaded', message: `${props.name} files uploaded` })
}
</script>

<template>
  <PrimeCard>
    <template #content>
      <PrimeFileUpload
        :name="name"
        :multiple="multiple"
        :accept="accept"
        :url="url"
        :max-file-size="maxFileSize"
        @upload="onAdvancedUpload()"
      >
        <template #empty>
          <p>Drag and drop files to here to upload.</p>
        </template>
      </PrimeFileUpload>
    </template>
  </PrimeCard>
</template>
</file>

<file path="layers/crud/composables/audit.ts">
export enum AuditLogLevel {
  INFO = 'INFO',
  WARNING = 'WARNING',
  ERROR = 'ERROR',
  CRITICAL = 'CRITICAL',
}

export interface AuditLogEntry {
  userId: string
  action: string
  details: any
  level: AuditLogLevel
  timestamp: string
  ipAddress?: string
  userAgent?: string
  resourceId?: string
  resourceType?: string
}

interface AuditLogOptions {
  level?: AuditLogLevel
  resourceId?: string
  resourceType?: string
  skipDB?: boolean
}

export function useAuditLog() {
  const supabase = useSupabaseClient()
  const user = useSupabaseUser()
  const config = useRuntimeConfig()

  const logEvent = async (action: string, details: any, options: AuditLogOptions = {}) => {
    const userId = user.value?.id || 'anonymous'
    const timestamp = new Date().toISOString()
    const level = options.level || AuditLogLevel.INFO

    const logEntry: AuditLogEntry = {
      userId,
      action,
      details,
      level,
      timestamp,
      ipAddress: useRequestHeaders(['x-forwarded-for'])['x-forwarded-for'] || '',
      userAgent: useRequestHeaders(['user-agent'])['user-agent'] || '',
      resourceId: options.resourceId,
      resourceType: options.resourceType,
    }

    // Remove any sensitive information from the log entry
    sanitizeLogEntry(logEntry)

    // Log to console in development
    if (import.meta.dev) {
      console.log('Audit Log:', logEntry)
    }

    if (!options.skipDB) {
      try {
        const { error } = await supabase.from('audit_logs').insert(logEntry)

        if (error) {
          console.error('Error logging audit event to database:', error)
        }
      } catch (error) {
        console.error('Error logging audit event to database:', error)
      }
    }

    // If configured, send logs to an external service
    if (config.public.EXTERNAL_LOGGING_SERVICE) {
      try {
        await $fetch(config.public.EXTERNAL_LOGGING_SERVICE, {
          method: 'POST',
          body: JSON.stringify(logEntry),
        })
      } catch (error) {
        console.error('Error sending log to external service:', error)
      }
    }
  }

  const sanitizeLogEntry = (logEntry: AuditLogEntry) => {
    // Remove sensitive information like passwords, tokens, etc.
    if (logEntry.details && typeof logEntry.details === 'object') {
      const sensitiveFields = ['password', 'token', 'secret', 'credit_card']
      for (const field of sensitiveFields) {
        if (field in logEntry.details) {
          logEntry.details[field] = '[REDACTED]'
        }
      }
    }
  }

  const getAuditLogs = async (
    filters: Partial<AuditLogEntry>,
    pagination: { page: number, pageSize: number },
  ) => {
    let query = supabase.from('audit_logs').select('*')

    // Apply filters
    Object.entries(filters).forEach(([key, value]) => {
      if (value !== undefined) {
        query = query.eq(key, value)
      }
    })

    // Apply pagination
    const { data, error, count } = await query
      .range(pagination.page * pagination.pageSize, (pagination.page + 1) * pagination.pageSize - 1)
      .order('timestamp', { ascending: false })

    if (error) {
      console.error('Error fetching audit logs:', error)
      throw error
    }

    return { logs: data, totalCount: count }
  }

  return {
    logEvent,
    getAuditLogs,
    AuditLogLevel,
  }
}
</file>

<file path="layers/crud/composables/delete.ts">
import { useErrorHandler, AppError, ErrorSeverity, ErrorType, useLogger } from '@ib/logger'
import { useRateLimit } from './rate-limit'
import { useHttpHandler } from './http-handler'
import { getOrCreateStore } from './main.store'

export function useDeleteData<T extends { id: string | number }>(
  tableName: string,
  options: {
    validateDelete?: (id: string | number) => boolean | Promise<boolean>
    refreshRelated?: () => Promise<void>
    rateLimitMs?: number
    auditLog?: (action: string, details: any) => Promise<void>
  } = {},
) {
  const { remove } = useHttpHandler()
  const { handleError } = useErrorHandler()
  const logger = useLogger('useDeleteData')
  const store = getOrCreateStore<T>(tableName)()
  const { checkRateLimit } = useRateLimit()
  const isDeleting: Ref<boolean> = ref(false)
  let lastDeleteTime = 0

  const deleteData = async (id: string | number | (string | number)[]) => {
    isDeleting.value = true
    const startTime = Date.now()

    const deleteSingle = async (itemId: string | number): Promise<void> => {
      try {
        // Rate limiting
        if (options.rateLimitMs) {
          await checkRateLimit('useDeleteData', { limitMs: options.rateLimitMs })
        }

        // Validation
        if (options.validateDelete && !(await options.validateDelete(itemId))) {
          throw new AppError({
            type: ErrorType.VALIDATION_ERROR,
            message: 'Delete validation failed',
            severity: ErrorSeverity.MEDIUM,
            context: 'Data Validation',
          })
        }

        // Optimistic delete
        store.removeItem(itemId)

        // Perform the delete
        await remove(tableName, itemId)

        // Refresh related data if needed
        if (options.refreshRelated) {
          await options.refreshRelated()
        }

        // Audit logging
        if (options.auditLog) {
          await options.auditLog('DELETE', { tableName, id: itemId })
        }

        lastDeleteTime = Date.now()
      } catch (error: any) {
        // Revert optimistic delete
        const oldItem = store.getItemById(itemId)
        if (oldItem) {
          store.addItems([oldItem])
        }
        throw error
      }
    }

    try {
      if (Array.isArray(id)) {
        await Promise.all(id.map(deleteSingle))
      } else {
        await deleteSingle(id)
      }
    } catch (error: any) {
      handleError(error, 'Error deleting data')
      throw error
    } finally {
      isDeleting.value = false
    }
  }

  return {
    deleteData,
    isDeleting,
  }
}
</file>

<file path="layers/crud/composables/fetch.ts">
import { useLogger } from '@ib/logger'
import type { FilterBy, DBTable } from '../server/utils/base.interface'
import type { DomainKey } from './pagination.store'
import { useCookie, useRequestHeaders } from '#imports'
import type { FetchResult } from '#app'

export interface FetchInput {
  domainKey: DomainKey
  endpoint: string
  pagination?: {
    page: number
    limit: number
  }
  criteria: {
    dto: string
    filterBy?: FilterBy<DBTable>
  }
}

function getDataStructure(obj: any): any {
  if (Array.isArray(obj)) {
    return obj.length > 0 ? [getDataStructure(obj[0])] : []
  } else if (typeof obj === 'object' && obj !== null) {
    const structure: Record<string, any> = {}
    for (const key in obj) {
      structure[key] = getDataStructure(obj[key])
    }
    return structure
  } else {
    return typeof obj
  }
}

export function useBaseFetch() {
  const errors = useBaseError()
  const paginationStore = usePaginationStore()
  const loading = useLoadingStore()
  const logger = useLogger('useBaseFetch')
  const apiDataStore = useApiDataStore()

  const fetch = $fetch.create({
    retryStatusCodes: [408, 409, 425, 500, 502, 503, 504],
    headers: {
      'X-USER-ID': useCookie('userId').value ?? 'no-user-id',
      'cookie': useRequestHeaders(['cookie']).cookie ?? '',
    },
    onResponseError({ error, response, request, options }) {
      console.error('onResponseError', response, response._data, error)
    },
    async onResponse({ request, response, options }) {
      const url = request.toString()
      const structure = getDataStructure(response._data)
      console.log('Captured data structure for:', url, structure)
      apiDataStore.setData(url, structure)
    },
  })

  async function fetchPaginatedData(params: FetchInput) {
    const { domainKey, endpoint, criteria } = params

    if (loading.isLoading(domainKey)) {
      return null
    }

    if (paginationStore.isDataFinished(domainKey)) {
      return null
    }

    if (!paginationStore.getPagination(domainKey)) {
      return null
    }

    loading.setLoading(domainKey, true)

    try {
      logger.info('fetchPaginatedData for', domainKey, endpoint, criteria)
      const response = await fetch(endpoint, {
        method: 'POST',
        params: {
          ...criteria,
          pagination: paginationStore.getPaginationRange(domainKey),
        },
      })

      console.log('fetchPaginatedData RESPONSE', response)

      const data = errors.server({
        response,
        devOnly: false,
        userMessage: `Sorry there was an error getting ${domainKey} from ${endpoint}`,
        devMessage: `fetchPaginatedData errored selecting paginated ${domainKey} data from ${endpoint}`,
      })

      if (!data || !data.length || data.length < paginationStore.getPagination(domainKey)!.limit) {
        paginationStore.setDataFinished(domainKey)
      }

      await loading.setLoadingInterval(domainKey, false, 1500)
      paginationStore.incrementPagination(domainKey)

      return data
    } catch (error) {
      errors.client({
        error,
        devOnly: false,
        userMessage: `Sorry there was an error getting ${domainKey} from ${endpoint}`,
        devMessage: `fetchPaginatedData error for ${domainKey}`,
      })
    }
  }

  return {
    fetchPaginatedData,
    fetch,
  }
}
</file>

<file path="layers/crud/composables/http-handler.ts">
import type { PostgrestResponse, PostgrestError } from '@supabase/supabase-js'
import {
  useErrorHandler,
  ErrorType,
  useLogger,
  ErrorSeverity,
  AppError,
  mapErrorSeverity,
  mapErrorType,
  retryableStatusCodes,
} from '@ib/logger'
import { getOrCreateStore } from './main.store'
import { usePaginationStore, type PaginationType } from './pagination.store'

type FilterOperator =
  | 'eq'
  | 'neq'
  | 'gt'
  | 'gte'
  | 'lt'
  | 'lte'
  | 'like'
  | 'ilike'
  | 'is'
  | 'in'
  | 'contains'
  | 'containedBy'
  | 'overlaps'
  | 'textSearch'
  | 'match'
  | 'not'
  | 'or'
  | 'and'
  | 'rangeGt'
  | 'rangeGte'
  | 'rangeLt'
  | 'rangeLte'
  | 'rangeAdjacent'

type FilterOptionValue = string | number | boolean | null | any[] | Record<string, unknown>

type FilterOption = {
  [K in FilterOperator]?: K extends 'not'
    ? FilterOption
    : K extends 'or' | 'and'
      ? string
      : FilterOptionValue
}

type Filters = Record<string, FilterOption>

interface SelectOptions<T> {
  columns?: keyof T | Array<keyof T> | string
  filters?: Filters
  range?: { from: number; to: number }
  order?: { column: keyof T; ascending: boolean }
}

function applyFilter(query: any, column: string, filter: FilterOption): any {
  const [operator, value] = Object.entries(filter)[0]
  switch (operator) {
    case 'eq':
      return query.eq(column, value)
    case 'neq':
      return query.neq(column, value)
    case 'gt':
      return query.gt(column, value)
    case 'gte':
      return query.gte(column, value)
    case 'lt':
      return query.lt(column, value)
    case 'lte':
      return query.lte(column, value)
    case 'like':
      return query.like(column, value)
    case 'ilike':
      return query.ilike(column, value)
    case 'is':
      return query.is(column, value)
    case 'in':
      return query.in(column, value as any[])
    case 'contains':
      return query.contains(column, value)
    case 'containedBy':
      return query.containedBy(column, value)
    case 'rangeGt':
      return query.rangeGt(column, value)
    case 'rangeGte':
      return query.rangeGte(column, value)
    case 'rangeLt':
      return query.rangeLt(column, value)
    case 'rangeLte':
      return query.rangeLte(column, value)
    case 'rangeAdjacent':
      return query.rangeAdjacent(column, value)
    case 'overlaps':
      return query.overlaps(column, value)
    case 'textSearch':
      return query.textSearch(column, value as string, { config: 'english' })
    case 'match':
      return query.match(column, value as Record<string, unknown>)
    case 'not':
      return applyFilter(query.not(), column, value as FilterOption)
    case 'or':
      return query.or(value as string)
    case 'and':
      return query.and(value as string)
    default:
      console.warn(`Unsupported filter operator: ${operator}`)
      return query
  }
}

export function useHttpHandler() {
  const supabase = useSupabaseClient()
  const { handleError } = useErrorHandler()
  const logger = useLogger('HttpHandler')

  async function handleDatabaseOperation<T>(
    operation: () => Promise<PostgrestResponse<T>>,
    context: string,
    maxRetries: number = 3,
  ): Promise<T> {
    let retries = 0
    while (retries < maxRetries) {
      try {
        const response = await operation()
        // logger.debug(`${context} response:`, response)

        if (response.error) {
          throw response.error
        }
        return response.data as T
      } catch (error: unknown) {
        retries++
        logger.warn(`${context} failed. Attempt ${retries} of ${maxRetries}`)

        const pgError = error as PostgrestError
        const errorType = mapErrorType(pgError)
        const errorSeverity = mapErrorSeverity(pgError)

        if (
          retries >= maxRetries ||
          !Object.keys(retryableStatusCodes).includes(pgError.code?.toString() || '')
        ) {
          const appError = new AppError({
            type: errorType,
            message:
              pgError.message ||
              retryableStatusCodes[pgError.code as keyof typeof retryableStatusCodes] ||
              'Database operation failed',
            severity: errorSeverity,
            code: pgError.code,
            context: context,
            pgError: pgError.details || pgError.hint || pgError.message,
            operation: context,
          })
          throw handleError(appError)
        }

        // Exponential backoff with jitter
        const backoffTime = Math.min(1000 * 2 ** retries + Math.random() * 1000, 10000)
        await new Promise((resolve) => setTimeout(resolve, backoffTime))
      }
    }
    throw new Error('Max retries reached')
  }

  async function insert<T>(
    tableName: string,
    data: T,
    options: { columns?: string } = {},
  ): Promise<T> {
    return handleDatabaseOperation(
      async () =>
        await supabase
          .from(tableName)
          .insert(data)
          .select(options.columns || '*'),
      `Insert into ${tableName}`,
    )
  }

  async function update<T>(
    tableName: string,
    id: string | number,
    data: Partial<T>,
    options: { columns?: string } = {},
  ): Promise<T> {
    return handleDatabaseOperation(
      async () =>
        await supabase
          .from(tableName)
          .update(data)
          .eq('id', id)
          .select(options.columns || '*'),
      `Update ${tableName}`,
    )
  }

  async function remove(tableName: string, id: string | number): Promise<void> {
    await handleDatabaseOperation(
      async () => await supabase.from(tableName).delete().eq('id', id),
      `Delete from ${tableName}`,
    )
  }

  async function select<T>(tableName: string, options: SelectOptions<T> = {}): Promise<T[]> {
    let query = supabase.from(tableName).select(options.columns || '*')

    if (options.filters) {
      Object.entries(options.filters).forEach(([column, filterOption]) => {
        query = applyFilter(query, column, filterOption)
      })
    }

    if (options.range) {
      query = query.range(options.range.from, options.range.to)
    }

    if (options.order) {
      query = query.order(options.order.column, { ascending: options.order.ascending })
    }

    return handleDatabaseOperation(() => query, `Select from ${tableName}`)
  }

  return {
    insert,
    update,
    remove,
    select,
  }
}
</file>

<file path="layers/crud/composables/insert.ts">
import { useErrorHandler, AppError, ErrorType, ErrorSeverity, useLogger } from '@ib/logger'
import { useHttpHandler } from './http-handler'
import { getOrCreateStore } from './main.store'
import { useRateLimit } from './rate-limit'

type InsertError =
  | 'VALIDATION_ERROR'
  | 'NETWORK_ERROR'
  | 'SERVER_ERROR'
  | 'RATE_LIMIT_ERROR'
  | 'DUPLICATE_ERROR'

export function useInsertData<T extends { id: string | number }>(
  tableName: string,
  options: {
    columns?: string
    validateData?: (data: T) => boolean | Promise<boolean>
    maxRetries?: number
    refreshRelated?: () => Promise<void>
    transformData?: (data: T) => T
    onError?: (error: InsertError, details: any) => void
    rateLimitMs?: number
    auditLog?: (action: string, details: any) => Promise<void>
    generateClientId?: () => string | number
  } = {},
) {
  const supabase = useSupabaseClient()
  const { insert } = useHttpHandler()
  const { handleError } = useErrorHandler()
  const log = useLogger('useInsertData')
  const store = getOrCreateStore<T>(tableName)()
  const { checkRateLimit } = useRateLimit()
  const isInserting: Ref<boolean> = ref(false)
  let lastInsertTime = 0

  const insertData = async (data: T | T[]) => {
    isInserting.value = true
    const startTime = Date.now()

    const insertSingle = async (item: T): Promise<T> => {
      try {
        // Rate limiting
        if (options.rateLimitMs) {
          await checkRateLimit('useInsertData', { limitMs: options.rateLimitMs })
        }

        // Validation
        if (options.validateData && !(await options.validateData(item))) {
          throw new AppError({
            type: ErrorType.VALIDATION_ERROR,
            message: 'Data validation failed',
            severity: ErrorSeverity.MEDIUM,
            context: 'Data Validation',
          })
        }

        // Data transformation
        const transformedData = options.transformData ? options.transformData(item) : item

        // Generate client-side ID if needed
        if (options.generateClientId && !transformedData.id) {
          transformedData.id = options.generateClientId()
        }

        // Optimistic insert
        store.addItems([transformedData])

        // Perform the insert
        const result = await insert(tableName, transformedData, { columns: options.columns })

        // Update store with actual server data
        store.updateItem(result)

        // Refresh related data if needed
        if (options.refreshRelated) {
          await options.refreshRelated()
        }

        // Audit logging
        if (options.auditLog) {
          await options.auditLog('INSERT', { tableName, newData: result })
        }

        lastInsertTime = Date.now()
        return result
      } catch (error: any) {
        // Revert optimistic insert
        store.removeItem(item.id)
        throw error // error handler in the HTTP handler deals with this
      }
    }

    try {
      if (Array.isArray(data)) {
        const results = await Promise.all(data.map(insertSingle))
        isInserting.value = false
        return results
      } else {
        const result = await insertSingle(data)
        isInserting.value = false
        return result
      }
    } catch (error: any) {
      handleError(error, 'Error inserting data')
      throw error // Re-throw to allow caller to handle if needed
    } finally {
      isInserting.value = false
    }
  }

  return {
    insertData,
    isInserting,
  }
}
</file>

<file path="layers/crud/composables/loading.store.ts">
import type { DomainKey } from './pagination.store'

type Loaders = {
  [K in DomainKey]?: boolean
}

export const useLoadingStore = defineStore('storeLoading', () => {
  const loaders = ref({} as Loaders)

  function setLoading(key: DomainKey, isLoading: boolean) {
    loaders.value[key] = isLoading
  }

  async function setLoadingInterval(key: DomainKey, isLoading: boolean, time: number) {
    await new Promise<void>((resolve) => {
      setTimeout(() => {
        setLoading(key, isLoading)
        resolve()
      }, time)
    })
  }

  function isLoading(key: DomainKey) {
    return !!loaders.value[key]
  }

  return {
    setLoadingInterval,
    setLoading,
    isLoading,
  }
})

if (import.meta.hot) {
  import.meta.hot.accept(acceptHMRUpdate(useLoadingStore, import.meta.hot))
}
</file>

<file path="layers/crud/composables/local-storage.ts">
import { useLogger } from '@ib/logger'

const CACHE_DURATION = 24 * 60 * 60 * 1000 // 24 hours in milliseconds
const CACHE_VERSION = '1.0' // Increment this when data structure changes

const LocalStorageEnum = {
  CATEGORIES: 'astronera-categories',
  TAGS: 'astronera-tags',
} as const

type LocalStorageKey = (typeof LocalStorageEnum)[keyof typeof LocalStorageEnum]

interface CachedData<T> {
  version: string
  timestamp: number
  data: T
}

export function useBaseLocalStorage() {
  const logger = useLogger('localStorage')

  function getCacheKey(key: LocalStorageKey): string {
    return `${key}-${CACHE_VERSION}`
  }

  function clearCache(key: LocalStorageKey): void {
    localStorage.removeItem(getCacheKey(key))
    logger.debug(`Cleared cache for: ${key}`)
  }

  function clearAllCaches(): void {
    Object.values(LocalStorageEnum).forEach(clearCache)
    logger.debug('Cleared all caches')
  }

  function getFromCache<T>(key: LocalStorageKey): T | null {
    const cacheKey = getCacheKey(key)
    const cachedItem = localStorage.getItem(cacheKey)

    if (!cachedItem) {
      logger.debug(`No cached data found for: ${key}`)
      return null
    }

    try {
      const parsedData = JSON.parse(cachedItem) as CachedData<T>
      const currentTime = Date.now()

      if (
        currentTime - parsedData.timestamp <= CACHE_DURATION &&
        parsedData.version === CACHE_VERSION
      ) {
        logger.debug(`Retrieved valid cached data for: ${key}`)
        return parsedData.data
      } else {
        logger.debug(`Cached data for ${key} is outdated or version mismatch`)
        clearCache(key)
        return null
      }
    } catch (error) {
      logger.error(`Error parsing cached data for ${key}:`, error)
      clearCache(key)
      return null
    }
  }

  function setCache<T>(key: LocalStorageKey, data: T): void {
    const cacheKey = getCacheKey(key)
    const cacheData: CachedData<T> = {
      version: CACHE_VERSION,
      timestamp: Date.now(),
      data,
    }
    localStorage.setItem(cacheKey, JSON.stringify(cacheData))
    logger.debug(`Cached data for: ${key}`)
  }

  async function getCachedOrFetch<T>(key: LocalStorageKey, fetchFn: () => Promise<T>): Promise<T> {
    const cachedData = getFromCache<T>(key)
    if (cachedData) return cachedData

    try {
      const fetchedData = await fetchFn()
      setCache(key, fetchedData)
      return fetchedData
    } catch (error) {
      logger.error(`Error fetching data for ${key}:`, error)
      throw error
    }
  }

  return {
    getFromCache,
    setCache,
    clearCache,
    clearAllCaches,
    getCachedOrFetch,
  }
}
</file>

<file path="layers/crud/composables/main.store.ts">
import { defineStore } from 'pinia'
import { type Ref, ref } from 'vue'
import type { DomainKey } from './pagination.store'

export function createBaseStore<T extends object>(domainKey: DomainKey) {
  return defineStore(`${domainKey}Store`, () => {
    const items = ref<T[]>([]) as Ref<T[]>
    const itemsMap = computed(() => new Map(items.value.map((item) => [item.id, item])))

    function setItems(newItems: T[]) {
      items.value = newItems
    }

    function addItems(newItems: T[]) {
      const newItemsMap = new Map(newItems.map((item) => [item.id, item]))
      items.value = [...items.value.filter((item) => !newItemsMap.has(item.id)), ...newItems]
    }

    function updateItem(updatedItem: T) {
      const index = items.value.findIndex((item) => item.id === updatedItem.id)
      if (index !== -1) {
        items.value[index] = { ...items.value[index], ...updatedItem }
      } else {
        items.value.push(updatedItem)
      }
    }

    function removeItem(id: string | number) {
      items.value = items.value.filter((item) => item.id !== id)
    }

    function clearItems() {
      items.value = []
    }

    function getItemById(id: string | number) {
      return itemsMap.value.get(id)
    }

    return {
      items,
      itemsMap,
      setItems,
      addItems,
      updateItem,
      removeItem,
      clearItems,
      getItemById,
    }
  })
}

const storeCache: Partial<Record<DomainKey, ReturnType<typeof createBaseStore>>> = {}

export function getOrCreateStore<T>(domainKey: DomainKey) {
  if (!storeCache[domainKey]) {
    storeCache[domainKey] = createBaseStore<T>(domainKey)
  }
  return storeCache[domainKey] as ReturnType<typeof createBaseStore<T>>
}
</file>

<file path="layers/crud/composables/notification.ts">
import type { useToast } from 'primevue/usetoast'

interface BaseNotification {
  summary: string
  message: string
}

export function useNotification() {
  const nuxtApp = useNuxtApp()
  const getToast: typeof useToast = () => nuxtApp.vueApp.config.globalProperties.$toast
  const toast = getToast()

  const success = ({ summary, message }: BaseNotification) => {
    toast.add({
      severity: 'success',
      summary: `Success: ${summary}`,
      detail: message,
      life: 5000,
      closable: true,
    })
  }

  const error = ({ summary, message }: BaseNotification) => {
    toast.add({
      severity: 'error',
      summary: `Error: ${summary}`,
      detail: message,
      life: 0,
      closable: true,
    })
  }

  const info = ({ summary, message }: BaseNotification) => {
    toast.add({
      severity: 'info',
      summary: `Info: ${summary}`,
      detail: message,
      life: 5000,
      closable: true,
    })
  }

  const warn = ({ summary, message }: BaseNotification) => {
    toast.add({
      severity: 'warn',
      summary: `Warning: ${summary}`,
      detail: message,
      life: 5000,
      closable: true,
    })
  }

  const feature = ({ summary, message }: BaseNotification) => {
    toast.add({
      severity: 'warn',
      group: 'cta',
      summary: summary,
      detail: message,
      life: 0,
      closable: true,
    })
  }

  return {
    success,
    error,
    info,
    warn,
    feature,
  }
}
</file>

<file path="layers/crud/composables/pagination.store.ts">
import { useLogger } from '@ib/logger'

export type DomainKey =
  | 'users'
  | 'news'
  | 'events'
  | 'venues'
  | 'research'
  | 'companies'
  | 'chats'
  | 'feedbacks'
  | 'currentUser'
  | 'chat'
  | 'auth'

export type PaginationType = {
  page: number
  limit: number
}

export interface PaginationInput {
  domainKey: DomainKey
  pagination: PaginationType
  force?: boolean
}

export const usePaginationStore = defineStore('paginationStore', () => {
  const logger = useLogger('paginationStore')
  const stores = reactive({} as Record<DomainKey, Ref<{ page: number; limit: number }>>)
  const dataFinished = ref({} as Record<DomainKey, boolean>)

  function initPagination(input: PaginationInput) {
    if (!stores[input.domainKey] || input.force) {
      // -1 for supabase because it is 0 indexed
      console.log('initPagination', input.force)
      stores[input.domainKey] = {
        page: input.pagination.page,
        limit: input.pagination.limit - 1,
      }
    }
  }

  function getPagination(domainKey: DomainKey) {
    if (!stores[domainKey]) {
      logger.warn(`Pagination settings for '${domainKey}' is not initialized.`)
      return null
    }

    return stores[domainKey]
  }

  function getPaginationRange(domainKey: DomainKey) {
    const pagination = getPagination(domainKey)
    if (pagination) {
      logger.info('getPaginationRange', pagination.limit, (pagination.page - 1) * pagination.limit)
      return {
        from: (pagination.page - 1) * pagination.limit,
        to: pagination.limit * pagination.page,
      }
    }
    return undefined
  }

  function incrementPagination(domainKey: DomainKey) {
    const currentPagination = getPagination(domainKey)
    if (currentPagination) {
      currentPagination.page++
    } else {
      logger.warn(`Attempted to increment pagination for an uninitialized store '${domainKey}'.`)
    }
  }

  function setDataFinished(domainKey: DomainKey) {
    if (stores[domainKey]) {
      dataFinished.value[domainKey] = true
    }
  }

  const isDataFinished = (domainKey: DomainKey) => dataFinished.value[domainKey]

  return {
    stores,
    isDataFinished,
    setDataFinished,
    initPagination,
    getPagination,
    incrementPagination,
    getPaginationRange,
  }
})
</file>

<file path="layers/crud/composables/rate-limit.ts">
interface RateLimitOptions {
  limitMs: number
}

export function useRateLimit() {
  const lastActionTimes = ref<Map<string, number>>(new Map())

  const checkRateLimit = async (action: string, options: RateLimitOptions): Promise<void> => {
    const now = Date.now()
    const lastActionTime = lastActionTimes.value.get(action) || 0
    const timeElapsed = now - lastActionTime

    if (timeElapsed < options.limitMs) {
      const waitTime = options.limitMs - timeElapsed
      await new Promise((resolve) => setTimeout(resolve, waitTime))
    }

    lastActionTimes.value.set(action, Date.now())
  }

  return {
    checkRateLimit,
  }
}
</file>

<file path="layers/crud/composables/select.ts">
import { useErrorHandler, AppError, ErrorType, ErrorSeverity, useLogger } from '@ib/logger'
import { useHttpHandler } from './http-handler'
import { getOrCreateStore } from './main.store'
import { usePaginationStore, type PaginationType } from './pagination.store'
import { useRateLimit } from './rate-limit'

export function useSelectData<T extends { id: string | number }>(
  tableName: string,
  options: {
    columns?: string
    filters?: Record<string, any>
    orderBy?: { column: string; ascending?: boolean }
    initialFetch?: boolean
    pagination?: PaginationType
    limit?: number
    refreshRelated?: () => Promise<void>
    rateLimitMs?: number
    auditLog?: (action: string, details: any) => Promise<void>
  } = {},
) {
  const { select } = useHttpHandler()
  const { handleError } = useErrorHandler()
  const logger = useLogger('useSelectData')
  const store = getOrCreateStore<T>(tableName)()
  const { checkRateLimit } = useRateLimit()

  const isSelecting: Ref<boolean> = ref(false)
  let lastSelectTime = 0

  let paginationStore: ReturnType<typeof usePaginationStore> | null = null

  if (options.pagination) {
    paginationStore = usePaginationStore()
    paginationStore.initPagination({
      domainKey: tableName,
      pagination: options.pagination,
      force: true,
    })
  }

  const fetchData = async (forceFetch = false) => {
    isSelecting.value = true
    const startTime = Date.now()

    try {
      // Rate limiting
      if (options.rateLimitMs && !forceFetch) {
        await checkRateLimit('useSelectData', { limitMs: options.rateLimitMs })
      }

      const queryOptions: any = {
        columns: options.columns || '*',
        filters: options.filters,
      }

      if (options.orderBy) {
        queryOptions.order = {
          column: options.orderBy.column,
          ascending: options.orderBy.ascending ?? true,
        }
      }

      if (paginationStore) {
        const pagination = paginationStore.getPaginationRange(tableName)
        if (pagination) {
          console.log('pagination', pagination)
          queryOptions.range = pagination
        } else {
          throw new AppError({
            type: ErrorType.VALIDATION_ERROR,
            message: `Pagination not initialized for ${tableName}`,
            severity: ErrorSeverity.MEDIUM,
            context: 'Data Fetching',
          })
        }
      } else if (options.limit) {
        queryOptions.range = { from: 0, to: options.limit - 1 }
      }

      const result = await select<T>(tableName, queryOptions)
      console.log('Fetch result:', result)

      // Audit logging
      if (options.auditLog) {
        await options.auditLog('SELECT', { tableName, options: queryOptions })
      }

      lastSelectTime = Date.now()
      return result
    } catch (error: any) {
      handleError(error, 'Error selecting data')
      throw error
    } finally {
      isSelecting.value = false
    }
  }

  const loadMore = async () => {
    if (paginationStore) {
      console.log('loading more data')
      const newData = await fetchData()
      if (newData.length === 0) {
        paginationStore.setDataFinished(tableName)
      } else {
        store.addItems(newData)
        paginationStore.incrementPagination(tableName)
      }
    } else {
      const data = await fetchData()
      store.setItems(data)
    }

    // Refresh related data if needed
    if (options.refreshRelated) {
      await options.refreshRelated()
    }
  }

  const refresh = async () => {
    if (paginationStore) {
      paginationStore.initPagination({
        domainKey: tableName,
        pagination: options.pagination!,
        force: true,
      })
    }
    store.clearItems()
    await loadMore()
  }

  if (options.initialFetch) {
    loadMore()
  }

  return {
    store,
    loadMore,
    refresh,
    isSelecting,
  }
}
</file>

<file path="layers/crud/composables/settings.store.ts">
type SettingsKey = 'usersStore' | 'storeNews'

export const useSettingsStore = defineStore('settingsStore', () => {
  const settings = ref({} as Settings)
  const summaryLevel = ref('beginner' as SummaryLevel)

  function toggleSettings(key: SettingsKey) {
    settings.value[key] = !settings.value[key]
  }

  function isSettingsOn(key: SettingsKey) {
    return !settings.value[key]
  }

  const changeSummaryLevel = (level: 'beginner' | 'intermediate' | 'expert') => {
    summaryLevel.value = level
  }

  return {
    toggleSettings,
    isSettingsOn,
  }
})

if (import.meta.hot) {
  import.meta.hot.accept(acceptHMRUpdate(useSettingsStore, import.meta.hot))
}
</file>

<file path="layers/crud/composables/update.ts">
import { useErrorHandler, AppError, ErrorSeverity, ErrorType, useLogger } from '@ib/logger'
import { useHttpHandler } from './http-handler'
import { getOrCreateStore } from './main.store'
import { useRateLimit } from './rate-limit'

export function useUpdateData<T extends { id: string | number }>(
  tableName: string,
  options: {
    columns?: string
    validateData?: (data: Partial<T>) => boolean | Promise<boolean>
    refreshRelated?: () => Promise<void>
    transformData?: (data: Partial<T>) => Partial<T>
    rateLimitMs?: number
    auditLog?: (action: string, details: any) => Promise<void>
  } = {},
) {
  const { update } = useHttpHandler()
  const { handleError } = useErrorHandler()
  const logger = useLogger('useUpdateData')
  const store = getOrCreateStore<T>(tableName)()
  const { checkRateLimit } = useRateLimit()

  const isUpdating: Ref<boolean> = ref(false)
  let lastUpdateTime = 0

  const updateData = async (id: string | number, data: Partial<T>) => {
    isUpdating.value = true
    const startTime = Date.now()
    let oldData: T | undefined = undefined

    try {
      // Rate limiting
      if (options.rateLimitMs) {
        await checkRateLimit('useUpdateData', { limitMs: options.rateLimitMs })
      }

      // Validation
      if (options.validateData && !(await options.validateData(data))) {
        throw new AppError({
          type: ErrorType.VALIDATION_ERROR,
          message: 'Data validation failed',
          severity: ErrorSeverity.MEDIUM,
          context: 'Data Validation',
        })
      }

      // Data transformation
      const transformedData = options.transformData ? options.transformData(data) : data

      // Optimistic update
      oldData = store.getItemById(id)
      if (!oldData) {
        throw new AppError({
          type: ErrorType.NOT_FOUND_ERROR,
          message: 'Item not found in store',
          severity: ErrorSeverity.MEDIUM,
          context: 'Data Update',
        })
      }
      store.updateItem({ ...oldData, ...transformedData, id })

      // Perform the update
      const result = await update(tableName, id, transformedData, { columns: options.columns })

      // Update store with actual server data
      store.updateItem(result)

      // Refresh related data if needed
      if (options.refreshRelated) {
        await options.refreshRelated()
      }

      // Audit logging
      if (options.auditLog) {
        await options.auditLog('UPDATE', { tableName, id, oldData, newData: result })
      }

      lastUpdateTime = Date.now()
      return result
    } catch (error: any) {
      // Revert optimistic update
      if (oldData) {
        store.updateItem(oldData)
      }
      handleError(error, 'Error updating data')
      throw error
    } finally {
      isUpdating.value = false
    }
  }

  return {
    updateData,
    isUpdating,
  }
}
</file>

<file path="layers/crud/composables/upload.ts">
import { v4 as uuidv4 } from 'uuid'
import { useErrorHandler, AppError, ErrorType, ErrorSeverity, useLogger } from '@ib/logger'
import { useRateLimit } from './rate-limit'

type FileType = 'profile' | 'document' | 'image' | 'video' | 'audio' | 'other'

interface UploadOptions {
  bucket: string
  path: string
  fileType: FileType
  userId?: string
  metadata?: Record<string, string>
  optimizeImage?: boolean
  maxWidth?: number
  maxHeight?: number
  quality?: number
  format?: 'jpeg' | 'jpg' | 'png' | 'webp'
  rateLimitMs?: number
  auditLog?: (action: string, details: any) => Promise<void>
  onProgress?: (progress: number) => void
  maxFileSize?: number
  allowedMimeTypes?: string[]
  serverSideOptimize?: boolean
  useServerUpload?: boolean
  replace?: boolean
}

interface UploadResult {
  path: string
  publicUrl: string
  size: number
  mimeType: string
  metadata: Record<string, string>
}

export function useFileUpload() {
  const supabase = useSupabaseClient()
  const { handleError } = useErrorHandler()
  const { checkRateLimit } = useRateLimit()
  const isUploading: Ref<boolean> = ref(false)
  const uploadProgress: Ref<number> = ref(0)
  const lastUploadTime = ref(0)
  const uploadQueue: Ref<File[]> = ref([])
  const currentUpload: Ref<File | null> = ref(null)

  const isProcessing = computed(() => uploadQueue.value.length > 0 || currentUpload.value !== null)

  const getFilePath = (fileName: string, options: UploadOptions): string => {
    const { bucket, path, fileType, userId, replace } = options
    const timestamp = new Date().toISOString().replace(/[-:]/g, '').split('.')[0]
    const uniqueId = uuidv4().slice(0, 8)
    const userPath = userId ? `${userId}/` : ''
    return `${bucket}/${fileType}/${userPath}${path || ''}/${replace ? '' : `${timestamp}_${uniqueId}_`}${fileName}`
  }

  const validateFile = (file: File, options: UploadOptions): void => {
    if (options.maxFileSize && file.size > options.maxFileSize) {
      throw new AppError({
        type: ErrorType.VALIDATION_ERROR,
        message: `File size exceeds the maximum allowed size of ${options.maxFileSize} bytes`,
        severity: ErrorSeverity.MEDIUM,
        context: 'File Upload',
      })
    }

    if (options.allowedMimeTypes && !options.allowedMimeTypes.includes(file.type)) {
      throw new AppError({
        type: ErrorType.VALIDATION_ERROR,
        message: `File type ${file.type} is not allowed`,
        severity: ErrorSeverity.MEDIUM,
        context: 'File Upload',
      })
    }
  }

  const serverSideUpload = async (file: File, options: UploadOptions): Promise<UploadResult> => {
    const formData = new FormData()
    formData.append('file', file)
    formData.append('userId', options.userId || '')
    formData.append('fileType', options.fileType)
    formData.append('bucket', options.bucket)
    formData.append('path', options.path)
    formData.append(
      'optimizationOptions',
      JSON.stringify({
        maxWidth: options.maxWidth,
        maxHeight: options.maxHeight,
        quality: options.quality,
        format: options.format,
      }),
    )

    const response = await $fetch('/api/upload', {
      method: 'POST',
      body: formData,
      onUploadProgress: (progressEvent) => {
        if (progressEvent.total) {
          const progress = Math.round((progressEvent.loaded * 100) / progressEvent.total)
          uploadProgress.value = progress
          options.onProgress?.(progress)
        }
      },
    })

    if (!response || !response.fileName) {
      throw new Error('Failed to upload file on server')
    }

    const publicUrl = supabase.storage.from(options.bucket).getPublicUrl(response.fileName)
      .data.publicUrl

    return {
      path: response.fileName,
      publicUrl,
      size: file.size,
      mimeType: file.type,
      metadata: {
        originalName: file.name,
        ...options.metadata,
      },
    }
  }

  const uploadFile = async (file: File, options: UploadOptions): Promise<UploadResult> => {
    isUploading.value = true
    uploadProgress.value = 0
    currentUpload.value = file

    try {
      validateFile(file, options)

      // Rate limiting
      if (options.rateLimitMs) {
        await checkRateLimit('fileUpload', { limitMs: options.rateLimitMs })
      }

      let result: UploadResult

      if (options.useServerUpload) {
        result = await serverSideUpload(file, options)
      } else {
        const filePath = getFilePath(file.name, options)
        const { data, error } = await supabase.storage.from(options.bucket).upload(filePath, file, {
          cacheControl: '3600',
          upsert: options.replace,
          contentType: file.type,
        })

        if (error) {
          throw new AppError({
            type: ErrorType.UPLOAD_ERROR,
            message: `Error uploading file: ${error.message}`,
            severity: ErrorSeverity.HIGH,
            context: 'File Upload',
          })
        }

        const {
          data: { publicUrl },
        } = supabase.storage.from(options.bucket).getPublicUrl(data.path)

        result = {
          path: data.path,
          publicUrl,
          size: file.size,
          mimeType: file.type,
          metadata: {
            originalName: file.name,
            ...options.metadata,
          },
        }
      }

      lastUploadTime.value = Date.now()

      return result
    } catch (error: any) {
      handleError(error, 'Error uploading file')
      throw error
    } finally {
      isUploading.value = false
      uploadProgress.value = 100
      currentUpload.value = null
      processQueue()
    }
  }

  const processQueue = async () => {
    if (uploadQueue.value.length > 0 && !isUploading.value) {
      const nextFile = uploadQueue.value.shift()
      if (nextFile) {
        await uploadFile(nextFile, {
          bucket: 'default',
          path: 'uploads',
          fileType: 'other',
        })
      }
    }
  }

  const queueUpload = (file: File, options: UploadOptions) => {
    uploadQueue.value.push(file)
    processQueue()
  }

  const cancelUpload = () => {
    if (currentUpload.value) {
      // Implement cancellation logic here
      // This might involve aborting the Supabase upload if possible
      currentUpload.value = null
      isUploading.value = false
      uploadProgress.value = 0
    }
  }

  const clearQueue = () => {
    uploadQueue.value = []
  }

  return {
    uploadFile,
    queueUpload,
    cancelUpload,
    clearQueue,
    isUploading,
    isProcessing,
    uploadProgress,
    currentUpload,
    uploadQueue,
  }
}
</file>

<file path="layers/crud/composables/useApiDataStore.ts">
// stores/apiData.ts
import { defineStore } from 'pinia'
import { ref } from 'vue'

interface ApiDataStructure {
  [key: string]: any
}

export const useApiDataStore = defineStore('apiData', () => {
  const apiData = ref<ApiDataStructure>({})

  const setData = (url: string, data: any): void => {
    apiData.value[url] = data
  }

  const getData = (url: string): any => {
    return apiData.value[url]
  }

  const clearData = (): void => {
    apiData.value = {}
  }

  return {
    apiData,
    setData,
    getData,
    clearData,
  }
})
</file>

<file path="layers/crud/composables/useBaseError.ts">
import { useLogger } from '@ib/logger'

interface ErrorMessage {
  userMessage: string // User-friendly error message if needed
  devMessage: string // Make bugfixing easy!
  error: any
}

interface ErrorServer extends Omit<ErrorMessage, 'error'> {
  devOnly: boolean // default true - don't show toasts in production
  featureRelated?: boolean // default false - log to feature-specific log
  response: { data: any; error: any }
}

interface ErrorClient extends ErrorMessage {
  isServer?: boolean // default false
  featureRelated?: boolean // default false - log to feature-specific log
  devOnly: boolean
}

export function useBaseError() {
  // !todo:med:easy - add prefix to base error

  // const toast = useNotification()
  const logger = useLogger('useBaseError')
  const isAdmin = useRuntimeConfig().public.nodeEnv === 'development'

  // function handleErrorWithCodes(error: any) {
  //   switch (error.statusCode) {
  //     case 429:
  //       toast.feature({
  //         summary: error.statusMessage,
  //         message: error.message,
  //       })
  //       break
  //     case 403:
  //       toast.error({
  //         summary: error.statusMessage,
  //         message: error.message,
  //       })
  //       break
  //     default:
  //       console.error('Unhandled feature error:', error)
  //   }
  // }

  function formatErrorMessage({ userMessage, devMessage, error }: ErrorMessage) {
    const devError = `${devMessage}: ${JSON.stringify(error)}`
    logger.error(devError)
    const userError = userMessage || 'An unexpected error occurred. Please try again later.'
    return isAdmin ? devError : userError
  }

  function handleError({
    userMessage,
    devMessage,
    devOnly = true,
    isServer = false,
    error,
  }: ErrorClient) {
    // Determine the appropriate user message
    const errorMessage = formatErrorMessage({ error, userMessage, devMessage })

    // Add an error toast notification with an option to retry if an action is provided

    // Handle critical errors specifically if needed
    if (!devOnly || isAdmin) {
      // toast.error({
      //   summary: 'Error',
      //   message: errorMessage,
      // })
      // Here you could navigate to an error page, log out the user, etc.
      console.error('Handling critical error for:', devMessage)
    }

    throw createError({
      message: `${isServer ? 'SERVER' : 'CLIENT'} ERROR: ${errorMessage}`,
    })
  }

  function handleServerError({ response, devMessage, devOnly, userMessage }: ErrorServer) {
    if (response.error) {
      console.log('FeatError', response.error)
      handleError({
        error: response.error,
        devOnly,
        userMessage,
        isServer: true,
        devMessage,
      })
    } else if (response.data) {
      logger.info(`Successfully fetched ${response.data.length} items`)
      return response.data
    }
    logger.info('Nothing returned from database')
    return null
  }

  return {
    server: handleServerError,
    client: handleError,
  }
}
</file>

<file path="layers/crud/composables/user.current.store.ts">
import { useLogger } from '@ib/logger'

const DOMAIN_KEY = 'currentUser'

export const useCurrentUser = defineStore(DOMAIN_KEY, () => {
  const authUrl = useRuntimeConfig().public.aeAuthUrl
  const logger = useLogger(DOMAIN_KEY)
  const errors = useBaseError()
  const loading = useLoadingStore()
  const { fetch } = useBaseFetch()
  const userId = useCookie('userId')
  const user = useSupabaseUser()

  // check:critical - user should only be able to fetch their own full profile
  // check:critical - user should only be able to update their own profile
  // todo:high - allow user to update their profile info
  // todo:med - merge currentUser and profile into one, store all required data everything in their session
  // assign Posthog identify

  console.log('user', user.value)

  const profile = computed(() => ({
    id: user.value?.id,
    given_name: user.value?.user_metadata?.given_name,
    email_confirmed_at: user.value?.email_confirmed_at,
    confirmation_sent_at: user.value?.confirmation_sent_at,
    confirmed_at: user.value?.confirmed_at,
    created_at: user.value?.created_at,
    surname: user.value?.user_metadata?.surname,
    last_sign_in_at: user.value?.last_sign_in_at,
    email: user.value?.email,
    providers: user.value?.app_metadata.providers,
    avatar: user.value?.user_metadata.avatar ?? user.value?.user_metadata.avatar_url,
    provider: user.value?.provider,
    user_role: user.value?.app_metadata?.role,
    user_plan: user.value?.app_metadata?.plan,
  }))

  // extract as util func
  function hasValueChanged(newValue: any, currentValue: any): boolean {
    console.log('hasValueChanged', newValue, currentValue)
    if (
      typeof newValue === 'string' ||
      typeof newValue === 'boolean' ||
      typeof newValue === 'number'
    ) {
      return newValue !== currentValue
    } else if (Array.isArray(newValue)) {
      return JSON.stringify(newValue) !== JSON.stringify(currentValue)
    } else if (typeof newValue === 'object' && newValue !== null) {
      return JSON.stringify(newValue) !== JSON.stringify(currentValue)
    } else {
      return newValue !== currentValue
    }
  }

  function cleanDataForUpdate(newData: any, previousData: any) {
    const updatedData: any = {}
    for (const key in newData) {
      if (
        Object.hasOwnProperty.call(newData, key) &&
        hasValueChanged(newData[key], previousData[key])
      ) {
        updatedData[key] = newData[key]
      }
    }

    return { data: updatedData, noDataUpdated: Object.keys(updatedData).length === 0 }
  }

  async function updateProfile(newData: any, isMock: boolean = false) {
    logger.info('Starting updateProfile function', { newData, isMock })
    const updatedData: any = {}

    logger.debug('Cleaning data for update')
    // Compare newData with fullProfile and only include changed values
    const { noDataUpdated, data } = cleanDataForUpdate(newData, profile.value)

    if (noDataUpdated) {
      logger.info('No changes detected, no update necessary')
      return
    }

    logger.debug('Changes detected', { changedData: data })

    try {
      logger.info('Sending update request to server')
      let response
      if (isMock) {
        logger.info('Using mock API call')
        // response = await mockApiCall(data)
      } else {
        response = await $fetch('/api/users/update', {
          method: 'POST',
          body: JSON.stringify(data),
        })
      }
      logger.debug('Received response from server', { response })

      const validData = errors.server({
        response,
        devOnly: false,
        devMessage: 'Error updating user profile',
        userMessage: 'There was an error updating your profile after action',
      })

      logger.info('Successfully validated server response', { validData })

      // update state
      logger.debug('Updating user profile state')
      for (const key in validData[0]) {
        if (Object.hasOwnProperty.call(validData[0], key)) {
          logger.debug(`Updating profile field: ${key}`, {
            newValue: validData[0][key],
          })
        }
      }
      logger.info('Profile update completed successfully')
    } catch (error) {
      logger.error('Error occurred during profile update', { error })
      throw error // Re-throw the error for the caller to handle
    }
  }

  // Test function
  async function testUpdateProfile() {
    const testCases = [
      { name: 'John Doe', email: 'john@example.com' },
      { name: 'Jane Doe', email: 'error@example.com' }, // This will trigger an error
      {}, // This should result in no update
    ]

    for (const testCase of testCases) {
      try {
        console.log('Testing with data:', testCase)
        await updateProfile(testCase, true) // Use mock API
        console.log('Test passed successfully')
      } catch (error) {
        console.error('Test failed:', error.message)
      }
      console.log('---')
    }
  }

  type FileType = 'avatar'
  async function uploadImage(fileType: FileType, blob: Blob) {
    // currentFileName is the current file name in the database eg. avatar-drew-macgibbon.jpg
    const formData = new FormData()
    formData.append('file', blob)

    const response = await $fetch('/api/users/insert/image', {
      method: 'POST',
      body: formData,
      params: {
        fileType,
        userId: userId.value,
      },
    })

    console.log('fileName', response)

    const fileName = errors.server({
      response,
      devOnly: false,
      devMessage: `Error uploading ${fileType} image`,
      userMessage: `There was an error uploading your ${fileType}`,
    })

    let newData = {}

    console.log('fileName', fileName)

    if (fileType === 'avatar') {
      newData = {
        avatar: fileName,
      }
    }

    updateProfile(newData)
  }

  // first check if the user has an avatar in their profile
  // if not, check if the user has an avatar in their identities
  // cycle through identities check identities_data for picture

  return {
    haveUserSession: computed(() => !!profile.value),
    isAdmin: computed(
      () => profile.value?.user_role === 'admin' || profile.value?.user_role === 'super_admin',
    ),
    registeredWithProvider: computed(() => profile.value?.provider),
    profile,
    uploadImage,
    updateProfile,
    testUpdateProfile,
  }
})

if (import.meta.hot) {
  import.meta.hot.accept(acceptHMRUpdate(useCurrentUser, import.meta.hot))
}
</file>

<file path="layers/crud/server/utils/base.interface.ts">
type DBTable = keyof Database['public']['Tables'] & keyof Database['public']['Views']
type DBColumns<T extends DBTable> = keyof Tables<T>
type TableSpecificColumns<T extends DBTable> = Partial<DBColumns<T>>

// full list of filters here: https://postgrest.org/en/v12/references/api/tables_views.html#operators

type FilterKey =
  | 'eq'
  | 'match'
  | 'neq'
  | 'not'
  | 'gte'
  | 'gt'
  | 'lt'
  | 'lte'
  | 'like'
  | 'ilike'
  | 'is'
  | 'in'
  | 'contains'
  | 'containedBy'
  | 'rangeGt'
  | 'rangeGte'
  | 'rangeLt'
  | 'rangeLte'
  | 'rangeAdjacent'
  | 'overlaps'
  | 'textSearch'

interface Pagination {
  page?: number
  limit?: number
  from: number
  to: number
}

export type GenericReturn<T> = Promise<T[] | T | null>

export type TableKey = keyof Database['public']['Tables'] | keyof Database['public']['Views']

export type FilterBy<T extends DBTable> = {
  columnName: TableSpecificColumns<T>
  operator: FilterKey
  value: string | boolean | number
}

type OrderBy<T extends DBTable> = {
  columnNames: TableSpecificColumns<T>[]
  ascending: boolean
  referenceTable?: string
}

type Conflict = {
  onConflict: string[]
  ignoreDuplicates: boolean
  count?: 'exact' | 'planned' | 'estimated'
  defaultToNull?: boolean
}

// todo: refactor to have options under select/insert/update/delete
// for instance we can group limit, pagination, selectStatement all under select
export interface BaseOperationInput<T, K extends DBTable> {
  tableName: K
  data?: T | T[]
  selectStatement?: string
  filterBy?: FilterBy<K> | false
  orderBy?: OrderBy<K> | false
  pagination?: Pagination | false
  limit?: number
  isSingle?: boolean
  isReturned?: boolean
  conflict?: Conflict
}

export interface SelectInput<T, K extends DBTable> extends BaseOperationInput<T, K> {
  selectStatement: string
}

export interface InsertInput<T, K extends DBTable> extends BaseOperationInput<T, K> {
  data: T | T[]
}

export interface UpsertInput<T, K extends DBTable> extends BaseOperationInput<T, K> {
  data: T | T[]
  conflict: Conflict
}

export interface UpdateInput<T, K extends DBTable> extends BaseOperationInput<T, K> {
  data: T | T[]
  filterBy: FilterBy<K>
}

export interface DeleteInput<T, K extends DBTable> extends BaseOperationInput<T, K> {
  data: T | T[]
  filterBy: FilterBy<K>
}

export type { Database, Tables, DBTable }
</file>

<file path="layers/crud/nuxt.config.ts">
export default defineNuxtConfig({
  modules: ['@nuxtjs/supabase'],

  supabase: {
    redirect: false,
    clientOptions: {
      auth: {
        flowType: 'pkce',
        detectSessionInUrl: true,
        persistSession: true,
        autoRefreshToken: true,
      },
    },
    cookieName: 'sb',
  },
})
</file>

</repository_files>
