This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-11-21T14:47:48.647Z

# File Summary

## Purpose
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A header with the file path (## File: path/to/file)
  b. The full contents of the file in a code block

## Usage Guidelines
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
- Code comments have been removed.

## Additional Info

For more information about Repomix, visit: https://github.com/yamadashy/repomix

# Repository Structure
```
libs/
  logger/
    src/
      environment.d.ts
      environment.ts
      error-interface.ts
      handler.ts
      logger.ts
    index.d.ts
    index.ts
```

# Repository Files

## File: libs/logger/src/environment.d.ts
```typescript
declare global {
  interface RuntimeConfig {
    public: {
      nodeEnv?: string
      [key: string]: any
    }
    [key: string]: any
  }
  type UseRuntimeConfig = () => RuntimeConfig
  const useRuntimeConfig: UseRuntimeConfig | undefined
}
export interface ImportMetaEnv {
  MODE: string
  DEV: boolean
  PROD: boolean
  [key: string]: any
}
export interface ImportMeta {
  url: string
  env: ImportMetaEnv
  readonly hot?: {
    accept: () => void
    dispose: () => void
    invalidate: () => void
    [key: string]: any
  }
}
export {}
```

## File: libs/logger/src/environment.ts
```typescript
export const getEnvironment = () => {
  const isNode = (() => {
    try {
      return typeof globalThis.process !== 'undefined' && !!globalThis.process?.versions?.node
    } catch {
      return false
    }
  })()
  const isBrowser = (() => {
    try {
      return typeof window !== 'undefined'
    } catch {
      return false
    }
  })()
  const isDev = (() => {
    try {
      if (typeof globalThis.useRuntimeConfig === 'function') {
        const config = globalThis.useRuntimeConfig()
        return config.public.nodeEnv === 'development'
      }
      return Boolean(
        import.meta?.env?.DEV ||
          import.meta?.env?.MODE === 'development' ||
          (typeof process !== 'undefined' && process.env.NODE_ENV === 'development'),
      )
    } catch {
      return false
    }
  })()
  return {
    isNode,
    isBrowser,
    isDev,
  }
}
```

## File: libs/logger/src/error-interface.ts
```typescript
export interface ErrorMessage {
  userMessage: string
  devMessage: string
  error: any
}
export interface ErrorServer extends Omit<ErrorMessage, 'error'> {
  featureRelated?: boolean
  response: { data: any; error: any }
}
export const retryableStatusCodes: { [key: number]: string } = {
  408: 'Request Timeout - The server timed out waiting for the request.',
  409: 'Conflict - The request could not be completed due to a conflict with the current state of the target resource.',
  425: 'Too Early - The server is unwilling to risk processing a request that might be replayed.',
  500: 'Internal Server Error - The server encountered an unexpected condition that prevented it from fulfilling the request.',
  502: 'Bad Gateway - The server, while acting as a gateway or proxy, received an invalid response from an inbound server.',
  503: 'Service Unavailable - The server is currently unable to handle the request due to temporary overloading or maintenance of the server.',
  504: 'Gateway Timeout - The server, while acting as a gateway or proxy, did not receive a timely response from an upstream server.',
}
export enum ErrorSeverity {
  LOW = 'low',
  MEDIUM = 'medium',
  HIGH = 'high',
  CRITICAL = 'critical',
}
export enum ErrorType {
  UPLOAD_ERROR = 'UPLOAD_ERROR',
  CONNECTION_ERROR = 'CONNECTION_ERROR',
  AUTHENTICATION_ERROR = 'AUTHENTICATION_ERROR',
  UNIQUE_VIOLATION = 'UNIQUE_VIOLATION',
  FOREIGN_KEY_VIOLATION = 'FOREIGN_KEY_VIOLATION',
  NOT_NULL_VIOLATION = 'NOT_NULL_VIOLATION',
  CONSTRAINT_ERROR = 'CONSTRAINT_ERROR',
  UNDEFINED_TABLE = 'UNDEFINED_TABLE',
  UNDEFINED_PARAMETER = 'UNDEFINED_PARAMETER',
  SYNTAX_ERROR = 'SYNTAX_ERROR',
  DUPLICATE_ALIAS = 'DUPLICATE_ALIAS',
  UNDEFINED_COLUMN = 'UNDEFINED_COLUMN',
  DATA_EXCEPTION = 'DATA_EXCEPTION',
  SERIALIZATION_FAILURE = 'SERIALIZATION_FAILURE',
  DEADLOCK_DETECTED = 'DEADLOCK_DETECTED',
  INSUFFICIENT_RESOURCES = 'INSUFFICIENT_RESOURCES',
  RATE_LIMIT_ERROR = 'RATE_LIMIT_ERROR',
  SERVER_ERROR = 'SERVER_ERROR',
  UNKNOWN_ERROR = 'UNKNOWN_ERROR',
  VALIDATION_ERROR = 'VALIDATION_ERROR',
  NOT_FOUND_ERROR = 'NOT_FOUND_ERROR',
  NETWORK_ERROR = 'NETWORK_ERROR',
}
export interface ErrorDetails {
  type: ErrorType
  message: string
  severity: ErrorSeverity
  stack?: string
  code?: string | number
  context?: string
  pgError?: string
  operation?: string
  originalError?: any
}
export interface ErrorHandlerOptions {
  context?: string
  userMessage?: string
  devMessage?: string
  throwError?: boolean
}
export interface FetchErrorResponse {
  data?: any
  error?: any
}
export function mapErrorSeverity(error: any): ErrorSeverity {
  if (error.status >= 500) return ErrorSeverity.CRITICAL
  if (error.status === 429) return ErrorSeverity.HIGH
  if (error.code?.startsWith('08')) return ErrorSeverity.CRITICAL
  if (error.code?.startsWith('28')) return ErrorSeverity.HIGH
  if (error.code?.startsWith('23')) return ErrorSeverity.HIGH
  if (error.code?.startsWith('42')) return ErrorSeverity.MEDIUM
  if (error.code?.startsWith('22')) return ErrorSeverity.MEDIUM
  if (error.code === '40001' || error.code === '40P01') return ErrorSeverity.HIGH
  if (error.code?.startsWith('53')) return ErrorSeverity.CRITICAL
  return ErrorSeverity.MEDIUM
}
export function mapErrorType(error: any): ErrorType {
  if (
    error.code === '08000' ||
    error.code === '08003' ||
    error.code === '08006' ||
    error.code === '08001' ||
    error.code === '08004'
  ) {
    return ErrorType.CONNECTION_ERROR
  }
  if (error.code === '28000' || error.code === '28P01') {
    return ErrorType.AUTHENTICATION_ERROR
  }
  if (error.code === '23505') return ErrorType.UNIQUE_VIOLATION
  if (error.code === '23503') return ErrorType.FOREIGN_KEY_VIOLATION
  if (error.code === '23502') return ErrorType.NOT_NULL_VIOLATION
  if (error.code?.startsWith('23') && !['23505', '23503', '23502'].includes(error.code))
    return ErrorType.CONSTRAINT_ERROR
  if (error.code === '42P01') return ErrorType.UNDEFINED_TABLE
  if (error.code === '42P02') return ErrorType.UNDEFINED_PARAMETER
  if (error.code === '42601') return ErrorType.SYNTAX_ERROR
  if (error.code === '42P07') return ErrorType.DUPLICATE_ALIAS
  if (error.code === '42703') return ErrorType.UNDEFINED_COLUMN
  if (error.code?.startsWith('22')) return ErrorType.DATA_EXCEPTION
  if (error.code === '40001') return ErrorType.SERIALIZATION_FAILURE
  if (error.code === '40P01') return ErrorType.DEADLOCK_DETECTED
  if (
    error.code === '53000' ||
    error.code === '53100' ||
    error.code === '53200' ||
    error.code === '53300'
  ) {
    return ErrorType.INSUFFICIENT_RESOURCES
  }
  if (error.status === 429) return ErrorType.RATE_LIMIT_ERROR
  if (error.status >= 500) return ErrorType.SERVER_ERROR
  return ErrorType.UNKNOWN_ERROR
}
export interface LogLevels {
  error: 0
  warn: 1
  info: 2
  http: 3
  verbose: 4
  debug: 5
  silly: 6
}
export class AppError extends Error {
  details: ErrorDetails
  constructor(details: ErrorDetails) {
    super(details.message)
    this.details = details
    this.name = 'AppError'
  }
}
export interface Logger {
  error: (message: string, ...args: any[]) => void
  warn: (message: string, ...args: any[]) => void
  info: (message: string, ...args: any[]) => void
  verbose: (message: string, ...args: any[]) => void
  debug: (message: string, ...args: any[]) => void
  silly: (message: string, ...args: any[]) => void
  http: (message: string, ...args: any[]) => void
}
```

## File: libs/logger/src/handler.ts
```typescript
import { createLogger } from './logger'
import { getEnvironment } from './environment'
import {
  ErrorType,
  ErrorSeverity,
  AppError,
  mapErrorType,
  mapErrorSeverity,
  retryableStatusCodes,
  type ErrorHandlerOptions,
  type FetchErrorResponse,
} from './error-interface'
export class ErrorHandler {
  private logger
  private env = getEnvironment()
  constructor(private context = 'ErrorHandler') {
    this.logger = createLogger(context)
  }
  private determineErrorType(error: any): ErrorType {
    if (error instanceof AppError) return error.details.type
    return mapErrorType(error)
  }
  private determineSeverity(error: any): ErrorSeverity {
    if (error instanceof AppError) return error.details.severity
    return mapErrorSeverity(error)
  }
  private formatErrorMessage(options: {
    userMessage?: string
    devMessage: string
    error: any
  }): string {
    const { userMessage, devMessage, error } = options
    const devError = `${devMessage}: ${JSON.stringify(error)}`
    this.logger.error(devError)
    return this.env.isDev ? devError : userMessage || 'An unexpected error occurred'
  }
  private normalizeError(error: Error | AppError, context?: string): AppError {
    if (error instanceof AppError) {
      return error
    }
    const errorType = this.determineErrorType(error)
    const severity = this.determineSeverity(error)
    return new AppError({
      type: errorType,
      message: error.message,
      severity,
      stack: error.stack,
      context,
      code: (error as any).code,
      pgError: (error as any).details || (error as any).hint,
      operation: context,
      originalError: error,
    })
  }
  private getErrorStatusCode(errorType: ErrorType): number {
    switch (errorType) {
      case ErrorType.AUTHENTICATION_ERROR:
        return 401
      case ErrorType.VALIDATION_ERROR:
        return 400
      case ErrorType.NOT_FOUND_ERROR:
        return 404
      case ErrorType.RATE_LIMIT_ERROR:
        return 429
      case ErrorType.CONSTRAINT_ERROR:
      case ErrorType.UNIQUE_VIOLATION:
      case ErrorType.FOREIGN_KEY_VIOLATION:
        return 409
      default:
        return 500
    }
  }
  handleError(error: Error | AppError, options: ErrorHandlerOptions = {}) {
    const appError = this.normalizeError(error, options.context)
    this.logger.error(`${appError.details.type}: ${appError.message}`, {
      ...appError.details,
      stack: this.env.isDev ? appError.stack : undefined,
    })
    if (this.env.isNode) {
      const errorMessage = this.formatErrorMessage({
        userMessage: options.userMessage || appError.message,
        devMessage: options.devMessage || appError.details.type,
        error: appError,
      })
      if (options.throwError) {
        const serverError = new Error()
        serverError.message = `SERVER ERROR: ${errorMessage}`
        ;(serverError as any).statusCode = this.getErrorStatusCode(appError.details.type)
        ;(serverError as any).statusMessage = appError.message
        ;(serverError as any).data = {
          error: {
            type: appError.details.type,
            message: appError.message,
            severity: appError.details.severity,
            details: this.env.isDev ? appError.details : undefined,
          },
        }
        throw serverError
      }
    }
    if (appError.details.severity === ErrorSeverity.CRITICAL) {
      this.handleCriticalError(appError)
    }
    return appError
  }
  handleFetchError({
    response,
    devMessage,
    userMessage,
  }: {
    response: FetchErrorResponse
    devMessage: string
    userMessage?: string
  }) {
    if (response.error) {
      this.logger.error(`FETCH Error: ${response.error}`)
      return this.handleError(response.error, { userMessage, devMessage })
    }
    if (response.data) {
      this.logger.info(
        `Successfully fetched ${Array.isArray(response.data) ? response.data.length : 1} items`,
      )
      return response.data
    }
    this.logger.info('Nothing returned from fetch')
    return this.handleError(new Error('No data found'), {
      userMessage: 'Resource not found',
      devMessage: 'Fetch returned empty response',
    })
  }
  handleDBError(response: FetchErrorResponse, context: string) {
    if (response.error) {
      return this.handleError(response.error, {
        context,
        devMessage: `Database error in ${context}`,
        userMessage: 'Database operation failed',
      })
    }
    return response.data
  }
  private handleCriticalError(error: AppError) {
    this.logger.error('CRITICAL ERROR:', error.details)
  }
}
export function createErrorHandler(context = 'ErrorHandler') {
  const handler = new ErrorHandler(context)
  return {
    handleError: handler.handleError.bind(handler),
    handleFetchError: handler.handleFetchError.bind(handler),
    handleDBError: handler.handleDBError.bind(handler),
  }
}
export const useErrorHandler = (context = 'ErrorHandler') => {
  return createErrorHandler(context)
}
```

## File: libs/logger/src/logger.ts
```typescript
import { createConsola } from 'consola'
import type { ConsolaInstance } from 'consola'
import type { Logger, LogLevels } from './error-interface'
import { getEnvironment } from './environment'
export class BaseLogger implements Logger {
  protected logger: ConsolaInstance | Logger
  protected env = getEnvironment()
  constructor(tag = '') {
    this.logger = createConsola({
      level: this.env.isDev ? 10 : 3,
      formatOptions: {
        date: this.env.isNode,
        colors: true,
      },
    }).withTag(tag.toUpperCase())
  }
  error(message: string, ...args: any[]) {
    this.logger.error(message, ...args)
  }
  warn(message: string, ...args: any[]) {
    this.logger.warn(message, ...args)
  }
  info(message: string, ...args: any[]) {
    this.logger.info(message, ...args)
  }
  verbose(message: string, ...args: any[]) {
    if (this.env.isDev) {
      this.logger.verbose(message, ...args)
    }
  }
  debug(message: string, ...args: any[]) {
    if (this.env.isDev) {
      this.logger.debug(message, ...args)
    }
  }
  silly(message: string, ...args: any[]) {
    if (this.env.isDev) {
      this.logger.info(message, ...args)
    }
  }
  http(message: string, ...args: any[]) {
    this.logger.info(message, ...args)
  }
}
let winstonPackage: typeof import('winston') | undefined = undefined
export class NodeLogger extends BaseLogger {
  private winstonLogger: any
  constructor(tag = '') {
    super(tag)
    if (this.env.isNode) {
      this.initWinston(tag).catch((err) => {
        this.logger.error('Failed to initialize Winston:', err)
      })
    }
  }
  private async initWinston(tag: string) {
    try {
      if (!winstonPackage) {
        winstonPackage = await import('winston')
      }
      const format = winstonPackage.format.combine(
        winstonPackage.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss:ms' }),
        winstonPackage.format.cli(),
        winstonPackage.format.printf(
          (info) => `${info['timestamp']} ${info.level}: [${tag}] ${info.message}`,
        ),
      )
      this.winstonLogger = winstonPackage.createLogger({
        levels: {
          error: 0,
          warn: 1,
          info: 2,
          http: 3,
          verbose: 4,
          debug: 5,
          silly: 6,
        },
        level: this.env.isDev ? 'silly' : 'info',
        format,
        transports: [
          new winstonPackage.transports.Console(),
          ...(this.env.isDev
            ? []
            : [
                new winstonPackage.transports.File({
                  filename: './data/logs/error.log',
                  level: 'error',
                }),
                new winstonPackage.transports.File({
                  filename: './data/logs/combined.log',
                }),
              ]),
        ],
      })
    } catch (err) {
      this.logger.warn('Winston not available, falling back to console logger')
    }
  }
  override error(message: string, ...args: any[]) {
    if (this.winstonLogger) {
      this.winstonLogger.error(message, ...args)
    } else {
      super.error(message, ...args)
    }
  }
  override warn(message: string, ...args: any[]) {
    if (this.winstonLogger) {
      this.winstonLogger.warn(message, ...args)
    } else {
      super.warn(message, ...args)
    }
  }
  override info(message: string, ...args: any[]) {
    if (this.winstonLogger) {
      this.winstonLogger.info(message, ...args)
    } else {
      super.info(message, ...args)
    }
  }
  override verbose(message: string, ...args: any[]) {
    if (this.winstonLogger && this.env.isDev) {
      this.winstonLogger.verbose(message, ...args)
    } else {
      super.verbose(message, ...args)
    }
  }
  override debug(message: string, ...args: any[]) {
    if (this.winstonLogger && this.env.isDev) {
      this.winstonLogger.debug(message, ...args)
    } else {
      super.debug(message, ...args)
    }
  }
  override silly(message: string, ...args: any[]) {
    if (this.winstonLogger && this.env.isDev) {
      this.winstonLogger.silly(message, ...args)
    } else {
      super.silly(message, ...args)
    }
  }
  override http(message: string, ...args: any[]) {
    if (this.winstonLogger) {
      this.winstonLogger.http(message, ...args)
    } else {
      super.http(message, ...args)
    }
  }
}
export const createLogger = (tag = '') => {
  const env = getEnvironment()
  return env.isNode ? new NodeLogger(tag) : new BaseLogger(tag)
}
// Async version for when we want to ensure Winston is loaded
export const createLoggerAsync = async (tag = '') => {
  const logger = createLogger(tag)
  if (logger instanceof NodeLogger) {
    // Wait for Winston to initialize if needed
    await new Promise((resolve) => setTimeout(resolve, 100))
  }
  return logger
}
// Framework-specific wrappers if needed
export const useLogger = (tag = '') => {
  return createLogger(tag)
}
export const useLoggerAsync = async (tag = '') => {
  return await createLoggerAsync(tag)
}
```

## File: libs/logger/index.d.ts
```typescript
import type { Consola } from 'consola'
export * from './src/environment.d'
export function useLogger(tag?: string): Consola
```

## File: libs/logger/index.ts
```typescript
export * from './src/logger'
export * from './src/handler'
export * from './src/error-interface'
```
