This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-11-30T06:41:51.994Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
apps/
  admin-dashboard/
    middleware/
      auth.global.ts
      is-admin.ts
    pages/
      business-systems/
        index.vue
    plugins/
      dev-helper.ts
    server/
      api/
        classifier/
          [action].ts
        create/
          many-public-users.post.ts
          roles.post.ts
        error/
          [type].ts
        feature/
          [action].ts
        social/
          instagram/
            analytics.ts
          linkedin/
            analytics.ts
          twitter/
            analytics.ts
          youtube/
            analytics.ts
            channel-videos.ts
        update/
          user-profile.post.ts
        users/
          bulk-upload.ts
          update.ts
        _ws.ts
        cron-jobs.post.ts
        execute-script.ts
        goals.ts
        healthy.ts
        milestones.ts
        server-jobs.ts
        store-image.ts
      utils/
        socials/
          useInstagramAnalytics.ts
          useLinkedinAnalytics.ts
          useTwitterAnalytics.ts
    nuxt.config.ts
  auth-service/
    components/
      form/
        FormPassword.vue
      AuthCard.vue
      AuthRegisterWith.vue
      AuthSocialButton.vue
      AuthVerifiedWith.vue
      TurnstileChallenge.vue
    composables/
      useAuth.ts
      useAuthUser.ts
      useResetPassword.ts
    layouts/
      default.vue
    middleware/
      auth.global.ts
      reset-password.ts
    pages/
      settings/
        password.vue
      forgot-password.vue
      index.vue
      login.vue
      register.vue
      reset-password.vue
      success.vue
    server/
      routes/
        session.ts
        signin.post.ts
        validate-turnstile.post.ts
      utils/
        getUserSession.ts
        secretManager.ts
    .npmrc
    app.vue
    Dockerfile
    example-env
    nuxt.config.ts
    tailwind.config.ts
  main-app/
    components/
      bookmark/
        BookmarkCard.vue
      nav/
        NavAppTop.vue
      news/
        NewsCard.vue
      settings/
        2FA.vue
        SecuritySection.vue
      supa/
        Upload.vue
    composables/
      users/
        user.admin.composable.ts
      useBookmarkStore.ts
      usePlan.ts
      useSettingsSecurity.ts
      useVotesStore.ts
    middleware/
      auth.global.ts
    pages/
      feed/
        [feed].vue
      news/
        index.vue
      profile/
        bookmarks.vue
      auth-callback.vue
    server/
      api/
        ai/
          ask.ts
        bookmarks/
          [id].delete.ts
          counts.ts
          index.ts
          move.patch.ts
          toggle.ts
        feature/
          [action].ts
        folders/
          [id].delete.ts
          [id].patch.ts
          index.ts
        payment/
          [provider]/
            create-order.ts
            subscription.get.ts
            verify-payment.post.ts
        users/
          metrics/
            [action].ts
          metrics.ts
          update.post.ts
        votes/
          [contentType]/
            [id].get.ts
            [id].post.ts
          user/
            [voteType].get.ts
          user.get.ts
        webhook/
          database.ts
        upload.ts
      middleware/
        feature-limit.ts
      utils/
        errors.ts
    nuxt.config.ts
  monitoring-dashboard/
    middleware/
      is-super-admin.ts
    pages/
      not-authorized.vue
    server/
      api/
        logs.get.ts
    nuxt.config.ts
  website/
    components/
      blog/
        article/
          BlogArticle.vue
          BlogArticleAuthor.vue
          BlogArticleAuthorCard.vue
          BlogArticleHero.vue
        card/
          BlogCard.vue
          BlogCardSkeleton.vue
        BlogShowcase.vue
      conference/
        ConferenceSpeakers.vue
      home/
        HomeCtaMain.vue
        HomeFeatureTabs.vue
        HomeHero.vue
      landing/
        LandingCTA.vue
      LoginButton.vue
      NavTop.vue
    pages/
      blog/
        category/
          [category]/
            page/
              [page].vue
        [title].vue
    nuxt.config.ts

================================================================
Repository Files
================================================================

================
File: apps/admin-dashboard/middleware/auth.global.ts
================
import { defineNuxtRouteMiddleware, navigateTo, useCookie } from '#app'
import { useRuntimeConfig } from '#imports'

export default defineNuxtRouteMiddleware(async (to, from) => {
  const config = useRuntimeConfig()
  const { loginURL, authURL } = config.public

  try {
    const user = useSupabaseUser()

    if (!user.value) {
      console.log('USER_NOT_LOGGED_IN', authURL, loginURL)

      return navigateTo(String(`${authURL}${loginURL}`), { external: true })
    } else {
      console.log('USER_LOGGED_IN', user.value)
    }
  } catch (error: any) {
    console.error('redirect error', `${authURL}${loginURL}`)
    return navigateTo(String(`${authURL}${loginURL}`), { external: true })
  }
})

================
File: apps/admin-dashboard/middleware/is-admin.ts
================
// const isAdmin = (role: string) => role === 'admin' || role === 'super_admin'

export default defineNuxtRouteMiddleware((to, from) => {
  // const user = useSupabaseUser()
  // const authUrl = useRuntimeConfig().public.authURL
  // if (!isAdmin(user.value?.app_metadata.role)) {
  //   return navigateTo(authUrl, { external: true })
  // }
})

================
File: apps/admin-dashboard/pages/business-systems/index.vue
================
<script setup lang="ts">
definePageMeta({
  layoutTransition: false,
  name: 'Business Systems',
})

const systemsTabs = [
  {
    title: 'Auth',
    slotName: 'auth',
    value: '0',
    system: 'authentication-flow',
  },
  {
    title: 'News',
    slotName: 'news',
    value: '1',
    system: 'news-feed',
  },
]
</script>

<template>
  <div>
    <IBTabView
      ref="analyticsTabView"
      :tabs="systemsTabs"
    >
      <template
        v-for="tab in systemsTabs"
        :key="tab.slotName"
        #[tab.slotName]
      >
        <BusinessSystems :system-name="tab.system" />
      </template>
    </IBTabView>
  </div>
</template>

<style scoped></style>

================
File: apps/admin-dashboard/plugins/dev-helper.ts
================
import { useLogger } from '@ib/logger'

const logger = useLogger('devHelper')

export default defineNuxtPlugin((nuxtApp) => {
  const config = useRuntimeConfig()

  const DevHelper = {
    features: { ...config.public.devHelper.features },

    toggleFeature(feature: string, enabled: boolean) {
      if (feature in this.features) {
        this.features[feature] = enabled
        logger.info(`Feature '${feature}' ${enabled ? 'enabled' : 'disabled'}`)

        // Reinitialize the feature if it's being enabled
        if (enabled) {
          const initMethod =
            `init${feature.charAt(0).toUpperCase() + feature.slice(1)}` as keyof typeof DevHelper
          if (typeof this[initMethod] === 'function') {
            ;(this[initMethod] as () => void)()
          }
        }
      }
    },
    initNetworkErrorClassifier() {
      if (!this.features.networkErrorClassifier) return

      const errorCategories = {
        timeout: ['ECONNABORTED'],
        serverError: ['500', '501', '502', '503', '504', '505'],
        clientError: [
          '400',
          '401',
          '403',
          '404',
          '405',
          '406',
          '407',
          '408',
          '409',
          '410',
          '411',
          '412',
          '413',
          '414',
          '415',
        ],
        networkError: [
          'ECONNRESET',
          'ENOTFOUND',
          'ESOCKETTIMEDOUT',
          'ETIMEDOUT',
          'ECONNREFUSED',
          'EHOSTUNREACH',
          'EPIPE',
          'EAI_AGAIN',
        ],
      }

      nuxtApp.hook('app:error', (error) => {
        let category = 'unknown'
        const errorCode = error.statusCode?.toString() || error.name

        for (const [key, codes] of Object.entries(errorCategories)) {
          if (codes.includes(errorCode)) {
            category = key
            break
          }
        }

        logger.error(`ðŸŒ Network Error (${category}):`, {
          message: error.message,
          code: errorCode,
          stack: error.stack,
        })
      })

      logger.info('ðŸŒ Network Error Classifier initialized')
    },

    initInfiniteLoopDetector() {
      if (!this.features.infiniteLoopDetector) return
      if (!import.meta.client) return

      const MAX_ITERATIONS = 1000000
      const TIME_THRESHOLD = 100 // ms

      const originalSetTimeout = window.setTimeout
      window.setTimeout = function (
        this: typeof window,
        handler: TimerHandler,
        timeout?: number,
        ...args: any[]
      ): number {
        const start = Date.now()
        let iterationCount = 0

        const wrappedCallback = function (this: typeof window) {
          iterationCount++
          if (
            iterationCount > MAX_ITERATIONS ||
            (Date.now() - start > TIME_THRESHOLD && iterationCount > 1000)
          ) {
            logger.warn('ðŸ”„ Potential infinite loop detected:', {
              iterations: iterationCount,
              time: Date.now() - start,
              stack: new Error().stack,
            })
          }
          if (typeof handler === 'function') {
            return handler.apply(this, args)
          } else {
            return Function(handler as string).apply(this, args)
          }
        }

        return Number(originalSetTimeout.call(this, wrappedCallback, timeout))
      }

      logger.info('ðŸ”„ Infinite Loop Detector initialized')
    },

    initUnhandledPromiseRejectionTracker() {
      if (!this.features.unhandledPromiseRejectionTracker) return
      if (!import.meta.client) return

      window.addEventListener('unhandledrejection', (event) => {
        logger.error('ðŸ’¥ Unhandled Promise Rejection:', {
          reason: event.reason,
          stack: event.reason.stack || new Error().stack,
          event: event,
        })
      })

      logger.info('ðŸ’¥ Unhandled Promise Rejection Tracker initialized')
    },

    checkEnvironmentConsistency() {
      if (!this.features.environmentConsistencyChecker) return

      const requiredVars = ['API_URL', 'AUTH_SECRET', 'DB_CONNECTION']
      const missingVars = requiredVars.filter((varName) => !config.public[varName])

      if (missingVars.length > 0) {
        logger.warn('ðŸ”‘ Missing required environment variables:', missingVars)
      } else {
        logger.info('ðŸ”‘ All required environment variables are set')
      }
    },
  }

  if (import.meta.dev && config.public.devHelper.enabled) {
    logger.info('ðŸ› ï¸ DevHelper: Initializing...')
    try {
      DevHelper.initNetworkErrorClassifier()
      DevHelper.initInfiniteLoopDetector()
      DevHelper.initUnhandledPromiseRejectionTracker()
      DevHelper.checkEnvironmentConsistency()
      logger.info('Initialization complete')
    } catch (error) {
      logger.error('Initialization failed:', error)
    }
  } else {
    logger.info('Initialization skipped (not in dev mode or devHelper not enabled)')
  }

  return {
    provide: {
      devHelper: DevHelper,
    },
  }
})

================
File: apps/admin-dashboard/server/api/classifier/[action].ts
================
import { defineEventHandler, getRouterParam, createError } from 'h3'
import jwt from 'jsonwebtoken'

export default defineEventHandler(async (event) => {
  const config = useRuntimeConfig()
  const action = getRouterParam(event, 'action')
  console.log('Classifier action:', action)

  let url: string
  let label: string
  let id: string

  if (action !== 'select') {
    const body = await readBody(event)
    url = body.url
    label = body.label
    id = body.id
  }

  if (!action) {
    throw createError({
      statusCode: 400,
      statusMessage: 'Action is required',
    })
  }

  try {
    const token = jwt.sign({ sender: 'AstronEra' }, config.scraperKey, {
      algorithm: 'HS256',
    })

    if (action === 'insert') {
      const response = await $fetch(`${config.public.scraperUrl}/api/classifier/urls`, {
        method: 'POST',
        headers: {
          Authorization: `Bearer ${token}`,
        },
        body: JSON.stringify({ url, label }),
      })

      return {
        data: response,
      }
    } else if (action === 'delete') {
      const response = await $fetch(`${config.public.scraperUrl}/api/classifier/urls/${id}`, {
        method: 'DELETE',
        headers: {
          Authorization: `Bearer ${token}`,
        },
      })

      return {
        data: response,
      }
    } else if (action === 'select') {
      const response = await $fetch(`${config.public.scraperUrl}/api/classifier/urls`, {
        method: 'GET',
        headers: {
          Authorization: `Bearer ${token}`,
        },
      })

      return {
        data: response,
      }
    }

    throw createError({
      statusCode: 400,
      statusMessage: 'Invalid action',
    })
  } catch (error: any) {
    console.error(`Error in classifier ${action}:`, error)

    throw createError({
      statusCode: 500,
      statusMessage: 'Internal Server Error',
    })
  }
})

================
File: apps/admin-dashboard/server/api/create/many-public-users.post.ts
================
export default defineEventHandler(async (event) => {
  const users = await readBody(event)
  const client = dbClient(event)
  let message
  let status

  // Function to insert users from JSON file
  if (users.length > 0) {
    const mappedUsers = users.map((user) => {
      if (user.dob !== null) {
        user.dob = new Date(user.dob).toISOString()
      }
      user.created_at = new Date().toISOString()
      user.updated_at = new Date().toISOString()
      user.last_seen = new Date().toISOString()
      return {
        ...user,
      }
    })

    const { data, error } = await client
      .from('user_profiles')
      .createMany({ data: [...mappedUsers] })
      .select('*')

    status = 200
    message = 'Users have been inserted successfully'
  } else {
    console.error('no users to add')
    status = 200
    message = 'no users to add'
  }

  return {
    status,
    message,
  }
})

================
File: apps/admin-dashboard/server/api/create/roles.post.ts
================
import type { Role } from '@/types/roles'

export default defineEventHandler(async (event) => {
  const client = dbClient(event)

  const { roles }: { roles: Role[] } = await readBody(event)
  // const env = useRuntimeConfig().public

  // Function to insert users from JSON file
  // !TODO: use transforms from types foler to handle date/string conversion
  if (roles.length > 0) {
    const mappedRoles = roles.map((role) => {
      role.created_at = new Date(role.created_at).toISOString()
      return {
        ...role,
      }
    })

    await client.roles.createMany({ data: [...mappedRoles] })
  }

  return {
    status: 200,
    message: 'Users have been inserted successfully',
  }
})

================
File: apps/admin-dashboard/server/api/error/[type].ts
================
import { defineEventHandler, getRouterParam, createError } from 'h3'
import jwt from 'jsonwebtoken'

export default defineEventHandler(async (event) => {
  const config = useRuntimeConfig()
  const type = getRouterParam(event, 'type')

  if (!type) {
    throw createError({
      statusCode: 400,
      statusMessage: 'Error type is required',
    })
  }

  console.log(`Sending error event to scraper for type: ${type}`)

  try {
    const token = jwt.sign({ sender: 'AstronEra' }, config.scraperKey, {
      algorithm: 'HS256',
    })

    const response = await $fetch(`${config.public.scraperUrl}/api/error/${type}`, {
      headers: {
        Authorization: `Bearer ${token}`,
      },
    })

    return {
      data: response,
    }
  } catch (error: any) {
    console.error(`Error fetching ${type} data:`, error)

    if (error.response) {
      // The request was made and the server responded with a status code
      // that falls out of the range of 2xx
      if (error.response.status === 404) {
        // Handle 404 Not Found error
        return {
          data: null,
          error: `No ${type} data found for the specified parameters`,
        }
      } else {
        // Handle other error statuses
        throw createError({
          statusCode: error.response.status,
          statusMessage: error.response.statusText || `Error fetching ${type} data`,
        })
      }
    } else if (error.request) {
      // The request was made but no response was received
      throw createError({
        statusCode: 503,
        statusMessage: 'Service Unavailable',
      })
    } else {
      // Something happened in setting up the request that triggered an Error
      throw createError({
        statusCode: 500,
        statusMessage: 'Internal Server Error',
      })
    }
  }
})

================
File: apps/admin-dashboard/server/api/feature/[action].ts
================
// server/api/admin/features/[action].ts
import { serverSupabaseClient, serverSupabaseUser } from '#supabase/server'

export default defineEventHandler(async (event) => {
  const client = await serverSupabaseClient(event)
  const user = await serverSupabaseUser(event)
  const action = event.context.params?.action

  if (!user) {
    throw createError({
      statusCode: 401,
      message: 'Unauthorized',
    })
  }

  // Check if user is admin
  const { data: profile } = await client
    .from('user_profiles')
    .select('role')
    .eq('id', user.id)
    .single()

  if (profile?.role !== 'admin') {
    throw createError({
      statusCode: 403,
      message: 'Forbidden',
    })
  }

  try {
    switch (action) {
      case 'list': {
        const { data: features, error: listError } = await client
          .from('feature_requests')
          .select('*')
          .order('priority')

        if (listError) throw listError
        return features
      }

      case 'create': {
        const createBody = await readBody(event)
        const { data: newFeature, error: createError } = await client
          .from('feature_requests')
          .insert([createBody])
          .select()
          .single()

        if (createError) throw createError
        return newFeature
      }

      case 'update': {
        const updateBody = await readBody(event)
        const { id, ...updateData } = updateBody
        const { data: updatedFeature, error: updateError } = await client
          .from('feature_requests')
          .update(updateData)
          .eq('id', id)
          .select()
          .single()

        if (updateError) throw updateError
        return updatedFeature
      }

      case 'delete': {
        const deleteBody = await readBody(event)
        const { error: deleteError } = await client
          .from('feature_requests')
          .delete()
          .eq('id', deleteBody.id)

        if (deleteError) throw deleteError
        return { success: true }
      }

      default:
        throw createError({
          statusCode: 400,
          message: 'Invalid action',
        })
    }
  } catch (error) {
    console.error(`Admin features API error (${action}):`, error)
    throw createError({
      statusCode: 500,
      message: 'Failed to process request',
    })
  }
})

================
File: apps/admin-dashboard/server/api/social/instagram/analytics.ts
================
import { defineEventHandler, getQuery } from 'h3'
import { useLoggerAsync, useErrorHandler } from '@ib/logger'
import { useInstagramAnalytics } from '#imports'

const PREFIX = 'social/instagram/insights'

export default defineEventHandler(async (event) => {
  const log = await useLoggerAsync(PREFIX)
  const errors = await useErrorHandler(PREFIX)

  const { userId } = getQuery(event) as { userId: string }

  log.info(`userId: ${userId}`)

  try {
    const instagram = useInstagramAnalytics()
    const businessAnalytics = await instagram.fetchBusinessAnalytics(userId)

    log.info(businessAnalytics)

    return {
      status: 200,
      message: 'Profile businessAnalytics returned from Instagram',
      data: businessAnalytics,
    }
  } catch (error: any) {
    errors.handleError({
      error,
      devMessage: 'Error fetching Instagram insights',
      userMessage: 'Error fetching Instagram insights',
    })
  }
})

================
File: apps/admin-dashboard/server/api/social/linkedin/analytics.ts
================
import { useErrorHandler, useLoggerAsync } from '@ib/logger'
import { useLinkedinAnalytics } from '#imports'

const PREFIX = 'social/linkedin/analytics'

export default defineEventHandler(async (event) => {
  const log = await useLoggerAsync(PREFIX)
  const errors = useErrorHandler(PREFIX)

  const { postId } = getQuery(event) as { postId: string }

  log.info(`postId: ${postId}`)

  try {
    const linkedin = useLinkedinAnalytics(postId)
    const postAnalytics = await linkedin.fetchPostAnalytics()
    log.info(postAnalytics)

    return {
      status: 200,
      message: 'Post analytics returned from LinkedIn',
      data: postAnalytics,
    }
  } catch (error: any) {
    errors.handleError({
      error,
      devMessage: 'Error fetching LinkedIn analytics',
      userMessage: 'Error fetching LinkedIn analytics',
    })
  }
})

================
File: apps/admin-dashboard/server/api/social/twitter/analytics.ts
================
import { defineEventHandler, getQuery } from 'h3'
import { useErrorHandler, useLoggerAsync } from '@ib/logger'
import { useTwitterAnalytics } from '#imports'

const PREFIX = 'social/twitter/analytics'

export default defineEventHandler(async (event) => {
  const log = await useLoggerAsync(PREFIX)
  const errors = useErrorHandler(PREFIX)

  const { postId } = getQuery(event) as { postId: string }

  log.info(`postId: ${postId}`)

  try {
    const twitter = useTwitterAnalytics(postId)
    const userAnalytics = await twitter.fetchUserProfile()
    log.info(userAnalytics)

    return {
      status: 200,
      message: 'Post analytics returned from Twitter',
      data: userAnalytics,
    }
  } catch (error: any) {
    errors.handleError({
      error,
      devMessage: 'Error fetching Twitter analytics',
      userMessage: 'Error fetching Twitter analytics',
    })
  }
})

================
File: apps/admin-dashboard/server/api/social/youtube/analytics.ts
================
import { useErrorHandler, useLoggerAsync } from '@ib/logger'
import { useYoutubeChannel } from '#imports'

const PREFIX = 'social/youtube/analytics'

export default defineEventHandler(async (event) => {
  const log = await useLoggerAsync(PREFIX)
  const errors = useErrorHandler(PREFIX)

  const { channelName } = getQuery(event) as { channelName: string }

  log.info(`channelName: ${channelName}`)

  try {
    const youtube = useYoutubeChannel(channelName)
    const channelStatistics = await youtube.fetchChannelStatistics()
    log.info(channelStatistics)
    const videoItems = await youtube.fetchChannelVideos()
    log.info(videoItems)
    const videoStatsPromises = videoItems.map(async (video: any) => {
      const stats = await youtube.fetchVideoStatistics(video.id.videoId)
      log.info(stats)
      return { ...video, statistics: stats }
    })
    const videos = await Promise.all(videoStatsPromises)

    log.info('returning videos')
    return {
      status: 200,
      message: 'Videos returned from youtube',
      data: {
        channelStatistics,
        videos,
      },
    }
  } catch (error: any) {
    errors.handleError({
      error,
      devMessage: 'error fetching youtube analytics',
      userMessage: 'error fetching youtube analytics',
    })
  }
})

================
File: apps/admin-dashboard/server/api/social/youtube/channel-videos.ts
================
export default defineEventHandler(async (event) => {
  const { channelName } = getQuery(event)

  console.log('channelName', channelName)

  try {
    const videos = await getYoutubeContent(String(channelName))

    console.log('returnedData', videos)
    return {
      status: 200,
      message: 'Videos returned from youtube',
      data: videos,
    }
  } catch (error: any) {
    console.error('social/youtube error', error.message)
    return {
      status: 500,
      message: 'Error retrieving videos',
      data: null,
      error,
    }
  }
})

================
File: apps/admin-dashboard/server/api/update/user-profile.post.ts
================
export default defineEventHandler(async (event) => {
  const { userId, profile }: { userId: string; profile: any } = await readBody(event)
  const client = await dbClient(event)

  // Function to insert users from JSON file
  try {
    if (profile.dob) {
      console.log('profile.dob:', profile.dob)
      profile.dob = new Date(profile.dob).toISOString()
    }

    if (!profile) {
      return {
        status: 400,
        message: 'No user profile provided',
      }
    }

    console.log(`attempting to update ${profile.given_name} with id ${userId}`)
    const { data, error } = await client
      .from('user_profiles')
      .update(profile)
      .eq('email', profile.email)
      .select()

    if (error) {
      throw createError({ message: `error updating users: ${error.message}` })
    }

    console.log(`User ${data.email} updated successfully`)

    return {
      status: 200,
      message: 'Users have been inserted successfully',
      data,
    }
  } catch (error) {
    console.error(`Error updating user ${userId}:`, error)
    return {
      status: 500,
      message: 'Error updating user profile',
    }
  }
})

================
File: apps/admin-dashboard/server/api/users/bulk-upload.ts
================
import { readMultipartFormData, type MultiPartData } from 'h3'
import { serverSupabaseServiceRole } from '#supabase/server'

async function upload(path: string, file: MultiPartData) {
  const supabase = serverSupabaseServiceRole(useEvent())
  const { data, error } = await supabase.storage.from('profile-public').upload(path, file.data, {
    cacheControl: '3600',
    contentType: file.type,
    upsert: true,
  })
  console.log('uploadResponse', data, error)
}

export default defineEventHandler(async (event) => {
  console.log('upload eventHandler')
  const form = await readMultipartFormData(event)
  console.log('workingUpload', form)
  if (!form?.length) {
    return console.log('no form data')
  }

  console.log('file', form)

  // we would need to fetch all users based on the file name

  try {
    const userRepository = new UserRepository()
    const users = await userRepository.selectMany<'user_profiles'>({
      tableName: 'user_profiles',
      selectStatement: 'id, given_name, surname',
    })

    form.forEach(async (file) => {
      console.log('uploading file', file)
      const fileName = file.filename
      if (!fileName) {
        console.log('no filename found')
        return
      }
      const fullName = fileName.split('.')[0]
      const [given_name, surname] = fullName.split('-')
      console.log('searching for', given_name, surname)
      const userId = users.find((user) => {
        if (!user.given_name || !user.surname) {
          return false
        }
        return (
          user.given_name.toLowerCase() === given_name && user.surname.toLowerCase() === surname
        )
      })?.id

      if (!userId) {
        console.log('no user found for', given_name, surname)
        return
      }
      console.log('name and id', given_name, surname, userId)
      console.log('uploading file for', userId, fileName)
      const newFileName = `avatar_${userId}.jpg`
      await upload(`${userId}/avatar/${newFileName}`, file)
    })
  } catch (error) {
    console.log('upload error', error)
    throw createError({ statusMessage: error.message })
  }

  return {
    statusCode: 200,
    message: 'successfully uploaded files',
  }
})

================
File: apps/admin-dashboard/server/api/users/update.ts
================
export default defineEventHandler(async (event) => {
  console.log('update user endpoint fired')
  const { id, data } = await readBody(event)

  console.log('have body', data)


  


  try {
    return {
      error: null,
      data: [],
      status: 200,
      message: 'User fetched',
    }
  } catch (error: any) {
    console.error('update user error', error.message)
    return {
      error,
      data: null,
      status: 500,
      message: error.message,
    }
  }
})

================
File: apps/admin-dashboard/server/api/_ws.ts
================
export default defineWebSocketHandler({
  open(peer) {
    console.log('[ws] open', peer)
  },

  message(peer, message) {
    console.log('[ws] message', peer, message)
    if (message.text().includes('ping')) {
      peer.send('pong')
    }
  },

  close(peer, event) {
    console.log('[ws] close', peer, event)
  },

  error(peer, error) {
    console.log('[ws] error', peer, error)
  },
})

================
File: apps/admin-dashboard/server/api/cron-jobs.post.ts
================
import jwt from 'jsonwebtoken'

export default defineEventHandler(async (event) => {
  const body = await readBody(event)
  const { action } = body

  const scraperKey = useRuntimeConfig().scraperKey
  const token = jwt.sign({ sender: 'AstronEra' }, scraperKey, {
    algorithm: 'HS256',
  })

  const scraperBaseURL = useRuntimeConfig().public.scraperUrl

  let endpoint = ''
  switch (action) {
    case 'scrapeNewsLinks':
      endpoint = '/trigger/news_links'
      break
    case 'scrapeNewsArticles':
      endpoint = '/trigger/news_pages'
      break
    default:
      throw createError({
        statusCode: 400,
        statusMessage: 'Invalid action',
      })
  }

  try {
    const response = await $fetch(`${scraperBaseURL}${endpoint}`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json',
      },
    })

    return response
  } catch (error) {
    console.error(`Error in scraper request: ${error}`)
    throw createError({
      statusCode: 500,
      statusMessage: 'Error communicating with scraper',
    })
  }
})

================
File: apps/admin-dashboard/server/api/execute-script.ts
================
import { execFile } from 'child_process'
import { promisify } from 'util'
import path from 'path'
import fs from 'fs'

const execFileAsync = promisify(execFile)

type ScriptName = 'build-all' | 'db-setup' | 'generate-lazy-routes' | 'clean-packages'

const scriptConfigs = {
  'build-all': { type: 'sh', file: 'build-all.sh' },
  'db-setup': { type: 'ts', file: 'db-setup.ts' },
  'generate-lazy-routes': { type: 'ts', file: 'generate-lazy-routes.ts' },
  'clean-packages': { type: 'sh', file: 'clean-packages.sh' },
  // Add more scripts as needed
}

export default defineEventHandler(async (event) => {
  const { scriptName } = (await readBody(event)) as { scriptName: ScriptName }

  if (!scriptConfigs[scriptName]) {
    throw createError({
      statusCode: 400,
      statusMessage: 'Invalid script name',
    })
  }

  const { type, file } = scriptConfigs[scriptName]

  const baseDir = process.cwd()
  const scriptPath = path.join('/app', 'scripts', file)

  console.log(`Current working directory: ${process.cwd()}`)
  console.log(`Script path: ${scriptPath}`)
  console.log('Files in current directory:', fs.readdirSync(process.cwd()))
  console.log('Files in /app/scripts:', fs.readdirSync('/app/scripts'))
  console.log(`Current working directory: ${baseDir}`)
  console.log(`Attempting to execute script: ${scriptPath}`)

  // Check if the script file exists
  if (!fs.existsSync(scriptPath)) {
    console.error(`Script file not found: ${scriptPath}`)
    throw createError({
      statusCode: 500,
      statusMessage: 'Script file not found',
    })
  }

  try {
    let output
    if (type === 'sh') {
      const { stdout, stderr } = await execFileAsync('sh', [scriptPath], { cwd: baseDir })
      output = stdout + stderr
    } else if (type === 'ts') {
      const { stdout, stderr } = await execFileAsync('npx', ['tsx', scriptPath], { cwd: baseDir })
      output = stdout + stderr
    } else {
      throw new Error('Unsupported script type')
    }

    console.log(`Script execution completed: ${scriptName}`)
    return { output }
  } catch (error) {
    console.error(`Error executing script ${scriptName}:`, error)
    throw createError({
      statusCode: 500,
      statusMessage: 'Error executing script',
    })
  }
})

================
File: apps/admin-dashboard/server/api/goals.ts
================
import { promises as fs } from 'fs'
import { resolve } from 'path'
import { defineEventHandler, readBody } from 'h3'

const goalsFilePath = resolve(process.cwd(), 'data', 'tasks/goals.json')

export interface Goal {
  id: number
  title: string
  date: string
  category: 'financial' | 'metrics' | 'hiring' | 'events' | 'development' | 'milestone'
  assigneeId: number
  completed: boolean
  progress: number
  priority: 'low' | 'medium' | 'high'
  timeSpent: number
  description: string
  milestoneId?: number
  recurrence?: {
    frequency: 'daily' | 'weekly' | 'monthly' | 'yearly'
    interval: number
    endDate?: string
  }
}

export default defineEventHandler(async (event) => {
  const body = await readBody(event)
  const { action, goal } = body

  async function readGoals(): Promise<Goal[]> {
    try {
      const data = await fs.readFile(goalsFilePath, 'utf-8')
      return JSON.parse(data)
    } catch (error) {
      if (error.code === 'ENOENT') {
        return []
      }
      throw error
    }
  }

  async function writeGoals(goals: Goal[]): Promise<void> {
    await fs.writeFile(goalsFilePath, JSON.stringify(goals, null, 2), 'utf-8')
  }

  try {
    let goals = await readGoals()

    switch (action) {
      case 'read':
        return {
          success: true,
          goals: goals,
          totalCount: goals.length,
        }
      case 'create':
        goals.push(goal)
        await writeGoals(goals)
        break
      case 'update':
        const index = goals.findIndex((g) => g.id === goal.id)
        if (index !== -1) {
          goals[index] = { ...goals[index], ...goal }
          await writeGoals(goals)
        }
        break
      case 'delete':
        goals = goals.filter((g) => g.id !== goal.id)
        await writeGoals(goals)
        break
      default:
        throw new Error(`Invalid action: ${action}`)
    }

    return {
      success: true,
      message: action === 'read' ? 'Goals fetched successfully' : `Goal ${action}d successfully`,
    }
  } catch (error) {
    console.error('Error performing goal action:', error)
    return { success: false, message: `Failed to ${action} goal`, error: error.message }
  }
})

================
File: apps/admin-dashboard/server/api/healthy.ts
================
import { defineEventHandler } from 'h3'

export default defineEventHandler(async (event) => {
  const startTime = Date.now()
  const env = useRuntimeConfig().public
  const port = process.env.PORT

  try {
    // You can add more checks here, e.g., Redis connection, external API calls, etc.

    const uptime = process.uptime()
    const memoryUsage = process.memoryUsage()

    console.log('Health check successful', env)
    console.log('Process Port:', port)
    console.log('Nitro Port: ')

    return {
      status: 'healthy',
      timestamp: new Date().toISOString(),
      uptime: uptime,
      memory: {
        rss: memoryUsage.rss,
        heapTotal: memoryUsage.heapTotal,
        heapUsed: memoryUsage.heapUsed,
        external: memoryUsage.external,
      },
      environment: process.env.NODE_ENV,
      databaseConnection: 'ok',
      responseTime: Date.now() - startTime,
    }
  } catch (error: any) {
    console.error('Health check failed:', error)

    return {
      status: 'unhealthy',
      timestamp: new Date().toISOString(),
      error: error.message,
      responseTime: Date.now() - startTime,
    }
  }
})

================
File: apps/admin-dashboard/server/api/milestones.ts
================
import { promises as fs } from 'fs'
import { resolve } from 'path'
import { defineEventHandler, readBody } from 'h3'

const milestonesFilePath = resolve(process.cwd(), 'data', 'tasks', 'milestones.json')

export default defineEventHandler(async (event) => {
  const method = event.node.req.method

  if (method === 'GET') {
    try {
      const data = await fs.readFile(milestonesFilePath, 'utf-8')
      return JSON.parse(data)
    } catch (error) {
      console.error('Error reading milestones:', error)
      throw createError({
        statusCode: 500,
        statusMessage: 'Failed to read milestones',
      })
    }
  } else if (method === 'POST') {
    const body = await readBody(event)
    const { action, milestone } = body

    try {
      const data = await fs.readFile(milestonesFilePath, 'utf-8')
      let milestones = JSON.parse(data)

      switch (action) {
        case 'create':
          milestone.id = Math.max(...milestones.map((m: Milestone) => m.id)) + 1
          milestones.push(milestone)
          break
        case 'update':
          const index = milestones.findIndex((m: Milestone) => m.id === milestone.id)
          if (index !== -1) {
            milestones[index] = milestone
          }
          break
        case 'delete':
          milestones = milestones.filter((m: Milestone) => m.id !== milestone.id)
          break
        default:
          throw new Error(`Invalid action: ${action}`)
      }

      await fs.writeFile(milestonesFilePath, JSON.stringify(milestones, null, 2), 'utf-8')
      return { success: true, message: `Milestone ${action}d successfully` }
    } catch (error) {
      console.error(`Error ${action}ing milestone:`, error)
      throw createError({
        statusCode: 500,
        statusMessage: `Failed to ${action} milestone`,
      })
    }
  }
})

================
File: apps/admin-dashboard/server/api/server-jobs.ts
================
import { defineWebSocketHandler } from 'h3'
import { WebSocket } from 'ws'
import jwt from 'jsonwebtoken'

const clients = new Set()
let serverWs: WebSocket | null = null
let reconnectTimeout: NodeJS.Timeout | null = null
let reconnectAttempts = 0
const maxReconnectAttempts = 5
let reconnectInterval = 5000 // 5 seconds

let selectedMetrics: string[] = ['all']

const connectToAnalyticsServer = () => {
  if (reconnectAttempts >= maxReconnectAttempts) {
    console.log('Max reconnect attempts reached. Stopping reconnection attempts.')
    return
  }

  const scraperKey = useRuntimeConfig().scraperKey
  const token = jwt.sign({ sender: 'AstronEra' }, scraperKey, {
    algorithm: 'HS256',
  })

  const scraperBaseURL = useRuntimeConfig().public.scraperUrl
  const wsUrl = `${scraperBaseURL.replace(/^http/, 'ws')}/analytics`

  console.log(`Connecting to WebSocket URL: ${wsUrl}`)

  serverWs = new WebSocket(wsUrl, {
    headers: { Authorization: `Bearer ${token}` },
  })

  serverWs.on('open', () => {
    console.log('Connected to Analytics WebSocket server')
    reconnectAttempts = 0
    if (reconnectTimeout) {
      clearTimeout(reconnectTimeout)
      reconnectTimeout = null
    }
    // Send initial subscription with the selected metrics

    console.log('Subscribing to metrics:', selectedMetrics)
    serverWs.send(
      JSON.stringify({
        action: 'subscribe',
        metrics: selectedMetrics,
      }),
    )
  })

  serverWs.on('message', (data) => {
    // Broadcast the message to all connected Nuxt clients
    console.log('Received message from Analytics server:', data.toString())
    for (const client of clients) {
      client.send(data)
    }
  })

  serverWs.on('close', (code, reason) => {
    console.log(`Disconnected from Analytics WebSocket server: ${code} - ${reason}`)
    serverWs = null
    scheduleReconnect()
  })

  serverWs.on('error', (error) => {
    console.error('Error with Analytics WebSocket connection:', error)
    if (serverWs) {
      serverWs.close()
    }
  })
}

const scheduleReconnect = () => {
  if (reconnectAttempts < maxReconnectAttempts) {
    reconnectAttempts++
    console.log(
      `Scheduling reconnection attempt ${reconnectAttempts}/${maxReconnectAttempts} in ${reconnectInterval}ms`,
    )
    reconnectTimeout = setTimeout(() => {
      console.log(`Executing reconnection attempt ${reconnectAttempts}`)
      connectToAnalyticsServer()
    }, reconnectInterval)
  } else {
    console.log('Max reconnect attempts reached. Please check the server.')
  }
}

export default defineWebSocketHandler({
  async open(peer) {
    console.log('Nuxt client connected')
    clients.add(peer)

    if (!serverWs) {
      connectToAnalyticsServer()
    }
  },

  message(peer, message) {
    console.log('Received message from Nuxt client:', message)
    try {
      const parsedMessage = JSON.parse(message)
      selectedMetrics = parsedMessage.metrics
      console.log('Updated selectedMetrics:', selectedMetrics)

      if (serverWs && serverWs.readyState === WebSocket.OPEN) {
        console.log(
          'Forwarding message to Analytics server:',
          JSON.stringify({
            action: 'subscribe',
            subscribedMetrics: parsedMessage.metrics,
          }),
        )
        serverWs.send(
          JSON.stringify({
            action: 'subscribe',
            subscribedMetrics: parsedMessage.metrics,
          }),
        )
      } else {
        console.log(
          'Cannot forward message: serverWs not ready. Current state:',
          serverWs ? serverWs.readyState : 'null',
        )
      }
    } catch (error) {
      console.error('Error parsing or handling message:', error)
    }
  },

  close(peer) {
    console.log('Nuxt client disconnected')
    clients.delete(peer)

    if (clients.size === 0 && serverWs) {
      console.log('No more clients, closing server connection')
      serverWs.close()
      serverWs = null
      if (reconnectInterval) {
        clearInterval(reconnectInterval)
        reconnectInterval = null
      }
    }
  },

  error(peer, error) {
    console.error('Error with Nuxt client connection:', error)
    clients.delete(peer)
  },
})

================
File: apps/admin-dashboard/server/api/store-image.ts
================
export default defineEventHandler(async (event) => {
  try {
    console.log('store-image start')
    // !todo: I envision this endpoint being called, fetching all the image URLs that need to be stored
    // We would need to check if we have already stored the image, and if not, fetch and store it
    // When storing it would need to be stored in a folder using the news.id as the folder name
    // image name doesn't matter
    // then we would need to update the news.featured_image with the new URL

    // Fetch the image as a blob
    const imgBlob = await $fetch(
      'https://cdn.mos.cms.futurecdn.net/594rdNk4Ci9qT8e2XKsQ7Q-970-80.jpg.webp',
      { responseType: 'blob' },
    )

    console.log('Image fetched', imgBlob)

    // Get the Supabase client
    const supabase = await dbClient(event)

    // Upload the blob to Supabase Storage
    const { data, error } = await supabase.storage.from('posts').upload('public/test.webp', imgBlob)

    if (error) {
      throw createError({ message: `Error uploading image: ${error.message}` })
    }

    console.log('Image uploaded successfully')

    return {
      status: 200,
      message: 'Image Stored',
    }
  } catch (error: any) {
    console.error('store-image error', error.message)
    return {
      status: 500,
      message: 'Error Storing Image',
      error,
    }
  }
})

================
File: apps/admin-dashboard/server/utils/socials/useInstagramAnalytics.ts
================
import { useErrorHandler, useLoggerAsync } from '@ib/logger'

const INSTAGRAM_API_URL = 'https://graph.instagram.com'
const ACCESS_TOKEN = 'YOUR_INSTAGRAM_ACCESS_TOKEN'
const PREFIX = 'useInstagramAnalytics'

export async function useInstagramAnalytics() {
  const log = await useLoggerAsync(PREFIX)
  const errors = useErrorHandler(PREFIX)

  async function fetchProfileStatistics(userId: string) {
    log.info(`Fetching instagram profile statistics for: ${userId}`)
    const url = `${INSTAGRAM_API_URL}/${userId}?fields=id,username,media_count,followers_count,follows_count&access_token=${ACCESS_TOKEN}`
    const response = await $fetch(url)
    const data = errors.handleFetchError({
      response,
      devMessage: `Failed to fetch profile statistics for ${userId}`,
      userMessage: `Failed to fetch statistics for profile ${userId}`,
    })
    return data
  }

  async function fetchBusinessAnalytics(username: string) {
    const url = `${INSTAGRAM_API_URL}/${userId}?fields=business_discovery.username(${username}){followers_count,media_count,media{comments_count,like_count}}&access_token=${ACCESS_TOKEN}`
    const response = await $fetch(url, {
      headers: {
        Authorization: `Bearer ${ACCESS_TOKEN}`,
      },
    })
    const data = errors.handleFetchError({
      response,
      devMessage: `Failed to fetch business analytics for ${username}`,
      userMessage: `Failed to fetch analytics for ${username}`,
    })
    return {
      followers_count: data.business_discovery.followers_count,
      media_count: data.business_discovery.media_count,
      media: data.business_discovery.media.data.map((mediaItem: any) => ({
        id: mediaItem.id,
        comments_count: mediaItem.comments_count,
        like_count: mediaItem.like_count,
      })),
    }
  }

  return {
    fetchProfileStatistics,
    fetchBusinessAnalytics,
  }
}

================
File: apps/admin-dashboard/server/utils/socials/useLinkedinAnalytics.ts
================
import { useErrorHandler } from '@ib/logger'

const LINKEDIN_API_URL = 'https://api.linkedin.com/rest/dmaOrganizationalPageContentAnalytics'
const ACCESS_TOKEN = 'YOUR_LINKEDIN_ACCESS_TOKEN'

export function useLinkedinAnalytics(postId: string) {
  const errors = useErrorHandler('getLinkedInPageAnalytics')

  // https://learn.microsoft.com/en-us/linkedin/dma/analytics/organizational-page-content-analytics?tabs=http%2Cnon-obfuscated
  async function fetchPostAnalytics() {
    const url = `${LINKEDIN_API_URL}?q=postDimension&sourcePostEntity=${postId}&metricType=IMPRESSIONS,REPOSTS,COMMENTS,REACTIONS&dimensionType=STAFF_COUNT_RANGE&access_token=${ACCESS_TOKEN}`
    const response = await $fetch(url, {
      headers: {
        Authorization: `Bearer ${ACCESS_TOKEN}`,
      },
    })
    const data = errors.handleFetchError({
      response,
      devMessage: `Failed to fetch post analytics for ${postId}`,
      userMessage: `Failed to fetch analytics for post ${postId}`,
    })
    return data.elements.map((element: any) => ({
      type: element.type,
      value: element.metric.value.totalCount.long,
    }))
  }

  // Fetch trend data for the LinkedIn organizational page
  async function fetchTrendAnalytics(startDate: number, endDate: number, pageId: string) {
    const url = `${LINKEDIN_API_URL}?q=trend&sourceEntity=urn:li:organizationalPage:${pageId}&metricTypes=List(IMPRESSIONS,COMMENTS,REACTIONS,REPOSTS,ENGAGEMENT_RATE,CTR,ACQUIRED_FOLLOWS)&timeIntervals=(timeRange:(start:${startDate},end:${endDate}))`

    const response = await $fetch(url, {
      headers: {
        Authorization: `Bearer ${ACCESS_TOKEN}`,
      },
    })

    const data = errors.handleFetchError({
      response,
      devMessage: `Failed to fetch trend analytics for page ${pageId}`,
      userMessage: `Failed to fetch trend analytics for page ${pageId}`,
    })

    return data.elements.map((element: any) => ({
      type: element.type,
      value: element.metric.value.totalCount.long || element.metric.value.totalCount.bigDecimal,
    }))
  }

  return {
    fetchPostAnalytics,
    fetchTrendAnalytics,
  }
}

================
File: apps/admin-dashboard/server/utils/socials/useTwitterAnalytics.ts
================
import { useErrorHandler } from '@ib/logger'

// user tweet timeline
// https://developer.twitter.com/en/docs/twitter-api/tweets/timelines/api-reference/get-users-id-tweets

// mentions timeline
// https://developer.twitter.com/en/docs/twitter-api/tweets/timelines/api-reference/get-users-id-mentions

// api reference
// https://github.com/xdevplatform/twitter-api-typescript-sdk

// LINKEDIN

// MANAGE ACCOUNTS
// https://github.com/linkedin-developers/linkedin-api-js-client

// NON OFFICIAL API: https://github.com/tomquirk/linkedin-api

const TWITTER_API_URL = 'https://api.twitter.com/2/tweets'
const BEARER_TOKEN = 'YOUR_TWITTER_BEARER_TOKEN'

export function useTwitterAnalytics(postId: string) {
  const errors = useErrorHandler('getTwitterPostAnalytics')

  //
  async function fetchPostAnalytics() {
    const url = `${TWITTER_API_URL}/${postId}?tweet.fields=non_public_metrics,organic_metrics&expansions=attachments.media_keys&media.fields=non_public_metrics,organic_metrics`
    const response = await $fetch(url, {
      headers: {
        Authorization: `Bearer ${BEARER_TOKEN}`,
      },
    })
    const data = errors.handleFetchError({
      response,
      devMessage: `Failed to fetch post analytics for ${postId}`,
      userMessage: `Failed to fetch analytics for post ${postId}`,
    })
    return {
      impression_count: data.data.non_public_metrics.impression_count,
      like_count: data.data.organic_metrics.like_count,
      reply_count: data.data.organic_metrics.reply_count,
      retweet_count: data.data.organic_metrics.retweet_count,
      quote_count: data.data.public_metrics.quote_count,
      url_link_clicks: data.data.non_public_metrics.url_link_clicks,
      user_profile_clicks: data.data.non_public_metrics.user_profile_clicks,
      media: data.includes.media,
    }
  }

  async function fetchUserProfile(userId: string) {
    const url = `${TWITTER_API_URL}/users/${userId}?user.fields=created_at,description,entities,id,location,name,pinned_tweet_id,profile_image_url,protected,url,username,verified,withheld&expansions=pinned_tweet_id`
    const response = await $fetch(url, {
      headers: {
        Authorization: `Bearer ${BEARER_TOKEN}`,
      },
    })
    const data = errors.handleFetchError({
      response,
      devMessage: `Failed to fetch user profile for ${userId}`,
      userMessage: `Failed to fetch profile for user ${userId}`,
    })
    return {
      id: data.data.id,
      name: data.data.name,
      username: data.data.username,
      created_at: data.data.created_at,
      description: data.data.description,
      entities: data.data.entities,
      location: data.data.location,
      pinned_tweet_id: data.data.pinned_tweet_id,
      profile_image_url: data.data.profile_image_url,
      protected: data.data.protected,
      url: data.data.url,
      verified: data.data.verified,
      withheld: data.data.withheld,
      pinned_tweet: data.includes.tweets ? data.includes.tweets[0] : null,
    }
  }

  return {
    fetchPostAnalytics,
    fetchUserProfile,
  }
}

================
File: apps/admin-dashboard/nuxt.config.ts
================
import { fileURLToPath } from 'url'
import { dirname, join, resolve } from 'path'
import { defineNuxtConfig } from 'nuxt/config'
import runtimeConfig from '../../shared-runtime.config'

const currentDir = dirname(fileURLToPath(import.meta.url))

export default defineNuxtConfig({
  workspaceDir: '../../',
  srcDir: '.',
  extends: ['../../layers/base', '../../layers/auth', '../../layers/crud', '../../layers/advert'],
  modules: [
    '@nuxt/devtools',
    '@vueuse/nuxt',
    '@nuxt/content',
    '@nuxt/image',
    '@pinia/nuxt',
    '@nuxt/icon',
    '@nuxt/eslint',
    '@nuxtjs/tailwindcss',
    '@nuxtjs/supabase',
    '@primevue/nuxt-module',
  ],

  ssr: false,

  nitro: {
    experimental: {
      websocket: true,
    },
  },

  // tailwindcss: {
  //   configPath: `${currentDir}/tailwind.config.ts`,
  // cssPath: [`${currentDir}/assets/css/tailwind.css`, { injectPosition: 0 }],
  //   exposeConfig: true,
  //   viewer: true,
  // },

  primevue: {
    importPT: { from: resolve(currentDir, '../../theme/index.js') },
    autoImport: true,
    components: {
      prefix: 'Prime',
      include: '*',
      exclude: ['Editor'],
    },

    composables: {
      include: '*',
    },

    options: {
      ripple: true,
      unstyled: true,
      theme: {
        options: {
          cssLayer: {
            name: 'primevue',
            order: 'tailwind-base, primevue, tailwind-utilities',
          },
        },
      },
    },
  },

  ...runtimeConfig,
})

================
File: apps/auth-service/components/form/FormPassword.vue
================
<script setup lang="ts">
interface Props {
  modelValue: string
  id?: string
  suggestions?: string[]
  invalid?: boolean
  placeholder?: string
  disabled?: boolean
  required?: boolean
  inputClass?: string
  label?: string
  mediumRegex?: string
  strongRegex?: string
  feedback?: boolean
}

const props = withDefaults(defineProps<Props>(), {
  label: undefined,
  id: 'password',
  suggestions: () => [
    'At least one lowercase',
    'At least one uppercase',
    'At least one numeric',
    'Minimum 6 characters',
  ],
  invalid: false,
  feedback: true,
  placeholder: undefined,
  disabled: false,
  required: false,
  inputClass: 'w-full',
  mediumRegex:
    '^(((?=.*[a-z])(?=.*[A-Z]))|((?=.*[a-z])(?=.*[0-9]))|((?=.*[A-Z])(?=.*[0-9])))(?=.{6,})',
  strongRegex: '^(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9])(?=.{8,})',
})

const emit = defineEmits<{
  (e: 'update:modelValue', value: string): void
}>()

const onPasswordChange = (value: string) => {
  emit('update:modelValue', value)
}
</script>

<template>
  <label
    v-if="label"
    :for="id"
    >{{ label }}</label
  >
  <PrimePassword
    :id="id"
    class="w-full"
    :input-class="inputClass"
    :feedback="props.feedback"
    :model-value="modelValue"
    :invalid="invalid"
    :disabled="disabled"
    :required="required"
    :placeholder="placeholder"
    :label="props.label"
    @update:model-value="onPasswordChange"
  >
    <template #footer>
      <PrimeDivider />
      <p class="mt-2"> Suggestions </p>
      <ul
        class="ml-2 mt-0 pl-2"
        style="line-height: 1.5"
      >
        <li
          v-for="suggestion in props.suggestions"
          :key="suggestion"
        >
          {{ suggestion }}
        </li>
      </ul>
    </template>
  </PrimePassword>
</template>

<style scoped></style>

================
File: apps/auth-service/components/AuthCard.vue
================
<script setup lang="ts">
import type { TitleType } from '@/types/content'

defineProps({
  title: {
    type: Object as PropType<TitleType>,
    default: () => ({
      main: 'main title',
      subtitle: 'subtitle',
      label: 'label',
    }),
  },
  helpUrl: {
    type: String,
    default: '/login',
  },
  showTitle: {
    type: Boolean,
    default: false,
  },
  noFooter: {
    type: Boolean,
    default: false,
  },
})

// const currentUser = useCurrentUser()
// const { haveUserSession } = storeToRefs(currentUser)
</script>

<template>
  <div class="space-between flex min-h-full flex-col space-y-4">
    <div class="flex h-full flex-row items-center justify-center gap-4 py-8 text-white mx-auto">
      <div class="border-color group relative rounded-full border bg-white p-4 hover:invert">
        <NuxtLink
          to="/"
          class="flex items-center justify-center"
        >
          <IBImage
            class="group-hover:opacity-0"
            :img="{
              src: 'astronera-logo.jpg',
              alt: 'AstronEra Logo',
              width: '60',
              height: '60',
            }"
          />
          <p class="absolute mx-auto my-auto hidden text-black group-hover:flex"> Go Home </p>
        </NuxtLink>
      </div>
      <div class="w-full">
        <h2 class="text-3xl font-extrabold lg:text-start">
          {{ title.main }}
        </h2>
        <span class="flex items-center gap-2 text-start font-bold lg:justify-start">
          {{ title.subtitle }}
          <NuxtLink
            v-if="helpUrl && title.label"
            :to="helpUrl"
            class="text-primary-500 underline"
          >
            <PrimeButton
              link
              class="!p-0 !m-0 leading-normal underline"
            >
              {{ title.label }}
            </PrimeButton>
          </NuxtLink>
        </span>
      </div>
    </div>
    <PrimeCard class="max-w-sm w-full mx-auto py-2">
      <!-- <template
        v-if="showTitle && haveUserSession"
        #title
      >
        <div class="flex flex-col gap-4 xl:gap-6">
          <div>
            <AuthVerifiedWith class="w-full" />

            <div class="w-full pt-4">
              <PrimeDivider
                layout="horizontal"
                class="justify-left flex items-center"
              >
                <p>Or Login with</p>
              </PrimeDivider>
            </div>
          </div>
        </div>
      </template> -->
      <template #content>
        <div class="flex flex-col gap-4 xl:gap-6">
          <slot name="content" />
        </div>
      </template>
      <template
        v-if="!noFooter"
        #footer
      >
        <slot name="footer" />
      </template>
    </PrimeCard>
  </div>
</template>

<style scoped></style>

================
File: apps/auth-service/components/AuthRegisterWith.vue
================
<script setup lang="ts">
const auth = useAuth()
</script>

<template>
  <div class="w-full h-full">
    <div class="w-full">
      <PrimeDivider
        layout="horizontal"
        class="flex justify-left items-center"
      >
        <p>Or continue with</p>
      </PrimeDivider>
    </div>
    <div class="flex gap-4 xl:gap-6 w-full pt-4">
      <AuthSocialButton
        provider="twitter"
        @social-login="auth.loginSocial('twitter')"
      />
      <AuthSocialButton
        provider="linkedin"
        @social-login="auth.loginSocial('linkedin_oidc')"
      />
    </div>
  </div>
</template>

<style></style>

================
File: apps/auth-service/components/AuthSocialButton.vue
================
<script setup lang="ts">
type Provider = 'twitter' | 'linkedin'

defineProps({
  provider: {
    type: String as PropType<Provider>,
    required: true,
  },
})

const emit = defineEmits(['social-login'])

const socialLogin = () => {
  emit('social-login')
}
</script>

<template>
  <PrimeButton @click="socialLogin">
    <span>
      <Icon
        class="flex items-center justify-center"
        :name="`mdi:${provider}`"
        size="30px"
      />
    </span>
  </PrimeButton>
</template>

================
File: apps/auth-service/components/AuthVerifiedWith.vue
================
<script setup lang="ts">
import { useChangeCase } from '@vueuse/integrations/useChangeCase'

const currentUser = useCurrentUser()
const { haveUserSession, registeredWithProvider } = storeToRefs(currentUser)

const currentProvider = computed(() => {
  return useChangeCase(registeredWithProvider.value, 'capitalCase').value
})

const verifiedIcon = computed(() => {
  if (registeredWithProvider.value === 'email') {
    return 'mdi:email'
  } else if (registeredWithProvider.value === 'google') {
    return 'mdi:google'
  } else if (registeredWithProvider.value === 'facebook') {
    return 'mdi:facebook'
  } else if (registeredWithProvider.value === 'twitter') {
    return 'mdi:twitter'
  } else if (registeredWithProvider.value === 'linkedin_oidc') {
    return 'mdi:linkedin'
  } else {
    return 'mdi:account'
  }
})
</script>

<template>
  <div
    v-if="haveUserSession"
    class="flex items-center justify-start"
  >
    <div class="flex flex-col items-center">
      <NuxtLink
        v-ripple
        to="/"
      >
        <PrimeButton>
          Visit Dashboard
          <Icon
            name="mdi:play"
            size="24px"
          />
        </PrimeButton>
      </NuxtLink>
    </div>
  </div>
</template>

<style scoped></style>

================
File: apps/auth-service/components/TurnstileChallenge.vue
================
<template>
  <div>
    <div class="cf-turnstile"></div>
  </div>
</template>

<script setup>
const props = defineProps({
  onValidToken: {
    type: Function,
    required: true,
  },
})

const scriptLoaded = ref(false)

const emit = defineEmits(['error', 'expired', 'success'])
const config = useRuntimeConfig()
const colorMode = useColorMode()

// Load Turnstile script
useHead({
  script: [
    {
      src: 'https://challenges.cloudflare.com/turnstile/v0/api.js?render=explicit',
      async: true,
      defer: true,
      onload: () => {
        console.log('Turnstile script loaded successfully')
        scriptLoaded.value = true
      },
      onerror: () => {
        console.error('Failed to load Turnstile script')
      },
    },
  ],
})

const onSuccess = async (token) => {
  try {
    // Call server API to validate token
    const response = await $fetch('/validate-turnstile', {
      method: 'POST',
      body: { token },
    })

    if (response.success) {
      props.onValidToken(token)
      emit('success', token)
    } else {
      console.error('Turnstile validation failed')
      emit('error', new Error('Validation failed'))
    }
  } catch (error) {
    console.error('Error validating Turnstile token:', error)
    emit('error', error)
  }
}

const onError = (error) => {
  console.error('Turnstile error:', error)
  emit('error', error)
}

const onExpired = () => {
  console.warn('Turnstile token expired')
  emit('expired')
}

const reset = () => {
  if (window.turnstile) {
    window.turnstile.reset()
  }
}

onMounted(() => {
  watch(scriptLoaded, (loaded) => {
    if (loaded) {
      renderTurnstile()
    }
  })
})

const renderTurnstile = () => {
  if (window.turnstile) {
    window.turnstile.render('.cf-turnstile', {
      'sitekey': config.public.turnstileSiteKey,
      'theme': colorMode.value === 'dark' ? 'dark' : 'light',
      'callback': onSuccess,
      'error-callback': onError,
      'expired-callback': onExpired,
    })
  }
}

// Expose reset method to parent components
defineExpose({ reset })
</script>

================
File: apps/auth-service/composables/useAuth.ts
================
import { z } from 'zod'
import { useLogger } from '@ib/logger'

const passwordValidation = z
  .string()
  .min(8, 'Password must contain 6 characters')
  .regex(/[A-Z]/, 'Password must contain an uppercase letter')
  .regex(/[^a-zA-Z0-9]/, 'Password must contain a special character')

export const SettingsPasswordValidation = z
  .object({
    currentPassword: passwordValidation,
    newPassword: passwordValidation,
    confirmNewPassword: passwordValidation,
  })
  .refine((data) => data.newPassword === data.confirmNewPassword, {
    message: "Passwords don't match",
    path: ['confirmNewPassword'],
  })

export type SettingsPasswordType = z.infer<typeof SettingsPasswordValidation>

export function useAuth() {
  const { authURL, appURL } = useRuntimeConfig().public
  const authUrl = authURL
  const appUrl = `${appURL}/auth-callback`

  const logger = useLogger('auth')
  const toast = useNotification()
  const supabase = useSupabaseClient()

  const loading = useLoadingStore()

  // !todo:bug - I believe there is an issue where the token expires for Social login but it doesn't refresh
  // !todo:high - retrieve current user profile

  const userPasswordSettings = reactive({
    currentPassword: 'current password',
    newPassword: 'new password',
    confirmNewPassword: 'confirm new password',
  })

  interface RegisterWithEmail {
    email: string
    password: string
    confirmPassword: string
    given_name: string
    surname: string
  }

  const registerWithEmail = async (formData: {
    email: string
    password: string
    given_name: string
    surname: string
    turnstileToken?: string | null
  }) => {
    // First validate the turnstile token if provided
    if (formData.turnstileToken) {
      const validation = await $fetch('/validate-turnstile', {
        method: 'POST',
        body: { token: formData.turnstileToken },
      })

      if (!validation.success) {
        throw new Error('Invalid captcha')
      }
    }

    // Proceed with registration
    const { data, error } = await supabase.auth.signUp({
      email: formData.email,
      password: formData.password,
      options: {
        data: {
          given_name: formData.given_name,
          surname: formData.surname,
        },
      },
    })

    if (error) throw error

    // Handle successful registration
    return data
  }

  const loginWithEmail = async (
    email: string,
    password: string,
    options?: { turnstileToken: string | null },
  ) => {
    // First validate the turnstile token if provided
    if (options?.turnstileToken) {
      const validation = await $fetch('/validate-turnstile', {
        method: 'POST',
        body: { token: options.turnstileToken },
      })

      if (!validation.success) {
        throw new Error('Invalid captcha')
      }
    }

    // Proceed with login
    const { data, error } = await supabase.auth.signInWithPassword({
      email,
      password,
      options: { captchaToken: options?.turnstileToken },
    })

    if (error) throw error
    toast.success({ summary: 'Authenticated', message: 'Logging In...' })
    await new Promise((resolve) => setTimeout(resolve, 1000))
    navigateTo(appURL, { external: true })
  }

  async function loginSocial(provider: 'linkedin_oidc' | 'twitter') {
    const { data: user, error } = await supabase.auth.signInWithOAuth({
      provider,
      options: {
        redirectTo: appUrl,
      },
    })

    if (error?.message) {
      console.error({ message: error.message })
      toast.error({ summary: `${provider} login:`, message: error.message })
    }

    if (!user) {
      console.error({ message: 'Login failed' })
      toast.error({
        summary: 'Login failed',
        message: `there was an error logging in with ${provider}, no user returned`,
      })
    }
  }

  async function forgotPassword(email: string) {
    // infra:critical:easy:1 - add correct redirect for userId/settings/password
    const { error } = await supabase.auth.resetPasswordForEmail(email, {
      redirectTo: `${authUrl}settings/password`,
    })

    if (error) {
      console.error('Forgot password failed:', error)
      toast.error({ summary: 'Password Reset Failed', message: error.message })
    } else {
      toast.success({
        summary: 'Email Sent',
        message: 'Check your email for a password reset link',
      })
    }
  }

  async function updatePassword(newPassword: string) {
    const { error } = await supabase.auth.updateUser({ password: newPassword })

    if (error) {
      console.error('Password update failed:', error)
      toast.error({ summary: 'Password Update Failed', message: error.message })
    } else {
      toast.success({ summary: 'Password Updated', message: 'Your password has been updated' })
    }
  }

  async function logout() {
    const { error } = await supabase.auth.signOut()
    if (error) {
      console.error('Logout failed:', error)
      toast.error({ summary: 'Logout Failed', message: error.message })
    } else {
      toast.success({ summary: 'You Logged Out', message: 'You have been logged out' })
      navigateTo(authURL, { external: true })
    }
  }

  return {
    registerWithEmail,
    loginWithEmail,
    loginSocial,
    logout,
    password: {
      forgot: forgotPassword,
      update: updatePassword,
    },
  }
}

================
File: apps/auth-service/composables/useAuthUser.ts
================
// composables/useAuth.ts
export async function forgotPassword(email: string) {
  const { error } = await supabase.auth.resetPasswordForEmail(email, {
    redirectTo: `${authUrl}/reset-password`, // Public reset password page
  })
  if (error) {
    console.error('Forgot password failed:', error)
    toast.error({
      summary: 'Password Reset Failed',
      message: error.message,
    })
  } else {
    toast.success({ summary: 'EmailSent', message: 'Check your email for a password reset link' })
  }
}

================
File: apps/auth-service/composables/useResetPassword.ts
================
export interface ResetPasswordParams {
  access_token?: string
  refresh_token?: string
  expires_in?: number
  token_type?: string
  type?: string
}

// composables/useResetPassword.ts
export function useResetPassword() {
  const supabase = useSupabaseClient()

  // Verify the reset token is valid
  async function verifyResetToken(hash: string): Promise<boolean> {
    try {
      const params = parseHashFragment(hash)
      // Verify token with Supabase
      const { error } = await supabase.auth.verifyOtp({
        token_hash: params.access_token,
        type: 'recovery',
      })
      return !error
    } catch {
      return false
    }
  }

  return {
    verifyResetToken,
  }
}

================
File: apps/auth-service/layouts/default.vue
================
<script setup lang="ts">
const isAuthenticating = ref(true)
const route = useRoute()
onMounted(async () => {
  const toast = useNotification()
  const supabase = useSupabaseClient()
  const { data, error } = await supabase.auth.getSession()
  if (!data.session || error) {
    isAuthenticating.value = false
  } else {
    toast.success({ summary: 'Authenticated', message: 'Found user session' })
    await new Promise((resolve) => setTimeout(resolve, 1000))
  }
})

// !todo:consider:2 - add a delay to function execution, fade out the auth cards so the bg image is fully visible for a few seconds, then execute
// !todo:low:1 - add transitions to the auth cards
// !todo:high:1 - add subtitle prompt to all auth cards
// !todo:med:2 - handle session expired, redirect to login with explanation
</script>

<template>
  <div
    v-if="isAuthenticating && !route.path.includes('settings')"
    class="text-white w-screen flex justify-center items-center absolute h-screen z-50 bg-black bg-opacity-50"
    >Looking for a session...</div
  >
  <div
    :class="{ 'pointer-events-none': isAuthenticating && !route.path.includes('settings') }"
    class="relative flex h-full min-h-screen w-full items-center justify-start"
  >
    <div class="foreground relative z-20 min-h-lvh w-full min-w-[340px] max-w-[540px] p-4 lg:p-8">
      <ClientOnly>
        <slot />
      </ClientOnly>
    </div>
    <div class="absolute left-0 top-0 flex h-full w-full">
      <div class="absolute left-0 top-0 h-full w-full bg-black/40" />
      <IBBackground class="left-0 top-0 z-0 hidden lg:fixed lg:block" />

      <IBImage
        :img="{
          src: '/astron-era-hero.jpg',
          alt: '',
        }"
        class="min-h-full w-full object-cover object-center"
      />
    </div>
  </div>
</template>

<style scoped>
::-webkit-scrollbar {
  display: none;
}
</style>

================
File: apps/auth-service/middleware/auth.global.ts
================
// middleware/auth.ts
export default defineNuxtRouteMiddleware(async (to) => {
  const config = useRuntimeConfig()
  const { appURL } = config.public
  const supabase = useSupabaseClient()

  // Define public routes that don't require authentication
  const publicRoutes = [
    '/login',
    '/register',
    '/forgot-password',
    '/reset-password',
    '/success', // For registration success page
  ]

  // Allow access to public routes without checking auth
  if (publicRoutes.includes(to.path)) {
    return
  }

  const { data, error } = await supabase.auth.getSession()

  if (error || !data.session) {
    console.log('USER_NOT_LOGGED_IN')
    return navigateTo('/login')
  }

  // Don't redirect to app if user is logged in and accessing the password settings
  if (to.path === '/settings/password') {
    return
  }

  // Redirect to main app for all other authenticated routes
  console.log('USER_LOGGED_IN', data.session)
  return navigateTo(appURL, { external: true })
})

================
File: apps/auth-service/middleware/reset-password.ts
================
// middleware/reset-password.ts
export default defineNuxtRouteMiddleware((to) => {
  // Only allow access to reset-password page with valid hash
  if (to.path === '/reset-password' && !to.hash) {
    return navigateTo('/login')
  }
})

================
File: apps/auth-service/pages/settings/password.vue
================
<!-- pages/settings/password.vue -->
<script setup lang="ts">
const auth = useAuth()
const toast = useNotification()
const supabase = useSupabaseClient()
const currentUser = useCurrentUser()
const { profile } = storeToRefs(currentUser)

const form = reactive({
  currentPassword: '',
  newPassword: '',
  confirmNewPassword: '',
})

const hasEmailProvider = computed(() => {
  return profile.value?.providers?.includes('email')
})

const linkedProviders = computed(() => {
  const providers = profile.value?.providers || []
  return providers
    .filter((p) => p !== 'email')
    .map((provider) => ({
      name: currentUser.formatProviderName(provider),
      icon: currentUser.getProviderIcon(provider),
    }))
})

const providerName = computed(() => {
  const providers = {
    linkedin_oidc: 'LinkedIn',
    twitter: 'Twitter',
    google: 'Google',
    facebook: 'Facebook',
  }
  return providers[registeredWithProvider.value] || registeredWithProvider.value
})

async function handleUpdatePassword() {
  try {
    // First verify current password
    const { error: verifyError } = await supabase.auth.signInWithPassword({
      email: auth.user.email,
      password: form.currentPassword,
    })

    if (verifyError) {
      toast.error({
        summary: 'Invalid Password',
        message: 'Current password is incorrect',
      })
      return
    }

    // Then update to new password
    await auth.password.update(form.newPassword)

    // Clear form
    form.currentPassword = ''
    form.newPassword = ''
    form.confirmNewPassword = ''
  } catch (error) {
    toast.error({
      summary: 'Update Failed',
      message: error.message,
    })
  }
}
</script>

<template>
  <AuthCard
    no-footer
    :title="{
      main: 'Password Settings',
      subtitle: 'Change your password',
    }"
  >
    <template #content>
      <div
        v-if="!hasEmailProvider"
        class="mb-6"
      >
        <PrimeMessage severity="info">
          <p>Password management is not available as you are only using social login.</p>
          <p class="mt-2">Current login methods:</p>
          <div class="mt-2 flex gap-2">
            <template
              v-for="provider in linkedProviders"
              :key="provider.name"
            >
              <div class="flex items-center gap-1">
                <Icon :name="provider.icon" />
                <span>{{ provider.name }}</span>
              </div>
            </template>
          </div>
        </PrimeMessage>
      </div>

      <form
        v-else
        class="w-full"
        @submit.prevent="handleUpdatePassword"
      >
        <div class="space-y-4">
          <PrimeFloatLabel class="w-full">
            <PrimePassword
              v-model="form.currentPassword"
              class="w-full"
              input-class="w-full"
              required
            />
            <label>Current Password</label>
          </PrimeFloatLabel>

          <PrimeFloatLabel class="w-full">
            <PrimePassword
              v-model="form.newPassword"
              class="w-full"
              input-class="w-full"
              :feedback="true"
              required
            />
            <label>New Password</label>
          </PrimeFloatLabel>

          <PrimeFloatLabel class="w-full">
            <PrimePassword
              v-model="form.confirmNewPassword"
              class="w-full"
              input-class="w-full"
              required
            />
            <label>Confirm New Password</label>
          </PrimeFloatLabel>

          <PrimeButton
            type="submit"
            class="w-full"
          >
            Update Password
          </PrimeButton>
        </div>
      </form>
    </template>
  </AuthCard>
</template>

================
File: apps/auth-service/pages/forgot-password.vue
================
<!-- /forgot-password -->

<script setup lang="ts">
// If you use PKCE (default), this link only works on the device or browser where the original reset request was made. Display a message to the user to make sure they don't change devices or browsers.

const form = reactive({
  email: '',
})

const auth = useAuth()

definePageMeta({
  name: 'ForgotPassword',
})
</script>

<template>
  <AuthCard
    :show-title="false"
    :title="{
      main: 'Request Magic Link',
      subtitle: 'Enter your email to get a reset link.',
    }"
  >
    <template #content>
      <div class="flex flex-col gap-4 xl:gap-6">
        <PrimeFloatLabel class="flex flex-col w-full">
          <PrimeInputText
            id="username"
            v-model="form.email"
          />
          <label for="username">Your Registered Email</label>
        </PrimeFloatLabel>
      </div>
    </template>
    <template #footer>
      <PrimeButton
        class="w-full flex justify-center"
        @click="auth.password.forgot(form.email)"
      >
        Request Reset Email
      </PrimeButton>
    </template>
  </AuthCard>
</template>

================
File: apps/auth-service/pages/index.vue
================
<script lang="ts" setup></script>

<template>
  <div> </div>
</template>

<style></style>

================
File: apps/auth-service/pages/login.vue
================
<script setup lang="ts">
const form = ref({
  email: '',
  password: '',
  rememberMe: false,
})

const auth = useAuth()
const currentUser = useCurrentUser()
const { haveUserSession } = storeToRefs(currentUser)
const turnstileValid = ref(false)
const turnstileToken = ref<string | null>(null)

// Modified login handler
const handleLogin = async () => {
  if (!turnstileValid.value) {
    // Show error message to user that captcha is required
    return
  }

  await auth.loginWithEmail(form.value.email, form.value.password, {
    turnstileToken: turnstileToken.value,
  })
}

const onValidTurnstile = (token: string) => {
  turnstileValid.value = true
  turnstileToken.value = token
}

definePageMeta({
  name: 'Login',
})
</script>

<template>
  <AuthCard
    :title="{
      main: 'Login to AstronEra',
      subtitle: 'Don\'t have an account?',
      label: 'Sign up',
    }"
    help-url="/register"
  >
    <template #title>
      <div v-if="haveUserSession">
        <AuthVerifiedWith class="w-full" />

        <div class="w-full pt-4">
          <PrimeDivider
            layout="horizontal"
            class="flex justify-left items-center"
          >
            <p>Or Login with</p>
          </PrimeDivider>
        </div>
      </div>
    </template>
    <template #content>
      <PrimeFloatLabel class="flex flex-col w-full">
        <PrimeInputText
          id="username"
          v-model="form.email"
        />
        <label for="username">Username</label>
      </PrimeFloatLabel>

      <PrimeFloatLabel class="flex flex-col w-full">
        <FormPassword
          v-model="form.password"
          :feedback="false"
        />
        <label for="password">Password</label>
      </PrimeFloatLabel>

      <div class="w-full py-2 flex justify-between">
        <!-- Remember me and forgot password section -->
      </div>

      <TurnstileChallenge
        class="mb-4"
        :onValidToken="onValidTurnstile"
      />

      <PrimeButton
        class="justify-center link"
        :disabled="!turnstileValid"
        @click="handleLogin"
      >
        Sign in with email
      </PrimeButton>
    </template>
    <template #footer>
      <AuthRegisterWith />
    </template>
  </AuthCard>
</template>

================
File: apps/auth-service/pages/register.vue
================
<script setup lang="ts">
const form = reactive({
  given_name: '',
  surname: '',
  email: '',
  password: '',
  confirmPassword: '',
})

const auth = useAuth()
const turnstileValid = ref(false)
const turnstileToken = ref<string | null>(null)

const isPasswordEntered = computed(() => {
  return !!form.password && !!form.confirmPassword
})

const isPasswordValid = computed(() => {
  return form.password === form.confirmPassword && !!form.password && !!form.confirmPassword
})

const isEmailValid = computed(() => {
  return form.email.includes('@') && form.email.includes('.')
})

const isFormValid = computed(() => {
  return (
    isPasswordValid.value &&
    isEmailValid.value &&
    !!form.given_name &&
    !!form.surname &&
    turnstileValid.value
  )
})

const handleRegister = async () => {
  if (!isFormValid.value) return

  await auth.registerWithEmail({
    ...form,
    turnstileToken: turnstileToken.value,
  })
}

const onValidTurnstile = (token: string) => {
  turnstileValid.value = true
  turnstileToken.value = token
}

definePageMeta({
  name: 'Register',
})
</script>

<template>
  <AuthCard
    :title="{
      main: 'Create an Account',
      subtitle: 'Already have an account?',
      label: 'Login',
    }"
    help-url="/login"
  >
    <template #content>
      <div class="flex flex-col gap-4">
        <div class="flex w-full gap-4">
          <PrimeFloatLabel class="flex w-full flex-col">
            <PrimeInputText
              id="given_name"
              v-model="form.given_name"
              :pt="{ root: 'w-full' }"
              :pt-options="{ mergeProps: true, mergeSections: true }"
            />
            <label for="given_name">Given Name</label>
          </PrimeFloatLabel>
          <PrimeFloatLabel class="flex w-full flex-col">
            <PrimeInputText
              id="surname"
              v-model="form.surname"
              :pt="{ root: 'w-full' }"
              :pt-options="{ mergeProps: true, mergeSections: true }"
            />
            <label for="surname">Surname</label>
          </PrimeFloatLabel>
        </div>
        <PrimeFloatLabel class="flex w-full flex-col">
          <PrimeInputText
            id="email"
            v-model="form.email"
          />
          <label for="email">Email</label>
        </PrimeFloatLabel>
        <FormPassword
          id="user-password"
          v-model="form.password"
          label="Enter your password"
        />
        <FormPassword
          id="confirm-password"
          v-model="form.confirmPassword!"
          label="Confirm password"
          :invalid="!isPasswordValid && isPasswordEntered"
          :feedback="false"
        />

        <TurnstileChallenge :on-valid-token="onValidTurnstile" />

        <PrimeButton
          class="justify-center"
          :disabled="!isFormValid"
          @click="handleRegister"
        >
          Sign up with email
        </PrimeButton>
        <PrimeMessage
          v-show="!isPasswordValid && isPasswordEntered"
          severity="error"
        >
          Passwords do not match
        </PrimeMessage>
      </div>
    </template>
    <template #footer>
      <AuthRegisterWith />
    </template>
  </AuthCard>
</template>

================
File: apps/auth-service/pages/reset-password.vue
================
<!-- pages/reset-password.vue -->
<script setup lang="ts">
const route = useRoute()
const auth = useAuth()
const toast = useNotification()

const form = reactive({
  password: '',
  confirmPassword: '',
})

// Get the hash fragment from the URL (Supabase includes the token here)
const hash = route.hash

onMounted(() => {
  // Verify the hash exists
  if (!hash) {
    toast.error({
      summary: 'Invalid Reset Link',
      message: 'This password reset link is invalid or has expired',
    })
    return
  }
})

async function handlePasswordReset() {
  if (form.password !== form.confirmPassword) {
    toast.error({
      summary: 'Passwords Do Not Match',
      message: 'Please ensure both passwords are identical',
    })
    return
  }

  try {
    // Update the password
    await auth.password.update(form.password)

    // Redirect to login
    navigateTo('/login', {
      replace: true,
      query: {
        message: 'Password successfully reset. Please log in with your new password.',
      },
    })
  } catch (error) {
    toast.error({
      summary: 'Reset Failed',
      message: 'Unable to reset password. Please try again.',
    })
  }
}
</script>

<template>
  <AuthCard
    title="Reset Password"
    subtitle="Enter your new password below"
  >
    <form @submit.prevent="handlePasswordReset">
      <div class="space-y-4">
        <PrimeFloatLabel>
          <PrimePassword
            v-model="form.password"
            :feedback="true"
            required
          />
          <label>New Password</label>
        </PrimeFloatLabel>

        <PrimeFloatLabel>
          <PrimePassword
            v-model="form.confirmPassword"
            required
          />
          <label>Confirm Password</label>
        </PrimeFloatLabel>

        <PrimeButton
          type="submit"
          class="w-full"
        >
          Reset Password
        </PrimeButton>
      </div>
    </form>
  </AuthCard>
</template>

================
File: apps/auth-service/pages/success.vue
================
<script setup lang="ts">
const userStore = useCurrentUser()
const { profile } = storeToRefs(userStore)

definePageMeta({
  name: 'Success',
})
</script>

<template>
  <PrimeCard>
    <template #title>
      <h2 class="text-primary-700 pb-2 text-3xl font-semibold"> SUCCESS! </h2>
    </template>
    <template #subtitle>
      <PrimeMessage
        severity="info"
        class="text-white"
      >
        Please confirm your email
      </PrimeMessage>
    </template>
    <template #content>
      <div class="pt-2">
        <p> Weâ€™ve sent a message to your email address: </p>
        <p>
          <strong>{{ profile?.email }}</strong>
        </p>
        <p> with a link to activate your account. </p>
        <div class="w-auto space-x-2 py-4">
          <PrimeTag>
            <a
              target="_blank"
              href="https://mail.google.com/mail/u/0/"
              rel="noopener noreferrer"
            >
              Open Gmail
            </a>
          </PrimeTag>
          <PrimeTag>
            <a
              target="_blank"
              href="https://outlook.live.com/mail/0/inbox"
              rel="noopener noreferrer"
            >
              Open Outlook
            </a>
          </PrimeTag>
        </div>
        <p>Didnâ€™t get an email? Please check your spam folder.</p>
        <p>
          Still nothing?
          <NuxtLink
            class="text-primary-500 underline"
            to="/forgot-password"
          >
            Request another.
          </NuxtLink>
        </p>
      </div>
    </template>
  </PrimeCard>
</template>

<style scoped></style>

================
File: apps/auth-service/server/routes/session.ts
================
export default defineEventHandler(async (event) => {
  try {
    console.log('FETCHING USER SESSION ON SERVER')
    const session = await validateAndUpdateSession()

    if (!session) {
      console.log('No user user session found')
      return {
        error: null,
        status: 200,
        message: 'No user session found',
        data: null,
      }
    }

    return {
      error: null,
      status: 200,
      message: 'User session fetched from session',
      data: session.user,
    }
  } catch (error: any) {
    console.error('session error', error.message)
    return {
      error,
      status: 500,
      message: error.message,
      data: null,
    }
  }
})

================
File: apps/auth-service/server/routes/signin.post.ts
================
export default defineEventHandler(async (event) => {
  if (authenticated) {
    setCookie(event, 'auth_token', token, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      maxAge: 60 * 60 * 24 * 7, // 1 week
      path: '/',
      domain: '.domain.com',
    })
  }
})

================
File: apps/auth-service/server/routes/validate-turnstile.post.ts
================
import { defineEventHandler, readBody } from 'h3'

export default defineEventHandler(async (event) => {
  const { token } = await readBody(event)
  const config = useRuntimeConfig()

  // Create form data for Turnstile verification
  const formData = new FormData()
  formData.append('secret', config.turnstileSecretKey)
  formData.append('response', token)

  // Optional: Add visitor's IP
  if (event.node.req.headers['cf-connecting-ip']) {
    formData.append('remoteip', event.node.req.headers['cf-connecting-ip'])
  }

  try {
    const result = await fetch('https://challenges.cloudflare.com/turnstile/v0/siteverify', {
      method: 'POST',
      body: formData,
    })

    const outcome = await result.json()
    return outcome
  } catch (error) {
    console.error('Error validating Turnstile token:', error)
    return {
      success: false,
      error: 'Failed to validate token',
    }
  }
})

================
File: apps/auth-service/server/utils/getUserSession.ts
================
import { getCurrentSecret } from './secretManager'
import { serverSupabaseSession, serverSupabaseClient } from '#supabase/server'

async function fetchPermissions(userPlan: string, userRole: string) {
  const event = useEvent()
  try {
    const supabase = await serverSupabaseClient(event)
    console.log('fetching permissions for: ', userPlan, userRole)
    const { data: planPermissions, error: planError } = await supabase
      .from('plan_permissions')
      .select('*')
      .eq('plan', userPlan)

    const { data: rolePermissions, error: roleError } = await supabase
      .from('role_permissions')
      .select('*')
      .eq('role', userRole)

    if (roleError || planError) {
      console.error('error fetching permission', roleError, planError)
    }

    return {
      role: rolePermissions,
      plan: planPermissions,
    }
  } catch (error: any) {
    console.error('Error fetching permissions:', error.message)
    return null // Return null to indicate failure
  }
}

async function getSession() {
  const event = useEvent()
  const session = await serverSupabaseSession(event)
  return session
}

interface StoredSession {
  refresh_token: string
  expires_at: number
  user: any
}

type Operation = 'select' | 'update' | 'insert' | 'delete'

interface Permission {
  role: string
  table_name: string
  conditions: any
  permissions: Operation[]
}

interface StoredPermissions {
  refresh_token: string
  expires_at: number
  user: {
    email: string | undefined
    auth_role: string | undefined
    confirmation_sent_at: string | undefined
    confirmed_at: string | undefined
    provider: string | undefined
    providers: string[]
    identities: string[] | undefined
    avatar: string | undefined
    full_name: string
    given_name: string
    surname: string
    username: string
    user_id: string
    user_role: string
    user_plan: string
  }
  plan_permissions: Permission[] | undefined
  role_permissions: Permission[] | undefined
}

export async function validateAndUpdateSession() {
  const session = await getSession()
  if (!session) {
    return
  }

  const { user, refresh_token } = session
  if (!user || !refresh_token) {
    throw createError({
      message: `user: ${user.id} or refresh_token: ${refresh_token.length} undefined in session`,
    })
  }

  // SESSION
  const storage = useStorage('session')
  const secretKey = getCurrentSecret()
  const storageKey = `${user.id}:${secretKey}`

  // PERMISSIONS
  const storedPermissions = await storage.getItem<StoredPermissions>(`permissions:${storageKey}`)
  if (
    !storedPermissions ||
    storedPermissions.expires_at < Date.now() ||
    storedPermissions.refresh_token !== refresh_token
  ) {
    const { role: user_role, plan: user_plan } = user.app_metadata

    if (!user_role || !user_plan) {
      throw createError({
        message: `missing user_role: ${user_role} or user_plan: ${user_plan}, unable to fetch user permissions`,
      })

      // redirect to login page
      // clear the cookies
    }

    const permissions = await fetchPermissions(user_plan, user_role)

    if (!permissions) {
      console.error('Failed to fetch new permissions')
      return
    }

    await storage.setItem<StoredPermissions>(`permissions:${storageKey}`, {
      refresh_token,
      expires_at: Date.now() + 60 * 60 * 24 * 7 * 1000, // 1 week in milliseconds
      user: {
        ...user,
        user_id: user.id,
        user_role,
        user_plan,
        email: user.email,
        auth_role: user.role,
        confirmation_sent_at: user.confirmation_sent_at,
        confirmed_at: user.confirmed_at,
        provider: user.app_metadata.provider,
        providers: user.app_metadata.providers,
        identities: user.identities,
        // avatar: formatAvatarUrl({ avatar: user.user_metadata.avatar, id: user.id }),
        full_name: user.user_metadata.full_name,
        given_name: user.user_metadata.given_name ?? user.user_metadata.given_name,
        surname: user.user_metadata.surname ?? user.user_metadata.surname,
        username: user.user_metadata.username,
      },
      plan_permissions: permissions.plan,
      role_permissions: permissions.role,
    })
  } else {
    console.log('Current permissions are valid and do not need updates.')
  }

  return await storage.getItem<StoredPermissions>(`permissions:${storageKey}`)
}

export async function removeSession() {
  const event = useEvent()
  const userId = getRequestHeader(event, 'X-USER-ID')
  const storage = useStorage('session')
  const secretKey = getCurrentSecret()
  const storageKey = `${userId}:${secretKey}`

  console.log('removing session', storageKey)
  await storage.removeItem(`permissions:${storageKey}`)
}

export async function getUserRolePlan() {
  const event = useEvent()
  const userId = getRequestHeader(event, 'X-USER-ID')
  const secretKey = getCurrentSecret()
  const storageKey = `${userId}:${secretKey}`

  console.log('getting user role plan', storageKey)
  const storage = useStorage('session')

  return await storage.getItem<StoredSession>(`user:${storageKey}`)
}

export async function getUserPermissions() {
  const event = useEvent()
  const userId = getRequestHeader(event, 'X-USER-ID')
  const secretKey = getCurrentSecret()
  const storageKey = `${userId}:${secretKey}`

  console.log('getting user permissions', storageKey)
  const storage = useStorage('session')

  return await storage.getItem<StoredPermissions>(`permissions:${storageKey}`)
}

// these belong somewhere else

export async function hasDBPermission(
  tableName: string,
  operation: 'select' | 'update' | 'insert' | 'delete',
): Promise<boolean> {
  const permissions = await getUserPermissions()

  if (!permissions?.role_permissions) {
    console.log('no role permissions found')
    return false
  }

  const tablePermissions = permissions.role_permissions.find(
    (item) => item.table_name === tableName,
  )

  if (!tablePermissions) {
    throw createError({
      message: `${tableName} is not a valid table_name`,
    })
  }

  return tablePermissions.permissions.includes(operation)
}

export async function hasFeaturePermission(
  feature: string,
  action: 'select' | 'update' | 'insert' | 'delete',
): Promise<boolean> {
  const permissions = await getUserPermissions()

  if (!permissions?.plan_permissions) {
    console.log('no plan permissions found')
    return false
  }

  const featurePermissions = permissions.plan_permissions.find((item) => item.feature === feature)

  if (!featurePermissions) {
    throw createError({
      message: `${feature} is not a valid feature name`,
    })
  }

  return featurePermissions[action]
}

================
File: apps/auth-service/server/utils/secretManager.ts
================
import * as uuid from 'uuid'

class SecretManager {
  private currentSecret: string
  private previousSecret: string
  private rotationInterval: number

  constructor() {
    this.currentSecret = this.generateSecret()
    this.previousSecret = this.currentSecret // Initially, they are the same
    this.rotationInterval = 604800000 // Rotate weekly, in milliseconds
    setInterval(() => this.rotateSecret(), this.rotationInterval)
  }

  private generateSecret(): string {
    return uuid.v4()
  }

  private rotateSecret() {
    this.previousSecret = this.currentSecret // Update previous secret
    this.currentSecret = this.generateSecret()
    console.log('Secret rotated')
  }

  getSecret() {
    return this.currentSecret
  }

  getPreviousSecret() {
    return this.previousSecret
  }
}

const secretManager = new SecretManager()

export function getCurrentSecret() {
  return secretManager.getSecret()
}

export function getPreviousSecret() {
  return secretManager.getPreviousSecret()
}

================
File: apps/auth-service/.npmrc
================
shamefully-hoist=true
strict-peer-dependencies=false

================
File: apps/auth-service/app.vue
================
<template>
  <div class="h-full w-full">
    <NuxtLoadingIndicator />
    <NuxtLayout>
      <NuxtPage />
    </NuxtLayout>
    <PrimeToast position="bottom-right" />
  </div>
</template>

<style>
html {
  margin: 0;
  padding: 0;
}

#__nuxt {
  width: 100%;
  height: 100%;
  padding: 0;
  margin: 0;
}

.layout-enter-active,
.layout-leave-active {
  transition: all 0.4s;
}

.layout-enter-from,
.layout-leave-to {
  opacity: 0;
  filter: blur(1rem);
}
</style>

================
File: apps/auth-service/Dockerfile
================
# Use Node.js 20.17.0 as the base image
FROM node:20.17.0

# Set the working directory in the container
WORKDIR /app

# Copy package.json and package-lock.json
COPY package*.json ./
COPY package-lock.json ./

# Install dependencies
RUN npm ci

# Copy the entire project, including configuration files
COPY . .

# List contents to verify files are copied correctly
RUN ls -la && ls -la apps/auth-service

RUN npm install -g nx

RUN npx nx reset
RUN npx nx --version

# Build the auth-service
RUN nx build auth-service --verbose --skip-nx-cache

# Set the working directory to the auth-service output
WORKDIR /app/apps/auth-service/.output

# Command to run the application
CMD ["node", "server/index.mjs"]

# Expose the port the app runs on
EXPOSE 3000

================
File: apps/auth-service/example-env
================
SUPABASE_URL=""
SUPABASE_SERVICE_ROLE_KEY=""
SUPABASE_ANON_KEY=""

================
File: apps/auth-service/nuxt.config.ts
================
import { fileURLToPath } from 'url'
import { dirname, join, resolve } from 'path'
import { defineNuxtConfig } from 'nuxt/config'
import runtimeConfig from '../../shared-runtime.config'

const currentDir = dirname(fileURLToPath(import.meta.url))

export default defineNuxtConfig({
  workspaceDir: '../../',
  srcDir: '.',
  extends: ['../../layers/base', '../../layers/auth', '../../layers/crud'],
  build: {
    transpile: ['../../layers/base', '../../layers/auth', '../../layers/crud'],
  },
  modules: [
    '@nuxt/devtools',
    '@vueuse/nuxt',
    '@nuxt/image',
    '@pinia/nuxt',
    '@nuxt/icon',
    '@nuxt/eslint',
    '@nuxtjs/tailwindcss',
    '@primevue/nuxt-module',
  ],

  devServer: {
    host: 'localhost',
    port: 3009,
  },

  ssr: false,

  primevue: {
    importPT: { from: resolve(currentDir, '../../theme/index.js') },
    autoImport: true,
    components: {
      prefix: 'Prime',
      include: '*',
      exclude: ['Editor'],
    },

    composables: {
      include: '*',
    },

    options: {
      ripple: true,
      unstyled: true,
      theme: {
        options: {
          cssLayer: {
            name: 'primevue',
            order: 'tailwind-base, primevue, tailwind-utilities',
          },
        },
      },
    },
  },

  routeRules: {
    '/': { redirect: '/login' },
  },

  compatibilityDate: '2024-10-03',

  ...runtimeConfig,
})

================
File: apps/auth-service/tailwind.config.ts
================
import { fileURLToPath } from 'url'
import { dirname, resolve } from 'path'
import type { Config } from 'tailwindcss'

const currentDir = dirname(fileURLToPath(import.meta.url))

const config: Partial<Config> = {
  presets: [require('../../tailwind.config.base')],
  theme: {
    extend: {
      // Add app-specific extensions here
    },
  },
  content: [resolve(currentDir, '**/*.{js,vue,ts}'), '../../theme/**/*.{js,css,ts}'],
}

export default config

================
File: apps/main-app/components/bookmark/BookmarkCard.vue
================
<script setup lang="ts">
import { useTimeAgo } from '@vueuse/core'
import type { BaseBookmark } from '~/types/bookmark'

interface Props {
  bookmark: BaseBookmark
  selectable?: boolean
  isSelected?: boolean
}

const props = defineProps<Props>()
defineEmits<{
  (e: 'select', id: string): void
}>()

console.log('BookmarkCard props', props)

const bookmarkStore = useBookmarkStore()

const isBookmarked = computed(() =>
bookmarkStore.isBookmarked(props.bookmark.content_id, props.bookmark.content_type),
)

const handleBookmark = async () => {
  try {
    await bookmarkStore.toggleBookmark({
      id: props.bookmark.content_id,
      type: props.bookmark.content_type,
      title: props.bookmark.metadata.title,
      url: props.bookmark.metadata.url,
      description: props.bookmark.metadata.description,
      thumbnail: props.bookmark.metadata.featured_image,
      author: props.bookmark.metadata.author,
    })
  } catch (error) {
    console.error('Error handling bookmark:', error)
  }
}

const handleDoiClick = () => {
  if (props.bookmark.metadata.doi_url) {
    window.open(props.bookmark.metadata.doi_url, '_blank', 'noopener,noreferrer')
  }
}

const contentTypeIcon = computed(() => {
  switch (props.bookmark.content_type) {
    case 'news':
      return 'mdi:newspaper'
    case 'research':
      return 'mdi:file-document'
    case 'newsletters':
      return 'mdi:email-newsletter'
    case 'companies':
      return 'mdi:domain'
    default:
      return 'mdi:bookmark'
  }
})
</script>

<template>
  <div class="rounded-lg relative border border-color w-full h-full">
    <div
      v-if="selectable"
      class="absolute w-full h-10 inset-0 z-10 flex items-start justify-end p-2 bg-black/5"
      :class="[isSelected ? 'opacity-100' : 'opacity-0 group-hover:opacity-100 transition-opacity']"
    >
      <PrimeCheckbox
        :model-value="isSelected"
        :binary="true"
        @update:model-value="$emit('select', bookmark.id)"
      />
    </div>

    <div
      class="p-4 flex flex-col justify-between h-full"
      :class="{ 'opacity-75': isSelected }"
    >
      <!-- Header -->
      <div>
        <div class="flex items-center justify-between mb-2">
          <div class="flex items-center gap-2">
            <Icon
              :name="contentTypeIcon"
              size="20px"
              class="text-primary-500"
            />
            <span class="text-sm capitalize">{{ bookmark.content_type }}</span>
          </div>
          <span class="text-sm text-gray-500">{{
            useTimeAgo(bookmark.metadata.published_at || bookmark.created_at).value
          }}</span>
        </div>

        <h2 class="text-xl font-bold mb-2">{{ bookmark.metadata.title }}</h2>

        <!-- Additional metadata -->
        <div
          v-if="
            bookmark.metadata.author || bookmark.metadata.published_in || bookmark.metadata.category
          "
          class="flex items-center text-sm mb-4 text-gray-500"
        >
          <template v-if="bookmark.metadata.author">
            <span>{{ bookmark.metadata.author }}</span>
          </template>
          <template v-if="bookmark.metadata.published_in">
            <span>{{ bookmark.metadata.published_in }}</span>
          </template>
          <template v-if="bookmark.metadata.category">
            <span>{{ bookmark.metadata.category }}</span>
          </template>
        </div>
      </div>

      <!-- Body -->
      <div>
        <div
          v-if="bookmark.metadata.featured_image"
          class="mb-4"
        >
          <NuxtImg
            :provider="bookmark.metadata.featured_image ? 'supabase' : undefined"
            :src="bookmark.metadata.featured_image || 'fallback-image.jpg'"
            :alt="bookmark.metadata.title"
            class="w-full h-auto rounded-lg"
            width="400"
            height="200"
          />
        </div>

        <p
          v-if="bookmark.metadata.description"
          class="text-sm text-gray-600 mb-4 line-clamp-3"
        >
          {{ bookmark.metadata.description }}
        </p>

        <!-- Actions -->
        <div class="flex items-center justify-between">
          <div class="flex items-center gap-4">
            <Icon
              v-if="bookmark.metadata.doi_url"
              name="mdi:file-document-outline"
              size="20px"
              class="text-gray-500 hover:text-gray-700 cursor-pointer"
              @click="handleDoiClick"
            />
            <span
              v-if="bookmark.metadata.score"
              class="text-sm text-gray-500"
            >
              Score: {{ bookmark.metadata.score }}
            </span>
          </div>
          <div class="flex items-center gap-4">
            <button
              class="hover:text-gray-600"
              @click="handleBookmark"
            >
              <Icon
                :name="isBookmarked ? 'mdi:bookmark' : 'mdi:bookmark-outline'"
                size="20px"
                :class="{ 'text-primary-500': isBookmarked }"
              />
            </button>
            <NuxtLink
              :to="bookmark.metadata.url"
              target="_blank"
              rel="noopener noreferrer nofollow"
              class="hover:text-gray-600"
            >
              <Icon
                name="mdi:link-variant"
                size="20px"
              />
            </NuxtLink>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>

================
File: apps/main-app/components/nav/NavAppTop.vue
================
<script setup lang="ts">
const router = useRouter()
const userStore = useCurrentUser()
const toast = useNotification()
const supabase = useSupabaseClient()
const { profile, isAdmin } = storeToRefs(userStore)
const { adminUrl, loginURL, authURL } = useRuntimeConfig().public

const profileMenu = ref(null)
const toggleMenu = (e) => {
  profileMenu.value?.toggle(e)
}

const items = computed(() => {
  const menuItems = [
    {
      label: 'Settings',
      command: () => router.push('/settings/account'), // Updated from '/settings/profile'
    },
    {
      label: 'Logout',
      command: signOut,
    },
  ]

  if (isAdmin.value) {
    menuItems.splice(2, 0, {
      label: 'Admin',
      command: () => navigateTo(adminUrl, { external: true }),
    })
  }

  return menuItems
})

const signOut = async () => {
  const { error } = await supabase.auth.signOut()

  if (error) {
    console.error(error.message)
    toast.error({ summary: 'Could not log out', message: error.message })
  } else {
    return navigateTo(String(`${authURL}${loginURL}`), { external: true })
  }
}

const loading = useLoadingStore()
const isLoading = computed(() => loading.isLoading('currentUser'))

const avatarUrl = ref(null)
const fallbackLoaded = ref(false)

// Generate fallback avatar URL using UI Avatars
const getFallbackAvatarUrl = (name: string) => {
  const initials =
    name
      ?.split(' ')
      .map((word) => word[0])
      .join('')
      .toUpperCase() || 'U'
  return `https://ui-avatars.com/api/?name=${initials}&background=random&size=128`
}

watch(
  profile,
  (newProfile) => {
    if (newProfile?.avatar) {
      avatarUrl.value = newProfile.avatar
      fallbackLoaded.value = false
    } else {
      // Use name from profile for the fallback avatar, or default to 'User'
      avatarUrl.value = getFallbackAvatarUrl(newProfile?.full_name || 'User')
      fallbackLoaded.value = true
    }
  },
  { immediate: true },
)

const handleImageError = () => {
  if (!fallbackLoaded.value) {
    // Only load fallback if we haven't already tried
    avatarUrl.value = getFallbackAvatarUrl(profile.value?.full_name || 'User')
    fallbackLoaded.value = true
  }
  console.log('Avatar image load error, using fallback')
}
</script>

<template>
  <div
    class="foreground border-color sticky left-0 top-0 z-50 flex min-h-[60px] w-full flex-row items-center justify-between gap-4 border-b px-4 py-1"
  >
    <!-- start -->
    <div class="flex items-center gap-4">
      <IBNavHamburger />
      <IBBreadcrumbs class="hidden text-sm lg:block" />
    </div>
    <!-- center -->
    <div class="flex w-full max-w-[70%] gap-4 px-4 py-2 lg:max-w-xl" />
    <!-- end -->
    <ClientOnly>
      <div
        v-if="isLoading || !profile?.user_role"
        class="flex items-center justify-end gap-4"
      >
        <PrimeSkeleton class="min-h-4 min-w-10 rounded-md" />
        <PrimeSkeleton
          :pt="{
            root: 'min-w-10 min-h-10 rounded-full',
          }"
        />
      </div>
      <div
        v-else-if="profile?.user_role"
        class="flex items-center justify-center gap-4"
      >
        <PrimeTag v-if="profile.user_role">
          {{ profile.user_role }}
        </PrimeTag>
        <PrimeAvatar
          v-if="avatarUrl"
          :image="avatarUrl"
          size="normal"
          shape="circle"
          class="cursor-pointer"
          aria-haspopup="true"
          aria-controls="overlay_menu"
          @error="handleImageError"
          @click="toggleMenu"
        />
        <PrimeMenu
          id="overlay_menu"
          ref="profileMenu"
          :model="items"
          :popup="true"
        />
      </div>
    </ClientOnly>
  </div>
</template>

================
File: apps/main-app/components/news/NewsCard.vue
================
<script setup lang="ts">
import { useTimeAgo } from '@vueuse/core'
import { ref, onMounted } from 'vue'

export interface Company {
  id: string
  name: string
  logo_url?: string
}

export interface NewsCardT {
  id: string
  title: string
  description: string
  author: string
  published_at?: string
  featured_image: string
  created_at: string
  url: string
  comments: number
  score?: number
  company_id?: string
  companies?: Company
}

interface Props {
  news: NewsCardT
}

const props = defineProps<Props>()
const voteStore = useVoteStore()
const isFlipped = ref(false)

const showModal = ref(false)
const modalContent = ref('')
const currentVote = ref<number | null>(null)
const score = ref(props.news.score || 0)

const bookmarkStore = useBookmarkStore()
const bookmarked = computed(() => bookmarkStore.isBookmarked(props.news.id))

const folderStore = useFolderStore()

const handleBookmark = async () => {
  const folder = folderStore.getDefaultFolder

  console.log('Bookmarking news:', props.news.id, folder.id)
  try {
    await bookmarkStore.toggleBookmark({
      id: props.news.id,
      type: 'news',
      title: props.news.title,
      thumbnail: props.news.featured_image,
      url: props.news.url,
      author: props.news.author,
      folder_id: folder.id,
    })
  } catch (error) {
    console.error('Error handling bookmark:', error)
  }
}

const displayScore = computed(() => {
  const currentScore = voteStore.getScore(props.news.id) ?? score.value

  // Only show negative numbers if user has downvoted
  if (currentScore < 0 && currentVote.value !== -1) {
    return 0
  }
  return currentScore
})

const sourceDisplay = computed(() => {
  const company = props.news.companies
  const author = props.news.author

  if (company?.name && author) {
    return `${author} â€¢ ${company.name}`
  } else if (company?.name) {
    return company.name
  } else if (author) {
    return author
  }
  return 'Unknown source'
})

const formatSourceName = (name: string) => {
  // Remove common suffixes like .com, .org, etc. (we might need them for things like space.com, astronomy.com etc)
  // .replace(/\.(com|org|net|io|ai)$/, '')
  return name
}

const readTime = computed(() => {
  // Calculate read time based on content length
  // This is a placeholder, replace with actual logic
  return '2m read time'
})

onMounted(async () => {
  try {
    if (voteStore.getScore(props.news.id) == null)
      voteStore.setVotes(props.news.id, props.news.score || 0)
  } catch (error) {
    console.error('Error fetching vote status:', error)
  }
})

const handleVoteChange = ({ change }: { voteType: number | null; change: number }) => {
  score.value += change
}

const openModal = (feature: string) => {
  modalContent.value = `The ${feature} feature is coming soon! Stay tuned for updates.`
  showModal.value = true
}

const imageSource = computed(() => {
  if (props.news.featured_image) {
    return props.news.featured_image
  }
  // You can choose either random or deterministic fallbacks
  // return getRandomFallbackImage() // Random each time
  return 'fallback.jpg'
})

// Handle clicks for touch devices
const handleClick = (event: MouseEvent) => {
  const target = event.target as HTMLElement
  if (target.closest('a') || target.closest('button')) {
    event.stopPropagation()
    return
  }
  isFlipped.value = !isFlipped.value
}

// Handle hover states
const handleMouseEnter = () => {
  isFlipped.value = true
}

const handleMouseLeave = () => {
  isFlipped.value = false
}

// METRICS
const { trackNewsVisit } = useUserMetricsStore()
let cleanupVisit: (() => Promise<void>) | null = null

// Track when user visits source
const handleSourceVisit = async () => {
  cleanupVisit = await trackNewsVisit(props.news.id)
}

// Clean up when component is unmounted
onBeforeUnmount(async () => {
  if (cleanupVisit) {
    await cleanupVisit()
  }
})
</script>

<template>
  <div
    class="group relative h-[450px] perspective-1000 hover:cursor-pointer"
    @click="handleClick"
    @mouseenter="handleMouseEnter"
    @mouseleave="handleMouseLeave"
  >
    <div
      class="relative w-full h-full transition-transform duration-500 transform-style-preserve-3d border border-color rounded-lg"
      :class="{ 'rotate-y-180': isFlipped }"
    >
      <!-- Front of card -->
      <div class="absolute w-full h-full backface-hidden">
        <div class="p-4 flex flex-col justify-between h-full">
          <div>
            <div class="flex items-center gap-2 mb-2">
              <!-- Company logo or random image -->
              <div class="flex-shrink-0 w-6 h-6 rounded-full overflow-hidden">
                <NuxtImg
                  :src="news.companies?.logo_url ?? `https://picsum.photos/24/24?random=${news.id}`"
                  alt="Source"
                  class="w-full h-full object-cover"
                  width="24"
                  height="24"
                />
              </div>
              <!-- Source and author info -->
              <div class="flex flex-col min-w-0">
                <span
                  v-if="news.companies?.name"
                  class="font-medium text-sm truncate"
                >
                  {{ formatSourceName(news.companies.name) }}
                </span>
                <span
                  v-if="news.author"
                  class="text-xs text-gray-400 truncate"
                >
                  {{ news.author }}
                </span>
              </div>
            </div>
            <h3
              class="text-xl font-bold mb-2 line-clamp-3 min-h-[3.5rem]"
              :title="news.title"
            >
              {{ news.title }}
            </h3>
            <div class="flex items-center text-sm mb-4">
              {{ useTimeAgo(new Date(news.published_at ?? news.created_at)).value }}
              <span class="mx-2">â€¢</span>
              <span>{{ readTime }}</span>
            </div>
          </div>
          <div>
            <div class="mb-4">
              <div class="relative w-full pb-[56.25%]">
                <NuxtImg
                  :provider="news.featured_image ? 'supabase' : undefined"
                  :src="imageSource"
                  :alt="news.title"
                  class="absolute inset-0 w-full h-full object-cover rounded-lg"
                  sizes="sm:100vw md:50vw lg:400px"
                />
              </div>
            </div>
            <div class="flex items-center justify-between">
              <div class="flex items-center gap-4">
                <div class="flex items-center justify-center bg-primary-950 py-1 px-2 rounded-xl">
                  <VoteButton
                    :content-id="news.id"
                    direction="up"
                    card-side="front"
                    :initial-vote-type="currentVote"
                    @vote-change="handleVoteChange"
                  />
                  <span class="text-sm font-medium pl-1 pr-2">{{ displayScore }}</span>
                  <VoteButton
                    :content-id="`${news.id}-front-down`"
                    direction="down"
                    card-side="front"
                    :initial-vote-type="currentVote"
                    @vote-change="handleVoteChange"
                  />
                </div>
                <button
                  class="flex items-center gap-2 justify-center text-sm hover:text-primary-600"
                  @click="openModal('Comments')"
                >
                  <Icon
                    name="mdi:comment-outline"
                    size="20px"
                  />
                </button>
              </div>
              <div class="flex items-center justify-center gap-4">
                <button
                  class="hover:text-primary-600 flex items-center justify-center h-full"
                  @click="handleBookmark"
                >
                  <Icon
                    :name="bookmarked ? 'mdi:bookmark' : 'mdi:bookmark-outline'"
                    size="20px"
                    :class="{ 'text-primary-500': bookmarked }"
                  />
                </button>
                <NuxtLink
                  :to="news.url"
                  target="_blank"
                  rel="noopener noreferrer nofollow"
                  class="hover:text-primary-600"
                  @click="handleSourceVisit"
                >
                  <Icon
                    name="mdi:link-variant"
                    size="20px"
                  />
                </NuxtLink>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Back of card -->
      <div
        class="absolute w-full h-full backface-hidden rotate-y-180 bg-primary-950 rounded-lg p-4 flex flex-col"
      >
        <!-- Back side content -->
        <div class="flex-grow overflow-hidden flex flex-col">
          <h3
            class="text-xl font-bold mb-4 line-clamp-3 min-h-[3.5rem]"
            :title="news.title"
          >
            {{ news.title }}</h3
          >
          <p class="text-base overflow-y-auto flex-grow">{{ news.description }}</p>
        </div>

        <!-- Back side actions -->
        <div class="flex items-center justify-between border-t border-primary-900 pt-4">
          <div class="flex items-center gap-4">
            <div class="flex items-center justify-center bg-primary-900 py-1 px-2 rounded-xl">
              <VoteButton
                :content-id="news.id"
                direction="up"
                card-side="back"
                :initial-vote-type="currentVote"
                @vote-change="handleVoteChange"
              />
              <span class="text-sm font-medium pl-1 pr-2">{{ displayScore }}</span>
              <VoteButton
                :content-id="news.id"
                direction="down"
                card-side="back"
                :initial-vote-type="currentVote"
                @vote-change="handleVoteChange"
              />
            </div>
            <button
              class="flex items-center hover:text-primary-600"
              @click="openModal('Comments')"
            >
              <Icon
                name="mdi:comment-outline"
                size="20px"
              />
              <span>{{ news.comments }}</span>
            </button>
          </div>
          <div class="flex items-center gap-2 justify-center">
            <button
              class="hover:text-primary-600"
              @click="handleBookmark"
            >
              <Icon
                :name="bookmarked ? 'mdi:bookmark' : 'mdi:bookmark-outline'"
                size="20px"
                :class="{ 'text-primary-500': bookmarked }"
              />
            </button>
            <NuxtLink
              :to="news.url"
              target="_blank"
              rel="noopener noreferrer nofollow"
              class="flex items-center gap-1.5 group p-1 rounded-full bg-primary-500"
              @click="handleSourceVisit"
            >
              <Icon
                name="mdi:link-variant"
                size="20px"
              />
            </NuxtLink>
          </div>
        </div>
      </div>
    </div>
  </div>

  <PrimeDialog
    v-model:visible="showModal"
    modal
    header="Coming Soon"
    :style="{ width: '50vw' }"
  >
    <p>{{ modalContent }}</p>
  </PrimeDialog>
</template>

<style scoped>
.perspective-1000 {
  perspective: 1000px;
}

.transform-style-preserve-3d {
  transform-style: preserve-3d;
}

.backface-hidden {
  backface-visibility: hidden;
}

.rotate-y-180 {
  transform: rotateY(180deg);
}

/* Optional: Add a smooth transition for the hover effect */
.transition-transform {
  transition-property: transform;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 500ms;
}

/* Optional: Add hover state styles */
@media (hover: hover) {
  .hover\:cursor-pointer:hover {
    cursor: pointer;
  }
}
</style>

================
File: apps/main-app/components/settings/2FA.vue
================
<script setup lang="ts">
import { ref, computed } from 'vue'
import QRCode from 'qrcode'

const supabase = useSupabaseClient()
const toast = useNotification()

const currentUser = useCurrentUser()
const { profile } = storeToRefs(currentUser)

const loading = ref(false)
const setupStep = ref<'initial' | 'qr' | 'verify'>('initial')
const qrCodeUrl = ref('')
const verificationCode = ref('')
const factorId = ref('')
const secret = ref('')

const isVerifying = ref(false)
const setupError = ref('')

// Keep track of enrolled factors
const enrolledFactors = ref<any[]>([])

// Check if 2FA is already set up
async function checkExistingFactors() {
  try {
    loading.value = true
    const { data, error } = await supabase.auth.mfa.listFactors()

    if (error) throw error

    enrolledFactors.value = data.totp
  } catch (error) {
    toast.error({
      summary: 'Error',
      message: 'Could not fetch 2FA status',
    })
  } finally {
    loading.value = false
  }
}

const showSetupModal = ref(false) // New ref for controlling modal visibility
const factorName = ref(`AstronEra_${profile.value?.id}`) // Default name
const nameError = ref('')

// Modified startSetup to include validation
async function startSetup() {
  try {
    if (!factorName.value.trim()) {
      nameError.value = 'Please provide a name for this authenticator'
      return
    }

    loading.value = true
    setupError.value = ''
    nameError.value = ''

    const { data, error } = await supabase.auth.mfa.enroll({
      factorType: 'totp',
      issuer: 'AstronEra', // Add your app name here
      friendlyName: factorName.value.trim(),
    })

    if (error) throw error

    if (data.type === 'phone') {
      throw new Error('Phone enrollment is not supported')
    }

    // Generate QR code
    factorId.value = data.id
    secret.value = data.totp.secret

    const qrCode = await QRCode.toDataURL(data.totp.uri)
    qrCodeUrl.value = qrCode

    setupStep.value = 'qr'
  } catch (error: any) {
    setupError.value = 'Failed to start 2FA setup. Please try again.'
    toast.error({
      summary: 'Setup Failed',
      message: error.message || 'Could not start 2FA setup',
    })
  } finally {
    loading.value = false
  }
}

// Reset form should also clear the factor name
function resetForm() {
  setupStep.value = 'initial'
  verificationCode.value = ''
  qrCodeUrl.value = ''
  factorId.value = ''
  secret.value = ''
  setupError.value = ''
  factorName.value = ''
  nameError.value = ''
}

// Verify the setup
async function verifySetup() {
  try {
    isVerifying.value = true
    setupError.value = ''

    if (!verificationCode.value) {
      throw new Error('Please enter verification code')
    }

    const { data, error } = await supabase.auth.mfa.challenge({
      factorId: factorId.value,
    })

    if (error) throw error

    // Verify the challenge
    const { error: verifyError } = await supabase.auth.mfa.verify({
      factorId: factorId.value,
      challengeId: data.id,
      code: verificationCode.value,
    })

    if (verifyError) throw verifyError

    toast.success({
      summary: '2FA Enabled',
      message: 'Two-factor authentication has been successfully enabled',
    })

    // Reset the form and refresh factors
    await checkExistingFactors()
    resetForm()
    showSetupModal.value = false
  } catch (error: any) {
    setupError.value = error.message || 'Invalid verification code'
    toast.error({
      summary: 'Verification Failed',
      message: error.message || 'Could not verify 2FA setup',
    })
  } finally {
    isVerifying.value = false
  }
}

async function startEnrollment() {
  try {
    loading.value = true
    setupError.value = ''

    const { data, error } = await supabase.auth.mfa.enroll({
      factorType: 'totp',
      issuer: 'AstronEra',
      friendlyName: factorName.value,
    })

    if (error) throw error

    // Generate QR code
    factorId.value = data.id
    secret.value = data.totp.secret

    const qrCode = await QRCode.toDataURL(data.totp.uri)
    qrCodeUrl.value = qrCode

    setupStep.value = 'qr'
  } catch (error: any) {
    setupError.value = 'Failed to start 2FA setup. Please try again.'
    toast.error({
      summary: 'Setup Failed',
      message: error.message || 'Could not start 2FA setup',
    })
  } finally {
    loading.value = false
  }
}

// Disable 2FA
async function disableTwoFactor(factorId: string) {
  try {
    loading.value = true

    const { error } = await supabase.auth.mfa.unenroll({
      factorId,
    })

    if (error) throw error

    toast.success({
      summary: '2FA Disabled',
      message: 'Two-factor authentication has been disabled',
    })

    await checkExistingFactors()
  } catch (error: any) {
    toast.error({
      summary: 'Error',
      message: error.message || 'Could not disable 2FA',
    })
  } finally {
    loading.value = false
  }
}

const has2FAEnabled = computed(() => enrolledFactors.value.length > 0)

// Load existing factors on mount
onMounted(() => {
  checkExistingFactors()
})
</script>

<template>
  <div>
    <div class="flex items-center justify-between rounded-lg bg-black/20 p-4">
      <div class="flex items-center gap-3">
        <div class="flex h-10 w-10 items-center justify-center rounded-full bg-warning-500/10">
          <Icon
            name="mdi:shield-lock"
            class="text-xl text-warning-500"
          />
        </div>
        <div>
          <h3 class="font-medium">Two-Step Verification</h3>
          <p class="text-sm text-gray-400">
            {{ has2FAEnabled ? 'Enabled' : 'Not configured' }}
          </p>
        </div>
      </div>

      <div
        v-if="loading"
        class="flex items-center"
      >
        <PrimeProgressSpinner style="width: 20px; height: 20px" />
      </div>
      <template v-else>
        <PrimeButton
          v-if="!has2FAEnabled"
          severity="secondary"
          size="small"
          @click="showSetupModal = true"
        >
          Configure
        </PrimeButton>
        <PrimeButton
          v-else
          severity="danger"
          size="small"
          @click="disableTwoFactor(enrolledFactors[0].id)"
        >
          Disable
        </PrimeButton>
      </template>
    </div>

    <!-- Setup Modal -->
    <PrimeDialog
      v-model:visible="showSetupModal"
      modal
      header="Set up two-step verification"
      :closable="!isVerifying"
      @update:visible="(value) => !value && resetForm()"
    >
      <div
        v-if="setupError"
        class="mb-4"
      >
        <PrimeMessage
          severity="error"
          :closable="false"
        >
          {{ setupError }}
        </PrimeMessage>
      </div>

      <div class="space-y-6">
        <!-- Initial Welcome Screen -->
        <template v-if="setupStep === 'initial'">
          <div class="space-y-4 max-w-lg">
            <p class="text-sm text-gray-400">
              Two-step verification adds an extra layer of security to your account. Once enabled,
              you'll need to enter a code from your authenticator app when signing in.
            </p>

            <div class="flex justify-end">
              <PrimeButton
                :loading="loading"
                @click="startEnrollment"
              >
                Begin Setup
              </PrimeButton>
            </div>
          </div>
        </template>
        <!-- QR Code Step -->
        <template v-if="setupStep === 'qr'">
          <div class="space-y-4">
            <p class="text-sm text-gray-400">
              1. Install an authenticator app (like Google Authenticator) on your mobile device
            </p>
            <p class="text-sm text-gray-400"> 2. Scan this QR code with your authenticator app: </p>

            <div class="flex justify-center bg-white p-4 rounded-lg">
              <img
                :src="qrCodeUrl"
                alt="QR Code"
                class="w-48 h-48"
              />
            </div>

            <div class="mt-4">
              <p class="text-sm text-gray-400">
                Can't scan the QR code? Enter this setup code manually in your app:
              </p>
              <div class="mt-2 flex items-center gap-2">
                <code class="block p-2 bg-gray-800 rounded text-base font-mono select-all">
                  {{ secret }}
                </code>
              </div>
            </div>

            <PrimeButton
              class="w-full"
              @click="setupStep = 'verify'"
            >
              Continue
            </PrimeButton>
          </div>
        </template>

        <!-- Verification Step -->
        <template v-if="setupStep === 'verify'">
          <div class="space-y-4">
            <p class="text-sm text-gray-400">
              Enter the 6-digit code from your authenticator app to verify setup
            </p>

            <PrimeInputText
              v-model="verificationCode"
              type="text"
              class="w-full"
              :disabled="isVerifying"
              placeholder="Enter 6-digit code"
              maxlength="6"
            />

            <div class="flex justify-end gap-2">
              <PrimeButton
                severity="secondary"
                :disabled="isVerifying"
                @click="setupStep = 'qr'"
              >
                Back
              </PrimeButton>
              <PrimeButton
                :loading="isVerifying"
                @click="verifySetup"
              >
                Enable two-step verification
              </PrimeButton>
            </div>
          </div>
        </template>
      </div>
    </PrimeDialog>
  </div>
</template>

================
File: apps/main-app/components/settings/SecuritySection.vue
================
<script setup lang="ts">
const currentUser = useCurrentUser()
const { profile } = storeToRefs(currentUser)
const security = useSettingsSecurity()

const linkedIdentities = ref([])
const loading = ref(false)
const showSetPasswordModal = ref(false)

const form = reactive({
  password: '',
  confirmPassword: '',
})

onMounted(async () => {
  loading.value = true
  linkedIdentities.value = await security.getLinkedIdentities()
  loading.value = false
})

async function handleUnlinkIdentity(identity) {
  if (linkedIdentities.value.length <= 1) {
    toast.error({
      summary: 'Error',
      message: 'You must keep at least one login method',
    })
    return
  }

  const { error } = await security.unlinkIdentity(identity)

  if (!error) {
    linkedIdentities.value = await security.getLinkedIdentities()
  }
}

async function handleSetPassword() {
  if (form.password !== form.confirmPassword) {
    toast.error({
      summary: 'Error',
      message: 'Passwords do not match',
    })
    return
  }

  const success = await security.setPassword(form.password)
  if (success) {
    showSetPasswordModal.value = false
    form.password = ''
    form.confirmPassword = ''
  }
}
</script>

<template>
  <SettingsCard
    :title="{
      main: 'Security Settings',
      subtitle: 'Manage your account security',
    }"
  >
    <div class="space-y-8">
      <!-- Email/Password Section -->
      <section class="space-y-4">
        <h3 class="text-lg font-medium">Password & Email</h3>
        <div class="flex items-center justify-between rounded-lg bg-black/20 p-4">
          <div class="flex items-center gap-3">
            <div class="flex h-10 w-10 items-center justify-center rounded-full bg-primary-500/10">
              <Icon
                name="mdi:email"
                class="text-xl text-primary-500"
              />
            </div>
            <div>
              <h3 class="font-medium">Email Authentication</h3>
              <p class="text-sm text-gray-400">
                {{ profile.email }}
              </p>
            </div>
          </div>
          <template v-if="!hasEmailProvider">
            <PrimeButton
              severity="secondary"
              size="small"
              @click="showSetPasswordModal = true"
            >
              Set Password
            </PrimeButton>
          </template>
          <template v-else>
            <PrimeButton
              severity="secondary"
              size="small"
              @click="navigateTo(`${authURL}/settings/password`)"
            >
              Change Password
            </PrimeButton>
          </template>
        </div>
      </section>

      <!-- Connected Accounts -->
      <section class="space-y-4">
        <h3 class="text-lg font-medium">Connected Accounts</h3>
        <div
          v-if="loading"
          class="flex justify-center"
        >
          <PrimeProgressSpinner />
        </div>
        <template v-else>
          <div
            v-for="identity in linkedIdentities"
            :key="identity.id"
            class="flex items-center justify-between rounded-lg bg-black/20 p-4"
          >
            <div class="flex items-center gap-3">
              <div
                class="flex h-10 w-10 items-center justify-center rounded-full bg-primary-500/10"
              >
                <Icon
                  :name="currentUser.getProviderIcon(identity.provider)"
                  class="text-xl text-primary-500"
                />
              </div>
              <div>
                <h3 class="font-medium">{{ currentUser.formatProviderName(identity.provider) }}</h3>
                <p class="text-sm text-gray-400">{{ identity.email }}</p>
              </div>
            </div>
            <PrimeButton
              text
              severity="danger"
              size="small"
              :disabled="linkedIdentities.length <= 1"
              @click="handleUnlinkIdentity(identity)"
            >
              Unlink
            </PrimeButton>
          </div>

          <!-- Add New Connection -->
          <div
            class="flex items-center justify-between rounded-lg border border-dashed border-gray-700 p-4"
          >
            <div class="flex items-center gap-3">
              <div class="flex h-10 w-10 items-center justify-center rounded-full bg-gray-800">
                <Icon
                  name="mdi:plus"
                  class="text-xl text-gray-400"
                />
              </div>
              <div>
                <h3 class="font-medium">Add Account</h3>
                <p class="text-sm text-gray-400">Connect another social account</p>
              </div>
            </div>
            <PrimeButton
              severity="secondary"
              size="small"
              @click="security.linkIdentity('twitter')"
            >
              Connect
            </PrimeButton>
          </div>
        </template>
      </section>
      <section class="space-y-4">
        <h3 class="text-lg font-medium">Two-Step Verification</h3>
        <Settings2FA />
      </section>
    </div>

    <!-- Set Password Modal -->
    <PrimeDialog
      v-model:visible="showSetPasswordModal"
      modal
      header="Set Password"
    >
      <div class="space-y-4">
        <PrimePassword
          v-model="form.password"
          :feedback="true"
          toggleMask
          placeholder="Enter new password"
        />
        <PrimePassword
          v-model="form.confirmPassword"
          toggleMask
          placeholder="Confirm new password"
        />
      </div>
      <template #footer>
        <PrimeButton
          label="Cancel"
          severity="secondary"
          @click="showSetPasswordModal = false"
        />
        <PrimeButton
          label="Set Password"
          @click="handleSetPassword"
        />
      </template>
    </PrimeDialog>
  </SettingsCard>
</template>

================
File: apps/main-app/components/supa/Upload.vue
================
<script setup lang="ts">
const props = defineProps({
  uploadType: {
    type: String as PropType<string>,
    required: true,
  },
})

const imageInput = ref(null) // template ref for file input
const selectedFile = ref(null)
const imageSrc = ref(null)
const img = ref(null)
const cropper = ref({})
const destination = ref(null)

const fileReader = new FileReader()
fileReader.onload = (event) => {
  imageSrc.value = event.target.result
}

const handleImageCropped = () => {
  cropper.value
    .getCroppedCanvas({
      width: 180,
      height: 180,
    })
    .toBlob((blob) => {
      upload.avatar({ file: blob, userId, type: props.uploadType }) // !todo auth user, get id
    }, 'image/png')
  selectedFile.value = null
}
const fileChanged = (e) => {
  const files = e.target.files || e.dataTransfer.files
  if (files.length) {
    selectedFile.value = files[0]
  }
}

const fileCleared = (_) => {
  selectedFile.value = null
}

onMounted(() => {})

onUnmounted(() => {})

watchEffect(() => {
  if (selectedFile.value) {
    fileReader.readAsDataURL(selectedFile.value)
  } else {
    imageSrc.value = null
  }
})

watch(
  imageSrc,
  () => {
    if (imageSrc.value) {
      cropper.value.replace(imageSrc.value)
    }
  },
  {
    flush: 'post', // watch runs after component updates
  },
)
</script>

<template>
  <div class="flex flex-col items-center justify-center w-full h-full gap-4 example-avatar">
    <div
      v-show="imageSrc"
      class="object-fill w-1/2 mx-auto my-4 border-4 rounded-full aspect-ratio border-stone-700"
    >
      <img
        :src="destination"
        class="block w-full rounded-full"
      />
    </div>
    <div
      v-show="imageSrc"
      class="object-fill w-1/2 mx-auto my-2 aspect-ratio"
    >
      <img
        ref="img"
        class="block w-full max-w-full pb-4 aspect-auto"
        :src="imageSrc"
      />
    </div>
    <div class="flex content-end justify-center w-full py-2 mt-2 rounded-md">
      <PrimeButton
        v-if="!imageSrc"
        color="primary"
        @click="imageInput.click()"
      >
        <slot />
      </PrimeButton>
      <PrimeButton
        v-else
        color="primary"
        class="w-32 mx-2"
        @click="handleImageCropped"
      >
        Update
      </PrimeButton>
      <PrimeButton
        v-if="imageSrc"
        color="primary"
        class="w-32 mx-2"
        @click="fileCleared"
      >
        Cancel
      </PrimeButton>
      <input
        ref="imageInput"
        type="file"
        accept=".jpg,.jpeg,.png"
        class="py-4"
        :style="{ display: 'none' }"
        @change="fileChanged"
      />
    </div>
  </div>
</template>

<style scoped>
.preview {
  border: 5px solid #292929;
  overflow: hidden;
  width: 50px;
  height: 50px;
}

.example-avatar .avatar-upload .rounded-circle {
  width: 200px;
  height: 200px;
}

.example-avatar .text-center .btn {
  margin: 0 0.5rem;
}

.example-avatar .avatar-edit-image {
  max-width: 100%;
}

.example-avatar .drop-active {
  top: 0;
  bottom: 0;
  right: 0;
  left: 0;
  position: fixed;
  z-index: 9999;
  opacity: 0.6;
  text-align: center;
  background: #000;
}

.example-avatar .drop-active h3 {
  margin: -0.5em 0 0;
  position: absolute;
  top: 50%;
  left: 0;
  right: 0;
  -webkit-transform: translateY(-50%);
  -ms-transform: translateY(-50%);
  transform: translateY(-50%);
  font-size: 40px;
  color: #fff;
  padding: 0;
}
</style>

================
File: apps/main-app/composables/users/user.admin.composable.ts
================
import { useLogger } from '@ib/logger'
import { emailUnvalidatedUserSchema } from '../../../auth-service/types/auth'
import type { UserRowType } from '~/types/users'

interface NewUser {
  email: string
  password: string
}

const DOMAIN_KEY = 'useAdmin'

export function useAdmin() {
  const errors = useBaseError()
  const log = useLogger(DOMAIN_KEY)
  const utils = useUtils()
  const client = useSupabaseClient()
  const toast = useNotification()
  const createdUsers = ref([] as NewUser[])

  const register = async ({ email, password }: { email: string; password: string }) => {
    const { data, error } = await client.auth.signUp({
      email,
      password,
    })
    if (error) {
      throw createError({
        statusCode: 401,
        message: error.message,
      })
    }

    const validatedUser = emailUnvalidatedUserSchema.safeParse(data.user)

    if (!validatedUser.success) {
      throw createError(validatedUser.error)
    }

    return validatedUser.data
  }

  async function addProfilePicture(userId: string, file: File) {
    try {
      const { data, error } = await client.storage
        .from('profile-public')
        .upload(`${userId}/avatar/${file.name}`, file)
      if (error) {
        throw createError(
          `Error uploading profile picture for user with ID ${userId}: ${error.message}`,
        )
      }
      console.log(`Profile picture uploaded successfully for user with ID ${userId}`)
    } catch (error) {
      console.error(`Error uploading profile picture for user with ID ${userId}:`, error)
    }
  }

  async function registerManyUsers() {
    const users: UserRowType[] = []
    for (const user of users) {
      // Extract the given name and surname
      const givenName = user.given_name.charAt(0).toUpperCase() + user.given_name.slice(1)
      const surname = user.surname.charAt(0).toUpperCase() + user.surname.slice(1)

      // Construct the password
      const password = `${givenName}${surname}12345$`

      // Register the user
      try {
        // const newUser = await register({ email: user.email, password })
        // we handle user profile creation with a database trigger
        // now seed the database with the user data
        // createdUsers.value.push({ email: user.email, password })

        // Locate the profile image file based on the user's given name and surname
        const imageName = `${givenName.toLowerCase()}-${surname.toLowerCase()}.jpg`
        const imagePath = `/data/seed/avatars/${imageName}` // Adjust the path as necessary
        const imageFile = new File([await fetch(imagePath).then((r) => r.blob())], imageName, {
          type: 'image/jpeg',
        })

        console.log('file exists', imageFile.size)
        // Upload the profile image
        await addProfilePicture(newUser.id, imageFile)

        // update user profile with data
        await updateSingle(user, newUser.id)
      } catch (error) {
        console.error(`Failed to register user with email ${user.email}:`, error)
      }
    }
  }

  async function updateUser(newData: any, oldData: any) {
    log.info(`Updating user with email ${newData.email}`)
    // we should first parse the data to check if anything has changed and then filter out any undefined values
    try {
      const { noDataUpdated, data: updatedData } = utils.wasRowDataUpdated(newData, oldData)

      if (noDataUpdated) {
        log.info('No changes detected, no update necessary')
        return
      }

      const response = await $fetch('/api/users/update', {
        method: 'POST',
        body: {
          data: updatedData,
          id: newData.id,
        },
      })

      const data = errors.server({
        response,
        devOnly: false,
        showSuccess: true,
        devMessage: `Error updating user with email ${newData.email}`,
        userMessage: `There was an error updating user with email ${newData.email}`,
      })

      log.info(`User with email ${data.email} updated successfully`)
      toast.success({
        summary: 'Success',
        message: `User with email ${data.email} updated successfully`,
      })

      // maybe update state here
    } catch (error) {
      errors.client({
        error,
        devOnly: false,
        devMessage: `Error updating user with email ${newData.email}`,
        userMessage: `There was an error updating user with email ${newData.email}`,
      })
    }
  }

  return {
    registerManyUsers,
    updateUser,
    createdUsers,
  }
}

================
File: apps/main-app/composables/useBookmarkStore.ts
================
// useBookmarkStore.ts
import { defineStore } from 'pinia'
import Fuse from 'fuse.js'

interface BookmarkContent {
  id: string
  type: string
  title: string
  description?: string
  thumbnail?: string
  url?: string
  author?: string
  folder_id?: string
}

interface BookmarkParams {
  content_type?: string
  folder_id?: string
  include_subfolders?: boolean
}

interface Bookmark {
  id: string
  user_id: string
  folder_id: string | null
  content_type: string
  content_id: string
  metadata: {
    title: string
    author?: string
    description?: string
    thumbnail?: string
    url?: string
  }
  created_at: string
  folder?: {
    id: string
    name: string
    color: string
    is_favorite: boolean
  }
}

// stores/useBookmarkStore.ts
export const useBookmarkStore = defineStore('bookmarks', () => {
  const bookmarks = ref<Bookmark[]>([])
  const bookmarksByFolder = ref<Map<string, Bookmark[]>>(new Map())

  const folderBookmarkCounts = ref<Record<string, number>>({})

  const loading = ref(false)
  const error = ref<string | null>(null)
  const currentFolderId = ref<string | null>(null)
  const includeSubfolders = ref(true)
  const searchQuery = ref('')

  const organizeBookmarksByFolder = (bookmarksList: Bookmark[]) => {
    const folderMap = new Map<string, Bookmark[]>()

    bookmarksList.forEach((bookmark) => {
      const folderId = bookmark.folder_id || 'uncategorized'
      if (!folderMap.has(folderId)) {
        folderMap.set(folderId, [])
      }
      folderMap.get(folderId)?.push(bookmark)
    })

    bookmarksByFolder.value = folderMap
  }

  // Get bookmark count for a folder
  const fetchBookmarkCounts = async () => {
    try {
      console.log('Fetching bookmark counts...')
      const response = await $fetch('/api/bookmarks/counts')
      console.log('Bookmark counts response:', response)

      if (!response?.data) {
        console.error('No data received from bookmark counts endpoint')
        return
      }

      const oldCounts = { ...folderBookmarkCounts.value }
      folderBookmarkCounts.value = response.data.reduce(
        (acc: Record<string, number>, item: any) => {
          acc[item.folder_id || 'uncategorized'] = item.count
          return acc
        },
        {},
      )

      console.log('Old counts:', oldCounts)
      console.log('New counts:', folderBookmarkCounts.value)
    } catch (error) {
      console.error('Failed to fetch bookmark counts:', error)
    }
  }

  // Fetch bookmarks with optional folder filter
  const fetchBookmarks = async (params: BookmarkParams = {}) => {
    loading.value = true
    error.value = null

    try {
      const response = await $fetch('/api/bookmarks', {
        params: {
          folder_id: params.folder_id || null,
          include_subfolders: params.include_subfolders ?? includeSubfolders.value,
        },
      })

      bookmarks.value = response.data || []
      organizeBookmarksByFolder(bookmarks.value)
    } catch (e) {
      error.value = 'Failed to fetch bookmarks'
      bookmarks.value = []
      bookmarksByFolder.value = new Map()
    } finally {
      loading.value = false
    }
  }

  // Get bookmarks for a specific folder
  const getBookmarkCount = (folderId: string) => {
    return folderBookmarkCounts.value[folderId] || 0
  }

  const moveBookmarks = async (bookmarkIds: string[], targetFolderId: string) => {
    loading.value = true
    try {
      const response = await $fetch('/api/bookmarks/move', {
        method: 'PATCH',
        body: {
          bookmarkIds,
          targetFolderId,
        },
      })

      // Optimistically update the local state
      bookmarks.value = bookmarks.value.map((bookmark) =>
        bookmarkIds.includes(bookmark.id) ? { ...bookmark, folder_id: targetFolderId } : bookmark,
      )

      // Fetch fresh data to ensure consistency
      await fetchBookmarks()
      return response.data
    } catch (error) {
      console.error('Error moving bookmarks:', error)
      await fetchBookmarks()
      throw error
    } finally {
      loading.value = false
    }
  }

  const toggleBookmark = async (content: BookmarkContent) => {
    try {
      const response = await $fetch('/api/bookmarks/toggle', {
        method: 'POST',
        body: {
          content_id: content.id,
          content_type: content.type,
          folder_id: content.folder_id,
          metadata: {
            title: content.title,
            description: content.description,
            thumbnail: content.thumbnail,
            url: content.url,
            author: content.author,
          },
        },
      })

      await fetchBookmarks()
      return response.data
    } catch (error) {
      console.error('Error toggling bookmark:', error)
      await fetchBookmarks()
      throw error
    }
  }

  const isBookmarked = computed(() => (contentId: string, contentType: string = 'news') => {
    return bookmarks.value.some(
      (bookmark) => bookmark.content_id === contentId && bookmark.content_type === contentType,
    )
  })

  const filteredBookmarks = computed(() => {
    let filtered = bookmarks.value

    // Filter by folder
    if (currentFolderId.value) {
      filtered = filtered.filter((bookmark) => {
        if (includeSubfolders.value) {
          // TODO: Add logic for subfolder inclusion when implemented
          return bookmark.folder_id === currentFolderId.value
        }
        return bookmark.folder_id === currentFolderId.value
      })
    }

    // Filter by search
    if (searchQuery.value) {
      const fuse = new Fuse(filtered, {
        keys: [
          'metadata.title',
          'metadata.description',
          'metadata.author',
          'metadata.abstract',
          'metadata.name',
        ],
        threshold: 0.3,
        shouldSort: true,
      })
      return fuse.search(searchQuery.value).map((result) => result.item)
    }

    return filtered
  })

  const setCurrentFolder = async (folderId: string | null) => {
    currentFolderId.value = folderId
    await fetchBookmarks({
      folder_id: folderId,
      include_subfolders: includeSubfolders.value,
    })
  }

  const setIncludeSubfolders = async (include: boolean) => {
    includeSubfolders.value = include
    if (currentFolderId.value) {
      await fetchBookmarks({
        folder_id: currentFolderId.value,
        include_subfolders: include,
      })
    }
  }

  const setSearchQuery = (query: string) => {
    searchQuery.value = query
  }

  // Reset state
  const resetFilters = async () => {
    currentFolderId.value = null
    includeSubfolders.value = true
    searchQuery.value = ''
    await fetchBookmarks()
  }

  return {
    bookmarks,
    loading,
    error,
    bookmarksByFolder,
    currentFolderId,
    includeSubfolders,
    searchQuery,

    // Computed
    filteredBookmarks,

    // Actions
    fetchBookmarks,
    setCurrentFolder,
    setIncludeSubfolders,
    setSearchQuery,
    resetFilters,
    getBookmarkCount,
    fetchBookmarkCounts,

    moveBookmarks,
    toggleBookmark,
    isBookmarked,
  }
})

================
File: apps/main-app/composables/usePlan.ts
================
import { FEATURES } from '#shared/constants'

// composables/usePlan.ts
export enum PlanType {
  FREE = 'free',
  PRO = 'pro',
}

export interface PlanFeature {
  name: string
  limit: {
    [PlanType.FREE]: number
    [PlanType.PRO]: number
  }
  description: string
  comingSoon?: boolean
}

export const usePlan = () => {
  // For now, we'll assume everyone is on free plan
  // Later this can be updated based on your auth/subscription system
  const userPlan = ref<PlanType>(PlanType.FREE)

  // Utility functions
  const getFeatureLimit = (featureKey: keyof typeof FEATURES) => {
    return FEATURES[featureKey].limit[userPlan.value]
  }

  const isFeatureAvailable = (featureKey: keyof typeof FEATURES) => {
    const feature = FEATURES[featureKey]
    return !feature.comingSoon && getFeatureLimit(featureKey) !== 0
  }

  const checkFeatureLimit = async (
    featureKey: keyof typeof FEATURES,
    currentCount: number,
  ): Promise<boolean> => {
    const limit = getFeatureLimit(featureKey)
    return limit === -1 || currentCount < limit
  }

  const getUpgradeMessage = (featureKey: keyof typeof FEATURES) => {
    const feature = FEATURES[featureKey]
    if (userPlan.value === PlanType.FREE) {
      return feature.limit.pro === -1
        ? `Upgrade to Pro for unlimited ${feature.name}`
        : `Upgrade to Pro for up to ${feature.limit.pro} ${feature.name}`
    }
    return ''
  }

  // This can be used to show remaining quota
  const getFeatureUsage = (featureKey: keyof typeof FEATURES, currentCount: number) => {
    const limit = getFeatureLimit(featureKey)
    return {
      used: currentCount,
      limit,
      remaining: limit === -1 ? -1 : limit - currentCount,
      isUnlimited: limit === -1,
    }
  }

  return {
    FEATURES,
    userPlan,
    getFeatureLimit,
    isFeatureAvailable,
    checkFeatureLimit,
    getUpgradeMessage,
    getFeatureUsage,
  }
}

================
File: apps/main-app/composables/useSettingsSecurity.ts
================
// composables/useSettingsSecurity.ts
export function useSettingsSecurity() {
  const supabase = useSupabaseClient()
  const toast = useNotification()

  // Linked Identities
  async function getLinkedIdentities() {
    const { data, error } = await supabase.auth.getUserIdentities()
    if (error) {
      toast.error({
        summary: 'Error',
        message: 'Could not fetch linked accounts',
      })
      return []
    }
    return data?.identities || []
  }

  async function linkIdentity(provider: 'twitter' | 'google' | 'facebook' | 'linkedin_oidc') {
    const { data, error } = await supabase.auth.linkIdentity({ provider })
    if (error) {
      toast.error({
        summary: 'Error',
        message: 'Could not link account',
      })
    }
    return { data, error }
  }

  async function unlinkIdentity(identity: any) {
    const { data, error } = await supabase.auth.unlinkIdentity(identity)
    if (error) {
      toast.error({
        summary: 'Error',
        message: 'Could not unlink account',
      })
    }
    return { data, error }
  }

  // Password Management
  async function setPassword(password: string) {
    const { error } = await supabase.auth.updateUser({ password })
    if (error) {
      toast.error({
        summary: 'Error',
        message: 'Could not set password',
      })
      return false
    }
    return true
  }

  // 2FA Management
  async function setupTwoFactor() {
    const { data, error } = await supabase.auth.mfa.enroll({
      factorType: 'totp',
    })
    if (error) {
      toast.error({
        summary: 'Error',
        message: 'Could not setup 2FA',
      })
      return null
    }
    return data
  }

  async function verifyTwoFactor(code: string, factorId: string) {
    const { data, error } = await supabase.auth.mfa.challenge({
      factorId,
      code,
    })
    if (error) {
      toast.error({
        summary: 'Error',
        message: 'Invalid verification code',
      })
      return false
    }
    return true
  }

  return {
    getLinkedIdentities,
    linkIdentity,
    unlinkIdentity,
    setPassword,
    setupTwoFactor,
    verifyTwoFactor,
  }
}

================
File: apps/main-app/composables/useVotesStore.ts
================
// stores/useVoteStore.ts
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'

interface VoteResponse {
  success: boolean
  action: 'voted' | 'removed'
}

interface VoteMetrics {
  votes: Array<{
    id: string
    content_id: string
    vote_type: number
    created_at: string
    news_score: number
  }>
  votesByDate: Record<string, any[]>
  streakData: any[]
}

export const useVoteStore = defineStore('votes', () => {
  // Original vote store state
  const votes = ref<Record<string, number>>({})
  const userVotes = ref<Record<string, number>>({})
  const pendingVotes = ref<Record<string, Promise<VoteResponse>>>({})

  // Metrics state
  const metrics = ref<VoteMetrics | null>(null)
  const isLoading = ref(false)
  const error = ref<Error | null>(null)

  // Original getters
  const getVoteType = computed(() => {
    return (contentId: string): number | null => userVotes.value[contentId] ?? null
  })

  const getScore = computed(() => {
    return (contentId: string): number | null => votes.value[contentId] ?? null
  })

  const isVotePending = computed(() => {
    return (contentId: string): boolean => !!pendingVotes.value[contentId]
  })

  // Metrics getters
  const totalVotes = computed(() => metrics.value?.votes.length ?? 0)

  const upvoteCount = computed(
    () => metrics.value?.votes.filter((v) => v.vote_type === 1).length ?? 0,
  )

  const downvoteCount = computed(
    () => metrics.value?.votes.filter((v) => v.vote_type === -1).length ?? 0,
  )

  const voteAccuracy = computed(() => {
    if (!metrics.value?.votes.length) return 0

    const alignedVotes = metrics.value.votes.filter((vote) => {
      if (vote.news_score === 0) return true
      return (
        (vote.news_score > 0 && vote.vote_type === 1) ||
        (vote.news_score < 0 && vote.vote_type === -1)
      )
    })

    return Math.round((alignedVotes.length / metrics.value.votes.length) * 100)
  })

  const streakInfo = computed(() => {
    if (!metrics.value?.votesByDate) return { current: 0, best: 0 }

    const dates = Object.keys(metrics.value.votesByDate).sort()
    if (!dates.length) return { current: 0, best: 0 }

    let currentStreak = 0
    let bestStreak = 0

    const today = new Date().toISOString().split('T')[0]
    const yesterday = new Date(Date.now() - 86400000).toISOString().split('T')[0]

    if (metrics.value.votesByDate[today]) {
      currentStreak = 1
      let checkDate = new Date(Date.now() - 86400000)

      while (true) {
        const dateStr = checkDate.toISOString().split('T')[0]
        if (metrics.value.votesByDate[dateStr]) {
          currentStreak++
          checkDate = new Date(checkDate.getTime() - 86400000)
        } else {
          break
        }
      }
    } else if (metrics.value.votesByDate[yesterday]) {
      currentStreak = 1
      let checkDate = new Date(Date.now() - 2 * 86400000)

      while (true) {
        const dateStr = checkDate.toISOString().split('T')[0]
        if (metrics.value.votesByDate[dateStr]) {
          currentStreak++
          checkDate = new Date(checkDate.getTime() - 86400000)
        } else {
          break
        }
      }
    }

    let tempStreak = 0
    for (let i = 0; i < dates.length; i++) {
      const currentDate = new Date(dates[i])
      const nextDate = i < dates.length - 1 ? new Date(dates[i + 1]) : null

      if (!tempStreak) tempStreak = 1
      else if (nextDate) {
        const daysDiff = Math.floor((nextDate.getTime() - currentDate.getTime()) / 86400000)
        if (daysDiff === 1) tempStreak++
        else {
          bestStreak = Math.max(bestStreak, tempStreak)
          tempStreak = 1
        }
      }
    }
    bestStreak = Math.max(bestStreak, tempStreak, currentStreak)

    return {
      current: currentStreak,
      best: bestStreak,
    }
  })

  const todayVoteCount = computed(() => {
    if (!metrics.value?.votesByDate) return 0
    const today = new Date().toISOString().split('T')[0]
    return metrics.value.votesByDate[today]?.length ?? 0
  })

  // Original actions
  const fetchUserVotes = async () => {
    if (isLoading.value) return

    isLoading.value = true
    error.value = null

    try {
      const response = await $fetch('/api/votes/user')
      userVotes.value = response.votes
    } catch (err) {
      console.error('Error fetching votes:', err)
      error.value = err as Error
      throw err
    } finally {
      isLoading.value = false
    }
  }

  const fetchVotedPosts = async (voteType: 1 | -1) => {
    try {
      const response = await $fetch(`/api/votes/user/${voteType}`)
      return response
    } catch (err) {
      console.error('Error fetching voted posts:', err)
      error.value = err as Error
      throw err
    }
  }

  const setVotes = (contentId: string, score: number) => {
    votes.value[contentId] = score
  }

  const submitVote = async (
    contentId: string,
    voteType: number,
    { success: successNotify, error: errorNotify }: ReturnType<typeof useNotification>,
  ) => {
    if (pendingVotes.value[contentId]) {
      return
    }

    const currentVote = getVoteType.value(contentId)
    const isRemoving = currentVote === voteType
    const oldVote = currentVote

    try {
      pendingVotes.value[contentId] = $fetch(`/api/votes/news/${contentId}`, {
        method: 'POST',
        body: { voteType },
      })

      userVotes.value = {
        ...userVotes.value,
        [contentId]: isRemoving ? null : voteType,
      }

      const response = await pendingVotes.value[contentId]

      successNotify({
        summary: 'Vote Recorded',
        message: `Successfully ${response.action === 'removed' ? 'removed vote' : 'voted'}`,
      })

      let change = 0
      if (isRemoving) {
        change = -voteType
      } else {
        change = oldVote ? voteType * 2 : voteType
      }
      const newVotes = votes.value[contentId] + change

      votes.value = {
        ...votes.value,
        [contentId]: newVotes,
      }

      return { success: true, change }
    } catch (err: any) {
      userVotes.value = {
        ...userVotes.value,
        [contentId]: oldVote,
      }

      if (err.statusCode === 401) {
        errorNotify({
          summary: 'Authentication Required',
          message: 'Please log in to vote',
        })
      } else {
        errorNotify({
          summary: 'Vote Failed',
          message: 'Unable to record your vote. Please try again.',
        })
      }

      throw err
    } finally {
      delete pendingVotes.value[contentId]
    }
  }

  // New metrics action
  const fetchMetrics = async () => {
    if (isLoading.value) return

    isLoading.value = true
    error.value = null

    try {
      const response = await $fetch('/api/users/metrics')
      metrics.value = response as VoteMetrics
    } catch (err) {
      console.error('Error fetching metrics:', err)
      error.value = err as Error
      throw err
    } finally {
      isLoading.value = false
    }
  }

  return {
    // State
    votes,
    userVotes,
    isLoading,
    error,

    // Original getters
    getScore,
    getVoteType,
    isVotePending,

    // Metrics getters
    totalVotes,
    upvoteCount,
    downvoteCount,
    voteAccuracy,
    streakInfo,
    todayVoteCount,

    // Original actions
    setVotes,
    fetchUserVotes,
    submitVote,
    fetchVotedPosts,

    // New metrics action
    fetchMetrics,
  }
})

================
File: apps/main-app/middleware/auth.global.ts
================
import { defineNuxtRouteMiddleware, navigateTo, useNuxtApp } from '#app'
import { useRuntimeConfig, useSupabaseClient } from '#imports'

export default defineNuxtRouteMiddleware(async (to) => {
  const config = useRuntimeConfig()
  const { $formbricks } = useNuxtApp()

  console.log('AUTH_MIDDLEWARE', $formbricks)

  const { loginURL, authURL } = config.public
  const supabase = useSupabaseClient()

  // List of public routes that don't require authentication
  const publicRoutes = ['/auth-callback']

  if (publicRoutes.includes(to.path)) {
    return // Allow access to public routes without checking auth
  }

  const { data, error } = await supabase.auth.getSession()

  if (error || !data.session) {
    console.log('USER_NOT_LOGGED_IN', `${authURL}${loginURL}`)
    return navigateTo(String(`${authURL}${loginURL}`), { external: true })
  } else {
    console.log('USER_LOGGED_IN', data.session, $formbricks)
    // $formbricks.setUserId(data.session.user.id)
  }
})

================
File: apps/main-app/pages/feed/[feed].vue
================
<script setup lang="ts">
const route = useRoute()
const feedId = computed(() => String(route.params.feed))
const { deleteFeed, currentFeedName } = usePages()

console.log('feedId', feedId.value)

const isLoadingDependencies = ref(true)
// Load feed categories and sources
const { store: categoriesStore, isSelecting: isLoadingCategories } = useSelectData(
  'feed_categories',
  {
    columns: 'id, feed_id, categories(id, name)',
    filters: { feed_id: { eq: feedId.value } },
    orderBy: { column: 'created_at', ascending: false },
    initialFetch: true,
    storeKey: `feedCategories_${feedId.value}`,
  },
)

const { store: sourcesStore, isSelecting: isLoadingSources } = useSelectData('feed_sources', {
  columns: 'id, feed_id, source_id, content_sources(id, url, content_type)',
  filters: { feed_id: { eq: feedId.value } },
  orderBy: { column: 'created_at', ascending: false },
  initialFetch: true,
  storeKey: `feedSources_${feedId.value}`,
})

const { items: proxyCategories } = storeToRefs(categoriesStore)
const { items: proxySources } = storeToRefs(sourcesStore)

const categories = computed(() => proxyCategories.value.map((item) => toRaw(item).categories))
const sources = computed(() => proxySources.value.map((item) => toRaw(item).content_sources))

// Watch for dependencies to load
watchEffect(() => {
  isLoadingDependencies.value = isLoadingCategories.value || isLoadingSources.value
})

// Initialize news only after dependencies are loaded
const newsQuery = computed(() => {
  const filters: any = {
    body: { neq: 'null' },
  }

  const orConditions = []

  if (categories.value?.length) {
    orConditions.push({
      category_id: { in: categories.value.map((category) => category.id) },
    })
  }

  if (sources.value?.length) {
    orConditions.push({
      content_source_id: { in: sources.value.map((source) => source.id) },
    })
  }

  if (orConditions.length) {
    filters.or = orConditions
  }

  return {
    columns: `
      id, title, body, published_at, created_at, description,
      category_id, author, url, keywords, featured_image,
      company_id, companies(*), content_source_id, content_sources(*), score
    `,
    filters,
    orderBy: { column: 'created_at', ascending: false },
    pagination: { page: 1, limit: 20 },
    storeKey: `customFeed_${feedId.value}`,
    enabled: !isLoadingDependencies.value,
  }
})

const news = computed(() => newsStore?.items || [])

// Create news store only when query is ready
const {
  store: newsStore,
  loadMore: loadMoreFunc,
  refresh: refreshNews,
  isSelecting: isLoadingNews,
} = useSelectData<News>('news', newsQuery)

// Watch for query changes to refresh
watch(
  newsQuery,
  () => {
    if (newsQuery.value && refreshNews) {
      newsStore.clearItems()
      refreshNews()
    }
  },
  { deep: true },
)

// Safe loadMore function
const handleLoadMore = async () => {
  if (isLoadingNews.value || !loadMoreFunc) return

  try {
    await loadMoreFunc()
  } catch (error) {
    console.error('Error loading more news:', error)
  }
}

// Loading states
const loading = useLoadingStore()
const isLoading = computed(
  () =>
    isLoadingDependencies.value ||
    isLoadingNews.value ||
    loading.isLoading(`customFeed_${feedId.value}`),
)

onUnmounted(() => {
  newsStore?.clearItems()
})

// URL formatting helper
const formatSourceUrl = (url: string) => {
  try {
    const urlObj = new URL(url)
    return urlObj.hostname.replace('www.', '')
  } catch {
    return url
  }
}

// UI state
const showFiltersModal = ref(false)

// Clean up store when component is unmounted
onUnmounted(() => {
  newsStore.clearItems()
})
</script>

<template>
  <div>
    <FeedTitle
      :title="currentFeedName"
      :filters="{
        categories,
        sources,
      }"
    />

    <BlackFridayBanner />

    <IBInfiniteScroll @update:scroll-end="handleLoadMore">
      <div
        class="mx-auto w-full grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 md:col-start-2 gap-4 md:gap-8 p-4 md:p-8 max-w-[940px]"
      >
        <NewsCard
          v-for="item in news"
          :key="`news-post-${item.id}`"
          :news="item"
        />
        <NewsCardSkeleton v-show="isLoading" />
      </div>
    </IBInfiniteScroll>

    <PrimeDialog
      v-model:visible="showFiltersModal"
      modal
      header="Feed Filters"
      :style="{ width: '50vw' }"
    >
      <div class="space-y-6">
        <div v-if="categories.length">
          <h3 class="text-lg font-semibold mb-3">Categories</h3>
          <div class="flex flex-wrap gap-2">
            <PrimeChip
              v-for="category in categories"
              :key="category.id"
              :label="category.name"
              class="bg-primary-700 border border-primary-600"
            />
          </div>
        </div>

        <div v-if="sources.length">
          <h3 class="text-lg font-semibold mb-3">Sources</h3>
          <div class="flex flex-wrap gap-2">
            <PrimeChip
              v-for="source in sources"
              :key="source.id"
              :label="formatSourceUrl(source.url)"
              :title="source.url"
              class="bg-secondary-700 border border-secondary-600"
            >
              <template #extra>
                <span class="text-xs ml-1 opacity-75">{{ source.content_type }}</span>
              </template>
            </PrimeChip>
          </div>
        </div>
      </div>
    </PrimeDialog>
  </div>
</template>

================
File: apps/main-app/pages/news/index.vue
================
<script setup lang="ts">
// !todo:critical - add summaries for news articles
// !todo:high - allow news to toggle summary level
// !todo:bug:critical - infinite scroll is loading duplicate posts with pagination, probably a supabase issue

const domainKey = 'news'
const { store, loadMore, refresh } = useSelectData<News>('news', {
  columns:
    'id, title, body, published_at, created_at, description, category_id, author, url, keywords, featured_image, company_id, companies(*), score',
  filters: {
    // content_status: { eq: 'draft' },
    body: { neq: 'null' },
  },
  orderBy: { column: 'created_at', ascending: false },
  initialFetch: true,
  pagination: { page: 1, limit: 20 },
  storeKey: 'mainNewsFeed',
})

const { items: proxyNews } = storeToRefs(store)

const news = computed(() => proxyNews.value.map((item) => toRaw(item)))

const loading = useLoadingStore()
const isLoading = computed(() => loading.isLoading(domainKey))

definePageMeta({
  name: 'News',
})
</script>

<template>
  <div>
    <FeedTitle title="News Feed" />
    <BlackFridayBanner />

    <!-- News Content -->
    <IBInfiniteScroll @update:scroll-end="loadMore()">
      <div
        class="mx-auto w-full grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 md:col-start-2 gap-4 md:gap-8 p-4 md:p-8 max-w-[940px]"
      >
        <NewsCard
          v-for="(item, i) in news"
          :key="`news-post-${i}`"
          :news="item"
        />
        <NewsCardSkeleton v-show="isLoading" />
      </div>
    </IBInfiniteScroll>
  </div>
</template>

<style scoped></style>

================
File: apps/main-app/pages/profile/bookmarks.vue
================
<script setup lang="ts">
import { storeToRefs } from 'pinia'
import { useConfirm } from 'primevue/useconfirm'
import EmptyState from '../../components/EmptyState.vue'

const confirm = useConfirm()
const bookmarkStore = useBookmarkStore()
const folderStore = useFolderStore()
const bookmarkManager = useBookmarkManager()

const { selectedFolderId, includeSubfolders, folders } = storeToRefs(folderStore)
const { bookmarks, loading } = storeToRefs(bookmarkStore)

const searchQuery = ref('')
const searchResults = ref<any[]>([])
const isMoving = ref(false)

const searchFuseOptions = {
  keys: ['metadata.title', 'metadata.description', 'metadata.author'],
  threshold: 0.3,
  shouldSort: true,
}

// Computed properties
const currentFolder = computed(() => {
  const folder = folders.value?.find((f) => f.id === selectedFolderId.value)
  console.log('Current folder computed:', {
    selectedId: selectedFolderId.value,
    folder,
  })
  return folder
})

const filteredBookmarks = computed(() => {
  console.log('Computing filtered bookmarks:', {
    hasBookmarks: bookmarks.value?.length,
    selectedFolder: selectedFolderId.value,
    includeSubfolders: includeSubfolders.value,
    searchQuery: searchQuery.value,
  })

  let filtered = bookmarks.value ?? []

  // Filter by folder
  if (selectedFolderId.value) {
    filtered = filtered.filter((bookmark) => {
      const matches = bookmark.folder_id === selectedFolderId.value
      return matches
    })
  }

  console.log('After folder filter:', filtered.length)

  // Filter by search
  if (searchQuery.value && searchResults.value?.length) {
    return searchResults.value
  }

  return filtered
})

// Methods
const clearSelection = () => {
  bookmarkManager.clearSelection()
  selectedFolderId.value = null
}

const handleMoveSelected = async () => {
  if (!selectedFolderId.value || !bookmarkManager.selectedIds.value.length) return

  isMoving.value = true
  try {
    await bookmarkManager.handleMove(selectedFolderId.value)
    bookmarkManager.clearSelection()
  } finally {
    isMoving.value = false
  }
}

const handleDeleteSelected = () => {
  confirm.require({
    message: `Delete ${bookmarkManager.selectedIds.value.length} bookmark${bookmarkManager.selectedIds.value.length > 1 ? 's' : ''}?`,
    header: 'Confirm Delete',
    icon: 'pi pi-exclamation-triangle',
    acceptClass: 'p-button-danger',
    accept: async () => {
      await bookmarkManager.handleDelete(bookmarkManager.selectedIds.value)
      clearSelection()
    },
  })
}

const handleSearchResults = (results: FuseResult<any>[]) => {
  console.log('Search results:', results.length)
  searchResults.value = results.map((result) => result.item)
}

onMounted(async () => {
  console.log('Component mounted, fetching data...')
  await Promise.all([folderStore.fetchFolders(), bookmarkStore.fetchBookmarks()])
  console.log('Initial data loaded:', {
    folders: folders.value?.length,
    bookmarks: bookmarks.value?.length,
  })

  const defaultFolder = folderStore.getDefaultFolder
  console.log('Default folder:', defaultFolder)

  if (defaultFolder) {
    folderStore.setSelectedFolder(defaultFolder.id)
    console.log('Set default folder:', defaultFolder.id)
  }
})

// Also modify the empty check to add logging
const isEmpty = computed(() => {
  const empty =
    !loading.value && (!filteredBookmarks.value?.length || filteredBookmarks.value.length === 0)
  console.log('Checking empty state:', {
    loading: loading.value,
    filteredLength: filteredBookmarks.value?.length,
    isEmpty: empty,
  })
  return empty
})
</script>

<template>
  <div class="min-h-screen p-4 gap-4 max-w-[940px] flex flex-col mx-auto lg:p-8 lg:gap-8">
    <BookmarkViewFolder v-if="!searchQuery" />

    <!-- Search Bar & Actions -->
    <div
      class="flex flex-col gap-4 items-center justify-between z-40 bg-card p-4 border border-color rounded-lg foreground"
    >
      <div class="w-full">
        <FuzzySearch
          v-model="searchQuery"
          :data="bookmarks"
          :fuse-options="searchFuseOptions"
          placeholder="Search bookmarks..."
          class="w-full"
          @results="handleSearchResults"
        />
      </div>

      <!-- Selection Actions -->
      <template v-if="bookmarkManager.selectionCount > 0">
        <div class="flex items-center gap-4">
          <span class="text-sm text-gray-600"> {{ bookmarkManager.selectionCount }} selected </span>

          <PrimeSelect
            v-model="selectedFolderId"
            :options="folders"
            option-label="name"
            option-value="id"
            placeholder="Move to folder..."
          />
          <PrimeButton
            :disabled="!selectedFolderId || isMoving"
            :loading="isMoving"
            @click="handleMoveSelected"
          >
            {{ isMoving ? 'Moving...' : 'Move' }}
          </PrimeButton>
          <PrimeButton
            severity="danger"
            @click="handleDeleteSelected"
          >
            Delete
          </PrimeButton>

          <PrimeButton
            severity="secondary"
            @click="clearSelection"
          >
            Clear
          </PrimeButton>
        </div>
      </template>
    </div>

    <!-- Content -->
    <div class="space-y-6">
      <!-- Current Folder Info -->
      <div
        v-if="currentFolder"
        class="flex items-center gap-2"
      >
        <div
          class="w-3 h-3 rounded-full"
          :style="{ backgroundColor: currentFolder.color }"
        />
        <h2 class="text-xl font-semibold">{{ currentFolder.name }}</h2>
      </div>

      <!-- Loading State -->
      <div
        v-if="bookmarkStore.loading"
        class="flex items-center justify-center h-64"
      >
        <Icon
          name="mdi:loading"
          class="w-8 h-8 text-gray-400 animate-spin"
        />
      </div>

      <!-- Bookmarks Grid -->
      <div
        v-else
        class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4 lg:gap-8"
      >
        <TransitionGroup
          enter-active-class="transition-all duration-300 ease-out"
          enter-from-class="opacity-0 transform scale-95"
          enter-to-class="opacity-100 transform scale-100"
          leave-active-class="transition-all duration-200 ease-in"
          leave-from-class="opacity-0 transform scale-95"
          leave-to-class="opacity-100 transform scale-100"
        >
          <div
            v-for="bookmark in filteredBookmarks"
            :key="bookmark.id"
            class="relative group"
          >
            <BookmarkCard
              :bookmark="bookmark"
              :selectable="true"
              :is-selected="bookmarkManager.isSelected(bookmark.id).value"
              @select="bookmarkManager.toggleSelection"
            />
          </div>
        </TransitionGroup>
      </div>

      <!-- Empty State -->
      <EmptyState
        v-show="isEmpty"
        :is-searching="searchQuery !== ''"
        class="flex flex-col items-center justify-center h-64 text-gray-500"
      />

      <!-- Confirmation Dialog -->
    </div>
    <PrimeConfirmPopup />
  </div>
</template>

================
File: apps/main-app/pages/auth-callback.vue
================
// pages/auth-callback.vue
<template>
  <div class="w-full h-full flex justify-center items-center">Authenticating...</div>
</template>

<script setup lang="ts">
import { useRoute, useRouter } from 'vue-router'
import { useSupabaseClient } from '#imports'

const route = useRoute()
const router = useRouter()
const supabase = useSupabaseClient()

const isProcessing = ref(false)

const handleAuth = async () => {
  if (isProcessing.value) return
  isProcessing.value = true

  const code = route.query.code as string

  if (!code) {
    console.error('No code found in URL')
    router.push('/login')
    return
  }

  try {
    const { data, error } = await supabase.auth.getSession()

    if (error) throw error

    if (data.session) {
      console.log('Session established:', data.session)
      router.push('/')
    } else {
      throw new Error('No session established')
    }
  } catch (error) {
    console.error('Error during authentication:', error)
    router.push('/login')
  } finally {
    isProcessing.value = false
  }
}

onMounted(() => {
  handleAuth()
})
</script>

================
File: apps/main-app/server/api/ai/ask.ts
================
import { useLogger } from '@ib/logger'
import { openAI } from '~/server/utils/openai/callOpenAI'
import { serverSupabaseUser } from '#supabase/server'

const log = useLogger('API:ASK')

export default defineEventHandler({
  onRequest: [rateLimiter],
  onBeforeResponse: [],
  handler: async (event) => {
    const { messages } = await readBody(event)

    if (!Array.isArray(messages) || messages.length === 0) {
      return {
        statusCode: 400,
        error: {
          message: 'messages must be a non-empty array',
        },
      }
    }

    const isValidMessage = (msg) =>
      msg &&
      typeof msg === 'object' &&
      ['system', 'user', 'assistant'].includes(msg.role) &&
      typeof msg.content === 'string'

    if (!messages.every(isValidMessage)) {
      return {
        statusCode: 400,
        error: {
          message: 'Invalid message format',
        },
      }
    }

    console.log('messages', messages)

    try {
      const user = await serverSupabaseUser(event)
      let chatCompletion

      const plan = user?.app_metadata?.plan

      if (plan === 'free') {
        console.log('getGroqChatCompletion')
        chatCompletion = await getGroqChatCompletion(messages)
      } else if (plan === 'pro' || plan === 'expert') {
        console.log('openAI.createChatCompletion')
        chatCompletion = openAI.createChatCompletion(messages)
      } else {
        log.warn('no user plan', plan)
      }

      return {
        error: null,
        statusCode: 200,
        data: chatCompletion || '',
      }
    } catch (error) {
      log.error('error', error)
      return {
        data: null,
        error,
        statusCode: 500,
      }
    }
  },
})

================
File: apps/main-app/server/api/bookmarks/[id].delete.ts
================
import { serverSupabaseUser, serverSupabaseClient } from '#supabase/server'

// server/api/bookmarks/[id].delete.ts
export default defineEventHandler(async (event) => {
  const user = await serverSupabaseUser(event)
  const bookmarkId = event.context.params.id

  if (!user) {
    throw createError({
      statusCode: 401,
      message: 'Unauthorized',
    })
  }

  const supabase = await serverSupabaseClient(event)

  const { error } = await supabase
    .from('bookmarks')
    .delete()
    .eq('id', bookmarkId)
    .eq('user_id', user.id)

  if (error) {
    throw createError({
      statusCode: 500,
      message: 'Failed to delete bookmark',
    })
  }

  return { success: true }
})

================
File: apps/main-app/server/api/bookmarks/counts.ts
================
// server/api/bookmarks/counts.ts
import { serverSupabaseUser, serverSupabaseClient } from '#supabase/server'

export default defineEventHandler(async (event) => {
  console.log('fetch bookmark counts endpoint fired')
  try {
    const user = await serverSupabaseUser(event)
    if (!user) {
      throw createError({ statusCode: 401, message: 'Unauthorized' })
    }

    const supabase = await serverSupabaseClient(event)

    // Using a raw SQL query with Supabase
    const { data, error } = await supabase.rpc('get_bookmark_counts_by_folder', {
      user_id_param: user.id,
    })

    if (error) throw error

    console.log('FETCHED DATA', data?.length)

    // Transform the data to include uncategorized bookmarks
    const transformedData = data.map((item: any) => ({
      folder_id: item.folder_id || 'uncategorized',
      count: parseInt(item.count),
    }))

    console.log('TRANSFORMED DATA', transformedData)

    return { data: transformedData }
  } catch (error) {
    console.error('Error fetching bookmark counts:', error)
    throw createError({
      statusCode: error.statusCode || 500,
      message: error.message || 'Internal server error',
    })
  }
})

================
File: apps/main-app/server/api/bookmarks/index.ts
================
// server/api/bookmarks/index.ts
import { serverSupabaseUser, serverSupabaseClient } from '#supabase/server'

interface BookmarkMetadata {
  title: string
  url: string
  description?: string
  featured_image?: string
  author?: string
  published_at?: string
}

function normalizeContent(content: any, contentType: string): BookmarkMetadata {
  switch (contentType) {
    case 'news':
      return {
        title: content.title,
        url: content.url,
        description: content.description,
        featured_image: content.featured_image,
        author: content.author,
        published_at: content.published_at,
      }
    case 'research':
      return {
        title: content.title,
        url: content.abstract_url,
        description: content.abstract,
        author: content.authors?.[0], // First author or handle array differently
        published_at: content.published_at,
      }
    case 'newsletters':
      return {
        title: content.title,
        url: content.url,
        description: content.generated_content,
        published_at: content.start_date,
      }
    case 'companies':
      return {
        title: content.name,
        url: content.url,
        description: content.description,
        featured_image: content.logo_url,
      }
    default:
      throw new Error(`Unknown content type: ${contentType}`)
  }
}

// server/api/bookmarks/index.ts
// server/api/bookmarks/index.ts
export default defineEventHandler(async (event) => {
  try {
    const { folder_id = null, include_subfolders = false } = getQuery(event)
    const user = await serverSupabaseUser(event)
    const supabase = await serverSupabaseClient(event)

    if (!user) {
      throw createError({ statusCode: 401, message: 'Unauthorized' })
    }

    let query = supabase
      .from('bookmarks')
      .select(
        `
        *,
        folder:folder_id (
          id,
          name,
          color,
          path,
          is_favorite
        ),
        content:content_id (
          id,
          title,
          url,
          content_type,
          updated_at,
          created_at
        )
      `,
      )
      .eq('user_id', user.id)

    // Modify the query to fetch all bookmarks if no folder_id is provided
    if (folder_id) {
      if (include_subfolders) {
        // Always filter by a folder (either specified or default)
        const { data: folderData } = await supabase
          .from('bookmark_folders')
          .select('path')
          .eq('id', folder_id)
          .single()

        if (folderData?.path) {
          const { data: subFolderIds } = await supabase
            .from('bookmark_folders')
            .select('id')
            .like('path', `${folderData.path}%`)

          query = query.in('folder_id', [
            folder_id,
            ...(subFolderIds?.map((f) => f.id) || []),
          ])
        } else {
          query = query.eq('folder_id', folder_id)
        }
      } else {
        query = query.eq('folder_id', folder_id)
      }
    }

    query = query.order('created_at', { ascending: false })

    const { data: bookmarks, error: bookmarksError } = await query
    if (bookmarksError) throw bookmarksError

    if (!bookmarks?.length) return { data: [] }

    // Group bookmarks by content_type for fetching related data
    const bookmarksByType = bookmarks.reduce(
      (acc, bookmark) => {
        const type = bookmark.content_type
        if (!acc[type]) acc[type] = []
        acc[type].push(bookmark.content_id)
        return acc
      },
      {} as Record<string, string[]>,
    )

    // Fetch all content type specific data in parallel
    const contentTypeData: Record<string, any[]> = {}
    await Promise.all(
      Object.entries(bookmarksByType).map(async ([type, ids]) => {
        const { data, error } = await supabase.from(type).select('*').in('id', ids)
        if (error) throw error
        contentTypeData[type] = data || []
      }),
    )

    // Normalize and merge the data
    const normalizedBookmarks = bookmarks.map((bookmark) => {
      const typeSpecificContent = contentTypeData[bookmark.content_type]?.find(
        (c) => c.id === bookmark.content_id,
      )
      const newMetadata = typeSpecificContent
        ? normalizeContent(typeSpecificContent, bookmark.content_type)
        : null

      return {
        id: bookmark.id,
        user_id: bookmark.user_id,
        content_id: bookmark.content_id,
        content_type: bookmark.content_type,
        created_at: bookmark.created_at,
        updated_at: bookmark.updated_at,
        folder_id: bookmark.folder_id,
        folder: bookmark.folder,
        metadata: {
          ...bookmark.metadata,
          ...newMetadata,
        },
      }
    })

    console.log('Normalized bookmarks:', normalizedBookmarks)

    return { data: normalizedBookmarks }
  } catch (error) {
    console.error('Error in bookmark endpoint:', error)
    throw createError({
      statusCode: error.statusCode || 500,
      message: error.message || 'Internal server error',
    })
  }
})

================
File: apps/main-app/server/api/bookmarks/move.patch.ts
================
import { serverSupabaseUser, serverSupabaseClient } from '#supabase/server'

export default defineEventHandler(async (event: H3Event) => {
  try {
    const user = await serverSupabaseUser(event)
    if (!user) {
      throw createError({ statusCode: 401, message: 'Unauthorized' })
    }

    const supabase = await serverSupabaseClient(event)
    const { bookmarkIds, targetFolderId } = await readBody(event)

    // Verify user owns these bookmarks
    const { data: bookmarks, error: verifyError } = await supabase
      .from('bookmarks')
      .select('id')
      .in('id', bookmarkIds)
      .eq('user_id', user.id)

    if (verifyError || !bookmarks?.length) {
      throw createError({
        statusCode: 400,
        message: 'Invalid bookmark selection',
      })
    }

    // Move bookmarks to new folder
    const { error: updateError } = await supabase
      .from('bookmarks')
      .update({
        folder_id: targetFolderId,
        updated_at: new Date().toISOString(),
      })
      .in('id', bookmarkIds)
      .eq('user_id', user.id)

    if (updateError) throw updateError

    return { success: true }
  } catch (err) {
    console.error('Move bookmarks error:', err)
    throw createError({
      statusCode: err.statusCode || 500,
      message: err.message || 'Internal server error',
    })
  }
})

================
File: apps/main-app/server/api/bookmarks/toggle.ts
================
import { serverSupabaseUser, serverSupabaseClient } from '#supabase/server'

export default defineEventHandler(async (event) => {
  const body = await readBody(event)
  const user = await serverSupabaseUser(event)
  const { content_id, content_type, metadata } = body

  if (!user) {
    return createError({
      status: 401,
      message: 'Unauthorized',
    })
  }

  const supabase = await serverSupabaseClient(event)

  // Check if bookmark exists
  const { data: existing } = await supabase
    .from('bookmarks')
    .select('id')
    .eq('user_id', user.id)
    .eq('content_id', content_id)
    .eq('content_type', content_type)
    .maybeSingle()

  if (existing) {
    // Remove bookmark
    const { error: deleteError } = await supabase
      .from('bookmarks')
      .delete()
      .match({ id: existing.id })

    if (deleteError) {
      throw createError({
        statusCode: 500,
        message: 'Failed to remove bookmark',
      })
    }

    return {
      bookmarked: false,
    }
  }

  // Get default folder if needed
  let folder_id = null
  const { data: defaultFolder } = await supabase
    .from('bookmark_folders')
    .select('id')
    .eq('user_id', user.id)
    .eq('is_default', true)
    .single()

  if (defaultFolder) {
    folder_id = defaultFolder.id
  }

  // Create new bookmark
  const { data: newBookmark, error: bookError } = await supabase
    .from('bookmarks')
    .insert({
      user_id: user.id,
      content_id,
      content_type,
      folder_id,
      metadata: {
        ...metadata,
        bookmarked_at: new Date().toISOString(),
      },
    })
    .select()
    .single()

  if (bookError) {
    throw createError({
      statusCode: 500,
      message: 'Failed to create bookmark',
    })
  }

  return {
    bookmarked: true,
    data: newBookmark,
  }
})

================
File: apps/main-app/server/api/feature/[action].ts
================
import { serverSupabaseClient, serverSupabaseUser } from '#supabase/server'

export default defineEventHandler(async (event) => {
  const client = await serverSupabaseClient(event)
  const user = await serverSupabaseUser(event)
  const action = event.context.params?.action

  if (!user) {
    throw createError({
      statusCode: 401,
      message: 'Unauthorized',
    })
  }

  switch (action) {
    case 'list': {
      const { data: features, error: listError } = await client
        .from('feature_requests')
        .select('*')
        .order('priority')

      if (listError) throw createError({ statusCode: 500, message: listError.message })
      return features
    }

    case 'rank': {
      const body = await readBody(event)
      const { rankings } = body

      const { error: rankError } = await client.from('feature_rankings').upsert(
        {
          user_id: user.id,
          rankings: rankings,
          updated_at: new Date().toISOString(),
        },
        {
          onConflict: 'user_id',
        },
      )

      if (rankError) throw createError({ statusCode: 500, message: rankError.message })
      return { success: true }
    }

    default:
      throw createError({
        statusCode: 400,
        message: 'Invalid action',
      })
  }
})

================
File: apps/main-app/server/api/folders/[id].delete.ts
================
// server/api/folders/[id].delete.ts
import type { H3Event } from 'h3'
import { serverSupabaseUser, serverSupabaseClient } from '#supabase/server'

export default defineEventHandler(async (event: H3Event) => {
  try {
    const user = await serverSupabaseUser(event)
    if (!user) {
      throw createError({ statusCode: 401, message: 'Unauthorized' })
    }

    const supabase = await serverSupabaseClient(event)
    const id = getRouterParam(event, 'id')
    const body = await readBody(event)
    const { strategy, defaultFolderId } = body as {
      strategy: 'delete_all' | 'move_to_default'
      defaultFolderId?: string
    }

    // First try to update/delete bookmarks
    if (strategy === 'delete_all') {
      const { error: deleteError } = await supabase
        .from('bookmarks')
        .delete()
        .eq('folder_id', id)
        .eq('user_id', user.id)

      if (deleteError) {
        console.error('Delete bookmarks error:', deleteError)
        throw deleteError
      }
    } else {
      const { error: updateError } = await supabase
        .from('bookmarks')
        .update({ folder_id: defaultFolderId })
        .eq('folder_id', id)
        .eq('user_id', user.id)

      if (updateError) {
        console.error('Update bookmarks error:', updateError)
        throw updateError
      }
    }

    // Then delete the folder
    const { error: folderError } = await supabase
      .from('bookmark_folders')
      .delete()
      .eq('id', id)
      .eq('user_id', user.id)

    if (folderError) {
      console.error('Delete folder error:', folderError)
      throw folderError
    }

    return { success: true }
  } catch (err) {
    console.error('Folder Delete Error:', err)
    throw createError({
      statusCode: err.statusCode || 500,
      message: err.message || 'Internal server error',
    })
  }
})

================
File: apps/main-app/server/api/folders/[id].patch.ts
================
// server/api/folders/[id].patch.ts
import type { H3Event } from 'h3'
import { serverSupabaseUser, serverSupabaseClient } from '#supabase/server'

export default defineEventHandler(async (event: H3Event) => {
  try {
    const user = await serverSupabaseUser(event)
    if (!user) {
      throw createError({ statusCode: 401, message: 'Unauthorized' })
    }

    const supabase = await serverSupabaseClient(event)
    const id = event.context.params.id
    const updates = await readBody(event)

    // Validate updates
    if (updates.name !== undefined && !updates.name.trim()) {
      throw createError({
        statusCode: 400,
        message: 'Folder name cannot be empty',
      })
    }

    const { data, error } = await supabase
      .from('bookmark_folders')
      .update(updates)
      .eq('id', id)
      .eq('user_id', user.id)
      .select()
      .single()

    if (error) throw error
    return { data }
  } catch (err) {
    console.error('Folder Update Error:', err)
    throw createError({
      statusCode: err.statusCode || 500,
      message: err.message || 'Internal server error',
    })
  }
})

================
File: apps/main-app/server/api/folders/index.ts
================
// server/api/folders/index.ts
import type { H3Event } from 'h3'
import { serverSupabaseUser, serverSupabaseClient } from '#supabase/server'

export default defineEventHandler(async (event: H3Event) => {
  try {
    const user = await serverSupabaseUser(event)
    if (!user) {
      throw createError({ statusCode: 401, message: 'Unauthorized' })
    }

    const supabase = await serverSupabaseClient(event)

    // GET /api/folders
    if (event.method === 'GET') {
      const { data, error } = await supabase
        .from('bookmark_folders')
        .select('*')
        .eq('user_id', user.id)
        .order('position')

      if (error) throw error
      return { data }
    }

    // POST /api/folders
    if (event.method === 'POST') {
      const body = await readBody(event)

      // Validate required fields
      if (!body.name?.trim()) {
        throw createError({
          statusCode: 400,
          message: 'Folder name is required',
        })
      }

      // Get current folder count
      const { count } = await supabase
        .from('bookmark_folders')
        .select('*', { count: 'exact' })
        .eq('user_id', user.id)

      // Validate feature limit
      await validateFeatureLimit(event, 'BOOKMARK_FOLDERS', count || 0)

      // Insert new folder
      const { data, error: insertError } = await supabase
        .from('bookmark_folders')
        .insert({
          ...body,
          user_id: user.id,
          position: count || 0,
        })
        .select()
        .single()

      if (insertError) throw insertError
      return { data }
    }

    throw createError({ statusCode: 405, message: 'Method not allowed' })
  } catch (err) {
    console.error('Folder API Error:', err)
    throw createError({
      statusCode: err.statusCode || 500,
      message: err.message || 'Internal server error',
    })
  }
})

================
File: apps/main-app/server/api/payment/[provider]/create-order.ts
================
// server/api/payment/[provider]/create-order.post.ts
import { useRuntimeConfig } from '#imports'
import { generateServerToken } from '~/server/utils/generateServerToken'

export default defineEventHandler(async (event) => {
  const provider = getRouterParam(event, 'provider')
  const body = await readBody(event)
  const config = useRuntimeConfig().public

  console.log('provider:', provider)

  let backendUrl = config.scraperUrl
  if (provider === 'razorpay') {
    console.log('provider is razorpay')
    backendUrl = backendUrl.concat('/api/customer/subscription/create')
  } else if (provider === 'stripe') {
    backendUrl = backendUrl.concat('/api/customer/subscription/create')
  } else {
    throw createError({
      statusCode: 400,
      statusMessage: 'Invalid payment provider',
    })
  }

  console.log('backendUrl:', backendUrl)

  const token = generateServerToken()

  try {
    const response = await $fetch(backendUrl, {
      method: 'POST',
      body,
      headers: {
        Authorization: `Bearer ${token}`,
      },
    })

    return response
  } catch (error) {
    console.error(`Error creating order with ${provider}:`, error)
    throw createError({
      statusCode: 500,
      statusMessage: `Failed to create order with ${provider}`,
    })
  }
})

================
File: apps/main-app/server/api/payment/[provider]/subscription.get.ts
================
import { useRuntimeConfig } from '#imports'
import { generateServerToken } from '~/server/utils/generateServerToken'

export default defineEventHandler(async (event) => {
  const provider = getRouterParam(event, 'provider')
  const config = useRuntimeConfig().public

  const backendUrl = config.scraperUrl
  if (provider === 'razorpay') {
    backendUrl.concat('/api/customer/subscription')
  } else if (provider === 'stripe') {
    backendUrl.concat('/api/customer/subscription')
  } else {
    throw createError({
      statusCode: 400,
      statusMessage: 'Invalid payment provider',
    })
  }

  const token = generateServerToken()

  try {
    const response = await $fetch(backendUrl, {
      headers: {
        Authorization: `Bearer ${token}`,
      },
    })
    return response
  } catch (error) {
    console.error(`Error fetching subscription from ${provider}:`, error)
    throw createError({
      statusCode: 500,
      statusMessage: `Failed to fetch subscription from ${provider}`,
    })
  }
})

================
File: apps/main-app/server/api/payment/[provider]/verify-payment.post.ts
================
// server/api/payment/[provider]/verify-payment.post.ts
import { useRuntimeConfig } from '#imports'
import { generateServerToken } from '~/server/utils/generateServerToken'

export default defineEventHandler(async (event) => {
  const provider = getRouterParam(event, 'provider')
  const body = await readBody(event)
  const config = useRuntimeConfig().public

  const backendUrl = config.scraperUrl
  if (provider === 'razorpay') {
    backendUrl.concat('/api/customer/subscription/verify-payment')
  } else if (provider === 'stripe') {
    backendUrl.concat('/api/customer/subscription/verify-payment')
  } else {
    throw createError({
      statusCode: 400,
      statusMessage: 'Invalid payment provider',
    })
  }

  const token = generateServerToken()

  try {
    const response = await $fetch(backendUrl, {
      method: 'POST',
      body,
      headers: {
        Authorization: `Bearer ${token}`,
      },
    })
    return response
  } catch (error) {
    console.error(`Error verifying payment with ${provider}:`, error)
    throw createError({
      statusCode: 500,
      statusMessage: `Failed to verify payment with ${provider}`,
    })
  }
})

================
File: apps/main-app/server/api/users/metrics/[action].ts
================
// server/api/users/metrics/[action].ts
import { serverSupabaseClient, serverSupabaseUser } from '#supabase/server'

export default defineEventHandler(async (event) => {
  const client = await serverSupabaseClient(event)
  const user = await serverSupabaseUser(event)
  const action = event.context.params?.action

  if (!user) {
    throw createError({
      statusCode: 401,
      message: 'Unauthorized',
    })
  }

  try {
    switch (action) {
      case 'get':
        return await getUserMetrics(client, user.id)

      case 'track-source-visit': {
        const { newsId, timeSpent } = await readBody(event)
        return await trackSourceVisit(client, user.id, newsId, timeSpent)
      }

      case 'get-achievements':
        return await getAchievements(client, user.id)

      case 'update-title': {
        const { title } = await readBody(event)
        return await updateTitle(client, user.id, title)
      }

      case 'get-reading-time': {
        const { newsId: id } = await readBody(event)
        return await getReadingTime(client, user.id, id)
      }

      default:
        throw createError({
          statusCode: 400,
          message: 'Invalid action',
        })
    }
  } catch (error) {
    console.error(`Metrics API error (${action}):`, error)
    throw createError({
      statusCode: 500,
      message: 'Failed to process metrics action',
    })
  }
})

async function getUserMetrics(client: any, userId: string) {
  // Get user metrics, they should already exist due to our DB triggers
  const { data: metrics, error } = await client
    .from('user_metrics')
    .select('*')
    .eq('user_id', userId)
    .single()

  if (error) throw error

  // Get today's activity for real-time tracking
  const today = new Date().toISOString().split('T')[0]
  const { data: todayVotes } = await client
    .from('votes')
    .select('created_at, vote_type')
    .eq('user_id', userId)
    .gte('created_at', `${today}T00:00:00`)
    .order('created_at', { ascending: false })

  const { data: todayBookmarks } = await client
    .from('bookmarks')
    .select('created_at')
    .eq('user_id', userId)
    .gte('created_at', `${today}T00:00:00`)

  return {
    ...metrics,
    today_activity: {
      votes: todayVotes || [],
      bookmarks: todayBookmarks || [],
    },
  }
}

async function trackSourceVisit(client: any, userId: string, newsId: string, timeSpent: number) {
  // First record the visit
  const { error: visitError } = await client.from('content_source_visits').insert({
    user_id: userId,
    content_id: newsId,
  })

  if (visitError) throw visitError

  // Update reading time if provided
  if (timeSpent) {
    const { error: timeError } = await client
      .from('user_metrics')
      .update({
        total_reading_time: timeSpent,
      })
      .eq('user_id', userId)

    if (timeError) throw timeError
  }

  return await getUserMetrics(client, userId)
}

async function getAchievements(client: any, userId: string) {
  const { data: metrics, error } = await client
    .from('user_metrics')
    .select('achievements')
    .eq('user_id', userId)
    .single()

  if (error) throw error

  // Get completed achievements count
  const completedCount = countCompletedAchievements(metrics.achievements)

  return {
    achievements: metrics.achievements,
    stats: {
      completed: completedCount,
      total: getTotalAchievements(metrics.achievements),
    },
  }
}

async function updateTitle(client: any, userId: string, newTitle: string) {
  const { data: metrics, error } = await client
    .from('user_metrics')
    .select('titles')
    .eq('user_id', userId)
    .single()

  if (error) throw error

  // Verify title is unlocked
  if (!metrics.titles.unlocked_titles.includes(newTitle)) {
    throw createError({
      statusCode: 400,
      message: 'Title not unlocked',
    })
  }

  const { data: updatedMetrics, error: updateError } = await client
    .from('user_metrics')
    .update({
      titles: {
        ...metrics.titles,
        current_title: newTitle,
      },
    })
    .eq('user_id', userId)
    .select()
    .single()

  if (updateError) throw updateError
  return updatedMetrics
}

async function getReadingTime(client: any, userId: string, newsId: string) {
  const { data, error } = await client
    .from('source_visits')
    .select('created_at')
    .eq('user_id', userId)
    .eq('content_id', newsId)
    .order('created_at', { ascending: false })
    .limit(1)

  if (error) throw error

  return {
    lastVisit: data?.[0]?.created_at || null,
  }
}

// Utility functions
function updateFavoriteSources(currentSources: string[], newSource: string) {
  const sourceList = [...(currentSources || [])]
  if (!sourceList.includes(newSource)) {
    sourceList.push(newSource)
  }
  return sourceList.slice(-5) // Keep only last 5 sources
}

function countCompletedAchievements(achievements: any) {
  let count = 0
  for (const category in achievements) {
    for (const achievement in achievements[category]) {
      if (achievements[category][achievement] === true) {
        count++
      }
    }
  }
  return count
}

function getTotalAchievements(achievements: any) {
  let count = 0
  for (const category in achievements) {
    count += Object.keys(achievements[category]).length
  }
  return count
}

================
File: apps/main-app/server/api/users/metrics.ts
================
// server/api/users/metrics.ts
import { serverSupabaseClient, serverSupabaseUser } from '#supabase/server'

export default defineEventHandler(async (event) => {
  const client = await serverSupabaseClient(event)
  const user = await serverSupabaseUser(event)

  if (!user) {
    throw createError({
      statusCode: 401,
      message: 'Unauthorized',
    })
  }

  try {
    // Get all user votes first
    const { data: votes, error: votesError } = await client
      .from('votes')
      .select('*')
      .eq('user_id', user.id)
      .eq('content_type', 'news')
      .order('created_at', { ascending: false })

    if (votesError) throw votesError

    // If we have votes, get the corresponding news items
    if (votes && votes.length > 0) {
      const newsIds = votes.map((vote) => vote.content_id)

      // Get news items for accuracy calculation
      const { data: newsItems, error: newsError } = await client
        .from('news')
        .select('id, score')
        .in('id', newsIds)

      if (newsError) throw newsError

      // Create a lookup map for news scores
      const newsScores =
        newsItems?.reduce(
          (acc, news) => {
            acc[news.id] = news.score
            return acc
          },
          {} as Record<string, number>,
        ) || {}

      // Combine votes with news scores
      const votesWithScores = votes.map((vote) => ({
        ...vote,
        news_score: newsScores[vote.content_id] || 0,
      }))

      return {
        votes: votesWithScores,
        streakData: votes, // For streak calculation
        // Group votes by date for easier processing
        votesByDate: votes.reduce(
          (acc, vote) => {
            const date = new Date(vote.created_at).toISOString().split('T')[0]
            if (!acc[date]) acc[date] = []
            acc[date].push(vote)
            return acc
          },
          {} as Record<string, any[]>,
        ),
      }
    }

    return {
      votes: [],
      streakData: [],
      votesByDate: {},
    }
  } catch (error) {
    console.error('Get user metrics error:', error)
    throw createError({
      statusCode: 500,
      message: 'Failed to get user metrics',
    })
  }
})

================
File: apps/main-app/server/api/users/update.post.ts
================
import { serverSupabaseClient } from '#supabase/server'

export default defineEventHandler(async (event) => {
  try {
    const body = await readBody(event)

    const supabase = await serverSupabaseClient(event)

    const { data } = await supabase.auth.getUser()
    const { user } = data

    if (user && user.email) {
      const response = await supabase.from('user_profiles').update(body).eq('id', user.id)

      if (response.error) {
        return {
          error: response.error,
          data: [],
          status: 500,
          message: 'Error Updating User',
        }
      } else {
        return {
          error: null,
          data: [],
          status: 200,
          message: 'User Updated',
        }
      }
    }

    return {
      error: null,
      data: [],
      status: 500,
      message: 'Something went wrong',
    }
  } catch (error) {
    return {
      error,
      data: [],
      status: 500,
      message: 'Error',
    }
  }
})

================
File: apps/main-app/server/api/votes/[contentType]/[id].get.ts
================
import { serverSupabaseClient, serverSupabaseUser } from '#supabase/server'

export default defineEventHandler(async (event) => {
  const client = await serverSupabaseClient(event)
  const user = await serverSupabaseUser(event)

  if (!user) {
    throw createError({
      statusCode: 401,
      message: 'Unauthorized',
    })
  }

  const { contentType, id } = event.context.params

  try {
    const { data, error } = await client
      .from('votes')
      .select('vote_type')
      .match({
        content_type: contentType,
        content_id: id,
        user_id: user.id,
      })
      .single()

    if (error && error.code !== 'PGRST116') throw error

    return {
      voteType: data?.vote_type || null,
    }
  } catch (error) {
    console.error('Get vote error:', error)
    throw createError({
      statusCode: 500,
      message: 'Failed to get vote status',
    })
  }
})

================
File: apps/main-app/server/api/votes/[contentType]/[id].post.ts
================
import { serverSupabaseClient, serverSupabaseUser } from '#supabase/server'

export default defineEventHandler(async (event) => {
  const client = await serverSupabaseClient(event)
  const user = await serverSupabaseUser(event)

  if (!user) {
    throw createError({
      statusCode: 401,
      message: 'Unauthorized',
    })
  }

  const { contentType, id } = event.context.params
  const { voteType } = await readBody(event)

  // Validate content type (only news for now)
  if (contentType !== 'news') {
    throw createError({
      statusCode: 400,
      message: 'Invalid content type',
    })
  }

  // Validate vote type
  if (![1, -1].includes(voteType)) {
    throw createError({
      statusCode: 400,
      message: 'Invalid vote type',
    })
  }

  try {
    // Handle vote removal if same vote type is sent
    const { data: existingVote } = await client
      .from('votes')
      .select('vote_type')
      .match({
        content_type: contentType,
        content_id: id,
        user_id: user.id,
      })
      .single()

    if (existingVote?.vote_type === voteType) {
      // Remove the vote if it's the same type
      const { error } = await client.from('votes').delete().match({
        content_type: contentType,
        content_id: id,
        user_id: user.id,
      })

      if (error) throw error
      return { success: true, action: 'removed' }
    }

    // Insert or update the vote
    const { error } = await client.from('votes').upsert(
      {
        content_type: contentType,
        content_id: id,
        user_id: user.id,
        vote_type: voteType,
      },
      {
        onConflict: 'content_type,content_id,user_id',
      },
    )

    if (error) throw error
    return { success: true, action: 'voted' }
  } catch (error) {
    console.error('Vote error:', error)
    throw createError({
      statusCode: 500,
      message: 'Failed to process vote',
    })
  }
})

================
File: apps/main-app/server/api/votes/user/[voteType].get.ts
================
import { serverSupabaseClient, serverSupabaseUser } from '#supabase/server'

export default defineEventHandler(async (event) => {
  const client = await serverSupabaseClient(event)
  const user = await serverSupabaseUser(event)

  if (!user) {
    throw createError({
      statusCode: 401,
      message: 'Unauthorized',
    })
  }

  const voteType = parseInt(event.context.params.voteType) // 1 for upvotes, -1 for downvotes

  if (![1, -1].includes(voteType)) {
    throw createError({
      statusCode: 400,
      message: 'Invalid vote type',
    })
  }

  try {
    const { data, error } = await client
      .from('votes')
      .select('content_id')
      .eq('content_type', 'news')
      .eq('user_id', user.id)
      .eq('vote_type', voteType)

    if (error) throw error

    // Get the actual news items
    const { data: news, error: newsError } = await client
      .from('news')
      .select('*')
      .in(
        'id',
        data.map((v) => v.content_id),
      )
      .order('created_at', { ascending: false })

    if (newsError) throw newsError

    return news
  } catch (error) {
    console.error('Get voted news error:', error)
    throw createError({
      statusCode: 500,
      message: 'Failed to get voted news',
    })
  }
})

================
File: apps/main-app/server/api/votes/user.get.ts
================
import { serverSupabaseClient, serverSupabaseUser } from '#supabase/server'

export default defineEventHandler(async (event) => {
  const client = await serverSupabaseClient(event)
  const user = await serverSupabaseUser(event)

  if (!user) {
    throw createError({
      statusCode: 401,
      message: 'Unauthorized',
    })
  }

  try {
    const { data, error } = await client
      .from('votes')
      .select('content_id, vote_type')
      .eq('content_type', 'news')
      .eq('user_id', user.id)

    if (error) throw error

    // Transform into a more efficient lookup object
    const voteLookup = data.reduce(
      (acc, vote) => {
        acc[vote.content_id] = vote.vote_type
        return acc
      },
      {} as Record<string, number>,
    )

    return {
      votes: voteLookup,
    }
  } catch (error) {
    console.error('Get votes error:', error)
    throw createError({
      statusCode: 500,
      message: 'Failed to get votes',
    })
  }
})

================
File: apps/main-app/server/api/webhook/database.ts
================
export default defineEventHandler(async (event) => {
  const data = await readBody(event)

  console.log('SUPABASE DB WEBHOOK EVENT', data)
})

================
File: apps/main-app/server/api/upload.ts
================
import crypto from 'crypto'
import { defineEventHandler, createError } from 'h3'
import { PDFDocument } from 'pdf-lib'
import lame from 'node-lame'
import ffmpeg from 'fluent-ffmpeg'
import { serverSupabaseClient } from '#supabase/server'

// Base optimizer interface
interface FileOptimizer {
  optimize(
    buffer: Buffer,
    options: any,
  ): Promise<{
    data: Buffer
    extension: string
    mimeType: string
  }>
}

// Image optimizer using Sharp
// class ImageOptimizer implements FileOptimizer {
//   async optimize(buffer: Buffer, options: any) {
//     const { maxWidth = 1920, maxHeight = 1080, quality = 80 } = options
//     const optimized = await sharp(buffer)
//       .resize(maxWidth, maxHeight, { fit: 'inside', withoutEnlargement: true })
//       .webp({ quality })
//       .toBuffer()
//     return { data: optimized, extension: 'webp', mimeType: 'image/webp' }
//   }
// }

// PDF optimizer using pdf-lib
class PDFOptimizer implements FileOptimizer {
  async optimize(buffer: Buffer, options: any) {
    const pdfDoc = await PDFDocument.load(buffer)
    // Implement PDF optimization logic here
    const optimized = await pdfDoc.save({ useObjectStreams: false })
    return { data: Buffer.from(optimized), extension: 'pdf', mimeType: 'application/pdf' }
  }
}

class VideoOptimizer implements FileOptimizer {
  async optimize(buffer: Buffer, options: any) {
    const {
      maxWidth = 1920,
      maxHeight = 1080,
      videoBitrate = '1000k',
      audioBitrate = '128k',
    } = options

    return new Promise((resolve, reject) => {
      ffmpeg()
        .input(buffer)
        .videoFilters(
          `scale='min(${maxWidth},iw)':min'(${maxHeight},ih)':force_original_aspect_ratio=decrease`,
        )
        .videoBitrate(videoBitrate)
        .audioBitrate(audioBitrate)
        .toFormat('mp4')
        .on('end', (stdout, stderr) => {
          resolve({ data: stdout, extension: 'mp4', mimeType: 'video/mp4' })
        })
        .on('error', reject)
        .pipe()
    })
  }
}

class AudioOptimizer implements FileOptimizer {
  async optimize(buffer: Buffer, options: any) {
    const { bitrate = 128 } = options

    const encoder = new lame.Lame({
      output: 'buffer',
      bitrate: bitrate,
    }).setBuffer(buffer)

    const encodedBuffer = await encoder.encode()
    return { data: encodedBuffer, extension: 'mp3', mimeType: 'audio/mpeg' }
  }
}

// Optimizer factory
class OptimizerFactory {
  private optimizers: Map<string, FileOptimizer> = new Map()

  register(mimeType: string, optimizer: FileOptimizer) {
    this.optimizers.set(mimeType, optimizer)
  }

  getOptimizer(mimeType: string): FileOptimizer | undefined {
    return this.optimizers.get(mimeType)
  }
}

// Create and configure the optimizer factory
const optimizerFactory = new OptimizerFactory()
// optimizerFactory.register('image', new ImageOptimizer())
optimizerFactory.register('application/pdf', new PDFOptimizer())
optimizerFactory.register('video', new VideoOptimizer())
optimizerFactory.register('audio', new AudioOptimizer())

export default defineEventHandler(async (event) => {
  console.log('File optimization and upload eventHandler')
  const form = await readMultipartFormData(event)
  if (!form?.length) {
    throw createError({ statusCode: 400, statusMessage: 'No form data provided' })
  }

  const userId = form.find((item) => item.name === 'userId')?.data.toString()
  const fileType = form.find((item) => item.name === 'fileType')?.data.toString()
  const bucket = form.find((item) => item.name === 'bucket')?.data.toString()
  const path = form.find((item) => item.name === 'path')?.data.toString()
  const optimizationOptions = JSON.parse(
    form.find((item) => item.name === 'optimizationOptions')?.data.toString() || '{}',
  )

  const file = form.find((item) => item.name === 'file')
  if (!file) {
    throw createError({ statusCode: 400, statusMessage: 'No file provided' })
  }

  if (!userId || !fileType || !bucket || !path) {
    throw createError({ statusCode: 400, statusMessage: 'Missing required parameters' })
  }

  const fileName = `${fileType}-${crypto.randomUUID()}`
  const mimeType = file.type || 'application/octet-stream'

  console.log('Processing file:', userId, fileType, fileName, mimeType)

  try {
    let optimizedFile: Buffer
    let finalExtension: string
    let finalMimeType: string

    const optimizerKey = mimeType.split('/')[0]
    const optimizer
      = optimizerFactory.getOptimizer(optimizerKey) || optimizerFactory.getOptimizer(mimeType)

    if (optimizer) {
      const result = await optimizer.optimize(file.data, optimizationOptions)
      optimizedFile = result.data
      finalExtension = result.extension
      finalMimeType = result.mimeType
    } else {
      console.log('No optimizer found for this file type, uploading as-is')
      optimizedFile = file.data
      finalExtension = mimeType.split('/')[1]
      finalMimeType = mimeType
    }

    const client = await serverSupabaseClient(event)
    const { error } = await client.storage
      .from(bucket)
      .upload(`${path}/${fileName}.${finalExtension}`, optimizedFile, {
        contentType: finalMimeType,
        cacheControl: '3600',
        upsert: true,
      })

    if (error) {
      throw createError({ statusCode: 500, statusMessage: error.message })
    }

    // If this is a profile-related upload, update the user_profiles table
    if (bucket === 'user-profiles' && ['avatar', 'cover-photo'].includes(fileType)) {
      const { error: updateError, data } = await client
        .from('user_profiles')
        .update({ [fileType]: `${fileName}.${finalExtension}` })
        .eq('id', userId)
        .select()

      if (updateError) {
        console.error('Error updating user profile:', updateError)
      } else {
        console.log('User profile updated:', data)
      }
    }

    return {
      statusCode: 200,
      body: JSON.stringify({
        message: 'File successfully uploaded and optimized',
        fileName: `${fileName}.${finalExtension}`,
      }),
    }
  } catch (error: any) {
    console.error('Error processing file:', error)
    throw createError({ statusCode: 500, statusMessage: error.message })
  }
})

================
File: apps/main-app/server/middleware/feature-limit.ts
================
import { handleFeatureLimitError } from '../utils/errors'
import { validateFeatureLimit } from '../utils/featureLimits'
import { serverSupabaseUser, serverSupabaseClient } from '#supabase/server'

export default defineEventHandler(async (event) => {
  // Only check POST requests
  if (event.method !== 'POST') return

  // Get the path to determine which feature to check
  const path = getRequestPath(event)

  // Map endpoints to features
  const featureMap: Record<string, string> = {
    '/api/bookmarks': 'BOOKMARKS',
    '/api/folders': 'BOOKMARK_FOLDERS',
  }

  const feature = featureMap[path]
  if (!feature) return // Not a feature-limited endpoint

  try {
    const user = await serverSupabaseUser(event)

    if (!user) {
      throw createError({
        statusCode: 401,
        message: 'Unauthorized',
      })
    }

    const supabase = await serverSupabaseClient(event)

    // Get the table name from the path
    let table = path.split('/')[2] // 'bookmarks' or 'folders'

    if (table === 'folders') {
      table = 'bookmark_folders'
    }

    // Check current count
    const { count } = await supabase
      .from(table)
      .select('*', { count: 'exact' })
      .eq('user_id', user.id)

    await validateFeatureLimit(event, feature, count ?? 0)
  } catch (error) {
    handleFeatureLimitError(error)
  }
})

================
File: apps/main-app/server/utils/errors.ts
================
export const handleFeatureLimitError = (error: any) => {
  // Feature limit errors
  if (error.statusCode === 403) {
    throw createError({
      statusCode: 403,
      message: error.message || 'Feature limit reached',
      data: {
        code: 'FEATURE_LIMIT_REACHED',
      },
    })
  }

  // Auth errors
  if (error.statusCode === 401) {
    throw createError({
      statusCode: 401,
      message: 'Authentication required',
      data: {
        code: 'AUTH_REQUIRED',
      },
    })
  }

  // Validation errors
  if (error.statusCode === 400) {
    throw createError({
      statusCode: 400,
      message: error.message || 'Invalid request',
      data: {
        code: 'VALIDATION_ERROR',
      },
    })
  }

  // Default error
  throw createError({
    statusCode: error.statusCode || 500,
    message: error.message || 'An unexpected error occurred',
    data: {
      code: 'INTERNAL_SERVER_ERROR',
    },
  })
}

================
File: apps/main-app/nuxt.config.ts
================
import { fileURLToPath } from 'url'
import { dirname, join, resolve } from 'path'
import { defineNuxtConfig } from 'nuxt/config'
import runtimeConfig from '../../shared-runtime.config'

const currentDir = dirname(fileURLToPath(import.meta.url))

export default defineNuxtConfig({
  workspaceDir: '../../',
  srcDir: '.',
  extends: ['../../layers/base', '../../layers/auth', '../../layers/crud'],

  vite: {
    optimizeDeps: {
      exclude: ['fsevents'],
    },
  },

  // Add this to your Nuxt config temporarily
  hooks: {
    'imports:dirs'(dirs) {
      console.log('Import directories:', dirs)
    },
  },

  build: {
    transpile: ['@formbricks/js'],
  },

  plugins: [{ src: '~/plugins/formbricks.client.ts' }],

  debug: true,

  modules: [
    'nuxt-tiptap-editor',
    '@nuxt/devtools',
    '@vueuse/nuxt',
    '@nuxt/image',
    '@pinia/nuxt',
    '@nuxt/icon',
    '@nuxt/eslint',
    '@nuxtjs/tailwindcss',
    '@nuxtjs/mdc',
    '@primevue/nuxt-module',
    '@vite-pwa/nuxt',
    '@nuxt/test-utils/module',
  ],

  experimental: {
    asyncContext: true,
  },

  tailwindcss: {
    configPath: `${currentDir}/tailwind.config.ts`,
    cssPath: [`${currentDir}/assets/css/tailwind.css`, { injectPosition: 0 }],
    exposeConfig: true,
    viewer: true,
  },

  primevue: {
    importPT: { from: resolve(currentDir, '../../theme/index.js') },
    autoImport: true,
    components: {
      prefix: 'Prime',
      include: '*',
      exclude: ['Editor'],
    },

    composables: {
      include: '*',
    },

    options: {
      ripple: true,
      unstyled: true,
      theme: {
        options: {
          cssLayer: true,
        },
      },
    },
  },

  image: {
    format: ['webp', 'jpg'],
  },

  tiptap: {
    prefix: 'Tiptap',
  },

  pwa: {
    registerType: 'autoUpdate',
    manifest: false, // We'll use our own manifest file
    workbox: {
      navigateFallback: '/offline',
      globPatterns: ['**/*.{js,css,html,ico,png,svg}'],
      cleanupOutdatedCaches: true,
      runtimeCaching: [
        {
          urlPattern: /^\/api\//,
          handler: 'NetworkFirst',
        },
      ],
    },
    client: {
      installPrompt: true,
    },
  },

  alias: {
    '#shared': fileURLToPath(new URL('./shared', import.meta.url)),
  },

  // Add proper MIME type handling
  nitro: {
    routeRules: {
      '/manifest.webmanifest': {
        headers: {
          'Content-Type': 'application/manifest+json',
          'Cache-Control': 'public, max-age=0',
        },
      },
      '/api/bookmarks/**': {
        appMiddleware: ['feature-limit'],
      },
      '/api/folders/**': {
        appMiddleware: ['feature-limit'],
      },
    },
    alias: {
      '#shared': fileURLToPath(new URL('./shared', import.meta.url)),
    },
  },

  ...runtimeConfig,
})

================
File: apps/monitoring-dashboard/middleware/is-super-admin.ts
================
export default defineNuxtRouteMiddleware(async (to, from) => {
  const user = useSupabaseUser()

  // Check for super_admin role
  const role = user.app_metadata?.role || []
  if (role !== 'super_admin') {
    console.log('Not super_admin')
    // return navigateTo('/not-authorized')
  }
})

================
File: apps/monitoring-dashboard/pages/not-authorized.vue
================
<template>
  <div> you are not authorized to see this </div>
</template>

<script setup lang="ts"></script>

<style scoped></style>

================
File: apps/monitoring-dashboard/server/api/logs.get.ts
================
// server/api/logs.get.ts

import { defineEventHandler } from 'h3'
import { InfluxDB } from '@influxdata/influxdb-client'

export default defineEventHandler(async (event) => {
  const config = useRuntimeConfig()

  // Create InfluxDB client
  const influxDB = new InfluxDB({
    url: config.influxUrl,
    token: config.influxToken,
  })

  const queryApi = influxDB.getQueryApi(config.influxOrg)

  // Extract query parameters if needed
  const queryParams = getQuery(event)

  // Build InfluxDB query
  const query = `from(bucket: "${config.influxBucket}")
    |> range(start: -1h)
    |> filter(fn: (r) => r._measurement == "logs")`

  const data = []
  await queryApi.collectRows(query, {
    next: (row) => data.push(row),
    error: (error) => console.error(error),
    complete: () => console.log('Query completed'),
  })

  return data
})

================
File: apps/monitoring-dashboard/nuxt.config.ts
================
import { fileURLToPath } from 'url'
import { dirname, join, resolve } from 'path'
import { defineNuxtConfig } from 'nuxt/config'
import runtimeConfig from '../../shared-runtime.config'

const currentDir = dirname(fileURLToPath(import.meta.url))

export default defineNuxtConfig({
  workspaceDir: '../../',
  srcDir: '.',
  extends: ['../../layers/base', '../../layers/auth'],
  modules: ['@primevue/nuxt-module'],

  routeRules: {
    '/**': { appMiddleware: 'auth' },
  },

  tailwindcss: {
    configPath: `${currentDir}/tailwind.config.ts`,
    cssPath: [`${currentDir}/assets/css/tailwind.css`, { injectPosition: 0 }],
    exposeConfig: true,
    viewer: true,
  },

  primevue: {
    importPT: { from: resolve(currentDir, '../../theme/index.js') },
    autoImport: true,
    components: {
      prefix: 'Prime',
      include: '*',
      exclude: ['Editor'],
    },

    composables: {
      include: '*',
    },

    options: {
      ripple: true,
      unstyled: true,
      theme: {
        options: {
          cssLayer: {
            name: 'primevue',
            order: 'tailwind-base, primevue, tailwind-utilities',
          },
        },
      },
    },
  },

  imports: {
    autoImport: true,
  },

  ...runtimeConfig,
})

================
File: apps/website/components/blog/article/BlogArticle.vue
================
<script setup lang="ts">
const { width } = useWindowSize()

const expandToc = computed(() => width.value < 1280)

const articleContent = ref<HTMLElement | null>(null)
const articleHtml = ref<string>('')

const p = defineProps({
  article: {
    type: Object as PropType<ArticleFullT>,
    required: true,
  },
})

console.log('Props Article:', p.article)

const ast = ref<MDCParserResult | null>(null)
const parse = useMarkdownParser()

// Function to render blocks as markdown
const renderBlocksAsMarkdown = (blocks) => {
  return blocks
    .map((block) => {
      if (block.__component === 'shared.rich-text') {
        return block.body
      }
      // Add more conditions for other block types if needed
      return ''
    })
    .join('\n\n')
}

onBeforeMount(async () => {
  if (p.article.blocks) {
    const markdown = renderBlocksAsMarkdown(p.article.blocks)
    ast.value = await parse(markdown)
  }
})

interface TocLink {
  id: string
  text: string
  depth: number
  children: TocLink[]
}

const extractToc = (markdown: any): TocLink[] => {
  const tocLinks: TocLink[] = []
  let currentH2: TocLink | null = null

  console.log('Markdown:', markdown)

  markdown.forEach((block) => {
    const lines = block.body.split('\n')

    lines.forEach((line) => {
      const match = line.match(/^(##|###)\s+(.+)$/)
      if (match) {
        const depth = match[1].length // 2 for h2, 3 for h3
        const text = match[2].trim()

        // Generate an id from the text
        const id = text
          .toLowerCase()
          .replace(/\s+/g, '-')
          .replace(/[^\w-]+/g, '')

        const tocLink: TocLink = { id, text, depth, children: [] }

        if (depth === 2) {
          currentH2 = tocLink
          tocLinks.push(tocLink)
        } else if (depth === 3) {
          if (currentH2) {
            currentH2.children.push(tocLink)
          } else {
            // If there's no current H2, treat H3 as top-level
            tocLinks.push(tocLink)
          }
        }
      }
    })
  })

  return tocLinks
}

watch(
  () => articleContent.value,
  async (newVal) => {
    if (newVal && ast.value) {
      await new Promise((resolve) => setTimeout(resolve, 1000))
      articleHtml.value = newVal.innerHTML
    }
  },
)

console.log('Article:', p.article)
</script>

<template>
  <div class="max-w-full pb-10">
    <main>
      <BlogArticleHero :article="article" />
      <div
        class="padded-x grid grid-cols-[minmax(300px,700px)] justify-center pt-8 xl:grid-cols-[minmax(240px,1fr)_minmax(660px,740px)_minmax(240px,1fr)] xl:gap-8"
      >
        <div class="w-full xl:col-start-1">
          <BlogArticleToc
            v-if="article.blocks"
            class="background border-color rounded-md border p-4 xl:sticky xl:left-0 xl:top-24 xl:border-none xl:p-0"
            :toc="extractToc(article.blocks)"
            :updated-at="article.updatedAt"
            :expanded="expandToc"
          />
        </div>
        <div class="xl:padded-x xl:col-start-2">
          <div class="pb-12">
            <div
              ref="articleContent"
              class="mx-auto space-y-8"
            >
              <Suspense>
                <MDCRenderer
                  v-if="ast?.body"
                  class="nuxt-content"
                  :body="ast.body"
                  :data="ast.data"
                />
              </Suspense>
            </div>
            <BlogArticleShare
              :link="article.slug"
              :summary="article.description"
            />
            <BlogArticleAuthorCard :authors="[article.author]" />
          </div>
        </div>
      </div>
    </main>
  </div>
</template>

<style>
.nuxt-content p {
  font-size: 18px;
  margin-bottom: 22px;
  line-height: 1.65;
  font-family: 'Open Sans', sans-serif;
}

.nuxt-content h2,
.nuxt-content h3,
.nuxt-content h4,
.nuxt-content h5,
.nuxt-content h6 {
  text-decoration: none;
  margin-bottom: 18px;
  font-family: 'Oswald', 'sans-serif';
  font-weight: 700;
}

/* Golden Ratio for heading sizes */
.nuxt-content h2 {
  margin-top: 24px;
  font-size: 36px;
  line-height: 1.6;
}

.nuxt-content h3 {
  margin-top: 2.8rem;
  font-size: 28px;
  line-height: 1.6;
}

.nuxt-content h4 {
  font-size: 22px;
  line-height: 1.3;
}

.nuxt-content ul,
ol {
  margin-bottom: 28px;
  font-family: 'Open Sans', sans-serif;
}

.nuxt-content ul {
  list-style: disc;
}

.nuxt-content ol {
  list-style: decimal;
}

.nuxt-content li {
  margin-left: 1.6rem;
  font-size: 18px;
  margin-bottom: 22px;
  line-height: 1.55;
}

.nuxt-content p a {
  color: #10b981;
  text-decoration: none;
  font-weight: 500;
}

@media (max-width: 768px) {
  .nuxt-content p {
    font-size: 16px;
    line-height: 1.6;
    margin-bottom: 16px;
    font-family: 'Open Sans', sans-serif;
  }

  .nuxt-content li {
    font-size: 16px;
  }

  .nuxt-content h2 {
    margin-top: 10px;
    font-size: 30px;
    line-height: 1.6;
  }

  .nuxt-content h3 {
    margin-top: 2.8rem;
    font-size: 26px;
    line-height: 1.6;
  }

  .nuxt-content h4 {
    font-size: 22px;
    line-height: 1.3;
  }

  .nuxt-content li {
    margin-left: 1.6rem;
    font-size: 16px;
    margin-bottom: 22px;
    line-height: 1.55;
  }
}
</style>

================
File: apps/website/components/blog/article/BlogArticleAuthor.vue
================
<script setup lang="ts">
import { useDateFormat } from '@vueuse/core'

defineProps<{
  authors: any[]
  publishedAt: string
}>()
</script>

<template>
  <div
    v-if="authors && authors.length > 0"
    class="flex flex-col items-center"
  >
    <div class="flex items-center">
      <template
        v-for="(author, index) in authors"
        :key="author?.id"
      >
        <div
          v-if="index > 0"
          class="text-lg mx-2 font-bold"
        >
          &
        </div>
        <div class="flex flex-col items-center">
          <IBImage
            v-if="author"
            :img="{
              src: `${author.avatar.url}`,
              alt: `${author.name} is an author on the AstronEra Blog`,
              width: '44px',
              height: '44px',
            }"
            class="border-color rounded-full border"
          />
          <p
            v-if="author"
            class="mt-2 text-center text-sm font-semibold"
          >
            {{ author.name }}<br />
          </p>
        </div>
      </template>
    </div>
    <p class="mt-4 text-sm"> Published: {{ useDateFormat(publishedAt, 'DD MMM YYYY').value }} </p>
  </div>
</template>

<style scoped></style>

================
File: apps/website/components/blog/article/BlogArticleAuthorCard.vue
================
<script setup lang="ts">
defineProps<{
  authors: any[]
}>()
</script>

<template>
  <div
    v-if="authors"
    class="grid grid-cols-1 gap-4 md:grid-cols-2 xl:gap-8"
  >
    <div
      v-for="(author, i) in authors"
      :key="`author-${i}`"
      class="border-color foreground flex h-full flex-col items-center gap-4 rounded-xl border p-4 xl:p-8"
    >
      <div>
        <IBImage
          v-if="author"
          :img="{
            src: `${author.avatar.url}`,
            alt: `${author.name} is an author on the AstronEra Blog`,
            width: 100,
            height: 100,
          }"
          class="h-full rounded-full sm:max-w-[100px]"
        />
      </div>
      <div
        v-if="author"
        class="w-full space-y-1 text-left"
      >
        <h4 class="text-xl font-semibold"> About {{ author.name }} </h4>
        <div class="flex items-center gap-2">
          <!-- <IBSocialBlock
            v-if="author.socials"
            size="24px"
            :socials="author.socials"
          /> -->
          <PrimeTag class="text-sm uppercase text-primary-600"> follow me </PrimeTag>
        </div>
        <p class="text-sm">
          {{ author.bio }}
        </p>
      </div>
    </div>
  </div>
</template>

<style scoped></style>

================
File: apps/website/components/blog/article/BlogArticleHero.vue
================
<template>
  <div class="foreground relative flex w-full items-center justify-center pb-12 pt-16">
    <div class="flex w-full max-w-[1140px] flex-col">
      <IBBreadcrumbs class="px-4 py-10" />
      <NuxtImg
        v-if="article.cover"
        provider="strapi"
        :src="article.cover.url.replace('/uploads/', '')"
        :width="article.cover.width"
        :height="article.cover.height"
        :alt="article.cover.alternativeText || article.title"
        class="relative md:rounded-md"
      />
      <div
        class="flex w-full flex-col items-start justify-between gap-12 rounded-md p-3 md:flex-row-reverse"
      >
        <div class="flex flex-wrap gap-4">
          <PrimeTag
            v-if="article.category"
            :value="article.category.name"
            class="text-nowrap text-sm"
          />
          <PrimeTag
            v-for="tag in article.tags"
            :key="tag.name"
            :value="tag.name"
            class="text-nowrap text-sm"
          />
          <!-- Add tags here if you have them in your data structure -->
        </div>
        <BlogArticleAuthor
          :authors="[article.author]"
          :published-at="article.publishedAt"
        />
      </div>
      <div
        class="padded-x relative z-10 mx-auto flex w-full max-w-[740px] flex-col items-start gap-8 rounded-md pt-8"
      >
        <h1 class="font-[Oswald] text-4xl font-semibold lg:text-center xl:text-5xl">
          {{ article.title }}
        </h1>
        <div class="border-color w-full rounded-md border p-4 xl:p-8 bg-primary-950">
          <p class="text-xl">
            {{ article.description }}
          </p>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import type { ArticleFullT } from '~/types/articles'

defineProps({
  article: {
    type: Object as PropType<ArticleFullT>,
    required: true,
  },
})
</script>

<style scoped></style>

================
File: apps/website/components/blog/card/BlogCard.vue
================
<script setup lang="ts">
import { useDateFormat } from '@vueuse/core'

const p = defineProps({
  article: {
    type: Object,
    required: true,
  },
})

// "/uploads/Screenshot_2024_10_09_at_11_34_50_AM_3839858f26.png"

console.log('Article:', p.article)
</script>

<template>
  <PrimeCard v-if="article">
    <template #header>
      <BlogCatTag
        v-if="article.tags"
        :tags="article.tags"
        :category="article.category"
        class="p-4"
      />
      <NuxtImg
        provider="strapi"
        :src="article.cover.url.replace('/uploads/', '')"
        width="400"
        height="300"
        quality="80"
        class="aspect-video w-full object-cover"
      />
    </template>
    <template #title>
      <NuxtLink :to="`/blog/${article.slug}`">
        <h3 class="text-xl font-bold lg:text-xl">
          {{ article.title }}
        </h3>
      </NuxtLink>
    </template>
    <template #subtitle>
      <div class="flex flex-row gap-2 text-sm">
        <p class="text-primary">
          {{ useDateFormat(article.publishedAt, 'DD MMM YYYY').value }}
        </p>
        <!-- <span
          v-if="article.author"
          class="flex gap-2"
        >
          by
          <span
            v-for="author in article.author"
            :key="author.id"
          >
            {{ author.name }}
          </span>
        </span> -->
      </div>
    </template>
    <template #content>
      <div class="flex w-full flex-col items-start justify-center gap-2">
        <p class="text-sm">
          {{ article.description }}
        </p>
      </div>
    </template>
    <template #footer>
      <div class="flex w-full justify-end">
        <NuxtLink :to="`/blog/${article.slug}`">
          <PrimeButton outlined> Read More </PrimeButton>
        </NuxtLink>
      </div>
    </template>
  </PrimeCard>
</template>

================
File: apps/website/components/blog/card/BlogCardSkeleton.vue
================
<template>
  <div
    class="relative w-full h-full md:rounded-md border border-color cursor-pointer p-4 gap-4 flex flex-col overflow-hidden background"
  >
    <!-- BlogCatTag Skeleton -->
    <div class="flex gap-2 w-full mb-4 flex-wrap">
      <div class="w-24 h-5 foreground rounded mb-2" />
      <!-- Category Badge -->
      <div class="w-16 h-5 foreground rounded mb-2" />
      <!-- Tag Badge 1 -->
      <div class="w-20 h-5 foreground rounded mb-2" />
      <!-- Tag Badge 2 -->
    </div>

    <!-- NuxtImg Skeleton -->
    <div class="rounded-md w-full h-48 foreground mb-4" />

    <div class="flex flex-col gap-2 items-start w-full p-2 xl:p-4 justify-center">
      <!-- article.title Skeleton -->
      <div class="h-6 w-3/4 foreground mb-2 rounded" />

      <!-- BlogAuthor Skeleton -->
      <div class="flex flex-row gap-2 lg:gap-3 justify-center items-center">
        <div class="w-32 h-5 foreground rounded" />
        <!-- Author Name 1 -->
        <div class="w-16 h-5 foreground rounded ml-2" />
        <!-- Date -->
      </div>

      <!-- article.description Skeleton -->
      <div class="h-5 w-full foreground rounded mt-2" />
    </div>
  </div>
</template>

<script lang="ts" setup></script>

================
File: apps/website/components/blog/BlogShowcase.vue
================
<script setup lang="ts">
import { ref, computed, watchEffect } from 'vue'
import type { PropType } from 'vue'
import type { ArticleCategoriesT, ArticleCardT } from '~/types/articles'

const message = ref('')

const props = defineProps({
  articleCategory: {
    type: String as PropType<ArticleCategoriesT>,
    required: true,
  },
})

const articlesShowcase = ref<ArticleCardT[]>([])
const category = computed(() => props.articleCategory)
const haveArticles = computed(() => articlesShowcase.value.length > 0)

const strapi = useStrapi()

// Fetch articles on server and client
const { data, error, status } = await useAsyncData(`blog-showcase-${category.value}`, async () => {
  const params: any = {
    pagination: {
      pageSize: 3,
      page: 1,
    },
    sort: ['publishedAt:desc'],
    filters: {},
    populate: {
      cover: {
        populate: '*',
      },
      category: {
        fields: ['name', 'slug'],
      },
      author: {
        fields: ['name', 'bio'],
      },
    },
  }

  // If you have a 'status' field and want to filter by 'published'
  params.filters['status'] = {
    $eq: 'published',
  }

  if (category.value !== 'all') {
    params.filters['category'] = {
      slug: {
        $eq: category.value,
      },
    }
  }

  const response = await strapi.fetchFromStrapi<any>('articles', params)

  if (response && response.data && response.data.length > 0) {
    return response.data
  } else {
    message.value = 'No articles loaded...'
    return []
  }
})

if (error.value) {
  console.error('Fetch Articles Error:', error.value)
}

watchEffect(() => {
  if (data.value) {
    articlesShowcase.value = data.value
  }
})
</script>

<template>
  <div>
    <div class="space-y-6 lg:space-y-12">
      <slot name="title" />
      <p
        v-if="message.length"
        class="rounded-md bg-red-950/70 p-4 text-sm lg:text-base"
      >
        {{ message }}
      </p>
      <div
        v-if="haveArticles"
        class="grid grid-cols-1 gap-4 md:grid-cols-2 lg:grid-cols-3 lg:gap-8"
      >
        <BlogCard
          v-for="article in articlesShowcase"
          :key="`blog-showcase-${article.id}`"
          :article="article"
        />
        <ClientOnly>
          <BlogCardSkeleton v-show="status === 'pending'" />
          <BlogCardSkeleton v-show="status === 'pending'" />
          <BlogCardSkeleton v-show="status === 'pending'" />
        </ClientOnly>
      </div>
      <div class="flex justify-end">
        <slot />
      </div>
    </div>
  </div>
</template>

<style scoped></style>

================
File: apps/website/components/conference/ConferenceSpeakers.vue
================
<template>
  <div class="w-full">
    <CommonTitle
      :title="{
        main: 'Meet The IDSPC2023 Group',
      }"
    />
    <p class="text-primary-700 text-sm font-bold uppercase">
      offline / online Chairperson
    </p>
    <ConferenceChairperson
      class="pt-6"
      :hosts="hosts"
    />
    <p class="text-primary-700 text-sm font-bold uppercase pt-4 lg:pt-8">
      Conference Speakers
    </p>
    <div class="pt-4 lg:pt-8 grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-4 lg:gap-8">
      <ConferenceSpeakerCard
        v-for="speaker in filterSpeakers(true)"
        :key="speaker.given_name"
        :speaker="speaker"
        featured
      />
      <ConferenceSpeakerCard
        v-for="speaker in filterSpeakers(false, true)"
        :key="speaker.given_name"
        :speaker="speaker"
      />
    </div>
  </div>
</template>

<script setup lang="ts">
import type { SpeakerType } from '@/types/conference'

const hosts = [
  {
    given_name: 'Ruchira',
    surname: 'Huchgol',
    professional_title: 'Organising Committee, Chairman, IDSPAC23 & Operations Manager, AstronEra.',
    bio: `Ruchira Huchgol an analog astronaut with background of
    aerospace engineering has a keen intersted in human space exploration and also works to bring in new opportunities in space sector for the Indian student community
    `,
    avatar: 'ruchira-huchgol',
  },
  {
    given_name: 'Atharva',
    surname: 'Joshi (Jhey)',
    professional_title:
      'Organising Committee, Online Chairman, IDSPAC23 & Project Co-ordinator, AstronEra.',
    bio: `Atharva Joshi is a dedicated architect with extensive experience ranging from the Southern coast to the Himalayas.
    His profound interest in astronomy brings a unique perspective to the innovative projects at AstronEra.`,
    avatar: 'atharva-joshi',
  },
]

const speakers = [
  {
    given_name: 'Sonam',
    surname: 'Wangchuk',
    professional_title: 'Engineer, Innovator and Education Reformist',
    bio: 'Recipient of the Ramon Magsaysay Award, Sonam Wangchuk, an engineer and educator, is lauded for his sustainable development efforts via SECMOL ALTERNATIVE SCHOOL. His innovative approach to environmental and educational challenges showcases a profound commitment to fostering sustainable communities.',
    abstract: {
      title: 'Sustainable Development for Tribal Ladakhies',
      description: `Mr. Sonam Wangchuk, a prominent figure in
        education reform, delivered a keynote speech at the conference, commending the
        AstronEra team's efforts and announcing a collaborative effort between SECMOL,
        HIAL, and AstronEra to safeguard Ladakh's starry skies. He drew parallels between
        Ladakh's rugged terrain and Mars, highlighting its rich cultural diversity.
        Wangchuk stressed the impact of climate change on Ladakh and emphasized the need for
        sustainable living practices to preserve the environment. Introducing SECMOL, an
        innovative school focusing on practical learning and sustainable living, Wangchuk
        emphasized Ladakh's natural sky as a gateway to understanding the universe. He advocated
        for promoting eco-friendly tourism in Ladakh, envisioning it as a pilgrimage site for
        experiencing its majestic landscapes and pristine night skies. Proposing an astrotourism
        campaign to ignite youth interest in astronomy, Wangchuk emphasized the importance of
        conserving Ladakh's dark skies while providing livelihood opportunities. Expressing concern
        over light pollution's effects on wildlife, he highlighted the "I Live Simply" movement,
        urging simplicity to combat climate change's impact.`,
    },
    avatar: 'sonam-wangchuk',
    featured: true,
    inPerson: true,
  },
  {
    title: 'Dr.',
    given_name: 'Constance (Connie)',
    surname: 'Walker',
    professional_title:
      'Head of Office of Site Protection, NSF\'s NOIRLab, USA and Co-Director, IAU CPS',
    bio: 'Astronomer Dr. Connie E. Walker is celebrated for her dark skies education advocacy. With a journey sparked by celestial fascinations, she\'s devoted two decades at NSF\'s National Optical-Infrared Astronomy Research Lab, crafting global innovative programs. Her academic trail from Physics to a Ph.D. in Astronomy underscores a lifelong dedication to astronomical education.',
    abstract: {
      title:
        'Astronomy and Satellite Constellations: Pathways Forward for Light Pollution from Space',
      description: `Dr. Constance (Connie) Walker, the Head of
        the Office of Site Protection at NSF's NOIRLab, USA, and
        Co-Director of the IAU CPS. Her talk, titled "Astronomy and
        Satellite Constellations: Pathways Forward for Light
        Pollution from Space," highlighted the initiatives and
        programs supported by the International Astronomical
        Union (IAU) to promote and preserve Dark and Quiet Skies.
        Dr. Walker emphasised the challenge posed by satellite constellations to observational
        astronomy and discussed the collaboration of working groups from various fields such as
        engineering, law and policy, pure sciences, astrophysics, and art. She emphasised that the
        field of space and astronomy requires contributions from individuals in every discipline and
        is a common heritage for all.`,
    },
    avatar: 'connie-walker',
    featured: true,
    inPerson: false,
  },
  {
    given_name: 'Neethu',
    surname: 'Susan George',
    professional_title: 'MSLL ( Member Society of Light & Lighting ) as well as Dark Sky Advocate',
    bio: `Neethu Susan George, MSLL, WELL APâ„¢, LEEDÂ® Green Associateâ„¢.
    Designation - Specification Manager Middle East North Africa and India - Lamp Worktitude for Light (Spain) and Griven (Italy)
    MSLL (Member Society of Light and Lighting), DarkSky Advocate, WELL APâ„¢, LEEDÂ® Green Associateâ„¢.
    Graduate in Electrical and Electronics Engineering from Mahatma Gandhi University, and MSc. Energy with dissertation on Light Pollution and Circularity in Lighting from Heriot-Watt University

    `,
    abstract: {
      title: 'Lighting for Dark Skies',
      description: `Mrs. Neethu Susan George, a member of
        the Society of Light & Lighting (MSLL) and a Dark Sky Advocate, presented
        "Lighting for Dark Skies," focusing on fundamental strategies to combat light
        pollution. She advocated for installing motion sensors or timers to regulate light
        usage efficiently and advocated for the adoption of lower-intensity lighting to
        minimize unnecessary illumination. Mrs. George emphasized the importance of
        properly aiming and shielding outdoor lights to prevent glare, light spill, and
        skyglow. Additionally, she recommended the implementation of louvers, baffles, or shields to
        direct light where needed and prevent it from dispersing into the sky or neighboring areas. To
        further mitigate light pollution, she suggested the use of curtains or blinds indoors to contain
        light within the premises, thus safeguarding the night environment from artificial light intrusion.
        
        Ms. George emphasized the importance of educating oneself and the community about the
        impacts of light pollution on the environment, human health, and astronomical observations.
        She encouraged support for organizations like the International Dark-sky Association (IDA),
        which actively promotes responsible outdoor lighting and the preservation of dark skies.
        Additionally, Ms. George advocated for increased involvement from stakeholders,
        companies, and government bodies to engage in discussions and collaborate on
        implementable solutions to address the issue of light pollution.`,
    },
    avatar: 'neethu-george',
    featured: false,
    inPerson: true,
  },
  {
    given_name: 'Bhakti',
    surname: 'Mithagri',
    professional_title: 'MSc Astrophysics',
    bio: 'Curious learner and astronomy enthusiast. Graduated with a Master\'s degree in Astrophysics from St. Xavier\'s College in Mumbai and currently preparing for Ph.D.',
    abstract: {
      title: 'Indian successors to the Indian Gamma-Ray Observatory(IGRO) Mission',
      description: `Ms. Bhakti Mithagri, an MSc Astrophysics graduate and avid astronomy
        enthusiast, delivered a presentation titled "Indian Successors to the Indian Gamma-Ray
        Observatory (IGRO) Mission." Alongside her colleague Mr. Kshititj Pawar, they elucidated
        an indigenous alternative mission concept in its initial stages. The presentation also addressed
        the issue of insufficient data democratisation within the research domain, particularly for
        students and young researchers.`,
    },
    avatar: 'bhakti-mithagri',
    featured: false,
    inPerson: true,
  },
  {
    title: 'Dr.',
    given_name: 'Anita',
    surname: 'Gupta',
    professional_title: 'Adviser/Scientist G at DST, Govt. of India',
    bio: 'Dr. Anita Gupta, an Adviser/Scientist G at India\'s DST, has over 25 years of experience in innovation, entrepreneurship, and start-ups. As Associate Head of Innovation and Entrepreneurship, she leads initiatives like Startup India, fostering over 150 technology business incubators across premier institutes and engaging in Public-Private Partnerships with major MNCs to enhance India\'s innovation landscape.',
    abstract: {
      title: 'Harnessing India\'s  potential to fight Climate Change',
      description: `Dr. Anita Gupta. Representing the Climate Change & Clean Energy (C3E) Division within
        the Department of Science and Technology, Government of India, Dr.
        Gupta underscored the government's cognizance of pressing concerns such
        as light pollution and its adverse effects on astronomy. She emphasized
        the readiness of governmental entities to engage in collaborative endeavors with
        organizations, corporations, and non-governmental organizations (NGOs) to explore
        alternative strategies and foster the adoption of clean energy practices and sustainable
        initiatives.`,
    },
    avatar: 'anita-gupta',
    featured: true,
    inPerson: false,
  },
  {
    given_name: 'Maria',
    surname: 'Alejandra DÃ­az',
    professional_title: 'Astronomer',
    bio: `Alejandra, with a Physics degree from UAM, Spain, has worked at the European Space Agency and is pursuing a PhD in Turku.
    Passionate about astronomy's societal impact, she's contributed to IAU's OAD projects and operates a telescope in La Palma alongside her thesis.`,
    abstract: {
      title: 'Astronomy\'s Impact on Sustainability',
      description: `Maria Alejandra DÃ­az is an astronomer with a Physics degree from UAM, Spain, and is
        pursuing a PhD in Turku. Passionate about astronomy's societal impact, she's contributed to
        IAU's OAD projects and operates a telescope in La Palma alongside her thesis. Her talk was
        titled Astronomy's Impact on Sustainability. In her talk, she gave a very brief overview of the
        various 200 projects funded by the IAU OAD and how these projects highlighted exactly the
        definition of sustainability and the harmony that it helps to maintain between economy,
        society and environment. She highlighted how these projects evolved in following Goal 4:
        quality education, Goal 8: Decent work and economic growth, Goal 5: gender equality, Goal
        10: Reduced Inequality, and Goal 11: affordable clean energy. She also mentioned case
        studies that highlighted astronomy and its impact and relation with mental health,
        socio-economic development and preserving indigenous roots and knowledge of the night sky.`,
    },
    avatar: 'maria-alejandra-diaz',
    featured: false,
    inPerson: false,
  },
  {
    title: 'Dr.',
    given_name: 'Priya',
    surname: 'Hasan',
    professional_title: 'Dr. of Astrophysics and Physics',
    bio: `Dr. Priya Hasan, from Moscow State and Osmania University, is an acclaimed astrophysicist. Awarded as Women Scientist by the Department of Science & Technology,
    she's lectured at CalTech and Harvard. Currently at Maulana Azad University, she co-chairs the IAU's Women in Astronomy and champions science outreac`,
    abstract: {
      title: 'Dark Skies and Bright Satellites',
      description: `Dr. Priya Hasan, a distinguished astrophysicist
        and co-chair of the International Astronomical
        Union's Women in Astronomy, delivered a presentation titled "Dark Skies and Bright
        Satellites." Dr. Hasan highlighted the disruptive impact of the launch of numerous satellites on
        astronomical observations, particularly during twilight after dawn and dusk. She elucidated
        that the brightness of satellites depends on various factors, including inclination, altitude,
        attitude, orbital position, wavelength, and time of the year. Focusing on the Vera Rubin Observatory (LSST), which scans the skies for
        transients and near-Earth objects, Dr. Hasan discussed the adverse effects of satellite trails in
        science images. These effects encompass the loss of information on pixels, cross-talk in
        electronics, ghost images, and residual images, varying depending on the telescope and
        detector used. Furthermore, Dr. Hasan addressed potential solutions and mitigation strategies, referencing
        the SATCON1 report. These strategies include reducing reflectivity through the application of
        dark paint, redirecting light away, deploying fewer satellites to minimize the issue, designing
        smaller satellites to mitigate their impact, and ensuring predictability to facilitate scheduled observations
        `,
    },
    avatar: 'priya-hasan',
    inPerson: false,
    featured: true,
  },
  {
    given_name: 'Vedvrat',
    surname: 'Vinayak Bedekar',
    professional_title: 'BE IT Student',
    bio: 'An amateur astronomer running an astronomy club in college. Frequent stargazer and host of stargazing events. ',
    abstract: {
      title: 'Light pollution: A Camouflaging pollution',
      description: `Mr. Vedvrat Vinayak Bedekar, a BE IT student and amateur astronomer overseeing an
        astronomy club in college, presented insights as one of the youngest speakers. His talk
        centred around the proposal to include a new category, 'Average Light Pollution,' in the daily
        regional weather report to raise awareness about the severity of light pollution. He further
        suggested the observance of a designated day, 'Dark Sky Preservation Day,' during which
        residents of villages and cities would turn off their lights temporarily to observe, enjoy, study,
        and appreciate the beauty of the universe. Additionally, he advocated for the initiation of a
        nationwide movement called 'Dark Sky Preservation Mission,' similar to the 'Swachh Bharat
        Mission.' This initiative would recognize and award villages and cities making exemplary
        efforts to raise awareness and reduce light pollution with a unique 'Dark Sky Preservation
        Award' at both state and national levels.
        `,
    },
    avatar: 'vedvrat-bedekar',
    featured: false,
    inPerson: false,
  },
  {
    given_name: 'David',
    surname: 'Ault',
    professional_title: 'Director of Education For Immersive Experiences',
    bio: `David is the Director of Education for Immersive Experiences, a UK planetarium and interactives company with a global footprint.
    With an astrophysics degree from Cambridge University, he entered the planetarium space in 2006, organising science festivals and starting a number of astronomy podcasts.`,
    abstract: {
      title: 'The planetarium as a creative space',
      description: `David Ault, the Director of Education for Immersive
        Experiences, a UK-based planetarium and interactives
        company, adeptly showcased the use of domes as an
        interactive tool for educating intricate concepts in
        astronomy. Through collaborative discussions,
        plans were formulated to deploy these inflatable
        portable domes in schools and remote areas, creating a mobile planetarium.
        This initiative aims to reinstate and enhance
        outreach efforts in the field of astronomy.
        `,
    },
    avatar: 'david-ault',
    featured: false,
    inPerson: false,
  },
  {
    given_name: 'Samyukta',
    surname: 'Manikumar',
    professional_title: 'Astrotourism Consultant',
    bio: `Samyukta, director of Noctia Institute, champions dark sky conservation through astrotourism. Blending science with cultural preservation,
    she's a fellow at the International Astronomical Union, focusing on rural astrotourism resources via the 'Socio-economic development through Astronomy Flagship'.`,
    abstract: {
      title: 'Harnessing Dark Skies for Socioeconomic Development in Rural Areas',
      description: `Ms. Samyukta Manikumar,
        an Astro Tourism consultant and fellow at the
        International Astronomical Union, presented on the
        topic "Harnessing Dark Skies for Socioeconomic
        Development in Rural Areas." She highlighted the
        immense potential of astro tourism in involving,
        educating, and uplifting rural populations. Ms Manikumar emphasized that rural areas still
        have the privilege of having dark skies, which can be leveraged by tourism companies
        through collaborations with the rural population. This, in turn, can help improve the social
        and economic conditions of these areas.
        `,
    },
    avatar: 'samyukta-manikumar',
    inPerson: false,
    featured: true,
  },
  {
    given_name: 'Upasana',
    surname: 'Dasgupta',
    professional_title:
      'Postdoctoral Researcher at Canada Research Chair in International Political Economy of UniversitÃ© Laval ',
    bio: `Upasana Dasgupta researches space policies at UniversitÃ© Laval and is on ACES Worldwide's board. With a Doctorate from McGill,
    she's an expert in space law, associated with global space entities, and emphasizes on space collision prevention and dark sky conservation.`,
    avatar: 'upasana-dasgupta',
    abstract: {
      title: 'Intruders in the Dark Sky: The Megaconstellation Crisiss',
      description: ` Ms. Upasana Dasgupta, a Postdoctoral Researcher at the Canada Research Chair in
        International Political Economy of UniversitÃ© Laval, presented "Intruders in the Dark Sky:
        The Mega Constellation Crisis." She outlined the current space policy framework, including
        the Outer Space Treaty, liability convention, and Moon agreement. Ms. Dasgupta highlighted
        the absence of dedicated regulations for satellite constellations and debris, underscoring their
        disruptive impact on observational astronomy by introducing additional noise into datasets,
        hindering scientific research.
        `,
    },
    featured: false,
    inPerson: true,
  },
  {
    given_name: 'Dinesh',
    surname: 'Nisang',
    professional_title: 'Science Communicator',
    bio: `Dinesh founded Sunday Science School and is passionate about science communication. An astronomer, he views astronomy as a unifier for humanity.
    He enjoys astrophotography, exploring nature, and is an aspiring writer with articles and a book on scientific innovation. Focus: ISAAC.`,
    abstract: {
      title: 'Stellar Education: Unveiling ISAAC',
      description: `Mr. Dinesh Nisang, Science Communicator and founder of Sunday Science School shared
        his talk â€œStellar Education: Unveiling Interactive Space and Astronomy Activity Centreâ€
        (ISAAC). His entire conversation was focused on how astronomy deserves and hands on
        approach to improve and enhance better understanding the concepts. He demonstrated very
        well by showing the kits of innovative models, one of them was a GMRT telescope which
        helped understand the engineering aspect as well as the working of the observatory. His talk
        very well complemented the tone of the day's inclusion of astronomy and space science in the
        educational curriculum.
        `,
    },
    avatar: 'dinesh-nisang',
    featured: false,
    inPerson: true,
  },
  {
    given_name: 'Exodus',
    surname: 'Chun-Long Sit',
    professional_title: 'Transmedia Astronomy Educator',
    bio: `Exodus CL Sit from Hong Kong is a transmedia astronomy educator and science author.
    He holds roles in IAU as the National Astronomy Education Coordinator for Hong Kong and Co-Outreach Coordinator.
    A member of the Dark Sky International Committee, he champions dark-sky protection, STEAM education, and interdisciplinary science approaches.`,
    abstract: {
      title: 'ASTROx Dark Sky: How to Integrate Astronomy Education into Interactive Classroom',
      description: `Exodus Chun-Long Sit addressed
        the integration of astronomy education in an interactive
        classroom and the escalating issue of light pollution, proposing a DIY
        light shielding solution. He also explored the interconnectedness of
        entrepreneurship and space arts with astronomy. Additionally, he
        advocated for biodiversity conservation, suggesting the
        establishment of Dark Sky Parks. Mr. Sit emphasized the IDEAS
        framework, encompassing Immersivity, Diversity, Equity, Access, and Spreading awareness, as a strategy for advancing
        astronomy education and outreach efforts.
        `,
    },
    avatar: 'exodus-chun-long-sit',
    featured: false,
    inPerson: false,
  },
  {
    given_name: 'Nadia Makhijani',
    surname: '& Udish Sharma',
    professional_title: 'BSc. Physics Students',
    bio: `We are pursuing BSc Physics hons from St. Stephen's College, University of Delhi and have mainly worked in radio astronomy,
    its applications and Cosmology. Nadia Makhijani and Udish Sharma are students in their final year at St. Stephen's College pursuing a course in physics.
    They work in the fields of Astronomy and Cosmology and are currently involved in setting up a Radio Astronomy Laboratory in their institution.
    They are also currently in the student led physics and astronomy society.`,
    avatar: 'nadia-makhijani',
    abstract: {
      title: 'Affordable Radio Astronomy Lab',
      description: `Ms. Nadia Makhijani and Mr. Udish Sharma, both BSc Physics students with a primary focus
        on radio astronomy, its applications, and cosmology, presented a talk titled "Affordable Radio
        Astronomy Lab." During their presentation, they introduced an economically viable radio
        telescope â€“ a pyramidal horn â€“ that was constructed in-house using low-cost equipment. This
        telescope is designed for use in college laboratories and outreach programs, providing an
        accessible platform for students. The duo utilized the horn antenna for a Radio Frequency
        Interference (RFI) survey of their campus, observed the H-21 emission from our galaxy, and
        plotted the rotation curve. They also highlighted the versatility of this affordable setup for
        various experiments in college laboratories, such as satellite and meteor tracking, receiving
        weather images, and collecting GPS data. The objective of their presentation was to
        emphasize how cost-effective experiments can be implemented in undergraduate labs.
        `,
    },
    featured: false,
    inPerson: false,
  },
  {
    title: 'Dr.',
    given_name: 'Kiran',
    surname: 'Kulkarni',
    professional_title: 'Indian Administrative Service Officer',
    bio: 'Dr. Kulkarni has significantly contributed to tribal development, notably as Tribal Development Commissioner. While his work doesn\'t directly involve astronomy, his extensive outreach in education and governance innovations hints at a potential for fostering astronomy-related initiatives within tribal communities. His campaigns like Dream Melghat showcase his commitment to community upliftment, possibly providing a platform for intertwining traditional tribal knowledge with astronomical insights.',
    abstract: {
      title: 'Sustainable Development through Astronomy: A Tribal Perspective',
      description: `Dr. Kiran Kulkarni (IAS), former Commissioner of the
        Tribal Development Department, Gov. of Maharashtra. While Dr. Kulkarni's primary
        professional focus may not directly involve astronomy, his extensive involvement in
        education and governance innovations suggests potential avenues for fostering
        astronomy-related initiatives within tribal communities. His talk was titled
        "Sustainable Development through Astronomy: A Tribal Perspective."
        During his presentation, Dr. Kulkarni drew attention to the critical distinctions
        between tribal and rural communities. He prompted contemplation on the unique
        characteristics of the locations inhabited by tribal populations, characterized by their remoteness, isolation, and freedom from the
        impact of pollution, including light pollution. Dr. Kulkarni suggested that these remote and
        quiet locations might be ideal for establishing dark skies, encouraging further assessment and
        consideration for similar initiatives.
        `,
    },
    avatar: 'kiran-kulkarni',
    featured: true,
    inPerson: true,
  },
  {
    given_name: 'Amshu',
    surname: 'CR',
    professional_title: 'Entrepreneur, Thapasu foods LLP',
    bio: 'Forest value chains, Land degradation, Biodynamic Agriculture, Tribal produce supply chains, Food security, knowledge preservation, Sustainablity ',
    abstract: {
      title: 'The ancient science of space and agriculture for sustainability and harmony',
      description: `Amshu CR, an entrepreneur from Thapasu Foods LLP, presented on "The
        Ancient Science of Space and Agriculture for Sustainability and Harmony." She effectively
        explained the significance of Vedic knowledge in assessing the night skies based on seasons
        and how this knowledge can be applied to enhance agricultural conditions. Emphasizing the
        revision and implementation of this ancient approach in the form of Biodynamic farming,
        Amshu CR left the audience with thought-provoking insights. The presentation highlighted
        how actual sky observations, in addition to satellite imagery and mapping, can assist farmers
        in optimizing their agricultural practices.
        `,
    },
    avatar: 'amshu-cr',
    featured: false,
    inPerson: false,
  },
  {
    given_name: 'Albert',
    surname: 'Kuntu Forson',
    professional_title: 'PhD Research Student',
    bio: 'Albert, an engineer specializing in Radio Astronomy Instrumentation and radio interferometer designs at the University of Mauritius, holds the esteemed role of IAU-OAD National Astronomy Education Coordinator for Ghana. Additionally, he serves as the President for PRAGSAC and is highly enthusiastic about science communication.',
    abstract: {
      title:
        'Empowering Ghana\'s STEM Education: Bridging the Gap through Capacity Building in Astronomy Instrumentation',
      description: `Mr. Albert Kuntu Forson, a Ph.D. Research Student and
        the IAU-OAD National Astronomy Education Coordinator for Ghana,
        presented on "Empowering Ghana's STEM Education: Bridging the Gap
        through Capacity Building in Astronomy Instrumentation." Mr.
        Forson emphasized Africa's growing presence in the field of space sciences
        and discussed initiatives such as the AtroPhy project. This project serves
        as a catalyst for graduate and undergraduate students, offering hands-on experience in radio telescope engineering and
        operational techniques. Utilizing the Table Top Radio Telescope (TTRT) for Galactic
        Hydrogen Emission (HI) studies and developing small parabolic dish antennas, AtroPhy
        contributes significantly to addressing socio-economic challenges, including poverty, hunger,
        and illegal mining in Ghana. By nurturing practical skills, fostering scientific curiosity, and
        promoting collaboration, AtroPhy plays a pivotal role in advancing STEM education and
        capacity building in the region.
        `,
    },
    avatar: 'albert-forson',
    featured: false,
    inPerson: false,
  },
  {
    given_name: 'Aishwarya',
    surname: 'Khade',
    professional_title: 'Mental Health Practitioner / Expressive Arts ',
    bio: 'A seasoned Psychologist and Mental Health Professional, Aishwarya Khade employs art and movement-based facilitation in educational and corporate settings. Specialized in corporate wellness, her drive is to enhance mental health and well-being through innovative methodologies.',
    abstract: {
      title: 'Mental Health Arts and Astronomy',
      description: `The final presentation of the day addressed the intersection of Mental Health, Arts, and
        Astronomy, delivered by Ms. Aishwarya Khade, a seasoned Psychologist and Mental Health
        Professional. Ms. Khade employs art and movement-based facilitation techniques in both
        educational and corporate settings. She provided a detailed account of her experiences while
        collaborating with the AstoTribe project in Nashik in 2022 and Ladakh in 2023. Ms Khade
        emphasized her work with tribal children who were undergoing training to become Astro
        guides. The incorporation of artistic elements proved instrumental in creating a comfortable
        environment, allowing the children to share their indigenous tribal stories related to
        constellations. This approach also facilitated discussions about the beliefs and superstitions
        prevalent in their respective tribal communities.
        `,
    },
    avatar: 'aishwarya-khade',
    featured: false,
    inPerson: true,
  },
  {
    given_name: 'Hosein',
    surname: 'Khezri',
    professional_title: 'Associate of Commission C1 WG Astronomy Education Research & Methods',
    bio: 'Affiliated with multiple astronomical unions including the IAU, Hosein Khezri is dedicated to elevating astronomy education and its cultural integration. His association with the Iranian Teachers Astronomy Union and various International Astronomical Union commissions reflects a broad engagement in promoting astronomy in diverse cultural landscapes.',
    abstract: {
      title: 'Road to Sky',
      description: 'Cancelled due to technical issues',
    },
    avatar: 'hossein-khezri',
    featured: false,
    inPerson: false,
  },
  {
    given_name: 'Shweta',
    surname: 'Kulkarni',
    professional_title: 'Founder/Director of AstronEra',
    bio: 'Astropreneur Shweta Kulkarni, listed among top 100 women entrepreneurs, spearheads Astronera, marrying business acumen with astronomy for innovative solutions. As a Fellow of the Royal Astronomical Society of England, her venture reflects a novel approach to integrating astronomy with enterprise.',
    abstract: {
      title: 'Skill Training in Astronomy for Income Generation',
      description: `Shweta, the director of AstronEra and CEO of Astron
        SHK Trust, initiated the conference to bridge the link between conserving dark skies and
        sustainable socio-economic development. She introduced herself as an "AstroPreneur,"
        emphasizing her dual roles as a part-time astronomer and full-time entrepreneur. Shweta
        identified key problems including the lack of authentic astronomy knowledge, scientific
        temperament in society, and diminishing dark skies due to light pollution.
        She introduced the "AstroTribe" Project, funded by IAU and OAD, aimed at training tribal
        children in astronomy to empower them economically. This initiative incentivizes students by
        enabling them to generate income through bridging technical astronomy with entertainment
        through astrotourism, thereby promoting awareness about dark skies and addressing SDGs of
        quality education and sustainable economic growth.
        Shweta outlined action points post-conference, focusing on understanding the problem of
        light pollution, identifying target areas and audiences, determining mediums and expected
        outcomes, and establishing frameworks aligned with the human right to dark skies. She
        emphasized leveraging resources available on darksky.org to find solutions and highlighted
        the historical contributions to astronomy, underscoring the responsibility to conserve night
        skies for future generations.
        Following Shweta's talk, a significant event took place where the Astroguide's batch in
        Manali was honored with certificates and recognized for the income they earned from their
        stargazing event. This event served as their graduation ceremony, marking the culmination of
        their training. The Astroguides introduced themselves and shared their experiences gained
        through the training program. They expressed heartfelt gratitude towards the AstronEra team
        for their support and guidance throughout the journey. This ceremony not only celebrated the
        achievements of the Astroguides but also highlighted the impact of empowering individuals
        with astronomical knowledge and skills for economic sustainability in the region.`,
    },
    avatar: 'shweta-kulkarni',
    featured: true,
    inPerson: true,
  },
] as SpeakerType[]

const filterSpeakers = (featured: boolean, toSort = false) => {
  return speakers
    .filter((s: Speaker): boolean | undefined => s.featured === featured)
    .sort((a: Speaker, b: Speaker) => {
      if (!toSort) return 0
      if (a.given_name < b.given_name) {
        return -1
      }
      if (a.given_name > b.given_name) {
        return 1
      }
      return 0
    })
}
</script>

<style scoped></style>

================
File: apps/website/components/home/HomeCtaMain.vue
================
<template>
  <div
    class="relative flex items-center text-white justify-center w-full p-10 mx-auto md:py-20 lg:py-40 bg-black"
  >
    <div class="flex flex-col items-center justify-center gap-4 text-center text-light">
      <h2 class="text-3xl font-bold">
        {{ title }}
      </h2>
      <p class="max-w-sm text-lg leading-snug text-center">
        {{ body }}
      </p>
      <NuxtLink to="auth/register">
        <PrimeButton
          class="p-2"
          color="primary"
          size="xl"
        >
          {{ cta }}
        </PrimeButton>
      </NuxtLink>
    </div>
  </div>
</template>

<script setup lang="ts">
defineProps({
  title: {
    type: String as PropType<string>,
    required: true,
  },
  body: {
    type: String as PropType<string>,
    required: true,
  },
  cta: {
    type: String as PropType<string>,
    required: true,
  },
})
</script>

<style scoped></style>

================
File: apps/website/components/home/HomeFeatureTabs.vue
================
<script setup lang="ts">
const productSteps = [
  {
    id: 1,
    tabName: 'tab1',
    tabTitle: 'News',
    title: 'Stay Updated with Astronomy News',
    info: '10+ News Sources',
    body: 'We aggregate news from all major space agencies like NASA and ISRO, as well as private companies.',
    points: [
      'News from NASA, ISRO, and more',
      'Daily updates',
      'AI-powered article summaries',
      'Comprehensive coverage of private companies',
    ],
    cta: 'Check it out',
    available: true,
  },
  {
    id: 2,
    tabName: 'tab2',
    tabTitle: 'Companies',
    info: '20+ Companies Onboarded',
    title: 'Explore Government and Private Sector Companies',
    body: 'Our database will include all major government and private sector companies from around the world, our initial focus is Indian private companies.',
    points: [
      'Database of major government agencies',
      'Insights into private companies',
      'Follow companies of interest - coming soon',
      'Linked social profiles - coming soon',
    ],
    cta: 'Check it out',
    available: true,
  },
  {
    id: 3,
    tabName: 'tab3',
    tabTitle: 'People',
    info: '50+ People',
    title: 'Connect with Astronomy Enthusiasts',
    body: 'Join a global community of astronomy enthusiasts.',
    points: [
      'Connect with global enthusiasts',
      'Share your passion for astronomy',
      'Foster collaboration',
      'Hire AstroGuides',
    ],
    cta: 'Check it out',
    available: true,
  },
  {
    id: 4,
    tabName: 'tab4',
    tabTitle: 'Launches',
    info: 'Upcoming Launches',
    title: 'Never Miss a Launch',
    body: 'Stay informed about all upcoming launches from launch providers worldwide.',
    points: [
      'Database of upcoming launches',
      'Global launch providers',
      'Stay informed about space events',
      'Never miss an important launch',
    ],
    cta: 'Coming Q2 2024',
    available: false,
  },
]

const dummyData = {
  news: {
    id: 1,
    created_at: '2024-03-23 06:30:24.736222+00',
    updated_at: '2024-03-23 06:30:24.736222+00',
    title: 'Elastocaloric Refrigeration for Spaceflight Applications (ESRA)',
    body: 'Jun Cui Iowa State University ESI23 Cui Quadchart.pdf Elastocaloric materials heat up when exposed to a mechanical force and cool down, removing the same amount of heat from their environment, when the force is removed. Professor Cui will use the recently established DFT\\/machine learning guided metals development methodology to unravel the complex relationships between compositions, crystal structures, phase transformation, and fatigue behavior of the elastocaloric materials. He will develop novel, new elastocaloric materials and use them as the basis of a high-performance refrigeration system for NASA exploration applications. Back to ESI 2023',
    category_id: 16,
    author: null,
    description:
      'Jun Cui Iowa State University ESI23 Cui Quadchart.pdf Elastocaloric materials heat up when exposed to a mechanical force and cool down, removing the same amount of heat from their environment, when the force is removed. Professor Cui will use the\u2026',
    featured_image:
      'https://www.nasa.gov/wp-content/themes/nasa/assets/images/default-thumbnail.jpg',
    has_summary: false,
    published_at: '2024-03-21 18:30:00+00',
    source: 'nasa',
    url: 'https://www.nasa.gov/directorates/stmd/space-tech-research-grants/esi/elastocaloric-refrigeration-for-spaceflight-applications-esra/',
  },

  company: {
    id: 1,
    name: 'Agnikul Cosmos',
    description:
      'Agnikul Cosmos is a space tech company building small satellite launch vehicles. We are building a full stack launch vehicle to take small satellites to space.',
    founding_year: 2017,
    logo_url: 'agnikul-logo.jpg',
    url: 'https://agnikul.in/#/',
    is_government: false,
    category_id: 1,
    scrape_frequency: 'bi_weekly',
    social_media: {
      linkedin_url: 'https://www.linkedin.com/company/agnikul-cosmos/',
      twitter_url: 'https://twitter.com/@agnikulcosmos',
      instagram_url: 'https://instagram.com/agnikul/',
      youtube_url: 'https://www.youtube.com/@agnikulcosmos1404',
    },
  },
  user: {
    id: 'e1bf12c6-aad4-4905-bda2-127c027504a3',
    email: 'shwetakk6@gmail.com',
    given_name: 'Shweta',
    surname: 'Kulkarni',
    username: 'Shweta',
    dob: '1995-11-16',
    gender_id: 2,
    created_at: '2023-08-11 16:49:09.163+00',
    updated_at: '2023-08-11 16:49:09.163+00',
    last_seen: '2023-08-11 16:49:09.163+00',
    avatar: 'shweta-kulkarni.jpg',
    introduction: null,
    quote: null,
    followed_count: 1,
    followers_count: 1,
    plan: 'free',
    role: 'admin',
  },
} as const

const getDummyData = (type: string) => {
  return dummyData[type as keyof typeof dummyData]
}
</script>

<template>
  <div>
    <IBTabView :tabs="productSteps">
      <template
        v-for="feat in productSteps"
        :key="feat.id"
        #[feat.tabName]
      >
        <div class="grid grid-cols-1 gap-8 md:grid-cols-2">
          <div class="background border-color space-y-4 rounded-md border p-4 lg:p-8">
            <h3 class="text-2xl">
              {{ feat.title }}
            </h3>
            <!-- <p> {{ feat.body }}</p> -->
            <ul class="list-inside list-disc">
              <li
                v-for="point in feat.points"
                :key="point"
              >
                {{ point }}
              </li>
            </ul>
            <PrimeMessage severity="info">
              {{ feat.info }}
            </PrimeMessage>
          </div>
          <div class="space-y-4">
            <NewsCard
              v-if="feat.id === 1"
              :news="getDummyData('news')"
            />
            <CompanyCard
              v-else-if="feat.id === 2"
              :company="getDummyData('company')"
            />
            <UserCard
              v-else-if="feat.id === 3"
              :user="getDummyData('user')"
            />
            <div v-else>
              <PrimeMessage severity="info"> Coming Very Soon </PrimeMessage>
            </div>
            <PrimeButton class="flex w-full justify-center"> Join to see more </PrimeButton>
          </div>
        </div>
      </template>
    </IBTabView>
  </div>
</template>

<style scoped></style>

================
File: apps/website/components/home/HomeHero.vue
================
<template>
  <div class="relative min-h-screen text-white w-full">
    <IBImage
      :img="{
        src: bgImg,
        quality: '80',
        format: 'webp',
      }"
      class="absolute left-0 top-0 h-full w-full bg-center bg-no-repeat object-cover"
    />
    <div class="absolute left-0 top-0 z-10 h-full w-full bg-zinc-900" />
    <div
      class="relative mx-auto grid max-w-[1920px] gap-8 px-4 py-32 md:px-16 lg:grid-cols-[1.5fr_1.75fr] xl:gap-16 xl:px-32"
    >
      <!-- Hero Left -->
      <div
        class="relative z-50 flex h-full w-full flex-col items-center gap-8 text-center lg:items-start lg:text-left"
      >
        <div
          class="h-16 w-16 overflow-hidden rounded-full bg-white p-2 shadow-lg lg:h-24 lg:w-24 xl:p-4"
        >
          <IBImage
            :img="{
              src: '/astronera-logo.jpg',
            }"
          />
        </div>
        <h1 class="max-w-lg text-4xl font-bold leading-tight lg:text-5xl">
          Explore The Universe And Grow With Us
        </h1>
        <p class="max-w-sm text-xl font-semibold">
          AstroTribe is a community of astronomers and enthusiasts unveiling the mysteries of the
          cosmos together.
        </p>
        <div>
          <NuxtLink :to="`${$config.public.authURL}/register`">
            <PrimeButton> Signup, it's FREE! </PrimeButton>
          </NuxtLink>
        </div>
      </div>
      <div class="relative z-50 mx-auto flex h-full w-full items-center justify-center">
        <AppVideoModal :video="video" />
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
const video = {
  url: 'https://www.youtube.com/embed/x5ijmeCJ42s?si=V_t46bCe9ClaKmrN?mute=0&autoplay=1',
  thumbnail: 'images/hero-image.jpg',
  alt: 'Astron Era Hero Video',
}

const bgImg = '/hero-image.jpg'
</script>

================
File: apps/website/components/landing/LandingCTA.vue
================
<script setup lang="ts">
import { onMounted } from 'vue'
import { useAnimation } from '~/composables/useAnimation'
import { useRuntimeConfig } from '#app'

const { fadeInLeft, fadeInRight } = useAnimation()

defineProps<{
  title: string
  subtitle: string
  buttonText: string
}>()

const config = useRuntimeConfig()
const authLink = config.public.aeAuthLink

onMounted(() => {
  fadeInLeft('.cta-content')
  fadeInRight('.cta-image')
})
</script>

<template>
  <section class="cta-section relative py-32">
    <div
    class="absolute inset-0 -z-10 h-full w-full bg-gradient-to-b from-transparent from-10% via-primary-950 via-50% to-transparent to-90%"
    ></div>

    <div class="flex flex-col md:flex-row items-center justify-between">
      <div class="cta-content text-white md:w-1/2 mb-8 md:mb-0">
        <h2 class="text-2xl md:text-3xl font-bold mb-4 font-space">
          {{ title }}
        </h2>
        <p class="text-xl mb-8">{{ subtitle }}</p>
        <NuxtLink
          :to="authLink"
          class="inline-block"
        >
          <PrimeButton
            :label="buttonText"
            severity="secondary"
            size="large"
          />
        </NuxtLink>
      </div>
      <div class="md:w-1/2 cta-image">
        <NuxtImg
          src="https://picsum.photos/800/600"
          alt="CTA Image"
          class="rounded-lg w-full h-auto shadow-2xl shadow-black"
        />
      </div>
    </div>
  </section>
</template>

<style scoped>
.bg-gradient-to-b {
  background-image: linear-gradient(
    to bottom,
    rgba(1, 34, 63, 0) 0%,
    rgba(1, 34, 63, 1) 50%,
    rgba(1, 34, 63, 0) 100%
  );
}
</style>

================
File: apps/website/components/LoginButton.vue
================
<template>
  <button @click="initiateLogin"> Login </button>
</template>

<script setup>
const user = ref(null)

const initiateLogin = () => {
  const authWindow = window.open(
    'https://auth.domain.com/auth-handler',
    'Auth',
    'width=600,height=600',
  )

  window.addEventListener(
    'message',
    (event) => {
      if (event.origin !== 'https://auth.domain.com') return

      if (event.data.type === 'AUTH_RESULT') {
        if (event.data.success) {
          user.value = event.data.user
          // Handle successful login
        } else {
          // Handle login error
        }
      }
    },
    false,
  )
}
</script>

================
File: apps/website/components/NavTop.vue
================
<script setup lang="ts">
const websiteLinks = [
  {
    key: 'about-us',
    label: 'About Us',
    icon: 'material-symbols:info',
    visible: true,
    disabled: false,
    items: [
      {
        key: 'about',
        label: 'About',
        icon: 'material-symbols:info',
        url: '/about',
        visible: true,
        disabled: false,
      },
      {
        key: 'team',
        label: 'Team',
        icon: 'material-symbols:emoji-people',
        url: '/team',
        visible: true,
        disabled: false,
      },
      {
        key: 'contact',
        label: 'Contact',
        icon: 'material-symbols:call',
        url: '/contact',
        visible: true,
        disabled: false,
      },
    ],
  },
  {
    key: 'projects',
    label: 'Projects',
    icon: 'material-symbols:work',
    visible: true,
    disabled: false,
    items: [
      {
        key: 'dark-sky-conference-2023',
        label: 'Conference',
        icon: 'material-symbols:mic-rounded',
        url: '/projects/dark-sky-conference-2023',
        visible: true,
        disabled: false,
      },
    ],
  },
  {
    key: 'blog',
    label: 'Blog',
    icon: 'material-symbols:menu-book-outline',
    visible: true,
    disabled: false,
    items: [
      {
        key: 'blog-home',
        label: 'All',
        icon: 'material-symbols:menu-book-outline',
        url: '/blog/category/all/page/1',
        visible: true,
        disabled: false,
      },
      {
        key: 'blog-dark-sky-conservation',
        label: 'Conservation',
        icon: 'material-symbols:menu-book-outline',
        url: '/blog/category/dark-sky-conservation/page/1',
        visible: true,
        disabled: false,
      },
      {
        key: 'blog-people-of-space',
        label: 'People',
        icon: 'material-symbols:menu-book-outline',
        url: '/blog/category/people-of-space/page/1',
        visible: true,
        disabled: false,
      },
      {
        key: 'blog-space-exploration',
        label: 'Exploration',
        icon: 'material-symbols:menu-book-outline',
        url: '/blog/category/space-exploration/page/1',
        visible: true,
        disabled: false,
      },
      {
        key: 'blog-sustainable-development',
        label: 'Sustainability',
        icon: 'material-symbols:menu-book-outline',
        url: '/blog/category/sustainable-development/page/1',
        visible: true,
        disabled: false,
      },
    ],
  },
]

defineProps({
  isCompact: {
    type: Boolean,
    default: false,
  },
  compactOnScroll: {
    type: Boolean,
    default: false,
  },
})

const { y } = useWindowScroll()
const lastScrollY = ref(y.value)
const navbarClasses = computed(() => {
  if (navPosition.value === 'fixed') {
    return ''
  } else {
    return navPosition.value === 'hidden' ? 'animate-bounce-out' : 'animate-bounce-in'
  }
})

const navPosition = ref('fixed')

watch(
  y,
  (newY) => {
    if (window?.innerWidth < 1024) {
      navPosition.value = 'fixed'
    } else if (newY > lastScrollY.value) {
      navPosition.value = 'hidden'
    } else if (newY < lastScrollY.value) {
      navPosition.value = 'visible'
    }
    lastScrollY.value = newY
  },
  { immediate: true },
)
</script>

<template>
  <div
    ref="navbar"
    class="flex min-w-full w-full fixed top-0 left-0 right-0 z-50"
    :class="navbarClasses"
  >
    <!-- Glass Container -->
    <LandingGlass
      hover-effect="glow"
      glow-color="purple"
      gradient="mixed"
      intensity="low"
      interactive
      isolate-content
      class="!w-full"
      :padded="false"
      :rounded="false"
      :overflow="true"
    >
      <PrimeMenubar
        :model="websiteLinks"
        class="w-full text-white rounded-none lg:rounded-b-xl bg-transparent border-none relative z-10"
        :pt="{
          root: {
            class: 'flex items-center justify-between px-4 py-2',
          },
          submenu: {
            class:
              '!bg-primary-950/95 backdrop-blur-xl md:absolute md:flex-col flex !text-sm !font-bold !text-white border border-primary-500/50 rounded-md',
          },
        }"
      >
        <template #start>
          <div class="hidden gap-4 rounded-md p-1 lg:flex">
            <div
              class="relative flex h-[36px] w-[36px] items-center justify-center rounded-md border bg-white p-1 md:h-[44px] md:w-[44px]"
            >
              <IBImage
                :img="{
                  src: '/astronera-logo.jpg',
                }"
                class="h-full w-full opacity-90"
              />
            </div>
            <NuxtLink
              to="/"
              class="flex min-h-full items-center justify-center"
            >
              <h4
                class="mt-[2px] flex cursor-pointer flex-col items-start justify-start pr-2 text-sm font-bold uppercase leading-none tracking-normal"
              >
                Astron
                <strong class="font-extrabold text-primary-400"> Era </strong>
              </h4>
            </NuxtLink>
          </div>
        </template>
        <template #item="{ item, hasSubmenu, root }">
          <div class="px-4 py-2">
            <NuxtLink
              :to="item.url"
              class="cursor-pointer text-white text-nowrap"
            >
              <p class="flex items-center gap-1">
                {{ item.label }}
                <Icon
                  v-if="hasSubmenu"
                  :name="root ? 'mdi:chevron-down' : 'mdi:chevron-right'"
                />
              </p>
            </NuxtLink>
          </div>
        </template>
        <template #end>
          <div class="flex flex-nowrap items-center justify-center gap-4 lg:pr-2">
            <NuxtLink
              to="https://github.com/incubrain/astrotribe"
              target="_blank"
              class="hidden items-center justify-center lg:flex"
            >
              <Icon
                name="mdi:github"
                class="flex cursor-pointer items-center justify-center"
                size="24px"
              />
            </NuxtLink>
            <div class="flex h-auto min-w-24 items-center justify-center gap-2 lg:gap-4">
              <div class="space-x-2 lg:space-x-4">
                <NuxtLink
                  v-ripple
                  :to="$config.public.authURL"
                >
                  <PrimeButton
                    severity="contrast"
                    outlined
                  >
                    login
                  </PrimeButton>
                </NuxtLink>

                <NuxtLink
                  v-ripple
                  :to="`${$config.public.authURL}/register`"
                >
                  <PrimeButton> Join AstronEra </PrimeButton>
                </NuxtLink>
              </div>
            </div>
          </div>
        </template>
      </PrimeMenubar>
    </LandingGlass>
  </div>
</template>

<style scoped>
canvas {
  width: 100vw;
  height: 100vh;
  display: block;
}

.navbar {
  display: flex !important;
  position: static !important;
  background-color: red !important; /* Just to make it obvious */
  z-index: 9999 !important;
}

@keyframes bounce-in {
  0% {
    transform: translateY(-100%);
  }
  100% {
    transform: translateY(0);
  }
}

@keyframes bounce-out {
  0% {
    transform: translateY(0);
  }
  100% {
    transform: translateY(-100%);
  }
}

.animate-bounce-in {
  animation: bounce-in 0.5s ease-out forwards;
}

.animate-bounce-out {
  animation: bounce-out 1s ease-in forwards;
}
</style>

================
File: apps/website/pages/blog/category/[category]/page/[page].vue
================
<script setup lang="ts">
import { useChangeCase } from '@vueuse/integrations/useChangeCase'
import { useRoute, useRuntimeConfig, useStrapi } from '#imports'

const route = useRoute()
const strapi = useStrapi()

const validCategories = [
  'all',
  'people-of-space',
  'space-exploration',
  'dark-sky-conservation',
  'sustainable-development',
] as const

type ArticleCategoriesT = (typeof validCategories)[number]

const categoryInfo = {
  'all': {
    title: 'AstronEra Blog',
    description: 'Discover all our articles spanning the wonders and advancements of space.',
  },
  'people-of-space': {
    title: 'People of Space',
    description: 'Meet the trailblazers and visionaries propelling humanity into the cosmos.',
  },
  'space-exploration': {
    title: 'Space Exploration',
    description: 'Embark on thrilling journeys through our latest missions and cosmic discoveries.',
  },
  'dark-sky-conservation': {
    title: 'Dark Sky Conservation',
    description: 'Uncover efforts to preserve our celestial vistas and protect night skies.',
  },
  'sustainable-development': {
    title: 'Sustainable Development',
    description: 'Explore innovations for a sustainable future in space and on Earth.',
  },
}

const { data: pageData } = await useAsyncData(
  `articles-${route.params.category}-page-${route.params.page}`,
  () =>
    fetchArticlesFromAPI(String(route.params.category).toLowerCase(), Number(route.params.page)),
  { server: false, immediate: true },
)

const articles = computed(() => pageData.value?.articles || [])
const totalPages = computed(() => pageData.value?.totalPages || 1)
const categoryParam = computed(() => route.params.category || 'all')
const pageParam = computed(() => pageData.value?.page || 1)

// Use the pageData in your component

console.log('useRuntimeConfig:', useRuntimeConfig().public, categoryParam.value, pageData)

async function fetchArticlesFromAPI(category: string, page: number) {
  console.log('Fetching articles:', category, page)
  const params: any = {
    populate: {
      author: {
        populate: true,
      },
      cover: {
        populate: true,
      },
      category: {
        populate: true,
      },
    },
  }

  if (category !== 'all') {
    params.filters = {
      slug: {
        $eq: category,
      },
    }
  }

  const response = await strapi.find<any>('articles', params)

  // If you need categories and authors separately
  // const categories = await strapi.find<any>('categories');

  console.log('Response:', response)

  return {
    articles: response.data,
    totalPages: response.meta.pagination.pageCount,
    category,
    page,
  }
}

// old
// SEO
// if (categoryParam.value) {
//   useSeoMeta({
//     title: categoryInfo[categoryParam.value].title,
//     ogTitle: categoryInfo[categoryParam.value].title,
//     description: categoryInfo[categoryParam.value].description,
//     ogDescription: categoryInfo[categoryParam.value].description,
//     ogImage: '/images/icons/blog-icon.svg',
//     twitterCard: 'summary_large_image',
//     twitterTitle: categoryInfo[categoryParam.value].title,
//     twitterDescription: categoryInfo[categoryParam.value].description,
//     twitterImage: `${websiteUrl}/images/icons/blog-icon.svg`,
//   })

//   defineOgImageComponent('OgImageDefault', {
//     title: `${categoryParam.value} Articles`,
//     description: categoryInfo[categoryParam.value]?.description,
//     image: './',
//   })
// }

const heroImage = computed(() => {
  let src = `images/blog/${categoryParam.value}/`

  switch (categoryParam.value) {
    case 'people-of-space':
      return (src += '1.20-people-who-influenced-the-space-industry.webp')
    case 'space-exploration':
      return (src += '1.starship-lands-on-mars.webp')
    case 'dark-sky-conservation':
      return (src += '1.landscape-painting-of-dark-skies-and-mountains.webp')
    case 'sustainable-development':
      return (src += '1.sustainable-global-space-development.webp')
    default:
      return (src += 'isro-rocket-launch.png')
  }
})
</script>

<template>
  <div>
    <CommonHero
      v-if="categoryParam && categoryInfo[categoryParam as ArticleCategoriesT]"
      :img="{
        src: heroImage,
        alt: `AstronEra ${useChangeCase(categoryParam, 'capitalCase').value} Hero Image`,
        width: 1080,
        height: 720,
      }"
      :title="{
        main: categoryInfo[categoryParam].title,
        subtitle: categoryInfo[categoryParam].description,
      }"
      position="center"
      invert
    />
    <div class="wrapper p-4 xl:p-8">
      <BlogFilter />
    </div>
    <div
      class="wrapper relative grid w-full grid-cols-1 items-start md:gap-4 md:px-4 lg:grid-cols-[0.5fr_1fr] lg:gap-8 lg:px-8"
    >
      <BlogAdFloat />

      <div
        v-show="articles.length"
        class="grid h-full grid-cols-1 md:grid-cols-2 md:gap-4 lg:gap-8"
      >
        <BlogCard
          v-for="article in articles"
          :key="`astronera-${categoryParam}-article-${article.id}`"
          :article="article"
        />
        <div
          v-if="!articles.length"
          class="background flex w-full items-center justify-center border border-primary-500 p-8 md:rounded-md"
        >
          <p class="foreground px-2"> No articles found... </p>
        </div>
        <!-- <template>
          <BlogCardSkeleton />
          <BlogCardSkeleton />
          <BlogCardSkeleton />
        </template> -->
      </div>
    </div>

    <!-- Pagination Component -->
    <Pagination
      :current-page="pageParam"
      :total-pages="totalPages"
      :base-url="`/blog/category/${categoryParam}`"
    />
  </div>
</template>

================
File: apps/website/pages/blog/[title].vue
================
<script setup lang="ts">
import qs from 'qs'
import { computed } from 'vue'
import { useRoute, useStrapi } from '#imports'

const route = useRoute()
const strapi = useStrapi()

const slug = computed(() => String(route.params.title))

const { data, pending, error } = await useAsyncData(
  `article-${slug.value}`,
  async () => {
    try {
      const params: any = {
        filters: {
          slug: {
            $eq: slug.value,
          },
        },
        populate: {
          cover: {
            populate: true,
          },
          category: {
            populate: true,
          },
          blocks: true,
          author: {
            fields: ['name', 'bio'],
            populate: {
              avatar: {
                populate: true,
              },
            },
          },
        },
      }

      const response = await strapi.find<any>('articles', params)

      if (!response || !response.data || response.data.length === 0) {
        console.error({ statusCode: 404, message: 'Article not found' })
      }

      const article = response.data[0]

      return article
    } catch (e) {
      console.error('Error fetching article:', e)
    }
  },
  { server: true },
)

const article = computed(() => data.value)

console.log('Article:', article.value)
</script>

<template>
  <div>
    <div v-if="pending">Loading...</div>
    <div v-else-if="error">{{ error.message }}</div>
    <BlogArticle
      v-else-if="article"
      class="background"
      :article="article"
    />
    <div v-else>No article found</div>
  </div>
</template>

================
File: apps/website/nuxt.config.ts
================
import { fileURLToPath } from 'url'
import { dirname, join, resolve } from 'path'
import { defineNuxtConfig } from 'nuxt/config'
import sharedRuntimeConfig from '../../shared-runtime.config'
import prerenderRoutes from './prerender-routes.json'

const currentDir = dirname(fileURLToPath(import.meta.url))

function generateLocalUrls(start = 3000, end = 3009) {
  return Array.from({ length: end - start + 1 }, (_, i) => `http://localhost:${start + i}`)
}

const localUrls = generateLocalUrls()

const og = {
  title: 'AstronEra: Your Gateway to the Stars',
  description:
    'Connect, learn, and unravel the cosmos with astronomers and space enthusiasts from around the globe',
  image: '/astronera-logo-with-text.jpg',
  url: 'https://www.astronera.org',
}

export default defineNuxtConfig({
  workspaceDir: '../../',
  srcDir: '.',

  ssr: true,

  modules: [
    '@nuxtjs/mdc',
    'nuxt-security',
    '@nuxtjs/seo',
    '@nuxt/devtools',
    '@vueuse/nuxt',
    '@nuxt/image',
    '@pinia/nuxt',
    '@nuxt/icon',
    '@nuxt/eslint',
    '@nuxt/fonts',
    '@nuxtjs/tailwindcss',
    '@primevue/nuxt-module',
    '@nuxt/content',
  ],

  extends: ['../../layers/base', '../../layers/crud'],

  build: {
    transpile: [
      'embla-carousel-vue',
      'embla-carousel-autoplay',
      'embla-carousel-auto-scroll',
      'gsap',
    ],
  },

  // routeRules: {
  //   '/': { prerender: true },
  //   '/about': { prerender: true },
  //   '/contact': { prerender: true },
  //   '/team/**': { prerender: true },
  //   '/projects/**': { prerender: true },
  //   '/policies/**': { prerender: true },
  //   '/blog': { isr: true },
  //   '/blog/**': { isr: 60 }, // Revalidate every 60 seconds
  // },

  content: {
    highlight: {
      theme: {
        default: 'github-dark',
        light: 'github-light',
        dark: 'github-dark',
      },
    },
  },

  security: {
    headers: {
      contentSecurityPolicy: {
        'worker-src': ["'self'", 'blob:'],
        'default-src': [
          "'self'",
          ...localUrls,
          'http://localhost:3000',
          'http://localhost:54321',
          'https://www.astronera.org',
          'https://*.up.railway.app',
          'https://*.supabase.co',
          'https://*.posthog.com',
        ],
        'connect-src': [
          "'self'",
          ...localUrls,
          'http://localhost:3000',
          'http://localhost:8080',
          'http://host.docker.internal:8080',
          'http://localhost:54321',
          'https://o1175094.ingest.sentry.io',
          'https://api.iconify.design',
          'https://api.unisvg.com',
          'https://api.simplesvg.com',
          'https://*.supabase.co',
          'https://*.up.railway.app',
          'http://*.railway.internal',
          'http://scrapers.railway.internal:8080',
          'https://*.razorpay.com',
          'https://*.posthog.com',
          'https://us.i.posthog.com',
          'ws://localhost:4000',
          'wss://localhost:4000',
          'ws://localhost:4001', // Add this line
          'wss://localhost:4001',
          'https://picsum.photos',
          'https://cms.astronera.org',
          'https://astronera.org',
          'https://*.astronera.org',
          'http://localhost:1337/',
        ],
        'img-src': [
          "'self'",
          'data:',
          'http://localhost:54321',
          'http://localhost:3000',
          'http://localhost:1337/',
          'https://*.up.railway.app',
          'https://www.nasa.gov',
          'https://science.nasa.gov',
          'https://www.youtube.com',
          'https://s.ytimg.com',
          'https://pbs.twimg.com',
          'https://media.licdn.com',
          'https://*.supabase.co',
          'https://*.posthog.com',
          'https://us.i.posthog.com',
          'http://*.railway.internal',
          'https://picsum.photos',
          'https://fastly.picsum.photos/',
          'https://img.youtube.com',
          'https://cms.astronera.org',
          'https://*.astronera.org',
        ],
        'script-src': [
          "'self'",
          "'unsafe-inline'",
          "'wasm-unsafe-eval'",
          'http://localhost:3000',
          'http://localhost:54321',
          'https://www.youtube.com',
          'https://s.ytimg.com',
          'https://www.google.com/maps',
          'https://*.betterstack.com',
          'https://*.razorpay.com',
          'https://*.posthog.com',
          'https://us.i.posthog.com',
        ],
        'script-src-attr': ["'unsafe-inline'"],
        'style-src': [
          "'self'",
          "'unsafe-inline'",
          'https://fonts.googleapis.com',
          'https://*.posthog.com',
        ],
        'frame-src': [
          "'self'",
          'https://www.youtube.com',
          'https://us.i.posthog.com',
          'https://*.posthog.com',
          'https://www.google.com',
          'https://*.astronera.org',
          'https://*.betterstack.com',
          'https://*.razorpay.com',
        ],
        'child-src': ["'self'", 'https://us.i.posthog.com', 'https://*.posthog.com'],
      },
      xFrameOptions: 'DENY', // Prevents clickjacking
      crossOriginResourcePolicy: 'cross-origin', // Ensures resources are allowed
      crossOriginOpenerPolicy: 'same-origin',
      crossOriginEmbedderPolicy: 'unsafe-none',
    },
    requestSizeLimiter: {
      maxUploadFileRequestInBytes: 2000000, // 2 MB
      throwError: true,
      maxRequestSizeInBytes: 2000000, // 2 MB
    },
    xssValidator: false,
    corsHandler: {
      origin: [
        ...localUrls,
        'http://localhost:8080',
        'http://host.docker.internal:8080',
        'http://*.railway.internal',
        'http://scrapers.railway.internal:8080',
        'http://localhost:54321',
        'https://*.supabase.co',
        'https://us.i.posthog.com',
        'https://*.posthog.com',
      ],
      methods: ['GET', 'HEAD', 'PUT', 'PATCH', 'POST', 'DELETE'],
      allowHeaders: [
        'Content-Type',
        'Authorization',
        'X-Requested-With',
        'x-client-info',
        'apikey',
      ],
      exposeHeaders: ['Content-Length', 'X-Kuma-Revision'],
      credentials: true,
      maxAge: '86400', // 24 hours in seconds
      preflight: {
        statusCode: 204,
      },
    },
    allowedMethodsRestricter: false,
    hidePoweredBy: false,
    basicAuth: false,
    csrf: false,
    nonce: false,
    removeLoggers: false,
    ssg: false,
    sri: false,
  },

  nitro: {
    debug: true,
    logLevel: 'debug',
    prerender: {
      crawlLinks: true,
      routes: prerenderRoutes,
    },
  },

  image: {
    format: ['webp', 'jpg', 'png'],
    quality: 80,
    dir: 'public',
    domains: ['astronera.org', 'cms.astronera.org', 'staging.cms.astronera.org', 'localhost'],
    fallback: '/defaults/fallback.jpg',

    // Strapi provider configuration
    strapi: {
      baseURL: `${process.env.NUXT_PUBLIC_STRAPI_URL}/uploads/`, // Adjust this URL to match your Strapi setup
    },

    // You can keep the ipx provider as a fallback or for local development
    ipx: {
      maxAge: 60 * 60 * 24 * 365, // 1 year (in seconds)
    },
  },

  experimental: {
    inlineRouteRules: true,
    asyncContext: true,
  },

  tailwindcss: {
    configPath: `${currentDir}/tailwind.config.ts`,
    cssPath: [`${currentDir}/assets/css/tailwind.css`, { injectPosition: 0 }],
    exposeConfig: true,
    viewer: true,
  },

  primevue: {
    importPT: { from: resolve(currentDir, '../../theme/index.js') },
    autoImport: true,
    components: {
      prefix: 'Prime',
      include: '*',
      exclude: ['Editor'],
    },

    composables: {
      include: '*',
    },

    options: {
      ripple: true,
      unstyled: true,
      theme: {
        options: {
          cssLayer: {
            name: 'primevue',
            order: 'tailwind-base, primevue, tailwind-utilities',
          },
        },
      },
    },
  },
  site: {
    url: og.url,
    name: 'AstronEra',
    description: 'Astronomy Hub',
    defaultLocale: 'en',
  },

  // seo: {
  //   redirectToCanonicalSiteUrl: true,
  // },

  // ogImage: {
  //   componentOptions: {
  //     global: true,
  //   },
  // },

  fonts: {
    families: [
      { name: 'Orbitron', provider: 'google' },
      { name: 'Source Code Pro', provider: 'google' },
    ],
  },

  app: {
    layoutTransition: { name: 'layout', mode: 'out-in' },
    head: {
      link: [{ rel: 'icon', href: '/favicon.ico', sizes: 'any' }],
      htmlAttrs: {
        lang: 'en',
      },
      meta: [
        { property: 'title', content: og.description },
        { property: 'description', content: og.description },
        { property: 'og:title', content: og.title },
        { property: 'og:type', content: 'website' },
        { property: 'og:image', content: og.image },
        { property: 'og:description', content: og.description },
        { property: 'og:url', content: og.url },
        { name: 'twitter:card', content: 'Twitter Card' },
        { name: 'twitter:title', content: og.title },
        { name: 'twitter:description', content: og.description },
        { name: 'twitter:image', content: og.image },
      ],
      script: [
        // Insert your Google Tag Manager Script here
        // { src: 'https://browser.sentry-cdn.com/7.28.1/bundle.min.js', async: true, type: 'text/partytown' },
        {
          src: 'https://www.youtube.com/iframe_api',
          async: true,
        },
      ],
    },
  },

  compatibilityDate: '2024-09-22',

  runtimeConfig: {
    public: {
      ...sharedRuntimeConfig.runtimeConfig.public,
    },
  },
})
