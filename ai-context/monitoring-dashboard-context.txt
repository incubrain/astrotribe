This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-11-14T04:19:07.936Z

# File Summary

## Purpose
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A header with the file path (## File: path/to/file)
  b. The full contents of the file in a code block

## Usage Guidelines
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
- Pay special attention to the Repository Description. These contain important context and guidelines specific to this project.

## Notes
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

- Line numbers have been added to the beginning of each line.

## Additional Info
### User Provided Header
Monitoring Dashboard application context including shared libraries and layers

For more information about Repomix, visit: https://github.com/yamadashy/repomix

# Repository Structure
```
apps/
  monitoring-dashboard/
    components/
      LogList.vue
    layouts/
      default.vue
    middleware/
      is-super-admin.ts
    pages/
      index.vue
      not-authorized.vue
    server/
      api/
        logs.get.ts
    types/
      auth.ts
    app.vue
    nuxt.config.ts
    README.md
    tailwind.config.ts
layers/
  advert/
    .playground/
      app.config.ts
      nuxt.config.ts
    components/
      Advertisement.vue
    plugins/
      error-handler.ts
      sentry.server.ts
    server/
      api/
        advertisement/
          metrics.get.ts
          metrics.post.ts
    nuxt.config.ts
  auth/
    .playground/
      app.config.ts
      nuxt.config.ts
    composables/
      user.current.store.ts
    server/
      middleware/
        cors.ts
    nuxt.config.ts
  base/
    .playground/
      app.config.ts
      nuxt.config.ts
    components/
      image/
        ImageHero.vue
        ImageWithFallback.vue
      Background.vue
      Breadcrumbs.vue
      Glass.vue
      GlobalTimer.vue
      Grid.vue
      HelloWorld.vue
      HoverCard.vue
      Image.vue
      InfiniteScroll.vue
      Loader.vue
      Modal.vue
      NavHamburger.vue
      NewLabel.vue
      Pagination.vue
      Popover.vue
      Resizable.vue
      Sidebar.vue
      SideNav.vue
      SocialBlock.vue
      TabView.vue
      YT.client.vue
    composables/
      utils/
        arrays.ts
        hasValueChanged.ts
        objects.ts
        strings.ts
        time.ts
      ab-test.ts
      analytics.ts
      glass-card.ts
      metrics.ts
      modal.ts
      notification.ts
      settings.store.ts
      social.store.ts
      useMediaQuery.ts
      useNavigation.ts
      utils.ts
    plugins/
      error-handler.ts
      posthog.client.ts
      sentry.client.ts
    types/
      content.ts
      database.ts
      index.ts
      users.ts
    nuxt.config.ts
    supabase-provider.ts
  crud/
    .playground/
      app.config.ts
      nuxt.config.ts
    components/
      Feedback.vue
      Upload.vue
    composables/
      audit.ts
      delete.ts
      fetch.ts
      http-handler.ts
      insert.ts
      loading.store.ts
      local-storage.ts
      main.store.ts
      notification.ts
      pagination.store.ts
      rate-limit.ts
      select.ts
      settings.store.ts
      update.ts
      upload.ts
      useApiDataStore.ts
      useBaseError.ts
      user.current.store.ts
    server/
      utils/
        base.interface.ts
    nuxt.config.ts
libs/
  logger/
    src/
      environment.d.ts
      environment.ts
      error-interface.ts
      handler.ts
      logger.ts
    index.d.ts
    index.ts
shared-runtime.config.ts
```

# Repository Files

## File: apps/monitoring-dashboard/components/LogList.vue
```vue
 1: <script setup lang="ts">
 2: const logs = ref([])
 3: 
 4: onMounted(async () => {
 5:   const response = await $fetch('/api/logs', { method: 'GET' })
 6:   logs.value = response
 7: })
 8: </script>
 9: 
10: <template>
11:   <div>
12:     <h2>Logs</h2>
13:     <ul>
14:       <li
15:         v-for="log in logs"
16:         :key="log._time"
17:       >
18:         {{ log._time }} - {{ log.message }}
19:       </li>
20:     </ul>
21:   </div>
22: </template>
```

## File: apps/monitoring-dashboard/layouts/default.vue
```vue
1: <script setup lang="ts"></script>
2: 
3: <template>
4:   <div class="relative flex h-full min-h-screen w-full items-center justify-start">
5:     <slot />
6:   </div>
7: </template>
8: 
9: <style scoped></style>
```

## File: apps/monitoring-dashboard/middleware/is-super-admin.ts
```typescript
 1: export default defineNuxtRouteMiddleware(async (to, from) => {
 2:   const user = useSupabaseUser()
 3: 
 4:   // Check for super_admin role
 5:   const role = user.app_metadata?.role || []
 6:   if (role !== 'super_admin') {
 7:     console.log('Not super_admin')
 8:     // return navigateTo('/not-authorized')
 9:   }
10: })
```

## File: apps/monitoring-dashboard/pages/index.vue
```vue
 1: <script lang="ts" setup></script>
 2: 
 3: <template>
 4:   <div>
 5:     <h1>Logging Dashboard</h1>
 6:     <LogList />
 7:   </div>
 8: </template>
 9: 
10: <style></style>
```

## File: apps/monitoring-dashboard/pages/not-authorized.vue
```vue
1: <template>
2:   <div> you are not authorized to see this </div>
3: </template>
4: 
5: <script setup lang="ts"></script>
6: 
7: <style scoped></style>
```

## File: apps/monitoring-dashboard/server/api/logs.get.ts
```typescript
 1: // server/api/logs.get.ts
 2: 
 3: import { defineEventHandler } from 'h3'
 4: import { InfluxDB } from '@influxdata/influxdb-client'
 5: 
 6: export default defineEventHandler(async (event) => {
 7:   const config = useRuntimeConfig()
 8: 
 9:   // Create InfluxDB client
10:   const influxDB = new InfluxDB({
11:     url: config.influxUrl,
12:     token: config.influxToken,
13:   })
14: 
15:   const queryApi = influxDB.getQueryApi(config.influxOrg)
16: 
17:   // Extract query parameters if needed
18:   const queryParams = getQuery(event)
19: 
20:   // Build InfluxDB query
21:   const query = `from(bucket: "${config.influxBucket}")
22:     |> range(start: -1h)
23:     |> filter(fn: (r) => r._measurement == "logs")`
24: 
25:   const data = []
26:   await queryApi.collectRows(query, {
27:     next: (row) => data.push(row),
28:     error: (error) => console.error(error),
29:     complete: () => console.log('Query completed'),
30:   })
31: 
32:   return data
33: })
```

## File: apps/monitoring-dashboard/types/auth.ts
```typescript
 1: import { z } from 'zod'
 2: 
 3: export const identitySchema = z.object({
 4:   id: z.string(),
 5:   user_id: z.string(),
 6:   identity_data: z.object({
 7:     email: z.string().email(),
 8:     sub: z.string(),
 9:   }),
10:   provider: z.string(),
11:   last_sign_in_at: z.string(),
12:   created_at: z.string(),
13:   updated_at: z.string(),
14: })
15: 
16: export const emailUnvalidatedUserSchema = z.object({
17:   id: z.string(),
18:   aud: z.string(),
19:   role: z.string(),
20:   email: z.string().email(),
21:   phone: z.string().optional(),
22:   confirmation_sent_at: z.string().optional(),
23:   app_metadata: z.object({
24:     provider: z.string(),
25:     providers: z.array(z.string()),
26:   }),
27:   user_metadata: z.record(z.any()).optional(),
28:   identities: z.array(identitySchema),
29:   created_at: z.string().optional(),
30:   updated_at: z.string().optional(),
31: })
32: 
33: export const userSchema = z.object({
34:   id: z.string(),
35:   aud: z.string(),
36:   role: z.string().optional(),
37:   email: z.string().email().optional(),
38:   email_confirmed_at: z.string().optional(),
39:   phone: z.string().optional(),
40:   confirmation_sent_at: z.string().optional(),
41:   confirmed_at: z.string().optional(),
42:   last_sign_in_at: z.string().optional(),
43:   app_metadata: z.object({
44:     provider: z.string().optional(),
45:     providers: z.array(z.string()).optional(),
46:   }),
47:   user_metadata: z.record(z.any()),
48:   identities: z.array(identitySchema).optional(),
49:   created_at: z.string().optional(),
50:   updated_at: z.string().optional(),
51: })
52: 
53: export const sessionSchema = z.object({
54:   access_token: z.string(),
55:   refresh_token: z.string(),
56:   user: userSchema.optional(),
57:   token_type: z.string(),
58:   expires_in: z.number(),
59:   expires_at: z.number().optional(),
60: })
61: 
62: export const authSchema = z.object({
63:   user: userSchema,
64:   session: sessionSchema,
65: })
66: 
67: export const simpleUserSchema = z.object({
68:   email: z.string().email(),
69:   password: z.string(),
70: })
71: 
72: // Infer the types
73: export type AuthTypeType = z.infer<typeof authSchema>
74: export type SimpleUserTypeType = z.infer<typeof simpleUserSchema>
75: export type EmailUnvalidatedUserTypeType = z.infer<typeof emailUnvalidatedUserSchema>
76: export type UserTypeType = z.infer<typeof userSchema>
77: export type SessionTypeType = z.infer<typeof sessionSchema>
```

## File: apps/monitoring-dashboard/app.vue
```vue
 1: <template>
 2:   <div class="h-full w-full">
 3:     <NuxtLoadingIndicator />
 4:     <NuxtLayout>
 5:       <NuxtPage />
 6:     </NuxtLayout>
 7:     <PrimeToast position="bottom-right" />
 8:   </div>
 9: </template>
10: 
11: <style>
12: html {
13:   margin: 0;
14:   padding: 0;
15: }
16: 
17: #__nuxt {
18:   width: 100%;
19:   height: 100%;
20:   padding: 0;
21:   margin: 0;
22: }
23: 
24: .layout-enter-active,
25: .layout-leave-active {
26:   transition: all 0.4s;
27: }
28: 
29: .layout-enter-from,
30: .layout-leave-to {
31:   opacity: 0;
32:   filter: blur(1rem);
33: }
34: </style>
```

## File: apps/monitoring-dashboard/nuxt.config.ts
```typescript
 1: import { fileURLToPath } from 'url'
 2: import { dirname, join, resolve } from 'path'
 3: import { defineNuxtConfig } from 'nuxt/config'
 4: import runtimeConfig from '../../shared-runtime.config'
 5: 
 6: const currentDir = dirname(fileURLToPath(import.meta.url))
 7: 
 8: export default defineNuxtConfig({
 9:   workspaceDir: '../../',
10:   srcDir: '.',
11:   extends: ['../../layers/base', '../../layers/auth'],
12:   modules: ['@primevue/nuxt-module'],
13: 
14:   routeRules: {
15:     '/**': { appMiddleware: 'auth' },
16:   },
17: 
18:   tailwindcss: {
19:     configPath: `${currentDir}/tailwind.config.ts`,
20:     cssPath: [`${currentDir}/assets/css/tailwind.css`, { injectPosition: 0 }],
21:     exposeConfig: true,
22:     viewer: true,
23:   },
24: 
25:   primevue: {
26:     importPT: { from: resolve(currentDir, '../../theme/index.js') },
27:     autoImport: true,
28:     components: {
29:       prefix: 'Prime',
30:       include: '*',
31:       exclude: ['Editor'],
32:     },
33: 
34:     composables: {
35:       include: '*',
36:     },
37: 
38:     options: {
39:       ripple: true,
40:       unstyled: true,
41:       theme: {
42:         options: {
43:           cssLayer: {
44:             name: 'primevue',
45:             order: 'tailwind-base, primevue, tailwind-utilities',
46:           },
47:         },
48:       },
49:     },
50:   },
51: 
52:   imports: {
53:     autoImport: true,
54:   },
55: 
56:   ...runtimeConfig,
57: })
```

## File: apps/monitoring-dashboard/README.md
```markdown
 1: # Nuxt 3 Minimal Starter
 2: 
 3: Look at the [Nuxt 3 documentation](https://nuxt.com/docs/getting-started/introduction) to learn
 4: more.
 5: 
 6: ## Setup
 7: 
 8: Make sure to install the dependencies:
 9: 
10: ```bash
11: # npm
12: npm install
13: 
14: # pnpm
15: pnpm install
16: 
17: # yarn
18: yarn install
19: 
20: # bun
21: bun install
22: ```
23: 
24: ## Development Server
25: 
26: Start the development server on `http://localhost:3000`:
27: 
28: ```bash
29: # npm
30: npm run dev
31: 
32: # pnpm
33: pnpm run dev
34: 
35: # yarn
36: yarn dev
37: 
38: # bun
39: bun run dev
40: ```
41: 
42: ## Production
43: 
44: Build the application for production:
45: 
46: ```bash
47: # npm
48: npm run build
49: 
50: # pnpm
51: pnpm run build
52: 
53: # yarn
54: yarn build
55: 
56: # bun
57: bun run build
58: ```
59: 
60: Locally preview production build:
61: 
62: ```bash
63: # npm
64: npm run preview
65: 
66: # pnpm
67: pnpm run preview
68: 
69: # yarn
70: yarn preview
71: 
72: # bun
73: bun run preview
74: ```
75: 
76: Check out the [deployment documentation](https://nuxt.com/docs/getting-started/deployment) for more
77: information.
```

## File: apps/monitoring-dashboard/tailwind.config.ts
```typescript
 1: import { fileURLToPath } from 'url'
 2: import { dirname, resolve } from 'path'
 3: import type { Config } from 'tailwindcss'
 4: import baseConfig from '../../tailwind.config.base'
 5: 
 6: const currentDir = dirname(fileURLToPath(import.meta.url))
 7: 
 8: const config: Partial<Config> = {
 9:   presets: [baseConfig],
10:   theme: {
11:     extend: {
12:       // Add app-specific extensions here
13:     },
14:   },
15:   content: [resolve(currentDir, '**/*.{js,vue,ts}'), '../../theme/**/*.{js,css,ts}'],
16: }
17: 
18: export default config
```

## File: layers/advert/.playground/app.config.ts
```typescript
1: export default defineAppConfig({
2:   myLayer: {
3:     name: 'My amazing Nuxt layer (overwritten)'
4:   }
5: })
```

## File: layers/advert/.playground/nuxt.config.ts
```typescript
1: export default defineNuxtConfig({
2:   extends: ['..'],
3:   modules: ['@nuxt/eslint']
4: })
```

## File: layers/advert/components/Advertisement.vue
```vue
  1: <script setup lang="ts">
  2: import { useStorage } from '@vueuse/core'
  3: import advertisements from '../assets/advertisements.json'
  4: 
  5: const showAds = ref(false)
  6: const userShowAds = useStorage('userShowAds', true)
  7: 
  8: interface Advertisement {
  9:   id: number
 10:   title: string
 11:   description: string
 12:   imageUrl: string
 13:   link: string
 14:   active: boolean
 15: }
 16: 
 17: interface AdMetric {
 18:   adId: number
 19:   impressions: number
 20:   clicks: number
 21:   uniqueViews: number // Changed to number
 22:   deviceType: string
 23:   viewTimes: number[]
 24: }
 25: 
 26: const activeAds = ref<Advertisement[]>([])
 27: const adMetrics = useStorage<Record<number, AdMetric>>('adMetrics', {})
 28: const viewedAds = useStorage<Set<number>>('viewedAds', new Set())
 29: const sendInterval = 10000 // 10 seconds
 30: 
 31: const loadActiveAds = () => {
 32:   activeAds.value = advertisements.filter((ad) => ad.active).slice(0, 3)
 33: }
 34: 
 35: const getDeviceType = () => {
 36:   const userAgent = navigator.userAgent
 37:   if (/mobile/i.test(userAgent)) return 'Mobile'
 38:   if (/tablet/i.test(userAgent)) return 'Tablet'
 39:   return 'Desktop'
 40: }
 41: 
 42: const trackImpression = (adId: number) => {
 43:   if (!adMetrics.value[adId]) {
 44:     adMetrics.value[adId] = {
 45:       adId,
 46:       impressions: 0,
 47:       clicks: 0,
 48:       uniqueViews: 0,
 49:       deviceType: getDeviceType(),
 50:       viewTimes: [],
 51:     }
 52:   }
 53:   adMetrics.value[adId].impressions++
 54:   adMetrics.value[adId].viewTimes.push(Date.now())
 55: 
 56:   // Increment uniqueViews only if it's the first time this ad is viewed
 57:   if (!viewedAds.value.has(adId)) {
 58:     adMetrics.value[adId].uniqueViews++
 59:     viewedAds.value.add(adId)
 60:   }
 61: }
 62: 
 63: const trackInteraction = (adId: number) => {
 64:   if (adMetrics.value[adId]) {
 65:     adMetrics.value[adId].clicks++
 66:   }
 67: }
 68: 
 69: const sendMetrics = async () => {
 70:   const metricsToSend = JSON.parse(JSON.stringify(adMetrics.value))
 71: 
 72:   try {
 73:     // Send metrics to admin server (not implemented)
 74:     await $fetch('/api/advertisement/metrics', {
 75:       method: 'POST',
 76:       body: { metrics: metricsToSend },
 77:     })
 78: 
 79:     console.log('Metrics sent successfully')
 80:     // Clear the local metrics after successful send
 81:     adMetrics.value = {}
 82:   } catch (error) {
 83:     console.error('Failed to send metrics:', error)
 84:   }
 85: }
 86: 
 87: const intervalId = ref(null as NodeJS.Timeout | null)
 88: onMounted(() => {
 89:   intervalId.value = setInterval(sendMetrics, sendInterval)
 90:   loadActiveAds()
 91:   activeAds.value.forEach((ad) => trackImpression(ad.id))
 92: })
 93: 
 94: watch(
 95:   activeAds,
 96:   (newAds) => {
 97:     newAds.forEach((ad) => trackImpression(ad.id))
 98:   },
 99:   { deep: true },
100: )
101: 
102: onUnmounted(() => {
103:   clearInterval(intervalId.value!)
104:   sendMetrics() // Send any remaining metrics before unmounting
105: })
106: </script>
107: 
108: <template>
109:   <aside class="mx-auto min-h-72 w-72 space-y-4 p-4">
110:     <div class="mb-4 flex items-center justify-between">
111:       <label
112:         for="show-ads-toggle"
113:         class="pr-2 text-sm"
114:       >
115:         Toggle Ads
116:       </label>
117:       <PrimeToggleSwitch
118:         v-model="showAds"
119:         input-id="show-ads-toggle"
120:       />
121:     </div>
122:     <div
123:       v-for="ad in activeAds"
124:       :key="ad.id"
125:       class="border-color overflow-hidden rounded-lg"
126:       :class="!showAds ? '' : 'border'"
127:     >
128:       <a
129:         :href="showAds ? ad.link : undefined"
130:         target="_blank"
131:         rel="noopener noreferrer"
132:         class="block h-full w-full"
133:         :class="{ invisible: !showAds }"
134:         @click="trackInteraction(ad.id)"
135:       >
136:         <div class="max-h-72 w-full">
137:           <NuxtImg
138:             v-if="showAds"
139:             :src="ad.imageUrl"
140:             :alt="ad.title"
141:             class="w-full object-cover"
142:           />
143:         </div>
144:         <div class="p-4">
145:           <h3
146:             v-if="showAds"
147:             class="text-lg font-semibold"
148:           >
149:             {{ ad.title }}
150:           </h3>
151:           <p
152:             v-if="showAds"
153:             class="text-sm"
154:           >
155:             {{ ad.description }}
156:           </p>
157:         </div>
158:       </a>
159:     </div>
160:   </aside>
161: </template>
```

## File: layers/advert/plugins/error-handler.ts
```typescript
 1: import { useErrorHandler } from '@ib/logger'
 2: 
 3: export default defineNuxtPlugin((nuxtApp) => {
 4:   const { handleError } = useErrorHandler()
 5: 
 6:   // Set up global error handlers
 7:   if (import.meta.client) {
 8:     window.addEventListener('error', (event) => {
 9:       handleError(event.error, 'Uncaught Exception')
10:     })
11: 
12:     window.addEventListener('unhandledrejection', (event) => {
13:       handleError(event.reason, 'Unhandled Promise Rejection')
14:     })
15:   }
16: })
```

## File: layers/advert/plugins/sentry.server.ts
```typescript
1: export default defineNuxtPlugin(() => {
2:   const environment = useRuntimeConfig().public.nodeEnv
3: })
```

## File: layers/advert/server/api/advertisement/metrics.get.ts
```typescript
 1: import { promises as fs } from 'fs'
 2: import { resolve } from 'path'
 3: import { defineEventHandler } from 'h3'
 4: 
 5: interface AdMetric {
 6:   adId: number
 7:   impressions: number
 8:   clicks: number
 9:   uniqueViews: number
10:   deviceType: string
11:   viewTimes: number[]
12: }
13: 
14: const adMetricsFilePath = resolve(process.cwd(), 'data', 'advertising', 'metrics.json')
15: 
16: export default defineEventHandler(async (event) => {
17:   try {
18:     const data = await fs.readFile(adMetricsFilePath, 'utf-8')
19:     const metrics: AdMetric[] = JSON.parse(data)
20: 
21:     // Calculate additional metrics
22:     const processedMetrics = Object.values(metrics).map((metric: AdMetric) => {
23:       const ctr = metric.impressions > 0 ? (metric.clicks / metric.impressions) * 100 : 0
24:       const frequency = metric.impressions / metric.uniqueViews
25:       const timeOfDay = metric.viewTimes.map((time) => new Date(time).getHours())
26: 
27:       return {
28:         ...metric,
29:         ctr: ctr.toFixed(2) + '%',
30:         frequency: frequency.toFixed(2),
31:         timeOfDay: timeOfDay.reduce(
32:           (acc, hour) => {
33:             acc[hour] = (acc[hour] || 0) + 1
34:             return acc
35:           },
36:           {} as Record<number, number>,
37:         ),
38:       }
39:     })
40: 
41:     return processedMetrics
42:   } catch (error) {
43:     console.error('Error reading ad metrics:', error)
44:     throw createError({
45:       statusCode: 500,
46:       statusMessage: 'Failed to read ad metrics',
47:     })
48:   }
49: })
```

## File: layers/advert/server/api/advertisement/metrics.post.ts
```typescript
 1: import { promises as fs } from 'fs'
 2: import { resolve } from 'path'
 3: import { defineEventHandler, readBody } from 'h3'
 4: 
 5: const adMetricsFilePath = resolve(process.cwd(), 'data', 'advertising', 'metrics.json')
 6: 
 7: interface AdMetric {
 8:   adId: number
 9:   impressions: number
10:   clicks: number
11:   uniqueViews: number
12:   deviceType: string
13:   viewTimes: number[]
14: }
15: 
16: let batchedMetrics: Record<number, AdMetric> = {}
17: let lastWriteTime = Date.now()
18: const WRITE_INTERVAL = 60000 // 1 minute
19: 
20: const writeMetricsToFile = async () => {
21:   try {
22:     let existingMetrics: Record<number, AdMetric> = {}
23:     try {
24:       const data = await fs.readFile(adMetricsFilePath, 'utf-8')
25:       existingMetrics = JSON.parse(data)
26:     } catch (error) {
27:       console.warn('No existing ad metrics found:', error)
28:       // File doesn't exist yet, start with empty object
29:     }
30: 
31:     // Merge batched metrics with existing metrics
32:     for (const [adId, metric] of Object.entries(batchedMetrics)) {
33:       if (!existingMetrics[adId]) {
34:         existingMetrics[adId] = metric
35:       } else {
36:         existingMetrics[adId].impressions += metric.impressions
37:         existingMetrics[adId].clicks += metric.clicks
38:         existingMetrics[adId].uniqueViews += metric.uniqueViews
39:         existingMetrics[adId].viewTimes.push(...metric.viewTimes)
40:       }
41:     }
42: 
43:     await fs.writeFile(adMetricsFilePath, JSON.stringify(existingMetrics, null, 2), 'utf-8')
44:     batchedMetrics = {} // Clear batched metrics after writing
45:     lastWriteTime = Date.now()
46:   } catch (error) {
47:     console.error('Error writing ad metrics:', error)
48:   }
49: }
50: 
51: export default defineEventHandler(async (event) => {
52:   const body = await readBody(event)
53:   const { metrics } = body as { metrics: Record<number, AdMetric> }
54: 
55:   if (!metrics) {
56:     return { success: false, message: 'No ad metrics received' }
57:   }
58: 
59:   console.log('Received ad metrics:', metrics)
60:   // Merge incoming metrics with batched metrics
61:   for (const [adId, metric] of Object.entries(metrics)) {
62:     if (!batchedMetrics[adId]) {
63:       batchedMetrics[adId] = metric
64:     } else {
65:       batchedMetrics[adId].impressions += metric.impressions
66:       batchedMetrics[adId].clicks += metric.clicks
67:       batchedMetrics[adId].uniqueViews += metric.uniqueViews
68:       batchedMetrics[adId].viewTimes.push(...metric.viewTimes)
69:     }
70:   }
71: 
72:   // Check if it's time to write to file
73:   if (Date.now() - lastWriteTime > WRITE_INTERVAL) {
74:     await writeMetricsToFile()
75:   }
76: 
77:   return { success: true, message: 'Ad metrics received and batched' }
78: })
```

## File: layers/advert/nuxt.config.ts
```typescript
1: import { defineNuxtConfig } from 'nuxt/config'
2: 
3: export default defineNuxtConfig({
4:   workspaceDir: '../../',
5:   srcDir: '.',
6: })
```

## File: layers/auth/.playground/app.config.ts
```typescript
1: export default defineAppConfig({
2:   myLayer: {
3:     name: 'My amazing Nuxt layer (overwritten)'
4:   }
5: })
```

## File: layers/auth/.playground/nuxt.config.ts
```typescript
1: export default defineNuxtConfig({
2:   extends: ['..'],
3:   modules: ['@nuxt/eslint']
4: })
```

## File: layers/auth/composables/user.current.store.ts
```typescript
  1: import { useLogger } from '@ib/logger'
  2: 
  3: const DOMAIN_KEY = 'currentUser'
  4: 
  5: export const useCurrentUser = defineStore(DOMAIN_KEY, () => {
  6:   const authUrl = useRuntimeConfig().public.aeAuthUrl
  7:   const logger = useLogger(DOMAIN_KEY)
  8:   const errors = useBaseError()
  9:   const loading = useLoadingStore()
 10:   const { fetch } = useBaseFetch()
 11:   const userId = useCookie('userId')
 12:   const user = useSupabaseUser()
 13: 
 14:   // check:critical - user should only be able to fetch their own full profile
 15:   // check:critical - user should only be able to update their own profile
 16:   // todo:high - allow user to update their profile info
 17:   // todo:med - merge currentUser and profile into one, store all required data everything in their session
 18:   // assign Posthog identify
 19: 
 20:   console.log('user', user.value)
 21: 
 22:   const profile = computed(() => ({
 23:     id: user.value?.id,
 24:     given_name: user.value?.user_metadata?.given_name,
 25:     email_confirmed_at: user.value?.email_confirmed_at,
 26:     confirmation_sent_at: user.value?.confirmation_sent_at,
 27:     confirmed_at: user.value?.confirmed_at,
 28:     created_at: user.value?.created_at,
 29:     surname: user.value?.user_metadata?.surname,
 30:     last_sign_in_at: user.value?.last_sign_in_at,
 31:     email: user.value?.email,
 32:     providers: user.value?.app_metadata.providers,
 33:     avatar: user.value?.user_metadata.avatar || user.value?.user_metadata.avatar_url,
 34:     provider: user.value?.provider,
 35:     user_role: user.value?.app_metadata?.role,
 36:     user_plan: user.value?.app_metadata?.plan,
 37:   }))
 38: 
 39:   // extract as util func
 40:   function hasValueChanged(newValue: any, currentValue: any): boolean {
 41:     console.log('hasValueChanged', newValue, currentValue)
 42:     if (
 43:       typeof newValue === 'string' ||
 44:       typeof newValue === 'boolean' ||
 45:       typeof newValue === 'number'
 46:     ) {
 47:       return newValue !== currentValue
 48:     } else if (Array.isArray(newValue)) {
 49:       return JSON.stringify(newValue) !== JSON.stringify(currentValue)
 50:     } else if (typeof newValue === 'object' && newValue !== null) {
 51:       return JSON.stringify(newValue) !== JSON.stringify(currentValue)
 52:     } else {
 53:       return newValue !== currentValue
 54:     }
 55:   }
 56: 
 57:   function cleanDataForUpdate(newData: any, previousData: any) {
 58:     const updatedData: any = {}
 59:     for (const key in newData) {
 60:       if (
 61:         Object.hasOwnProperty.call(newData, key) &&
 62:         hasValueChanged(newData[key], previousData[key])
 63:       ) {
 64:         updatedData[key] = newData[key]
 65:       }
 66:     }
 67: 
 68:     return { data: updatedData, noDataUpdated: Object.keys(updatedData).length === 0 }
 69:   }
 70: 
 71:   async function updateProfile(newData: any, isMock: boolean = false) {
 72:     logger.info('Starting updateProfile function', { newData, isMock })
 73:     const updatedData: any = {}
 74:     const toast = useNotification()
 75: 
 76:     logger.debug('Cleaning data for update')
 77:     // Compare newData with fullProfile and only include changed values
 78:     const { noDataUpdated, data } = cleanDataForUpdate(newData, profile.value)
 79: 
 80:     if (noDataUpdated) {
 81:       logger.info('No changes detected, no update necessary')
 82:       return
 83:     }
 84: 
 85:     logger.debug('Changes detected', { changedData: data })
 86: 
 87:     try {
 88:       logger.info('Sending update request to server')
 89:       let response
 90:       if (isMock) {
 91:         logger.info('Using mock API call')
 92:         // response = await mockApiCall(data)
 93:       } else {
 94:         response = await $fetch('/api/users/update', {
 95:           method: 'POST',
 96:           body: JSON.stringify(data),
 97:         })
 98:       }
 99:       logger.debug('Received response from server', { response })
100: 
101:       const validData = errors.server({
102:         response,
103:         devOnly: false,
104:         devMessage: 'Error updating user profile',
105:         userMessage: 'There was an error updating your profile after action',
106:       })
107: 
108:       if (response.error) {
109:         toast.error({ summary: 'Could not update profile', message: response.error.message })
110:         return
111:       } else {
112:         toast.success({
113:           summary: 'Profile updated successfully',
114:           message: 'Your profile was updated',
115:         })
116:       }
117: 
118:       logger.info('Successfully validated server response', { validData })
119: 
120:       // update state
121:       logger.debug('Updating user profile state')
122:       for (const key in data) {
123:         if (Object.hasOwnProperty.call(data, key)) {
124:           profile.value[key] = data[key]
125:           logger.debug(`Updating profile field: ${key}`, {
126:             newValue: data[key],
127:           })
128:         }
129:       }
130:       logger.info('Profile update completed successfully')
131:     } catch (error) {
132:       logger.error('Error occurred during profile update', { error })
133:       throw error // Re-throw the error for the caller to handle
134:     }
135:   }
136: 
137:   // Test function
138:   async function testUpdateProfile() {
139:     const testCases = [
140:       { name: 'John Doe', email: 'john@example.com' },
141:       { name: 'Jane Doe', email: 'error@example.com' }, // This will trigger an error
142:       {}, // This should result in no update
143:     ]
144: 
145:     for (const testCase of testCases) {
146:       try {
147:         console.log('Testing with data:', testCase)
148:         await updateProfile(testCase, true) // Use mock API
149:         console.log('Test passed successfully')
150:       } catch (error) {
151:         console.error('Test failed:', error.message)
152:       }
153:       console.log('---')
154:     }
155:   }
156: 
157:   type FileType = 'avatar'
158:   async function uploadImage(fileType: FileType, blob: Blob) {
159:     // currentFileName is the current file name in the database eg. avatar-drew-macgibbon.jpg
160:     const formData = new FormData()
161:     formData.append('file', blob)
162: 
163:     const response = await $fetch('/api/users/insert/image', {
164:       method: 'POST',
165:       body: formData,
166:       params: {
167:         fileType,
168:         userId: userId.value,
169:       },
170:     })
171: 
172:     console.log('fileName', response)
173: 
174:     const fileName = errors.server({
175:       response,
176:       devOnly: false,
177:       devMessage: `Error uploading ${fileType} image`,
178:       userMessage: `There was an error uploading your ${fileType}`,
179:     })
180: 
181:     let newData = {}
182: 
183:     console.log('fileName', fileName)
184: 
185:     if (fileType === 'avatar') {
186:       newData = {
187:         avatar: fileName,
188:       }
189:     }
190: 
191:     updateProfile(newData)
192:   }
193: 
194:   // first check if the user has an avatar in their profile
195:   // if not, check if the user has an avatar in their identities
196:   // cycle through identities check identities_data for picture
197: 
198:   return {
199:     haveUserSession: computed(() => !!profile.value),
200:     isAdmin: computed(
201:       () => profile.value?.user_role === 'admin' || profile.value?.user_role === 'super_admin',
202:     ),
203:     registeredWithProvider: computed(() => profile.value?.provider),
204:     profile,
205:     uploadImage,
206:     updateProfile,
207:     testUpdateProfile,
208:   }
209: })
210: 
211: if (import.meta.hot) {
212:   import.meta.hot.accept(acceptHMRUpdate(useCurrentUser, import.meta.hot))
213: }
```

## File: layers/auth/server/middleware/cors.ts
```typescript
 1: import { defineEventHandler, getRequestHeader, setResponseHeaders } from 'h3'
 2: 
 3: export default defineEventHandler((event) => {
 4:   const allowedDomains = ['astronera.org', 'up.railway.app', 'rlwy.net', 'localhost']
 5: 
 6:   const origin = getRequestHeader(event, 'origin') || ''
 7: 
 8:   const isAllowedOrigin = allowedDomains.some(
 9:     (domain) =>
10:       origin.startsWith('http://localhost:') || // Allow any localhost port
11:       origin.endsWith(`.${domain}`) || // Allow all subdomains
12:       origin === `https://${domain}`, // Allow apex domain
13:   )
14: 
15:   if (isAllowedOrigin || process.env.NODE_ENV !== 'production') {
16:     setResponseHeaders(event, {
17:       'Access-Control-Allow-Methods': 'GET,HEAD,PUT,PATCH,POST,DELETE',
18:       'Access-Control-Allow-Origin': origin,
19:       'Access-Control-Allow-Credentials': 'true',
20:       'Access-Control-Allow-Headers': 'Content-Type, Authorization, X-Requested-With',
21:       'Access-Control-Expose-Headers': 'Content-Length, X-JSON',
22:     })
23:   }
24: 
25:   console.log('CORS', origin, isAllowedOrigin)
26: 
27:   if (event.method === 'OPTIONS') {
28:     event.node.res.statusCode = 204
29:     event.node.res.statusMessage = 'No Content.'
30:     return 'OK'
31:   }
32: })
```

## File: layers/auth/nuxt.config.ts
```typescript
 1: import { fileURLToPath } from 'url'
 2: import { dirname, join, resolve } from 'path'
 3: import { defineNuxtConfig } from 'nuxt/config'
 4: import tsconfigPaths from 'vite-tsconfig-paths'
 5: 
 6: const currentDir = dirname(fileURLToPath(import.meta.url))
 7: 
 8: console.log('Node Env:', process.env.NODE_ENV)
 9: 
10: export default defineNuxtConfig({
11:   workspaceDir: '../../',
12:   srcDir: '.',
13: 
14:   modules: ['@nuxtjs/supabase'],
15: 
16:   supabase: {
17:     redirect: false,
18:     clientOptions: {
19:       auth: {
20:         flowType: 'pkce',
21:         detectSessionInUrl: true,
22:         persistSession: true,
23:         autoRefreshToken: true,
24:       },
25:     },
26:     cookieOptions: {
27:       domain:
28:         process.env.NODE_ENV === 'production'
29:           ? 'astronera.org' // This will work for all subdomains
30:           : 'localhost',
31:       maxAge: 60 * 60 * 8,
32:       path: '/',
33:       sameSite: 'lax',
34:       secure: process.env.NODE_ENV === 'production' ? true : false,
35:     },
36:     cookieName: 'sb',
37:   },
38: })
```

## File: layers/base/.playground/app.config.ts
```typescript
1: export default defineAppConfig({
2:   myLayer: {
3:     name: 'My amazing Nuxt layer (overwritten)',
4:   },
5: })
```

## File: layers/base/.playground/nuxt.config.ts
```typescript
1: export default defineNuxtConfig({
2:   extends: ['..'],
3:   modules: ['@nuxt/eslint'],
4: })
```

## File: layers/base/components/image/ImageHero.vue
```vue
 1: <script setup lang="ts">
 2: import type { TitleType, ImageType } from '../../types/content'
 3: 
 4: defineProps({
 5:   fit: {
 6:     type: String,
 7:     default: 'cover',
 8:   },
 9:   objectPosition: {
10:     type: String,
11:     default: 'center',
12:   },
13:   title: {
14:     type: Object as () => TitleType,
15:     required: true,
16:   },
17:   img: {
18:     type: Object as () => ImageType,
19:     required: true,
20:   },
21: })
22: 
23: // consider turning the images into short videos using AI
24: // consider using mix-blend-mode for cool text effect with video
25: </script>
26: 
27: <template>
28:   <div class="relative flex items-center justify-center">
29:     <IBImage
30:       :img="{
31:         src: img.src,
32:         alt: img.alt,
33:         width: img.width,
34:         height: img.height,
35:       }"
36:       :class="`w-full object-${fit} ${objectPosition} h-screen`"
37:     />
38:     <div
39:       class="absolute z-10 flex flex-col items-center justify-center gap-8 px-4 text-white lg:flex-row lg:gap-16 xl:px-8"
40:     >
41:       <slot />
42:       <div class="flex flex-col gap-4">
43:         <h2
44:           :class="`rounded-md bg-black/30 px-4 py-1 text-3xl font-bold shadow-xl lg:text-5xl xl:px-8 text-${title.centered ? 'center' : 'left'}`"
45:         >
46:           {{ title.main }}
47:         </h2>
48:         <p
49:           v-if="title.subtitle"
50:           :class="`inline-block w-auto max-w-2xl rounded-sm px-4 pb-4 text-xl font-semibold lg:text-3xl xl:px-8 text-${title.centered ? 'center' : 'left'}`"
51:         >
52:           {{ title.subtitle }}
53:         </p>
54:       </div>
55:     </div>
56:     <div class="absolute left-0 top-0 h-full w-full bg-black/50" />
57:   </div>
58: </template>
59: 
60: <style scoped></style>
```

## File: layers/base/components/image/ImageWithFallback.vue
```vue
 1: <script setup lang="ts">
 2: interface Image {
 3:   src: string
 4:   alt: string | null
 5:   caption: string | null
 6:   credit: string | null
 7: }
 8: 
 9: interface Options {
10:   width: number
11:   height: number
12:   sizes: string | undefined | null
13:   quality: number | undefined | null
14: }
15: 
16: defineProps({
17:   image: {
18:     type: Object as () => Image | undefined,
19:     default: undefined,
20:   },
21:   options: {
22:     type: Object as () => Options | undefined,
23:     default: () => ({
24:       width: 50,
25:       height: 50,
26:       sizes: null,
27:       quality: 80,
28:     }),
29:   },
30: })
31: </script>
32: 
33: <template>
34:   <div class="relative h-full w-full overflow-hidden rounded-md object-cover">
35:     <IBImage
36:       :img="{
37:         src: image?.src || 'hero-image.jpg',
38:         alt: image?.alt || 'this is a default fallback for when an image is not present',
39:         width: options?.width || 60,
40:         height: options?.height || 37,
41:         quality: options?.quality || 80,
42:       }"
43:       class="h-full w-full object-cover"
44:     />
45:     <div
46:       v-if="!image?.src"
47:       class="absolute left-0 top-0 z-50 flex h-full w-full items-center justify-center bg-black/40"
48:     >
49:       <h3 class="foreground rounded-lg px-3 py-1 text-base"> NO IMAGE </h3>
50:     </div>
51:   </div>
52: </template>
```

## File: layers/base/components/Background.vue
```vue
 1: <template>
 2:   <canvas
 3:     ref="canvas"
 4:     class="w-full h-full"
 5:   />
 6: </template>
 7: 
 8: <script setup lang="ts">
 9: const CANVAS_WIDTH = computed(() => (window ? window.innerWidth : 0))
10: const CANVAS_HEIGHT = computed(() => (window ? window.innerHeight + 800 : 0))
11: const STAR_COUNT = 300 // Number of stars
12: const COLORS = ['#ffffff', '#ffcccb', '#add8e6'] // White, red, blue
13: 
14: // Refs
15: const canvas = ref<HTMLCanvasElement | null>(null)
16: let ctx: CanvasRenderingContext2D | null = null
17: let animationFrameId: number
18: 
19: // Utility function to get random number within a range
20: function getRandom(min: number, max: number): number {
21:   return Math.random() * (max - min) + min
22: }
23: 
24: // Create stars array
25: const stars = Array.from({ length: STAR_COUNT }, () => ({
26:   x: getRandom(0, CANVAS_WIDTH.value),
27:   y: getRandom(0, CANVAS_HEIGHT.value),
28:   radius: getRandom(0.5, 2),
29:   color: COLORS[Math.floor(Math.random() * COLORS.length)],
30:   speed: 0.01, // Speed of movement
31:   initialX: 0,
32:   initialY: 0,
33: }))
34: 
35: // Initialize star positions
36: stars.forEach((star) => {
37:   star.initialX = star.x
38:   star.initialY = star.y
39: })
40: 
41: // Draw stars on canvas
42: function drawStars() {
43:   if (!ctx) {
44:     return
45:   }
46: 
47:   ctx.clearRect(0, 0, CANVAS_WIDTH.value, CANVAS_HEIGHT.value)
48: 
49:   stars.forEach((star) => {
50:     ctx.beginPath()
51:     ctx.arc(star.x, star.y, star.radius, 0, 2 * Math.PI, false)
52:     ctx.fillStyle = star.color
53:     ctx.shadowColor = star.color
54:     ctx.shadowBlur = 8
55:     ctx.fill()
56:     ctx.closePath()
57: 
58:     // Update star position to follow an inverted arc path
59:     star.x -= star.speed
60:     star.y =
61:       star.initialY - Math.sin((star.x / CANVAS_WIDTH.value) * Math.PI) * (CANVAS_HEIGHT.value / 4)
62: 
63:     // Wrap stars around edges
64:     if (star.x < 0) {
65:       star.x = CANVAS_WIDTH.value
66:       star.initialY = getRandom(0, CANVAS_HEIGHT.value)
67:     }
68:   })
69: 
70:   // Request next animation frame
71:   animationFrameId = requestAnimationFrame(drawStars)
72: }
73: 
74: // Set up canvas and start animation
75: onMounted(() => {
76:   if (canvas.value) {
77:     canvas.value.width = CANVAS_WIDTH.value
78:     canvas.value.height = CANVAS_HEIGHT.value
79:     ctx = canvas.value.getContext('2d')
80:     if (ctx) {
81:       ctx.fillStyle = 'black'
82:       ctx.fillRect(0, 0, CANVAS_WIDTH.value, CANVAS_HEIGHT.value)
83:       drawStars()
84:     }
85:   }
86: })
87: 
88: // Clean up animation on component unmount
89: onBeforeUnmount(() => {
90:   cancelAnimationFrame(animationFrameId)
91: })
92: </script>
93: 
94: <style scoped>
95: canvas {
96:   width: 100vw;
97:   height: 120vh;
98: }
99: </style>
```

## File: layers/base/components/Breadcrumbs.vue
```vue
 1: <script lang="ts" setup>
 2: const route = useRoute()
 3: 
 4: const generateBreadcrumbs = (path: string) => {
 5:   const pathParts = path.split('/').filter(Boolean)
 6:   let currentPath = ''
 7:   return pathParts.map((part) => {
 8:     currentPath += `/${part}`
 9:     return {
10:       to: currentPath,
11:       label: part.charAt(0).toUpperCase() + part.slice(1),
12:       ariaLabel: part.charAt(0).toUpperCase() + part.slice(1),
13:     }
14:   })
15: }
16: 
17: const links = computed(() => generateBreadcrumbs(route.path))
18: 
19: // Prepare links by filtering and adjusting labels
20: const formattedLinks = computed(() => {
21:   if (!links.value) return []
22:   console.log('Formatting links', links.value)
23:   return links.value
24:     .map((link) => {
25:       if (!link) return null // Skip if link is undefined or null
26: 
27:       // Filter out the home link if in app route
28:       if (link.to === '/') {
29:         console.log('Filtering out home link', link)
30:         return null
31:       }
32: 
33:       // Special handling for the 'astrotribe' path
34:       if (link.to === '/') {
35:         return { ...link, label: 'Home', ariaLabel: 'Home' }
36:       }
37: 
38:       if (link.to === '/ask') {
39:         return { ...link, label: 'Q&A', ariaLabel: 'Q&A' }
40:       }
41: 
42:       return link // Return unmodified link
43:     })
44:     .filter(Boolean) // Remove null entries
45: })
46: </script>
47: 
48: <template>
49:   <PrimeBreadcrumb
50:     v-if="formattedLinks.length"
51:     :model="formattedLinks"
52:     :pt="{
53:       root: 'foreground p-0 flex items-center justify-start',
54:       menu: '!mb-0',
55:     }"
56:   >
57:     <template #item="{ item }">
58:       <NuxtLink :to="item.to">
59:         <span
60:           class="text-primary font-semibold"
61:           :class="item.current ? 'link-active' : ''"
62:         >
63:           {{ item.label }}
64:         </span>
65:       </NuxtLink>
66:     </template>
67:   </PrimeBreadcrumb>
68: </template>
69: 
70: <style></style>
```

## File: layers/base/components/Glass.vue
```vue
  1: <script setup lang="ts">
  2: const uniqueId = useId()
  3: 
  4: const tailwindColors = [
  5:   'slate',
  6:   'gray',
  7:   'zinc',
  8:   'neutral',
  9:   'stone',
 10:   'red',
 11:   'orange',
 12:   'amber',
 13:   'yellow',
 14:   'lime',
 15:   'green',
 16:   'emerald',
 17:   'teal',
 18:   'cyan',
 19:   'sky',
 20:   'blue',
 21:   'indigo',
 22:   'violet',
 23:   'purple',
 24:   'fuchsia',
 25:   'pink',
 26:   'rose',
 27:   'primary', // Assuming you have a custom 'primary' color
 28: ] as const
 29: 
 30: type TailwindColor = (typeof tailwindColors)[number]
 31: 
 32: const props = defineProps({
 33:   color: { type: String as PropType<TailwindColor>, default: 'slate' },
 34:   bgOpacity: { type: Number, default: 20 },
 35:   gradientOpacity: { type: Number, default: 10 },
 36:   blurIntensity: { type: String, default: 'md' },
 37:   disableHover: { type: Boolean, default: false },
 38:   padding: { type: String, default: '6' },
 39:   loading: { type: Boolean, default: false },
 40:   ariaLabel: { type: String, default: 'Glass card' },
 41: })
 42: 
 43: const cardRef = ref<HTMLElement | null>(null)
 44: const gravityAreaRef = ref<HTMLElement | null>(null)
 45: 
 46: const {
 47:   handleMouseMove,
 48:   handleMouseLeave,
 49:   cardStyle,
 50:   spotlightStyle,
 51:   bgClasses,
 52:   borderClasses,
 53:   textClasses,
 54:   gradientClasses,
 55:   hoverClasses,
 56: } = useGlassCard(props, uniqueId)
 57: </script>
 58: 
 59: <template>
 60:   <div
 61:     :id="uniqueId"
 62:     class="relative"
 63:   >
 64:     <div
 65:       ref="gravityAreaRef"
 66:       class="pointer-events-none absolute -inset-[30%] z-0"
 67:     ></div>
 68:     <div
 69:       ref="cardRef"
 70:       :class="[
 71:         'glass-card relative overflow-hidden rounded-md shadow-xl',
 72:         'ring-2 ring-inset ring-white/10',
 73:         `backdrop-blur-${blurIntensity}`,
 74:         `p-${padding}`,
 75:         bgClasses,
 76:         borderClasses,
 77:         textClasses,
 78:         ...hoverClasses,
 79:       ]"
 80:       :style="cardStyle"
 81:       role="region"
 82:       :aria-label="ariaLabel"
 83:       @mousemove="(e) => handleMouseMove(e)"
 84:       @mouseleave="handleMouseLeave"
 85:     >
 86:       <div class="glass-card-content relative z-20">
 87:         <slot name="header"></slot>
 88:         <slot></slot>
 89:       </div>
 90:       <div
 91:         :class="['absolute inset-0 z-10 h-full w-full bg-gradient-to-br', gradientClasses]"
 92:       ></div>
 93:       <div
 94:         class="glass-effect"
 95:         :style="spotlightStyle"
 96:       ></div>
 97:       <div
 98:         v-if="loading"
 99:         class="animate-shimmer absolute inset-0 bg-gradient-to-r from-transparent via-white/10 to-transparent"
100:       ></div>
101:     </div>
102:   </div>
103: </template>
104: 
105: <style scoped>
106: .glass-card {
107:   transition: all 0.3s ease;
108: }
109: 
110: .glass-effect {
111:   position: absolute;
112:   inset: 0;
113:   pointer-events: none;
114:   transition: opacity 0.2s;
115: }
116: 
117: .glass-card-content {
118:   transition: transform 0.3s ease;
119: }
120: 
121: .glass-card:hover .glass-card-content {
122:   transform: translateY(-5px);
123: }
124: 
125: @keyframes shimmer {
126:   0% {
127:     transform: translateX(-100%);
128:   }
129:   100% {
130:     transform: translateX(100%);
131:   }
132: }
133: 
134: .animate-shimmer {
135:   animation: shimmer 1.5s infinite;
136: }
137: 
138: .spotlight {
139:   backdrop-filter: blur(2px) contrast(1.2);
140:   mix-blend-mode: overlay;
141: }
142: </style>
```

## File: layers/base/components/GlobalTimer.vue
```vue
  1: <script setup lang="ts">
  2: const isVisible = ref(true)
  3: const isTracking = ref(false)
  4: const elapsedTime = ref(0)
  5: const currentTask = ref('')
  6: let timer: NodeJS.Timeout | null = null
  7: let startTime: number
  8: let pausedTime = 0
  9: 
 10: function startTimer() {
 11:   if (!import.meta.client) return
 12: 
 13:   if (!isTracking.value) {
 14:     isTracking.value = true
 15:     startTime = Date.now() - pausedTime
 16:     timer = setInterval(() => {
 17:       elapsedTime.value = Math.floor((Date.now() - startTime) / 1000)
 18:     }, 1000)
 19:   }
 20: }
 21: 
 22: function pauseTimer() {
 23:   if (isTracking.value) {
 24:     isTracking.value = false
 25:     if (timer) {
 26:       clearInterval(timer)
 27:       timer = null
 28:     }
 29:     pausedTime = Date.now() - startTime
 30:   }
 31: }
 32: 
 33: function stopTimer() {
 34:   isTracking.value = false
 35:   isVisible.value = false
 36:   if (timer) {
 37:     clearInterval(timer)
 38:     timer = null
 39:   }
 40:   elapsedTime.value = 0
 41:   pausedTime = 0
 42:   currentTask.value = ''
 43: }
 44: 
 45: function showTimer(taskTitle: string) {
 46:   currentTask.value = taskTitle
 47:   isVisible.value = true
 48:   startTimer()
 49: }
 50: 
 51: function formatTime(seconds: number) {
 52:   const hours = Math.floor(seconds / 3600)
 53:   const minutes = Math.floor((seconds % 3600) / 60)
 54:   const secs = seconds % 60
 55:   return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`
 56: }
 57: 
 58: onUnmounted(() => {
 59:   if (timer) clearInterval(timer)
 60: })
 61: 
 62: defineExpose({
 63:   showTimer,
 64:   stopTimer,
 65: })
 66: </script>
 67: 
 68: <template>
 69:   <div
 70:     v-if="isVisible"
 71:     class="flex items-center gap-2 rounded-lg bg-gray-800 p-2 text-white shadow-lg"
 72:   >
 73:     <div class="text-sm font-bold">
 74:       {{ currentTask }}
 75:     </div>
 76:     <div class="text-xl"> ⏱️ {{ formatTime(elapsedTime) }} </div>
 77:     <div class="flex space-x-2">
 78:       <PrimeButton
 79:         v-if="!isTracking"
 80:         size="small"
 81:         class="rounded-full bg-green-500 p-2 hover:bg-green-600"
 82:         @click="startTimer"
 83:       >
 84:         <Icon
 85:           name="mdi:play"
 86:           size="24px"
 87:         />
 88:       </PrimeButton>
 89:       <PrimeButton
 90:         v-else
 91:         size="small"
 92:         class="rounded-full bg-yellow-500 p-2 hover:bg-yellow-600"
 93:         @click="pauseTimer"
 94:       >
 95:         <Icon
 96:           name="mdi:pause"
 97:           size="24px"
 98:         />
 99:       </PrimeButton>
100:       <PrimeButton
101:         size="small"
102:         class="rounded-full bg-red-500 p-2 hover:bg-red-600"
103:         @click="stopTimer"
104:       >
105:         <Icon
106:           name="mdi:stop"
107:           size="24px"
108:         />
109:       </PrimeButton>
110:     </div>
111:   </div>
112: </template>
```

## File: layers/base/components/Grid.vue
```vue
1: <script setup lang="ts"></script>
2: 
3: <template>
4:   <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 2xl:grid-cols-4 md:gap-4 xl:gap-8">
5:     <slot />
6:   </div>
7: </template>
8: 
9: <style scoped></style>
```

## File: layers/base/components/HelloWorld.vue
```vue
 1: <script setup lang="ts">
 2: const { myLayer } = useAppConfig()
 3: </script>
 4: 
 5: <template>
 6:   <div>
 7:     <h1>Hello World!</h1>
 8:     <pre>{{ myLayer }}</pre>
 9:   </div>
10: </template>
```

## File: layers/base/components/HoverCard.vue
```vue
 1: <script setup lang="ts">
 2: const enableHoverEffect = ref(false)
 3: const hoverPosition = ref(null as null | 'up' | 'down') // 'up', 'center', or 'down'
 4: 
 5: function checkHoverPosition(event) {
 6:   if (!enableHoverEffect.value) {
 7:     return // Do nothing if hover effects are disabled
 8:   }
 9:   const rect = event.target.getBoundingClientRect()
10:   const halfScreen = window.innerHeight / 2
11:   if (rect.top < halfScreen) {
12:     console.log('top')
13:     // If the card is in the top third, expand downwards
14:     hoverPosition.value = 'down'
15:   } else {
16:     console.log('bottom')
17:     // If the card is in the bottom third, expand upwards
18:     hoverPosition.value = 'up'
19:   }
20: }
21: 
22: const checkScreenSize = () => {
23:   enableHoverEffect.value = window.innerWidth >= 1024 // Tailwind's 'lg' breakpoint
24: }
25: 
26: const paddingSize = computed(() => (window.innerWidth >= 1280 ? 32 : 16))
27: 
28: onMounted(() => {
29:   window.addEventListener('resize', checkScreenSize)
30:   checkScreenSize()
31:   return () => window.removeEventListener('resize', checkScreenSize)
32: })
33: 
34: // ui:med:easy:1 - if there is only one card in the grid row, we need to set min h of 100% to prevent the card from collapsing
35: </script>
36: 
37: <template>
38:   <div
39:     class="group relative hover:z-50"
40:     @mouseenter="checkHoverPosition"
41:     @mouseleave="hoverPosition = null"
42:   >
43:     <div
44:       :class="[
45:         'transition-all duration-300 delay-200 p-4 border-b-2 md:border border-color overflow-hidden background',
46:         'flex flex-col gap-4 w-full h-full md:rounded-md md:shadow-md',
47:         {
48:           'lg:group-hover:absolute': enableHoverEffect && !!hoverPosition,
49:           'top-0': enableHoverEffect && hoverPosition === 'down',
50:           'bottom-0': enableHoverEffect && hoverPosition === 'up',
51:         },
52:       ]"
53:       :style="{
54:         height: enableHoverEffect && !!hoverPosition ? `calc(200% + ${paddingSize}px)` : '100%',
55:       }"
56:     >
57:       <slot></slot>
58:     </div>
59:   </div>
60: </template>
61: 
62: <style scoped>
63: /* Extra styles if needed */
64: </style>
```

## File: layers/base/components/Image.vue
```vue
 1: <script lang="ts" setup>
 2: const uuid = useId()
 3: 
 4: const props = defineProps({
 5:   img: {
 6:     type: Object,
 7:     required: true,
 8:   },
 9:   noShrink: {
10:     type: Boolean,
11:     default: false,
12:   },
13: })
14: 
15: const imageUrl = ref(null)
16: 
17: watch(
18:   () => props.img.src,
19:   (newVal) => {
20:     imageUrl.value = newVal
21:   },
22:   { immediate: true },
23: )
24: 
25: function loadFallbackImage(error: Error) {
26:   console.error('Image loading error:', error)
27:   imageUrl.value = `images/defaults/${props.img.type ?? 'fallback'}.jpg`
28: }
29: </script>
30: 
31: <template>
32:   <NuxtImg
33:     v-if="imageUrl"
34:     :key="`image-${uuid}`"
35:     v-bind="$attrs"
36:     :src="imageUrl"
37:     :alt="img.alt"
38:     :width="img.width"
39:     :height="img.height"
40:     :format="img.format"
41:     :quality="img.quality"
42:     :loading="img.loading"
43:     crossorigin="anonymous"
44:     :class="{ 'flex shrink-0': !noShrink }"
45:     @error="loadFallbackImage"
46:   />
47: </template>
```

## File: layers/base/components/InfiniteScroll.vue
```vue
 1: <script setup lang="ts">
 2: const emit = defineEmits(['update:scrollEnd'])
 3: const scrollContainer = ref<HTMLElement | null>(null)
 4: const observer = ref<IntersectionObserver | null>(null)
 5: 
 6: onMounted(() => {
 7:   if ('IntersectionObserver' in window) {
 8:     observer.value = new IntersectionObserver(
 9:       (entries) => {
10:         if (entries[0].isIntersecting) {
11:           emit('update:scrollEnd')
12:         }
13:       },
14:       {
15:         root: null,
16:         rootMargin: '200px', // Load more content when within 200px of the bottom
17:         threshold: 0.1, // Trigger when at least 10% of the target is visible
18:       },
19:     )
20: 
21:     if (scrollContainer.value) {
22:       observer.value.observe(scrollContainer.value)
23:     }
24:   } else {
25:     // Fallback for browsers that don't support IntersectionObserver
26:     window.addEventListener('scroll', handleScroll)
27:   }
28: })
29: 
30: onUnmounted(() => {
31:   if (observer.value && scrollContainer.value) {
32:     observer.value.unobserve(scrollContainer.value)
33:   }
34:   window.removeEventListener('scroll', handleScroll)
35: })
36: 
37: const handleScroll = () => {
38:   if (scrollContainer.value) {
39:     const rect = scrollContainer.value.getBoundingClientRect()
40:     if (rect.top <= window.innerHeight) {
41:       emit('update:scrollEnd')
42:     }
43:   }
44: }
45: </script>
46: 
47: <template>
48:   <div>
49:     <slot />
50:     <div
51:       ref="scrollContainer"
52:       class="h-10 bg-transparent"
53:       aria-hidden="true"
54:     />
55:   </div>
56: </template>
```

## File: layers/base/components/Loader.vue
```vue
 1: <script setup lang="ts">
 2: const loaderWidth = ref('100%')
 3: const loaderHeight = ref('100%')
 4: 
 5: defineProps({
 6:   width: {
 7:     type: String,
 8:     default: '100%',
 9:   },
10:   height: {
11:     type: String,
12:     default: '100%',
13:   },
14: })
15: </script>
16: 
17: <template>
18:   <div
19:     class="skeleton-loader"
20:     :style="{ width: loaderWidth, height: loaderHeight }"
21:   ></div>
22: </template>
23: 
24: <style scoped>
25: .skeleton-loader {
26:   background-color: #f3f3f3;
27:   animation: skeleton-loading 1s infinite linear;
28: }
29: 
30: @keyframes skeleton-loading {
31:   0% {
32:     background-position: -200px 0;
33:   }
34:   100% {
35:     background-position: 200px 0;
36:   }
37: }
38: </style>
```

## File: layers/base/components/Modal.vue
```vue
 1: <script setup lang="ts">
 2: const isOpen = ref(false)
 3: 
 4: const toggleModalOpen = () => {
 5:   isOpen.value = !isOpen.value
 6: }
 7: 
 8: const options = ref({
 9:   isOpen,
10:   toggleModalOpen,
11: })
12: </script>
13: 
14: <template>
15:   <div>
16:     <slot
17:       name="button"
18:       v-bind="options"
19:     />
20:     <PrimeDialog
21:       v-model:visible="isOpen"
22:       modal
23:       :pt="{
24:         root: 'max-w-2xl w-full',
25:         content: 'w-full aspect-square',
26:       }"
27:       :pt-options="{ mergeProps: true, mergeSections: true }"
28:     >
29:       <template #header>
30:         <slot name="modal:header" />
31:       </template>
32:       <slot name="modal:default" />
33:       <template #footer>
34:         <slot
35:           name="modal:footer"
36:           v-bind="options"
37:         />
38:       </template>
39:     </PrimeDialog>
40:   </div>
41: </template>
42: 
43: <style scoped></style>
```

## File: layers/base/components/NavHamburger.vue
```vue
 1: <!-- components/nav/NavHamburger.vue -->
 2: <template>
 3:   <button
 4:     class="md:hidden p-2 hover:bg-gray-800 rounded-lg transition-colors flex"
 5:     @click="toggleMobileNav"
 6:   >
 7:     <Icon
 8:       :name="isMobileSidebarOpen ? 'mdi:close' : 'mdi:menu'"
 9:       size="24px"
10:     />
11:   </button>
12: </template>
13: 
14: <script setup lang="ts">
15: const { isMobileSidebarOpen } = useNavigation()
16: 
17: const toggleMobileNav = () => {
18:   isMobileSidebarOpen.value = !isMobileSidebarOpen.value
19: }
20: </script>
```

## File: layers/base/components/NewLabel.vue
```vue
 1: <script setup lang="ts">
 2: const props = defineProps({
 3:   date: {
 4:     type: String,
 5:     required: true,
 6:   },
 7:   maxAge: {
 8:     type: Number,
 9:     required: true,
10:   },
11: })
12: 
13: const isWithinNumberOfDays = computed(() => {
14:   const currentDate = new Date()
15:   const itemDate = new Date(props.date)
16:   const differenceInDays = Math.floor(
17:     (currentDate.getTime() - itemDate.getTime()) / (1000 * 3600 * 24),
18:   )
19:   return differenceInDays <= props.maxAge
20: })
21: </script>
22: 
23: <template>
24:   <PrimeTag
25:     v-if="isWithinNumberOfDays"
26:     severity="success"
27:     value="NEW"
28:   />
29: </template>
```

## File: layers/base/components/Pagination.vue
```vue
 1: <script setup>
 2: import { onMounted, ref } from 'vue'
 3: import { useRoute } from 'vue-router'
 4: 
 5: // todo:high:1 - implement and test on component
 6: 
 7: const route = useRoute()
 8: const slug = route.params.slug // Dynamic slug based on the current route
 9: const items = ref([])
10: const currentPage = ref(1)
11: 
12: // Store and restore pagination state using session storage
13: const sessionStorageKey = `pagination-${slug}`
14: 
15: function restoreState() {
16:   const savedState = sessionStorage.getItem(sessionStorageKey)
17:   if (savedState) {
18:     const state = JSON.parse(savedState)
19:     currentPage.value = state.currentPage
20:     items.value = state.items
21:   }
22: }
23: 
24: function storeState() {
25:   const state = {
26:     currentPage: currentPage.value,
27:     items: items.value,
28:   }
29:   sessionStorage.setItem(sessionStorageKey, JSON.stringify(state))
30: }
31: 
32: async function fetchItems() {
33:   // Placeholder function to simulate fetching items
34:   const newItems = [{ id: Date.now(), content: `Item ${currentPage.value}` }]
35:   items.value.push(...newItems)
36:   currentPage.value += 1
37:   storeState()
38: }
39: 
40: function loadMore() {
41:   fetchItems()
42: }
43: 
44: onMounted(() => {
45:   restoreState()
46:   if (items.value.length === 0) {
47:     fetchItems()
48:   }
49: })
50: </script>
51: 
52: <template>
53:   <div>
54:     <ul v-if="items.length">
55:       <li
56:         v-for="item in items"
57:         :key="item.id"
58:       >
59:         {{ item.content }}
60:       </li>
61:     </ul>
62:     <button @click="loadMore"> Load More </button>
63:   </div>
64: </template>
```

## File: layers/base/components/Popover.vue
```vue
 1: <script setup lang="ts">
 2: const props = defineProps({
 3:   buttonLabel: { type: String, required: true },
 4: })
 5: 
 6: const popover = ref(null)
 7: 
 8: const toggle = (event) => {
 9:   popover.value?.toggle(event)
10: }
11: </script>
12: 
13: <template>
14:   <div>
15:     <PrimeButton
16:       type="button"
17:       size="small"
18:       severity="secondary"
19:       :label="buttonLabel"
20:       @click="toggle"
21:     />
22:     <PrimePopover ref="popover">
23:       <slot></slot>
24:     </PrimePopover>
25:   </div>
26: </template>
27: 
28: <style scoped></style>
```

## File: layers/base/components/Resizable.vue
```vue
 1: <script lang="ts" setup>
 2: const props = defineProps<{
 3:   slots: Record<string, string>
 4: }>()
 5: 
 6: const container = ref<HTMLElement | null>(null)
 7: const resizer = ref<HTMLElement | null>(null)
 8: const sizes = ref<number[]>([1, 1])
 9: 
10: const startResize = (e: MouseEvent) => {
11:   e.preventDefault()
12:   window.addEventListener('mousemove', resize)
13:   window.addEventListener('mouseup', stopResize)
14: }
15: 
16: const resize = (e: MouseEvent) => {
17:   if (!container.value) return
18:   const containerRect = container.value.getBoundingClientRect()
19:   const newLeftWidth = e.clientX - containerRect.left
20:   const containerWidth = containerRect.width
21: 
22:   sizes.value = [newLeftWidth / containerWidth, 1 - newLeftWidth / containerWidth]
23: }
24: 
25: const stopResize = () => {
26:   window.removeEventListener('mousemove', resize)
27:   window.removeEventListener('mouseup', stopResize)
28: }
29: 
30: onMounted(() => {
31:   if (resizer.value) {
32:     resizer.value.addEventListener('mousedown', startResize)
33:   }
34: })
35: 
36: onUnmounted(() => {
37:   if (resizer.value) {
38:     resizer.value.removeEventListener('mousedown', startResize)
39:   }
40:   window.removeEventListener('mousemove', resize)
41:   window.removeEventListener('mouseup', stopResize)
42: })
43: </script>
44: 
45: <template>
46:   <div
47:     ref="container"
48:     class="relative flex h-full w-full"
49:   >
50:     <div
51:       v-for="(componentId, index) in Object.values(slots)"
52:       :key="componentId"
53:       :class="['overflow-auto', index === 0 ? 'pr-4' : 'pl-4']"
54:       :style="{ flex: sizes[index] }"
55:     >
56:       <slot :name="componentId"></slot>
57:     </div>
58:     <div
59:       ref="resizer"
60:       class="w-2 cursor-col-resize bg-gray-200 hover:bg-gray-300"
61:       @mousedown="startResize"
62:     ></div>
63:   </div>
64: </template>
65: 
66: <style scoped>
67: /* Add any additional styles here */
68: </style>
```

## File: layers/base/components/Sidebar.vue
```vue
 1: <script setup lang="ts">
 2: const isSideVisible = ref(true)
 3: </script>
 4: 
 5: <template>
 6:   <div class="top-0 space-y-4 p-8 md:sticky">
 7:     <div class="flex flex-col justify-center md:justify-start">
 8:       <div class="flex gap-4">
 9:         <!-- <PrimeToggleButton
10:           v-model="isSideVisible"
11:           on-label="Hide"
12:           off-label="Show"
13:         >
14:           <Icon :name="isSideVisible ? 'mdi:eye' : 'mdi:sun'" />
15:         </PrimeToggleButton> -->
16:         <!-- <Transition name="slide-fade">
17:           <PrimeMessage
18:             v-show="isSideVisible"
19:             severity="info"
20:             :pt="{ root: '', text: 'text-sm text-left' }"
21:           >
22:             Filters Coming Soon
23:           </PrimeMessage>
24:         </Transition> -->
25:       </div>
26:     </div>
27:   </div>
28: </template>
29: 
30: <style scoped>
31: /*
32:   Enter and leave animations can use different
33:   durations and timing functions.
34: */
35: .slide-fade-enter-active {
36:   transition: all 0.3s ease-out;
37: }
38: 
39: .slide-fade-leave-active {
40:   transition: all 0.8s cubic-bezier(1, 0.5, 0.8, 1);
41: }
42: 
43: .slide-fade-enter-from,
44: .slide-fade-leave-to {
45:   transform: translateX(-20px);
46:   opacity: 0;
47: }
48: 
49: .slide-top-enter-active {
50:   transition: all 0.3s ease-out;
51: }
52: 
53: .slide-top-leave-active {
54:   transition: all 0.8s cubic-bezier(1, 0.5, 0.8, 1);
55: }
56: 
57: .slide-top-enter-from,
58: .slide-top-leave-to {
59:   transform: translateY(-20px);
60:   opacity: 0;
61: }
62: </style>
```

## File: layers/base/components/SideNav.vue
```vue
  1: <script setup lang="ts">
  2: const props = defineProps({
  3:   categories: {
  4:     type: Array,
  5:     required: true,
  6:   },
  7:   showDevHelpers: {
  8:     type: Boolean,
  9:     default: false,
 10:   },
 11:   isMobile: {
 12:     type: Boolean,
 13:     default: false,
 14:   },
 15:   isSidebarOpen: {
 16:     type: Boolean,
 17:     required: true,
 18:   },
 19:   isMobileSidebarOpen: {
 20:     type: Boolean,
 21:     required: true,
 22:   },
 23: })
 24: 
 25: const route = useRoute()
 26: const emit = defineEmits(['update:isSidebarOpen', 'update:isMobileSidebarOpen'])
 27: // Handle navigation - close mobile nav when navigating
 28: const handleNavigation = () => {
 29:   if (props.isMobile) {
 30:     emit('update:isMobileSidebarOpen', false)
 31:   }
 32: }
 33: 
 34: // Watch route changes to close mobile nav
 35: watch(
 36:   () => route.path,
 37:   () => {
 38:     if (props.isMobile) {
 39:       emit('update:isMobileSidebarOpen', false)
 40:     }
 41:   },
 42: )
 43: </script>
 44: 
 45: <template>
 46:   <div class="relative z-50">
 47:     <!-- Mobile Overlay -->
 48:     <div
 49:       v-if="isMobile"
 50:       class="fixed inset-0 z-[90] bg-black/50 transition-opacity duration-300"
 51:       :class="
 52:         isMobileSidebarOpen ? 'opacity-100 pointer-events-auto' : 'opacity-0 pointer-events-none'
 53:       "
 54:       @click="$emit('update:isMobileSidebarOpen', false)"
 55:     />
 56:     <div
 57:       class="flex flex-col background text-gray-300 shadow-lg transition-all duration-300 group"
 58:       :class="[
 59:         // Shared styles
 60:         'h-full',
 61: 
 62:         // Mobile styles
 63:         isMobile && [
 64:           'fixed left-0 top-0 bottom-0 z-[100]',
 65:           'w-[70vw]',
 66:           isMobileSidebarOpen ? 'translate-x-0' : '-translate-x-full',
 67:         ],
 68: 
 69:         // Desktop styles
 70:         !isMobile && ['relative', 'md:translate-x-0', isSidebarOpen ? 'md:w-60' : 'md:w-14'],
 71:       ]"
 72:     >
 73:       <!-- Toggle button (desktop only) -->
 74:       <button
 75:         v-if="!isMobile"
 76:         class="absolute !z-[1000] -right-3 top-24 hidden h-6 w-6 -translate-y-1/2 items-center justify-center rounded-full bg-primary-600 text-gray-300 transition-opacity duration-300 hover:bg-primary-400 group-hover:opacity-100 md:flex"
 77:         :class="[
 78:           'z-[110]', // Ensure button is above other elements
 79:           isSidebarOpen ? 'opacity-0' : 'opacity-100',
 80:         ]"
 81:         :title="isSidebarOpen ? 'Collapse sidebar' : 'Expand sidebar'"
 82:         @click="$emit('update:isSidebarOpen', !isSidebarOpen)"
 83:       >
 84:         <Icon
 85:           :name="isSidebarOpen ? 'mdi:chevron-left' : 'mdi:chevron-right'"
 86:           size="12px"
 87:         />
 88:       </button>
 89: 
 90:       <div class="flex h-full flex-col overflow-hidden">
 91:         <!-- Logo -->
 92:         <div
 93:           class="flex items-center px-4 py-3 transition-all duration-300"
 94:           :class="isMobile || isSidebarOpen ? 'gap-3' : 'justify-center'"
 95:         >
 96:           <div
 97:             class="flex items-center justify-center rounded-md border bg-white transition-all duration-300 delay-150"
 98:             :class="isMobile || isSidebarOpen ? 'h-10 w-10' : 'h-6 w-6'"
 99:           >
100:             <NuxtLink
101:               to="/"
102:               class="flex h-full w-full items-center justify-center"
103:             >
104:               <IBImage
105:                 :img="{ src: '/astronera-logo.jpg', width: 36, height: 36 }"
106:                 class="h-full w-full transition-all duration-300"
107:                 :class="isMobile || isSidebarOpen ? 'p-0.5' : 'p-1'"
108:                 no-shrink
109:               />
110:             </NuxtLink>
111:           </div>
112:           <Transition
113:             enter-active-class="transition-all duration-150 ease-out"
114:             leave-active-class="transition-all duration-150 ease-in"
115:             enter-from-class="opacity-0 -translate-x-4"
116:             leave-to-class="opacity-0 -translate-x-4"
117:           >
118:             <div
119:               v-if="isMobile || isSidebarOpen"
120:               class="flex cursor-pointer flex-col items-start justify-center text-sm font-bold uppercase leading-none tracking-normal"
121:             >
122:               Astron
123:               <strong class="font-extrabold text-primary-400">Era</strong>
124:             </div>
125:           </Transition>
126:         </div>
127: 
128:         <!-- Navigation Categories - always expanded on mobile -->
129:         <nav class="flex-1 space-y-4 px-2 py-4">
130:           <div
131:             v-for="category in categories"
132:             :key="category.id"
133:             class="space-y-1"
134:           >
135:             <div
136:               v-if="isMobile || isSidebarOpen"
137:               class="px-2 text-xs font-semibold uppercase text-gray-400"
138:             >
139:               {{ category.label }}
140:             </div>
141:             <ul>
142:               <li
143:                 v-for="item in category.items"
144:                 :key="item.slug"
145:               >
146:                 <NuxtLink
147:                   :to="item.slug"
148:                   class="flex items-center rounded-lg px-2 py-2 text-sm font-medium hover:bg-primary-700"
149:                   :class="{ 'bg-primary-800': route.path === item.slug }"
150:                   @click="handleNavigation"
151:                 >
152:                   <Icon
153:                     :name="item.icon"
154:                     size="20px"
155:                     class="mr-3 flex-shrink-0"
156:                   />
157:                   <span v-if="isMobile || isSidebarOpen">{{ item.label }}</span>
158:                 </NuxtLink>
159:               </li>
160:             </ul>
161:           </div>
162:         </nav>
163:       </div>
164:     </div>
165:   </div>
166: </template>
167: 
168: <style>
169: .transition-transform {
170:   transition-property: transform, width, height;
171: }
172: </style>
```

## File: layers/base/components/SocialBlock.vue
```vue
 1: <script setup lang="ts">
 2: interface Socials {
 3:   [key: string]: string
 4: }
 5: 
 6: const props = defineProps({
 7:   socials: {
 8:     type: Object as PropType<Socials>,
 9:     required: true,
10:   },
11:   size: {
12:     type: String,
13:     default: '24px',
14:   },
15: })
16: 
17: const socialIcon = (platform: string) => {
18:   switch (platform) {
19:     case 'linkedin':
20:       return 'mdi:linkedin'
21:     case 'youtube':
22:       return 'mdi:youtube'
23:     case 'instagram':
24:       return 'mdi:instagram'
25:     case 'facebook':
26:       return 'mdi:facebook'
27:     case 'twitter':
28:       return 'mdi:twitter'
29:     default:
30:       return ''
31:   }
32: }
33: 
34: const formattedSocials = computed(() => {
35:   if (!props.socials) return []
36:   return Object.entries(props.socials).map(([platform, url]) => {
37:     return {
38:       platform: platform.split('_')[0],
39:       url,
40:       icon: socialIcon(platform.split('_')[0]),
41:     }
42:   })
43: })
44: </script>
45: 
46: <template>
47:   <div
48:     v-if="formattedSocials.length > 0"
49:     class="flex gap-2"
50:   >
51:     <a
52:       v-for="social in formattedSocials"
53:       :key="`${social.platform}-icon`"
54:       class="flex cursor-pointer items-center"
55:       target="_blank"
56:       :href="social.url"
57:     >
58:       <Icon
59:         :name="social.icon"
60:         :size="size"
61:       />
62:     </a>
63:   </div>
64: </template>
65: 
66: <style scoped></style>
```

## File: layers/base/components/TabView.vue
```vue
 1: <script setup lang="ts">
 2: interface Tab {
 3:   title: string
 4:   slotName: string
 5:   value: string
 6: }
 7: 
 8: defineProps<{
 9:   tabs: Tab[]
10: }>()
11: </script>
12: 
13: <template>
14:   <PrimeTabs
15:     value="0"
16:     class="h-full"
17:     scrollable
18:     :pt="{
19:       root: 'w-full h-full',
20:     }"
21:     :pt-options="{ mergeSections: true }"
22:   >
23:     <PrimeTabList
24:       :pt="{
25:         root: 'gap-4 sticky top-0 left-0 z-50 flex text-nowrap flex-grow w-full overflow-scroll bg-black no-scrollbar border-b border-color',
26:       }"
27:       :pt-options="{ mergeSections: true, mergeProps: true }"
28:     >
29:       <PrimeTab
30:         v-for="tab in tabs"
31:         :key="tab.title"
32:         :value="tab.value"
33:         :pt="{
34:           root: ({ context }) => ({
35:             class: [
36:               'text-nowrap px-6 py-4 border-x border-color h-full',
37:               { 'bg-primary-900': context.active },
38:             ],
39:           }),
40:         }"
41:         :pt-options="{ mergeSections: true, mergeProps: true }"
42:       >
43:         {{ tab.title }}
44:       </PrimeTab>
45:     </PrimeTabList>
46:     <PrimeTabPanel
47:       v-for="tab in tabs"
48:       :key="`tab-index-${tab.title}`"
49:       :value="tab.value"
50:       :pt="{
51:         root: 'overflow-scroll h-full',
52:       }"
53:       :pt-options="{ mergeProps: true, mergeSections: true }"
54:     >
55:       <slot :name="tab.slotName" />
56:     </PrimeTabPanel>
57:   </PrimeTabs>
58: </template>
59: 
60: <style></style>
```

## File: layers/base/components/YT.client.vue
```vue
 1: <template>
 2:   <div id="player"></div>
 3: </template>
 4: 
 5: <script setup lang="ts">
 6: const player = ref(null)
 7: 
 8: onMounted(() => {
 9:   // Load the YouTube IFrame API dynamically if it's not already loaded
10:   if (!window.YT) {
11:     // Check if YT object is already present
12:     const tag = document.createElement('script')
13:     tag.src = 'https://www.youtube.com/iframe_api'
14:     const firstScriptTag = document.getElementsByTagName('script')[0]
15:     firstScriptTag.parentNode.insertBefore(tag, firstScriptTag)
16: 
17:     // Define the callback globally to initialize player when API is ready
18:     window.onYouTubeIframeAPIReady = initializePlayer
19:   } else {
20:     // Initialize the player immediately if YT is already loaded
21:     initializePlayer()
22:   }
23: })
24: 
25: function initializePlayer() {
26:   // Make sure the YT object and YT.Player are defined
27:   if (typeof YT !== 'undefined' && YT.Player) {
28:     player.value = new YT.Player('player', {
29:       // Ensure the element ID matches your template
30:       height: '390',
31:       width: '640',
32:       listType: 'user_uploads',
33:       list: 'Fireship', // Make sure 'Fireship' is a correct videoId or replace it with a valid one
34:       events: {
35:         onReady: onPlayerReady,
36:       },
37:     })
38:   }
39: }
40: 
41: function onPlayerReady(event) {
42:   event.target.playVideo()
43: }
44: 
45: onBeforeUnmount(() => {
46:   if (player.value) {
47:     player.value.destroy()
48:   }
49: })
50: </script>
```

## File: layers/base/composables/utils/arrays.ts
```typescript
1: export const removeDuplicates = <T>(arr: T[]): T[] => [...new Set(arr)]
2: 
3: export const sortBy = <T, K extends keyof T>(arr: T[], key: K): T[] =>
4:   arr.sort((a, b) => (a[key] > b[key] ? 1 : a[key] < b[key] ? -1 : 0))
```

## File: layers/base/composables/utils/hasValueChanged.ts
```typescript
 1: export function deepEqual(obj1: any, obj2: any): boolean {
 2:   if (obj1 === obj2) {
 3:     return true
 4:   }
 5: 
 6:   if (typeof obj1 !== 'object' || typeof obj2 !== 'object' || obj1 === null || obj2 === null) {
 7:     return false
 8:   }
 9: 
10:   if (Array.isArray(obj1) && Array.isArray(obj2)) {
11:     if (obj1.length !== obj2.length) {
12:       return false
13:     }
14:     for (let i = 0; i < obj1.length; i++) {
15:       if (!deepEqual(obj1[i], obj2[i])) {
16:         return false
17:       }
18:     }
19:     return true
20:   }
21: 
22:   if (Array.isArray(obj1) || Array.isArray(obj2)) {
23:     return false // One is an array, the other is not
24:   }
25: 
26:   const keys1 = Object.keys(obj1)
27:   const keys2 = Object.keys(obj2)
28: 
29:   if (keys1.length !== keys2.length) {
30:     return false
31:   }
32: 
33:   for (const key of keys1) {
34:     if (!keys2.includes(key) || !deepEqual(obj1[key], obj2[key])) {
35:       return false
36:     }
37:   }
38: 
39:   return true
40: }
41: 
42: export function hasValueChanged(newValue: any, currentValue: any): boolean {
43:   if (
44:     typeof newValue === 'string'
45:     || typeof newValue === 'boolean'
46:     || typeof newValue === 'number'
47:     || newValue === null
48:   ) {
49:     return newValue !== currentValue
50:   }
51: 
52:   if (Array.isArray(newValue) || typeof newValue === 'object') {
53:     return !deepEqual(newValue, currentValue)
54:   }
55: 
56:   return newValue !== currentValue
57: }
58: 
59: interface UpdateData {
60:   [key: string]: any
61: }
62: 
63: interface CleanDataResult {
64:   data: UpdateData
65:   noDataUpdated: boolean
66: }
67: 
68: export function wasRowDataUpdated(newData: UpdateData, previousData: UpdateData): CleanDataResult {
69:   const updatedData: UpdateData = {}
70: 
71:   Object.entries(newData).forEach(([key, value]) => {
72:     if (hasValueChanged(value, previousData[key])) {
73:       updatedData[key] = value
74:     }
75:   })
76: 
77:   return { data: updatedData, noDataUpdated: Object.keys(updatedData).length === 0 }
78: }
```

## File: layers/base/composables/utils/objects.ts
```typescript
1: export const pluck = <T, K extends keyof T>(objs: T[], key: K): T[K][] =>
2:   objs.map((obj) => obj[key])
```

## File: layers/base/composables/utils/strings.ts
```typescript
 1: export const slugify = (str: string): string => {
 2:   str = str.replace(/^\s+|\s+$/g, '')
 3:   str = str.toLowerCase()
 4: 
 5:   const from
 6:     = 'ÁÄÂÀÃÅČÇĆĎÉĚËÈÊẼĔȆÍÌÎÏŇÑÓÖÒÔÕØŘŔŠŤÚŮÜÙÛÝŸŽáäâàãåčçćďéěëèêẽĕȇíìîïňñóöòôõøðřŕšťúůüùûýÿžþÞĐđßÆa·/_,:;'
 7:   const to
 8:     = 'AAAAAACCCDEEEEEEEEIIIINNOOOOOORRSTUUUUUYYZaaaaaacccdeeeeeeeeiiiinnooooooorrstuuuuuyyzbBDdBAa------'
 9:   for (let i = 0, l = from.length; i < l; i++) {
10:     str = str.replace(new RegExp(from.charAt(i), 'g'), to.charAt(i))
11:   }
12: 
13:   str = str
14:     .replace(/[^a-z0-9 -]/g, '')
15:     .replace(/\s+/g, '-')
16:     .replace(/-+/g, '-')
17:   return str
18: }
19: 
20: export function upperCaseFirstLetter(str: string): string {
21:   const firstLetter = str.slice(0, 1)
22:   return firstLetter.toUpperCase() + str.substring(1)
23: }
24: 
25: export const stringIsNull = (value: any): boolean =>
26:   value === null || value === undefined || value === '' || value.length === 0
```

## File: layers/base/composables/utils/time.ts
```typescript
 1: export function toDateObject(inputDate = '2022-03-01T10:30:00-05:00') {
 2:   // !todo - add support for internationalization
 3:   // !todo - add support for dynamic length
 4:   const length = 'short'
 5:   // convert date to local time
 6:   const date = new Date(inputDate.toLocaleString())
 7: 
 8:   const formattedDate = new Intl.DateTimeFormat('en-US', {
 9:     weekday: length,
10:     year: 'numeric',
11:     month: length,
12:     day: 'numeric',
13:     hour: 'numeric',
14:     minute: 'numeric',
15:     timeZoneName: length,
16:   }).format(date)
17: 
18:   const dateArray = formattedDate.split(', ')
19: 
20:   return {
21:     weekday: dateArray[0],
22:     month: dateArray[1].split(' ')[0],
23:     day: dateArray[1].split(' ')[1],
24:     time: dateArray[3].split(' ')[0],
25:     ampm: dateArray[3].split(' ')[1],
26:     timezone: dateArray[3].split(' ')[2],
27:     year: dateArray[2],
28:   }
29: }
30: 
31: export function lastSeen(lastSeenTimestamp: string): string {
32:   const now = new Date()
33:   const lastSeen = new Date(lastSeenTimestamp)
34:   const secondsSinceLastSeen = Math.round((now.getTime() - lastSeen.getTime()) / 1000)
35: 
36:   if (secondsSinceLastSeen < 60) {
37:     return `${secondsSinceLastSeen} second${secondsSinceLastSeen === 1 ? '' : 's'} ago`
38:   }
39: 
40:   const minutesSinceLastSeen = Math.round(secondsSinceLastSeen / 60)
41: 
42:   if (minutesSinceLastSeen < 60) {
43:     return `${minutesSinceLastSeen} minute${minutesSinceLastSeen === 1 ? '' : 's'} ago`
44:   }
45: 
46:   const hoursSinceLastSeen = Math.round(minutesSinceLastSeen / 60)
47: 
48:   if (hoursSinceLastSeen < 24) {
49:     return `${hoursSinceLastSeen} hour${hoursSinceLastSeen === 1 ? '' : 's'} ago`
50:   }
51: 
52:   const daysSinceLastSeen = Math.round(hoursSinceLastSeen / 24)
53:   return `${daysSinceLastSeen} day${daysSinceLastSeen === 1 ? '' : 's'} ago`
54: }
```

## File: layers/base/composables/ab-test.ts
```typescript
 1: import type { DefineComponent } from 'vue'
 2: 
 3: export enum TestGoal {
 4:   SignUp = 'sign_up',
 5:   Purchase = 'purchase',
 6:   FeatureUsage = 'feature_usage',
 7:   TimeOnPage = 'time_on_page',
 8:   ClickThroughRate = 'click_through_rate',
 9: }
10: 
11: interface ABTestVariant<T> {
12:   name: string
13:   value: T
14: }
15: 
16: interface ABTestConfig<T> {
17:   experimentName: string
18:   variants: ABTestVariant<T>[]
19:   defaultVariant: ABTestVariant<T>
20:   goals: TestGoal[]
21: }
22: 
23: export function useABTest<T>({ experimentName, variants, defaultVariant, goals }: ABTestConfig<T>) {
24:   const { $posthog } = useNuxtApp()
25: 
26:   const selectedVariant = ref<ABTestVariant<T>>(defaultVariant)
27: 
28:   // Use PostHog's experiment feature to get the variant
29:   const variantName = $posthog.getFeatureFlag(experimentName)
30:   selectedVariant.value = variants.find((v) => v.name === variantName) || defaultVariant
31: 
32:   // Capture experiment exposure
33:   $posthog.capture('$experiment_started', {
34:     experiment: experimentName,
35:     variant: selectedVariant.value.name,
36:     goals: goals,
37:   })
38: 
39:   const value = computed(() => selectedVariant.value.value)
40: 
41:   // Function to track goal completion
42:   const trackGoal = (goal: TestGoal, properties: Record<string, any> = {}) => {
43:     $posthog.capture(goal, {
44:       ...properties,
45:       $experiment_name: experimentName,
46:       $variant: selectedVariant.value.name,
47:     })
48:   }
49: 
50:   return {
51:     variant: selectedVariant,
52:     value,
53:     trackGoal,
54:   }
55: }
56: 
57: // Helper function for component-based A/B tests
58: type ComponentVariant = ABTestVariant<DefineComponent<any, any, any>>
59: 
60: export function useComponentABTest(config: ABTestConfig<DefineComponent<any, any, any>>) {
61:   const { variant, trackGoal } = useABTest(config)
62: 
63:   const TestComponent = computed(() => ({
64:     render() {
65:       return h(variant.value.value.component)
66:     },
67:   }))
68: 
69:   return {
70:     TestComponent,
71:     trackGoal,
72:   }
73: }
```

## File: layers/base/composables/analytics.ts
```typescript
  1: import { ref, onMounted, onUnmounted } from 'vue'
  2: import { useRoute } from 'vue-router'
  3: 
  4: export enum UserAcquisitionMetric {
  5:   SignUpConversion = 'sign_up_conversion',
  6:   DemoRequest = 'demo_request',
  7:   ContactFormSubmission = 'contact_form_submission',
  8:   FeaturePageEngagement = 'feature_page_engagement',
  9:   BlogTraffic = 'blog_traffic',
 10: }
 11: 
 12: export enum OnboardingMetric {
 13:   StartRate = 'start_rate',
 14:   StepCompletion = 'step_completion',
 15:   DropOff = 'drop_off',
 16:   CompletionTime = 'completion_time',
 17: }
 18: 
 19: export enum UserEngagementMetric {
 20:   SessionDuration = 'session_duration',
 21:   ActionsPerSession = 'actions_per_session',
 22:   VisitFrequency = 'visit_frequency',
 23:   FeatureAdoption = 'feature_adoption',
 24: }
 25: 
 26: export enum ContentPerformanceMetric {
 27:   ArticleView = 'article_view',
 28:   ReadTime = 'read_time',
 29:   Share = 'share',
 30:   Like = 'like',
 31:   Comment = 'comment',
 32: }
 33: 
 34: export enum JobMarketMetric {
 35:   JobListing = 'job_listing',
 36:   JobView = 'job_view',
 37:   JobApplication = 'job_application',
 38:   CompanyProfileCreation = 'company_profile_creation',
 39:   CompanyFollow = 'company_follow',
 40: }
 41: 
 42: export enum TechnicalPerformanceMetric {
 43:   PageLoadTime = 'page_load_time',
 44:   APIResponseTime = 'api_response_time',
 45:   ErrorRate = 'error_rate',
 46:   Uptime = 'uptime',
 47: }
 48: 
 49: export type ContentType = 'blog_post' | 'news_article' | 'company_profile' | 'job_listing'
 50: 
 51: export type ErrorType = 'javascript_error' | 'api_error' | '404_error'
 52: 
 53: export interface AnalyticsEventProperties {
 54:   [key: string]: any
 55: }
 56: 
 57: export function useAnalytics() {
 58:   const { $posthog } = useNuxtApp()
 59:   const route = useRoute()
 60:   const pageEnterTime = ref(Date.now())
 61: 
 62:   const trackEvent = (eventName: string, properties?: AnalyticsEventProperties) => {
 63:     $posthog.capture(eventName, properties)
 64:   }
 65: 
 66:   const trackPageView = (properties?: AnalyticsEventProperties) => {
 67:     const timeSpent = Date.now() - pageEnterTime.value
 68:     $posthog.capture('$pageview', {
 69:       path: route.path,
 70:       title: document.title,
 71:       timeSpent,
 72:       ...properties,
 73:     })
 74:     pageEnterTime.value = Date.now()
 75:   }
 76: 
 77:   const identifyUser = (userId: string, properties?: AnalyticsEventProperties) => {
 78:     $posthog.identify(userId, properties)
 79:   }
 80: 
 81:   const trackError = (errorType: ErrorType, errorDetails: string, componentName?: string) => {
 82:     $posthog.capture('Error Occurred', {
 83:       errorType,
 84:       errorDetails,
 85:       componentName,
 86:     })
 87:   }
 88: 
 89:   const trackUserAcquisition = (
 90:     metric: UserAcquisitionMetric,
 91:     properties?: AnalyticsEventProperties,
 92:   ) => {
 93:     $posthog.capture(`User Acquisition - ${metric}`, properties)
 94:   }
 95: 
 96:   const trackOnboarding = (metric: OnboardingMetric, properties?: AnalyticsEventProperties) => {
 97:     $posthog.capture(`Onboarding - ${metric}`, properties)
 98:   }
 99: 
100:   const trackUserEngagement = (
101:     metric: UserEngagementMetric,
102:     properties?: AnalyticsEventProperties,
103:   ) => {
104:     $posthog.capture(`User Engagement - ${metric}`, properties)
105:   }
106: 
107:   const trackContentPerformance = (
108:     metric: ContentPerformanceMetric,
109:     contentType: ContentType,
110:     properties?: AnalyticsEventProperties,
111:   ) => {
112:     $posthog.capture(`Content Performance - ${contentType} - ${metric}`, properties)
113:   }
114: 
115:   const trackJobMarketActivity = (
116:     metric: JobMarketMetric,
117:     properties?: AnalyticsEventProperties,
118:   ) => {
119:     $posthog.capture(`Job Market - ${metric}`, properties)
120:   }
121: 
122:   const trackTechnicalPerformance = (
123:     metric: TechnicalPerformanceMetric,
124:     value: number,
125:     properties?: AnalyticsEventProperties,
126:   ) => {
127:     $posthog.capture(`Technical Performance - ${metric}`, { value, ...properties })
128:   }
129: 
130:   // Session tracking
131:   onMounted(() => {
132:     trackPageView()
133:     $posthog.capture('Session Started')
134:   })
135: 
136:   onUnmounted(() => {
137:     trackPageView()
138:     $posthog.capture('Session Ended', {
139:       sessionDuration: Date.now() - pageEnterTime.value,
140:     })
141:   })
142: 
143:   return {
144:     trackEvent,
145:     trackPageView,
146:     identifyUser,
147:     trackUserAcquisition,
148:     trackOnboarding,
149:     trackUserEngagement,
150:     trackContentPerformance,
151:     trackJobMarketActivity,
152:     trackTechnicalPerformance,
153:     trackError,
154:   }
155: }
156: 
157: // import {
158: //   UserAcquisitionMetric,
159: //   OnboardingMetric,
160: //   UserEngagementMetric,
161: //   ContentPerformanceMetric,
162: //   JobMarketMetric,
163: //   TechnicalPerformanceMetric,
164: //   ContentType,
165: //   ErrorType
166: // } from '~/types/analytics'
167: 
168: // const {
169: //   trackUserAcquisition,
170: //   trackOnboarding,
171: //   trackUserEngagement,
172: //   trackContentPerformance,
173: //   trackJobMarketActivity,
174: //   trackTechnicalPerformance,
175: //   trackError
176: // } = useAnalytics()
177: 
178: // // Track a sign-up conversion
179: // trackUserAcquisition(UserAcquisitionMetric.SignUpConversion, { source: 'organic' })
180: 
181: // // Track an onboarding step completion
182: // trackOnboarding(OnboardingMetric.StepCompletion, { step: 'personal_info', timeSpent: 120 })
183: 
184: // // Track a feature adoption
185: // trackUserEngagement(UserEngagementMetric.FeatureAdoption, { feature: 'job_search' })
186: 
187: // // Track a blog post share
188: // trackContentPerformance(ContentPerformanceMetric.Share, 'blog_post', { postId: '123', platform: 'twitter' })
189: 
190: // // Track a job application
191: // trackJobMarketActivity(JobMarketMetric.JobApplication, { jobId: '456', companyId: '789' })
192: 
193: // // Track page load time
194: // trackTechnicalPerformance(TechnicalPerformanceMetric.PageLoadTime, performance.now())
195: 
196: // // Track an error
197: // trackError(ErrorType.APIError, 'Failed to fetch job listings', 'JobSearchComponent')
```

## File: layers/base/composables/glass-card.ts
```typescript
  1: interface GlassCardProps {
  2:   color: string
  3:   bgOpacity: number
  4:   gradientOpacity: number
  5:   blurIntensity: string
  6:   disableHover: boolean
  7:   padding: string
  8:   loading: boolean
  9:   ariaLabel: string
 10: }
 11: 
 12: const cardStates = reactive<Record<string, any>>({})
 13: 
 14: export function useGlassCard(props: GlassCardProps, uniqueId: string) {
 15:   if (!cardStates[uniqueId]) {
 16:     cardStates[uniqueId] = {
 17:       tiltFactor: 0,
 18:       mouseX: 0,
 19:       mouseY: 0,
 20:       isOutside: true,
 21:       cardWidth: 0,
 22:       cardHeight: 0,
 23:     }
 24:   }
 25: 
 26:   const state = cardStates[uniqueId]
 27: 
 28:   const handleMouseMove = (event: MouseEvent) => {
 29:     const cardElement = document.getElementById(uniqueId)?.querySelector('.glass-card')
 30:     if (!cardElement) return
 31: 
 32:     const cardRect = cardElement.getBoundingClientRect()
 33: 
 34:     state.cardWidth = cardRect.width
 35:     state.cardHeight = cardRect.height
 36: 
 37:     const gravityArea = 100 // pixels around the card
 38:     const x = event.clientX - cardRect.left
 39:     const y = event.clientY - cardRect.top
 40: 
 41:     // Check if the mouse is within the gravity field
 42:     if (
 43:       x >= -gravityArea &&
 44:       x <= cardRect.width + gravityArea &&
 45:       y >= -gravityArea &&
 46:       y <= cardRect.height + gravityArea
 47:     ) {
 48:       state.mouseX = x
 49:       state.mouseY = y
 50:       state.isOutside = false
 51: 
 52:       // Calculate distance from the edge of the card
 53:       const distanceX = Math.max(0, -x, x - cardRect.width)
 54:       const distanceY = Math.max(0, -y, y - cardRect.height)
 55:       const distance = Math.sqrt(distanceX * distanceX + distanceY * distanceY)
 56: 
 57:       // Calculate tilt factor
 58:       if (x >= 0 && x <= cardRect.width && y >= 0 && y <= cardRect.height) {
 59:         state.tiltFactor = 1 // Cursor is directly over the card
 60:       } else {
 61:         // Smooth transition in the gravity area
 62:         state.tiltFactor = Math.max(0, 1 - distance / gravityArea)
 63:       }
 64:     } else {
 65:       state.tiltFactor = 0
 66:       state.isOutside = true
 67:     }
 68:   }
 69: 
 70:   const handleMouseLeave = () => {
 71:     state.tiltFactor = 0
 72:     state.isOutside = true
 73:   }
 74: 
 75:   const cardStyle = computed(() => {
 76:     if (state.isOutside) return {}
 77: 
 78:     const maxTilt = 4 // maximum tilt in degrees
 79: 
 80:     // Use cardWidth and cardHeight from state instead of getting them from cardRef
 81:     const centerX = state.cardWidth / 2
 82:     const centerY = state.cardHeight / 2
 83: 
 84:     const tiltY = ((state.mouseX - centerX) / centerX) * maxTilt * state.tiltFactor
 85:     const tiltX = ((centerY - state.mouseY) / centerY) * maxTilt * state.tiltFactor
 86: 
 87:     return {
 88:       transform: `perspective(1000px) rotateX(${tiltX}deg) rotateY(${tiltY}deg)`,
 89:       transition: state.isOutside ? 'transform 0.3s ease-out' : 'none',
 90:     }
 91:   })
 92: 
 93:   const spotlightColor = computed(() => {
 94:     const hue = (state.mouseX / state.cardWidth) * 360
 95:     return `hsl(${hue}, 100%, 70%)`
 96:   })
 97: 
 98:   const spotlightStyle = computed(() => {
 99:     if (state.isOutside) return { opacity: 0 }
100: 
101:     const spotlightSize = 300 // Fixed 300px radius
102:     const opacity = 0.07 + state.tiltFactor * 0.08
103: 
104:     return {
105:       background: `
106:       radial-gradient(circle ${spotlightSize}px at ${state.mouseX}px ${state.mouseY}px, 
107:       ${spotlightColor.value}, 
108:       transparent 70%),
109:       radial-gradient(circle ${spotlightSize * 0.8}px at ${state.mouseX}px ${state.mouseY}px, 
110:       ${spotlightColor.value}, 
111:       transparent 70%)
112:     `,
113:       opacity: opacity,
114:       transition: 'opacity 0.3s ease-out',
115:       mixBlendMode: 'soft-light',
116:     }
117:   })
118: 
119:   const bgClasses = computed(() => [
120:     `bg-${props.color}-950/${props.bgOpacity}`,
121:     `hover:bg-${props.color}-900/${props.bgOpacity + 10}`,
122:   ])
123: 
124:   const borderClasses = computed(() => [
125:     'border',
126:     'border-color',
127:     `hover:border-${props.color}-400/40`,
128:   ])
129: 
130:   const textClasses = computed(() => [`text-${props.color}-100`])
131: 
132:   const gradientClasses = computed(() => [
133:     `from-${props.color}-100/${props.gradientOpacity}`,
134:     `to-${props.color}-500/${props.gradientOpacity}`,
135:   ])
136: 
137:   const hoverClasses = computed(() =>
138:     props.disableHover
139:       ? []
140:       : ['hover:shadow-2xl', `hover:bg-${props.color}-800/${props.bgOpacity + 10}`],
141:   )
142: 
143:   return {
144:     handleMouseMove,
145:     handleMouseLeave,
146:     cardStyle,
147:     spotlightStyle,
148:     bgClasses,
149:     borderClasses,
150:     textClasses,
151:     gradientClasses,
152:     hoverClasses,
153:   }
154: }
```

## File: layers/base/composables/metrics.ts
```typescript
 1: function roundToNDecimalPlaces(value: number, n: number): number {
 2:   return Number(value.toFixed(n))
 3: }
 4: 
 5: function calculateMedian(arr: number[]): number {
 6:   const sorted = arr.slice().sort((a, b) => a - b)
 7:   const mid = Math.floor(sorted.length / 2)
 8:   return sorted.length % 2 !== 0 ? sorted[mid] : (sorted[mid - 1] + sorted[mid]) / 2
 9: }
10: 
11: function calculateStandardDeviation(valuesArray: number[]): number {
12:   const mean = valuesArray.reduce((a, b) => a + b) / valuesArray.length
13:   return Math.sqrt(
14:     valuesArray.map((x) => Math.pow(x - mean, 2)).reduce((a, b) => a + b) / valuesArray.length,
15:   )
16: }
17: 
18: function calculateMean(arr: number[]): number {
19:   return arr.reduce((a, b) => a + b) / arr.length
20: }
21: 
22: function calculateVariance(arr: number[]): number {
23:   const mean = calculateMean(arr)
24:   return arr.reduce((sum, value) => sum + Math.pow(value - mean, 2), 0) / arr.length
25: }
26: 
27: function calculateRange(arr: number[]): number {
28:   return Math.max(...arr) - Math.min(...arr)
29: }
30: 
31: function calculateSum(arr: number[]): number {
32:   return arr.reduce((a, b) => a + b, 0)
33: }
34: 
35: function calculateMode(arr: number[]): number | number[] {
36:   const frequency: { [key: number]: number } = {}
37:   let maxFreq = 0
38:   let modes: number[] = []
39: 
40:   arr.forEach((value) => {
41:     frequency[value] = (frequency[value] || 0) + 1
42:     if (frequency[value] > maxFreq) {
43:       maxFreq = frequency[value]
44:       modes = [value]
45:     } else if (frequency[value] === maxFreq) {
46:       modes.push(value)
47:     }
48:   })
49: 
50:   return modes.length === 1 ? modes[0] : modes
51: }
52: 
53: function calculateMin(arr: number[]): number {
54:   return Math.min(...arr)
55: }
56: 
57: function calculateMax(arr: number[]): number {
58:   return Math.max(...arr)
59: }
60: 
61: function calculatePercentile(arr: number[], percentile: number): number {
62:   if (percentile < 0 || percentile > 100) {
63:     throw new Error('Percentile must be between 0 and 100')
64:   }
65:   const sorted = arr.slice().sort((a, b) => a - b)
66:   const index = (percentile / 100) * (sorted.length - 1)
67:   const lower = Math.floor(index)
68:   const upper = lower + 1
69:   const weight = index % 1
70: 
71:   if (upper >= sorted.length) {
72:     return sorted[lower]
73:   }
74: 
75:   return sorted[lower] * (1 - weight) + sorted[upper] * weight
76: }
77: 
78: export function useBaseMetrics() {
79:   return {
80:     format: {
81:       roundToN: roundToNDecimalPlaces,
82:     },
83:     calculate: {
84:       median: calculateMedian,
85:       standardDeviation: calculateStandardDeviation,
86:       mean: calculateMean,
87:       variance: calculateVariance,
88:       range: calculateRange,
89:       sum: calculateSum,
90:       mode: calculateMode,
91:       min: calculateMin,
92:       max: calculateMax,
93:       percentile: calculatePercentile,
94:     },
95:   }
96: }
```

## File: layers/base/composables/modal.ts
```typescript
 1: export function useModal() {
 2:   // was used for news modals at one point
 3:   const currentPost = computed(() => news.value[currentIndex.value])
 4:   const nextPost = computed(() => news.value[nextIndex.value])
 5:   const previousPost = computed(() => news.value[previousIndex.value])
 6:   const isModalOpen = ref(false)
 7:   const currentIndex = ref(0)
 8:   const previousIndex = computed(() => (currentIndex.value > 0 ? currentIndex.value - 1 : 0))
 9:   const nextIndex = computed(() =>
10:     currentIndex.value < news.value.length - 1 ? currentIndex.value + 1 : currentIndex.value,
11:   )
12: 
13:   const toggleModal = (postIndex?: number) => {
14:     isModalOpen.value = !isModalOpen.value
15:     if (postIndex !== undefined) {
16:       currentIndex.value = postIndex
17:     }
18:   }
19: 
20:   const next = () => {
21:     if (currentIndex.value < news.value.length - 1) {
22:       currentIndex.value++
23:     }
24:   }
25: 
26:   const previous = () => {
27:     if (currentIndex.value > 0) {
28:       currentIndex.value--
29:     }
30:   }
31: }
```

## File: layers/base/composables/notification.ts
```typescript
 1: import type { useToast } from 'primevue/usetoast'
 2: 
 3: interface BaseNotification {
 4:   summary: string
 5:   message: string
 6: }
 7: 
 8: export function useNotification() {
 9:   const nuxtApp = useNuxtApp()
10:   const getToast: typeof useToast = () => nuxtApp.vueApp.config.globalProperties.$toast
11:   const toast = getToast()
12: 
13:   const success = ({ summary, message }: BaseNotification) => {
14:     toast.add({
15:       severity: 'success',
16:       summary: `Success: ${summary}`,
17:       detail: message,
18:       life: 5000,
19:       closable: true,
20:     })
21:   }
22: 
23:   const error = ({ summary, message }: BaseNotification) => {
24:     toast.add({
25:       severity: 'error',
26:       summary: `Error: ${summary}`,
27:       detail: message,
28:       life: 0,
29:       closable: true,
30:     })
31:   }
32: 
33:   const info = ({ summary, message }: BaseNotification) => {
34:     toast.add({
35:       severity: 'info',
36:       summary: `Info: ${summary}`,
37:       detail: message,
38:       life: 5000,
39:       closable: true,
40:     })
41:   }
42: 
43:   const warn = ({ summary, message }: BaseNotification) => {
44:     toast.add({
45:       severity: 'warn',
46:       summary: `Warning: ${summary}`,
47:       detail: message,
48:       life: 5000,
49:       closable: true,
50:     })
51:   }
52: 
53:   const feature = ({ summary, message }: BaseNotification) => {
54:     toast.add({
55:       severity: 'warn',
56:       group: 'cta',
57:       summary: summary,
58:       detail: message,
59:       life: 0,
60:       closable: true,
61:     })
62:   }
63: 
64:   return {
65:     success,
66:     error,
67:     info,
68:     warn,
69:     feature,
70:   }
71: }
```

## File: layers/base/composables/settings.store.ts
```typescript
 1: type SettingsKey = 'usersStore' | 'storeNews'
 2: 
 3: export const useSettingsStore = defineStore('settingsStore', () => {
 4:   const settings = ref({} as Settings)
 5:   const summaryLevel = ref('beginner' as SummaryLevel)
 6: 
 7:   function toggleSettings(key: SettingsKey) {
 8:     settings.value[key] = !settings.value[key]
 9:   }
10: 
11:   function isSettingsOn(key: SettingsKey) {
12:     return !settings.value[key]
13:   }
14: 
15:   const changeSummaryLevel = (level: 'beginner' | 'intermediate' | 'expert') => {
16:     summaryLevel.value = level
17:   }
18: 
19:   return {
20:     toggleSettings,
21:     isSettingsOn,
22:   }
23: })
24: 
25: if (import.meta.hot) {
26:   import.meta.hot.accept(acceptHMRUpdate(useSettingsStore, import.meta.hot))
27: }
```

## File: layers/base/composables/social.store.ts
```typescript
  1: import { useLogger } from '@ib/logger'
  2: 
  3: export const useSocialStore = defineStore('settingsStore', () => {
  4:   const errors = useBaseError()
  5:   const logger = useLogger('useSocialStore')
  6:   const { fetch } = useBaseFetch()
  7: 
  8:   const youtube = ref({})
  9:   async function getYoutubeAnalytics(channelName: string) {
 10:     logger.info(`getting youtube analytics for ${channelName}`)
 11:     const response = await fetch('/api/social/youtube/analytics', {
 12:       method: 'GET',
 13:       query: {
 14:         channelName,
 15:       },
 16:     })
 17: 
 18:     const data = errors.server({
 19:       response,
 20:       devOnly: false,
 21:       devMessage: 'error getting youtube analytics',
 22:       userMessage: 'something went wrong when getting youtube analytics',
 23:     })
 24: 
 25:     youtube.value = data
 26:   }
 27: 
 28:   const instagram = ref<any>(null)
 29:   async function getInstagramAnalytics(userId: string) {
 30:     const logger = useLogger('getInstagramAnalytics')
 31:     logger.info(`Fetching Instagram analytics for ${userId}`)
 32:     try {
 33:       const response = await $fetch(`/api/social/instagram/analytics?userId=${userId}`, {
 34:         method: 'GET',
 35:       })
 36: 
 37:       const data = errors.server({
 38:         response,
 39:         devOnly: false,
 40:         devMessage: 'Error getting Instagram analytics',
 41:         userMessage: 'Something went wrong when getting Instagram analytics',
 42:       })
 43: 
 44:       instagram.value = data
 45:     } catch (error) {
 46:       errors.client({
 47:         error,
 48:         devOnly: false,
 49:         devMessage: 'Error getting Instagram analytics',
 50:         userMessage: 'Something went wrong when getting Instagram analytics',
 51:       })
 52:     }
 53:   }
 54: 
 55:   const linkedin = ref<any>(null)
 56:   async function getLinkedInAnalytics(postId: string) {
 57:     const logger = useLogger('getLinkedInAnalytics')
 58:     logger.info(`Fetching LinkedIn analytics for post ${postId}`)
 59:     try {
 60:       const response = await $fetch(`/api/social/linkedin/analytics?postId=${postId}`, {
 61:         method: 'GET',
 62:       })
 63: 
 64:       const data = errors.server({
 65:         response,
 66:         devOnly: false,
 67:         devMessage: 'Error getting LinkedIn analytics',
 68:         userMessage: 'Something went wrong when getting LinkedIn analytics',
 69:       })
 70: 
 71:       linkedin.value = data
 72:     } catch (error) {
 73:       errors.client({
 74:         error,
 75:         devOnly: false,
 76:         devMessage: 'Error getting LinkedIn analytics',
 77:         userMessage: 'Something went wrong when getting LinkedIn analytics',
 78:       })
 79:     }
 80:   }
 81: 
 82:   const twitter = ref<any>(null)
 83:   async function getTwitterAnalytics(postId: string) {
 84:     const logger = useLogger('getTwitterAnalytics')
 85:     logger.info(`Fetching Twitter analytics for post ${postId}`)
 86:     try {
 87:       const response = await fetch(`/api/social/twitter/analytics?postId=${postId}`, {
 88:         method: 'GET',
 89:       })
 90: 
 91:       const data = errors.server({
 92:         response,
 93:         devOnly: false,
 94:         devMessage: 'Error getting Twitter analytics',
 95:         userMessage: 'Something went wrong when getting Twitter analytics',
 96:       })
 97: 
 98:       twitter.value = data
 99:     } catch (error) {
100:       errors.client({
101:         error,
102:         devOnly: false,
103:         devMessage: 'Error getting Twitter analytics',
104:         userMessage: 'Something went wrong when getting Twitter analytics',
105:       })
106:     }
107:   }
108: 
109:   return {
110:     youtube,
111:     getYoutubeAnalytics,
112:     //
113:     instagram,
114:     getInstagramAnalytics,
115:     //
116:     linkedin,
117:     getLinkedInAnalytics,
118:     //
119:     twitter,
120:     getTwitterAnalytics,
121:   }
122: })
123: 
124: if (import.meta.hot) {
125:   import.meta.hot.accept(acceptHMRUpdate(useSocialStore, import.meta.hot))
126: }
```

## File: layers/base/composables/useMediaQuery.ts
```typescript
 1: // composables/useMediaQuery.ts
 2: export const useMediaQuery = (query: string) => {
 3:   const matches = ref(false)
 4: 
 5:   if (import.meta.client) {
 6:     const mediaQuery = window.matchMedia(query)
 7:     matches.value = mediaQuery.matches
 8: 
 9:     const handler = (event: MediaQueryListEvent) => {
10:       matches.value = event.matches
11:     }
12: 
13:     // Watch for changes
14:     mediaQuery.addEventListener('change', handler)
15: 
16:     // Cleanup
17:     onUnmounted(() => {
18:       mediaQuery.removeEventListener('change', handler)
19:     })
20:   }
21: 
22:   return matches
23: }
```

## File: layers/base/composables/useNavigation.ts
```typescript
 1: // composables/useNavigation.ts
 2: export const useNavigation = () => {
 3:   const isSidebarOpen = useState('nav-sidebar-open', () => true)
 4:   const isMobileSidebarOpen = useState('nav-mobile-sidebar-open', () => false)
 5: 
 6:   // Create our own media query composable
 7:   const isMobile = useMediaQuery('(max-width: 768px)')
 8: 
 9:   // Close mobile nav on route changes
10:   const route = useRoute()
11:   
12:   watch(
13:     () => route.path,
14:     () => {
15:       isMobileSidebarOpen.value = false
16:     },
17:   )
18: 
19:   return {
20:     isSidebarOpen,
21:     isMobileSidebarOpen,
22:     isMobile,
23:   }
24: }
```

## File: layers/base/composables/utils.ts
```typescript
 1: import { wasRowDataUpdated } from './utils/hasValueChanged'
 2: import * as time from './utils/time'
 3: import * as strings from './utils/strings'
 4: import * as objects from './utils/objects'
 5: import * as arrays from './utils/arrays'
 6: 
 7: export function useUtils() {
 8:   return {
 9:     wasRowDataUpdated,
10:     time: {
11:       format: time.toDateObject,
12:       lastSeen: time.lastSeen,
13:     },
14:     strings: {
15:       firstUpper: strings.upperCaseFirstLetter,
16:       slugify: strings.slugify,
17:     },
18:     arrays: {
19:       removeDuplicates: arrays.removeDuplicates,
20:       sortBy: arrays.sortBy,
21:     },
22:     objects: {
23:       pluck: objects.pluck,
24:     },
25:   }
26: }
```

## File: layers/base/plugins/error-handler.ts
```typescript
 1: import { useErrorHandler } from '@ib/logger'
 2: 
 3: export default defineNuxtPlugin((nuxtApp) => {
 4:   const { handleError } = useErrorHandler()
 5: 
 6:   // Set up global error handlers
 7:   if (import.meta.client) {
 8:     window.addEventListener('error', (event) => {
 9:       handleError(event.error, 'Uncaught Exception')
10:     })
11: 
12:     window.addEventListener('unhandledrejection', (event) => {
13:       handleError(event.reason, 'Unhandled Promise Rejection')
14:     })
15:   }
16: })
```

## File: layers/base/plugins/posthog.client.ts
```typescript
 1: import posthog from 'posthog-js'
 2: 
 3: export default defineNuxtPlugin((nuxtApp) => {
 4:   const env = nuxtApp.$config.public
 5:   const env2 = useRuntimeConfig().public
 6: 
 7:   console.log('ENV Key:', env, env2)
 8:   console.log('NODE_ENV:', import.meta.env.NODE_ENV)
 9: 
10:   const posthogKey = env.posthogKey || env2.posthogKey
11:   const posthogUrl = env.posthogUrl || env2.posthogUrl
12: 
13:   // Initialize PostHog
14:   posthog.init(posthogKey, {
15:     api_host: posthogUrl,
16:     autocapture: false, // Disable autocapture as we'll handle events manually
17:     capture_pageview: false, // We'll capture pageviews manually for more control
18:     persistence: 'localStorage+cookie',
19:     // bootstrap: {
20:     //   distinctID: runtimeConfig.public.posthogDistinctId // Set this in your runtime config if you have a user ID
21:     // },
22:     loaded: (posthog) => {
23:       // This function is called once PostHog is loaded
24:       if (import.meta.env.NODE_ENV === 'development') {
25:         // Log to console in development mode
26:         posthog.debug()
27:       }
28:     },
29:   })
30: 
31:   // Capture page views
32:   nuxtApp.hook('page:finish', () => {
33:     posthog.capture('$pageview')
34:   })
35: 
36:   // Expose PostHog instance and utility functions
37:   return {
38:     provide: {
39:       posthog: {
40:         // Expose the raw PostHog instance
41:         raw: posthog,
42: 
43:         // Utility function to capture events
44:         capture: (eventName: string, properties?: Record<string, any>) => {
45:           posthog.capture(eventName, properties)
46:         },
47: 
48:         // Utility function for A/B testing
49:         getFeatureFlag: (flagName: string, defaultValue?: any) => {
50:           return posthog.getFeatureFlag(flagName, defaultValue)
51:         },
52: 
53:         // Utility function to identify users
54:         identify: (distinctId: string, properties?: Record<string, any>) => {
55:           posthog.identify(distinctId, properties)
56:         },
57: 
58:         // Utility function to reset user identity
59:         reset: () => {
60:           posthog.reset()
61:         },
62: 
63:         // Utility function to opt in/out of tracking
64:         optIn: () => {
65:           posthog.opt_in_capturing()
66:         },
67:         optOut: () => {
68:           posthog.opt_out_capturing()
69:         },
70: 
71:         // Utility function for registering super properties
72:         register: (properties: Record<string, any>) => {
73:           posthog.register(properties)
74:         },
75: 
76:         // Utility function for registering one-time super properties
77:         registerOnce: (properties: Record<string, any>) => {
78:           posthog.register_once(properties)
79:         },
80:       },
81:     },
82:   }
83: })
```

## File: layers/base/plugins/sentry.client.ts
```typescript
 1: import * as Sentry from '@sentry/vue'
 2: import { defineNuxtPlugin } from '#app'
 3: 
 4: export default defineNuxtPlugin((nuxtApp) => {
 5:   const app = nuxtApp.vueApp
 6:   const router = useRouter()
 7: 
 8:   Sentry.init({
 9:     app,
10:     dsn: 'https://eec364410b024a5a837f60e00d367513@o1175094.ingest.sentry.io/4504389151621120',
11:     integrations: [Sentry.browserTracingIntegration({ router }), Sentry.replayIntegration()],
12:     tracesSampleRate: process.env.NODE_ENV === 'production' ? 0.2 : 1.0,
13:     tracePropagationTargets: ['localhost', /^https:\/\/yourserver\.io\/api/],
14:     replaysSessionSampleRate: 0.1,
15:     replaysOnErrorSampleRate: 1.0,
16:     attachProps: true,
17:     trackComponents: true,
18:   })
19: 
20:   // Sentry.setUser(useSupabaseUser())
21:   Sentry.setTag('environment', process.env.NODE_ENV)
22: })
```

## File: layers/base/types/content.ts
```typescript
 1: import { z } from 'zod'
 2: 
 3: export const titleSchema = z.object({
 4:   centered: z.boolean().optional(),
 5:   label: z.string().optional(),
 6:   main: z.string(),
 7:   subtitle: z.string().optional(),
 8: })
 9: 
10: export const faqSchema = z.object({
11:   label: z.string(),
12:   description: z.string(),
13: })
14: 
15: export const imageSchema = z.object({
16:   src: z.string(),
17:   alt: z.string(),
18:   width: z.number().optional(),
19:   height: z.number().optional(),
20: })
21: 
22: export type ImageType = z.infer<typeof imageSchema>
23: export type TitleType = z.infer<typeof titleSchema>
24: export type FaqType = z.infer<typeof faqSchema>
```

## File: layers/base/types/database.ts
```typescript
 1: import type { Tables } from '../../../supabase/schema.gen'
 2: 
 3: export type RowUser = Tables<'user_profiles'>
 4: export type RowUserFollowers = Tables<'user_followers'>
 5: export type RowRole = Tables<'roles'>
 6: export type RowRegisterInterest = Tables<'register_interest'>
 7: 
 8: export type RowCategory = Tables<'categories'>
 9: export type RowTag = Tables<'tags'>
10: 
11: export type RowNews = Tables<'news'>
12: export type RowNewsTag = Tables<'news_tags'>
13: 
14: export type RowEmbedding = Tables<'embeddings'>
15: 
16: export type RowPaper = Tables<'papers'>
17: 
18: type ArrayToUnion<A> = A extends readonly (infer T)[] ? T : never
19: 
20: const userCardKeys = [
21:   'id',
22:   'given_name',
23:   'surname',
24:   'username',
25:   'avatar',
26:   'followed_count',
27:   'followers_count',
28:   'plan',
29: ] as const
30: 
31: export type UserCard = Pick<RowUser, ArrayToUnion<typeof userCardKeys>>
```

## File: layers/base/types/index.ts
```typescript
1: export * from './users'
2: export * from './other-type-file'
```

## File: layers/base/types/users.ts
```typescript
 1: // don't forget to add to this file if you make any changes in the database
 2: import * as z from 'zod'
 3: 
 4: export const LocationSchema = z.object({
 5:   id: z.number(),
 6:   created_at: z.string().optional(),
 7:   city: z.string(),
 8:   country: z.string(),
 9:   state: z.string(),
10:   address: z.string().nullable(),
11:   latitude: z.number().optional().nullable(),
12:   longitude: z.number().optional().nullable(),
13: })
14: 
15: export const UserRoleSchema = z.object({
16:   id: z.number(),
17:   name: z.string().nullable(),
18:   body: z.string().nullable().optional(),
19:   created_at: z.string().optional(),
20:   icon: z.string(),
21: })
22: 
23: export const IdName = z.object({
24:   id: z.number(),
25:   name: z.string(),
26: })
27: 
28: export const UserSkillSchema = z.object({
29:   id: z.number(),
30:   title: z.string().nullable(),
31:   body: z.string().nullable().optional(),
32:   total_endorsements: z.number(),
33:   admin_rating: z.number().nullable(),
34:   avg_rating: z.number().nullable(),
35:   created_at: z.string().optional(),
36: })
37: 
38: export const UserSocialSchema = z.object({
39:   id: z.number(),
40:   url: z.string(),
41:   platform: z.string(),
42:   username: z.string(),
43: })
44: 
45: export const UserBasicSchema = z.object({
46:   id: z.string(),
47:   given_name: z.string(),
48:   surname: z.string().nullable(),
49:   username: z.string().nullable(),
50:   avatar: z.string().nullable(),
51:   introduction: z.string().nullable(),
52:   followers_count: z.number().nullable(),
53:   followed_count: z.number().nullable(),
54:   is_following: z.boolean().nullable(),
55:   role: z.number(),
56: })
57: 
58: export const UserFullSchema = UserBasicSchema.extend({
59:   email: z.string(),
60:   dob: z.string().nullable(),
61:   gender_id: z.number().nullable(),
62:   created_at: z.string(),
63:   updated_at: z.string().nullable(),
64:   quote: z.string().nullable(),
65: })
66: 
67: export const UserRowSchema = z.object({
68:   given_name: z.string(),
69:   email: z.string(),
70:   surname: z.string().nullable(),
71:   username: z.string().nullable(),
72:   avatar: z.string().nullable(),
73:   introduction: z.string().nullable(),
74:   plan: z.string().nullish(),
75:   dob: z.string().nullable(),
76:   quote: z.string().nullable(),
77:   gender_id: z.number().nullable(),
78: })
79: 
80: export const UserRolesSchema = z.array(UserRoleSchema)
81: 
82: export type UserType = z.infer<typeof UserBasicSchema>
83: export type UserFullType = z.infer<typeof UserFullSchema>
84: export type UserRoleType = z.infer<typeof UserRoleSchema>
85: export type UserRowType = z.infer<typeof UserRowSchema>
86: export type UserSocialType = z.infer<typeof UserSocialSchema>
```

## File: layers/base/nuxt.config.ts
```typescript
 1: import { defineNuxtConfig } from 'nuxt/config'
 2: 
 3: export default defineNuxtConfig({
 4:   workspaceDir: '../../',
 5:   srcDir: '.',
 6: 
 7:   icon: {
 8:     serverBundle: {
 9:       collections: ['material-symbols', 'mdi'],
10:     },
11:   },
12: 
13:   eslint: {
14:     checker: true,
15:   },
16: 
17:   image: {
18:     providers: {
19:       supabase: {
20:         provider: '../../layers/base/supabase-provider.ts',
21:         options: {
22:           baseURL: process.env.NUXT_PUBLIC_SUPABASE_URL,
23:         },
24:       },
25:     },
26:     presets: {
27:       original: {
28:         modifiers: {
29:           width: 1920,
30:           height: 1080,
31:         },
32:       },
33:       mobile: {
34:         modifiers: {
35:           width: 768,
36:           height: 1024,
37:         },
38:       },
39:       thumbnail: {
40:         modifiers: {
41:           width: 300,
42:           height: 200,
43:         },
44:       },
45:     },
46:   },
47: 
48:   components: [
49:     {
50:       path: './components',
51:       pathPrefix: false,
52:       prefix: 'IB',
53:       global: true,
54:     },
55:   ],
56: })
```

## File: layers/base/supabase-provider.ts
```typescript
 1: export function getImage(
 2:   src,
 3:   {
 4:     modifiers = { width: null, height: null, format: null },
 5:     baseURL = process.env.NUXT_PUBLIC_SUPABASE_URL,
 6:   } = {},
 7: ) {
 8:   const { width, height, format } = modifiers
 9:   const [_, bucket, sizeName, imageFileName] = src.split('/')
10: 
11:   // Determine target size
12:   let targetSizeName = sizeName
13:   if (width && height) {
14:     if (width <= 300 && height <= 200) {
15:       targetSizeName = 'thumbnail'
16:     } else if (width <= 768 && height <= 1024) {
17:       targetSizeName = 'mobile'
18:     } else {
19:       targetSizeName = 'original'
20:     }
21:   }
22: 
23:   const imageNameWithoutExt = imageFileName.split('.')[0]
24:   const imageFormat = format || imageFileName.split('.')[1] || 'jpg'
25: 
26:   return {
27:     url: `${baseURL}/storage/v1/object/public/${bucket}/${targetSizeName}/${imageNameWithoutExt}.${imageFormat}`,
28:   }
29: }
```

## File: layers/crud/.playground/app.config.ts
```typescript
1: export default defineAppConfig({
2:   myLayer: {
3:     name: 'My amazing Nuxt layer (overwritten)'
4:   }
5: })
```

## File: layers/crud/.playground/nuxt.config.ts
```typescript
1: export default defineNuxtConfig({
2:   extends: ['..'],
3:   modules: ['@nuxt/eslint']
4: })
```

## File: layers/crud/components/Feedback.vue
```vue
  1: <script setup lang="ts">
  2: import { z } from 'zod'
  3: 
  4: const feedbackStore = useFeedbackStore()
  5: 
  6: defineProps({
  7:   cta: {
  8:     type: String,
  9:     required: true,
 10:     default: 'How could we improve?',
 11:   },
 12: })
 13: 
 14: interface FeedbackType {
 15:   name: string
 16:   value: string
 17: }
 18: 
 19: const feedbackTypes = [
 20:   { name: 'Bug Report', value: 'bug_report' },
 21:   { name: 'Feature Request', value: 'feature_request' },
 22:   { name: 'User Interface Issue', value: 'user_interface_issue' },
 23:   { name: 'Performance Issue', value: 'performance_issue' },
 24:   { name: 'Documentation', value: 'documentation' },
 25: ]
 26: 
 27: const route = useRoute()
 28: const { userId } = useCurrentUser()
 29: 
 30: const initialFeedback = () => ({
 31:   user_id: userId,
 32:   page_identifier: route.fullPath,
 33:   feedback_type: null,
 34:   message: '',
 35:   device_info: '',
 36:   content_status: 'new',
 37: })
 38: 
 39: const feedback = ref(initialFeedback())
 40: 
 41: const messagePlaceholder = computed(() => {
 42:   if (!feedback.value.feedback_type) {
 43:     return 'Please select a feedback type first'
 44:   }
 45: 
 46:   const type = feedback.value.feedback_type
 47:   if (!type) return ''
 48: 
 49:   switch (type.value) {
 50:     case 'bug_report':
 51:       return 'Describe the bug in detail...'
 52:     case 'feature_request':
 53:       return 'Describe the feature you would like to see...'
 54:     case 'user_interface_issue':
 55:       return 'What UI issue did you encounter?'
 56:     case 'performance_issue':
 57:       return 'Describe the performance issue...'
 58:     case 'documentation':
 59:       return 'What documentation issue did you find?'
 60:     default:
 61:       return 'Enter your message'
 62:   }
 63: })
 64: 
 65: const isMessageDisabled = computed(() => !feedback.value.feedback_type)
 66: 
 67: const messageLength = z.string().min(10)
 68: 
 69: const isMessageInvalid = computed(() => !messageLength.safeParse(feedback.value.message).success)
 70: 
 71: const resetFeedback = () => {
 72:   feedback.value = initialFeedback()
 73: }
 74: 
 75: const submitFeedback = async () => {
 76:   await feedbackStore.submitFeedback(feedback.value)
 77:   resetFeedback()
 78: }
 79: </script>
 80: 
 81: <template>
 82:   <div class="w-52">
 83:     <h2 class="text-lg mb-4 text-left font-bold">
 84:       {{ cta }}
 85:     </h2>
 86:     <form
 87:       class="w-52 space-y-4"
 88:       @submit.prevent="submitFeedback"
 89:     >
 90:       <PrimeSelect
 91:         v-model="feedback.feedback_type"
 92:         :pt="{ root: 'flex text-left pl-1' }"
 93:         :pt-options="{ mergeProps: true, mergeSections: true }"
 94:         :options="feedbackTypes"
 95:         option-label="name"
 96:         placeholder="Feedback Type"
 97:       />
 98:       <PrimeTextarea
 99:         v-show="feedback.feedback_type"
100:         v-model="feedback.message"
101:         class="w-full"
102:         :rows="5"
103:         :placeholder="messagePlaceholder"
104:         :disabled="isMessageDisabled"
105:         :invalid="isMessageInvalid"
106:       />
107:       <div>
108:         <PrimeButton
109:           v-show="feedback.feedback_type"
110:           class="flex w-full justify-between"
111:           :disabled="isMessageInvalid"
112:           :outlined="isMessageInvalid"
113:           @click="submitFeedback"
114:         >
115:           Submit Feedback
116:           <Icon name="mdi:send" />
117:         </PrimeButton>
118:       </div>
119:     </form>
120:   </div>
121: </template>
122: 
123: <style scoped></style>
```

## File: layers/crud/components/Upload.vue
```vue
 1: <script setup lang="ts">
 2: // const toast = useNotification()
 3: 
 4: const props = defineProps({
 5:   name: {
 6:     type: String,
 7:     required: true,
 8:   },
 9:   url: {
10:     type: String,
11:     required: true,
12:   },
13:   multiple: {
14:     type: Boolean,
15:     default: false,
16:   },
17:   accept: {
18:     type: String,
19:     default: '',
20:   },
21:   maxFileSize: {
22:     type: Number,
23:     default: 1000000,
24:   },
25: })
26: 
27: const onAdvancedUpload = () => {
28:   toast.success({ summary: 'File Uploaded', message: `${props.name} files uploaded` })
29: }
30: </script>
31: 
32: <template>
33:   <PrimeCard>
34:     <template #content>
35:       <PrimeFileUpload
36:         :name="name"
37:         :multiple="multiple"
38:         :accept="accept"
39:         :url="url"
40:         :max-file-size="maxFileSize"
41:         @upload="onAdvancedUpload()"
42:       >
43:         <template #empty>
44:           <p>Drag and drop files to here to upload.</p>
45:         </template>
46:       </PrimeFileUpload>
47:     </template>
48:   </PrimeCard>
49: </template>
```

## File: layers/crud/composables/audit.ts
```typescript
  1: export enum AuditLogLevel {
  2:   INFO = 'INFO',
  3:   WARNING = 'WARNING',
  4:   ERROR = 'ERROR',
  5:   CRITICAL = 'CRITICAL',
  6: }
  7: 
  8: export interface AuditLogEntry {
  9:   userId: string
 10:   action: string
 11:   details: any
 12:   level: AuditLogLevel
 13:   timestamp: string
 14:   ipAddress?: string
 15:   userAgent?: string
 16:   resourceId?: string
 17:   resourceType?: string
 18: }
 19: 
 20: interface AuditLogOptions {
 21:   level?: AuditLogLevel
 22:   resourceId?: string
 23:   resourceType?: string
 24:   skipDB?: boolean
 25: }
 26: 
 27: export function useAuditLog() {
 28:   const supabase = useSupabaseClient()
 29:   const user = useSupabaseUser()
 30:   const config = useRuntimeConfig()
 31: 
 32:   const logEvent = async (action: string, details: any, options: AuditLogOptions = {}) => {
 33:     const userId = user.value?.id || 'anonymous'
 34:     const timestamp = new Date().toISOString()
 35:     const level = options.level || AuditLogLevel.INFO
 36: 
 37:     const logEntry: AuditLogEntry = {
 38:       userId,
 39:       action,
 40:       details,
 41:       level,
 42:       timestamp,
 43:       ipAddress: useRequestHeaders(['x-forwarded-for'])['x-forwarded-for'] || '',
 44:       userAgent: useRequestHeaders(['user-agent'])['user-agent'] || '',
 45:       resourceId: options.resourceId,
 46:       resourceType: options.resourceType,
 47:     }
 48: 
 49:     // Remove any sensitive information from the log entry
 50:     sanitizeLogEntry(logEntry)
 51: 
 52:     // Log to console in development
 53:     if (import.meta.dev) {
 54:       console.log('Audit Log:', logEntry)
 55:     }
 56: 
 57:     if (!options.skipDB) {
 58:       try {
 59:         const { error } = await supabase.from('audit_logs').insert(logEntry)
 60: 
 61:         if (error) {
 62:           console.error('Error logging audit event to database:', error)
 63:         }
 64:       } catch (error) {
 65:         console.error('Error logging audit event to database:', error)
 66:       }
 67:     }
 68: 
 69:     // If configured, send logs to an external service
 70:     if (config.public.EXTERNAL_LOGGING_SERVICE) {
 71:       try {
 72:         await $fetch(config.public.EXTERNAL_LOGGING_SERVICE, {
 73:           method: 'POST',
 74:           body: JSON.stringify(logEntry),
 75:         })
 76:       } catch (error) {
 77:         console.error('Error sending log to external service:', error)
 78:       }
 79:     }
 80:   }
 81: 
 82:   const sanitizeLogEntry = (logEntry: AuditLogEntry) => {
 83:     // Remove sensitive information like passwords, tokens, etc.
 84:     if (logEntry.details && typeof logEntry.details === 'object') {
 85:       const sensitiveFields = ['password', 'token', 'secret', 'credit_card']
 86:       for (const field of sensitiveFields) {
 87:         if (field in logEntry.details) {
 88:           logEntry.details[field] = '[REDACTED]'
 89:         }
 90:       }
 91:     }
 92:   }
 93: 
 94:   const getAuditLogs = async (
 95:     filters: Partial<AuditLogEntry>,
 96:     pagination: { page: number, pageSize: number },
 97:   ) => {
 98:     let query = supabase.from('audit_logs').select('*')
 99: 
100:     // Apply filters
101:     Object.entries(filters).forEach(([key, value]) => {
102:       if (value !== undefined) {
103:         query = query.eq(key, value)
104:       }
105:     })
106: 
107:     // Apply pagination
108:     const { data, error, count } = await query
109:       .range(pagination.page * pagination.pageSize, (pagination.page + 1) * pagination.pageSize - 1)
110:       .order('timestamp', { ascending: false })
111: 
112:     if (error) {
113:       console.error('Error fetching audit logs:', error)
114:       throw error
115:     }
116: 
117:     return { logs: data, totalCount: count }
118:   }
119: 
120:   return {
121:     logEvent,
122:     getAuditLogs,
123:     AuditLogLevel,
124:   }
125: }
```

## File: layers/crud/composables/delete.ts
```typescript
 1: import { useErrorHandler, AppError, ErrorSeverity, ErrorType, useLogger } from '@ib/logger'
 2: import { useRateLimit } from './rate-limit'
 3: import { useHttpHandler } from './http-handler'
 4: import { getOrCreateStore } from './main.store'
 5: 
 6: export function useDeleteData<T extends { id: string | number }>(
 7:   tableName: string,
 8:   options: {
 9:     validateDelete?: (id: string | number) => boolean | Promise<boolean>
10:     refreshRelated?: () => Promise<void>
11:     rateLimitMs?: number
12:     auditLog?: (action: string, details: any) => Promise<void>
13:   } = {},
14: ) {
15:   const { remove } = useHttpHandler()
16:   const { handleError } = useErrorHandler()
17:   const logger = useLogger('useDeleteData')
18:   const store = getOrCreateStore<T>(tableName)()
19:   const { checkRateLimit } = useRateLimit()
20:   const isDeleting: Ref<boolean> = ref(false)
21:   let lastDeleteTime = 0
22: 
23:   const deleteData = async (id: string | number | (string | number)[]) => {
24:     isDeleting.value = true
25:     const startTime = Date.now()
26: 
27:     const deleteSingle = async (itemId: string | number): Promise<void> => {
28:       try {
29:         // Rate limiting
30:         if (options.rateLimitMs) {
31:           await checkRateLimit('useDeleteData', { limitMs: options.rateLimitMs })
32:         }
33: 
34:         // Validation
35:         if (options.validateDelete && !(await options.validateDelete(itemId))) {
36:           throw new AppError({
37:             type: ErrorType.VALIDATION_ERROR,
38:             message: 'Delete validation failed',
39:             severity: ErrorSeverity.MEDIUM,
40:             context: 'Data Validation',
41:           })
42:         }
43: 
44:         // Optimistic delete
45:         store.removeItem(itemId)
46: 
47:         // Perform the delete
48:         await remove(tableName, itemId)
49: 
50:         // Refresh related data if needed
51:         if (options.refreshRelated) {
52:           await options.refreshRelated()
53:         }
54: 
55:         // Audit logging
56:         if (options.auditLog) {
57:           await options.auditLog('DELETE', { tableName, id: itemId })
58:         }
59: 
60:         lastDeleteTime = Date.now()
61:       } catch (error: any) {
62:         // Revert optimistic delete
63:         const oldItem = store.getItemById(itemId)
64:         if (oldItem) {
65:           store.addItems([oldItem])
66:         }
67:         throw error
68:       }
69:     }
70: 
71:     try {
72:       if (Array.isArray(id)) {
73:         await Promise.all(id.map(deleteSingle))
74:       } else {
75:         await deleteSingle(id)
76:       }
77:     } catch (error: any) {
78:       handleError(error, 'Error deleting data')
79:       throw error
80:     } finally {
81:       isDeleting.value = false
82:     }
83:   }
84: 
85:   return {
86:     deleteData,
87:     isDeleting,
88:   }
89: }
```

## File: layers/crud/composables/fetch.ts
```typescript
  1: import { useLogger } from '@ib/logger'
  2: import type { FilterBy, DBTable } from '../server/utils/base.interface'
  3: import type { DomainKey } from './pagination.store'
  4: import { useCookie, useRequestHeaders } from '#imports'
  5: import type { FetchResult } from '#app'
  6: 
  7: export interface FetchInput {
  8:   domainKey: DomainKey
  9:   endpoint: string
 10:   pagination?: {
 11:     page: number
 12:     limit: number
 13:   }
 14:   criteria: {
 15:     dto: string
 16:     filterBy?: FilterBy<DBTable>
 17:   }
 18: }
 19: 
 20: function getDataStructure(obj: any): any {
 21:   if (Array.isArray(obj)) {
 22:     return obj.length > 0 ? [getDataStructure(obj[0])] : []
 23:   } else if (typeof obj === 'object' && obj !== null) {
 24:     const structure: Record<string, any> = {}
 25:     for (const key in obj) {
 26:       structure[key] = getDataStructure(obj[key])
 27:     }
 28:     return structure
 29:   } else {
 30:     return typeof obj
 31:   }
 32: }
 33: 
 34: export function useBaseFetch() {
 35:   const errors = useBaseError()
 36:   const paginationStore = usePaginationStore()
 37:   const loading = useLoadingStore()
 38:   const logger = useLogger('useBaseFetch')
 39:   const apiDataStore = useApiDataStore()
 40: 
 41:   const fetch = $fetch.create({
 42:     retryStatusCodes: [408, 409, 425, 500, 502, 503, 504],
 43:     headers: {
 44:       'X-USER-ID': useCookie('userId').value ?? 'no-user-id',
 45:       'cookie': useRequestHeaders(['cookie']).cookie ?? '',
 46:     },
 47:     onResponseError({ error, response, request, options }) {
 48:       console.error('onResponseError', response, response._data, error)
 49:     },
 50:     async onResponse({ request, response, options }) {
 51:       const url = request.toString()
 52:       const structure = getDataStructure(response._data)
 53:       console.log('Captured data structure for:', url, structure)
 54:       apiDataStore.setData(url, structure)
 55:     },
 56:   })
 57: 
 58:   async function fetchPaginatedData(params: FetchInput) {
 59:     const { domainKey, endpoint, criteria } = params
 60: 
 61:     if (loading.isLoading(domainKey)) {
 62:       return null
 63:     }
 64: 
 65:     if (paginationStore.isDataFinished(domainKey)) {
 66:       return null
 67:     }
 68: 
 69:     if (!paginationStore.getPagination(domainKey)) {
 70:       return null
 71:     }
 72: 
 73:     loading.setLoading(domainKey, true)
 74: 
 75:     try {
 76:       logger.info('fetchPaginatedData for', domainKey, endpoint, criteria)
 77:       const response = await fetch(endpoint, {
 78:         method: 'POST',
 79:         params: {
 80:           ...criteria,
 81:           pagination: paginationStore.getPaginationRange(domainKey),
 82:         },
 83:       })
 84: 
 85:       console.log('fetchPaginatedData RESPONSE', response)
 86: 
 87:       const data = errors.server({
 88:         response,
 89:         devOnly: false,
 90:         userMessage: `Sorry there was an error getting ${domainKey} from ${endpoint}`,
 91:         devMessage: `fetchPaginatedData errored selecting paginated ${domainKey} data from ${endpoint}`,
 92:       })
 93: 
 94:       if (!data || !data.length || data.length < paginationStore.getPagination(domainKey)!.limit) {
 95:         paginationStore.setDataFinished(domainKey)
 96:       }
 97: 
 98:       await loading.setLoadingInterval(domainKey, false, 1500)
 99:       paginationStore.incrementPagination(domainKey)
100: 
101:       return data
102:     } catch (error) {
103:       errors.client({
104:         error,
105:         devOnly: false,
106:         userMessage: `Sorry there was an error getting ${domainKey} from ${endpoint}`,
107:         devMessage: `fetchPaginatedData error for ${domainKey}`,
108:       })
109:     }
110:   }
111: 
112:   return {
113:     fetchPaginatedData,
114:     fetch,
115:   }
116: }
```

## File: layers/crud/composables/http-handler.ts
```typescript
  1: import type { PostgrestResponse, PostgrestError } from '@supabase/supabase-js'
  2: import {
  3:   useErrorHandler,
  4:   ErrorType,
  5:   useLogger,
  6:   ErrorSeverity,
  7:   AppError,
  8:   mapErrorSeverity,
  9:   mapErrorType,
 10:   retryableStatusCodes,
 11: } from '@ib/logger'
 12: import { getOrCreateStore } from './main.store'
 13: import { usePaginationStore, type PaginationType } from './pagination.store'
 14: 
 15: type FilterOperator =
 16:   | 'eq'
 17:   | 'neq'
 18:   | 'gt'
 19:   | 'gte'
 20:   | 'lt'
 21:   | 'lte'
 22:   | 'like'
 23:   | 'ilike'
 24:   | 'is'
 25:   | 'in'
 26:   | 'contains'
 27:   | 'containedBy'
 28:   | 'overlaps'
 29:   | 'textSearch'
 30:   | 'match'
 31:   | 'not'
 32:   | 'or'
 33:   | 'and'
 34:   | 'rangeGt'
 35:   | 'rangeGte'
 36:   | 'rangeLt'
 37:   | 'rangeLte'
 38:   | 'rangeAdjacent'
 39: 
 40: type FilterOptionValue = string | number | boolean | null | any[] | Record<string, unknown>
 41: 
 42: type FilterOption = {
 43:   [K in FilterOperator]?: K extends 'not'
 44:     ? FilterOption
 45:     : K extends 'or' | 'and'
 46:       ? string
 47:       : FilterOptionValue
 48: }
 49: 
 50: type Filters = Record<string, FilterOption>
 51: 
 52: interface SelectOptions<T> {
 53:   columns?: keyof T | Array<keyof T> | string
 54:   filters?: Filters
 55:   range?: { from: number; to: number }
 56:   order?: { column: keyof T; ascending: boolean }
 57: }
 58: 
 59: function applyFilter(query: any, column: string, filter: FilterOption): any {
 60:   const [operator, value] = Object.entries(filter)[0]
 61:   switch (operator) {
 62:     case 'eq':
 63:       return query.eq(column, value)
 64:     case 'neq':
 65:       return query.neq(column, value)
 66:     case 'gt':
 67:       return query.gt(column, value)
 68:     case 'gte':
 69:       return query.gte(column, value)
 70:     case 'lt':
 71:       return query.lt(column, value)
 72:     case 'lte':
 73:       return query.lte(column, value)
 74:     case 'like':
 75:       return query.like(column, value)
 76:     case 'ilike':
 77:       return query.ilike(column, value)
 78:     case 'is':
 79:       return query.is(column, value)
 80:     case 'in':
 81:       return query.in(column, value as any[])
 82:     case 'contains':
 83:       return query.contains(column, value)
 84:     case 'containedBy':
 85:       return query.containedBy(column, value)
 86:     case 'rangeGt':
 87:       return query.rangeGt(column, value)
 88:     case 'rangeGte':
 89:       return query.rangeGte(column, value)
 90:     case 'rangeLt':
 91:       return query.rangeLt(column, value)
 92:     case 'rangeLte':
 93:       return query.rangeLte(column, value)
 94:     case 'rangeAdjacent':
 95:       return query.rangeAdjacent(column, value)
 96:     case 'overlaps':
 97:       return query.overlaps(column, value)
 98:     case 'textSearch':
 99:       return query.textSearch(column, value as string, { config: 'english' })
100:     case 'match':
101:       return query.match(column, value as Record<string, unknown>)
102:     case 'not':
103:       return applyFilter(query.not(), column, value as FilterOption)
104:     case 'or':
105:       return query.or(value as string)
106:     case 'and':
107:       return query.and(value as string)
108:     default:
109:       console.warn(`Unsupported filter operator: ${operator}`)
110:       return query
111:   }
112: }
113: 
114: export function useHttpHandler() {
115:   const supabase = useSupabaseClient()
116:   const { handleError } = useErrorHandler()
117:   const logger = useLogger('HttpHandler')
118: 
119:   async function handleDatabaseOperation<T>(
120:     operation: () => Promise<PostgrestResponse<T>>,
121:     context: string,
122:     maxRetries: number = 3,
123:   ): Promise<T> {
124:     let retries = 0
125:     while (retries < maxRetries) {
126:       try {
127:         const response = await operation()
128:         // logger.debug(`${context} response:`, response)
129: 
130:         if (response.error) {
131:           throw response.error
132:         }
133:         return response.data as T
134:       } catch (error: unknown) {
135:         retries++
136:         logger.warn(`${context} failed. Attempt ${retries} of ${maxRetries}`)
137: 
138:         const pgError = error as PostgrestError
139:         const errorType = mapErrorType(pgError)
140:         const errorSeverity = mapErrorSeverity(pgError)
141: 
142:         if (
143:           retries >= maxRetries ||
144:           !Object.keys(retryableStatusCodes).includes(pgError.code?.toString() || '')
145:         ) {
146:           const appError = new AppError({
147:             type: errorType,
148:             message:
149:               pgError.message ||
150:               retryableStatusCodes[pgError.code as keyof typeof retryableStatusCodes] ||
151:               'Database operation failed',
152:             severity: errorSeverity,
153:             code: pgError.code,
154:             context: context,
155:             pgError: pgError.details || pgError.hint || pgError.message,
156:             operation: context,
157:           })
158:           throw handleError(appError)
159:         }
160: 
161:         // Exponential backoff with jitter
162:         const backoffTime = Math.min(1000 * 2 ** retries + Math.random() * 1000, 10000)
163:         await new Promise((resolve) => setTimeout(resolve, backoffTime))
164:       }
165:     }
166:     throw new Error('Max retries reached')
167:   }
168: 
169:   async function insert<T>(
170:     tableName: string,
171:     data: T,
172:     options: { columns?: string } = {},
173:   ): Promise<T> {
174:     return handleDatabaseOperation(
175:       async () =>
176:         await supabase
177:           .from(tableName)
178:           .insert(data)
179:           .select(options.columns || '*'),
180:       `Insert into ${tableName}`,
181:     )
182:   }
183: 
184:   async function update<T>(
185:     tableName: string,
186:     id: string | number,
187:     data: Partial<T>,
188:     options: { columns?: string } = {},
189:   ): Promise<T> {
190:     return handleDatabaseOperation(
191:       async () =>
192:         await supabase
193:           .from(tableName)
194:           .update(data)
195:           .eq('id', id)
196:           .select(options.columns || '*'),
197:       `Update ${tableName}`,
198:     )
199:   }
200: 
201:   async function remove(tableName: string, id: string | number): Promise<void> {
202:     await handleDatabaseOperation(
203:       async () => await supabase.from(tableName).delete().eq('id', id),
204:       `Delete from ${tableName}`,
205:     )
206:   }
207: 
208:   async function select<T>(tableName: string, options: SelectOptions<T> = {}): Promise<T[]> {
209:     let query = supabase.from(tableName).select(options.columns || '*')
210: 
211:     if (options.filters) {
212:       Object.entries(options.filters).forEach(([column, filterOption]) => {
213:         query = applyFilter(query, column, filterOption)
214:       })
215:     }
216: 
217:     if (options.range) {
218:       query = query.range(options.range.from, options.range.to)
219:     }
220: 
221:     if (options.order) {
222:       query = query.order(options.order.column, { ascending: options.order.ascending })
223:     }
224: 
225:     return handleDatabaseOperation(() => query, `Select from ${tableName}`)
226:   }
227: 
228:   return {
229:     insert,
230:     update,
231:     remove,
232:     select,
233:   }
234: }
```

## File: layers/crud/composables/insert.ts
```typescript
  1: import { useErrorHandler, AppError, ErrorType, ErrorSeverity, useLogger } from '@ib/logger'
  2: import { useHttpHandler } from './http-handler'
  3: import { getOrCreateStore } from './main.store'
  4: import { useRateLimit } from './rate-limit'
  5: 
  6: type InsertError =
  7:   | 'VALIDATION_ERROR'
  8:   | 'NETWORK_ERROR'
  9:   | 'SERVER_ERROR'
 10:   | 'RATE_LIMIT_ERROR'
 11:   | 'DUPLICATE_ERROR'
 12: 
 13: export function useInsertData<T extends { id: string | number }>(
 14:   tableName: string,
 15:   options: {
 16:     columns?: string
 17:     validateData?: (data: T) => boolean | Promise<boolean>
 18:     maxRetries?: number
 19:     refreshRelated?: () => Promise<void>
 20:     transformData?: (data: T) => T
 21:     onError?: (error: InsertError, details: any) => void
 22:     rateLimitMs?: number
 23:     auditLog?: (action: string, details: any) => Promise<void>
 24:     generateClientId?: () => string | number
 25:   } = {},
 26: ) {
 27:   const supabase = useSupabaseClient()
 28:   const { insert } = useHttpHandler()
 29:   const { handleError } = useErrorHandler()
 30:   const log = useLogger('useInsertData')
 31:   const store = getOrCreateStore<T>(tableName)()
 32:   const { checkRateLimit } = useRateLimit()
 33:   const isInserting: Ref<boolean> = ref(false)
 34:   let lastInsertTime = 0
 35: 
 36:   const insertData = async (data: T | T[]) => {
 37:     isInserting.value = true
 38:     const startTime = Date.now()
 39: 
 40:     const insertSingle = async (item: T): Promise<T> => {
 41:       try {
 42:         // Rate limiting
 43:         if (options.rateLimitMs) {
 44:           await checkRateLimit('useInsertData', { limitMs: options.rateLimitMs })
 45:         }
 46: 
 47:         // Validation
 48:         if (options.validateData && !(await options.validateData(item))) {
 49:           throw new AppError({
 50:             type: ErrorType.VALIDATION_ERROR,
 51:             message: 'Data validation failed',
 52:             severity: ErrorSeverity.MEDIUM,
 53:             context: 'Data Validation',
 54:           })
 55:         }
 56: 
 57:         // Data transformation
 58:         const transformedData = options.transformData ? options.transformData(item) : item
 59: 
 60:         // Generate client-side ID if needed
 61:         if (options.generateClientId && !transformedData.id) {
 62:           transformedData.id = options.generateClientId()
 63:         }
 64: 
 65:         // Optimistic insert
 66:         store.addItems([transformedData])
 67: 
 68:         // Perform the insert
 69:         const result = await insert(tableName, transformedData, { columns: options.columns })
 70: 
 71:         // Update store with actual server data
 72:         store.updateItem(result)
 73: 
 74:         // Refresh related data if needed
 75:         if (options.refreshRelated) {
 76:           await options.refreshRelated()
 77:         }
 78: 
 79:         // Audit logging
 80:         if (options.auditLog) {
 81:           await options.auditLog('INSERT', { tableName, newData: result })
 82:         }
 83: 
 84:         lastInsertTime = Date.now()
 85:         return result
 86:       } catch (error: any) {
 87:         // Revert optimistic insert
 88:         store.removeItem(item.id)
 89:         throw error // error handler in the HTTP handler deals with this
 90:       }
 91:     }
 92: 
 93:     try {
 94:       if (Array.isArray(data)) {
 95:         const results = await Promise.all(data.map(insertSingle))
 96:         isInserting.value = false
 97:         return results
 98:       } else {
 99:         const result = await insertSingle(data)
100:         isInserting.value = false
101:         return result
102:       }
103:     } catch (error: any) {
104:       handleError(error, 'Error inserting data')
105:       throw error // Re-throw to allow caller to handle if needed
106:     } finally {
107:       isInserting.value = false
108:     }
109:   }
110: 
111:   return {
112:     insertData,
113:     isInserting,
114:   }
115: }
```

## File: layers/crud/composables/loading.store.ts
```typescript
 1: import type { DomainKey } from './pagination.store'
 2: 
 3: type Loaders = {
 4:   [K in DomainKey]?: boolean
 5: }
 6: 
 7: export const useLoadingStore = defineStore('storeLoading', () => {
 8:   const loaders = ref({} as Loaders)
 9: 
10:   function setLoading(key: DomainKey, isLoading: boolean) {
11:     loaders.value[key] = isLoading
12:   }
13: 
14:   async function setLoadingInterval(key: DomainKey, isLoading: boolean, time: number) {
15:     await new Promise<void>((resolve) => {
16:       setTimeout(() => {
17:         setLoading(key, isLoading)
18:         resolve()
19:       }, time)
20:     })
21:   }
22: 
23:   function isLoading(key: DomainKey) {
24:     return !!loaders.value[key]
25:   }
26: 
27:   return {
28:     setLoadingInterval,
29:     setLoading,
30:     isLoading,
31:   }
32: })
33: 
34: if (import.meta.hot) {
35:   import.meta.hot.accept(acceptHMRUpdate(useLoadingStore, import.meta.hot))
36: }
```

## File: layers/crud/composables/local-storage.ts
```typescript
 1: import { useLogger } from '@ib/logger'
 2: 
 3: const CACHE_DURATION = 24 * 60 * 60 * 1000 // 24 hours in milliseconds
 4: const CACHE_VERSION = '1.0' // Increment this when data structure changes
 5: 
 6: const LocalStorageEnum = {
 7:   CATEGORIES: 'astronera-categories',
 8:   TAGS: 'astronera-tags',
 9: } as const
10: 
11: type LocalStorageKey = (typeof LocalStorageEnum)[keyof typeof LocalStorageEnum]
12: 
13: interface CachedData<T> {
14:   version: string
15:   timestamp: number
16:   data: T
17: }
18: 
19: export function useBaseLocalStorage() {
20:   const logger = useLogger('localStorage')
21: 
22:   function getCacheKey(key: LocalStorageKey): string {
23:     return `${key}-${CACHE_VERSION}`
24:   }
25: 
26:   function clearCache(key: LocalStorageKey): void {
27:     localStorage.removeItem(getCacheKey(key))
28:     logger.debug(`Cleared cache for: ${key}`)
29:   }
30: 
31:   function clearAllCaches(): void {
32:     Object.values(LocalStorageEnum).forEach(clearCache)
33:     logger.debug('Cleared all caches')
34:   }
35: 
36:   function getFromCache<T>(key: LocalStorageKey): T | null {
37:     const cacheKey = getCacheKey(key)
38:     const cachedItem = localStorage.getItem(cacheKey)
39: 
40:     if (!cachedItem) {
41:       logger.debug(`No cached data found for: ${key}`)
42:       return null
43:     }
44: 
45:     try {
46:       const parsedData = JSON.parse(cachedItem) as CachedData<T>
47:       const currentTime = Date.now()
48: 
49:       if (
50:         currentTime - parsedData.timestamp <= CACHE_DURATION &&
51:         parsedData.version === CACHE_VERSION
52:       ) {
53:         logger.debug(`Retrieved valid cached data for: ${key}`)
54:         return parsedData.data
55:       } else {
56:         logger.debug(`Cached data for ${key} is outdated or version mismatch`)
57:         clearCache(key)
58:         return null
59:       }
60:     } catch (error) {
61:       logger.error(`Error parsing cached data for ${key}:`, error)
62:       clearCache(key)
63:       return null
64:     }
65:   }
66: 
67:   function setCache<T>(key: LocalStorageKey, data: T): void {
68:     const cacheKey = getCacheKey(key)
69:     const cacheData: CachedData<T> = {
70:       version: CACHE_VERSION,
71:       timestamp: Date.now(),
72:       data,
73:     }
74:     localStorage.setItem(cacheKey, JSON.stringify(cacheData))
75:     logger.debug(`Cached data for: ${key}`)
76:   }
77: 
78:   async function getCachedOrFetch<T>(key: LocalStorageKey, fetchFn: () => Promise<T>): Promise<T> {
79:     const cachedData = getFromCache<T>(key)
80:     if (cachedData) return cachedData
81: 
82:     try {
83:       const fetchedData = await fetchFn()
84:       setCache(key, fetchedData)
85:       return fetchedData
86:     } catch (error) {
87:       logger.error(`Error fetching data for ${key}:`, error)
88:       throw error
89:     }
90:   }
91: 
92:   return {
93:     getFromCache,
94:     setCache,
95:     clearCache,
96:     clearAllCaches,
97:     getCachedOrFetch,
98:   }
99: }
```

## File: layers/crud/composables/main.store.ts
```typescript
 1: import { defineStore } from 'pinia'
 2: import { type Ref, ref } from 'vue'
 3: import type { DomainKey } from './pagination.store'
 4: 
 5: export function createBaseStore<T extends object>(domainKey: DomainKey) {
 6:   return defineStore(`${domainKey}Store`, () => {
 7:     const items = ref<T[]>([]) as Ref<T[]>
 8:     const itemsMap = computed(() => new Map(items.value.map((item) => [item.id, item])))
 9: 
10:     function setItems(newItems: T[]) {
11:       items.value = newItems
12:     }
13: 
14:     function addItems(newItems: T[]) {
15:       const newItemsMap = new Map(newItems.map((item) => [item.id, item]))
16:       items.value = [...items.value.filter((item) => !newItemsMap.has(item.id)), ...newItems]
17:     }
18: 
19:     function updateItem(updatedItem: T) {
20:       const index = items.value.findIndex((item) => item.id === updatedItem.id)
21:       if (index !== -1) {
22:         items.value[index] = { ...items.value[index], ...updatedItem }
23:       } else {
24:         items.value.push(updatedItem)
25:       }
26:     }
27: 
28:     function removeItem(id: string | number) {
29:       items.value = items.value.filter((item) => item.id !== id)
30:     }
31: 
32:     function clearItems() {
33:       items.value = []
34:     }
35: 
36:     function getItemById(id: string | number) {
37:       return itemsMap.value.get(id)
38:     }
39: 
40:     return {
41:       items,
42:       itemsMap,
43:       setItems,
44:       addItems,
45:       updateItem,
46:       removeItem,
47:       clearItems,
48:       getItemById,
49:     }
50:   })
51: }
52: 
53: const storeCache: Partial<Record<DomainKey, ReturnType<typeof createBaseStore>>> = {}
54: 
55: export function getOrCreateStore<T>(domainKey: DomainKey) {
56:   if (!storeCache[domainKey]) {
57:     storeCache[domainKey] = createBaseStore<T>(domainKey)
58:   }
59:   return storeCache[domainKey] as ReturnType<typeof createBaseStore<T>>
60: }
```

## File: layers/crud/composables/notification.ts
```typescript
 1: import type { useToast } from 'primevue/usetoast'
 2: 
 3: interface BaseNotification {
 4:   summary: string
 5:   message: string
 6: }
 7: 
 8: export function useNotification() {
 9:   const nuxtApp = useNuxtApp()
10:   const getToast: typeof useToast = () => nuxtApp.vueApp.config.globalProperties.$toast
11:   const toast = getToast()
12: 
13:   const success = ({ summary, message }: BaseNotification) => {
14:     toast.add({
15:       severity: 'success',
16:       summary: `Success: ${summary}`,
17:       detail: message,
18:       life: 5000,
19:       closable: true,
20:     })
21:   }
22: 
23:   const error = ({ summary, message }: BaseNotification) => {
24:     toast.add({
25:       severity: 'error',
26:       summary: `Error: ${summary}`,
27:       detail: message,
28:       life: 0,
29:       closable: true,
30:     })
31:   }
32: 
33:   const info = ({ summary, message }: BaseNotification) => {
34:     toast.add({
35:       severity: 'info',
36:       summary: `Info: ${summary}`,
37:       detail: message,
38:       life: 5000,
39:       closable: true,
40:     })
41:   }
42: 
43:   const warn = ({ summary, message }: BaseNotification) => {
44:     toast.add({
45:       severity: 'warn',
46:       summary: `Warning: ${summary}`,
47:       detail: message,
48:       life: 5000,
49:       closable: true,
50:     })
51:   }
52: 
53:   const feature = ({ summary, message }: BaseNotification) => {
54:     toast.add({
55:       severity: 'warn',
56:       group: 'cta',
57:       summary: summary,
58:       detail: message,
59:       life: 0,
60:       closable: true,
61:     })
62:   }
63: 
64:   return {
65:     success,
66:     error,
67:     info,
68:     warn,
69:     feature,
70:   }
71: }
```

## File: layers/crud/composables/pagination.store.ts
```typescript
 1: import { useLogger } from '@ib/logger'
 2: 
 3: export type DomainKey =
 4:   | 'users'
 5:   | 'news'
 6:   | 'events'
 7:   | 'venues'
 8:   | 'research'
 9:   | 'companies'
10:   | 'chats'
11:   | 'feedbacks'
12:   | 'currentUser'
13:   | 'chat'
14:   | 'auth'
15: 
16: export type PaginationType = {
17:   page: number
18:   limit: number
19: }
20: 
21: export interface PaginationInput {
22:   domainKey: DomainKey
23:   pagination: PaginationType
24:   force?: boolean
25: }
26: 
27: export const usePaginationStore = defineStore('paginationStore', () => {
28:   const logger = useLogger('paginationStore')
29:   const stores = reactive({} as Record<DomainKey, Ref<{ page: number; limit: number }>>)
30:   const dataFinished = ref({} as Record<DomainKey, boolean>)
31: 
32:   function initPagination(input: PaginationInput) {
33:     if (!stores[input.domainKey] || input.force) {
34:       // -1 for supabase because it is 0 indexed
35:       console.log('initPagination', input.force)
36:       stores[input.domainKey] = {
37:         page: input.pagination.page,
38:         limit: input.pagination.limit - 1,
39:       }
40:     }
41:   }
42: 
43:   function getPagination(domainKey: DomainKey) {
44:     if (!stores[domainKey]) {
45:       logger.warn(`Pagination settings for '${domainKey}' is not initialized.`)
46:       return null
47:     }
48: 
49:     return stores[domainKey]
50:   }
51: 
52:   function getPaginationRange(domainKey: DomainKey) {
53:     const pagination = getPagination(domainKey)
54:     if (pagination) {
55:       logger.info('getPaginationRange', pagination.limit, (pagination.page - 1) * pagination.limit)
56:       return {
57:         from: (pagination.page - 1) * pagination.limit,
58:         to: pagination.limit * pagination.page,
59:       }
60:     }
61:     return undefined
62:   }
63: 
64:   function incrementPagination(domainKey: DomainKey) {
65:     const currentPagination = getPagination(domainKey)
66:     if (currentPagination) {
67:       currentPagination.page++
68:     } else {
69:       logger.warn(`Attempted to increment pagination for an uninitialized store '${domainKey}'.`)
70:     }
71:   }
72: 
73:   function setDataFinished(domainKey: DomainKey) {
74:     if (stores[domainKey]) {
75:       dataFinished.value[domainKey] = true
76:     }
77:   }
78: 
79:   const isDataFinished = (domainKey: DomainKey) => dataFinished.value[domainKey]
80: 
81:   return {
82:     stores,
83:     isDataFinished,
84:     setDataFinished,
85:     initPagination,
86:     getPagination,
87:     incrementPagination,
88:     getPaginationRange,
89:   }
90: })
```

## File: layers/crud/composables/rate-limit.ts
```typescript
 1: interface RateLimitOptions {
 2:   limitMs: number
 3: }
 4: 
 5: export function useRateLimit() {
 6:   const lastActionTimes = ref<Map<string, number>>(new Map())
 7: 
 8:   const checkRateLimit = async (action: string, options: RateLimitOptions): Promise<void> => {
 9:     const now = Date.now()
10:     const lastActionTime = lastActionTimes.value.get(action) || 0
11:     const timeElapsed = now - lastActionTime
12: 
13:     if (timeElapsed < options.limitMs) {
14:       const waitTime = options.limitMs - timeElapsed
15:       await new Promise((resolve) => setTimeout(resolve, waitTime))
16:     }
17: 
18:     lastActionTimes.value.set(action, Date.now())
19:   }
20: 
21:   return {
22:     checkRateLimit,
23:   }
24: }
```

## File: layers/crud/composables/select.ts
```typescript
  1: import { useErrorHandler, AppError, ErrorType, ErrorSeverity, useLogger } from '@ib/logger'
  2: import { useHttpHandler } from './http-handler'
  3: import { getOrCreateStore } from './main.store'
  4: import { usePaginationStore, type PaginationType } from './pagination.store'
  5: import { useRateLimit } from './rate-limit'
  6: 
  7: export function useSelectData<T extends { id: string | number }>(
  8:   tableName: string,
  9:   options: {
 10:     columns?: string
 11:     filters?: Record<string, any>
 12:     orderBy?: { column: string; ascending?: boolean }
 13:     initialFetch?: boolean
 14:     pagination?: PaginationType
 15:     limit?: number
 16:     refreshRelated?: () => Promise<void>
 17:     rateLimitMs?: number
 18:     auditLog?: (action: string, details: any) => Promise<void>
 19:   } = {},
 20: ) {
 21:   const { select } = useHttpHandler()
 22:   const { handleError } = useErrorHandler()
 23:   const logger = useLogger('useSelectData')
 24:   const store = getOrCreateStore<T>(tableName)()
 25:   const { checkRateLimit } = useRateLimit()
 26: 
 27:   const isSelecting: Ref<boolean> = ref(false)
 28:   let lastSelectTime = 0
 29: 
 30:   let paginationStore: ReturnType<typeof usePaginationStore> | null = null
 31: 
 32:   if (options.pagination) {
 33:     paginationStore = usePaginationStore()
 34:     paginationStore.initPagination({
 35:       domainKey: tableName,
 36:       pagination: options.pagination,
 37:       force: true,
 38:     })
 39:   }
 40: 
 41:   const fetchData = async (forceFetch = false) => {
 42:     isSelecting.value = true
 43:     const startTime = Date.now()
 44: 
 45:     try {
 46:       // Rate limiting
 47:       if (options.rateLimitMs && !forceFetch) {
 48:         await checkRateLimit('useSelectData', { limitMs: options.rateLimitMs })
 49:       }
 50: 
 51:       const queryOptions: any = {
 52:         columns: options.columns || '*',
 53:         filters: options.filters,
 54:       }
 55: 
 56:       if (options.orderBy) {
 57:         queryOptions.order = {
 58:           column: options.orderBy.column,
 59:           ascending: options.orderBy.ascending ?? true,
 60:         }
 61:       }
 62: 
 63:       if (paginationStore) {
 64:         const pagination = paginationStore.getPaginationRange(tableName)
 65:         if (pagination) {
 66:           console.log('pagination', pagination)
 67:           queryOptions.range = pagination
 68:         } else {
 69:           throw new AppError({
 70:             type: ErrorType.VALIDATION_ERROR,
 71:             message: `Pagination not initialized for ${tableName}`,
 72:             severity: ErrorSeverity.MEDIUM,
 73:             context: 'Data Fetching',
 74:           })
 75:         }
 76:       } else if (options.limit) {
 77:         queryOptions.range = { from: 0, to: options.limit - 1 }
 78:       }
 79: 
 80:       const result = await select<T>(tableName, queryOptions)
 81:       console.log('Fetch result:', result)
 82: 
 83:       // Audit logging
 84:       if (options.auditLog) {
 85:         await options.auditLog('SELECT', { tableName, options: queryOptions })
 86:       }
 87: 
 88:       lastSelectTime = Date.now()
 89:       return result
 90:     } catch (error: any) {
 91:       handleError(error, 'Error selecting data')
 92:       throw error
 93:     } finally {
 94:       isSelecting.value = false
 95:     }
 96:   }
 97: 
 98:   const loadMore = async () => {
 99:     if (paginationStore) {
100:       console.log('loading more data')
101:       const newData = await fetchData()
102:       if (newData.length === 0) {
103:         paginationStore.setDataFinished(tableName)
104:       } else {
105:         store.addItems(newData)
106:         paginationStore.incrementPagination(tableName)
107:       }
108:     } else {
109:       const data = await fetchData()
110:       store.setItems(data)
111:     }
112: 
113:     // Refresh related data if needed
114:     if (options.refreshRelated) {
115:       await options.refreshRelated()
116:     }
117:   }
118: 
119:   const refresh = async () => {
120:     if (paginationStore) {
121:       paginationStore.initPagination({
122:         domainKey: tableName,
123:         pagination: options.pagination!,
124:         force: true,
125:       })
126:     }
127:     store.clearItems()
128:     await loadMore()
129:   }
130: 
131:   if (options.initialFetch) {
132:     loadMore()
133:   }
134: 
135:   return {
136:     store,
137:     loadMore,
138:     refresh,
139:     isSelecting,
140:   }
141: }
```

## File: layers/crud/composables/settings.store.ts
```typescript
 1: type SettingsKey = 'usersStore' | 'storeNews'
 2: 
 3: export const useSettingsStore = defineStore('settingsStore', () => {
 4:   const settings = ref({} as Settings)
 5:   const summaryLevel = ref('beginner' as SummaryLevel)
 6: 
 7:   function toggleSettings(key: SettingsKey) {
 8:     settings.value[key] = !settings.value[key]
 9:   }
10: 
11:   function isSettingsOn(key: SettingsKey) {
12:     return !settings.value[key]
13:   }
14: 
15:   const changeSummaryLevel = (level: 'beginner' | 'intermediate' | 'expert') => {
16:     summaryLevel.value = level
17:   }
18: 
19:   return {
20:     toggleSettings,
21:     isSettingsOn,
22:   }
23: })
24: 
25: if (import.meta.hot) {
26:   import.meta.hot.accept(acceptHMRUpdate(useSettingsStore, import.meta.hot))
27: }
```

## File: layers/crud/composables/update.ts
```typescript
 1: import { useErrorHandler, AppError, ErrorSeverity, ErrorType, useLogger } from '@ib/logger'
 2: import { useHttpHandler } from './http-handler'
 3: import { getOrCreateStore } from './main.store'
 4: import { useRateLimit } from './rate-limit'
 5: 
 6: export function useUpdateData<T extends { id: string | number }>(
 7:   tableName: string,
 8:   options: {
 9:     columns?: string
10:     validateData?: (data: Partial<T>) => boolean | Promise<boolean>
11:     refreshRelated?: () => Promise<void>
12:     transformData?: (data: Partial<T>) => Partial<T>
13:     rateLimitMs?: number
14:     auditLog?: (action: string, details: any) => Promise<void>
15:   } = {},
16: ) {
17:   const { update } = useHttpHandler()
18:   const { handleError } = useErrorHandler()
19:   const logger = useLogger('useUpdateData')
20:   const store = getOrCreateStore<T>(tableName)()
21:   const { checkRateLimit } = useRateLimit()
22: 
23:   const isUpdating: Ref<boolean> = ref(false)
24:   let lastUpdateTime = 0
25: 
26:   const updateData = async (id: string | number, data: Partial<T>) => {
27:     isUpdating.value = true
28:     const startTime = Date.now()
29:     let oldData: T | undefined = undefined
30: 
31:     try {
32:       // Rate limiting
33:       if (options.rateLimitMs) {
34:         await checkRateLimit('useUpdateData', { limitMs: options.rateLimitMs })
35:       }
36: 
37:       // Validation
38:       if (options.validateData && !(await options.validateData(data))) {
39:         throw new AppError({
40:           type: ErrorType.VALIDATION_ERROR,
41:           message: 'Data validation failed',
42:           severity: ErrorSeverity.MEDIUM,
43:           context: 'Data Validation',
44:         })
45:       }
46: 
47:       // Data transformation
48:       const transformedData = options.transformData ? options.transformData(data) : data
49: 
50:       // Optimistic update
51:       oldData = store.getItemById(id)
52:       if (!oldData) {
53:         throw new AppError({
54:           type: ErrorType.NOT_FOUND_ERROR,
55:           message: 'Item not found in store',
56:           severity: ErrorSeverity.MEDIUM,
57:           context: 'Data Update',
58:         })
59:       }
60:       store.updateItem({ ...oldData, ...transformedData, id })
61: 
62:       // Perform the update
63:       const result = await update(tableName, id, transformedData, { columns: options.columns })
64: 
65:       // Update store with actual server data
66:       store.updateItem(result)
67: 
68:       // Refresh related data if needed
69:       if (options.refreshRelated) {
70:         await options.refreshRelated()
71:       }
72: 
73:       // Audit logging
74:       if (options.auditLog) {
75:         await options.auditLog('UPDATE', { tableName, id, oldData, newData: result })
76:       }
77: 
78:       lastUpdateTime = Date.now()
79:       return result
80:     } catch (error: any) {
81:       // Revert optimistic update
82:       if (oldData) {
83:         store.updateItem(oldData)
84:       }
85:       handleError(error, 'Error updating data')
86:       throw error
87:     } finally {
88:       isUpdating.value = false
89:     }
90:   }
91: 
92:   return {
93:     updateData,
94:     isUpdating,
95:   }
96: }
```

## File: layers/crud/composables/upload.ts
```typescript
  1: import { v4 as uuidv4 } from 'uuid'
  2: import { useErrorHandler, AppError, ErrorType, ErrorSeverity, useLogger } from '@ib/logger'
  3: import { useRateLimit } from './rate-limit'
  4: 
  5: type FileType = 'profile' | 'document' | 'image' | 'video' | 'audio' | 'other'
  6: 
  7: interface UploadOptions {
  8:   bucket: string
  9:   path: string
 10:   fileType: FileType
 11:   userId?: string
 12:   metadata?: Record<string, string>
 13:   optimizeImage?: boolean
 14:   maxWidth?: number
 15:   maxHeight?: number
 16:   quality?: number
 17:   format?: 'jpeg' | 'jpg' | 'png' | 'webp'
 18:   rateLimitMs?: number
 19:   auditLog?: (action: string, details: any) => Promise<void>
 20:   onProgress?: (progress: number) => void
 21:   maxFileSize?: number
 22:   allowedMimeTypes?: string[]
 23:   serverSideOptimize?: boolean
 24:   useServerUpload?: boolean
 25:   replace?: boolean
 26: }
 27: 
 28: interface UploadResult {
 29:   path: string
 30:   publicUrl: string
 31:   size: number
 32:   mimeType: string
 33:   metadata: Record<string, string>
 34: }
 35: 
 36: export function useFileUpload() {
 37:   const supabase = useSupabaseClient()
 38:   const { handleError } = useErrorHandler()
 39:   const { checkRateLimit } = useRateLimit()
 40:   const isUploading: Ref<boolean> = ref(false)
 41:   const uploadProgress: Ref<number> = ref(0)
 42:   const lastUploadTime = ref(0)
 43:   const uploadQueue: Ref<File[]> = ref([])
 44:   const currentUpload: Ref<File | null> = ref(null)
 45: 
 46:   const isProcessing = computed(() => uploadQueue.value.length > 0 || currentUpload.value !== null)
 47: 
 48:   const getFilePath = (fileName: string, options: UploadOptions): string => {
 49:     const { bucket, path, fileType, userId, replace } = options
 50:     const timestamp = new Date().toISOString().replace(/[-:]/g, '').split('.')[0]
 51:     const uniqueId = uuidv4().slice(0, 8)
 52:     const userPath = userId ? `${userId}/` : ''
 53:     return `${bucket}/${fileType}/${userPath}${path || ''}/${replace ? '' : `${timestamp}_${uniqueId}_`}${fileName}`
 54:   }
 55: 
 56:   const validateFile = (file: File, options: UploadOptions): void => {
 57:     if (options.maxFileSize && file.size > options.maxFileSize) {
 58:       throw new AppError({
 59:         type: ErrorType.VALIDATION_ERROR,
 60:         message: `File size exceeds the maximum allowed size of ${options.maxFileSize} bytes`,
 61:         severity: ErrorSeverity.MEDIUM,
 62:         context: 'File Upload',
 63:       })
 64:     }
 65: 
 66:     if (options.allowedMimeTypes && !options.allowedMimeTypes.includes(file.type)) {
 67:       throw new AppError({
 68:         type: ErrorType.VALIDATION_ERROR,
 69:         message: `File type ${file.type} is not allowed`,
 70:         severity: ErrorSeverity.MEDIUM,
 71:         context: 'File Upload',
 72:       })
 73:     }
 74:   }
 75: 
 76:   const serverSideUpload = async (file: File, options: UploadOptions): Promise<UploadResult> => {
 77:     const formData = new FormData()
 78:     formData.append('file', file)
 79:     formData.append('userId', options.userId || '')
 80:     formData.append('fileType', options.fileType)
 81:     formData.append('bucket', options.bucket)
 82:     formData.append('path', options.path)
 83:     formData.append(
 84:       'optimizationOptions',
 85:       JSON.stringify({
 86:         maxWidth: options.maxWidth,
 87:         maxHeight: options.maxHeight,
 88:         quality: options.quality,
 89:         format: options.format,
 90:       }),
 91:     )
 92: 
 93:     const response = await $fetch('/api/upload', {
 94:       method: 'POST',
 95:       body: formData,
 96:       onUploadProgress: (progressEvent) => {
 97:         if (progressEvent.total) {
 98:           const progress = Math.round((progressEvent.loaded * 100) / progressEvent.total)
 99:           uploadProgress.value = progress
100:           options.onProgress?.(progress)
101:         }
102:       },
103:     })
104: 
105:     if (!response || !response.fileName) {
106:       throw new Error('Failed to upload file on server')
107:     }
108: 
109:     const publicUrl = supabase.storage.from(options.bucket).getPublicUrl(response.fileName)
110:       .data.publicUrl
111: 
112:     return {
113:       path: response.fileName,
114:       publicUrl,
115:       size: file.size,
116:       mimeType: file.type,
117:       metadata: {
118:         originalName: file.name,
119:         ...options.metadata,
120:       },
121:     }
122:   }
123: 
124:   const uploadFile = async (file: File, options: UploadOptions): Promise<UploadResult> => {
125:     isUploading.value = true
126:     uploadProgress.value = 0
127:     currentUpload.value = file
128: 
129:     try {
130:       validateFile(file, options)
131: 
132:       // Rate limiting
133:       if (options.rateLimitMs) {
134:         await checkRateLimit('fileUpload', { limitMs: options.rateLimitMs })
135:       }
136: 
137:       let result: UploadResult
138: 
139:       if (options.useServerUpload) {
140:         result = await serverSideUpload(file, options)
141:       } else {
142:         const filePath = getFilePath(file.name, options)
143:         const { data, error } = await supabase.storage.from(options.bucket).upload(filePath, file, {
144:           cacheControl: '3600',
145:           upsert: options.replace,
146:           contentType: file.type,
147:         })
148: 
149:         if (error) {
150:           throw new AppError({
151:             type: ErrorType.UPLOAD_ERROR,
152:             message: `Error uploading file: ${error.message}`,
153:             severity: ErrorSeverity.HIGH,
154:             context: 'File Upload',
155:           })
156:         }
157: 
158:         const {
159:           data: { publicUrl },
160:         } = supabase.storage.from(options.bucket).getPublicUrl(data.path)
161: 
162:         result = {
163:           path: data.path,
164:           publicUrl,
165:           size: file.size,
166:           mimeType: file.type,
167:           metadata: {
168:             originalName: file.name,
169:             ...options.metadata,
170:           },
171:         }
172:       }
173: 
174:       lastUploadTime.value = Date.now()
175: 
176:       return result
177:     } catch (error: any) {
178:       handleError(error, 'Error uploading file')
179:       throw error
180:     } finally {
181:       isUploading.value = false
182:       uploadProgress.value = 100
183:       currentUpload.value = null
184:       processQueue()
185:     }
186:   }
187: 
188:   const processQueue = async () => {
189:     if (uploadQueue.value.length > 0 && !isUploading.value) {
190:       const nextFile = uploadQueue.value.shift()
191:       if (nextFile) {
192:         await uploadFile(nextFile, {
193:           bucket: 'default',
194:           path: 'uploads',
195:           fileType: 'other',
196:         })
197:       }
198:     }
199:   }
200: 
201:   const queueUpload = (file: File, options: UploadOptions) => {
202:     uploadQueue.value.push(file)
203:     processQueue()
204:   }
205: 
206:   const cancelUpload = () => {
207:     if (currentUpload.value) {
208:       // Implement cancellation logic here
209:       // This might involve aborting the Supabase upload if possible
210:       currentUpload.value = null
211:       isUploading.value = false
212:       uploadProgress.value = 0
213:     }
214:   }
215: 
216:   const clearQueue = () => {
217:     uploadQueue.value = []
218:   }
219: 
220:   return {
221:     uploadFile,
222:     queueUpload,
223:     cancelUpload,
224:     clearQueue,
225:     isUploading,
226:     isProcessing,
227:     uploadProgress,
228:     currentUpload,
229:     uploadQueue,
230:   }
231: }
```

## File: layers/crud/composables/useApiDataStore.ts
```typescript
 1: // stores/apiData.ts
 2: import { defineStore } from 'pinia'
 3: import { ref } from 'vue'
 4: 
 5: interface ApiDataStructure {
 6:   [key: string]: any
 7: }
 8: 
 9: export const useApiDataStore = defineStore('apiData', () => {
10:   const apiData = ref<ApiDataStructure>({})
11: 
12:   const setData = (url: string, data: any): void => {
13:     apiData.value[url] = data
14:   }
15: 
16:   const getData = (url: string): any => {
17:     return apiData.value[url]
18:   }
19: 
20:   const clearData = (): void => {
21:     apiData.value = {}
22:   }
23: 
24:   return {
25:     apiData,
26:     setData,
27:     getData,
28:     clearData,
29:   }
30: })
```

## File: layers/crud/composables/useBaseError.ts
```typescript
  1: import { useLogger } from '@ib/logger'
  2: 
  3: interface ErrorMessage {
  4:   userMessage: string // User-friendly error message if needed
  5:   devMessage: string // Make bugfixing easy!
  6:   error: any
  7: }
  8: 
  9: interface ErrorServer extends Omit<ErrorMessage, 'error'> {
 10:   devOnly: boolean // default true - don't show toasts in production
 11:   featureRelated?: boolean // default false - log to feature-specific log
 12:   response: { data: any; error: any }
 13: }
 14: 
 15: interface ErrorClient extends ErrorMessage {
 16:   isServer?: boolean // default false
 17:   featureRelated?: boolean // default false - log to feature-specific log
 18:   devOnly: boolean
 19: }
 20: 
 21: export function useBaseError() {
 22:   // !todo:med:easy - add prefix to base error
 23: 
 24:   // const toast = useNotification()
 25:   const logger = useLogger('useBaseError')
 26:   const isAdmin = useRuntimeConfig().public.nodeEnv === 'development'
 27: 
 28:   // function handleErrorWithCodes(error: any) {
 29:   //   switch (error.statusCode) {
 30:   //     case 429:
 31:   //       toast.feature({
 32:   //         summary: error.statusMessage,
 33:   //         message: error.message,
 34:   //       })
 35:   //       break
 36:   //     case 403:
 37:   //       toast.error({
 38:   //         summary: error.statusMessage,
 39:   //         message: error.message,
 40:   //       })
 41:   //       break
 42:   //     default:
 43:   //       console.error('Unhandled feature error:', error)
 44:   //   }
 45:   // }
 46: 
 47:   function formatErrorMessage({ userMessage, devMessage, error }: ErrorMessage) {
 48:     const devError = `${devMessage}: ${JSON.stringify(error)}`
 49:     logger.error(devError)
 50:     const userError = userMessage || 'An unexpected error occurred. Please try again later.'
 51:     return isAdmin ? devError : userError
 52:   }
 53: 
 54:   function handleError({
 55:     userMessage,
 56:     devMessage,
 57:     devOnly = true,
 58:     isServer = false,
 59:     error,
 60:   }: ErrorClient) {
 61:     // Determine the appropriate user message
 62:     const errorMessage = formatErrorMessage({ error, userMessage, devMessage })
 63: 
 64:     // Add an error toast notification with an option to retry if an action is provided
 65: 
 66:     // Handle critical errors specifically if needed
 67:     if (!devOnly || isAdmin) {
 68:       // toast.error({
 69:       //   summary: 'Error',
 70:       //   message: errorMessage,
 71:       // })
 72:       // Here you could navigate to an error page, log out the user, etc.
 73:       console.error('Handling critical error for:', devMessage)
 74:     }
 75: 
 76:     throw createError({
 77:       message: `${isServer ? 'SERVER' : 'CLIENT'} ERROR: ${errorMessage}`,
 78:     })
 79:   }
 80: 
 81:   function handleServerError({ response, devMessage, devOnly, userMessage }: ErrorServer) {
 82:     if (response.error) {
 83:       console.log('FeatError', response.error)
 84:       handleError({
 85:         error: response.error,
 86:         devOnly,
 87:         userMessage,
 88:         isServer: true,
 89:         devMessage,
 90:       })
 91:     } else if (response.data) {
 92:       logger.info(`Successfully fetched ${response.data.length} items`)
 93:       return response.data
 94:     }
 95:     logger.info('Nothing returned from database')
 96:     return null
 97:   }
 98: 
 99:   return {
100:     server: handleServerError,
101:     client: handleError,
102:   }
103: }
```

## File: layers/crud/composables/user.current.store.ts
```typescript
  1: import { useLogger } from '@ib/logger'
  2: 
  3: const DOMAIN_KEY = 'currentUser'
  4: 
  5: export const useCurrentUser = defineStore(DOMAIN_KEY, () => {
  6:   const authUrl = useRuntimeConfig().public.aeAuthUrl
  7:   const logger = useLogger(DOMAIN_KEY)
  8:   const errors = useBaseError()
  9:   const loading = useLoadingStore()
 10:   const { fetch } = useBaseFetch()
 11:   const userId = useCookie('userId')
 12:   const user = useSupabaseUser()
 13: 
 14:   // check:critical - user should only be able to fetch their own full profile
 15:   // check:critical - user should only be able to update their own profile
 16:   // todo:high - allow user to update their profile info
 17:   // todo:med - merge currentUser and profile into one, store all required data everything in their session
 18:   // assign Posthog identify
 19: 
 20:   console.log('user', user.value)
 21: 
 22:   const profile = computed(() => ({
 23:     id: user.value?.id,
 24:     given_name: user.value?.user_metadata?.given_name,
 25:     email_confirmed_at: user.value?.email_confirmed_at,
 26:     confirmation_sent_at: user.value?.confirmation_sent_at,
 27:     confirmed_at: user.value?.confirmed_at,
 28:     created_at: user.value?.created_at,
 29:     surname: user.value?.user_metadata?.surname,
 30:     last_sign_in_at: user.value?.last_sign_in_at,
 31:     email: user.value?.email,
 32:     providers: user.value?.app_metadata.providers,
 33:     avatar: user.value?.user_metadata.avatar ?? user.value?.user_metadata.avatar_url,
 34:     provider: user.value?.provider,
 35:     user_role: user.value?.app_metadata?.role,
 36:     user_plan: user.value?.app_metadata?.plan,
 37:   }))
 38: 
 39:   // extract as util func
 40:   function hasValueChanged(newValue: any, currentValue: any): boolean {
 41:     console.log('hasValueChanged', newValue, currentValue)
 42:     if (
 43:       typeof newValue === 'string' ||
 44:       typeof newValue === 'boolean' ||
 45:       typeof newValue === 'number'
 46:     ) {
 47:       return newValue !== currentValue
 48:     } else if (Array.isArray(newValue)) {
 49:       return JSON.stringify(newValue) !== JSON.stringify(currentValue)
 50:     } else if (typeof newValue === 'object' && newValue !== null) {
 51:       return JSON.stringify(newValue) !== JSON.stringify(currentValue)
 52:     } else {
 53:       return newValue !== currentValue
 54:     }
 55:   }
 56: 
 57:   function cleanDataForUpdate(newData: any, previousData: any) {
 58:     const updatedData: any = {}
 59:     for (const key in newData) {
 60:       if (
 61:         Object.hasOwnProperty.call(newData, key) &&
 62:         hasValueChanged(newData[key], previousData[key])
 63:       ) {
 64:         updatedData[key] = newData[key]
 65:       }
 66:     }
 67: 
 68:     return { data: updatedData, noDataUpdated: Object.keys(updatedData).length === 0 }
 69:   }
 70: 
 71:   async function updateProfile(newData: any, isMock: boolean = false) {
 72:     logger.info('Starting updateProfile function', { newData, isMock })
 73:     const updatedData: any = {}
 74: 
 75:     logger.debug('Cleaning data for update')
 76:     // Compare newData with fullProfile and only include changed values
 77:     const { noDataUpdated, data } = cleanDataForUpdate(newData, profile.value)
 78: 
 79:     if (noDataUpdated) {
 80:       logger.info('No changes detected, no update necessary')
 81:       return
 82:     }
 83: 
 84:     logger.debug('Changes detected', { changedData: data })
 85: 
 86:     try {
 87:       logger.info('Sending update request to server')
 88:       let response
 89:       if (isMock) {
 90:         logger.info('Using mock API call')
 91:         // response = await mockApiCall(data)
 92:       } else {
 93:         response = await $fetch('/api/users/update', {
 94:           method: 'POST',
 95:           body: JSON.stringify(data),
 96:         })
 97:       }
 98:       logger.debug('Received response from server', { response })
 99: 
100:       const validData = errors.server({
101:         response,
102:         devOnly: false,
103:         devMessage: 'Error updating user profile',
104:         userMessage: 'There was an error updating your profile after action',
105:       })
106: 
107:       logger.info('Successfully validated server response', { validData })
108: 
109:       // update state
110:       logger.debug('Updating user profile state')
111:       for (const key in validData[0]) {
112:         if (Object.hasOwnProperty.call(validData[0], key)) {
113:           logger.debug(`Updating profile field: ${key}`, {
114:             newValue: validData[0][key],
115:           })
116:         }
117:       }
118:       logger.info('Profile update completed successfully')
119:     } catch (error) {
120:       logger.error('Error occurred during profile update', { error })
121:       throw error // Re-throw the error for the caller to handle
122:     }
123:   }
124: 
125:   // Test function
126:   async function testUpdateProfile() {
127:     const testCases = [
128:       { name: 'John Doe', email: 'john@example.com' },
129:       { name: 'Jane Doe', email: 'error@example.com' }, // This will trigger an error
130:       {}, // This should result in no update
131:     ]
132: 
133:     for (const testCase of testCases) {
134:       try {
135:         console.log('Testing with data:', testCase)
136:         await updateProfile(testCase, true) // Use mock API
137:         console.log('Test passed successfully')
138:       } catch (error) {
139:         console.error('Test failed:', error.message)
140:       }
141:       console.log('---')
142:     }
143:   }
144: 
145:   type FileType = 'avatar'
146:   async function uploadImage(fileType: FileType, blob: Blob) {
147:     // currentFileName is the current file name in the database eg. avatar-drew-macgibbon.jpg
148:     const formData = new FormData()
149:     formData.append('file', blob)
150: 
151:     const response = await $fetch('/api/users/insert/image', {
152:       method: 'POST',
153:       body: formData,
154:       params: {
155:         fileType,
156:         userId: userId.value,
157:       },
158:     })
159: 
160:     console.log('fileName', response)
161: 
162:     const fileName = errors.server({
163:       response,
164:       devOnly: false,
165:       devMessage: `Error uploading ${fileType} image`,
166:       userMessage: `There was an error uploading your ${fileType}`,
167:     })
168: 
169:     let newData = {}
170: 
171:     console.log('fileName', fileName)
172: 
173:     if (fileType === 'avatar') {
174:       newData = {
175:         avatar: fileName,
176:       }
177:     }
178: 
179:     updateProfile(newData)
180:   }
181: 
182:   // first check if the user has an avatar in their profile
183:   // if not, check if the user has an avatar in their identities
184:   // cycle through identities check identities_data for picture
185: 
186:   return {
187:     haveUserSession: computed(() => !!profile.value),
188:     isAdmin: computed(
189:       () => profile.value?.user_role === 'admin' || profile.value?.user_role === 'super_admin',
190:     ),
191:     registeredWithProvider: computed(() => profile.value?.provider),
192:     profile,
193:     uploadImage,
194:     updateProfile,
195:     testUpdateProfile,
196:   }
197: })
198: 
199: if (import.meta.hot) {
200:   import.meta.hot.accept(acceptHMRUpdate(useCurrentUser, import.meta.hot))
201: }
```

## File: layers/crud/server/utils/base.interface.ts
```typescript
 1: type DBTable = keyof Database['public']['Tables'] & keyof Database['public']['Views']
 2: type DBColumns<T extends DBTable> = keyof Tables<T>
 3: type TableSpecificColumns<T extends DBTable> = Partial<DBColumns<T>>
 4: 
 5: // full list of filters here: https://postgrest.org/en/v12/references/api/tables_views.html#operators
 6: 
 7: type FilterKey =
 8:   | 'eq'
 9:   | 'match'
10:   | 'neq'
11:   | 'not'
12:   | 'gte'
13:   | 'gt'
14:   | 'lt'
15:   | 'lte'
16:   | 'like'
17:   | 'ilike'
18:   | 'is'
19:   | 'in'
20:   | 'contains'
21:   | 'containedBy'
22:   | 'rangeGt'
23:   | 'rangeGte'
24:   | 'rangeLt'
25:   | 'rangeLte'
26:   | 'rangeAdjacent'
27:   | 'overlaps'
28:   | 'textSearch'
29: 
30: interface Pagination {
31:   page?: number
32:   limit?: number
33:   from: number
34:   to: number
35: }
36: 
37: export type GenericReturn<T> = Promise<T[] | T | null>
38: 
39: export type TableKey = keyof Database['public']['Tables'] | keyof Database['public']['Views']
40: 
41: export type FilterBy<T extends DBTable> = {
42:   columnName: TableSpecificColumns<T>
43:   operator: FilterKey
44:   value: string | boolean | number
45: }
46: 
47: type OrderBy<T extends DBTable> = {
48:   columnNames: TableSpecificColumns<T>[]
49:   ascending: boolean
50:   referenceTable?: string
51: }
52: 
53: type Conflict = {
54:   onConflict: string[]
55:   ignoreDuplicates: boolean
56:   count?: 'exact' | 'planned' | 'estimated'
57:   defaultToNull?: boolean
58: }
59: 
60: // todo: refactor to have options under select/insert/update/delete
61: // for instance we can group limit, pagination, selectStatement all under select
62: export interface BaseOperationInput<T, K extends DBTable> {
63:   tableName: K
64:   data?: T | T[]
65:   selectStatement?: string
66:   filterBy?: FilterBy<K> | false
67:   orderBy?: OrderBy<K> | false
68:   pagination?: Pagination | false
69:   limit?: number
70:   isSingle?: boolean
71:   isReturned?: boolean
72:   conflict?: Conflict
73: }
74: 
75: export interface SelectInput<T, K extends DBTable> extends BaseOperationInput<T, K> {
76:   selectStatement: string
77: }
78: 
79: export interface InsertInput<T, K extends DBTable> extends BaseOperationInput<T, K> {
80:   data: T | T[]
81: }
82: 
83: export interface UpsertInput<T, K extends DBTable> extends BaseOperationInput<T, K> {
84:   data: T | T[]
85:   conflict: Conflict
86: }
87: 
88: export interface UpdateInput<T, K extends DBTable> extends BaseOperationInput<T, K> {
89:   data: T | T[]
90:   filterBy: FilterBy<K>
91: }
92: 
93: export interface DeleteInput<T, K extends DBTable> extends BaseOperationInput<T, K> {
94:   data: T | T[]
95:   filterBy: FilterBy<K>
96: }
97: 
98: export type { Database, Tables, DBTable }
```

## File: layers/crud/nuxt.config.ts
```typescript
 1: export default defineNuxtConfig({
 2:   modules: ['@nuxtjs/supabase'],
 3: 
 4:   supabase: {
 5:     redirect: false,
 6:     clientOptions: {
 7:       auth: {
 8:         flowType: 'pkce',
 9:         detectSessionInUrl: true,
10:         persistSession: true,
11:         autoRefreshToken: true,
12:       },
13:     },
14:     cookieName: 'sb',
15:   },
16: })
```

## File: libs/logger/src/environment.d.ts
```typescript
 1: // src/environment.d.ts
 2: 
 3: declare global {
 4:   // Add Nuxt runtime config types
 5:   interface RuntimeConfig {
 6:     public: {
 7:       nodeEnv?: string
 8:       [key: string]: any
 9:     }
10:     [key: string]: any
11:   }
12: 
13:   // Add useRuntimeConfig function type
14:   type UseRuntimeConfig = () => RuntimeConfig
15: 
16:   const useRuntimeConfig: UseRuntimeConfig | undefined
17: }
18: 
19: export interface ImportMetaEnv {
20:   MODE: string
21:   DEV: boolean
22:   PROD: boolean
23:   [key: string]: any
24: }
25: 
26: export interface ImportMeta {
27:   url: string
28:   env: ImportMetaEnv
29:   readonly hot?: {
30:     accept: () => void
31:     dispose: () => void
32:     invalidate: () => void
33:     [key: string]: any
34:   }
35: }
36: 
37: export {}
```

## File: libs/logger/src/environment.ts
```typescript
 1: // src/environment.ts
 2: export const getEnvironment = () => {
 3:   // Check for Node.js environment more safely
 4:   const isNode = (() => {
 5:     try {
 6:       return typeof globalThis.process !== 'undefined' && !!globalThis.process?.versions?.node
 7:     } catch {
 8:       return false
 9:     }
10:   })()
11: 
12:   // Check for browser environment
13:   const isBrowser = (() => {
14:     try {
15:       return typeof window !== 'undefined'
16:     } catch {
17:       return false
18:     }
19:   })()
20: 
21:   // Check for development mode across different environments
22:   const isDev = (() => {
23:     try {
24:       // For Nuxt specific environment
25:       if (typeof globalThis.useRuntimeConfig === 'function') {
26:         const config = globalThis.useRuntimeConfig()
27:         return config.public.nodeEnv === 'development'
28:       }
29: 
30:       // Fallback checks
31:       return Boolean(
32:         import.meta?.env?.DEV ||
33:           import.meta?.env?.MODE === 'development' ||
34:           (typeof process !== 'undefined' && process.env.NODE_ENV === 'development'),
35:       )
36:     } catch {
37:       return false
38:     }
39:   })()
40: 
41:   return {
42:     isNode,
43:     isBrowser,
44:     isDev,
45:   }
46: }
```

## File: libs/logger/src/error-interface.ts
```typescript
  1: export interface ErrorMessage {
  2:   userMessage: string // User-friendly error message if needed
  3:   devMessage: string // Make bugfixing easy!
  4:   error: any
  5: }
  6: 
  7: export interface ErrorServer extends Omit<ErrorMessage, 'error'> {
  8:   featureRelated?: boolean // default false - log to feature-specific log
  9:   response: { data: any; error: any }
 10: }
 11: 
 12: // Retryable status codes with descriptions
 13: export const retryableStatusCodes: { [key: number]: string } = {
 14:   408: 'Request Timeout - The server timed out waiting for the request.',
 15:   409: 'Conflict - The request could not be completed due to a conflict with the current state of the target resource.',
 16:   425: 'Too Early - The server is unwilling to risk processing a request that might be replayed.',
 17:   500: 'Internal Server Error - The server encountered an unexpected condition that prevented it from fulfilling the request.',
 18:   502: 'Bad Gateway - The server, while acting as a gateway or proxy, received an invalid response from an inbound server.',
 19:   503: 'Service Unavailable - The server is currently unable to handle the request due to temporary overloading or maintenance of the server.',
 20:   504: 'Gateway Timeout - The server, while acting as a gateway or proxy, did not receive a timely response from an upstream server.',
 21: }
 22: 
 23: export enum ErrorSeverity {
 24:   LOW = 'low',
 25:   MEDIUM = 'medium',
 26:   HIGH = 'high',
 27:   CRITICAL = 'critical',
 28: }
 29: 
 30: export enum ErrorType {
 31:   UPLOAD_ERROR = 'UPLOAD_ERROR',
 32:   CONNECTION_ERROR = 'CONNECTION_ERROR',
 33:   AUTHENTICATION_ERROR = 'AUTHENTICATION_ERROR',
 34:   UNIQUE_VIOLATION = 'UNIQUE_VIOLATION',
 35:   FOREIGN_KEY_VIOLATION = 'FOREIGN_KEY_VIOLATION',
 36:   NOT_NULL_VIOLATION = 'NOT_NULL_VIOLATION',
 37:   CONSTRAINT_ERROR = 'CONSTRAINT_ERROR',
 38:   UNDEFINED_TABLE = 'UNDEFINED_TABLE',
 39:   UNDEFINED_PARAMETER = 'UNDEFINED_PARAMETER',
 40:   SYNTAX_ERROR = 'SYNTAX_ERROR',
 41:   DUPLICATE_ALIAS = 'DUPLICATE_ALIAS',
 42:   UNDEFINED_COLUMN = 'UNDEFINED_COLUMN',
 43:   DATA_EXCEPTION = 'DATA_EXCEPTION',
 44:   SERIALIZATION_FAILURE = 'SERIALIZATION_FAILURE',
 45:   DEADLOCK_DETECTED = 'DEADLOCK_DETECTED',
 46:   INSUFFICIENT_RESOURCES = 'INSUFFICIENT_RESOURCES',
 47:   RATE_LIMIT_ERROR = 'RATE_LIMIT_ERROR',
 48:   SERVER_ERROR = 'SERVER_ERROR',
 49:   UNKNOWN_ERROR = 'UNKNOWN_ERROR',
 50:   VALIDATION_ERROR = 'VALIDATION_ERROR',
 51:   NOT_FOUND_ERROR = 'NOT_FOUND_ERROR',
 52:   NETWORK_ERROR = 'NETWORK_ERROR',
 53: }
 54: 
 55: // Types
 56: export interface ErrorDetails {
 57:   type: ErrorType
 58:   message: string
 59:   severity: ErrorSeverity
 60:   stack?: string
 61:   code?: string | number
 62:   context?: string
 63:   pgError?: string
 64:   operation?: string
 65:   originalError?: any
 66: }
 67: 
 68: export interface ErrorHandlerOptions {
 69:   context?: string
 70:   userMessage?: string
 71:   devMessage?: string
 72:   throwError?: boolean
 73: }
 74: 
 75: export interface FetchErrorResponse {
 76:   data?: any
 77:   error?: any
 78: }
 79: 
 80: export function mapErrorSeverity(error: any): ErrorSeverity {
 81:   if (error.status >= 500) return ErrorSeverity.CRITICAL
 82:   if (error.status === 429) return ErrorSeverity.HIGH
 83: 
 84:   // Connection errors are critical
 85:   if (error.code?.startsWith('08')) return ErrorSeverity.CRITICAL
 86: 
 87:   // Authentication errors are high severity
 88:   if (error.code?.startsWith('28')) return ErrorSeverity.HIGH
 89: 
 90:   // Constraint violations are high severity
 91:   if (error.code?.startsWith('23')) return ErrorSeverity.HIGH
 92: 
 93:   // Query errors are medium severity
 94:   if (error.code?.startsWith('42')) return ErrorSeverity.MEDIUM
 95: 
 96:   // Data exceptions are medium severity
 97:   if (error.code?.startsWith('22')) return ErrorSeverity.MEDIUM
 98: 
 99:   // Transaction errors are high severity
100:   if (error.code === '40001' || error.code === '40P01') return ErrorSeverity.HIGH
101: 
102:   // System errors are critical
103:   if (error.code?.startsWith('53')) return ErrorSeverity.CRITICAL
104: 
105:   // Default to medium severity for unknown errors
106:   return ErrorSeverity.MEDIUM
107: }
108: 
109: export function mapErrorType(error: any): ErrorType {
110:   // Connection errors
111:   if (
112:     error.code === '08000' ||
113:     error.code === '08003' ||
114:     error.code === '08006' ||
115:     error.code === '08001' ||
116:     error.code === '08004'
117:   ) {
118:     return ErrorType.CONNECTION_ERROR
119:   }
120: 
121:   // Authentication errors
122:   if (error.code === '28000' || error.code === '28P01') {
123:     return ErrorType.AUTHENTICATION_ERROR
124:   }
125: 
126:   // Constraint violations
127:   if (error.code === '23505') return ErrorType.UNIQUE_VIOLATION
128:   if (error.code === '23503') return ErrorType.FOREIGN_KEY_VIOLATION
129:   if (error.code === '23502') return ErrorType.NOT_NULL_VIOLATION
130:   if (error.code?.startsWith('23') && !['23505', '23503', '23502'].includes(error.code))
131:     return ErrorType.CONSTRAINT_ERROR
132: 
133:   // Query errors
134:   if (error.code === '42P01') return ErrorType.UNDEFINED_TABLE
135:   if (error.code === '42P02') return ErrorType.UNDEFINED_PARAMETER
136:   if (error.code === '42601') return ErrorType.SYNTAX_ERROR
137:   if (error.code === '42P07') return ErrorType.DUPLICATE_ALIAS
138:   if (error.code === '42703') return ErrorType.UNDEFINED_COLUMN
139: 
140:   // Data errors
141:   if (error.code?.startsWith('22')) return ErrorType.DATA_EXCEPTION
142: 
143:   // Transaction errors
144:   if (error.code === '40001') return ErrorType.SERIALIZATION_FAILURE
145:   if (error.code === '40P01') return ErrorType.DEADLOCK_DETECTED
146: 
147:   // System errors
148:   if (
149:     error.code === '53000' ||
150:     error.code === '53100' ||
151:     error.code === '53200' ||
152:     error.code === '53300'
153:   ) {
154:     return ErrorType.INSUFFICIENT_RESOURCES
155:   }
156: 
157:   // HTTP-specific errors
158:   if (error.status === 429) return ErrorType.RATE_LIMIT_ERROR
159:   if (error.status >= 500) return ErrorType.SERVER_ERROR
160: 
161:   // Catch-all for unspecified errors
162:   return ErrorType.UNKNOWN_ERROR
163: }
164: 
165: export interface LogLevels {
166:   error: 0
167:   warn: 1
168:   info: 2
169:   http: 3
170:   verbose: 4
171:   debug: 5
172:   silly: 6
173: }
174: 
175: export class AppError extends Error {
176:   details: ErrorDetails
177: 
178:   constructor(details: ErrorDetails) {
179:     super(details.message)
180:     this.details = details
181:     this.name = 'AppError'
182:   }
183: }
184: 
185: export interface Logger {
186:   error: (message: string, ...args: any[]) => void
187:   warn: (message: string, ...args: any[]) => void
188:   info: (message: string, ...args: any[]) => void
189:   verbose: (message: string, ...args: any[]) => void
190:   debug: (message: string, ...args: any[]) => void
191:   silly: (message: string, ...args: any[]) => void
192:   http: (message: string, ...args: any[]) => void
193: }
```

## File: libs/logger/src/handler.ts
```typescript
  1: // utils/error-handler.ts
  2: import { createLogger } from './logger'
  3: import { getEnvironment } from './environment'
  4: import {
  5:   ErrorType,
  6:   ErrorSeverity,
  7:   AppError,
  8:   mapErrorType,
  9:   mapErrorSeverity,
 10:   retryableStatusCodes,
 11:   type ErrorHandlerOptions,
 12:   type FetchErrorResponse,
 13: } from './error-interface'
 14: 
 15: export class ErrorHandler {
 16:   private logger
 17:   private env = getEnvironment()
 18: 
 19:   constructor(private context = 'ErrorHandler') {
 20:     this.logger = createLogger(context)
 21:   }
 22: 
 23:   private determineErrorType(error: any): ErrorType {
 24:     if (error instanceof AppError) return error.details.type
 25:     return mapErrorType(error)
 26:   }
 27: 
 28:   private determineSeverity(error: any): ErrorSeverity {
 29:     if (error instanceof AppError) return error.details.severity
 30:     return mapErrorSeverity(error)
 31:   }
 32: 
 33:   private formatErrorMessage(options: {
 34:     userMessage?: string
 35:     devMessage: string
 36:     error: any
 37:   }): string {
 38:     const { userMessage, devMessage, error } = options
 39:     const devError = `${devMessage}: ${JSON.stringify(error)}`
 40:     this.logger.error(devError)
 41:     return this.env.isDev ? devError : userMessage || 'An unexpected error occurred'
 42:   }
 43: 
 44:   private normalizeError(error: Error | AppError, context?: string): AppError {
 45:     if (error instanceof AppError) {
 46:       return error
 47:     }
 48: 
 49:     const errorType = this.determineErrorType(error)
 50:     const severity = this.determineSeverity(error)
 51: 
 52:     return new AppError({
 53:       type: errorType,
 54:       message: error.message,
 55:       severity,
 56:       stack: error.stack,
 57:       context,
 58:       code: (error as any).code,
 59:       pgError: (error as any).details || (error as any).hint,
 60:       operation: context,
 61:       originalError: error,
 62:     })
 63:   }
 64: 
 65:   private getErrorStatusCode(errorType: ErrorType): number {
 66:     switch (errorType) {
 67:       case ErrorType.AUTHENTICATION_ERROR:
 68:         return 401
 69:       case ErrorType.VALIDATION_ERROR:
 70:         return 400
 71:       case ErrorType.NOT_FOUND_ERROR:
 72:         return 404
 73:       case ErrorType.RATE_LIMIT_ERROR:
 74:         return 429
 75:       case ErrorType.CONSTRAINT_ERROR:
 76:       case ErrorType.UNIQUE_VIOLATION:
 77:       case ErrorType.FOREIGN_KEY_VIOLATION:
 78:         return 409
 79:       default:
 80:         return 500
 81:     }
 82:   }
 83: 
 84:   handleError(error: Error | AppError, options: ErrorHandlerOptions = {}) {
 85:     const appError = this.normalizeError(error, options.context)
 86: 
 87:     this.logger.error(`${appError.details.type}: ${appError.message}`, {
 88:       ...appError.details,
 89:       stack: this.env.isDev ? appError.stack : undefined,
 90:     })
 91: 
 92:     // Handle server-side errors
 93:     if (this.env.isNode) {
 94:       const errorMessage = this.formatErrorMessage({
 95:         userMessage: options.userMessage || appError.message,
 96:         devMessage: options.devMessage || appError.details.type,
 97:         error: appError,
 98:       })
 99: 
100:       if (options.throwError) {
101:         const serverError = new Error()
102:         serverError.message = `SERVER ERROR: ${errorMessage}`
103:         ;(serverError as any).statusCode = this.getErrorStatusCode(appError.details.type)
104:         ;(serverError as any).statusMessage = appError.message
105:         ;(serverError as any).data = {
106:           error: {
107:             type: appError.details.type,
108:             message: appError.message,
109:             severity: appError.details.severity,
110:             details: this.env.isDev ? appError.details : undefined,
111:           },
112:         }
113:         throw serverError
114:       }
115:     }
116: 
117:     // Handle critical errors
118:     if (appError.details.severity === ErrorSeverity.CRITICAL) {
119:       // Add critical error handling logic
120:       this.handleCriticalError(appError)
121:     }
122: 
123:     return appError
124:   }
125: 
126:   handleFetchError({
127:     response,
128:     devMessage,
129:     userMessage,
130:   }: {
131:     response: FetchErrorResponse
132:     devMessage: string
133:     userMessage?: string
134:   }) {
135:     if (response.error) {
136:       this.logger.error(`FETCH Error: ${response.error}`)
137:       return this.handleError(response.error, { userMessage, devMessage })
138:     }
139: 
140:     if (response.data) {
141:       this.logger.info(
142:         `Successfully fetched ${Array.isArray(response.data) ? response.data.length : 1} items`,
143:       )
144:       return response.data
145:     }
146: 
147:     this.logger.info('Nothing returned from fetch')
148:     return this.handleError(new Error('No data found'), {
149:       userMessage: 'Resource not found',
150:       devMessage: 'Fetch returned empty response',
151:     })
152:   }
153: 
154:   handleDBError(response: FetchErrorResponse, context: string) {
155:     if (response.error) {
156:       return this.handleError(response.error, {
157:         context,
158:         devMessage: `Database error in ${context}`,
159:         userMessage: 'Database operation failed',
160:       })
161:     }
162:     return response.data
163:   }
164: 
165:   private handleCriticalError(error: AppError) {
166:     // Implement critical error handling
167:     this.logger.error('CRITICAL ERROR:', error.details)
168:     // Could trigger alerts, notifications, etc.
169:   }
170: }
171: 
172: // Factory function
173: export function createErrorHandler(context = 'ErrorHandler') {
174:   const handler = new ErrorHandler(context)
175: 
176:   return {
177:     handleError: handler.handleError.bind(handler),
178:     handleFetchError: handler.handleFetchError.bind(handler),
179:     handleDBError: handler.handleDBError.bind(handler),
180:   }
181: }
182: 
183: // Convenience function for framework integration
184: export const useErrorHandler = (context = 'ErrorHandler') => {
185:   return createErrorHandler(context)
186: }
```

## File: libs/logger/src/logger.ts
```typescript
  1: // utils/logger.ts
  2: import { createConsola } from 'consola'
  3: import type { ConsolaInstance } from 'consola'
  4: import type { Logger, LogLevels } from './error-interface'
  5: import { getEnvironment } from './environment'
  6: 
  7: export class BaseLogger implements Logger {
  8:   protected logger: ConsolaInstance | Logger
  9:   protected env = getEnvironment()
 10: 
 11:   constructor(tag = '') {
 12:     this.logger = createConsola({
 13:       level: this.env.isDev ? 10 : 3,
 14:       formatOptions: {
 15:         date: this.env.isNode,
 16:         colors: true,
 17:       },
 18:     }).withTag(tag.toUpperCase())
 19:   }
 20: 
 21:   error(message: string, ...args: any[]) {
 22:     this.logger.error(message, ...args)
 23:   }
 24: 
 25:   warn(message: string, ...args: any[]) {
 26:     this.logger.warn(message, ...args)
 27:   }
 28: 
 29:   info(message: string, ...args: any[]) {
 30:     this.logger.info(message, ...args)
 31:   }
 32: 
 33:   verbose(message: string, ...args: any[]) {
 34:     if (this.env.isDev) {
 35:       this.logger.verbose(message, ...args)
 36:     }
 37:   }
 38: 
 39:   debug(message: string, ...args: any[]) {
 40:     if (this.env.isDev) {
 41:       this.logger.debug(message, ...args)
 42:     }
 43:   }
 44: 
 45:   silly(message: string, ...args: any[]) {
 46:     if (this.env.isDev) {
 47:       this.logger.info(message, ...args)
 48:     }
 49:   }
 50: 
 51:   http(message: string, ...args: any[]) {
 52:     this.logger.info(message, ...args)
 53:   }
 54: }
 55: 
 56: let winstonPackage: typeof import('winston') | undefined = undefined
 57: 
 58: export class NodeLogger extends BaseLogger {
 59:   private winstonLogger: any
 60: 
 61:   constructor(tag = '') {
 62:     super(tag)
 63: 
 64:     if (this.env.isNode) {
 65:       this.initWinston(tag).catch((err) => {
 66:         this.logger.error('Failed to initialize Winston:', err)
 67:       })
 68:     }
 69:   }
 70: 
 71:   private async initWinston(tag: string) {
 72:     try {
 73:       if (!winstonPackage) {
 74:         winstonPackage = await import('winston')
 75:       }
 76: 
 77:       const format = winstonPackage.format.combine(
 78:         winstonPackage.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss:ms' }),
 79:         winstonPackage.format.cli(),
 80:         winstonPackage.format.printf(
 81:           (info) => `${info['timestamp']} ${info.level}: [${tag}] ${info.message}`,
 82:         ),
 83:       )
 84: 
 85:       this.winstonLogger = winstonPackage.createLogger({
 86:         levels: {
 87:           error: 0,
 88:           warn: 1,
 89:           info: 2,
 90:           http: 3,
 91:           verbose: 4,
 92:           debug: 5,
 93:           silly: 6,
 94:         },
 95:         level: this.env.isDev ? 'silly' : 'info',
 96:         format,
 97:         transports: [
 98:           new winstonPackage.transports.Console(),
 99:           ...(this.env.isDev
100:             ? []
101:             : [
102:                 new winstonPackage.transports.File({
103:                   filename: './data/logs/error.log',
104:                   level: 'error',
105:                 }),
106:                 new winstonPackage.transports.File({
107:                   filename: './data/logs/combined.log',
108:                 }),
109:               ]),
110:         ],
111:       })
112:     } catch (err) {
113:       this.logger.warn('Winston not available, falling back to console logger')
114:     }
115:   }
116: 
117:   override error(message: string, ...args: any[]) {
118:     if (this.winstonLogger) {
119:       this.winstonLogger.error(message, ...args)
120:     } else {
121:       super.error(message, ...args)
122:     }
123:   }
124: 
125:   override warn(message: string, ...args: any[]) {
126:     if (this.winstonLogger) {
127:       this.winstonLogger.warn(message, ...args)
128:     } else {
129:       super.warn(message, ...args)
130:     }
131:   }
132: 
133:   override info(message: string, ...args: any[]) {
134:     if (this.winstonLogger) {
135:       this.winstonLogger.info(message, ...args)
136:     } else {
137:       super.info(message, ...args)
138:     }
139:   }
140: 
141:   override verbose(message: string, ...args: any[]) {
142:     if (this.winstonLogger && this.env.isDev) {
143:       this.winstonLogger.verbose(message, ...args)
144:     } else {
145:       super.verbose(message, ...args)
146:     }
147:   }
148: 
149:   override debug(message: string, ...args: any[]) {
150:     if (this.winstonLogger && this.env.isDev) {
151:       this.winstonLogger.debug(message, ...args)
152:     } else {
153:       super.debug(message, ...args)
154:     }
155:   }
156: 
157:   override silly(message: string, ...args: any[]) {
158:     if (this.winstonLogger && this.env.isDev) {
159:       this.winstonLogger.silly(message, ...args)
160:     } else {
161:       super.silly(message, ...args)
162:     }
163:   }
164: 
165:   override http(message: string, ...args: any[]) {
166:     if (this.winstonLogger) {
167:       this.winstonLogger.http(message, ...args)
168:     } else {
169:       super.http(message, ...args)
170:     }
171:   }
172: }
173: 
174: // Factory function to create the appropriate logger
175: export const createLogger = (tag = '') => {
176:   const env = getEnvironment()
177:   return env.isNode ? new NodeLogger(tag) : new BaseLogger(tag)
178: }
179: 
180: // Async version for when we want to ensure Winston is loaded
181: export const createLoggerAsync = async (tag = '') => {
182:   const logger = createLogger(tag)
183:   if (logger instanceof NodeLogger) {
184:     // Wait for Winston to initialize if needed
185:     await new Promise((resolve) => setTimeout(resolve, 100))
186:   }
187:   return logger
188: }
189: 
190: // Framework-specific wrappers if needed
191: export const useLogger = (tag = '') => {
192:   return createLogger(tag)
193: }
194: 
195: export const useLoggerAsync = async (tag = '') => {
196:   return await createLoggerAsync(tag)
197: }
```

## File: libs/logger/index.d.ts
```typescript
1: import type { Consola } from 'consola'
2: 
3: export * from './src/environment.d'
4: 
5: export function useLogger(tag?: string): Consola
```

## File: libs/logger/index.ts
```typescript
1: export * from './src/logger'
2: export * from './src/handler'
3: export * from './src/error-interface'
```

## File: shared-runtime.config.ts
```typescript
 1: import { config } from 'dotenv'
 2: 
 3: config()
 4: 
 5: export default defineNuxtConfig({
 6:   runtimeConfig: {
 7:     public: {
 8:       strapiUrl: process.env.NUXT_PUBLIC_STRAPI_URL,
 9:       formbricksEnvironment: process.env.NUXT_PUBLIC_FORMBRICKS_ENVIRONMENT,
10:       formbricksHost: process.env.NUXT_PUBLIC_FORMBRICKS_HOST,
11:       supabaseUrl: process.env.NUXT_PUBLIC_SUPABASE_URL,
12:       supabaseKey: process.env.NUXT_PUBLIC_SUPABASE_KEY,
13:       aeAuthUrl: process.env.NUXT_PUBLIC_AE_AUTH_URL,
14:       aeLoginUrl: process.env.NUXT_PUBLIC_AE_LOGIN_URL,
15:       aeAppUrl: process.env.NUXT_PUBLIC_AE_APP_URL,
16:       aeAdminUrl: process.env.NUXT_PUBLIC_AE_ADMIN_URL,
17:       aeMonitoringUrl: process.env.NUXT_PUBLIC_AE_MONITORING_URL,
18:       aeWebsiteUrl: process.env.NUXT_PUBLIC_AE_WEBSITE_URL,
19:       nodeEnv: process.env.NUXT_PUBLIC_NODE_ENV,
20:       logLevel: process.env.NUXT_PUBLIC_LOG_LEVEL,
21:       posthogKey: process.env.NUXT_PUBLIC_POSTHOG_KEY,
22:       posthogUrl: process.env.NUXT_PUBLIC_POSTHOG_URL,
23:       studioTokens: process.env.NUXT_PUBLIC_STUDIO_TOKENS,
24:       scraperUrl: process.env.NUXT_PUBLIC_SCRAPER_URL,
25:       devHelper: {
26:         enabled: true,
27:         features: {
28:           networkErrorClassifier: true,
29:           infiniteLoopDetector: true,
30:           unhandledPromiseRejectionTracker: true,
31:           environmentConsistencyChecker: true,
32:         },
33:       },
34:     },
35:     strapiUrl: process.env.NUXT_STRAPI_URL,
36:     supabaseServiceKey: process.env.NUXT_SUPABASE_SERVICE_KEY,
37:     googleApiKey: process.env.NUXT_GOOGLE_API_KEY,
38:     nasaApiKey: process.env.NUXT_NASA_API_KEY,
39:     openaiApiKey: process.env.NUXT_OPENAI_API_KEY,
40:     openaiOrg: process.env.NUXT_OPENAI_ORG,
41:     redisFlushKey: process.env.NUXT_REDIS_FLUSH_KEY,
42:     scraperKey: process.env.NUXT_SCRAPER_KEY,
43:     razorpayKey: process.env.NUXT_RAZORPAY_KEY,
44:     razorpaySecret: process.env.NUXT_RAZORPAY_SECRET,
45:     razorpayTestKey: process.env.NUXT_RAZORPAY_TEST_KEY,
46:     razorpayTestSecret: process.env.NUXT_RAZORPAY_TEST_SECRET,
47:   },
48: })
```
