This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-26T06:08:14.407Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
apps/
  admin-dashboard/
    server/
      api/
        classifier/
          [action].ts
        create/
          many-public-users.post.ts
          roles.post.ts
        error/
          [type].ts
        feature/
          [action].ts
        social/
          instagram/
            analytics.ts
          linkedin/
            analytics.ts
          twitter/
            analytics.ts
          youtube/
            analytics.ts
            channel-videos.ts
        tables/
          structure.ts
        update/
          user-profile.post.ts
        users/
          bulk-upload.ts
          update.ts
        _ws.ts
        cron-jobs.post.ts
        error-logs.get.ts
        execute-script.ts
        goals.ts
        healthy.ts
        milestones.ts
        server-jobs.ts
        store-image.ts
  auth-service/
    server/
      routes/
        cookies.get.ts
        session.ts
        signin.post.ts
        validate-turnstile.post.ts
  main-app/
    components/
      bookmark/
        BookmarkCard.vue
        BookmarkGridAnimated.vue
        BookmarkViewFolder.vue
      folder/
        FolderItem.vue
        FolderTree.vue
      news/
        NewsCard.vue
      EmptyState.vue
    composables/
      useBookmarkManager.ts
      useBookmarkStore.ts
      useBookmarkView.ts
      useFolderStore.ts
      usePages.ts
    pages/
      profile/
        bookmarks.vue
    server/
      api/
        ai/
          ask.ts
        bookmarks/
          [id].delete.ts
          counts.ts
          index.ts
          move.patch.ts
          toggle.ts
        dev/
          update-role.ts
        feature/
          [action].ts
        feedback/
          index.post.ts
        feeds/
          index.ts
        folders/
          [id].delete.ts
          [id].patch.ts
          index.ts
        payment/
          [provider]/
            create-order.ts
            subscription.get.ts
            verify-payment.post.ts
        users/
          metrics/
            [action].ts
          metrics.ts
          update.post.ts
        votes/
          [contentType]/
            [id].get.ts
            [id].post.ts
          user/
            [voteType].get.ts
          user.get.ts
        webhook/
          database.ts
        upload.ts
      middleware/
        feature-limit.ts
    shared/
      constants.ts
    app.vue
    nuxt.config.ts
  monitoring-dashboard/
    server/
      api/
        logs.get.ts
  website/
    components/
      landing/
        LandingFeatures.vue
    composables/
      usePages.ts

================================================================
Repository Files
================================================================

================
File: apps/admin-dashboard/server/api/classifier/[action].ts
================
import { defineEventHandler, getRouterParam, createError } from 'h3'
import jwt from 'jsonwebtoken'

export default defineEventHandler(async (event) => {
  const config = useRuntimeConfig()
  const action = getRouterParam(event, 'action')
  console.log('Classifier action:', action)

  let url: string
  let label: string
  let id: string

  if (action !== 'select') {
    const body = await readBody(event)
    url = body.url
    label = body.label
    id = body.id
  }

  if (!action) {
    throw createError({
      statusCode: 400,
      statusMessage: 'Action is required',
    })
  }

  try {
    const token = jwt.sign({ sender: 'AstronEra' }, config.scraperKey, {
      algorithm: 'HS256',
    })

    if (action === 'insert') {
      const response = await $fetch(`${config.public.scraperUrl}/api/classifier/urls`, {
        method: 'POST',
        headers: {
          Authorization: `Bearer ${token}`,
        },
        body: JSON.stringify({ url, label }),
      })

      return {
        data: response,
      }
    } else if (action === 'delete') {
      const response = await $fetch(`${config.public.scraperUrl}/api/classifier/urls/${id}`, {
        method: 'DELETE',
        headers: {
          Authorization: `Bearer ${token}`,
        },
      })

      return {
        data: response,
      }
    } else if (action === 'select') {
      const response = await $fetch(`${config.public.scraperUrl}/api/classifier/urls`, {
        method: 'GET',
        headers: {
          Authorization: `Bearer ${token}`,
        },
      })

      return {
        data: response,
      }
    }

    throw createError({
      statusCode: 400,
      statusMessage: 'Invalid action',
    })
  } catch (error: any) {
    console.error(`Error in classifier ${action}:`, error)

    throw createError({
      statusCode: 500,
      statusMessage: 'Internal Server Error',
    })
  }
})

================
File: apps/admin-dashboard/server/api/create/many-public-users.post.ts
================
export default defineEventHandler(async (event) => {
  const users = await readBody(event)
  const client = dbClient(event)
  let message
  let status

  // Function to insert users from JSON file
  if (users.length > 0) {
    const mappedUsers = users.map((user) => {
      if (user.dob !== null) {
        user.dob = new Date(user.dob).toISOString()
      }
      user.created_at = new Date().toISOString()
      user.updated_at = new Date().toISOString()
      user.last_seen = new Date().toISOString()
      return {
        ...user,
      }
    })

    const { data, error } = await client
      .from('user_profiles')
      .createMany({ data: [...mappedUsers] })
      .select('*')

    status = 200
    message = 'Users have been inserted successfully'
  } else {
    console.error('no users to add')
    status = 200
    message = 'no users to add'
  }

  return {
    status,
    message,
  }
})

================
File: apps/admin-dashboard/server/api/create/roles.post.ts
================
import type { Role } from '@/types/roles'

export default defineEventHandler(async (event) => {
  const client = dbClient(event)

  const { roles }: { roles: Role[] } = await readBody(event)
  // const env = useRuntimeConfig().public

  // Function to insert users from JSON file
  // !TODO: use transforms from types foler to handle date/string conversion
  if (roles.length > 0) {
    const mappedRoles = roles.map((role) => {
      role.created_at = new Date(role.created_at).toISOString()
      return {
        ...role,
      }
    })

    await client.roles.createMany({ data: [...mappedRoles] })
  }

  return {
    status: 200,
    message: 'Users have been inserted successfully',
  }
})

================
File: apps/admin-dashboard/server/api/error/[type].ts
================
import { defineEventHandler, getQuery } from 'h3'
import { serverSupabaseClient } from '#supabase/server'

interface ErrorMetric {
  time_bucket: string
  service_name: string
  error_type: string
  severity: string
  error_count: number
}

interface ErrorPattern {
  error_hash: string
  error_pattern: string
  service_name: string
  occurrence_count: number
  first_seen: string
  last_seen: string
  severity_levels: string[]
  contexts: Record<string, any>[]
  days_active: number
  daily_frequency: number
  is_new: boolean
}

interface ErrorCorrelation {
  source_service: string
  source_pattern: string
  target_service: string
  target_pattern: string
  correlation_count: number
  avg_time_difference: number
}

export default defineEventHandler(async (event) => {
  const query = getQuery(event)
  const type = event.context.params?.type

  console.log(`Processing ${type} request with query:`, query)

  const supabase = await serverSupabaseClient(event)

  try {
    switch (type) {
      case 'report': {
        const date = query.date ? new Date(query.date as string) : new Date()
        const startOfDay = new Date(date)
        startOfDay.setHours(0, 0, 0, 0)
        const endOfDay = new Date(date)
        endOfDay.setHours(23, 59, 59, 999)

        console.log('Fetching metrics for date range:', { startOfDay, endOfDay })

        // Get time-based error metrics
        const metricsResponse = await supabase
          .from('error_metrics')
          .select('*')
          .gte('time_bucket', startOfDay.toISOString())
          .lte('time_bucket', endOfDay.toISOString())
          .order('time_bucket', { ascending: false })

        console.log('Metrics query response:', metricsResponse)

        // Get error patterns
        const patternsResponse = await supabase
          .from('error_patterns')
          .select('*')
          .order('occurrence_count', { ascending: false })
          .limit(10)

        console.log('Patterns query response:', patternsResponse)

        // Get error correlations
        const correlationsResponse = await supabase
          .from('error_correlations')
          .select('*')
          .order('correlation_count', { ascending: false })
          .limit(10)

        console.log('Correlations query response:', correlationsResponse)

        const { data: metrics } = metricsResponse
        const { data: patterns } = patternsResponse
        const { data: correlations } = correlationsResponse

        // Calculate time-based metrics
        const timeSeriesData = (metrics || []).reduce((acc: Record<string, number[]>, m) => {
          const hour = new Date(m.time_bucket).getHours()
          acc.hours = acc.hours || Array(24).fill(0)
          acc.hours[hour] += m.error_count
          return acc
        }, {})

        // Calculate severity distribution
        const severityDistribution = (metrics || []).reduce((acc: Record<string, number>, m) => {
          acc[m.severity] = (acc[m.severity] || 0) + m.error_count
          return acc
        }, {})

        // Calculate service distribution
        const serviceDistribution = (metrics || []).reduce((acc: Record<string, number>, m) => {
          acc[m.service_name] = (acc[m.service_name] || 0) + m.error_count
          return acc
        }, {})

        // Calculate error type distribution
        const errorTypeDistribution = (metrics || []).reduce((acc: Record<string, number>, m) => {
          acc[m.error_type] = (acc[m.error_type] || 0) + m.error_count
          return acc
        }, {})

        // Get new pattern count
        const newPatternsCount = (patterns || []).filter((p) => p.is_new).length

        return {
          data: {
            overview: {
              totalErrors: metrics?.reduce((sum, m) => sum + m.error_count, 0) || 0,
              newPatterns: newPatternsCount,
              activeServices: Object.keys(serviceDistribution).length,
              criticalErrors: severityDistribution['critical'] || 0,
            },
            distributions: {
              severity: severityDistribution,
              service: serviceDistribution,
              errorType: errorTypeDistribution,
            },
            trends: {
              hourly: timeSeriesData.hours,
              topPatterns: patterns?.map((p) => ({
                pattern: p.error_pattern,
                service: p.service_name,
                count: p.occurrence_count,
                dailyFrequency: p.daily_frequency,
                isNew: p.is_new,
              })),
              correlations: correlations?.map((c) => ({
                source: `${c.source_service}: ${c.source_pattern}`,
                target: `${c.target_service}: ${c.target_pattern}`,
                count: c.correlation_count,
                avgTimeDiff: c.avg_time_difference,
              })),
            },
          },
        }
      }

      case 'logs': {
        const page = parseInt(query.page as string) || 1
        const pageSize = parseInt(query.pageSize as string) || 50
        const severity = query.severity as string
        const service = query.service as string
        const from = query.from
          ? new Date(query.from as string)
          : new Date(Date.now() - 7 * 24 * 60 * 60 * 1000)
        const to = query.to ? new Date(query.to as string) : new Date()

        console.log('Fetching logs with params:', {
          page,
          pageSize,
          severity,
          service,
          from,
          to,
        })

        let queryBuilder = supabase
          .from('error_logs')
          .select('*', { count: 'exact' })
          .gte('created_at', from.toISOString())
          .lte('created_at', to.toISOString())
          .order('created_at', { ascending: false })

        if (severity) {
          queryBuilder = queryBuilder.eq('severity', severity)
        }
        if (service) {
          queryBuilder = queryBuilder.eq('service_name', service)
        }

        const response = await queryBuilder.range((page - 1) * pageSize, page * pageSize - 1)
        console.log('Logs query response:', response)

        return {
          data: {
            logs: response.data || [],
            total: response.count || 0,
            totalPages: Math.ceil((response.count || 0) / pageSize),
            currentPage: page,
          },
        }
      }

      default:
        throw new Error(`Unknown error type: ${type}`)
    }
  } catch (error: any) {
    console.error(`Error fetching ${type} data:`, error)
    throw createError({
      statusCode: error.status || 500,
      statusMessage: error.message || `Error fetching ${type} data`,
    })
  }
})

================
File: apps/admin-dashboard/server/api/feature/[action].ts
================
// server/api/admin/features/[action].ts
import { serverSupabaseClient, serverSupabaseUser } from '#supabase/server'

export default defineEventHandler(async (event) => {
  const client = await serverSupabaseClient(event)
  const user = await serverSupabaseUser(event)
  const action = event.context.params?.action

  if (!user) {
    throw createError({
      statusCode: 401,
      message: 'Unauthorized',
    })
  }

  // Check if user is admin
  const { data: profile } = await client
    .from('user_profiles')
    .select('role')
    .eq('id', user.id)
    .single()

  if (profile?.role !== 'admin') {
    throw createError({
      statusCode: 403,
      message: 'Forbidden',
    })
  }

  try {
    switch (action) {
      case 'list': {
        const { data: features, error: listError } = await client
          .from('feature_requests')
          .select('*')
          .order('priority')

        if (listError) throw listError
        return features
      }

      case 'create': {
        const createBody = await readBody(event)
        const { data: newFeature, error: createError } = await client
          .from('feature_requests')
          .insert([createBody])
          .select()
          .single()

        if (createError) throw createError
        return newFeature
      }

      case 'update': {
        const updateBody = await readBody(event)
        const { id, ...updateData } = updateBody
        const { data: updatedFeature, error: updateError } = await client
          .from('feature_requests')
          .update(updateData)
          .eq('id', id)
          .select()
          .single()

        if (updateError) throw updateError
        return updatedFeature
      }

      case 'delete': {
        const deleteBody = await readBody(event)
        const { error: deleteError } = await client
          .from('feature_requests')
          .delete()
          .eq('id', deleteBody.id)

        if (deleteError) throw deleteError
        return { success: true }
      }

      default:
        throw createError({
          statusCode: 400,
          message: 'Invalid action',
        })
    }
  } catch (error: any) {
    console.error(`Admin features API error (${action}):`, error)
    throw createError({
      statusCode: 500,
      message: 'Failed to process request',
    })
  }
})

================
File: apps/admin-dashboard/server/api/social/instagram/analytics.ts
================
import { defineEventHandler, getQuery } from 'h3'

import { useInstagramAnalytics } from '#imports'

const PREFIX = 'social/instagram/insights'

export default defineEventHandler(async (event) => {
  const logger = useServerLogger(PREFIX)

  const { userId } = getQuery(event) as { userId: string }

  log.info(`userId: ${userId}`)

  try {
    const instagram = useInstagramAnalytics()
    const businessAnalytics = await instagram.fetchBusinessAnalytics(userId)

    log.info(businessAnalytics)

    return {
      status: 200,
      message: 'Profile businessAnalytics returned from Instagram',
      data: businessAnalytics,
    }
  } catch (error: any) {
    logger.error({
      error,
      devMessage: 'Error fetching Instagram insights',
      userMessage: 'Error fetching Instagram insights',
    })
  }
})

================
File: apps/admin-dashboard/server/api/social/linkedin/analytics.ts
================
import { useLinkedinAnalytics } from '#imports'

const PREFIX = 'social/linkedin/analytics'

export default defineEventHandler(async (event) => {
  const logger = useServerLogger(PREFIX)

  const { postId } = getQuery(event) as { postId: string }

  log.info(`postId: ${postId}`)

  try {
    const linkedin = useLinkedinAnalytics(postId)
    const postAnalytics = await linkedin.fetchPostAnalytics()
    log.info(postAnalytics)

    return {
      status: 200,
      message: 'Post analytics returned from LinkedIn',
      data: postAnalytics,
    }
  } catch (error: any) {
    logger.error('Error fetching LinkedIn analytics', {
      error,
      userMessage: 'Error fetching LinkedIn analytics',
    })
  }
})

================
File: apps/admin-dashboard/server/api/social/twitter/analytics.ts
================
import { defineEventHandler, getQuery } from 'h3'

import { useTwitterAnalytics } from '#imports'

const PREFIX = 'social/twitter/analytics'

export default defineEventHandler(async (event) => {
  const logger = useServerLogger(PREFIX)

  const { postId } = getQuery(event) as { postId: string }

  log.info(`postId: ${postId}`)

  try {
    const twitter = useTwitterAnalytics(postId)
    const userAnalytics = await twitter.fetchUserProfile()
    log.info(userAnalytics)

    return {
      status: 200,
      message: 'Post analytics returned from Twitter',
      data: userAnalytics,
    }
  } catch (error: any) {
    logger.error({
      error,
      devMessage: 'Error fetching Twitter analytics',
      userMessage: 'Error fetching Twitter analytics',
    })
  }
})

================
File: apps/admin-dashboard/server/api/social/youtube/analytics.ts
================
import { useYoutubeChannel } from '#imports'

const PREFIX = 'social/youtube/analytics'

export default defineEventHandler(async (event) => {
  const logger = useServerLogger(PREFIX)

  const { channelName } = getQuery(event) as { channelName: string }

  logger.info(`Fetching YouTube analytics for channel: ${channelName}`)

  try {
    const youtube = useYoutubeChannel(channelName)

    const channelStatistics = await youtube.fetchChannelStatistics()
    logger.info('Channel statistics fetched', { data: channelStatistics })

    const videoItems = await youtube.fetchChannelVideos()
    logger.info('Channel videos fetched', { count: videoItems.length })

    const videoStatsPromises = videoItems.map(async (video: any) => {
      const stats = await youtube.fetchVideoStatistics(video.id.videoId)
      logger.info('Video statistics fetched', {
        videoId: video.id.videoId,
        stats,
      })
      return { ...video, statistics: stats }
    })

    const videos = await Promise.all(videoStatsPromises)

    logger.info('Successfully processed all videos', {
      channelName,
      videoCount: videos.length,
    })

    return {
      status: 200,
      message: 'Videos returned from youtube',
      data: {
        channelStatistics,
        videos,
      },
    }
  } catch (error: any) {
    // The centralized logger will automatically handle storing the error
    logger.error('Failed to fetch YouTube analytics', {
      type: 'API_ERROR',
      context: {
        channelName,
        action: 'fetchYoutubeAnalytics',
        component: 'YouTubeService',
      },
      error: {
        message: error.message,
        stack: error.stack,
        code: error.code,
      },
    })

    // Still throw an appropriate error for the API response
    throw createError({
      statusCode: error.status || 500,
      statusMessage: 'Failed to fetch YouTube analytics',
      message: 'An error occurred while fetching YouTube analytics',
    })
  }
})

================
File: apps/admin-dashboard/server/api/social/youtube/channel-videos.ts
================
export default defineEventHandler(async (event) => {
  const { channelName } = getQuery(event)

  console.log('channelName', channelName)

  try {
    const videos = await getYoutubeContent(String(channelName))

    console.log('returnedData', videos)
    return {
      status: 200,
      message: 'Videos returned from youtube',
      data: videos,
    }
  } catch (error: any) {
    console.error('social/youtube error', error.message)
    return {
      status: 500,
      message: 'Error retrieving videos',
      data: null,
      error,
    }
  }
})

================
File: apps/admin-dashboard/server/api/tables/structure.ts
================
// server/api/tables/structure.ts
import { serverSupabaseClient } from '#supabase/server'

export default defineEventHandler(async (event) => {
  const client = await serverSupabaseClient(event)
  const { table_name } = getQuery(event)

  const { data, error } = await client.rpc('get_table_structure', {
    table_name,
  })

  if (error) {
    throw createError({
      statusCode: 500,
      message: error.message,
    })
  }

  return data
})

================
File: apps/admin-dashboard/server/api/update/user-profile.post.ts
================
export default defineEventHandler(async (event) => {
  const { userId, profile }: { userId: string; profile: any } = await readBody(event)
  const client = await dbClient(event)

  // Function to insert users from JSON file
  try {
    if (profile.dob) {
      console.log('profile.dob:', profile.dob)
      profile.dob = new Date(profile.dob).toISOString()
    }

    if (!profile) {
      return {
        status: 400,
        message: 'No user profile provided',
      }
    }

    console.log(`attempting to update ${profile.given_name} with id ${userId}`)
    const { data, error } = await client
      .from('user_profiles')
      .update(profile)
      .eq('email', profile.email)
      .select()

    if (error) {
      throw createError({ message: `error updating users: ${error.message}` })
    }

    console.log(`User ${data.email} updated successfully`)

    return {
      status: 200,
      message: 'Users have been inserted successfully',
      data,
    }
  } catch (error: any) {
    console.error(`Error updating user ${userId}:`, error)
    return {
      status: 500,
      message: 'Error updating user profile',
    }
  }
})

================
File: apps/admin-dashboard/server/api/users/bulk-upload.ts
================
import { readMultipartFormData, type MultiPartData } from 'h3'
import { serverSupabaseServiceRole } from '#supabase/server'

async function upload(path: string, file: MultiPartData) {
  const supabase = serverSupabaseServiceRole(useEvent())
  const { data, error } = await supabase.storage.from('profile-public').upload(path, file.data, {
    cacheControl: '3600',
    contentType: file.type,
    upsert: true,
  })
  console.log('uploadResponse', data, error)
}

export default defineEventHandler(async (event) => {
  console.log('upload eventHandler')
  const form = await readMultipartFormData(event)
  console.log('workingUpload', form)
  if (!form?.length) {
    return console.log('no form data')
  }

  console.log('file', form)

  // we would need to fetch all users based on the file name

  try {
    const userRepository = new UserRepository()
    const users = await userRepository.selectMany<'user_profiles'>({
      tableName: 'user_profiles',
      selectStatement: 'id, given_name, surname',
    })

    form.forEach(async (file) => {
      console.log('uploading file', file)
      const fileName = file.filename
      if (!fileName) {
        console.log('no filename found')
        return
      }
      const fullName = fileName.split('.')[0]
      const [given_name, surname] = fullName.split('-')
      console.log('searching for', given_name, surname)
      const userId = users.find((user) => {
        if (!user.given_name || !user.surname) {
          return false
        }
        return (
          user.given_name.toLowerCase() === given_name && user.surname.toLowerCase() === surname
        )
      })?.id

      if (!userId) {
        console.log('no user found for', given_name, surname)
        return
      }
      console.log('name and id', given_name, surname, userId)
      console.log('uploading file for', userId, fileName)
      const newFileName = `avatar_${userId}.jpg`
      await upload(`${userId}/avatar/${newFileName}`, file)
    })
  } catch (error: any) {
    console.log('upload error', error)
    throw createError({ statusMessage: error.message })
  }

  return {
    statusCode: 200,
    message: 'successfully uploaded files',
  }
})

================
File: apps/admin-dashboard/server/api/users/update.ts
================
export default defineEventHandler(async (event) => {
  console.log('update user endpoint fired')
  const { id, data } = await readBody(event)

  console.log('have body', data)

  try {
    return {
      error: null,
      data: [],
      status: 200,
      message: 'User fetched',
    }
  } catch (error: any) {
    console.error('update user error', error.message)
    return {
      error,
      data: null,
      status: 500,
      message: error.message,
    }
  }
})

================
File: apps/admin-dashboard/server/api/_ws.ts
================
export default defineWebSocketHandler({
  open(peer) {
    console.log('[ws] open', peer)
  },

  message(peer, message) {
    console.log('[ws] message', peer, message)
    if (message.text().includes('ping')) {
      peer.send('pong')
    }
  },

  close(peer, event) {
    console.log('[ws] close', peer, event)
  },

  error(peer, error) {
    console.log('[ws] error', peer, error)
  },
})

================
File: apps/admin-dashboard/server/api/cron-jobs.post.ts
================
import jwt from 'jsonwebtoken'

export default defineEventHandler(async (event) => {
  const body = await readBody(event)
  const { action } = body

  const scraperKey = useRuntimeConfig().scraperKey
  const token = jwt.sign({ sender: 'AstronEra' }, scraperKey, {
    algorithm: 'HS256',
  })

  const scraperBaseURL = useRuntimeConfig().public.scraperUrl

  let endpoint = ''
  switch (action) {
    case 'scrapeNewsLinks':
      endpoint = '/trigger/news_links'
      break
    case 'scrapeNewsArticles':
      endpoint = '/trigger/news_pages'
      break
    default:
      throw createError({
        statusCode: 400,
        statusMessage: 'Invalid action',
      })
  }

  try {
    const response = await $fetch(`${scraperBaseURL}${endpoint}`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json',
      },
    })

    return response
  } catch (error: any) {
    console.error(`Error in scraper request: ${error}`)
    throw createError({
      statusCode: 500,
      statusMessage: 'Error communicating with scraper',
    })
  }
})

================
File: apps/admin-dashboard/server/api/error-logs.get.ts
================
// server/api/error-logs.get.ts
import { serverSupabaseClient } from '#supabase/server'

export default defineEventHandler(async (event) => {
  const logger = useServerLogger('error-logs')
  const supabase = await serverSupabaseClient(event)

  return logger.handleQuery(async () => {
    const { from, to } = getQuery(useEvent())
    const query = supabase
      .from('error_logs')
      .select('*')
      .order('created_at', { ascending: false })
      .limit(50)

    // Only add date filters if they are defined
    if (from) {
      query.gte('created_at', from as string)
    }

    if (to) {
      query.lte('created_at', to as string)
    }

    return query
  })
})

================
File: apps/admin-dashboard/server/api/execute-script.ts
================
import { execFile } from 'child_process'
import { promisify } from 'util'
import path from 'path'
import fs from 'fs'

const execFileAsync = promisify(execFile)

type ScriptName = 'build-all' | 'db-setup' | 'generate-lazy-routes' | 'clean-packages'

const scriptConfigs = {
  'build-all': { type: 'sh', file: 'build-all.sh' },
  'db-setup': { type: 'ts', file: 'db-setup.ts' },
  'generate-lazy-routes': { type: 'ts', file: 'generate-lazy-routes.ts' },
  'clean-packages': { type: 'sh', file: 'clean-packages.sh' },
  // Add more scripts as needed
}

export default defineEventHandler(async (event) => {
  const { scriptName } = (await readBody(event)) as { scriptName: ScriptName }

  if (!scriptConfigs[scriptName]) {
    throw createError({
      statusCode: 400,
      statusMessage: 'Invalid script name',
    })
  }

  const { type, file } = scriptConfigs[scriptName]

  const baseDir = process.cwd()
  const scriptPath = path.join('/app', 'scripts', file)

  console.log(`Current working directory: ${process.cwd()}`)
  console.log(`Script path: ${scriptPath}`)
  console.log('Files in current directory:', fs.readdirSync(process.cwd()))
  console.log('Files in /app/scripts:', fs.readdirSync('/app/scripts'))
  console.log(`Current working directory: ${baseDir}`)
  console.log(`Attempting to execute script: ${scriptPath}`)

  // Check if the script file exists
  if (!fs.existsSync(scriptPath)) {
    console.error(`Script file not found: ${scriptPath}`)
    throw createError({
      statusCode: 500,
      statusMessage: 'Script file not found',
    })
  }

  try {
    let output
    if (type === 'sh') {
      const { stdout, stderr } = await execFileAsync('sh', [scriptPath], { cwd: baseDir })
      output = stdout + stderr
    } else if (type === 'ts') {
      const { stdout, stderr } = await execFileAsync('npx', ['tsx', scriptPath], { cwd: baseDir })
      output = stdout + stderr
    } else {
      throw new Error('Unsupported script type')
    }

    console.log(`Script execution completed: ${scriptName}`)
    return { output }
  } catch (error: any) {
    console.error(`Error executing script ${scriptName}:`, error)
    throw createError({
      statusCode: 500,
      statusMessage: 'Error executing script',
    })
  }
})

================
File: apps/admin-dashboard/server/api/goals.ts
================
import { promises as fs } from 'fs'
import { resolve } from 'path'
import { defineEventHandler, readBody } from 'h3'

const goalsFilePath = resolve(process.cwd(), 'data', 'tasks/goals.json')

export interface Goal {
  id: number
  title: string
  date: string
  category: 'financial' | 'metrics' | 'hiring' | 'events' | 'development' | 'milestone'
  assigneeId: number
  completed: boolean
  progress: number
  priority: 'low' | 'medium' | 'high'
  timeSpent: number
  description: string
  milestoneId?: number
  recurrence?: {
    frequency: 'daily' | 'weekly' | 'monthly' | 'yearly'
    interval: number
    endDate?: string
  }
}

export default defineEventHandler(async (event) => {
  const body = await readBody(event)
  const { action, goal } = body

  async function readGoals(): Promise<Goal[]> {
    try {
      const data = await fs.readFile(goalsFilePath, 'utf-8')
      return JSON.parse(data)
    } catch (error: any) {
      if (error.code === 'ENOENT') {
        return []
      }
      throw error
    }
  }

  async function writeGoals(goals: Goal[]): Promise<void> {
    await fs.writeFile(goalsFilePath, JSON.stringify(goals, null, 2), 'utf-8')
  }

  try {
    let goals = await readGoals()

    switch (action) {
      case 'read':
        return {
          success: true,
          goals: goals,
          totalCount: goals.length,
        }
      case 'create':
        goals.push(goal)
        await writeGoals(goals)
        break
      case 'update':
        const index = goals.findIndex((g) => g.id === goal.id)
        if (index !== -1) {
          goals[index] = { ...goals[index], ...goal }
          await writeGoals(goals)
        }
        break
      case 'delete':
        goals = goals.filter((g) => g.id !== goal.id)
        await writeGoals(goals)
        break
      default:
        throw new Error(`Invalid action: ${action}`)
    }

    return {
      success: true,
      message: action === 'read' ? 'Goals fetched successfully' : `Goal ${action}d successfully`,
    }
  } catch (error: any) {
    console.error('Error performing goal action:', error)
    return { success: false, message: `Failed to ${action} goal`, error: error.message }
  }
})

================
File: apps/admin-dashboard/server/api/healthy.ts
================
import { defineEventHandler } from 'h3'

export default defineEventHandler(async (event) => {
  const startTime = Date.now()
  const env = useRuntimeConfig().public
  const port = process.env.PORT

  try {
    // You can add more checks here, e.g., Redis connection, external API calls, etc.

    const uptime = process.uptime()
    const memoryUsage = process.memoryUsage()

    console.log('Health check successful', env)
    console.log('Process Port:', port)
    console.log('Nitro Port: ')

    return {
      status: 'healthy',
      timestamp: new Date().toISOString(),
      uptime: uptime,
      memory: {
        rss: memoryUsage.rss,
        heapTotal: memoryUsage.heapTotal,
        heapUsed: memoryUsage.heapUsed,
        external: memoryUsage.external,
      },
      environment: process.env.NODE_ENV,
      databaseConnection: 'ok',
      responseTime: Date.now() - startTime,
    }
  } catch (error: any) {
    console.error('Health check failed:', error)

    return {
      status: 'unhealthy',
      timestamp: new Date().toISOString(),
      error: error.message,
      responseTime: Date.now() - startTime,
    }
  }
})

================
File: apps/admin-dashboard/server/api/milestones.ts
================
import { promises as fs } from 'fs'
import { resolve } from 'path'
import { defineEventHandler, readBody } from 'h3'

const milestonesFilePath = resolve(process.cwd(), 'data', 'tasks', 'milestones.json')

export default defineEventHandler(async (event) => {
  const method = event.node.req.method

  if (method === 'GET') {
    try {
      const data = await fs.readFile(milestonesFilePath, 'utf-8')
      return JSON.parse(data)
    } catch (error: any) {
      console.error('Error reading milestones:', error)
      throw createError({
        statusCode: 500,
        statusMessage: 'Failed to read milestones',
      })
    }
  } else if (method === 'POST') {
    const body = await readBody(event)
    const { action, milestone } = body

    try {
      const data = await fs.readFile(milestonesFilePath, 'utf-8')
      let milestones = JSON.parse(data)

      switch (action) {
        case 'create':
          milestone.id = Math.max(...milestones.map((m: Milestone) => m.id)) + 1
          milestones.push(milestone)
          break
        case 'update':
          const index = milestones.findIndex((m: Milestone) => m.id === milestone.id)
          if (index !== -1) {
            milestones[index] = milestone
          }
          break
        case 'delete':
          milestones = milestones.filter((m: Milestone) => m.id !== milestone.id)
          break
        default:
          throw new Error(`Invalid action: ${action}`)
      }

      await fs.writeFile(milestonesFilePath, JSON.stringify(milestones, null, 2), 'utf-8')
      return { success: true, message: `Milestone ${action}d successfully` }
    } catch (error: any) {
      console.error(`Error ${action}ing milestone:`, error)
      throw createError({
        statusCode: 500,
        statusMessage: `Failed to ${action} milestone`,
      })
    }
  }
})

================
File: apps/admin-dashboard/server/api/server-jobs.ts
================
import { defineWebSocketHandler } from 'h3'
import { WebSocket } from 'ws'
import jwt from 'jsonwebtoken'

const clients = new Set()
let serverWs: WebSocket | null = null
let reconnectTimeout: NodeJS.Timeout | null = null
let reconnectAttempts = 0
const maxReconnectAttempts = 5
let reconnectInterval = 5000 // 5 seconds

let selectedMetrics: string[] = ['all']

const connectToAnalyticsServer = () => {
  if (reconnectAttempts >= maxReconnectAttempts) {
    console.log('Max reconnect attempts reached. Stopping reconnection attempts.')
    return
  }

  const scraperKey = useRuntimeConfig().scraperKey
  const token = jwt.sign({ sender: 'AstronEra' }, scraperKey, {
    algorithm: 'HS256',
  })

  const scraperBaseURL = useRuntimeConfig().public.scraperUrl
  const wsUrl = `${scraperBaseURL.replace(/^http/, 'ws')}/analytics`

  console.log(`Connecting to WebSocket URL: ${wsUrl}`)

  serverWs = new WebSocket(wsUrl, {
    headers: { Authorization: `Bearer ${token}` },
  })

  serverWs.on('open', () => {
    console.log('Connected to Analytics WebSocket server')
    reconnectAttempts = 0
    if (reconnectTimeout) {
      clearTimeout(reconnectTimeout)
      reconnectTimeout = null
    }
    // Send initial subscription with the selected metrics

    console.log('Subscribing to metrics:', selectedMetrics)
    serverWs.send(
      JSON.stringify({
        action: 'subscribe',
        metrics: selectedMetrics,
      }),
    )
  })

  serverWs.on('message', (data) => {
    // Broadcast the message to all connected Nuxt clients
    console.log('Received message from Analytics server:', data.toString())
    for (const client of clients) {
      client.send(data)
    }
  })

  serverWs.on('close', (code, reason) => {
    console.log(`Disconnected from Analytics WebSocket server: ${code} - ${reason}`)
    serverWs = null
    scheduleReconnect()
  })

  serverWs.on('error', (error: any) => {
    console.error('Error with Analytics WebSocket connection:', error)
    if (serverWs) {
      serverWs.close()
    }
  })
}

const scheduleReconnect = () => {
  if (reconnectAttempts < maxReconnectAttempts) {
    reconnectAttempts++
    console.log(
      `Scheduling reconnection attempt ${reconnectAttempts}/${maxReconnectAttempts} in ${reconnectInterval}ms`,
    )
    reconnectTimeout = setTimeout(() => {
      console.log(`Executing reconnection attempt ${reconnectAttempts}`)
      connectToAnalyticsServer()
    }, reconnectInterval)
  } else {
    console.log('Max reconnect attempts reached. Please check the server.')
  }
}

export default defineWebSocketHandler({
  async open(peer) {
    console.log('Nuxt client connected')
    clients.add(peer)

    if (!serverWs) {
      connectToAnalyticsServer()
    }
  },

  message(peer, message) {
    console.log('Received message from Nuxt client:', message)
    try {
      const parsedMessage = JSON.parse(message)
      selectedMetrics = parsedMessage.metrics
      console.log('Updated selectedMetrics:', selectedMetrics)

      if (serverWs && serverWs.readyState === WebSocket.OPEN) {
        console.log(
          'Forwarding message to Analytics server:',
          JSON.stringify({
            action: 'subscribe',
            subscribedMetrics: parsedMessage.metrics,
          }),
        )
        serverWs.send(
          JSON.stringify({
            action: 'subscribe',
            subscribedMetrics: parsedMessage.metrics,
          }),
        )
      } else {
        console.log(
          'Cannot forward message: serverWs not ready. Current state:',
          serverWs ? serverWs.readyState : 'null',
        )
      }
    } catch (error: any) {
      console.error('Error parsing or handling message:', error)
    }
  },

  close(peer) {
    console.log('Nuxt client disconnected')
    clients.delete(peer)

    if (clients.size === 0 && serverWs) {
      console.log('No more clients, closing server connection')
      serverWs.close()
      serverWs = null
      if (reconnectInterval) {
        clearInterval(reconnectInterval)
        reconnectInterval = null
      }
    }
  },

  error(peer, error) {
    console.error('Error with Nuxt client connection:', error)
    clients.delete(peer)
  },
})

================
File: apps/admin-dashboard/server/api/store-image.ts
================
export default defineEventHandler(async (event) => {
  try {
    console.log('store-image start')
    // !todo: I envision this endpoint being called, fetching all the image URLs that need to be stored
    // We would need to check if we have already stored the image, and if not, fetch and store it
    // When storing it would need to be stored in a folder using the news.id as the folder name
    // image name doesn't matter
    // then we would need to update the news.featured_image with the new URL

    // Fetch the image as a blob
    const imgBlob = await $fetch(
      'https://cdn.mos.cms.futurecdn.net/594rdNk4Ci9qT8e2XKsQ7Q-970-80.jpg.webp',
      { responseType: 'blob' },
    )

    console.log('Image fetched', imgBlob)

    // Get the Supabase client
    const supabase = await dbClient(event)

    // Upload the blob to Supabase Storage
    const { data, error } = await supabase.storage.from('posts').upload('public/test.webp', imgBlob)

    if (error) {
      throw createError({ message: `Error uploading image: ${error.message}` })
    }

    console.log('Image uploaded successfully')

    return {
      status: 200,
      message: 'Image Stored',
    }
  } catch (error: any) {
    console.error('store-image error', error.message)
    return {
      status: 500,
      message: 'Error Storing Image',
      error,
    }
  }
})

================
File: apps/auth-service/server/routes/cookies.get.ts
================
export default defineEventHandler((event) => {
  const cookies = getHeaders(event)
  console.log('All Headers:', cookies)

  // Or specifically cookies
  const allCookies = parseCookies(event)
  console.log('Parsed Cookies:', allCookies)

  return { cookies: allCookies }
})

================
File: apps/auth-service/server/routes/session.ts
================
export default defineEventHandler(async (event) => {
  try {
    console.log('FETCHING USER SESSION ON SERVER')
    const session = await validateAndUpdateSession()

    if (!session) {
      console.log('No user user session found')
      return {
        error: null,
        status: 200,
        message: 'No user session found',
        data: null,
      }
    }

    return {
      error: null,
      status: 200,
      message: 'User session fetched from session',
      data: session.user,
    }
  } catch (error: any) {
    console.error('session error', error.message)
    return {
      error,
      status: 500,
      message: error.message,
      data: null,
    }
  }
})

================
File: apps/auth-service/server/routes/signin.post.ts
================
export default defineEventHandler(async (event) => {
  if (authenticated) {
    setCookie(event, 'auth_token', token, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      maxAge: 60 * 60 * 24 * 7, // 1 week
      path: '/',
      domain: '.domain.com',
    })
  }
})

================
File: apps/auth-service/server/routes/validate-turnstile.post.ts
================
import { defineEventHandler, readBody } from 'h3'

export default defineEventHandler(async (event) => {
  const { token } = await readBody(event)
  const config = useRuntimeConfig()

  // Create form data for Turnstile verification
  const formData = new FormData()
  formData.append('secret', config.turnstileSecretKey)
  formData.append('response', token)

  // Optional: Add visitor's IP
  if (event.node.req.headers['cf-connecting-ip']) {
    formData.append('remoteip', event.node.req.headers['cf-connecting-ip'])
  }

  try {
    const result = await fetch('https://challenges.cloudflare.com/turnstile/v0/siteverify', {
      method: 'POST',
      body: formData,
    })

    const outcome = await result.json()
    return outcome
  } catch (error: any) {
    console.error('Error validating Turnstile token:', error)
    return {
      success: false,
      error: 'Failed to validate token',
    }
  }
})

================
File: apps/main-app/components/bookmark/BookmarkCard.vue
================
<script setup lang="ts">
import { useTimeAgo } from '@vueuse/core'
import type { BaseBookmark } from '~/types/bookmark'

interface Props {
  bookmark: BaseBookmark
  selectable?: boolean
  isSelected?: boolean
}

const props = defineProps<Props>()
defineEmits<{
  (e: 'select', id: string): void
}>()

const bookmarkStore = useBookmarkStore()

const isBookmarked = computed(() =>
  bookmarkStore.isBookmarked(props.bookmark.content_id, props.bookmark.content_type),
)

const handleBookmark = async () => {
  try {
    await bookmarkStore.handleToggleBookmark({
      id: props.bookmark.content_id,
      type: props.bookmark.content_type,
      title: props.bookmark.metadata.title,
      url: props.bookmark.metadata.url,
      description: props.bookmark.metadata.description,
      thumbnail: props.bookmark.metadata.featured_image,
      author: props.bookmark.metadata.author,
    })
  } catch (error: any) {
    console.error('Error handling bookmark:', error)
  }
}

const handleDoiClick = () => {
  if (props.bookmark.metadata.doi_url) {
    window.open(props.bookmark.metadata.doi_url, '_blank', 'noopener,noreferrer')
  }
}

const contentTypeIcon = computed(() => {
  switch (props.bookmark.content_type) {
    case 'news':
      return 'mdi:newspaper'
    case 'research':
      return 'mdi:file-document'
    case 'newsletters':
      return 'mdi:email-newsletter'
    case 'companies':
      return 'mdi:domain'
    default:
      return 'mdi:bookmark'
  }
})
</script>

<template>
  <div class="rounded-lg relative border border-color w-full h-full">
    <div
      v-if="selectable"
      class="absolute w-full h-10 inset-0 z-10 flex items-start justify-end p-2 bg-black/5"
      :class="[isSelected ? 'opacity-100' : 'opacity-0 group-hover:opacity-100 transition-opacity']"
    >
      <PrimeCheckbox
        :model-value="isSelected"
        :binary="true"
        @update:model-value="$emit('select', bookmark.id)"
      />
    </div>

    <div
      class="p-4 flex flex-col justify-between h-full"
      :class="{ 'opacity-75': isSelected }"
    >
      <!-- Header -->
      <div>
        <div class="flex items-center justify-between mb-2">
          <div class="flex items-center gap-2">
            <Icon
              :name="contentTypeIcon"
              size="20px"
              class="text-primary-500"
            />
            <span class="text-sm capitalize">{{ bookmark.content_type }}</span>
          </div>
          <span class="text-sm text-gray-500">{{
            useTimeAgo(bookmark.metadata.published_at || bookmark.created_at).value
          }}</span>
        </div>

        <h2 class="text-xl font-bold mb-2">{{ bookmark.metadata.title }}</h2>

        <!-- Additional metadata -->
        <div
          v-if="
            bookmark.metadata.author || bookmark.metadata.published_in || bookmark.metadata.category
          "
          class="flex items-center text-sm mb-4 text-gray-500"
        >
          <template v-if="bookmark.metadata.author">
            <span>{{ bookmark.metadata.author }}</span>
          </template>
          <template v-if="bookmark.metadata.published_in">
            <span>{{ bookmark.metadata.published_in }}</span>
          </template>
          <template v-if="bookmark.metadata.category">
            <span>{{ bookmark.metadata.category }}</span>
          </template>
        </div>
      </div>

      <!-- Body -->
      <div>
        <div
          v-if="bookmark.metadata.featured_image"
          class="mb-4"
        >
          <NuxtImg
            :provider="bookmark.metadata.featured_image ? 'supabase' : undefined"
            :src="bookmark.metadata.featured_image || 'fallback-image.jpg'"
            :alt="bookmark.metadata.title"
            class="w-full h-auto rounded-lg"
            width="400"
            height="200"
          />
        </div>

        <p
          v-if="bookmark.metadata.description"
          class="text-sm text-gray-600 mb-4 line-clamp-3"
        >
          {{ bookmark.metadata.description }}
        </p>

        <!-- Actions -->
        <div class="flex items-center justify-between">
          <div class="flex items-center gap-4">
            <Icon
              v-if="bookmark.metadata.doi_url"
              name="mdi:file-document-outline"
              size="20px"
              class="text-gray-500 hover:text-gray-700 cursor-pointer"
              @click="handleDoiClick"
            />
            <span
              v-if="bookmark.metadata.score"
              class="text-sm text-gray-500"
            >
              Score: {{ bookmark.metadata.score }}
            </span>
          </div>
          <div class="flex items-center gap-4">
            <button
              class="hover:text-gray-600"
              @click="handleBookmark"
            >
              <Icon
                :name="isBookmarked ? 'mdi:bookmark' : 'mdi:bookmark-outline'"
                size="20px"
                :class="{ 'text-primary-500': isBookmarked }"
              />
            </button>
            <NuxtLink
              :to="bookmark.metadata.url"
              target="_blank"
              rel="noopener noreferrer nofollow"
              class="hover:text-gray-600"
            >
              <Icon
                name="mdi:link-variant"
                size="20px"
              />
            </NuxtLink>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>

================
File: apps/main-app/components/bookmark/BookmarkGridAnimated.vue
================
<script lang="ts" setup>
import { gsap } from 'gsap'

defineProps({
  bookmarks: {
    type: Array as PropType<Bookmark[]>,
    required: true,
  },
  isSelected: {
    type: Function as PropType<(id: string) => boolean>,
    required: true,
  },
  toggleSelection: {
    type: Function as PropType<(id: string) => void>,
    required: true,
  },
})

const positions = new Map()

const getPosition = (el: Element) => {
  const { top, left, width, height } = el.getBoundingClientRect()
  return { top, left, width, height }
}

const beforeLeave = (el: Element) => {
  const pos = getPosition(el)
  positions.set(el, pos)
  el.style.position = 'absolute'
  el.style.top = pos.top + 'px'
  el.style.left = pos.left + 'px'
  el.style.width = pos.width + 'px'
  el.style.height = pos.height + 'px'
}

const leave = (el: Element, done: () => void) => {
  gsap.to(el, {
    opacity: 0,
    scale: 0.8,
    duration: 0.3,
    onComplete: done,
  })
}

const enter = (el: Element, done: () => void) => {
  gsap.from(el, {
    opacity: 0,
    scale: 0.8,
    duration: 0.5,
    onComplete: done,
  })
}

const afterEnter = (el: Element) => {
  el.style.removeProperty('position')
  el.style.removeProperty('top')
  el.style.removeProperty('left')
  el.style.removeProperty('width')
  el.style.removeProperty('height')
}
</script>

<template>
  <TransitionGroup
    class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4 lg:gap-8"
    tag="div"
    :css="false"
    @before-leave="beforeLeave"
    @leave="leave"
    @enter="enter"
    @after-enter="afterEnter"
  >
    <div
      v-for="bookmark in bookmarks"
      :key="bookmark.id"
      :data-index="bookmark.id"
      class="relative group transition-all duration-300"
    >
      <BookmarkCard
        :bookmark="bookmark"
        :selectable="true"
        :is-selected="isSelected(bookmark.id)"
        class="h-full w-full"
        @select="toggleSelection"
      />
    </div>
  </TransitionGroup>
</template>

================
File: apps/main-app/components/bookmark/BookmarkViewFolder.vue
================
<template>
  <PrimeDialog
    v-model:visible="showNewFolderModal"
    modal
    header="Create New Folder"
  >
    <div class="space-y-4 flex flex-col">
      <PrimeInputText
        v-model="newFolderName"
        :feedback="true"
        placeholder="Enter Folder Name"
      />
      <div class="flex gap-2">
        <PrimeCheckbox
          id="default"
          v-model="makeDefault"
          binary
        />
        <label for="default">Make Default</label>
      </div>
    </div>
    <template #footer>
      <PrimeButton
        label="Cancel"
        severity="secondary"
        @click="showNewFolderModal = false"
      />
      <PrimeButton
        severity="danger"
        label="Create"
        @click="createFolder"
      />
    </template>
  </PrimeDialog>
  <div class="space-y-6">
    <div class="flex items-center justify-between mb-4">
      <h2 class="text-xl font-semibold">Folders</h2>
      <PrimeButton
        :disabled="!folderUsage.isUnlimited && folderUsage.used >= folderUsage.limit"
        class="p-button-primary"
        @click="showNewFolderModal = true"
      >
        <div class="flex items-center gap-2">
          <Icon name="mdi:folder-plus" />
          <span
            >New Folder ({{ folderUsage.used }}/{{
              folderUsage.isUnlimited ? '∞' : folderUsage.limit
            }})</span
          >
        </div>
      </PrimeButton>
    </div>

    <!-- Folders Grid -->
    <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4">
      <div
        v-for="folder in folderStore.folders"
        :key="folder.id"
        class="relative p-4 hover:shadow-md transition-shadow border border-color rounded-lg cursor-pointer group overflow-hidden"
        :class="{ 'bg-primary-900': folderStore.selectedFolderId === folder.id }"
        @click="handleFolderSelect(folder)"
      >
        <!-- Static color strip -->
        <div
          class="absolute top-0 left-0 right-0 h-[5px]"
          :style="{ backgroundColor: folder.color }"
        />

        <!-- Main Content -->
        <div class="flex items-center justify-between mt-2">
          <div class="flex items-center gap-2 w-full relative">
            <!-- Normal title view -->
            <h3
              v-if="editingFolderId !== folder.id"
              class="font-medium flex-1"
            >
              {{ folder.name }}
            </h3>

            <!-- Edit title mode -->
            <div
              v-if="editingFolderId === folder.id"
              class="flex items-center w-full gap-2"
              @click.stop
            >
              <input
                v-model="editingName"
                class="min-w-0 flex-1 bg-transparent border-b border-primary-500 focus:outline-none px-1"
                @keyup.enter="saveEdit(folder)"
                @keyup.esc="cancelEdit"
                ref="editInput"
                autocomplete="off"
              />
              <button
                class="shrink-0 p-1 hover:text-primary-500 transition-colors border border-color flex text-white rounded-full"
                @click="saveEdit(folder)"
              >
                <Icon
                  name="mdi:check"
                  class="w-4 h-4"
                />
              </button>
            </div>

            <Icon
              v-if="folder.is_favorite"
              name="mdi:star"
              class="w-4 h-4 text-yellow-400 shrink-0"
            />
          </div>

          <!-- Mobile-only action button -->
          <button
            class="p-2 md:hidden rounded-full hover:bg-gray-100 dark:hover:bg-gray-800"
            @click.stop="toggleActions(folder.id)"
          >
            <Icon
              name="mdi:dots-vertical"
              class="w-4 h-4"
            />
          </button>
        </div>

        <p class="mt-2 text-sm text-muted-foreground">
          {{ bookmarkStore.getBookmarkCount(folder.id) }} bookmarks
        </p>

        <!-- Sliding Action Panel -->
        <div
          v-show="!editingFolderId || editingFolderId !== folder.id"
          class="absolute top-0 right-0 h-full w-1/3 bg-card shadow-lg transform transition-transform bg-primary-900 border-l border-color duration-200 translate-x-full group-hover:translate-x-0"
          :class="{ '!translate-x-0': activeActionsFolder === folder.id }"
        >
          <div class="grid grid-cols-2 items-center justify-center h-full gap-1 p-2">
            <!-- Color Selector -->
            <button
              class="w-full h-full flex items-center justify-center hover:bg-gray-100 dark:hover:bg-gray-800 transition-colors p-2"
              @click.stop
            >
              <div
                class="w-full h-full rounded cursor-pointer"
                :style="{ backgroundColor: folder.color }"
              >
                <input
                  type="color"
                  :value="folder.color"
                  class="opacity-0 absolute w-full h-full"
                  @input="(e) => updateFolder(folder, { color: e.target.value })"
                />
              </div>
            </button>

            <!-- Other Actions -->
            <button
              v-for="action in getActions(folder)"
              :key="action.title"
              class="w-full h-full foreground hover:bg-gray-100 dark:hover:bg-gray-800 transition-colors"
              :class="action.buttonClass"
              @click.stop="action.handler(folder)"
              :title="action.title"
            >
              <Icon
                :name="action.icon"
                class="w-4 h-4"
                :class="action.iconClass"
              />
            </button>
          </div>
        </div>
      </div>
    </div>

    <div
      v-if="!folderUsage.isUnlimited && folderUsage.used >= folderUsage.limit"
      class="bg-amber-300 p-2 text-black rounded flex items-center justify-between"
    >
      <span>Upgrade to <b>Pro</b> plan to create more folders</span>
      <NuxtLink
        to="/settings/payments"
        class="text-black gap-2 border-black border-2 flex rounded items-center bg-white p-2"
      >
        <Icon
          class="text-amber-500"
          name="mdi-star"
        />
        <b>Upgrade</b>
      </NuxtLink>
    </div>
  </div>
</template>

<script setup lang="ts">
import type { Folder } from '~/types/folder'

const folderStore = useFolderStore()
const bookmarkStore = useBookmarkStore()
const { handleFolderSelect } = useBookmarkView()
const { getFeatureUsage } = usePlan()
const toast = useNotification()

const newFolderName = ref('')
const makeDefault = ref(false)

const editingFolderId = ref<string | null>(null)
const editingName = ref('')
const editInput = ref<HTMLInputElement | null>(null)
const activeActionsFolder = ref<string | null>(null)
const showNewFolderModal = ref(false)

const folderUsage = computed(() => getFeatureUsage('BOOKMARK_FOLDERS', folderStore.folders.length))
const currentFolderId = computed(() => folderStore.getDefaultFolder).value?.id

console.log('folderStore.folders', folderStore.getDefaultFolder, currentFolderId)
// Start editing folder name
const startEdit = (folder: Folder) => {
  activeActionsFolder.value = null // Hide action panel
  editingFolderId.value = folder.id
  editingName.value = folder.name
  nextTick(() => {
    if (editInput.value) {
      editInput.value.focus()
      editInput.value.select() // Auto select the text
    }
  })
}

// Save edited name
const saveEdit = async (folder: Folder) => {
  if (editingName.value.trim() && editingName.value !== folder.name) {
    await updateFolder(folder, { name: editingName.value })
  }
  editingFolderId.value = null
}

// Cancel editing
const cancelEdit = () => {
  editingFolderId.value = null
}

// Update folder with new data
const updateFolder = async (folder: Folder, data: Partial<Folder>) => {
  try {
    await folderStore.updateFolder(folder.id, data)
  } catch (error: any) {
    console.error('Error updating folder:', error)
    toast.error({ summary: 'Could not update folder', message: error.message })
  }
}

const getActions = (folder: Folder) => {
  const baseActions = [
    {
      title: 'Edit Name',
      icon: 'mdi:pencil',
      handler: startEdit,
      buttonClass: '',
      iconClass: '',
    },
    {
      title: 'Toggle Favorite',
      icon: folder.is_favorite ? 'mdi:star' : 'mdi:star-outline',
      handler: toggleFavorite,
      buttonClass: '',
      iconClass: folder.is_favorite ? 'text-yellow-400' : '',
    },
  ]

  if (!folder.is_default) {
    baseActions.push({
      title: 'Delete',
      icon: 'mdi:trash',
      handler: handleDelete,
      buttonClass: 'text-red-500',
      iconClass: '',
    })
  }

  return baseActions
}

const toggleActions = (folderId: string) => {
  activeActionsFolder.value = activeActionsFolder.value === folderId ? null : folderId
}

const toggleFavorite = async (folder: Folder) => {
  await folderStore.updateFolder(folder.id, {
    is_favorite: !folder.is_favorite,
  })
}

const handleDelete = async (folder: Folder) => {
  const success = await folderStore.deleteFolder(folder.id)
  if (success) {
    if (currentFolderId?.value === folder.id) {
      currentFolderId.value = null
    }
    await bookmarkStore.fetchBookmarks()
    await bookmarkStore.fetchBookmarkCounts()
    activeActionsFolder.value = null
  }
}

const createFolder = async () => {
  const folder: Partial<Folder> = {
    name: newFolderName.value,
    is_default: makeDefault.value,
  }

  try {
    await folderStore.createFolder(folder)
    toast.success({
      summary: 'Folder created',
      message: `Folder ${newFolderName.value} was created successfully`,
    })
    showNewFolderModal.value = false
    newFolderName.value = ''
    makeDefault.value = ''
  } catch (error: any) {
    console.error('Error Creating Folder', error)
    toast.error({ summary: 'Could not create folder', message: error.message })
  }
}

// Close active actions panel when clicking outside
onMounted(() => {
  document.addEventListener('click', (e) => {
    const target = e.target as HTMLElement

    // If clicking outside folder card
    if (!target.closest('.folder-card')) {
      activeActionsFolder.value = null
      if (editingFolderId.value) {
        cancelEdit()
      }
    }
  })

  try {
    folderStore.fetchFolders()
    bookmarkStore.fetchBookmarks()
  } catch (error: any) {
    console.error('Error initializing data:', error)
  }
})

onUnmounted(() => {
  document.removeEventListener('click', () => {})
})
</script>

================
File: apps/main-app/components/folder/FolderItem.vue
================
<!-- FolderItem.vue -->
<template>
  <div
    :class="[
      'group flex items-center px-2 py-1.5 rounded-md cursor-pointer',
      isSelected ? 'border' : 'hover:border-primary-950 border border-color foreground',
    ]"
    :style="{ paddingLeft: `${depth * 1.5 + 0.5}rem` }"
    @click="handleSelect"
  >
    <div class="flex-1 flex items-center min-w-0">
      <div
        class="w-2 h-2 rounded-full mr-2"
        :style="{ backgroundColor: folder.color }"
      />
      <Icon
        v-if="folder.is_favorite"
        name="mdi:star"
        class="w-4 h-4 text-yellow-400 mr-1"
      />
      <span class="truncate">{{ folder.name }}</span>
      <span
        v-if="folder.is_default"
        class="ml-2 px-1.5 py-0.5 text-xs rounded-full bg-primary-900"
      >
        Default
      </span>
    </div>

    <div class="flex items-center gap-1 opacity-0 group-hover:opacity-100">
      <button
        class="p-1"
        @click.stop="handleEdit"
      >
        <Icon
          name="mdi:pencil"
          class="w-4 h-4"
        />
      </button>
      <button
        v-if="!folder.is_default"
        class="p-1 hover:text-red-600"
        @click.stop="handleDelete"
      >
        <Icon
          name="mdi:trash"
          class="w-4 h-4"
        />
      </button>
    </div>
  </div>

  <div v-if="folder.children?.length">
    <FolderItem
      v-for="child in folder.children"
      :key="child.id"
      :folder="child"
      :depth="depth + 1"
      :selected-id="selectedId"
      @select="$emit('select', $event)"
      @edit="$emit('edit', $event)"
      @delete="$emit('delete', $event)"
    />
  </div>
</template>

<script setup lang="ts">
import type { Folder } from '../../types/bookmarks'

interface Props {
  folder: Folder
  depth?: number
  selectedId?: string
}

interface Emits {
  (e: 'select' | 'edit' | 'delete', folder: Folder): void
}

const props = withDefaults(defineProps<Props>(), {
  depth: 0,
  selectedId: undefined,
})

const emit = defineEmits<Emits>()

const isSelected = computed(() => props.folder.id === props.selectedId)

const handleSelect = () => {
  emit('select', props.folder)
}

const handleEdit = () => {
  emit('edit', props.folder)
}

const handleDelete = () => {
  emit('delete', props.folder)
}
</script>

================
File: apps/main-app/components/folder/FolderTree.vue
================
<!-- FolderTree.vue -->
<script setup lang="ts">
const props = defineProps<{
  modelValue?: string | null // For v-model of selected folder ID
}>()

const emit = defineEmits<{
  (e: 'update:modelValue', value: string | null): void
  (e: 'select', folder: Folder): void
}>()

const { folders, flatFolders, getFavorites, createFolder } = useFolderStore()
const { checkFeatureLimit, getFeatureUsage, getUpgradeMessage } = usePlan()

const canCreateFolder = computed(() => {
  return checkFeatureLimit('BOOKMARK_FOLDERS', folders.value?.length ?? 0)
})

const folderUsage = computed(() => getFeatureUsage('BOOKMARK_FOLDERS', folders.value?.length ?? 0))

const showNewFolderModal = ref(false)

const selectFolder = (folder: Folder) => {
  emit('update:modelValue', folder.id)
  emit('select', folder)
}

const handleNewFolder = async () => {
  if (!newFolder.value.name.trim()) return

  try {
    await createFolder(newFolder.value)
    showNewFolderModal.value = false
    resetNewFolder()
  } catch (error: any) {
    console.error('Failed to create folder:', error)
  }
}

const newFolder = ref({
  name: '',
  parent_id: null,
  color: '#94A3B8',
  is_favorite: false,
  is_default: false,
})

const resetNewFolder = () => {
  newFolder.value = {
    name: '',
    parent_id: null,
    color: '#94A3B8',
    is_favorite: false,
    is_default: false,
  }
}
</script>

<template>
  <div class="space-y-2">
    <div class="mt-4">
      <button
        v-if="canCreateFolder"
        class="w-full flex items-center justify-center px-4 py-2 text-sm font-medium border border-color bg-primary-500 rounded-md"
        @click="showNewFolderModal = true"
      >
        <Icon
          name="mdi:plus"
          class="w-4 h-4 mr-2"
        />
        New Folder
        <span
          v-if="!folderUsage.isUnlimited"
          class="ml-1"
        >
          ({{ folderUsage.used }}/{{ folderUsage.limit }})
        </span>
      </button>
      <div
        v-else
        class="text-sm p-3 rounded-md"
      >
        <p>You've reached the folder limit.</p>
        <NuxtLink
          to="/premium"
          class="text-primary-600 hover:text-primary-700 font-medium"
        >
          {{ getUpgradeMessage('BOOKMARK_FOLDERS') }}
        </NuxtLink>
      </div>
    </div>

    <div
      v-if="getFavorites.length"
      class="mb-4"
    >
      <h3 class="font-medium mb-2">Favorites</h3>
      <div class="space-y-1">
        <FolderItem
          v-for="folder in getFavorites"
          :key="folder.id"
          :folder="folder"
          @select="selectFolder"
        />
      </div>
    </div>

    <!-- Folder Tree -->
    <div class="space-y-1">
      <FolderItem
        v-for="folder in folders"
        :key="folder.id"
        :folder="folder"
        :selected-id="modelValue"
        @select="selectFolder"
      />
    </div>

    <!-- New Folder Dialog -->
    <PrimeDialog
      v-model:visible="showNewFolderModal"
      modal
      header="New Folder"
      :style="{ width: '90vw', maxWidth: '500px' }"
    >
      <!-- Main Content -->
      <span class="block mb-4">Create a new folder to organize your bookmarks.</span>

      <form
        class="space-y-4"
        @submit.prevent="handleNewFolder"
      >
        <div class="flex items-center gap-4 mb-4">
          <label
            for="folderName"
            class="font-semibold w-24"
            >Name</label
          >
          <PrimeInputText
            id="folderName"
            v-model="newFolder.name"
            class="flex-auto"
            required
            autofocus
          />
        </div>

        <div class="flex items-center gap-4 mb-4">
          <label
            for="parentFolder"
            class="font-semibold w-24"
            >Parent</label
          >
          <PrimeSelect
            id="parentFolder"
            v-model="newFolder.parent_id"
            :options="flatFolders"
            option-label="name"
            option-value="id"
            placeholder="Select a parent folder"
            class="flex-auto"
          />
        </div>

        <div class="flex items-center gap-4 mb-4">
          <label
            for="folderColor"
            class="font-semibold w-24"
            >Color</label
          >
          <div class="flex items-center gap-2 flex-auto">
            <input
              id="folderColor"
              v-model="newFolder.color"
              type="color"
              class="h-8 w-8 rounded cursor-pointer"
            />
            <span class="text-sm">{{ newFolder.color }}</span>
          </div>
        </div>

        <div class="flex items-center gap-4">
          <label class="flex items-center flex-1">
            <PrimeCheckbox
              v-model="newFolder.is_favorite"
              :binary="true"
            />
            <span class="ml-2">Add to favorites</span>
          </label>

          <label class="flex items-center flex-1">
            <PrimeCheckbox
              v-model="newFolder.is_default"
              :binary="true"
            />
            <span class="ml-2">Set as default</span>
          </label>
        </div>
      </form>

      <!-- Footer -->
      <template #footer>
        <PrimeButton
          label="Cancel"
          class="p-button-text"
          severity="secondary"
          @click="showNewFolderModal = false"
        />
        <PrimeButton
          label="Create"
          @click="handleNewFolder"
        />
      </template>
    </PrimeDialog>
  </div>
</template>

================
File: apps/main-app/components/news/NewsCard.vue
================
<script setup lang="ts">
import { useTimeAgo } from '@vueuse/core'
import { ref, onMounted } from 'vue'

// Update the interfaces to match our materialized view
interface Company {
  name: string
  logo_url?: string
}

interface NewsCardT {
  id: string
  title: string
  url: string
  hot_score: number
  vote_count: number
  created_at: string
  updated_at: string
  categories: {
    name: string
    isPrimary: boolean
  }[]
  tags: string[]
  status: string
  published_at: string | null
  featured_image: string | null
  author: string | null
  description: string | null
  company_name: string | null
  company_logo: string | null
  summaries: {
    undefined: Array<{
      id: string
      summary: string
      version: number
    }> | null
    beginner: Array<{
      id: string
      summary: string
      version: number
    }> | null
    intermediate: Array<{
      id: string
      summary: string
      version: number
    }> | null
    expert: Array<{
      id: string
      summary: string
      version: number
    }> | null
  }
}

interface Props {
  news: NewsCardT
}

// Update computed properties
const sourceDisplay = computed(() => {
  const companyName = props.news.company_name
  const author = props.news.author

  if (companyName && author) {
    return `${author} • ${companyName}`
  } else if (companyName) {
    return companyName
  } else if (author) {
    return author
  }
  return 'Unknown source'
})

const props = defineProps<Props>()

const hasSummary = computed(() => {
  return props.news.summaries?.undefined?.[0]?.summary !== undefined
})

const summary = computed(() => {
  if (hasSummary.value) {
    return props.news.summaries.undefined[0].summary
  }
  return props.news.description
})

const voteStore = useVoteStore()
const isFlipped = ref(false)

const showModal = ref(false)
const showBookmarkFolders = ref(false)
const modalContent = ref('')
const currentVote = ref<number | null>(null)
const votes = ref(props.news.hot_score || 0)
const bookmarkFolderSelected = ref(null)

const bookmarkStore = useBookmarkStore()
const bookmarked = computed(() => bookmarkStore.isBookmarked(props.news.id))

const folderStore = useFolderStore()

const displayScore = computed(() => {
  const currentScore = voteStore.getScore(props.news.id) ?? votes.value

  // Only show negative numbers if user has downvoted
  if (currentScore < 0 && currentVote.value !== -1) {
    return 0
  }
  return currentScore
})

const submitFolder = async () => {
  showBookmarkFolders.value = false
  setTimeout(
    () => bookmarkStore.handleToggleBookmark(props.news, bookmarkFolderSelected.value),
    500,
  )
}

const formatSourceName = (name: string) => {
  // Remove common suffixes like .com, .org, etc. (we might need them for things like space.com, astronomy.com etc)
  // .replace(/\.(com|org|net|io|ai)$/, '')
  return name
}

const readTime = computed(() => {
  // Calculate read time based on content length
  // This is a placeholder, replace with actual logic
  return '2m read time'
})

onMounted(async () => {
  try {
    if (voteStore.getScore(props.news.id) == null)
      voteStore.setVotes(props.news.id, props.news.vote_count || 0)
  } catch (error: any) {
    console.error('Error fetching vote status:', error)
  }
})

const handleVoteChange = ({ change }: { voteType: number | null; change: number }) => {
  votes.value += change
}

const openModal = (feature: string) => {
  modalContent.value = `The ${feature} feature is coming soon! Stay tuned for updates.`
  showModal.value = true
}

const imageSource = computed(() => {
  if (props.news.featured_image) {
    return props.news.featured_image
  }
  // You can choose either random or deterministic fallbacks
  // return getRandomFallbackImage() // Random each time
  return 'fallback.jpg'
})

// Handle clicks for touch devices
const handleClick = (event: MouseEvent) => {
  const target = event.target as HTMLElement
  if (target.closest('a') || target.closest('button')) {
    event.stopPropagation()
    return
  }
  isFlipped.value = !isFlipped.value
}

// Handle hover states
const handleMouseEnter = () => {
  isFlipped.value = true
}

const handleMouseLeave = () => {
  isFlipped.value = false
}

// METRICS
const { trackNewsVisit } = useUserMetricsStore()
let cleanupVisit: (() => Promise<void>) | null = null

// Track when user visits source
const handleSourceVisit = async () => {
  cleanupVisit = await trackNewsVisit(props.news.id)
}

// Clean up when component is unmounted
onBeforeUnmount(async () => {
  if (cleanupVisit) {
    await cleanupVisit()
  }
})
</script>

<template>
  <div
    class="group relative h-[450px] perspective-1000 hover:cursor-pointer"
    @click="handleClick"
    @mouseenter="handleMouseEnter"
    @mouseleave="handleMouseLeave"
  >
    <div
      class="relative w-full h-full transition-all duration-500 transform-style-preserve-3d border rounded-lg"
      :class="[{ 'rotate-y-180': isFlipped }, bookmarked ? 'border-amber-500/30 ' : 'border-color']"
    >
      <!-- Front of card -->
      <div class="absolute w-full h-full backface-hidden">
        <div class="p-4 flex flex-col justify-between h-full">
          <div>
            <div class="flex items-center gap-2 mb-2">
              <!-- Company logo or random image -->
              <div class="flex-shrink-0 w-6 h-6 rounded-full overflow-hidden">
                <NuxtImg
                  :src="news.company_logo ?? `https://picsum.photos/24/24?random=${news.id}`"
                  alt="Source"
                  class="w-full h-full object-cover"
                  width="24"
                  height="24"
                />
              </div>
              <!-- Source and author info -->
              <div class="flex flex-col min-w-0">
                <span
                  v-if="news.company_name"
                  class="font-medium text-sm truncate"
                >
                  {{ formatSourceName(news.company_name) }}
                </span>
                <span
                  v-if="news.author"
                  class="text-xs text-gray-400 truncate"
                >
                  {{ news.author }}
                </span>
              </div>
            </div>
            <h3
              class="text-xl font-bold mb-2 line-clamp-3 min-h-[3.5rem]"
              :title="news.title"
            >
              {{ news.title }}
            </h3>
            <div class="flex items-center text-sm mb-4">
              {{ useTimeAgo(new Date(news.published_at ?? news.created_at)).value }}
              <span class="mx-2">•</span>
              <span>{{ readTime }}</span>
            </div>
          </div>
          <div>
            <div class="mb-4">
              <div class="relative w-full pb-[56.25%]">
                <NuxtImg
                  :provider="news.featured_image ? 'supabase' : undefined"
                  :src="imageSource"
                  :alt="news.title"
                  class="absolute inset-0 w-full h-full object-cover rounded-lg"
                  sizes="sm:100vw md:50vw lg:400px"
                />
              </div>
            </div>
            <NewsActions
              :news-id="news.id"
              :score="displayScore"
              :comments-count="news.comments"
              :bookmarked="bookmarked"
              :url="news.url"
              :current-vote="currentVote"
              card-side="front"
              :on-bookmark="
                async () => {
                  if (folderStore.folders.length > 1) {
                    await folderStore.fetchFolders()
                    bookmarkFolderSelected =
                      folderStore.folders.find((folder) => folder.is_default) || null
                    showBookmarkFolders = true
                    return
                  }
                  bookmarkStore.handleToggleBookmark(news, folderStore.getDefaultFolder?.id)
                }
              "
              :on-source-visit="handleSourceVisit"
              @vote-change="handleVoteChange"
              @open-modal="openModal"
            />
          </div>
        </div>
      </div>

      <!-- Back of card -->
      <div
        class="absolute w-full h-full backface-hidden rotate-y-180 bg-primary-950 rounded-lg p-4 flex flex-col"
      >
        <!-- Back side content -->
        <div class="flex-grow overflow-hidden flex flex-col">
          <h3
            class="text-xl font-bold mb-4 line-clamp-1"
            :title="news.title"
          >
            {{ news.title }}</h3
          >
          <div
            v-if="hasSummary"
            class="flex items-center w-full justify-center gap-2 pb-4 text-xs"
          >
            <p class="text-sm overflow-y-auto flex-grow">
              {{ summary }}
            </p>
          </div>
          <div
            v-else
            class="flex items-center w-full justify-center gap-2 pb-4 text-xs"
          >
            <p class="text-sm overflow-y-auto flex-grow">
              {{ news.description }}
            </p>
          </div>
        </div>

        <!-- Back side actions -->
        <NewsActions
          :news-id="news.id"
          :score="displayScore"
          :comments-count="news.comments"
          :bookmarked="bookmarked"
          :url="news.url"
          :current-vote="currentVote"
          card-side="back"
          :on-bookmark="
            async () => {
              if (folderStore.folders.length > 1) {
                await folderStore.fetchFolders()
                bookmarkFolderSelected =
                  folderStore.folders.find((folder) => folder.is_default)?.id || null
                showBookmarkFolders = true
                return
              }
              bookmarkStore.handleToggleBookmark(news, folderStore.getDefaultFolder?.id)
            }
          "
          :on-source-visit="handleSourceVisit"
          @vote-change="handleVoteChange"
          @open-modal="openModal"
        />
      </div>
    </div>
  </div>
  <PrimeDialog
    v-model:visible="showBookmarkFolders"
    modal
    header="Choose Folder"
    :style="{ width: '50vw' }"
  >
    <PrimeSelect
      v-model="bookmarkFolderSelected"
      class="w-full"
      :options="folderStore.folders"
      option-label="name"
      option-value="id"
    />
    <template #footer>
      <PrimeButton
        label="Cancel"
        @click="showBookmarkFolders = false"
      />
      <PrimeButton
        label="Submit"
        @click="submitFolder"
      />
    </template>
  </PrimeDialog>
  <PrimeDialog
    v-model:visible="showModal"
    modal
    header="Coming Soon"
    :style="{ width: '50vw' }"
  >
    <p>{{ modalContent }}</p>
  </PrimeDialog>
</template>

<style scoped>
.perspective-1000 {
  perspective: 1000px;
}

.transform-style-preserve-3d {
  transform-style: preserve-3d;
}

.backface-hidden {
  backface-visibility: hidden;
}

.rotate-y-180 {
  transform: rotateY(180deg);
}

/* Optional: Add a smooth transition for the hover effect */
.transition-transform {
  transition-property: transform;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 500ms;
}

/* Optional: Add hover state styles */
@media (hover: hover) {
  .hover\:cursor-pointer:hover {
    cursor: pointer;
  }
}
</style>

================
File: apps/main-app/components/EmptyState.vue
================
<script setup lang="ts">
defineProps<{
  isSearching: boolean
}>()
</script>

<template>
  <div class="flex flex-col items-center justify-center h-64 text-gray-500">
    <Icon
      name="mdi:bookmark-outline"
      class="w-12 h-12"
    />
    <p class="mt-4 text-lg">No bookmarks found</p>
    <p class="text-sm">
      {{ isSearching ? 'Try a different search term' : 'Start by bookmarking some articles' }}
    </p>
  </div>
</template>

================
File: apps/main-app/composables/useBookmarkManager.ts
================
export const useBookmarkManager = () => {
  const selectedIds = ref<string[]>([])
  const targetFolderId = ref<string | null>(null)
  const { moveBookmarks, fetchBookmarks, fetchBookmarkCounts } = useBookmarkStore()
  const confirm = useConfirm()

  const hasSelection = computed(() => selectedIds.value.length > 0)
  const selectionCount = computed(() => selectedIds.value.length)
  const isSelected = (bookmarkId: string) => selectedIds.value.includes(bookmarkId)

  const toggleSelection = (bookmarkId: string) => {
    const index = selectedIds.value.indexOf(bookmarkId)
    if (index === -1) {
      selectedIds.value.push(bookmarkId)
    } else {
      selectedIds.value.splice(index, 1)
    }
  }

  const clearSelection = () => {
    selectedIds.value = []
  }

  const handleMove = async (targetFolder: string) => {
    if (!selectedIds.value.length) return

    try {
      await moveBookmarks(selectedIds.value, targetFolder)
      // Refresh bookmarks
      await fetchBookmarks({})
      await fetchBookmarkCounts()
      // Clear selection
      clearSelection()
    } catch (error: any) {
      console.error('Failed to move bookmarks:', error)
    }
  }

  const handleDelete = async (bookmarkId: string | string[]) => {
    const ids = Array.isArray(bookmarkId) ? bookmarkId : [bookmarkId]
    const bookmarkStore = useBookmarkStore()
    const { bookmarks } = storeToRefs(bookmarkStore)
    const optimisticUpdate = useOptimisticUpdate()

    try {
      await optimisticUpdate.execute({
        key: 'delete-bookmarks',
        apiCall: async () => {
          return Promise.all(ids.map((id) => $fetch(`/api/bookmarks/${id}`, { method: 'DELETE' })))
        },
        optimisticUpdate: () => {
          // Update local state
          bookmarks.value = bookmarks.value.filter((b) => !ids.includes(b.id))
          // Update selection state
          selectedIds.value = selectedIds.value.filter((id) => !ids.includes(id))
        },
        rollback: async () => {
          // Revert by refetching
          await bookmarkStore.fetchBookmarks({})
        },
      })
      await fetchBookmarkCounts()
    } catch (error: any) {
      console.error('Failed to delete bookmarks:', error)
    }
  }

  return {
    selectedIds,
    targetFolderId,
    hasSelection,
    selectionCount,
    isSelected,
    toggleSelection,
    clearSelection,
    handleMove,
    handleDelete,
  }
}

================
File: apps/main-app/composables/useBookmarkStore.ts
================
// useBookmarkStore.ts
import { defineStore } from 'pinia'
import Fuse from 'fuse.js'

interface BookmarkContent {
  id: string
  type: string
  title: string
  description?: string
  thumbnail?: string
  url?: string
  author?: string
  folder_id?: string
}

interface BookmarkParams {
  content_type?: string
  folder_id?: string
  include_subfolders?: boolean
}

interface Bookmark {
  id: string
  user_id: string
  folder_id: string | null
  content_type: string
  content_id: string
  metadata: {
    title: string
    author?: string
    description?: string
    thumbnail?: string
    url?: string
  }
  created_at: string
  folder?: {
    id: string
    name: string
    color: string
    is_favorite: boolean
  }
}

interface BookmarkableContent {
  id: string
  type: 'news' | 'research' | 'newsletters' // add other types as needed
  title: string
  url?: string
  description?: string
  featured_image?: string
  author?: string
  metadata?: Record<string, any>
  folder_id?: string
}

// stores/useBookmarkStore.ts
export const useBookmarkStore = defineStore('bookmarks', () => {
  const bookmarks = ref<Bookmark[]>([])
  const bookmarksByFolder = ref<Map<string, Bookmark[]>>(new Map())
  const showBookmarkFeedback = ref(false)

  const folderBookmarkCounts = ref<Record<string, number>>({})

  const loading = ref(false)
  const error = ref<string | null>(null)
  const currentFolderId = ref<string | null>(null)
  const includeSubfolders = ref(true)
  const searchQuery = ref('')

  const { execute: executeOptimistic } = useOptimisticUpdate()

  const organizeBookmarksByFolder = (bookmarksList: Bookmark[]) => {
    const folderMap = new Map<string, Bookmark[]>()

    bookmarksList.forEach((bookmark) => {
      const folderId = bookmark.folder_id || 'uncategorized'
      if (!folderMap.has(folderId)) {
        folderMap.set(folderId, [])
      }
      folderMap.get(folderId)?.push(bookmark)
    })

    bookmarksByFolder.value = folderMap
  }

  // Get bookmark count for a folder
  const fetchBookmarkCounts = async () => {
    try {
      console.log('Fetching bookmark counts...')
      const response = await $fetch('/api/bookmarks/counts')
      console.log('Bookmark counts response:', response)

      if (!response?.data) {
        console.error('No data received from bookmark counts endpoint')
        return
      }

      const oldCounts = { ...folderBookmarkCounts.value }
      folderBookmarkCounts.value = response.data.reduce(
        (acc: Record<string, number>, item: any) => {
          acc[item.folder_id || 'uncategorized'] = item.count
          return acc
        },
        {},
      )

      console.log('Old counts:', oldCounts)
      console.log('New counts:', folderBookmarkCounts.value)
    } catch (error: any) {
      console.error('Failed to fetch bookmark counts:', error)
    }
  }

  // Fetch bookmarks with optional folder filter
  const fetchBookmarks = async (params: BookmarkParams = {}) => {
    loading.value = true
    error.value = null

    try {
      const response = await $fetch('/api/bookmarks', {
        params: {
          folder_id: params.folder_id || null,
          include_subfolders: params.include_subfolders ?? includeSubfolders.value,
        },
      })

      bookmarks.value = response.data || []
      organizeBookmarksByFolder(bookmarks.value)
    } catch (e) {
      error.value = 'Failed to fetch bookmarks'
      bookmarks.value = []
      bookmarksByFolder.value = new Map()
    } finally {
      loading.value = false
    }
  }

  // Get bookmarks for a specific folder
  const getBookmarkCount = (folderId: string) => {
    return folderBookmarkCounts.value[folderId] || 0
  }

  const toggleBookmark = async (content: BookmarkContent) => {
    const existingBookmark = bookmarks.value.find(
      (b) => b.content_id === content.id && b.content_type === content.type,
    )

    return executeOptimistic({
      key: `bookmark-${content.id}`,
      apiCall: () =>
        $fetch('/api/bookmarks/toggle', {
          method: 'POST',
          body: {
            content_id: content.id,
            content_type: content.type,
            folder_id: content.folder_id,
            metadata: {
              title: content.title,
              description: content.description,
              thumbnail: content.thumbnail,
              url: content.url,
              author: content.author,
            },
          },
        }),
      optimisticUpdate: () => {
        if (existingBookmark) {
          bookmarks.value = bookmarks.value.filter((b) => b.id !== existingBookmark.id)
        } else {
          // Add optimistic bookmark with temporary id
          const optimisticBookmark = {
            id: `temp-${content.id}`,
            content_id: content.id,
            content_type: content.type,
            folder_id: content.folder_id,
            metadata: {
              title: content.title,
              description: content.description,
              thumbnail: content.thumbnail,
              url: content.url,
              author: content.author,
            },
            created_at: new Date().toISOString(),
          }
          bookmarks.value = [...bookmarks.value, optimisticBookmark]
        }
        organizeBookmarksByFolder(bookmarks.value)
      },
      rollback: () => {
        // Revert to previous state
        if (existingBookmark) {
          bookmarks.value = [...bookmarks.value, existingBookmark]
        } else {
          bookmarks.value = bookmarks.value.filter((b) => b.id !== `temp-${content.id}`)
        }
        organizeBookmarksByFolder(bookmarks.value)
      },
    })
  }

  const moveBookmarks = async (bookmarkIds: string[], targetFolderId: string) => {
    return executeOptimistic({
      key: `move-${bookmarkIds.join('-')}`,
      apiCall: () =>
        $fetch('/api/bookmarks/move', {
          method: 'PATCH',
          body: {
            bookmarkIds,
            targetFolderId,
          },
        }),
      optimisticUpdate: () => {
        const previousState = [...bookmarks.value]
        bookmarks.value = bookmarks.value.map((bookmark) =>
          bookmarkIds.includes(bookmark.id) ? { ...bookmark, folder_id: targetFolderId } : bookmark,
        )
        organizeBookmarksByFolder(bookmarks.value)
        return { previousState }
      },
      rollback: (context) => {
        if (context?.previousState) {
          bookmarks.value = context.previousState
          organizeBookmarksByFolder(bookmarks.value)
        }
      },
    })
  }

  const removeBookmarks = async (bookmarkIds: string[]) => {
    return executeOptimistic({
      key: `remove-${bookmarkIds.join('-')}`,
      apiCall: () =>
        $fetch('/api/bookmarks/batch', {
          method: 'DELETE',
          body: { bookmarkIds },
        }),
      optimisticUpdate: () => {
        const previousState = [...bookmarks.value]
        bookmarks.value = bookmarks.value.filter((b) => !bookmarkIds.includes(b.id))
        organizeBookmarksByFolder(bookmarks.value)
        return { previousState }
      },
      rollback: (context) => {
        if (context?.previousState) {
          bookmarks.value = context.previousState
          organizeBookmarksByFolder(bookmarks.value)
        }
      },
    })
  }

  const isBookmarked = computed(() => (contentId: string, contentType: string = 'news') => {
    return bookmarks.value.some(
      (bookmark) => bookmark.content_id === contentId && bookmark.content_type === contentType,
    )
  })

  const filteredBookmarks = computed(() => {
    let filtered = bookmarks.value

    // Filter by folder
    if (currentFolderId.value) {
      filtered = filtered.filter((bookmark) => {
        if (includeSubfolders.value) {
          // TODO: Add logic for subfolder inclusion when implemented
          return bookmark.folder_id === currentFolderId.value
        }
        return bookmark.folder_id === currentFolderId.value
      })
    }

    // Filter by search
    if (searchQuery.value) {
      const fuse = new Fuse(filtered, {
        keys: [
          'metadata.title',
          'metadata.description',
          'metadata.author',
          'metadata.abstract',
          'metadata.name',
        ],
        threshold: 0.3,
        shouldSort: true,
      })
      return fuse.search(searchQuery.value).map((result) => result.item)
    }

    return filtered
  })

  const setCurrentFolder = async (folderId: string | null) => {
    currentFolderId.value = folderId
    await fetchBookmarks({
      folder_id: folderId,
      include_subfolders: includeSubfolders.value,
    })
  }

  const setIncludeSubfolders = async (include: boolean) => {
    includeSubfolders.value = include
    if (currentFolderId.value) {
      await fetchBookmarks({
        folder_id: currentFolderId.value,
        include_subfolders: include,
      })
    }
  }

  const setSearchQuery = (query: string) => {
    searchQuery.value = query
  }

  // Reset state
  const resetFilters = async () => {
    currentFolderId.value = null
    includeSubfolders.value = true
    searchQuery.value = ''
    await fetchBookmarks()
  }

  const handleToggleBookmark = async (content: any, folder_id?: string) => {
    try {
      const bookmarkData = {
        id: content.id,
        type: content.content_type || 'news',
        title: content.title || content.metadata?.title,
        thumbnail: content.featured_image || content.metadata?.featured_image,
        url: content.url || content.metadata?.url,
        author: content.author || content.metadata?.author,
        description: content.description || content.metadata?.description,
        folder_id,
      }

      await toggleBookmark(bookmarkData)
      await fetchBookmarkCounts()
      showBookmarkFeedback.value = true
      setTimeout(() => {
        showBookmarkFeedback.value = false
      }, 1000)
    } catch (error: any) {
      console.error('Error handling bookmark:', error)
    }
  }

  return {
    bookmarks,
    loading,
    error,
    bookmarksByFolder,
    currentFolderId,
    includeSubfolders,
    searchQuery,

    // Computed
    filteredBookmarks,
    showBookmarkFeedback,

    // Actions
    handleToggleBookmark,
    removeBookmarks,
    fetchBookmarks,
    setCurrentFolder,
    setIncludeSubfolders,
    setSearchQuery,
    resetFilters,
    getBookmarkCount,
    fetchBookmarkCounts,

    moveBookmarks,
    toggleBookmark,
    isBookmarked,
  }
})

================
File: apps/main-app/composables/useBookmarkView.ts
================
// useBookmarkView.ts
import { set } from 'zod'
import type { Folder } from '../types/bookmarks'

export const useBookmarkView = () => {
  const viewMode = ref<'grid' | 'list'>('grid')
  const searchQuery = ref('')
  const includeSubfolders = ref(true)
  const showNewFolderModal = ref(false)

  const handleFolderSelect = async (folder: Folder) => {
    const { fetchBookmarks } = useBookmarkStore()
    const { setSelectedFolder } = useFolderStore()
    setSelectedFolder(folder.id)
    await fetchBookmarks({
      folder_id: folder.id,
      include_subfolders: includeSubfolders.value,
    })
  }

  const debouncedSearch = useDebounceFn((query: string) => {
    // Implement search logic here
    console.log('Searching:', query)
  }, 300)

  watch(searchQuery, (newQuery) => {
    debouncedSearch(newQuery)
  })

  return {
    viewMode,
    searchQuery,
    includeSubfolders,
    showNewFolderModal,
    handleFolderSelect,
  }
}

================
File: apps/main-app/composables/useFolderStore.ts
================
import { useConfirm } from 'primevue/useconfirm'
import { handleResponse } from '@ib/logger'
import type { Folder } from '~/types/folder'

export const useFolderStore = defineStore('folders', () => {
  const error = ref<string | null>(null)
  const confirm = useConfirm()
  const logger = useLogger()
  const loading = ref(false)

  const folders = ref<Folder[]>([])
  const selectedFolderId = ref<string | null>(null)
  const includeSubfolders = ref(true)

  // Computed properties for convenience
  const getDefaultFolder = computed(() => folders.value.find((f) => f.is_default) || null)
  const getFavorites = computed(() => folders.value.filter((f) => f.is_favorite) || [])

  const setSelectedFolder = (folderId: string | null) => {
    selectedFolderId.value = folderId
  }

  const setIncludeSubfolders = (value: boolean) => {
    includeSubfolders.value = value
  }

  const fetchFolders = async () => {
    console.log('Fetching folders...')
    loading.value = true
    error.value = null

    try {
      const response = await $fetch('/api/folders')
      console.log('Folders response:', response)

      if (!response.data) {
        console.warn('No data in response')
      }

      folders.value = response.data || []
      console.log('Folders updated:', folders.value)
    } catch (e) {
      console.error('Error fetching folders:', e)
      error.value = 'Failed to fetch folders'
      folders.value = []
    } finally {
      loading.value = false
    }
  }

  const flatFolders = computed(() => {
    const flattened: Folder[] = []

    const flatten = (items: Folder[], depth = 0) => {
      items.forEach((item) => {
        flattened.push({ ...item, depth })
        if (item.children?.length) {
          flatten(item.children, depth + 1)
        }
      })
    }

    flatten(folders.value)
    return flattened
  })

  const createFolder = async (folder: Partial<Folder>) => {
    loading.value = true
    try {
      const data = await handleResponse(
        logger,
        () =>
          $fetch('/api/folders', {
            method: 'POST',
            body: folder,
          }),
        'Fetching Folders',
      )

      if (data) {
        await fetchFolders()
      }
      return data
    } catch (error: any) {
      logger.error(error, {
        context: 'createFolder',
        userMessage: 'Failed to create folder',
      })
      throw error
    } finally {
      loading.value = false
    }
  }

  const updateFolder = async (folderId: string, updates: Partial<Folder>) => {
    loading.value = true
    try {
      const data = await handleResponse(
        logger,
        () =>
          $fetch(`/api/folders/${folderId}`, {
            method: 'PATCH',
            body: updates,
          }),
        'Failed to update folder',
      )

      if (data) {
        await fetchFolders()
      }
      return data
    } catch (error: any) {
      logger.error(error, {
        context: 'updateFolder',
        userMessage: 'Failed to update folder',
      })
      throw error
    } finally {
      loading.value = false
    }
  }

  const deleteFolder = async (folderId: string) => {
    loading.value = true

    try {
      // First get the default folder
      const defaultFolder = getDefaultFolder.value
      if (!defaultFolder) {
        throw new Error('Default folder not found')
      }

      // Show confirmation dialog
      return new Promise((resolve) => {
        confirm.require({
          message: 'What would you like to do with the bookmarks in this folder?',
          header: 'Delete Folder',
          icon: 'pi pi-exclamation-triangle',
          acceptLabel: 'Delete all bookmarks',
          rejectLabel: 'Move to default folder',
          accept: async () => {
            try {
              const data = await handleResponse(
                logger,
                () =>
                  $fetch(`/api/folders/${folderId}`, {
                    method: 'DELETE',
                    body: {
                      strategy: 'delete_all',
                    },
                  }),
                'Deleting Folder',
              )

              if (data !== null) {
                await fetchFolders()
              }
              resolve(true)
            } catch (error: any) {
              logger.error(error, {
                context: 'deleteFolder',
                userMessage: 'Failed to delete folder',
              })
              resolve(false)
            } finally {
              loading.value = false
            }
          },
          reject: async () => {
            // Move to default folder
            const result = await handleMoveAndDelete(folderId, defaultFolder.id)
            resolve(result)
          },
        })
      })
    } catch (error: any) {
      logger.error(error, {
        context: 'deleteFolder',
        userMessage: 'Failed to delete folder',
      })
      loading.value = false
      return false
    }
  }

  const handleMoveAndDelete = async (folderId: string, defaultFolderId: string) => {
    try {
      const data = await handleResponse(
        logger,
        () =>
          $fetch(`/api/folders/${folderId}`, {
            method: 'DELETE',
            body: {
              strategy: 'move_to_default',
              defaultFolderId,
            },
          }),
        'Moving and Deleting Folder',
      )

      if (data !== null) {
        await fetchFolders()
      }
      return true
    } catch (error: any) {
      logger.error(error, {
        context: 'handleMoveAndDelete',
        userMessage: 'Failed to move bookmarks and delete folder',
      })
      return false
    } finally {
      loading.value = false
    }
  }

  return {
    folders,
    loading,
    error,
    selectedFolderId,
    includeSubfolders,
    setSelectedFolder,
    setIncludeSubfolders,
    fetchFolders,
    createFolder,
    updateFolder,
    deleteFolder,
    flatFolders,
    getDefaultFolder,
    getFavorites,
  }
})

================
File: apps/main-app/composables/usePages.ts
================
import { ref } from 'vue'

export interface PageType {
  id: string
  label: string
  slug: string
  icon: string
  children?: PageType[]
  isExpanded?: boolean
}

export interface NavigationCategory {
  id: string
  label: string
  items: PageType[]
}

export interface BreadcrumbLink {
  to: string
  label: string
  ariaLabel: string
}

const UUID_REGEX = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i

const createFeedItem = {
  id: 'create_feed',
  label: '+ Create Feed',
  slug: '/feed/add',
  icon: 'mdi:plus',
}

const upgradePlan = {
  id: 'upgrade_plan',
  label: 'Upgrade to create custom feeds',
  slug: '/settings/payments',
  icon: 'mdi:star',
}

const navigationCategories = ref([
  {
    id: 'main',
    label: 'Main',
    items: [
      {
        id: '1',
        label: 'Home',
        slug: '/',
        icon: 'material-symbols:home-rounded',
      },
      {
        id: '2',
        label: 'Companies',
        slug: '/companies',
        icon: 'material-symbols:domain',
      },
    ],
  },
  {
    id: 'news',
    label: 'News',
    items: [
      {
        id: '2',
        label: 'Feed',
        slug: '/news',
        icon: 'mdi:newspaper-variant-outline',
      },
      {
        id: 'my-feeds',
        label: 'My Feeds',
        slug: '#',
        icon: 'mdi:rss',
        isExpanded: false,
        children: [],
      },
    ],
  },
  {
    id: 'profile',
    label: 'Profile',
    items: [
      {
        id: '4',
        label: 'Bookmarks',
        slug: '/profile/bookmarks',
        icon: 'mdi:bookmark-outline',
      },
    ],
  },
] as NavigationCategory[])

export default function usePages() {
  const client = useSupabaseClient()
  const { profile } = useCurrentUser()
  const route = useRoute()
  const { getFeatureUsage } = usePlan()

  const getFeedName = (feedId: string): string => {
    // Return empty string if it's a UUID
    if (UUID_REGEX.test(feedId)) {
      const newsCategory = navigationCategories.value.find((cat) => cat.id === 'news')
      const myFeeds = newsCategory?.items.find((item) => item.id === 'my-feeds')
      const feed = myFeeds?.children?.find((feed) => feed.id === feedId)
      return feed?.label || ''
    }
    return feedId
  }

  const generateBreadcrumbs = (path: string): BreadcrumbLink[] => {
    const pathParts = path.split('/').filter(Boolean)
    let currentPath = ''

    return pathParts
      .map((part): BreadcrumbLink | null => {
        currentPath += `/${part}`

        // Skip home link
        if (currentPath === '/' || (UUID_REGEX.test(part) && !getFeedName(part))) {
          return null
        }

        // Handle feeds
        if (currentPath.startsWith('/feed/')) {
          if (part === 'feed') {
            return {
              to: currentPath,
              label: 'Feeds',
              ariaLabel: 'Feeds',
            }
          }
          return {
            to: currentPath,
            label: getFeedName(part),
            ariaLabel: getFeedName(part),
          }
        }

        // Default handling
        return {
          to: currentPath,
          label: part.charAt(0).toUpperCase() + part.slice(1),
          ariaLabel: part.charAt(0).toUpperCase() + part.slice(1),
        }
      })
      .filter(Boolean) as BreadcrumbLink[]
  }

  const breadcrumbs = computed(() => generateBreadcrumbs(route.path))

  const currentFeedName = computed(() => {
    if (route.path.startsWith('/feed/')) {
      const feedId = route.params.feed as string
      return getFeedName(feedId)
    }
    return ''
  })

  // Existing feed management functions
  const addFeed = (id: string, label: string) => {
    const newsCategory = navigationCategories.value.find((cat) => cat.id === 'news')
    const myFeeds = newsCategory?.items.find((item) => item.id === 'my-feeds')

    if (myFeeds && !myFeeds.children.some((feed) => feed.id === id)) {
      myFeeds.children.splice(1, 0, {
        id,
        label,
        slug: `/feed/${id}`,
        icon: 'mdi:newspaper-variant-multiple-outline',
      })
    }

    checkUsage(myFeeds)
  }

  const initializeFeeds = () => {
    if (profile.id) {
      const toast = useNotification()
      client
        .from('feeds')
        .select('id, name')
        .eq('user_id', profile.id)
        .then(({ data, error }) => {
          if (error) {
            toast.error({
              summary: 'Failed to get custom feeds',
              message: 'Could not get custom feeds',
            })
            return
          }

          const newsCategory = navigationCategories.value.find((cat) => cat.id === 'news')
          const myFeeds = newsCategory?.items.find((item) => item.id === 'my-feeds')

          if (myFeeds) {
            data.forEach((feed) => {
              if (!myFeeds.children.some((item) => item.id === feed.id)) {
                myFeeds.children.push({
                  id: feed.id,
                  label: feed.name,
                  slug: `/feed/${feed.id}`,
                  icon: 'mdi:newspaper-variant-multiple-outline',
                })
              }
            })
            checkUsage(myFeeds)
          }
        })
    }
  }

  const deleteFeed = (feedId: string) => {
    const newsCategory = navigationCategories.value.find((cat) => cat.id === 'news')
    const myFeeds = newsCategory?.items.find((item) => item.id === 'my-feeds')

    if (myFeeds) {
      const index = myFeeds.children.findIndex((item) => item.id === feedId)
      if (index > -1) {
        myFeeds.children.splice(index, 1)
      }
    }

    checkUsage(myFeeds)
  }

  const checkUsage = (myFeeds: Record<string, any>) => {
    const feeds = myFeeds.children.filter(
      (feed) => feed.id !== 'create_feed' && feed.id !== 'upgrade_plan',
    )

    const usage = getFeatureUsage('CUSTOM_FEEDS', feeds.length)

    myFeeds.children =
      !usage.isUnlimited && usage.used >= usage.limit
        ? [upgradePlan, ...feeds]
        : [createFeedItem, ...feeds]
  }

  onMounted(initializeFeeds)

  return {
    appLinks: navigationCategories,
    breadcrumbs,
    currentFeedName,
    addFeed,
    deleteFeed,
  }
}

================
File: apps/main-app/pages/profile/bookmarks.vue
================
<script setup lang="ts">
import { storeToRefs } from 'pinia'
import { useConfirm } from 'primevue/useconfirm'
import EmptyState from '../../components/EmptyState.vue'

const confirm = useConfirm()
const bookmarkStore = useBookmarkStore()
const folderStore = useFolderStore()
const bookmarkManager = useBookmarkManager()

const { selectedFolderId, includeSubfolders, folders } = storeToRefs(folderStore)
const { bookmarks, loading } = storeToRefs(bookmarkStore)

const searchQuery = ref('')
const searchResults = ref<any[]>([])
const isMoving = ref(false)
const movingFolderId = ref()

const searchFuseOptions = {
  keys: ['metadata.title', 'metadata.description', 'metadata.author'],
  threshold: 0.3,
  shouldSort: true,
}

// Computed properties
const currentFolder = computed(() => {
  const folder = folders.value?.find((f) => f.id === selectedFolderId.value)
  console.log('Current folder computed:', {
    selectedId: selectedFolderId.value,
    folder,
  })
  return folder
})

const filteredBookmarks = computed(() => {
  console.log('Computing filtered bookmarks:', {
    hasBookmarks: bookmarks.value?.length,
    selectedFolder: selectedFolderId.value,
    includeSubfolders: includeSubfolders.value,
    searchQuery: searchQuery.value,
  })

  let filtered = bookmarks.value ?? []

  // Filter by folder
  if (selectedFolderId.value) {
    filtered = filtered.filter((bookmark) => {
      const matches = bookmark.folder_id === selectedFolderId.value
      return matches
    })
  }

  console.log('After folder filter:', filtered.length)

  // Filter by search
  if (searchQuery.value && searchResults.value?.length) {
    return searchResults.value
  }

  return filtered
})

// Methods
const clearSelection = () => {
  bookmarkManager.clearSelection()
  movingFolderId.value = null
}

const handleMoveSelected = async () => {
  if (!movingFolderId.value || !bookmarkManager.selectedIds.value.length) return

  isMoving.value = true
  try {
    await bookmarkManager.handleMove(movingFolderId.value)
    bookmarkManager.clearSelection()
  } finally {
    movingFolderId.value = null
    isMoving.value = false
  }
}

const handleDeleteSelected = () => {
  confirm.require({
    message: `Delete ${bookmarkManager.selectedIds.value.length} bookmark${bookmarkManager.selectedIds.value.length > 1 ? 's' : ''}?`,
    header: 'Confirm Delete',
    icon: 'pi pi-exclamation-triangle',
    acceptClass: 'p-button-danger',
    accept: async () => {
      await bookmarkManager.handleDelete(bookmarkManager.selectedIds.value)
      clearSelection()
    },
  })
}

const handleSearchResults = (results: FuseResult<any>[]) => {
  console.log('Search results:', results.length)
  searchResults.value = results.map((result) => result.item)
}

onMounted(async () => {
  console.log('Component mounted, fetching data...')
  await Promise.all([folderStore.fetchFolders(), bookmarkStore.fetchBookmarks()])
  console.log('Initial data loaded:', {
    folders: folders.value?.length,
    bookmarks: bookmarks.value?.length,
  })

  const defaultFolder = folderStore.getDefaultFolder
  console.log('Default folder:', defaultFolder)

  if (defaultFolder) {
    folderStore.setSelectedFolder(defaultFolder.id)
    console.log('Set default folder:', defaultFolder.id)
  }
})

// Also modify the empty check to add logging
const isEmpty = computed(() => {
  const empty =
    !loading.value && (!filteredBookmarks.value?.length || filteredBookmarks.value.length === 0)
  console.log('Checking empty state:', {
    loading: loading.value,
    filteredLength: filteredBookmarks.value?.length,
    isEmpty: empty,
  })
  return empty
})
</script>

<template>
  <div class="min-h-screen p-4 gap-4 max-w-[940px] flex flex-col mx-auto lg:p-8 lg:gap-8">
    <BookmarkViewFolder v-if="!searchQuery" />

    <!-- Search Bar & Actions -->
    <div
      class="flex flex-col gap-4 items-center justify-between z-40 bg-card p-4 border border-color rounded-lg foreground"
    >
      <div class="w-full">
        <FuzzySearch
          v-model="searchQuery"
          :data="bookmarks"
          :fuse-options="searchFuseOptions"
          placeholder="Search bookmarks..."
          class="w-full"
          @results="handleSearchResults"
        />
      </div>

      <!-- Selection Actions -->
      <template v-if="bookmarkManager.selectionCount">
        <div class="flex w-full justify-between flex-row">
          <div
            v-if="currentFolder"
            class="flex items-center gap-2 flex-grow"
          >
            <div
              class="w-3 h-3 rounded-full"
              :style="{ backgroundColor: currentFolder.color }"
            />
            <h2 class="text-xl font-semibold">{{ currentFolder.name }}</h2>
          </div>
          <div class="flex items-center gap-2 lg:gap-4">
            <!-- Selection count -->
            <span class="text-sm text-gray-600 hidden sm:inline">
              {{ bookmarkManager.selectionCount }} selected
            </span>
            <span class="text-sm text-gray-600 sm:hidden">
              {{ bookmarkManager.selectionCount }}
            </span>

            <!-- Move to folder dropdown -->
            <PrimeSelect
              v-model="movingFolderId"
              :options="folders.filter((folder) => folder.id !== currentFolder?.id)"
              option-label="name"
              option-value="id"
              placeholder="Move to..."
              class="min-w-[120px] lg:min-w-[200px]"
            />

            <!-- Move button -->
            <PrimeButton
              :disabled="!movingFolderId || !bookmarkManager.selectedIds.value.length || isMoving"
              :loading="isMoving"
              class="!p-2 lg:!p-3"
              @click="handleMoveSelected"
            >
              <Icon
                name="mdi:folder-move"
                class="w-5 h-5 lg:mr-2"
              />
              <span class="hidden lg:inline">
                {{ isMoving ? 'Moving...' : 'Move' }}
              </span>
            </PrimeButton>

            <!-- Delete button -->
            <PrimeButton
              :disabled="!bookmarkManager.selectedIds.value.length"
              severity="danger"
              class="!p-2 lg:!p-3"
              @click="handleDeleteSelected"
            >
              <Icon
                name="mdi:trash-can"
                class="w-5 h-5 lg:mr-2"
              />
              <span class="hidden lg:inline">Delete</span>
            </PrimeButton>

            <!-- Clear selection button -->
            <PrimeButton
              :disabled="!bookmarkManager.selectedIds.value.length && !movingFolderId"
              severity="secondary"
              class="!p-2 lg:!p-3"
              @click="clearSelection"
            >
              <Icon
                name="mdi:close"
                class="w-5 h-5 lg:mr-2"
              />
              <span class="hidden lg:inline">Clear</span>
            </PrimeButton>
          </div>
        </div>
      </template>
    </div>

    <!-- Content -->
    <div class="space-y-6">
      <!-- Loading State -->
      <div
        v-if="bookmarkStore.loading"
        class="flex items-center justify-center h-64"
      >
        <Icon
          name="mdi:loading"
          class="w-8 h-8 text-gray-400 animate-spin"
        />
      </div>

      <!-- Bookmarks Grid -->
      <BookmarkGridAnimated
        v-else
        :bookmarks="filteredBookmarks"
        :is-selected="bookmarkManager.isSelected"
        :toggle-selection="bookmarkManager.toggleSelection"
      />

      <!-- Empty State -->
      <EmptyState
        v-show="isEmpty"
        :is-searching="searchQuery !== ''"
        class="flex flex-col items-center justify-center h-64 text-gray-500"
      />

      <!-- Confirmation Dialog -->
    </div>
    <PrimeConfirmPopup />
  </div>
</template>

================
File: apps/main-app/server/api/ai/ask.ts
================
import { openAI } from '~/server/utils/openai/callOpenAI'
import { serverSupabaseUser } from '#supabase/server'

export default defineEventHandler({
  onRequest: [rateLimiter],
  onBeforeResponse: [],
  handler: async (event) => {
    const log = useServerLogger('API:ASK')
    const { messages } = await readBody(event)

    if (!Array.isArray(messages) || messages.length === 0) {
      return {
        statusCode: 400,
        error: {
          message: 'messages must be a non-empty array',
        },
      }
    }

    const isValidMessage = (msg) =>
      msg &&
      typeof msg === 'object' &&
      ['system', 'user', 'assistant'].includes(msg.role) &&
      typeof msg.content === 'string'

    if (!messages.every(isValidMessage)) {
      return {
        statusCode: 400,
        error: {
          message: 'Invalid message format',
        },
      }
    }

    console.log('messages', messages)

    try {
      const user = await serverSupabaseUser(event)
      let chatCompletion

      const plan = user?.app_metadata?.plan

      if (plan === 'free') {
        console.log('getGroqChatCompletion')
        chatCompletion = await getGroqChatCompletion(messages)
      } else if (plan === 'pro' || plan === 'expert') {
        console.log('openAI.createChatCompletion')
        chatCompletion = openAI.createChatCompletion(messages)
      } else {
        log.warn('no user plan', plan)
      }

      return {
        error: null,
        statusCode: 200,
        data: chatCompletion || '',
      }
    } catch (error: any) {
      log.error('error', error)
      return {
        data: null,
        error,
        statusCode: 500,
      }
    }
  },
})

================
File: apps/main-app/server/api/bookmarks/[id].delete.ts
================
import { serverSupabaseUser, serverSupabaseClient } from '#supabase/server'

// server/api/bookmarks/[id].delete.ts
export default defineEventHandler(async (event) => {
  const user = await serverSupabaseUser(event)
  const bookmarkId = event.context.params.id

  if (!user) {
    throw createError({
      statusCode: 401,
      message: 'Unauthorized',
    })
  }

  const supabase = await serverSupabaseClient(event)

  const { error } = await supabase
    .from('bookmarks')
    .delete()
    .eq('id', bookmarkId)
    .eq('user_id', user.id)

  if (error) {
    throw createError({
      statusCode: 500,
      message: 'Failed to delete bookmark',
    })
  }

  return { success: true }
})

================
File: apps/main-app/server/api/bookmarks/counts.ts
================
// server/api/bookmarks/counts.ts
import { serverSupabaseServiceRole, serverSupabaseUser } from '#supabase/server'

export default defineEventHandler(async (event) => {
  console.log('fetch bookmark counts endpoint fired')
  try {
    const user = await serverSupabaseUser(event)
    if (!user) {
      throw createError({ statusCode: 401, message: 'Unauthorized' })
    }

    const supabase = serverSupabaseServiceRole(event)

    // Using a raw SQL query with Supabase
    const { data, error } = await supabase.rpc('get_bookmark_counts_by_folder', {
      user_id_param: user.id,
    })

    if (error) throw error

    console.log('FETCHED DATA', data?.length)

    // Transform the data to include uncategorized bookmarks
    const transformedData = data.map((item: any) => ({
      folder_id: item.folder_id || 'uncategorized',
      count: parseInt(item.count),
    }))

    console.log('TRANSFORMED DATA', transformedData)

    return { data: transformedData }
  } catch (error: any) {
    console.error('Error fetching bookmark counts:', error)
    throw createError({
      statusCode: error.statusCode || 500,
      message: error.message || 'Internal server error',
    })
  }
})

================
File: apps/main-app/server/api/bookmarks/index.ts
================
// server/api/bookmarks/index.ts
import { serverSupabaseUser, serverSupabaseClient } from '#supabase/server'

interface BookmarkMetadata {
  title: string
  url: string
  description?: string
  featured_image?: string
  author?: string
  published_at?: string
}

function normalizeContent(content: any, contentType: string): BookmarkMetadata {
  switch (contentType) {
    case 'news':
      return {
        title: content.title,
        url: content.url,
        description: content.description,
        featured_image: content.featured_image,
        author: content.author,
        published_at: content.published_at,
      }
    case 'research':
      return {
        title: content.title,
        url: content.abstract_url,
        description: content.abstract,
        author: content.authors?.[0], // First author or handle array differently
        published_at: content.published_at,
      }
    case 'newsletters':
      return {
        title: content.title,
        url: content.url,
        description: content.generated_content,
        published_at: content.start_date,
      }
    default:
      throw new Error(`Unknown content type: ${contentType}`)
  }
}

export default defineEventHandler(async (event) => {
  try {
    const { folder_id = null, include_subfolders = false } = getQuery(event)
    const user = await serverSupabaseUser(event)
    const supabase = await serverSupabaseClient(event)

    if (!user) {
      throw createError({ statusCode: 401, message: 'Unauthorized' })
    }

    let query = supabase
      .from('bookmarks')
      .select(
        `
        *,
        folder:folder_id (
          id,
          name,
          color,
          path,
          is_favorite
        ),
        content:content_id (
          id,
          title,
          url,
          content_type,
          updated_at,
          created_at
        )
      `,
      )
      .eq('user_id', user.id)

    // Modify the query to fetch all bookmarks if no folder_id is provided
    if (folder_id) {
      if (include_subfolders) {
        // Always filter by a folder (either specified or default)
        const { data: folderData } = await supabase
          .from('bookmark_folders')
          .select('path')
          .eq('id', folder_id)
          .single()

        if (folderData?.path) {
          const { data: subFolderIds } = await supabase
            .from('bookmark_folders')
            .select('id')
            .like('path', `${folderData.path}%`)

          query = query.in('folder_id', [folder_id, ...(subFolderIds?.map((f) => f.id) || [])])
        } else {
          query = query.eq('folder_id', folder_id)
        }
      } else {
        query = query.eq('folder_id', folder_id)
      }
    }

    query = query.order('created_at', { ascending: false })

    const { data: bookmarks, error: bookmarksError } = await query
    if (bookmarksError) throw bookmarksError

    if (!bookmarks?.length) return { data: [] }

    // Group bookmarks by content_type for fetching related data
    const bookmarksByType = bookmarks.reduce(
      (acc, bookmark) => {
        const type = bookmark.content_type
        if (!acc[type]) acc[type] = []
        acc[type].push(bookmark.content_id)
        return acc
      },
      {} as Record<string, string[]>,
    )

    // Fetch all content type specific data in parallel
    const contentTypeData: Record<string, any[]> = {}
    await Promise.all(
      Object.entries(bookmarksByType).map(async ([type, ids]) => {
        const { data, error } = await supabase.from(type).select('*').in('id', ids)
        if (error) throw error
        contentTypeData[type] = data || []
      }),
    )

    // Normalize and merge the data
    const normalizedBookmarks = bookmarks.map((bookmark) => {
      const typeSpecificContent = contentTypeData[bookmark.content_type]?.find(
        (c) => c.id === bookmark.content_id,
      )
      const newMetadata = typeSpecificContent
        ? normalizeContent(typeSpecificContent, bookmark.content_type)
        : null

      return {
        id: bookmark.id,
        user_id: bookmark.user_id,
        content_id: bookmark.content_id,
        content_type: bookmark.content_type,
        created_at: bookmark.created_at,
        updated_at: bookmark.updated_at,
        folder_id: bookmark.folder_id,
        folder: bookmark.folder,
        metadata: {
          ...bookmark.metadata,
          ...newMetadata,
        },
      }
    })

    console.log('Normalized bookmarks:', normalizedBookmarks)

    return { data: normalizedBookmarks }
  } catch (error: any) {
    console.error('Error in bookmark endpoint:', error)
    throw createError({
      statusCode: error.statusCode || 500,
      message: error.message || 'Internal server error',
    })
  }
})

================
File: apps/main-app/server/api/bookmarks/move.patch.ts
================
import { serverSupabaseUser, serverSupabaseClient } from '#supabase/server'

export default defineEventHandler(async (event: H3Event) => {
  try {
    const user = await serverSupabaseUser(event)
    if (!user) {
      throw createError({ statusCode: 401, message: 'Unauthorized' })
    }

    const supabase = await serverSupabaseClient(event)
    const { bookmarkIds, targetFolderId } = await readBody(event)

    // Verify user owns these bookmarks
    const { data: bookmarks, error: verifyError } = await supabase
      .from('bookmarks')
      .select('id')
      .in('id', bookmarkIds)
      .eq('user_id', user.id)

    if (verifyError || !bookmarks?.length) {
      throw createError({
        statusCode: 400,
        message: 'Invalid bookmark selection',
      })
    }

    // Move bookmarks to new folder
    const { error: updateError } = await supabase
      .from('bookmarks')
      .update({
        folder_id: targetFolderId,
        updated_at: new Date().toISOString(),
      })
      .in('id', bookmarkIds)
      .eq('user_id', user.id)

    if (updateError) throw updateError

    return { success: true }
  } catch (err) {
    console.error('Move bookmarks error:', err)
    throw createError({
      statusCode: err.statusCode || 500,
      message: err.message || 'Internal server error',
    })
  }
})

================
File: apps/main-app/server/api/bookmarks/toggle.ts
================
import { serverSupabaseUser, serverSupabaseClient } from '#supabase/server'

export default defineEventHandler(async (event) => {
  const body = await readBody(event)
  const user = await serverSupabaseUser(event)
  const { content_id, content_type, folder_id, metadata } = body

  if (!user) {
    return createError({
      status: 401,
      message: 'Unauthorized',
    })
  }

  const supabase = await serverSupabaseClient(event)

  // Check if bookmark exists
  const { data: existing } = await supabase
    .from('bookmarks')
    .select('id')
    .eq('user_id', user.id)
    .eq('content_id', content_id)
    .eq('content_type', content_type)
    .maybeSingle()

  if (existing) {
    // Remove bookmark
    const { error: deleteError } = await supabase
      .from('bookmarks')
      .delete()
      .match({ id: existing.id })

    if (deleteError) {
      throw createError({
        statusCode: 500,
        message: 'Failed to remove bookmark',
      })
    }

    return {
      bookmarked: false,
    }
  }

  // Get default folder if needed
  const { data: defaultFolder } = await supabase
    .from('bookmark_folders')
    .select('id')
    .eq('user_id', user.id)
    .eq('is_default', true)
    .single()

  // Create new bookmark
  const { data: newBookmark, error: bookError } = await supabase
    .from('bookmarks')
    .insert({
      user_id: user.id,
      content_id,
      content_type,
      folder_id: folder_id || defaultFolder?.id,
      metadata: {
        ...metadata,
        bookmarked_at: new Date().toISOString(),
      },
    })
    .select()
    .single()

  if (bookError) {
    throw createError({
      statusCode: 500,
      message: 'Failed to create bookmark',
    })
  }

  return {
    bookmarked: true,
    data: newBookmark,
  }
})

================
File: apps/main-app/server/api/dev/update-role.ts
================
import { serverSupabaseServiceRole, serverSupabaseUser } from '#supabase/server'

export default defineEventHandler(async (event) => {
  const { role } = await readBody(event)
  const user = await serverSupabaseUser(event)
  const supabaseAdmin = serverSupabaseServiceRole(event)
  const env = useRuntimeConfig().public

  //   check if we are in development mode
  if (env.nodeEnv !== 'development') {
    console.warn(`user trying to override role from ${user.role} to ${role} in ${env.nodeEnv}`)
    return { error: 'Role override is only allowed in development mode' }
  }

  const { data, error } = await supabaseAdmin.auth.admin.updateUserById(user.id, {
    app_metadata: { role },
  })

  if (error) throw error
  return data
})

================
File: apps/main-app/server/api/feature/[action].ts
================
import { serverSupabaseClient, serverSupabaseUser } from '#supabase/server'

export default defineEventHandler(async (event) => {
  const client = await serverSupabaseClient(event)
  const user = await serverSupabaseUser(event)
  const action = event.context.params?.action

  if (!user) {
    throw createError({
      statusCode: 401,
      message: 'Unauthorized',
    })
  }

  switch (action) {
    case 'list': {
      const { data: features, error: listError } = await client
        .from('feature_requests')
        .select('*')
        .order('priority')

      if (listError) throw createError({ statusCode: 500, message: listError.message })
      return features
    }

    case 'rank': {
      const body = await readBody(event)
      const { rankings } = body

      const { error: rankError } = await client.from('feature_votes').upsert(
        {
          user_id: user.id,
          rankings: rankings,
          updated_at: new Date().toISOString(),
        },
        {
          onConflict: 'user_id',
        },
      )

      if (rankError) throw createError({ statusCode: 500, message: rankError.message })
      return { success: true }
    }

    default:
      throw createError({
        statusCode: 400,
        message: 'Invalid action',
      })
  }
})

================
File: apps/main-app/server/api/feedback/index.post.ts
================
import { serverSupabaseClient, serverSupabaseUser } from '#supabase/server'

export default defineEventHandler(async (event) => {
  const supabase = await serverSupabaseClient(event)
  const currentUser = await serverSupabaseUser(event)

  try {
    const body = await readBody(event)

    await supabase.from('feedbacks').insert({
      user_id: currentUser.id,
      ...body,
    })
  } catch (error: any) {
    return { message: error.message }
  }

  return { status: 200, message: 'Successfully submitted feedback' }
})

================
File: apps/main-app/server/api/feeds/index.ts
================
import type { H3Event } from 'h3'

interface Category {
  readonly id: string
  readonly feed_id: string
  readonly category_id: string
}

export default defineEventHandler(async (event: H3Event) => {
  const { addFeed } = usePages()
  if (event.method === 'POST') {
    try {
      const client = useSupabaseClient()
      const { name, selectedCategories, selectedSourceIds } = await readBody(event)
      const { profile } = useCurrentUser()

      if (profile?.id) {
        if (!name.trim()) {
          throw createError({
            statusCode: 400,
            message: 'Feed name is required',
          })
        }

        if (!selectedCategories.length && !selectedSourceIds.size) {
          throw createError({
            statusCode: 400,
            message: 'At least one category needs to be selected',
          })
        }

        // Get current folder count
        const { count } = await client
          .from('feeds')
          .select('*', { count: 'exact' })
          .eq('user_id', profile.id)

        // Validate feature limit
        await validateFeatureLimit(event, 'CUSTOM_FEEDS', count || 0)

        // Create feed
        const { data: feedData, error: feedError } = await client
          .from('feeds')
          .insert({ user_id: profile.id, name })
          .select('id')
          .single()

        if (feedError) throw feedError

        const feed_id = feedData.id

        // Insert categories
        if (selectedCategories.length) {
          const { error: categoriesError } = await client.from('feed_categories').insert(
            selectedCategories.map((category: Category) => ({
              feed_id,
              category_id: category.id,
            })),
          )

          if (categoriesError) throw categoriesError
        }

        // Insert sources
        if (selectedSourceIds.size) {
          const { error: sourcesError } = await client.from('feed_sources').insert(
            Array.from(selectedSourceIds).map((companyId) => ({
              feed_id,
              content_source_id: companyId,
            })),
          )

          if (sourcesError) throw sourcesError
        }
        addFeed(feed_id, name.value)

        return { feed_id, name }
      }
    } catch (error: any) {
      console.error('Feeds API Error:', err)
      throw createError({
        statusCode: err.statusCode || 500,
        message: err.message || 'Internal server error',
      })
    }
  }
})

================
File: apps/main-app/server/api/folders/[id].delete.ts
================
// server/api/folders/[id].delete.ts
import type { H3Event } from 'h3'
import { serverSupabaseUser, serverSupabaseClient } from '#supabase/server'

export default defineEventHandler(async (event: H3Event) => {
  try {
    const user = await serverSupabaseUser(event)
    if (!user) {
      throw createError({ statusCode: 401, message: 'Unauthorized' })
    }

    const supabase = await serverSupabaseClient(event)
    const id = getRouterParam(event, 'id')
    const body = await readBody(event)
    const { strategy, defaultFolderId } = body as {
      strategy: 'delete_all' | 'move_to_default'
      defaultFolderId?: string
    }

    // First try to update/delete bookmarks
    if (strategy === 'delete_all') {
      const { error: deleteError } = await supabase
        .from('bookmarks')
        .delete()
        .eq('folder_id', id)
        .eq('user_id', user.id)

      if (deleteError) {
        console.error('Delete bookmarks error:', deleteError)
        throw deleteError
      }
    } else {
      const { error: updateError } = await supabase
        .from('bookmarks')
        .update({ folder_id: defaultFolderId })
        .eq('folder_id', id)
        .eq('user_id', user.id)

      if (updateError) {
        console.error('Update bookmarks error:', updateError)
        throw updateError
      }
    }

    // Then delete the folder
    const { error: folderError } = await supabase
      .from('bookmark_folders')
      .delete()
      .eq('id', id)
      .eq('user_id', user.id)

    if (folderError) {
      console.error('Delete folder error:', folderError)
      throw folderError
    }

    return { success: true }
  } catch (err) {
    console.error('Folder Delete Error:', err)
    throw createError({
      statusCode: err.statusCode || 500,
      message: err.message || 'Internal server error',
    })
  }
})

================
File: apps/main-app/server/api/folders/[id].patch.ts
================
// server/api/folders/[id].patch.ts
import type { H3Event } from 'h3'
import { serverSupabaseUser, serverSupabaseClient } from '#supabase/server'

export default defineEventHandler(async (event: H3Event) => {
  try {
    const user = await serverSupabaseUser(event)
    if (!user) {
      throw createError({ statusCode: 401, message: 'Unauthorized' })
    }

    const supabase = await serverSupabaseClient(event)
    const id = event.context.params.id
    const updates = await readBody(event)

    // Validate updates
    if (updates.name !== undefined && !updates.name.trim()) {
      throw createError({
        statusCode: 400,
        message: 'Folder name cannot be empty',
      })
    }

    const { data, error } = await supabase
      .from('bookmark_folders')
      .update(updates)
      .eq('id', id)
      .eq('user_id', user.id)
      .select()
      .single()

    if (error) throw error
    return { data }
  } catch (err) {
    console.error('Folder Update Error:', err)
    throw createError({
      statusCode: err.statusCode || 500,
      message: err.message || 'Internal server error',
    })
  }
})

================
File: apps/main-app/server/api/folders/index.ts
================
// server/api/folders/index.ts
import type { H3Event } from 'h3'
import { serverSupabaseUser, serverSupabaseClient } from '#supabase/server'

export default defineEventHandler(async (event: H3Event) => {
  try {
    const user = await serverSupabaseUser(event)
    if (!user) {
      throw createError({ statusCode: 401, message: 'Unauthorized: No user object' })
    }

    const supabase = await serverSupabaseClient(event)

    // GET /api/folders
    if (event.method === 'GET') {
      const { data, error } = await supabase
        .from('bookmark_folders')
        .select('*')
        .eq('user_id', user.id)
        .order('position')

      if (error) throw error
      return { data }
    }

    // POST /api/folders
    if (event.method === 'POST') {
      const body = await readBody(event)

      // Validate required fields
      if (!body.name?.trim()) {
        throw createError({
          statusCode: 400,
          statusMessage: 'Folder name is required',
        })
      }

      // Get current folder count
      const { count } = await supabase
        .from('bookmark_folders')
        .select('*', { count: 'exact' })
        .eq('user_id', user.id)

      // Validate feature limit
      await validateFeatureLimit(event, 'BOOKMARK_FOLDERS', count || 0)

      // Insert new folder
      const { data, error: insertError } = await supabase
        .from('bookmark_folders')
        .insert({
          ...body,
          user_id: user.id,
          position: count || 0,
        })
        .select()
        .single()

      if (insertError) throw insertError
      return { data }
    }

    throw createError({ statusCode: 405, statusMessage: 'Method not allowed' })
  } catch (err) {
    console.error('Folder API Error:', err)
    throw createError({
      statusCode: err?.statusCode || 500,
      statusMessage: err?.message || 'Internal server error',
    })
  }
})

================
File: apps/main-app/server/api/payment/[provider]/create-order.ts
================
// server/api/payment/[provider]/create-order.post.ts
import { useRuntimeConfig } from '#imports'
import { generateServerToken } from '~/server/utils/generateServerToken'

export default defineEventHandler(async (event) => {
  const provider = getRouterParam(event, 'provider')
  const body = await readBody(event)
  const config = useRuntimeConfig().public

  console.log('provider:', provider)

  let backendUrl = config.scraperUrl
  if (provider === 'razorpay') {
    console.log('provider is razorpay')
    backendUrl = backendUrl.concat('/api/customer/subscription/create')
  } else if (provider === 'stripe') {
    backendUrl = backendUrl.concat('/api/customer/subscription/create')
  } else {
    throw createError({
      statusCode: 400,
      statusMessage: 'Invalid payment provider',
    })
  }

  console.log('backendUrl:', backendUrl)

  const token = generateServerToken()

  try {
    const response = await $fetch(backendUrl, {
      method: 'POST',
      body,
      headers: {
        Authorization: `Bearer ${token}`,
      },
    })

    return response
  } catch (error: any) {
    console.error(`Error creating order with ${provider}:`, error)
    throw createError({
      statusCode: 500,
      statusMessage: `Failed to create order with ${provider}`,
    })
  }
})

================
File: apps/main-app/server/api/payment/[provider]/subscription.get.ts
================
import { useRuntimeConfig } from '#imports'
import { generateServerToken } from '~/server/utils/generateServerToken'

export default defineEventHandler(async (event) => {
  const provider = getRouterParam(event, 'provider')
  const config = useRuntimeConfig().public

  const backendUrl = config.scraperUrl
  if (provider === 'razorpay') {
    backendUrl.concat('/api/customer/subscription')
  } else if (provider === 'stripe') {
    backendUrl.concat('/api/customer/subscription')
  } else {
    throw createError({
      statusCode: 400,
      statusMessage: 'Invalid payment provider',
    })
  }

  const token = generateServerToken()

  try {
    const response = await $fetch(backendUrl, {
      headers: {
        Authorization: `Bearer ${token}`,
      },
    })
    return response
  } catch (error: any) {
    console.error(`Error fetching subscription from ${provider}:`, error)
    throw createError({
      statusCode: 500,
      statusMessage: `Failed to fetch subscription from ${provider}`,
    })
  }
})

================
File: apps/main-app/server/api/payment/[provider]/verify-payment.post.ts
================
// server/api/payment/[provider]/verify-payment.post.ts
import { useRuntimeConfig } from '#imports'
import { generateServerToken } from '~/server/utils/generateServerToken'

export default defineEventHandler(async (event) => {
  const provider = getRouterParam(event, 'provider')
  const body = await readBody(event)
  const config = useRuntimeConfig().public

  const backendUrl = config.scraperUrl
  if (provider === 'razorpay') {
    backendUrl.concat('/api/customer/subscription/verify-payment')
  } else if (provider === 'stripe') {
    backendUrl.concat('/api/customer/subscription/verify-payment')
  } else {
    throw createError({
      statusCode: 400,
      statusMessage: 'Invalid payment provider',
    })
  }

  const token = generateServerToken()

  try {
    const response = await $fetch(backendUrl, {
      method: 'POST',
      body,
      headers: {
        Authorization: `Bearer ${token}`,
      },
    })
    return response
  } catch (error: any) {
    console.error(`Error verifying payment with ${provider}:`, error)
    throw createError({
      statusCode: 500,
      statusMessage: `Failed to verify payment with ${provider}`,
    })
  }
})

================
File: apps/main-app/server/api/users/metrics/[action].ts
================
// server/api/users/metrics/[action].ts
import { serverSupabaseClient, serverSupabaseUser } from '#supabase/server'

export default defineEventHandler(async (event) => {
  const client = await serverSupabaseClient(event)
  const user = await serverSupabaseUser(event)
  const action = event.context.params?.action

  if (!user) {
    throw createError({
      statusCode: 401,
      message: 'Unauthorized',
    })
  }

  try {
    switch (action) {
      case 'get':
        return await getUserMetrics(client, user.id)

      case 'track-source-visit': {
        const { newsId, timeSpent } = await readBody(event)
        return await trackSourceVisit(client, user.id, newsId, timeSpent)
      }

      case 'get-achievements':
        return await getAchievements(client, user.id)

      case 'update-title': {
        const { title } = await readBody(event)
        return await updateTitle(client, user.id, title)
      }

      case 'get-reading-time': {
        const { newsId: id } = await readBody(event)
        return await getReadingTime(client, user.id, id)
      }

      default:
        throw createError({
          statusCode: 400,
          message: 'Invalid action',
        })
    }
  } catch (error: any) {
    console.error(`Metrics API error (${action}):`, error)
    throw createError({
      statusCode: 500,
      message: 'Failed to process metrics action',
    })
  }
})

async function getUserMetrics(client: any, userId: string) {
  // Get user metrics, they should already exist due to our DB triggers
  const { data: metrics, error } = await client
    .from('user_metrics')
    .select('*')
    .eq('user_id', userId)
    .single()

  if (error) throw error

  // Get today's activity for real-time tracking
  const today = new Date().toISOString().split('T')[0]
  const { data: todayVotes } = await client
    .from('votes')
    .select('created_at, vote_type')
    .eq('user_id', userId)
    .gte('created_at', `${today}T00:00:00`)
    .order('created_at', { ascending: false })

  const { data: todayBookmarks } = await client
    .from('bookmarks')
    .select('created_at')
    .eq('user_id', userId)
    .gte('created_at', `${today}T00:00:00`)

  return {
    ...metrics,
    today_activity: {
      votes: todayVotes || [],
      bookmarks: todayBookmarks || [],
    },
  }
}

async function trackSourceVisit(client: any, userId: string, newsId: string, timeSpent: number) {
  // First record the visit
  const { error: visitError } = await client.from('content_source_visits').insert({
    user_id: userId,
    content_id: newsId,
  })

  if (visitError) throw visitError

  // Update reading time if provided
  if (timeSpent) {
    const { error: timeError } = await client
      .from('user_metrics')
      .update({
        total_reading_time: timeSpent,
      })
      .eq('user_id', userId)

    if (timeError) throw timeError
  }

  return await getUserMetrics(client, userId)
}

async function getAchievements(client: any, userId: string) {
  const { data: metrics, error } = await client
    .from('user_metrics')
    .select('achievements')
    .eq('user_id', userId)
    .single()

  if (error) throw error

  // Get completed achievements count
  const completedCount = countCompletedAchievements(metrics.achievements)

  return {
    achievements: metrics.achievements,
    stats: {
      completed: completedCount,
      total: getTotalAchievements(metrics.achievements),
    },
  }
}

async function updateTitle(client: any, userId: string, newTitle: string) {
  const { data: metrics, error } = await client
    .from('user_metrics')
    .select('titles')
    .eq('user_id', userId)
    .single()

  if (error) throw error

  // Verify title is unlocked
  if (!metrics.titles.unlocked_titles.includes(newTitle)) {
    throw createError({
      statusCode: 400,
      message: 'Title not unlocked',
    })
  }

  const { data: updatedMetrics, error: updateError } = await client
    .from('user_metrics')
    .update({
      titles: {
        ...metrics.titles,
        current_title: newTitle,
      },
    })
    .eq('user_id', userId)
    .select()
    .single()

  if (updateError) throw updateError
  return updatedMetrics
}

async function getReadingTime(client: any, userId: string, newsId: string) {
  const { data, error } = await client
    .from('source_visits')
    .select('created_at')
    .eq('user_id', userId)
    .eq('content_id', newsId)
    .order('created_at', { ascending: false })
    .limit(1)

  if (error) throw error

  return {
    lastVisit: data?.[0]?.created_at || null,
  }
}

// Utility functions
function updateFavoriteSources(currentSources: string[], newSource: string) {
  const sourceList = [...(currentSources || [])]
  if (!sourceList.includes(newSource)) {
    sourceList.push(newSource)
  }
  return sourceList.slice(-5) // Keep only last 5 sources
}

function countCompletedAchievements(achievements: any) {
  let count = 0
  for (const category in achievements) {
    for (const achievement in achievements[category]) {
      if (achievements[category][achievement] === true) {
        count++
      }
    }
  }
  return count
}

function getTotalAchievements(achievements: any) {
  let count = 0
  for (const category in achievements) {
    count += Object.keys(achievements[category]).length
  }
  return count
}

================
File: apps/main-app/server/api/users/metrics.ts
================
// server/api/users/metrics.ts
import { serverSupabaseClient, serverSupabaseUser } from '#supabase/server'

export default defineEventHandler(async (event) => {
  const client = await serverSupabaseClient(event)
  const user = await serverSupabaseUser(event)

  if (!user) {
    throw createError({
      statusCode: 401,
      message: 'Unauthorized',
    })
  }

  try {
    // Get all user votes first
    const { data: votes, error: votesError } = await client
      .from('votes')
      .select('*')
      .eq('user_id', user.id)
      .eq('content_type', 'news')
      .order('created_at', { ascending: false })

    if (votesError) throw votesError

    // If we have votes, get the corresponding news items
    if (votes && votes.length > 0) {
      const newsIds = votes.map((vote) => vote.content_id)

      // Get news items for accuracy calculation
      const { data: newsItems, error: newsError } = await client
        .from('news')
        .select('id, score')
        .in('id', newsIds)

      if (newsError) throw newsError

      // Create a lookup map for news scores
      const newsScores =
        newsItems?.reduce(
          (acc, news) => {
            acc[news.id] = news.score
            return acc
          },
          {} as Record<string, number>,
        ) || {}

      // Combine votes with news scores
      const votesWithScores = votes.map((vote) => ({
        ...vote,
        news_score: newsScores[vote.content_id] || 0,
      }))

      return {
        votes: votesWithScores,
        streakData: votes, // For streak calculation
        // Group votes by date for easier processing
        votesByDate: votes.reduce(
          (acc, vote) => {
            const date = new Date(vote.created_at).toISOString().split('T')[0]
            if (!acc[date]) acc[date] = []
            acc[date].push(vote)
            return acc
          },
          {} as Record<string, any[]>,
        ),
      }
    }

    return {
      votes: [],
      streakData: [],
      votesByDate: {},
    }
  } catch (error: any) {
    console.error('Get user metrics error:', error)
    throw createError({
      statusCode: 500,
      message: 'Failed to get user metrics',
    })
  }
})

================
File: apps/main-app/server/api/users/update.post.ts
================
import { serverSupabaseClient } from '#supabase/server'

export default defineEventHandler(async (event) => {
  try {
    const body = await readBody(event)

    const supabase = await serverSupabaseClient(event)

    const { data } = await supabase.auth.getUser()
    const { user } = data

    if (user && user.email) {
      const response = await supabase.from('user_profiles').update(body).eq('id', user.id)

      if (response.error) {
        return {
          error: response.error,
          data: [],
          status: 500,
          message: 'Error Updating User',
        }
      } else {
        return {
          error: null,
          data: [],
          status: 200,
          message: 'User Updated',
        }
      }
    }

    return {
      error: null,
      data: [],
      status: 500,
      message: 'Something went wrong',
    }
  } catch (error: any) {
    return {
      error,
      data: [],
      status: 500,
      message: 'Error',
    }
  }
})

================
File: apps/main-app/server/api/votes/[contentType]/[id].get.ts
================
import { serverSupabaseClient, serverSupabaseUser } from '#supabase/server'

export default defineEventHandler(async (event) => {
  const client = await serverSupabaseClient(event)
  const user = await serverSupabaseUser(event)

  if (!user) {
    throw createError({
      statusCode: 401,
      message: 'Unauthorized',
    })
  }

  const { contentType, id } = event.context.params

  try {
    const { data, error } = await client
      .from('votes')
      .select('vote_type')
      .match({
        content_type: contentType,
        content_id: id,
        user_id: user.id,
      })
      .single()

    if (error && error.code !== 'PGRST116') throw error

    return {
      voteType: data?.vote_type || null,
    }
  } catch (error: any) {
    console.error('Get vote error:', error)
    throw createError({
      statusCode: 500,
      message: 'Failed to get vote status',
    })
  }
})

================
File: apps/main-app/server/api/votes/[contentType]/[id].post.ts
================
import { serverSupabaseClient, serverSupabaseUser } from '#supabase/server'

export default defineEventHandler(async (event) => {
  const client = await serverSupabaseClient(event)
  const user = await serverSupabaseUser(event)

  if (!user) {
    throw createError({
      statusCode: 401,
      message: 'Unauthorized',
    })
  }

  const { contentType, id } = getRouterParams(event)
  const { voteType } = await readBody(event)

  // Validate content type (only news for now)
  if (contentType !== 'news') {
    throw createError({
      statusCode: 400,
      message: 'Invalid content type',
    })
  }

  // Validate vote type
  if (![1, -1].includes(voteType)) {
    throw createError({
      statusCode: 400,
      message: 'Invalid vote type',
    })
  }

  try {
    // Handle vote removal if same vote type is sent
    const { data: existingVote } = await client
      .from('votes')
      .select('vote_type')
      .match({
        content_type: contentType,
        content_id: id,
        user_id: user.id,
      })
      .single()

    if (existingVote?.vote_type === voteType) {
      // Remove the vote if it's the same type
      const { error } = await client.from('votes').delete().match({
        content_type: contentType,
        content_id: id,
        user_id: user.id,
      })

      if (error) throw error
      return { success: true, action: 'removed' }
    }

    // Insert or update the vote
    const { error } = await client.from('votes').upsert(
      {
        content_type: contentType,
        content_id: id,
        user_id: user.id,
        vote_type: voteType,
      },
      {
        onConflict: 'content_type,content_id,user_id',
      },
    )

    if (error) throw error
    return { success: true, action: 'voted' }
  } catch (error: any) {
    console.error('Vote error:', error)
    throw createError({
      statusCode: 500,
      message: 'Failed to process vote',
    })
  }
})

================
File: apps/main-app/server/api/votes/user/[voteType].get.ts
================
import { serverSupabaseClient, serverSupabaseUser } from '#supabase/server'

export default defineEventHandler(async (event) => {
  const client = await serverSupabaseClient(event)
  const user = await serverSupabaseUser(event)

  if (!user) {
    throw createError({
      statusCode: 401,
      message: 'Unauthorized',
    })
  }

  const voteType = parseInt(event.context.params.voteType) // 1 for upvotes, -1 for downvotes

  if (![1, -1].includes(voteType)) {
    throw createError({
      statusCode: 400,
      message: 'Invalid vote type',
    })
  }

  try {
    const { data, error } = await client
      .from('votes')
      .select('content_id')
      .eq('content_type', 'news')
      .eq('user_id', user.id)
      .eq('vote_type', voteType)

    if (error) throw error

    // Get the actual news items
    const { data: news, error: newsError } = await client
      .from('news')
      .select('*')
      .in(
        'id',
        data.map((v) => v.content_id),
      )
      .order('created_at', { ascending: false })

    if (newsError) throw newsError

    return news
  } catch (error: any) {
    console.error('Get voted news error:', error)
    throw createError({
      statusCode: 500,
      message: 'Failed to get voted news',
    })
  }
})

================
File: apps/main-app/server/api/votes/user.get.ts
================
import { serverSupabaseClient, serverSupabaseUser } from '#supabase/server'

export default defineEventHandler(async (event) => {
  const client = await serverSupabaseClient(event)
  const user = await serverSupabaseUser(event)

  if (!user) {
    throw createError({
      statusCode: 401,
      message: 'Unauthorized',
    })
  }

  try {
    const { data, error } = await client
      .from('votes')
      .select('content_id, vote_type')
      .eq('content_type', 'news')
      .eq('user_id', user.id)

    if (error) throw error

    // Transform into a more efficient lookup object
    const voteLookup = data.reduce(
      (acc, vote) => {
        acc[vote.content_id] = vote.vote_type
        return acc
      },
      {} as Record<string, number>,
    )

    return {
      votes: voteLookup,
    }
  } catch (error: any) {
    console.error('Get votes error:', error)
    throw createError({
      statusCode: 500,
      message: 'Failed to get votes',
    })
  }
})

================
File: apps/main-app/server/api/webhook/database.ts
================
export default defineEventHandler(async (event) => {
  const data = await readBody(event)

  console.log('SUPABASE DB WEBHOOK EVENT', data)
})

================
File: apps/main-app/server/api/upload.ts
================
import crypto from 'crypto'
import { defineEventHandler, createError } from 'h3'
import { PDFDocument } from 'pdf-lib'
import lame from 'node-lame'
import ffmpeg from 'fluent-ffmpeg'
import { serverSupabaseClient } from '#supabase/server'

// Base optimizer interface
interface FileOptimizer {
  optimize(
    buffer: Buffer,
    options: any,
  ): Promise<{
    data: Buffer
    extension: string
    mimeType: string
  }>
}

// Image optimizer using Sharp
// class ImageOptimizer implements FileOptimizer {
//   async optimize(buffer: Buffer, options: any) {
//     const { maxWidth = 1920, maxHeight = 1080, quality = 80 } = options
//     const optimized = await sharp(buffer)
//       .resize(maxWidth, maxHeight, { fit: 'inside', withoutEnlargement: true })
//       .webp({ quality })
//       .toBuffer()
//     return { data: optimized, extension: 'webp', mimeType: 'image/webp' }
//   }
// }

// PDF optimizer using pdf-lib
class PDFOptimizer implements FileOptimizer {
  async optimize(buffer: Buffer, options: any) {
    const pdfDoc = await PDFDocument.load(buffer)
    // Implement PDF optimization logic here
    const optimized = await pdfDoc.save({ useObjectStreams: false })
    return { data: Buffer.from(optimized), extension: 'pdf', mimeType: 'application/pdf' }
  }
}

class VideoOptimizer implements FileOptimizer {
  async optimize(buffer: Buffer, options: any) {
    const {
      maxWidth = 1920,
      maxHeight = 1080,
      videoBitrate = '1000k',
      audioBitrate = '128k',
    } = options

    return new Promise((resolve, reject) => {
      ffmpeg()
        .input(buffer)
        .videoFilters(
          `scale='min(${maxWidth},iw)':min'(${maxHeight},ih)':force_original_aspect_ratio=decrease`,
        )
        .videoBitrate(videoBitrate)
        .audioBitrate(audioBitrate)
        .toFormat('mp4')
        .on('end', (stdout, stderr) => {
          resolve({ data: stdout, extension: 'mp4', mimeType: 'video/mp4' })
        })
        .on('error', reject)
        .pipe()
    })
  }
}

class AudioOptimizer implements FileOptimizer {
  async optimize(buffer: Buffer, options: any) {
    const { bitrate = 128 } = options

    const encoder = new lame.Lame({
      output: 'buffer',
      bitrate: bitrate,
    }).setBuffer(buffer)

    const encodedBuffer = await encoder.encode()
    return { data: encodedBuffer, extension: 'mp3', mimeType: 'audio/mpeg' }
  }
}

// Optimizer factory
class OptimizerFactory {
  private optimizers: Map<string, FileOptimizer> = new Map()

  register(mimeType: string, optimizer: FileOptimizer) {
    this.optimizers.set(mimeType, optimizer)
  }

  getOptimizer(mimeType: string): FileOptimizer | undefined {
    return this.optimizers.get(mimeType)
  }
}

// Create and configure the optimizer factory
const optimizerFactory = new OptimizerFactory()
// optimizerFactory.register('image', new ImageOptimizer())
optimizerFactory.register('application/pdf', new PDFOptimizer())
optimizerFactory.register('video', new VideoOptimizer())
optimizerFactory.register('audio', new AudioOptimizer())

export default defineEventHandler(async (event) => {
  console.log('File optimization and upload eventHandler')
  const form = await readMultipartFormData(event)
  if (!form?.length) {
    throw createError({ statusCode: 400, statusMessage: 'No form data provided' })
  }

  const userId = form.find((item) => item.name === 'userId')?.data.toString()
  const fileType = form.find((item) => item.name === 'fileType')?.data.toString()
  const bucket = form.find((item) => item.name === 'bucket')?.data.toString()
  const path = form.find((item) => item.name === 'path')?.data.toString()
  const optimizationOptions = JSON.parse(
    form.find((item) => item.name === 'optimizationOptions')?.data.toString() || '{}',
  )

  const file = form.find((item) => item.name === 'file')
  if (!file) {
    throw createError({ statusCode: 400, statusMessage: 'No file provided' })
  }

  if (!userId || !fileType || !bucket || !path) {
    throw createError({ statusCode: 400, statusMessage: 'Missing required parameters' })
  }

  const fileName = `${fileType}-${crypto.randomUUID()}`
  const mimeType = file.type || 'application/octet-stream'

  console.log('Processing file:', userId, fileType, fileName, mimeType)

  try {
    let optimizedFile: Buffer
    let finalExtension: string
    let finalMimeType: string

    const optimizerKey = mimeType.split('/')[0]
    const optimizer =
      optimizerFactory.getOptimizer(optimizerKey) || optimizerFactory.getOptimizer(mimeType)

    if (optimizer) {
      const result = await optimizer.optimize(file.data, optimizationOptions)
      optimizedFile = result.data
      finalExtension = result.extension
      finalMimeType = result.mimeType
    } else {
      console.log('No optimizer found for this file type, uploading as-is')
      optimizedFile = file.data
      finalExtension = mimeType.split('/')[1]
      finalMimeType = mimeType
    }

    const client = await serverSupabaseClient(event)
    const { error } = await client.storage
      .from(bucket)
      .upload(`${path}/${fileName}.${finalExtension}`, optimizedFile, {
        contentType: finalMimeType,
        cacheControl: '3600',
        upsert: true,
      })

    if (error) {
      throw createError({ statusCode: 500, statusMessage: error.message })
    }

    // If this is a profile-related upload, update the user_profiles table
    if (bucket === 'user-profiles' && ['avatar', 'cover-photo'].includes(fileType)) {
      const { error: updateError, data } = await client
        .from('user_profiles')
        .update({ [fileType]: `${fileName}.${finalExtension}` })
        .eq('id', userId)
        .select()

      if (updateError) {
        console.error('Error updating user profile:', updateError)
      } else {
        console.log('User profile updated:', data)
      }
    }

    return {
      statusCode: 200,
      body: JSON.stringify({
        message: 'File successfully uploaded and optimized',
        fileName: `${fileName}.${finalExtension}`,
      }),
    }
  } catch (error: any) {
    console.error('Error processing file:', error)
    throw createError({ statusCode: 500, statusMessage: error.message })
  }
})

================
File: apps/main-app/server/middleware/feature-limit.ts
================
import { handleFeatureLimitError } from '../utils/errors'
import { validateFeatureLimit } from '../utils/featureLimits'
import { serverSupabaseUser, serverSupabaseClient } from '#supabase/server'

export default defineEventHandler(async (event) => {
  // Only check POST requests
  if (event.method !== 'POST') return

  // Get the path to determine which feature to check
  const path = getRequestPath(event)

  // Map endpoints to features
  const featureMap: Record<string, string> = {
    '/api/bookmarks': 'BOOKMARKS',
    '/api/folders': 'BOOKMARK_FOLDERS',
    '/api/feeds': 'CUSTOM_FEEDS',
  }

  const feature = featureMap[path]
  if (!feature) return // Not a feature-limited endpoint

  try {
    const user = await serverSupabaseUser(event)

    if (!user) {
      throw createError({
        statusCode: 401,
        message: 'Unauthorized',
      })
    }

    const supabase = await serverSupabaseClient(event)

    // Get the table name from the path
    let table = path.split('/')[2] // 'bookmarks' or 'folders'

    if (table === 'folders') {
      table = 'bookmark_folders'
    }

    // Check current count
    const { count } = await supabase
      .from(table)
      .select('*', { count: 'exact' })
      .eq('user_id', user.id)

    await validateFeatureLimit(event, feature, count ?? 0)
  } catch (error: any) {
    handleFeatureLimitError(error: any)
  }
})

================
File: apps/main-app/shared/constants.ts
================
export const FEATURES = {
  BOOKMARK_FOLDERS: {
    name: 'Bookmark Folders',
    limit: {
      free: 3,
      pro: -1, // unlimited
    },
    description: 'Organize your bookmarks into folders',
  },
  BOOKMARKS: {
    name: 'Bookmarks',
    limit: {
      free: 100,
      pro: -1,
    },
    description: 'Save articles for later',
  },
  CUSTOM_FOLDER_COLORS: {
    name: 'Custom Folder Colors',
    limit: {
      free: 0,
      pro: -1,
    },
    description: 'Personalize your folders with custom colors',
    comingSoon: true,
  },
  CUSTOM_FEEDS: {
    name: 'Custom Feed',
    limit: {
      free: 0,
      pro: -1,
    },
    description: 'Personalize your feeds',
  },
} as const

================
File: apps/main-app/app.vue
================
<script setup lang="ts">
const catTagStore = useCategoryTagStore()
const currentUser = useCurrentUser()
const folderStore = useFolderStore()
const bookmarkStore = useBookmarkStore()

onMounted(async () => {
  document.documentElement.classList.add('dark')
  try {
    await Promise.all([folderStore.fetchFolders(), bookmarkStore.fetchBookmarks()])
    await bookmarkStore.fetchBookmarkCounts() // Add error handling here
  } catch (error: any) {
    console.error('Error initializing data:', error)
  }
})

useHead({
  htmlAttrs: {
    lang: 'en',
  },
  meta: [
    {
      name: 'viewport',
      content: 'width=device-width, initial-scale=1',
    },
  ],
  link: [
    {
      rel: 'icon',
      type: 'image/png',
      href: '/favicon.png',
    },
  ],
})
</script>

<template>
  <div class="h-full w-full">
    <NuxtLoadingIndicator />
    <Head>
      <link
        rel="manifest"
        href="/manifest.webmanifest"
      />
    </Head>
    <NuxtPwaAssets />
    <NuxtLayout>
      <NuxtPage />
    </NuxtLayout>
    <PrimeToast position="bottom-right" />
    <ReferralCapture />
    <!-- <Notification /> -->
  </div>
</template>

<style>
html {
  margin: 0;
  padding: 0;
}

#__nuxt {
  width: 100%;
  height: 100%;
  padding: 0;
  margin: 0;
}

.layout-enter-active,
.layout-leave-active {
  transition: all 0.4s;
}

.layout-enter-from,
.layout-leave-to {
  opacity: 0;
  filter: blur(1rem);
}
</style>

================
File: apps/main-app/nuxt.config.ts
================
import { fileURLToPath } from 'url'
import { dirname, join, resolve } from 'path'
import { defineNuxtConfig } from 'nuxt/config'
import sharedConfig from '../../shared-runtime.config'

const currentDir = dirname(fileURLToPath(import.meta.url))

export default defineNuxtConfig({
  workspaceDir: '../../',
  srcDir: '.',
  extends: [
    '../../layers/base',
    '../../layers/auth',
    '../../layers/crud',
    '../../layers/advert',
    '../../layers/referral',
  ],

  vite: {
    optimizeDeps: {
      exclude: ['fsevents'],
    },
  },

  // build: {
  //   transpile: ['@formbricks/js'],
  // },

  debug: true,

  modules: [
    'nuxt-tiptap-editor',
    '@nuxt/devtools',
    '@vueuse/nuxt',
    '@nuxt/image',
    '@pinia/nuxt',
    '@nuxt/icon',
    '@nuxt/eslint',
    '@nuxtjs/tailwindcss',
    '@nuxtjs/mdc',
    '@primevue/nuxt-module',
    '@vite-pwa/nuxt',
    '@nuxt/test-utils/module',
  ],

  experimental: {
    asyncContext: true,
  },

  tailwindcss: {
    configPath: `${currentDir}/tailwind.config.ts`,
    cssPath: [`${currentDir}/assets/css/tailwind.css`, { injectPosition: 0 }],
    exposeConfig: true,
    viewer: true,
  },

  primevue: {
    importPT: { from: resolve(currentDir, '../../theme/index.js') },
    autoImport: true,
    components: {
      prefix: 'Prime',
      include: '*',
      exclude: ['Editor'],
    },

    composables: {
      include: '*',
    },

    options: {
      ripple: true,
      unstyled: true,
      theme: {
        options: {
          cssLayer: true,
        },
      },
    },
  },

  image: {
    format: ['webp', 'jpg'],
  },

  tiptap: {
    prefix: 'Tiptap',
  },

  pwa: {
    registerType: 'autoUpdate',
    manifest: false,
    workbox: {
      navigateFallback: '/offline',
      globPatterns: ['**/*.{js,css,html,ico,png,svg}'],
      cleanupOutdatedCaches: true,
      runtimeCaching: [
        {
          urlPattern: /^\/api\//,
          handler: 'NetworkFirst',
        },
      ],
    },
    client: {
      installPrompt: true,
    },
  },

  alias: {
    '#shared': fileURLToPath(new URL('./shared', import.meta.url)),
  },

  // Add proper MIME type handling
  nitro: {
    experimental: {
      asyncContext: true,
    },
    routeRules: {
      '/manifest.webmanifest': {
        headers: {
          'Content-Type': 'application/manifest+json',
          'Cache-Control': 'public, max-age=0',
        },
      },
      '/api/bookmarks/**': {
        appMiddleware: ['feature-limit'],
      },
      '/api/folders/**': {
        appMiddleware: ['feature-limit'],
      },
      '/api/feeds/**': {
        appMiddleware: ['feature-limit'],
      },
    },
    alias: {
      '#shared': fileURLToPath(new URL('./shared', import.meta.url)),
    },
  },

  runtimeConfig: {
    ...sharedConfig.runtimeConfig.private,
    serviceName: 'main-app',
    public: {
      ...sharedConfig.runtimeConfig.public,
      serviceName: 'main-app',
    },
  },
})

================
File: apps/monitoring-dashboard/server/api/logs.get.ts
================
// server/api/logs.get.ts

import { defineEventHandler } from 'h3'
import { InfluxDB } from '@influxdata/influxdb-client'

export default defineEventHandler(async (event) => {
  const config = useRuntimeConfig()

  // Create InfluxDB client
  const influxDB = new InfluxDB({
    url: config.influxUrl,
    token: config.influxToken,
  })

  const queryApi = influxDB.getQueryApi(config.influxOrg)

  // Extract query parameters if needed
  const queryParams = getQuery(event)

  // Build InfluxDB query
  const query = `from(bucket: "${config.influxBucket}")
    |> range(start: -1h)
    |> filter(fn: (r) => r._measurement == "logs")`

  const data = []
  await queryApi.collectRows(query, {
    next: (row) => data.push(row),
    error: (error: any) => console.error(error: any),
    complete: () => console.log('Query completed'),
  })

  return data
})

================
File: apps/website/components/landing/LandingFeatures.vue
================
<script setup lang="ts">
import { ref, onMounted } from 'vue'
import { gsap } from 'gsap'
import { useId } from '#app'

const features = [
  {
    id: useId(),
    title: '24/7 News Coverage',
    subtitle: '20+ trusted space news sources in one place',
    icon: 'mdi:earth',
    metrics: ['Live updates', 'Global coverage'],
  },
  {
    id: useId(),
    title: 'Community-Driven',
    subtitle: 'Quality content rises to the top',
    icon: 'mdi:thumb-up',
    metrics: ['Upvote/Downvote', 'Trending news'],
  },
  {
    id: useId(),
    title: 'Custom Categories',
    subtitle: 'Follow what interests you',
    icon: 'mdi:tune-vertical',
    metrics: ['Personalized feed', 'Topic filters'],
  },
  {
    id: useId(),
    title: 'Smart Bookmarks',
    subtitle: 'Save and organize your reading list',
    icon: 'mdi:bookmark-multiple',
    metrics: ['Custom folders', 'Quick access'],
  },
]

onMounted(() => {
  gsap.from('.feature-card', {
    y: 40,
    opacity: 0,
    duration: 0.8,
    stagger: 0.2,
    ease: 'power2.out',
    scrollTrigger: {
      trigger: '.features-grid',
      start: 'top bottom-=100px',
      toggleActions: 'play none none reverse',
    },
  })
})

const { loginURL, authURL } = useRuntimeConfig().public
</script>

<template>
  <section>
    <LandingGlass
      gradient="blue"
      intensity="low"
      class="mb-24"
      isolate-content
    >
      <div class="py-8 md:py-12 space-y-8">
        <LandingTitle
          title="Your Space Hub"
          subtitle="All your space in one place"
          class="!pb-8"
        />

        <div class="features-grid grid grid-cols-1 md:grid-cols-2 gap-6">
          <div
            v-for="feature in features"
            :key="feature.id"
            class="feature-card"
          >
            <PrimeCard
              class="h-full bg-primary-900/30 border border-primary-900/50 hover:border-sky-500/30 transition-all duration-300"
            >
              <template #title>
                <div class="flex items-center space-x-3">
                  <div class="p-2 flex rounded-lg bg-sky-500/10">
                    <Icon
                      :name="feature.icon"
                      class="text-sky-400"
                      size="24"
                    />
                  </div>
                  <div>
                    <h3 class="text-lg font-medium text-white">{{ feature.title }}</h3>
                    <p class="text-sm text-gray-400">{{ feature.subtitle }}</p>
                  </div>
                </div>
              </template>

              <template #content>
                <div class="flex flex-wrap gap-2 mt-4">
                  <span
                    v-for="(metric, index) in feature.metrics"
                    :key="index"
                    class="px-3 py-1 rounded-full text-xs bg-sky-900/30 text-sky-300 border border-sky-900/50"
                  >
                    {{ metric }}
                  </span>
                </div>
              </template>
            </PrimeCard>
          </div>
        </div>
      </div>
    </LandingGlass>
    <div class="mt-6 flex justify-center">
      <NuxtLink
        :to="String(`${authURL}${loginURL}`)"
        external
        class="relative group"
      >
        <PrimeButton
          size="large"
          class="flex !text-2xl gap-4 min-w-[280px] relative z-10 bg-gradient-to-r from-primary-600 via-primary-500 to-primary-700 hover:from-primary-500 hover:via-primary-400 hover:to-primary-600 transition-all duration-300 text-lg shadow-lg shadow-primary-600/30 hover:shadow-primary-500/40 hover:-translate-y-0.5"
        >
          Start Exploring Today,
          <strong>
            It's Free
          </strong>
          <Icon
            name="mdi:rocket"
            size="48"
            class="text-white"
          />
        </PrimeButton>
        <div
          class="absolute inset-0 bg-gradient-to-r from-primary-600/20 to-primary-400/20 blur-xl group-hover:blur-2xl transition-all duration-300 z-0"
        ></div>
      </NuxtLink>
    </div>
  </section>
</template>

<style scoped>
@keyframes twinkle {
  0%,
  100% {
    opacity: 0.4;
  }
  50% {
    opacity: 1;
  }
}

@keyframes float {
  0%,
  100% {
    transform: translateY(0);
  }
  50% {
    transform: translateY(-4px);
  }
}

.animate-twinkle {
  animation: twinkle 2s ease-in-out infinite;
}

.animate-twinkle-delayed {
  animation: twinkle 2s ease-in-out infinite;
  animation-delay: 1s;
}

.animate-float {
  animation: float 3s ease-in-out infinite;
}

.animate-float-delayed {
  animation: float 3s ease-in-out infinite;
  animation-delay: 1.5s;
}
</style>

================
File: apps/website/composables/usePages.ts
================
import { ref } from 'vue'

export interface PageType {
  id: string
  label: string
  slug: string
  icon: string
  children?: PageType[]
  isExpanded?: boolean
}

export interface NavigationCategory {
  id: string
  label: string
  items: PageType[]
}

export interface BreadcrumbLink {
  to: string
  label: string
  ariaLabel: string
}

const UUID_REGEX = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i

const navigationCategories = ref([
  {
    id: 'main',
    label: 'Main',
    items: [
      {
        id: '1',
        label: 'Home',
        slug: '/',
        icon: 'material-symbols:home-rounded',
      },
    ],
  },
  {
    id: 'news',
    label: 'News',
    items: [
      {
        id: '2',
        label: 'Feed',
        slug: '/news',
        icon: 'mdi:newspaper-variant-outline',
      },
      {
        id: 'my-feeds',
        label: 'My Feeds',
        slug: '#',
        icon: 'mdi:rss',
        isExpanded: false,
        children: [
          {
            id: '3',
            label: '+ Create Feed',
            slug: '/feed/add',
            icon: 'mdi:plus',
          },
        ],
      },
    ],
  },
  {
    id: 'profile',
    label: 'Profile',
    items: [
      {
        id: '4',
        label: 'Bookmarks',
        slug: '/profile/bookmarks',
        icon: 'mdi:bookmark-outline',
      },
    ],
  },
] as NavigationCategory[])

export default function usePages() {
  const client = useSupabaseClient()
  const { profile } = useCurrentUser()
  const route = useRoute()

  const getFeedName = (feedId: string): string => {
    // Return empty string if it's a UUID
    if (UUID_REGEX.test(feedId)) {
      const newsCategory = navigationCategories.value.find((cat) => cat.id === 'news')
      const myFeeds = newsCategory?.items.find((item) => item.id === 'my-feeds')
      const feed = myFeeds?.children?.find((feed) => feed.id === feedId)
      return feed?.label || ''
    }
    return feedId
  }

  const generateBreadcrumbs = (path: string): BreadcrumbLink[] => {
    const pathParts = path.split('/').filter(Boolean)
    let currentPath = ''

    return pathParts
      .map((part): BreadcrumbLink | null => {
        currentPath += `/${part}`

        // Skip home link
        if (currentPath === '/' || (UUID_REGEX.test(part) && !getFeedName(part))) {
          return null
        }

        // Handle feeds
        if (currentPath.startsWith('/feed/')) {
          if (part === 'feed') {
            return {
              to: currentPath,
              label: 'Feeds',
              ariaLabel: 'Feeds',
            }
          }
          return {
            to: currentPath,
            label: getFeedName(part),
            ariaLabel: getFeedName(part),
          }
        }

        // Default handling
        return {
          to: currentPath,
          label: part.charAt(0).toUpperCase() + part.slice(1),
          ariaLabel: part.charAt(0).toUpperCase() + part.slice(1),
        }
      })
      .filter(Boolean) as BreadcrumbLink[]
  }

  const breadcrumbs = computed(() => generateBreadcrumbs(route.path))

  const currentFeedName = computed(() => {
    if (route.path.startsWith('/feed/')) {
      const feedId = route.params.feed as string
      return getFeedName(feedId)
    }
    return ''
  })

  // Existing feed management functions
  const addFeed = (id: string, label: string) => {
    const newsCategory = navigationCategories.value.find((cat) => cat.id === 'news')
    const myFeeds = newsCategory?.items.find((item) => item.id === 'my-feeds')

    if (myFeeds && !myFeeds.children.some((feed) => feed.id === id)) {
      myFeeds.children.splice(1, 0, {
        id,
        label,
        slug: `/feed/${id}`,
        icon: 'mdi:newspaper-variant-multiple-outline',
      })
    }
  }

  const initializeFeeds = () => {
    if (profile.id) {
      const toast = useNotification()
      client
        .from('feeds')
        .select('id, name')
        .eq('user_id', profile.id)
        .then(({ data, error }) => {
          if (error) {
            toast.error({
              summary: 'Failed to get custom feeds',
              message: 'Could not get custom feeds',
            })
            return
          }

          const newsCategory = navigationCategories.value.find((cat) => cat.id === 'news')
          const myFeeds = newsCategory?.items.find((item) => item.id === 'my-feeds')

          if (myFeeds) {
            myFeeds.children = [myFeeds.children[0]]
            data.forEach((feed) => {
              if (!myFeeds.children.some((item) => item.id === feed.id)) {
                myFeeds.children.push({
                  id: feed.id,
                  label: feed.name,
                  slug: `/feed/${feed.id}`,
                  icon: 'mdi:newspaper-variant-multiple-outline',
                })
              }
            })
          }
        })
    }
  }

  const deleteFeed = (feedId: string) => {
    const newsCategory = navigationCategories.value.find((cat) => cat.id === 'news')
    const myFeeds = newsCategory?.items.find((item) => item.id === 'my-feeds')

    if (myFeeds) {
      const index = myFeeds.children.findIndex((item) => item.id === feedId)
      if (index > -1) {
        myFeeds.children.splice(index, 1)
      }
    }
  }

  onMounted(initializeFeeds)

  return {
    appLinks: navigationCategories,
    breadcrumbs,
    currentFeedName,
    addFeed,
    deleteFeed,
  }
}
