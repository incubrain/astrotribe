This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-11-14T04:19:07.406Z

# File Summary

## Purpose
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A header with the file path (## File: path/to/file)
  b. The full contents of the file in a code block

## Usage Guidelines
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
- Pay special attention to the Repository Description. These contain important context and guidelines specific to this project.

## Notes
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

- Line numbers have been added to the beginning of each line.

## Additional Info
### User Provided Header
CMS application context including shared libraries and layers

For more information about Repomix, visit: https://github.com/yamadashy/repomix

# Repository Structure
```
apps/
  cms/
    config/
      admin.ts
      api.ts
      database.ts
      middlewares.ts
      plugins.ts
      server.ts
    data/
      data.json
    scripts/
      seed.js
    src/
      admin/
        app.example.tsx
        tsconfig.json
        vite.config.example.ts
      api/
        about/
          content-types/
            about/
              schema.json
          controllers/
            about.ts
          routes/
            about.ts
          services/
            about.ts
        article/
          content-types/
            article/
              schema.json
          controllers/
            article.ts
          routes/
            article.ts
          services/
            article.ts
        author/
          content-types/
            author/
              schema.json
          controllers/
            author.ts
          routes/
            author.ts
          services/
            author.ts
        category/
          content-types/
            category/
              schema.json
          controllers/
            category.ts
          routes/
            category.ts
          services/
            category.ts
        data-export/
          controllers/
            data-export.ts
          routes/
            data-export.ts
        global/
          content-types/
            global/
              schema.json
          controllers/
            global.ts
          routes/
            global.ts
          services/
            global.ts
        tag/
          content-types/
            tag/
              schema.json
          controllers/
            tag.ts
          routes/
            tag.ts
          services/
            tag.ts
      components/
        shared/
          media.json
          quote.json
          rich-text.json
          seo.json
          slider.json
      providers/
        supabase/
          index.ts
      index.ts
    types/
      generated/
        contentTypes.d.ts
    package.json
    project.json
    README.md
    tsconfig.json
layers/
  advert/
    .playground/
      app.config.ts
      nuxt.config.ts
    components/
      Advertisement.vue
    plugins/
      error-handler.ts
      sentry.server.ts
    server/
      api/
        advertisement/
          metrics.get.ts
          metrics.post.ts
    nuxt.config.ts
  auth/
    .playground/
      app.config.ts
      nuxt.config.ts
    composables/
      user.current.store.ts
    server/
      middleware/
        cors.ts
    nuxt.config.ts
  base/
    .playground/
      app.config.ts
      nuxt.config.ts
    components/
      image/
        ImageHero.vue
        ImageWithFallback.vue
      Background.vue
      Breadcrumbs.vue
      Glass.vue
      GlobalTimer.vue
      Grid.vue
      HelloWorld.vue
      HoverCard.vue
      Image.vue
      InfiniteScroll.vue
      Loader.vue
      Modal.vue
      NavHamburger.vue
      NewLabel.vue
      Pagination.vue
      Popover.vue
      Resizable.vue
      Sidebar.vue
      SideNav.vue
      SocialBlock.vue
      TabView.vue
      YT.client.vue
    composables/
      utils/
        arrays.ts
        hasValueChanged.ts
        objects.ts
        strings.ts
        time.ts
      ab-test.ts
      analytics.ts
      glass-card.ts
      metrics.ts
      modal.ts
      notification.ts
      settings.store.ts
      social.store.ts
      useMediaQuery.ts
      useNavigation.ts
      utils.ts
    plugins/
      error-handler.ts
      posthog.client.ts
      sentry.client.ts
    types/
      content.ts
      database.ts
      index.ts
      users.ts
    nuxt.config.ts
    supabase-provider.ts
  crud/
    .playground/
      app.config.ts
      nuxt.config.ts
    components/
      Feedback.vue
      Upload.vue
    composables/
      audit.ts
      delete.ts
      fetch.ts
      http-handler.ts
      insert.ts
      loading.store.ts
      local-storage.ts
      main.store.ts
      notification.ts
      pagination.store.ts
      rate-limit.ts
      select.ts
      settings.store.ts
      update.ts
      upload.ts
      useApiDataStore.ts
      useBaseError.ts
      user.current.store.ts
    server/
      utils/
        base.interface.ts
    nuxt.config.ts
libs/
  logger/
    src/
      environment.d.ts
      environment.ts
      error-interface.ts
      handler.ts
      logger.ts
    index.d.ts
    index.ts
shared-runtime.config.ts
```

# Repository Files

## File: apps/cms/config/admin.ts
```typescript
 1: export default ({ env }) => ({
 2:   auth: {
 3:     secret: env('ADMIN_JWT_SECRET'),
 4:   },
 5:   apiToken: {
 6:     salt: env('API_TOKEN_SALT'),
 7:   },
 8:   transfer: {
 9:     token: {
10:       salt: env('TRANSFER_TOKEN_SALT'),
11:     },
12:   },
13:   flags: {
14:     nps: env.bool('FLAG_NPS', true),
15:     promoteEE: env.bool('FLAG_PROMOTE_EE', true),
16:   },
17: })
```

## File: apps/cms/config/api.ts
```typescript
1: export default {
2:   rest: {
3:     defaultLimit: 25,
4:     maxLimit: 100,
5:     withCount: true,
6:   },
7: }
```

## File: apps/cms/config/database.ts
```typescript
 1: import path from 'path'
 2: 
 3: export default ({ env }) => {
 4:   const client = env('DATABASE_CLIENT', 'postgres')
 5: 
 6:   const connections = {
 7:     mysql: {
 8:       connection: {
 9:         host: env('DATABASE_HOST', 'localhost'),
10:         port: env.int('DATABASE_PORT', 3306),
11:         database: env('DATABASE_NAME', 'strapi'),
12:         user: env('DATABASE_USERNAME', 'strapi'),
13:         password: env('DATABASE_PASSWORD', 'strapi'),
14:         ssl: env.bool('DATABASE_SSL', false) && {
15:           key: env('DATABASE_SSL_KEY', undefined),
16:           cert: env('DATABASE_SSL_CERT', undefined),
17:           ca: env('DATABASE_SSL_CA', undefined),
18:           capath: env('DATABASE_SSL_CAPATH', undefined),
19:           cipher: env('DATABASE_SSL_CIPHER', undefined),
20:           rejectUnauthorized: env.bool('DATABASE_SSL_REJECT_UNAUTHORIZED', true),
21:         },
22:       },
23:       pool: { min: env.int('DATABASE_POOL_MIN', 2), max: env.int('DATABASE_POOL_MAX', 10) },
24:     },
25:     postgres: {
26:       connection: {
27:         connectionString: env('DATABASE_URL'),
28:         host: env('DATABASE_HOST', 'localhost'),
29:         port: env.int('DATABASE_PORT', 5432),
30:         database: env('DATABASE_NAME', 'strapi'),
31:         user: env('DATABASE_USERNAME', 'strapi'),
32:         password: env('DATABASE_PASSWORD', 'strapi'),
33:         ssl: env.bool('DATABASE_SSL', false) && {
34:           key: env('DATABASE_SSL_KEY', undefined),
35:           cert: env('DATABASE_SSL_CERT', undefined),
36:           ca: env('DATABASE_SSL_CA', undefined),
37:           capath: env('DATABASE_SSL_CAPATH', undefined),
38:           cipher: env('DATABASE_SSL_CIPHER', undefined),
39:           rejectUnauthorized: env.bool('DATABASE_SSL_REJECT_UNAUTHORIZED', true),
40:         },
41:         schema: env('DATABASE_SCHEMA', 'public'),
42:       },
43:       pool: { min: env.int('DATABASE_POOL_MIN', 2), max: env.int('DATABASE_POOL_MAX', 10) },
44:     },
45:     sqlite: {
46:       connection: {
47:         filename: path.join(__dirname, '..', '..', env('DATABASE_FILENAME', '.tmp/data.db')),
48:       },
49:       useNullAsDefault: true,
50:     },
51:   }
52: 
53:   return {
54:     connection: {
55:       client,
56:       ...connections[client],
57:       acquireConnectionTimeout: env.int('DATABASE_CONNECTION_TIMEOUT', 60000),
58:     },
59:   }
60: }
```

## File: apps/cms/config/middlewares.ts
```typescript
 1: export default [
 2:   'strapi::logger',
 3:   'strapi::errors',
 4:   {
 5:     name: 'strapi::security',
 6:     config: {
 7:       contentSecurityPolicy: {
 8:         useDefaults: true,
 9:         directives: {
10:           'frameAncestors': ['http://localhost:*', 'self'],
11:           'connect-src': ["'self'", 'http:', 'https:'],
12:           'img-src': [
13:             "'self'",
14:             'data:',
15:             'blob:',
16:             'http:',
17:             'https:',
18:             'cms.astronera.org',
19:             '*.astronera.org',
20:             process.env.SUPABASE_STORAGE_URL.replace('https://', ''),
21:           ],
22:           'media-src': [
23:             "'self'",
24:             'data:',
25:             'blob:',
26:             'http:',
27:             'https:',
28:             'cms.astronera.org',
29:             '*.astronera.org',
30:             process.env.SUPABASE_STORAGE_URL.replace('https://', ''),
31:           ],
32:           'upgradeInsecureRequests': null,
33:         },
34:       },
35:     },
36:   },
37:   {
38:     name: 'strapi::cors',
39:     config: {
40:       origin: [
41:         'http://localhost:3000',
42:         'https://staging.website.astronera.org',
43:         'https://astronera.org',
44:         'https://staging.cms.astronera.org',
45:         'https://cms.astronera.org',
46:         'https://*.astronera.org',
47:         'https://*.up.railway.app',
48:         process.env.SUPABASE_STORAGE_URL,
49:       ],
50:       methods: ['GET', 'POST', 'PUT', 'PATCH', 'DELETE', 'OPTIONS', 'HEAD'],
51:       headers: ['Content-Type', 'Authorization', 'Origin', 'Accept', 'sentry-trace', 'baggage'],
52:       expose: ['WWW-Authenticate', 'Server-Authorization'],
53:       credentials: false,
54:       maxAge: 31536000,
55:     },
56:   },
57:   'strapi::poweredBy',
58:   'strapi::query',
59:   'strapi::body',
60:   'strapi::session',
61:   'strapi::favicon',
62:   'strapi::public',
63: ]
```

## File: apps/cms/config/plugins.ts
```typescript
 1: // config/plugins.js
 2: 
 3: module.exports = ({ env }) => ({
 4:   upload: {
 5:     config: {
 6:       provider: 'strapi-provider-upload-supabase',
 7:       providerOptions: {
 8:         endpoint: env('SUPABASE_STORAGE_URL'),
 9:         accessKeyId: env('SUPABASE_ACCESS_KEY'),
10:         secretAccessKey: env('SUPABASE_SECRET_KEY'),
11:         bucket: env('SUPABASE_BUCKET'),
12:         region: 'ap-south-1',
13:       },
14:     },
15:   },
16: })
```

## File: apps/cms/config/server.ts
```typescript
 1: export default ({ env }) => ({
 2:   host: env('HOST', '0.0.0.0'),
 3:   port: env.int('PORT', 1337),
 4:   url: env('PUBLIC_URL', 'https://cms.astronera.org'),
 5:   app: {
 6:     keys: env.array('APP_KEYS'),
 7:   },
 8:   bootstrap(app) {
 9:     const seedData = require('../scripts/seed')
10:     seedData()
11:   },
12: })
```

## File: apps/cms/data/data.json
```json
  1: {
  2:   "global": {
  3:     "siteName": "Strapi Blog",
  4:     "defaultSeo": {
  5:       "metaTitle": "Page",
  6:       "metaDescription": "A blog made with Strapi",
  7:       "shareImage": null
  8:     },
  9:     "siteDescription": "A Blog made with Strapi",
 10:     "favicon": null
 11:   },
 12:   "about": {
 13:     "title": "About the strapi blog",
 14:     "blocks": [
 15:       {
 16:         "__component": "shared.quote",
 17:         "title": "Thelonius Monk",
 18:         "body": "You've got to dig it to dig it, you dig?"
 19:       },
 20:       {
 21:         "__component": "shared.rich-text",
 22:         "body": "## Dedit imago conspicuus cum capillis totidem inhibere\n\nLorem markdownum **rerum**, est limine: columbas: ab infelix hostem arbore nudis\ncrudelis. Videtur reliquit ambo ferrum dote sub amne fatis **illuc**, in magis,\nnec."
 23:       },
 24:       {
 25:         "__component": "shared.media",
 26:         "file": "coffee-art.jpg"
 27:       }
 28:     ]
 29:   },
 30:   "categories": [
 31:     {
 32:       "name": "news",
 33:       "slug": "news"
 34:     },
 35:     {
 36:       "name": "tech",
 37:       "slug": "tech"
 38:     },
 39:     {
 40:       "name": "food",
 41:       "slug": "food"
 42:     },
 43:     {
 44:       "name": "nature",
 45:       "slug": "nature"
 46:     },
 47:     {
 48:       "name": "story",
 49:       "slug": "story"
 50:     }
 51:   ],
 52:   "authors": [
 53:     {
 54:       "name": "David Doe",
 55:       "email": "daviddoe@strapi.io",
 56:       "avatar": "daviddoe@strapi.io.jpg"
 57:     },
 58:     {
 59:       "name": "Sarah Baker",
 60:       "email": "sarahbaker@strapi.io",
 61:       "avatar": "sarahbaker@strapi.io.jpg"
 62:     }
 63:   ],
 64:   "articles": [
 65:     {
 66:       "title": "The internet's Own boy",
 67:       "slug": "the-internet-s-own-boy",
 68:       "category": {
 69:         "id": 5
 70:       },
 71:       "author": {
 72:         "id": 1
 73:       },
 74:       "description": "Follow the story of Aaron Swartz, the boy who could change the world",
 75:       "cover": null,
 76:       "blocks": [
 77:         {
 78:           "__component": "shared.rich-text",
 79:           "body": "## Probant \n\nse Lorem markdownum negat. Argo *saxa* videnda cornuaque hunc qui tanta spes teneas! Obliquis est dicenti est salutat ille tamen iuvenum nostrae dolore. - Colores nocituraque comitata eripiunt - Addit quodcunque solum cui et dextram illis - Nulli meus nec extemplo ille ferebat pressit Se blandita fulvae vox gravem Pittheus cesserunt sanguine herbis tu comitum tenuit. Sui in ruunt; Doridaque maculosae fuissem! Et loqui. \n\n## Abit sua\n\nse Lorem markdownum negat. Argo *saxa* videnda cornuaque hunc qui tanta spes teneas! Obliquis est dicenti est salutat ille tamen iuvenum nostrae dolore. - Colores nocituraque comitata eripiunt - Addit quodcunque solum cui et dextram illis - Nulli meus nec extemplo ille ferebat pressit Se blandita fulvae vox gravem Pittheus cesserunt sanguine herbis tu comitum tenuit. Sui in ruunt; Doridaque maculosae fuissem! Et loqui. "
 80:         },
 81:         {
 82:           "__component": "shared.quote",
 83:           "title": "Thelonius Monk",
 84:           "body": "You've got to dig it to dig it, you dig?"
 85:         },
 86:         {
 87:           "__component": "shared.media",
 88:           "file": "coffee-art.jpg"
 89:         },
 90:         {
 91:           "__component": "shared.rich-text",
 92:           "body": "## Spatiantia astra \n\nFoeda, medio silva *errandum*: onus formam munere. Mutata bibulis est auxiliare arces etiamnunc verbis virgineo Priamidas illa Thescelus, nam fit locis lucis auras. Exitus hospes gratulor ut pondere [speslimite](http://www.curas.io/figuram); quid habent, Avernales faciente de. Pervenit Ino sonabile supplex cognoscenti vires, Bacchumque errat miserarum venandi dignabere dedisti. Discrimina iuncosaque virgaque tot sine superest [fissus](http://quos.org/sitet.aspx). Non color esset potest non sumit, sed vix arserat. Nisi immo silva tantum pectusque quos pennis quisquam artus!"
 93:         },
 94:         {
 95:           "__component": "shared.slider",
 96:           "files": ["coffee-art.jpg", "coffee-beans.jpg"]
 97:         }
 98:       ]
 99:     },
100:     {
101:       "title": "This shrimp is awesome",
102:       "slug": "this-shrimp-is-awesome",
103:       "category": {
104:         "id": 4
105:       },
106:       "author": {
107:         "id": 1
108:       },
109:       "description": "Mantis shrimps, or stomatopods, are marine crustaceans of the order Stomatopoda.",
110:       "cover": null,
111:       "blocks": [
112:         {
113:           "__component": "shared.rich-text",
114:           "body": "## Probant \n\nse Lorem markdownum negat. Argo *saxa* videnda cornuaque hunc qui tanta spes teneas! Obliquis est dicenti est salutat ille tamen iuvenum nostrae dolore. - Colores nocituraque comitata eripiunt - Addit quodcunque solum cui et dextram illis - Nulli meus nec extemplo ille ferebat pressit Se blandita fulvae vox gravem Pittheus cesserunt sanguine herbis tu comitum tenuit. Sui in ruunt; Doridaque maculosae fuissem! Et loqui. \n\n## Abit sua\n\nse Lorem markdownum negat. Argo *saxa* videnda cornuaque hunc qui tanta spes teneas! Obliquis est dicenti est salutat ille tamen iuvenum nostrae dolore. - Colores nocituraque comitata eripiunt - Addit quodcunque solum cui et dextram illis - Nulli meus nec extemplo ille ferebat pressit Se blandita fulvae vox gravem Pittheus cesserunt sanguine herbis tu comitum tenuit. Sui in ruunt; Doridaque maculosae fuissem! Et loqui. "
115:         },
116:         {
117:           "__component": "shared.quote",
118:           "title": "Thelonius Monk",
119:           "body": "You've got to dig it to dig it, you dig?"
120:         },
121:         {
122:           "__component": "shared.media",
123:           "file": "coffee-art.jpg"
124:         },
125:         {
126:           "__component": "shared.rich-text",
127:           "body": "## Spatiantia astra \n\nFoeda, medio silva *errandum*: onus formam munere. Mutata bibulis est auxiliare arces etiamnunc verbis virgineo Priamidas illa Thescelus, nam fit locis lucis auras. Exitus hospes gratulor ut pondere [speslimite](http://www.curas.io/figuram); quid habent, Avernales faciente de. Pervenit Ino sonabile supplex cognoscenti vires, Bacchumque errat miserarum venandi dignabere dedisti. Discrimina iuncosaque virgaque tot sine superest [fissus](http://quos.org/sitet.aspx). Non color esset potest non sumit, sed vix arserat. Nisi immo silva tantum pectusque quos pennis quisquam artus!"
128:         },
129:         {
130:           "__component": "shared.slider",
131:           "files": ["coffee-art.jpg", "coffee-beans.jpg"]
132:         }
133:       ]
134:     },
135:     {
136:       "title": "A bug is becoming a meme on the internet",
137:       "slug": "a-bug-is-becoming-a-meme-on-the-internet",
138:       "category": {
139:         "id": 2
140:       },
141:       "author": {
142:         "id": 2
143:       },
144:       "description": "How a bug on MySQL is becoming a meme on the internet",
145:       "cover": null,
146:       "blocks": [
147:         {
148:           "__component": "shared.rich-text",
149:           "body": "## Probant \n\nse Lorem markdownum negat. Argo *saxa* videnda cornuaque hunc qui tanta spes teneas! Obliquis est dicenti est salutat ille tamen iuvenum nostrae dolore. - Colores nocituraque comitata eripiunt - Addit quodcunque solum cui et dextram illis - Nulli meus nec extemplo ille ferebat pressit Se blandita fulvae vox gravem Pittheus cesserunt sanguine herbis tu comitum tenuit. Sui in ruunt; Doridaque maculosae fuissem! Et loqui. \n\n## Abit sua\n\nse Lorem markdownum negat. Argo *saxa* videnda cornuaque hunc qui tanta spes teneas! Obliquis est dicenti est salutat ille tamen iuvenum nostrae dolore. - Colores nocituraque comitata eripiunt - Addit quodcunque solum cui et dextram illis - Nulli meus nec extemplo ille ferebat pressit Se blandita fulvae vox gravem Pittheus cesserunt sanguine herbis tu comitum tenuit. Sui in ruunt; Doridaque maculosae fuissem! Et loqui. "
150:         },
151:         {
152:           "__component": "shared.quote",
153:           "title": "Thelonius Monk",
154:           "body": "You've got to dig it to dig it, you dig?"
155:         },
156:         {
157:           "__component": "shared.media",
158:           "file": "coffee-art.jpg"
159:         },
160:         {
161:           "__component": "shared.rich-text",
162:           "body": "## Spatiantia astra \n\nFoeda, medio silva *errandum*: onus formam munere. Mutata bibulis est auxiliare arces etiamnunc verbis virgineo Priamidas illa Thescelus, nam fit locis lucis auras. Exitus hospes gratulor ut pondere [speslimite](http://www.curas.io/figuram); quid habent, Avernales faciente de. Pervenit Ino sonabile supplex cognoscenti vires, Bacchumque errat miserarum venandi dignabere dedisti. Discrimina iuncosaque virgaque tot sine superest [fissus](http://quos.org/sitet.aspx). Non color esset potest non sumit, sed vix arserat. Nisi immo silva tantum pectusque quos pennis quisquam artus!"
163:         },
164:         {
165:           "__component": "shared.slider",
166:           "files": ["coffee-art.jpg", "coffee-beans.jpg"]
167:         }
168:       ]
169:     },
170:     {
171:       "title": "Beautiful picture",
172:       "slug": "beautiful-picture",
173:       "category": {
174:         "id": 4
175:       },
176:       "author": {
177:         "id": 2
178:       },
179:       "description": "Description of a beautiful picture",
180:       "cover": null,
181:       "blocks": [
182:         {
183:           "__component": "shared.rich-text",
184:           "body": "## Probant \n\nse Lorem markdownum negat. Argo *saxa* videnda cornuaque hunc qui tanta spes teneas! Obliquis est dicenti est salutat ille tamen iuvenum nostrae dolore. - Colores nocituraque comitata eripiunt - Addit quodcunque solum cui et dextram illis - Nulli meus nec extemplo ille ferebat pressit Se blandita fulvae vox gravem Pittheus cesserunt sanguine herbis tu comitum tenuit. Sui in ruunt; Doridaque maculosae fuissem! Et loqui. \n\n## Abit sua\n\nse Lorem markdownum negat. Argo *saxa* videnda cornuaque hunc qui tanta spes teneas! Obliquis est dicenti est salutat ille tamen iuvenum nostrae dolore. - Colores nocituraque comitata eripiunt - Addit quodcunque solum cui et dextram illis - Nulli meus nec extemplo ille ferebat pressit Se blandita fulvae vox gravem Pittheus cesserunt sanguine herbis tu comitum tenuit. Sui in ruunt; Doridaque maculosae fuissem! Et loqui. "
185:         },
186:         {
187:           "__component": "shared.quote",
188:           "title": "Thelonius Monk",
189:           "body": "You've got to dig it to dig it, you dig?"
190:         },
191:         {
192:           "__component": "shared.media",
193:           "file": "coffee-art.jpg"
194:         },
195:         {
196:           "__component": "shared.rich-text",
197:           "body": "## Spatiantia astra \n\nFoeda, medio silva *errandum*: onus formam munere. Mutata bibulis est auxiliare arces etiamnunc verbis virgineo Priamidas illa Thescelus, nam fit locis lucis auras. Exitus hospes gratulor ut pondere [speslimite](http://www.curas.io/figuram); quid habent, Avernales faciente de. Pervenit Ino sonabile supplex cognoscenti vires, Bacchumque errat miserarum venandi dignabere dedisti. Discrimina iuncosaque virgaque tot sine superest [fissus](http://quos.org/sitet.aspx). Non color esset potest non sumit, sed vix arserat. Nisi immo silva tantum pectusque quos pennis quisquam artus!"
198:         },
199:         {
200:           "__component": "shared.slider",
201:           "files": ["coffee-art.jpg", "coffee-beans.jpg"]
202:         }
203:       ]
204:     },
205:     {
206:       "title": "What's inside a Black Hole",
207:       "slug": "what-s-inside-a-black-hole",
208:       "category": {
209:         "id": 1
210:       },
211:       "author": {
212:         "id": 2
213:       },
214:       "description": "Maybe the answer is in this article, or not...",
215:       "cover": null,
216:       "blocks": [
217:         {
218:           "__component": "shared.rich-text",
219:           "body": "## Probant \n\nse Lorem markdownum negat. Argo *saxa* videnda cornuaque hunc qui tanta spes teneas! Obliquis est dicenti est salutat ille tamen iuvenum nostrae dolore. - Colores nocituraque comitata eripiunt - Addit quodcunque solum cui et dextram illis - Nulli meus nec extemplo ille ferebat pressit Se blandita fulvae vox gravem Pittheus cesserunt sanguine herbis tu comitum tenuit. Sui in ruunt; Doridaque maculosae fuissem! Et loqui. \n\n## Abit sua\n\nse Lorem markdownum negat. Argo *saxa* videnda cornuaque hunc qui tanta spes teneas! Obliquis est dicenti est salutat ille tamen iuvenum nostrae dolore. - Colores nocituraque comitata eripiunt - Addit quodcunque solum cui et dextram illis - Nulli meus nec extemplo ille ferebat pressit Se blandita fulvae vox gravem Pittheus cesserunt sanguine herbis tu comitum tenuit. Sui in ruunt; Doridaque maculosae fuissem! Et loqui. "
220:         },
221:         {
222:           "__component": "shared.quote",
223:           "title": "Thelonius Monk",
224:           "body": "You've got to dig it to dig it, you dig?"
225:         },
226:         {
227:           "__component": "shared.media",
228:           "file": "coffee-art.jpg"
229:         },
230:         {
231:           "__component": "shared.rich-text",
232:           "body": "## Spatiantia astra \n\nFoeda, medio silva *errandum*: onus formam munere. Mutata bibulis est auxiliare arces etiamnunc verbis virgineo Priamidas illa Thescelus, nam fit locis lucis auras. Exitus hospes gratulor ut pondere [speslimite](http://www.curas.io/figuram); quid habent, Avernales faciente de. Pervenit Ino sonabile supplex cognoscenti vires, Bacchumque errat miserarum venandi dignabere dedisti. Discrimina iuncosaque virgaque tot sine superest [fissus](http://quos.org/sitet.aspx). Non color esset potest non sumit, sed vix arserat. Nisi immo silva tantum pectusque quos pennis quisquam artus!"
233:         },
234:         {
235:           "__component": "shared.slider",
236:           "files": ["coffee-art.jpg", "coffee-beans.jpg"]
237:         }
238:       ]
239:     }
240:   ]
241: }
```

## File: apps/cms/scripts/seed.js
```javascript
  1: 'use strict'
  2: 
  3: const path = require('path')
  4: const fs = require('fs-extra')
  5: const mime = require('mime-types')
  6: const axios = require('axios')
  7: 
  8: // Import your exported data
  9: const exportedData = require('../data/exported-data.json')
 10: 
 11: async function seedExampleApp() {
 12:   const shouldImportSeedData = await isFirstRun()
 13: 
 14:   if (shouldImportSeedData) {
 15:     try {
 16:       console.log('Setting up the template with production data...')
 17:       await importSeedData()
 18:       console.log('Ready to go')
 19:     } catch (error) {
 20:       console.log('Could not import seed data')
 21:       console.error(error)
 22:     }
 23:   } else {
 24:     console.log('Seed data has already been imported.')
 25:   }
 26: }
 27: 
 28: async function importSeedData() {
 29:   // Allow read of application content types
 30:   await setPublicPermissions({
 31:     article: ['find', 'findOne'],
 32:     category: ['find', 'findOne'],
 33:     tag: ['find', 'findOne'],
 34:     author: ['find', 'findOne'],
 35:     global: ['find', 'findOne'],
 36:     about: ['find', 'findOne'],
 37:   })
 38: 
 39:   // Create all entries
 40:   await importCategories()
 41:   await importTags()
 42:   await importAuthors()
 43:   await importArticles()
 44:   await importGlobal()
 45:   await importAbout()
 46: }
 47: 
 48: async function importCategories() {
 49:   for (const category of exportedData.categories.data) {
 50:     await createEntry({ model: 'category', entry: category.attributes })
 51:   }
 52: }
 53: 
 54: async function importTags() {
 55:   for (const tag of exportedData.tags.data) {
 56:     await createEntry({ model: 'tag', entry: tag.attributes })
 57:   }
 58: }
 59: 
 60: async function importAuthors() {
 61:   for (const author of exportedData.authors.data) {
 62:     const avatar = await downloadFile(author.attributes.avatar.data.attributes.url)
 63:     await createEntry({
 64:       model: 'author',
 65:       entry: {
 66:         ...author.attributes,
 67:         avatar,
 68:       },
 69:     })
 70:   }
 71: }
 72: 
 73: async function importArticles() {
 74:   for (const article of exportedData.articles.data) {
 75:     const cover = await downloadFile(article.attributes.cover.data.attributes.url)
 76:     const updatedBlocks = await updateBlocks(article.attributes.blocks)
 77: 
 78:     await createEntry({
 79:       model: 'article',
 80:       entry: {
 81:         ...article.attributes,
 82:         cover,
 83:         blocks: updatedBlocks,
 84:         publishedAt: article.attributes.publishedAt || Date.now(),
 85:       },
 86:     })
 87:   }
 88: }
 89: 
 90: async function importGlobal() {
 91:   const globalData = exportedData.global.data.attributes
 92:   const favicon = await downloadFile(globalData.favicon.data.attributes.url)
 93:   const shareImage = await downloadFile(globalData.defaultSeo.shareImage.data.attributes.url)
 94: 
 95:   return createEntry({
 96:     model: 'global',
 97:     entry: {
 98:       ...globalData,
 99:       favicon,
100:       publishedAt: globalData.publishedAt || Date.now(),
101:       defaultSeo: {
102:         ...globalData.defaultSeo,
103:         shareImage,
104:       },
105:     },
106:   })
107: }
108: 
109: async function importAbout() {
110:   const aboutData = exportedData.about.data.attributes
111:   const updatedBlocks = await updateBlocks(aboutData.blocks)
112: 
113:   await createEntry({
114:     model: 'about',
115:     entry: {
116:       ...aboutData,
117:       blocks: updatedBlocks,
118:       publishedAt: aboutData.publishedAt || Date.now(),
119:     },
120:   })
121: }
122: 
123: async function downloadFile(url) {
124:   const response = await axios.get(url, { responseType: 'arraybuffer' })
125:   const buffer = Buffer.from(response.data, 'binary')
126:   const fileName = path.basename(url)
127:   const filePath = path.join('data', 'uploads', fileName)
128:   await fs.writeFile(filePath, buffer)
129:   return checkFileExistsBeforeUpload([fileName])
130: }
131: 
132: async function isFirstRun() {
133:   const pluginStore = strapi.store({
134:     environment: strapi.config.environment,
135:     type: 'type',
136:     name: 'setup',
137:   })
138:   const initHasRun = await pluginStore.get({ key: 'initHasRun' })
139:   await pluginStore.set({ key: 'initHasRun', value: true })
140:   return !initHasRun
141: }
142: 
143: async function setPublicPermissions(newPermissions) {
144:   // Find the ID of the public role
145:   const publicRole = await strapi.query('plugin::users-permissions.role').findOne({
146:     where: {
147:       type: 'public',
148:     },
149:   })
150: 
151:   // Create the new permissions and link them to the public role
152:   const allPermissionsToCreate = []
153:   Object.keys(newPermissions).map((controller) => {
154:     const actions = newPermissions[controller]
155:     const permissionsToCreate = actions.map((action) => {
156:       return strapi.query('plugin::users-permissions.permission').create({
157:         data: {
158:           action: `api::${controller}.${controller}.${action}`,
159:           role: publicRole.id,
160:         },
161:       })
162:     })
163:     allPermissionsToCreate.push(...permissionsToCreate)
164:   })
165:   await Promise.all(allPermissionsToCreate)
166: }
167: 
168: function getFileSizeInBytes(filePath) {
169:   const stats = fs.statSync(filePath)
170:   const fileSizeInBytes = stats['size']
171:   return fileSizeInBytes
172: }
173: 
174: function getFileData(fileName) {
175:   const filePath = path.join('data', 'uploads', fileName)
176:   // Parse the file metadata
177:   const size = getFileSizeInBytes(filePath)
178:   const ext = fileName.split('.').pop()
179:   const mimeType = mime.lookup(ext || '') || ''
180: 
181:   return {
182:     filepath: filePath,
183:     originalFileName: fileName,
184:     size,
185:     mimetype: mimeType,
186:   }
187: }
188: 
189: async function uploadFile(file, name) {
190:   return strapi
191:     .plugin('upload')
192:     .service('upload')
193:     .upload({
194:       files: file,
195:       data: {
196:         fileInfo: {
197:           alternativeText: `An image uploaded to Strapi called ${name}`,
198:           caption: name,
199:           name,
200:         },
201:       },
202:     })
203: }
204: 
205: // Create an entry and attach files if there are any
206: async function createEntry({ model, entry }) {
207:   try {
208:     // Actually create the entry in Strapi
209:     await strapi.documents(`api::${model}.${model}`).create({
210:       data: entry,
211:     })
212:   } catch (error) {
213:     console.error({ model, entry, error })
214:   }
215: }
216: 
217: async function checkFileExistsBeforeUpload(files) {
218:   const existingFiles = []
219:   const uploadedFiles = []
220:   const filesCopy = [...files]
221: 
222:   for (const fileName of filesCopy) {
223:     // Check if the file already exists in Strapi
224:     const fileWhereName = await strapi.query('plugin::upload.file').findOne({
225:       where: {
226:         name: fileName.replace(/\..*$/, ''),
227:       },
228:     })
229: 
230:     if (fileWhereName) {
231:       // File exists, don't upload it
232:       existingFiles.push(fileWhereName)
233:     } else {
234:       // File doesn't exist, upload it
235:       const fileData = getFileData(fileName)
236:       const fileNameNoExtension = fileName.split('.').shift()
237:       const [file] = await uploadFile(fileData, fileNameNoExtension)
238:       uploadedFiles.push(file)
239:     }
240:   }
241:   const allFiles = [...existingFiles, ...uploadedFiles]
242:   // If only one file then return only that file
243:   return allFiles.length === 1 ? allFiles[0] : allFiles
244: }
245: 
246: async function updateBlocks(blocks) {
247:   const updatedBlocks = []
248:   for (const block of blocks) {
249:     if (block.__component === 'shared.media') {
250:       const uploadedFiles = await checkFileExistsBeforeUpload([block.file])
251:       // Copy the block to not mutate directly
252:       const blockCopy = { ...block }
253:       // Replace the file name on the block with the actual file
254:       blockCopy.file = uploadedFiles
255:       updatedBlocks.push(blockCopy)
256:     } else if (block.__component === 'shared.slider') {
257:       // Get files already uploaded to Strapi or upload new files
258:       const existingAndUploadedFiles = await checkFileExistsBeforeUpload(block.files)
259:       // Copy the block to not mutate directly
260:       const blockCopy = { ...block }
261:       // Replace the file names on the block with the actual files
262:       blockCopy.files = existingAndUploadedFiles
263:       // Push the updated block
264:       updatedBlocks.push(blockCopy)
265:     } else {
266:       // Just push the block as is
267:       updatedBlocks.push(block)
268:     }
269:   }
270: 
271:   return updatedBlocks
272: }
273: 
274: async function main() {
275:   const { createStrapi, compileStrapi } = require('@strapi/strapi')
276: 
277:   const appContext = await compileStrapi()
278:   const app = await createStrapi(appContext).load()
279: 
280:   app.log.level = 'error'
281: 
282:   await seedExampleApp()
283:   await app.destroy()
284: 
285:   process.exit(0)
286: }
287: 
288: main().catch((error) => {
289:   console.error(error)
290:   process.exit(1)
291: })
```

## File: apps/cms/src/admin/app.example.tsx
```typescript
 1: import type { StrapiApp } from '@strapi/strapi/admin'
 2: 
 3: export default {
 4:   config: {
 5:     locales: [
 6:       // 'ar',
 7:       // 'fr',
 8:       // 'cs',
 9:       // 'de',
10:       // 'dk',
11:       // 'es',
12:       // 'he',
13:       // 'id',
14:       // 'it',
15:       // 'ja',
16:       // 'ko',
17:       // 'ms',
18:       // 'nl',
19:       // 'no',
20:       // 'pl',
21:       // 'pt-BR',
22:       // 'pt',
23:       // 'ru',
24:       // 'sk',
25:       // 'sv',
26:       // 'th',
27:       // 'tr',
28:       // 'uk',
29:       // 'vi',
30:       // 'zh-Hans',
31:       // 'zh',
32:     ],
33:   },
34:   bootstrap(app: StrapiApp) {
35:     console.log(app)
36:   },
37: }
```

## File: apps/cms/src/admin/tsconfig.json
```json
 1: {
 2:   "compilerOptions": {
 3:     "target": "ESNext",
 4:     "module": "ESNext",
 5:     "moduleResolution": "Bundler",
 6:     "useDefineForClassFields": true,
 7:     "lib": ["DOM", "DOM.Iterable", "ESNext"],
 8:     "allowJs": false,
 9:     "skipLibCheck": true,
10:     "esModuleInterop": true,
11:     "allowSyntheticDefaultImports": true,
12:     "strict": true,
13:     "forceConsistentCasingInFileNames": true,
14:     "resolveJsonModule": true,
15:     "noEmit": true,
16:     "jsx": "react-jsx"
17:   },
18:   "include": ["../plugins/**/admin/src/**/*", "./"],
19:   "exclude": ["node_modules/", "build/", "dist/", "**/*.test.ts"]
20: }
```

## File: apps/cms/src/admin/vite.config.example.ts
```typescript
 1: import { mergeConfig, type UserConfig } from 'vite'
 2: 
 3: export default (config: UserConfig) => {
 4:   // Important: always return the modified config
 5:   return mergeConfig(config, {
 6:     resolve: {
 7:       alias: {
 8:         '@': '/src',
 9:       },
10:     },
11:   })
12: }
```

## File: apps/cms/src/api/about/content-types/about/schema.json
```json
 1: {
 2:   "kind": "singleType",
 3:   "collectionName": "abouts",
 4:   "info": {
 5:     "singularName": "about",
 6:     "pluralName": "abouts",
 7:     "displayName": "About",
 8:     "description": "Write about yourself and the content you create"
 9:   },
10:   "options": {
11:     "draftAndPublish": false
12:   },
13:   "pluginOptions": {},
14:   "attributes": {
15:     "title": {
16:       "type": "string"
17:     },
18:     "blocks": {
19:       "type": "dynamiczone",
20:       "components": ["shared.media", "shared.quote", "shared.rich-text", "shared.slider"]
21:     }
22:   }
23: }
```

## File: apps/cms/src/api/about/controllers/about.ts
```typescript
1: /**
2:  *  about controller
3:  */
4: 
5: import { factories } from '@strapi/strapi';
6: 
7: export default factories.createCoreController('api::about.about');
```

## File: apps/cms/src/api/about/routes/about.ts
```typescript
1: /**
2:  * about router.
3:  */
4: 
5: import { factories } from '@strapi/strapi';
6: 
7: export default factories.createCoreRouter('api::about.about');
```

## File: apps/cms/src/api/about/services/about.ts
```typescript
1: /**
2:  * about service.
3:  */
4: 
5: import { factories } from '@strapi/strapi';
6: 
7: export default factories.createCoreService('api::about.about');
```

## File: apps/cms/src/api/article/content-types/article/schema.json
```json
 1: {
 2:   "kind": "collectionType",
 3:   "collectionName": "articles",
 4:   "info": {
 5:     "singularName": "article",
 6:     "pluralName": "articles",
 7:     "displayName": "Article",
 8:     "description": "Create your blog content"
 9:   },
10:   "options": {
11:     "draftAndPublish": true
12:   },
13:   "pluginOptions": {},
14:   "attributes": {
15:     "title": {
16:       "type": "string"
17:     },
18:     "description": {
19:       "type": "text",
20:       "maxLength": 240
21:     },
22:     "slug": {
23:       "type": "uid",
24:       "targetField": "title"
25:     },
26:     "cover": {
27:       "type": "media",
28:       "multiple": false,
29:       "required": false,
30:       "allowedTypes": [
31:         "images",
32:         "files",
33:         "videos"
34:       ]
35:     },
36:     "author": {
37:       "type": "relation",
38:       "relation": "manyToOne",
39:       "target": "api::author.author",
40:       "inversedBy": "articles"
41:     },
42:     "category": {
43:       "type": "relation",
44:       "relation": "manyToOne",
45:       "target": "api::category.category",
46:       "inversedBy": "articles"
47:     },
48:     "blocks": {
49:       "type": "dynamiczone",
50:       "components": [
51:         "shared.media",
52:         "shared.quote",
53:         "shared.rich-text",
54:         "shared.slider"
55:       ]
56:     },
57:     "tags": {
58:       "type": "relation",
59:       "relation": "manyToMany",
60:       "target": "api::tag.tag",
61:       "inversedBy": "article"
62:     }
63:   }
64: }
```

## File: apps/cms/src/api/article/controllers/article.ts
```typescript
1: /**
2:  *  article controller
3:  */
4: 
5: import { factories } from '@strapi/strapi'
6: 
7: export default factories.createCoreController('api::article.article')
```

## File: apps/cms/src/api/article/routes/article.ts
```typescript
1: /**
2:  * article router.
3:  */
4: 
5: import { factories } from '@strapi/strapi'
6: 
7: export default factories.createCoreRouter('api::article.article')
```

## File: apps/cms/src/api/article/services/article.ts
```typescript
1: /**
2:  * article service.
3:  */
4: 
5: import { factories } from '@strapi/strapi'
6: 
7: export default factories.createCoreService('api::article.article')
```

## File: apps/cms/src/api/author/content-types/author/schema.json
```json
 1: {
 2:   "kind": "collectionType",
 3:   "collectionName": "authors",
 4:   "info": {
 5:     "singularName": "author",
 6:     "pluralName": "authors",
 7:     "displayName": "Author",
 8:     "description": "Create authors for your content"
 9:   },
10:   "options": {
11:     "draftAndPublish": false
12:   },
13:   "pluginOptions": {},
14:   "attributes": {
15:     "name": {
16:       "type": "string"
17:     },
18:     "avatar": {
19:       "type": "media",
20:       "multiple": false,
21:       "required": false,
22:       "allowedTypes": [
23:         "images",
24:         "files",
25:         "videos"
26:       ]
27:     },
28:     "email": {
29:       "type": "string"
30:     },
31:     "articles": {
32:       "type": "relation",
33:       "relation": "oneToMany",
34:       "target": "api::article.article",
35:       "mappedBy": "author"
36:     },
37:     "bio": {
38:       "type": "text"
39:     },
40:     "socials": {
41:       "type": "json"
42:     }
43:   }
44: }
```

## File: apps/cms/src/api/author/controllers/author.ts
```typescript
1: /**
2:  *  author controller
3:  */
4: 
5: import { factories } from '@strapi/strapi'
6: 
7: export default factories.createCoreController('api::author.author')
```

## File: apps/cms/src/api/author/routes/author.ts
```typescript
1: /**
2:  * author router.
3:  */
4: 
5: import { factories } from '@strapi/strapi'
6: 
7: export default factories.createCoreRouter('api::author.author')
```

## File: apps/cms/src/api/author/services/author.ts
```typescript
1: /**
2:  * author service.
3:  */
4: 
5: import { factories } from '@strapi/strapi'
6: 
7: export default factories.createCoreService('api::author.author')
```

## File: apps/cms/src/api/category/content-types/category/schema.json
```json
 1: {
 2:   "kind": "collectionType",
 3:   "collectionName": "categories",
 4:   "info": {
 5:     "singularName": "category",
 6:     "pluralName": "categories",
 7:     "displayName": "Category",
 8:     "description": "Organize your content into categories"
 9:   },
10:   "options": {
11:     "draftAndPublish": false
12:   },
13:   "pluginOptions": {},
14:   "attributes": {
15:     "name": {
16:       "type": "string"
17:     },
18:     "slug": {
19:       "type": "uid"
20:     },
21:     "articles": {
22:       "type": "relation",
23:       "relation": "oneToMany",
24:       "target": "api::article.article",
25:       "mappedBy": "category"
26:     },
27:     "description": {
28:       "type": "text"
29:     }
30:   }
31: }
```

## File: apps/cms/src/api/category/controllers/category.ts
```typescript
1: /**
2:  *  category controller
3:  */
4: 
5: import { factories } from '@strapi/strapi'
6: 
7: export default factories.createCoreController('api::category.category')
```

## File: apps/cms/src/api/category/routes/category.ts
```typescript
1: /**
2:  * category router.
3:  */
4: 
5: import { factories } from '@strapi/strapi'
6: 
7: export default factories.createCoreRouter('api::category.category')
```

## File: apps/cms/src/api/category/services/category.ts
```typescript
1: /**
2:  * category service.
3:  */
4: 
5: import { factories } from '@strapi/strapi';
6: 
7: export default factories.createCoreService('api::category.category');
```

## File: apps/cms/src/api/data-export/controllers/data-export.ts
```typescript
 1: module.exports = {
 2:   async exportData(ctx) {
 3:     console.log('Export Data Controller Loaded')
 4: 
 5:     const data = {
 6:       global: await strapi.service('api::global.global').find(),
 7:       about: await strapi.service('api::about.about').find(),
 8:       categories: await strapi.service('api::category.category').find(),
 9:       tags: await strapi.service('api::tag.tag').find(),
10:       authors: await strapi.service('api::author.author').find(),
11:       articles: await strapi.service('api::article.article').find(),
12:     }
13: 
14:     ctx.send(data)
15:   },
16: }
```

## File: apps/cms/src/api/data-export/routes/data-export.ts
```typescript
 1: module.exports = {
 2:   routes: [
 3:     {
 4:       method: 'GET',
 5:       path: '/export-data',
 6:       handler: 'data-export.exportData',
 7:       config: {
 8:         auth: false, // Set to false if you want the route to be public
 9:         policies: [],
10:         middlewares: [],
11:       },
12:     },
13:   ],
14: }
```

## File: apps/cms/src/api/global/content-types/global/schema.json
```json
 1: {
 2:   "kind": "singleType",
 3:   "collectionName": "globals",
 4:   "info": {
 5:     "singularName": "global",
 6:     "pluralName": "globals",
 7:     "displayName": "Global",
 8:     "description": "Define global settings"
 9:   },
10:   "options": {
11:     "draftAndPublish": false
12:   },
13:   "pluginOptions": {},
14:   "attributes": {
15:     "siteName": {
16:       "type": "string",
17:       "required": true
18:     },
19:     "favicon": {
20:       "type": "media",
21:       "multiple": false,
22:       "required": false,
23:       "allowedTypes": ["images", "files", "videos"]
24:     },
25:     "siteDescription": {
26:       "type": "text",
27:       "required": true
28:     },
29:     "defaultSeo": {
30:       "type": "component",
31:       "repeatable": false,
32:       "component": "shared.seo"
33:     }
34:   }
35: }
```

## File: apps/cms/src/api/global/controllers/global.ts
```typescript
1: /**
2:  *  global controller
3:  */
4: 
5: import { factories } from '@strapi/strapi';
6: 
7: export default factories.createCoreController('api::global.global');
```

## File: apps/cms/src/api/global/routes/global.ts
```typescript
1: /**
2:  * global router.
3:  */
4: 
5: import { factories } from '@strapi/strapi'
6: 
7: export default factories.createCoreRouter('api::global.global')
```

## File: apps/cms/src/api/global/services/global.ts
```typescript
1: /**
2:  * global service.
3:  */
4: 
5: import { factories } from '@strapi/strapi';
6: 
7: export default factories.createCoreService('api::global.global');
```

## File: apps/cms/src/api/tag/content-types/tag/schema.json
```json
 1: {
 2:   "kind": "collectionType",
 3:   "collectionName": "tags",
 4:   "info": {
 5:     "singularName": "tag",
 6:     "pluralName": "tags",
 7:     "displayName": "Tags",
 8:     "description": ""
 9:   },
10:   "options": {
11:     "draftAndPublish": false
12:   },
13:   "pluginOptions": {},
14:   "attributes": {
15:     "name": {
16:       "type": "string"
17:     },
18:     "article": {
19:       "type": "relation",
20:       "relation": "manyToMany",
21:       "target": "api::article.article",
22:       "mappedBy": "tags"
23:     }
24:   }
25: }
```

## File: apps/cms/src/api/tag/controllers/tag.ts
```typescript
1: /**
2:  * tag controller
3:  */
4: 
5: import { factories } from '@strapi/strapi'
6: 
7: export default factories.createCoreController('api::tag.tag');
```

## File: apps/cms/src/api/tag/routes/tag.ts
```typescript
1: /**
2:  * tag router
3:  */
4: 
5: import { factories } from '@strapi/strapi';
6: 
7: export default factories.createCoreRouter('api::tag.tag');
```

## File: apps/cms/src/api/tag/services/tag.ts
```typescript
1: /**
2:  * tag service
3:  */
4: 
5: import { factories } from '@strapi/strapi';
6: 
7: export default factories.createCoreService('api::tag.tag');
```

## File: apps/cms/src/components/shared/media.json
```json
 1: {
 2:   "collectionName": "components_shared_media",
 3:   "info": {
 4:     "displayName": "Media",
 5:     "icon": "file-video"
 6:   },
 7:   "options": {},
 8:   "attributes": {
 9:     "file": {
10:       "allowedTypes": ["images", "files", "videos"],
11:       "type": "media",
12:       "multiple": false
13:     }
14:   }
15: }
```

## File: apps/cms/src/components/shared/quote.json
```json
 1: {
 2:   "collectionName": "components_shared_quotes",
 3:   "info": {
 4:     "displayName": "Quote",
 5:     "icon": "indent"
 6:   },
 7:   "options": {},
 8:   "attributes": {
 9:     "title": {
10:       "type": "string"
11:     },
12:     "body": {
13:       "type": "text"
14:     }
15:   }
16: }
```

## File: apps/cms/src/components/shared/rich-text.json
```json
 1: {
 2:   "collectionName": "components_shared_rich_texts",
 3:   "info": {
 4:     "displayName": "Rich text",
 5:     "icon": "align-justify",
 6:     "description": ""
 7:   },
 8:   "options": {},
 9:   "attributes": {
10:     "body": {
11:       "type": "richtext"
12:     }
13:   }
14: }
```

## File: apps/cms/src/components/shared/seo.json
```json
 1: {
 2:   "collectionName": "components_shared_seos",
 3:   "info": {
 4:     "name": "Seo",
 5:     "icon": "allergies",
 6:     "displayName": "Seo",
 7:     "description": ""
 8:   },
 9:   "options": {},
10:   "attributes": {
11:     "metaTitle": {
12:       "type": "string",
13:       "required": true
14:     },
15:     "metaDescription": {
16:       "type": "text",
17:       "required": true
18:     },
19:     "shareImage": {
20:       "type": "media",
21:       "multiple": false,
22:       "required": false,
23:       "allowedTypes": ["images"]
24:     }
25:   }
26: }
```

## File: apps/cms/src/components/shared/slider.json
```json
 1: {
 2:   "collectionName": "components_shared_sliders",
 3:   "info": {
 4:     "displayName": "Slider",
 5:     "icon": "address-book",
 6:     "description": ""
 7:   },
 8:   "options": {},
 9:   "attributes": {
10:     "files": {
11:       "type": "media",
12:       "multiple": true,
13:       "required": false,
14:       "allowedTypes": ["images"]
15:     }
16:   }
17: }
```

## File: apps/cms/src/providers/supabase/index.ts
```typescript
 1: import type { Readable } from 'stream'
 2: import type { ObjectCannedACL, S3ClientConfig } from '@aws-sdk/client-s3'
 3: import { S3, PutObjectCommand, DeleteObjectCommand } from '@aws-sdk/client-s3'
 4: 
 5: interface ProviderConfig {
 6:   endpoint: string
 7:   accessKeyId: string
 8:   secretAccessKey: string
 9:   bucket: string
10:   region: string
11: }
12: 
13: interface File {
14:   hash: string
15:   ext: string
16:   mime: string
17:   buffer: Buffer
18:   stream?: Readable
19:   url?: string
20:   path?: string
21: }
22: 
23: module.exports = {
24:   init(config: ProviderConfig) {
25:     // Configure S3 client
26:     const s3Config: S3ClientConfig = {
27:       endpoint: config.endpoint,
28:       credentials: {
29:         accessKeyId: config.accessKeyId,
30:         secretAccessKey: config.secretAccessKey,
31:       },
32:       region: config.region,
33:       forcePathStyle: true,
34:     }
35: 
36:     const s3 = new S3(s3Config)
37: 
38:     const getFileKey = (file: File): string => {
39:       const path = file.path ? `${file.path}/` : ''
40:       return `${path}${file.hash}${file.ext}`
41:     }
42: 
43:     const getFileUrl = (key: string): string => {
44:       // Get the base domain without protocol and trailing slashes
45:       const domain = config.endpoint
46:         .replace(/^https?:\/\//, '')
47:         .replace(/\/+$/, '')
48:         .replace('/s3', '/object')
49:       return `https://${domain}/public/${config.bucket}/${key}`
50:     }
51: 
52:     return {
53:       async upload(file: File): Promise<void> {
54:         const key = getFileKey(file)
55: 
56:         const params = {
57:           Bucket: config.bucket,
58:           Key: key,
59:           Body: file.stream || file.buffer,
60:           ACL: 'public-read' as ObjectCannedACL,
61:           ContentType: file.mime,
62:           Metadata: {
63:             'x-amz-meta-Cache-Control': 'public, max-age=31536000',
64:             'x-amz-meta-Access-Control-Allow-Origin': '*',
65:           },
66:         }
67: 
68:         // Upload file to Supabase storage
69:         await s3.send(new PutObjectCommand(params))
70: 
71:         // Set file URL directly
72:         file.url = getFileUrl(key)
73:       },
74: 
75:       async delete(file: File): Promise<void> {
76:         const key = getFileKey(file)
77: 
78:         const params = {
79:           Bucket: config.bucket,
80:           Key: key,
81:         }
82: 
83:         await s3.send(new DeleteObjectCommand(params))
84:       },
85:     }
86:   },
87: }
```

## File: apps/cms/src/index.ts
```typescript
 1: // import type { Core } from '@strapi/strapi';
 2: 
 3: export default {
 4:   /**
 5:    * An asynchronous register function that runs before
 6:    * your application is initialized.
 7:    *
 8:    * This gives you an opportunity to extend code.
 9:    */
10:   register(/* { strapi }: { strapi: Core.Strapi } */) {},
11: 
12:   /**
13:    * An asynchronous bootstrap function that runs before
14:    * your application gets started.
15:    *
16:    * This gives you an opportunity to set up your data model,
17:    * run jobs, or perform some special logic.
18:    */
19:   bootstrap(/* { strapi }: { strapi: Core.Strapi } */) {},
20: }
```

## File: apps/cms/types/generated/contentTypes.d.ts
```typescript
   1: import type { Schema, Struct } from '@strapi/strapi';
   2: 
   3: export interface AdminApiToken extends Struct.CollectionTypeSchema {
   4:   collectionName: 'strapi_api_tokens';
   5:   info: {
   6:     description: '';
   7:     displayName: 'Api Token';
   8:     name: 'Api Token';
   9:     pluralName: 'api-tokens';
  10:     singularName: 'api-token';
  11:   };
  12:   options: {
  13:     draftAndPublish: false;
  14:   };
  15:   pluginOptions: {
  16:     'content-manager': {
  17:       visible: false;
  18:     };
  19:     'content-type-builder': {
  20:       visible: false;
  21:     };
  22:   };
  23:   attributes: {
  24:     accessKey: Schema.Attribute.String &
  25:       Schema.Attribute.Required &
  26:       Schema.Attribute.SetMinMaxLength<{
  27:         minLength: 1;
  28:       }>;
  29:     createdAt: Schema.Attribute.DateTime;
  30:     createdBy: Schema.Attribute.Relation<'oneToOne', 'admin::user'> &
  31:       Schema.Attribute.Private;
  32:     description: Schema.Attribute.String &
  33:       Schema.Attribute.SetMinMaxLength<{
  34:         minLength: 1;
  35:       }> &
  36:       Schema.Attribute.DefaultTo<''>;
  37:     expiresAt: Schema.Attribute.DateTime;
  38:     lastUsedAt: Schema.Attribute.DateTime;
  39:     lifespan: Schema.Attribute.BigInteger;
  40:     locale: Schema.Attribute.String & Schema.Attribute.Private;
  41:     localizations: Schema.Attribute.Relation<'oneToMany', 'admin::api-token'> &
  42:       Schema.Attribute.Private;
  43:     name: Schema.Attribute.String &
  44:       Schema.Attribute.Required &
  45:       Schema.Attribute.Unique &
  46:       Schema.Attribute.SetMinMaxLength<{
  47:         minLength: 1;
  48:       }>;
  49:     permissions: Schema.Attribute.Relation<
  50:       'oneToMany',
  51:       'admin::api-token-permission'
  52:     >;
  53:     publishedAt: Schema.Attribute.DateTime;
  54:     type: Schema.Attribute.Enumeration<['read-only', 'full-access', 'custom']> &
  55:       Schema.Attribute.Required &
  56:       Schema.Attribute.DefaultTo<'read-only'>;
  57:     updatedAt: Schema.Attribute.DateTime;
  58:     updatedBy: Schema.Attribute.Relation<'oneToOne', 'admin::user'> &
  59:       Schema.Attribute.Private;
  60:   };
  61: }
  62: 
  63: export interface AdminApiTokenPermission extends Struct.CollectionTypeSchema {
  64:   collectionName: 'strapi_api_token_permissions';
  65:   info: {
  66:     description: '';
  67:     displayName: 'API Token Permission';
  68:     name: 'API Token Permission';
  69:     pluralName: 'api-token-permissions';
  70:     singularName: 'api-token-permission';
  71:   };
  72:   options: {
  73:     draftAndPublish: false;
  74:   };
  75:   pluginOptions: {
  76:     'content-manager': {
  77:       visible: false;
  78:     };
  79:     'content-type-builder': {
  80:       visible: false;
  81:     };
  82:   };
  83:   attributes: {
  84:     action: Schema.Attribute.String &
  85:       Schema.Attribute.Required &
  86:       Schema.Attribute.SetMinMaxLength<{
  87:         minLength: 1;
  88:       }>;
  89:     createdAt: Schema.Attribute.DateTime;
  90:     createdBy: Schema.Attribute.Relation<'oneToOne', 'admin::user'> &
  91:       Schema.Attribute.Private;
  92:     locale: Schema.Attribute.String & Schema.Attribute.Private;
  93:     localizations: Schema.Attribute.Relation<
  94:       'oneToMany',
  95:       'admin::api-token-permission'
  96:     > &
  97:       Schema.Attribute.Private;
  98:     publishedAt: Schema.Attribute.DateTime;
  99:     token: Schema.Attribute.Relation<'manyToOne', 'admin::api-token'>;
 100:     updatedAt: Schema.Attribute.DateTime;
 101:     updatedBy: Schema.Attribute.Relation<'oneToOne', 'admin::user'> &
 102:       Schema.Attribute.Private;
 103:   };
 104: }
 105: 
 106: export interface AdminPermission extends Struct.CollectionTypeSchema {
 107:   collectionName: 'admin_permissions';
 108:   info: {
 109:     description: '';
 110:     displayName: 'Permission';
 111:     name: 'Permission';
 112:     pluralName: 'permissions';
 113:     singularName: 'permission';
 114:   };
 115:   options: {
 116:     draftAndPublish: false;
 117:   };
 118:   pluginOptions: {
 119:     'content-manager': {
 120:       visible: false;
 121:     };
 122:     'content-type-builder': {
 123:       visible: false;
 124:     };
 125:   };
 126:   attributes: {
 127:     action: Schema.Attribute.String &
 128:       Schema.Attribute.Required &
 129:       Schema.Attribute.SetMinMaxLength<{
 130:         minLength: 1;
 131:       }>;
 132:     actionParameters: Schema.Attribute.JSON & Schema.Attribute.DefaultTo<{}>;
 133:     conditions: Schema.Attribute.JSON & Schema.Attribute.DefaultTo<[]>;
 134:     createdAt: Schema.Attribute.DateTime;
 135:     createdBy: Schema.Attribute.Relation<'oneToOne', 'admin::user'> &
 136:       Schema.Attribute.Private;
 137:     locale: Schema.Attribute.String & Schema.Attribute.Private;
 138:     localizations: Schema.Attribute.Relation<'oneToMany', 'admin::permission'> &
 139:       Schema.Attribute.Private;
 140:     properties: Schema.Attribute.JSON & Schema.Attribute.DefaultTo<{}>;
 141:     publishedAt: Schema.Attribute.DateTime;
 142:     role: Schema.Attribute.Relation<'manyToOne', 'admin::role'>;
 143:     subject: Schema.Attribute.String &
 144:       Schema.Attribute.SetMinMaxLength<{
 145:         minLength: 1;
 146:       }>;
 147:     updatedAt: Schema.Attribute.DateTime;
 148:     updatedBy: Schema.Attribute.Relation<'oneToOne', 'admin::user'> &
 149:       Schema.Attribute.Private;
 150:   };
 151: }
 152: 
 153: export interface AdminRole extends Struct.CollectionTypeSchema {
 154:   collectionName: 'admin_roles';
 155:   info: {
 156:     description: '';
 157:     displayName: 'Role';
 158:     name: 'Role';
 159:     pluralName: 'roles';
 160:     singularName: 'role';
 161:   };
 162:   options: {
 163:     draftAndPublish: false;
 164:   };
 165:   pluginOptions: {
 166:     'content-manager': {
 167:       visible: false;
 168:     };
 169:     'content-type-builder': {
 170:       visible: false;
 171:     };
 172:   };
 173:   attributes: {
 174:     code: Schema.Attribute.String &
 175:       Schema.Attribute.Required &
 176:       Schema.Attribute.Unique &
 177:       Schema.Attribute.SetMinMaxLength<{
 178:         minLength: 1;
 179:       }>;
 180:     createdAt: Schema.Attribute.DateTime;
 181:     createdBy: Schema.Attribute.Relation<'oneToOne', 'admin::user'> &
 182:       Schema.Attribute.Private;
 183:     description: Schema.Attribute.String;
 184:     locale: Schema.Attribute.String & Schema.Attribute.Private;
 185:     localizations: Schema.Attribute.Relation<'oneToMany', 'admin::role'> &
 186:       Schema.Attribute.Private;
 187:     name: Schema.Attribute.String &
 188:       Schema.Attribute.Required &
 189:       Schema.Attribute.Unique &
 190:       Schema.Attribute.SetMinMaxLength<{
 191:         minLength: 1;
 192:       }>;
 193:     permissions: Schema.Attribute.Relation<'oneToMany', 'admin::permission'>;
 194:     publishedAt: Schema.Attribute.DateTime;
 195:     updatedAt: Schema.Attribute.DateTime;
 196:     updatedBy: Schema.Attribute.Relation<'oneToOne', 'admin::user'> &
 197:       Schema.Attribute.Private;
 198:     users: Schema.Attribute.Relation<'manyToMany', 'admin::user'>;
 199:   };
 200: }
 201: 
 202: export interface AdminTransferToken extends Struct.CollectionTypeSchema {
 203:   collectionName: 'strapi_transfer_tokens';
 204:   info: {
 205:     description: '';
 206:     displayName: 'Transfer Token';
 207:     name: 'Transfer Token';
 208:     pluralName: 'transfer-tokens';
 209:     singularName: 'transfer-token';
 210:   };
 211:   options: {
 212:     draftAndPublish: false;
 213:   };
 214:   pluginOptions: {
 215:     'content-manager': {
 216:       visible: false;
 217:     };
 218:     'content-type-builder': {
 219:       visible: false;
 220:     };
 221:   };
 222:   attributes: {
 223:     accessKey: Schema.Attribute.String &
 224:       Schema.Attribute.Required &
 225:       Schema.Attribute.SetMinMaxLength<{
 226:         minLength: 1;
 227:       }>;
 228:     createdAt: Schema.Attribute.DateTime;
 229:     createdBy: Schema.Attribute.Relation<'oneToOne', 'admin::user'> &
 230:       Schema.Attribute.Private;
 231:     description: Schema.Attribute.String &
 232:       Schema.Attribute.SetMinMaxLength<{
 233:         minLength: 1;
 234:       }> &
 235:       Schema.Attribute.DefaultTo<''>;
 236:     expiresAt: Schema.Attribute.DateTime;
 237:     lastUsedAt: Schema.Attribute.DateTime;
 238:     lifespan: Schema.Attribute.BigInteger;
 239:     locale: Schema.Attribute.String & Schema.Attribute.Private;
 240:     localizations: Schema.Attribute.Relation<
 241:       'oneToMany',
 242:       'admin::transfer-token'
 243:     > &
 244:       Schema.Attribute.Private;
 245:     name: Schema.Attribute.String &
 246:       Schema.Attribute.Required &
 247:       Schema.Attribute.Unique &
 248:       Schema.Attribute.SetMinMaxLength<{
 249:         minLength: 1;
 250:       }>;
 251:     permissions: Schema.Attribute.Relation<
 252:       'oneToMany',
 253:       'admin::transfer-token-permission'
 254:     >;
 255:     publishedAt: Schema.Attribute.DateTime;
 256:     updatedAt: Schema.Attribute.DateTime;
 257:     updatedBy: Schema.Attribute.Relation<'oneToOne', 'admin::user'> &
 258:       Schema.Attribute.Private;
 259:   };
 260: }
 261: 
 262: export interface AdminTransferTokenPermission
 263:   extends Struct.CollectionTypeSchema {
 264:   collectionName: 'strapi_transfer_token_permissions';
 265:   info: {
 266:     description: '';
 267:     displayName: 'Transfer Token Permission';
 268:     name: 'Transfer Token Permission';
 269:     pluralName: 'transfer-token-permissions';
 270:     singularName: 'transfer-token-permission';
 271:   };
 272:   options: {
 273:     draftAndPublish: false;
 274:   };
 275:   pluginOptions: {
 276:     'content-manager': {
 277:       visible: false;
 278:     };
 279:     'content-type-builder': {
 280:       visible: false;
 281:     };
 282:   };
 283:   attributes: {
 284:     action: Schema.Attribute.String &
 285:       Schema.Attribute.Required &
 286:       Schema.Attribute.SetMinMaxLength<{
 287:         minLength: 1;
 288:       }>;
 289:     createdAt: Schema.Attribute.DateTime;
 290:     createdBy: Schema.Attribute.Relation<'oneToOne', 'admin::user'> &
 291:       Schema.Attribute.Private;
 292:     locale: Schema.Attribute.String & Schema.Attribute.Private;
 293:     localizations: Schema.Attribute.Relation<
 294:       'oneToMany',
 295:       'admin::transfer-token-permission'
 296:     > &
 297:       Schema.Attribute.Private;
 298:     publishedAt: Schema.Attribute.DateTime;
 299:     token: Schema.Attribute.Relation<'manyToOne', 'admin::transfer-token'>;
 300:     updatedAt: Schema.Attribute.DateTime;
 301:     updatedBy: Schema.Attribute.Relation<'oneToOne', 'admin::user'> &
 302:       Schema.Attribute.Private;
 303:   };
 304: }
 305: 
 306: export interface AdminUser extends Struct.CollectionTypeSchema {
 307:   collectionName: 'admin_users';
 308:   info: {
 309:     description: '';
 310:     displayName: 'User';
 311:     name: 'User';
 312:     pluralName: 'users';
 313:     singularName: 'user';
 314:   };
 315:   options: {
 316:     draftAndPublish: false;
 317:   };
 318:   pluginOptions: {
 319:     'content-manager': {
 320:       visible: false;
 321:     };
 322:     'content-type-builder': {
 323:       visible: false;
 324:     };
 325:   };
 326:   attributes: {
 327:     blocked: Schema.Attribute.Boolean &
 328:       Schema.Attribute.Private &
 329:       Schema.Attribute.DefaultTo<false>;
 330:     createdAt: Schema.Attribute.DateTime;
 331:     createdBy: Schema.Attribute.Relation<'oneToOne', 'admin::user'> &
 332:       Schema.Attribute.Private;
 333:     email: Schema.Attribute.Email &
 334:       Schema.Attribute.Required &
 335:       Schema.Attribute.Private &
 336:       Schema.Attribute.Unique &
 337:       Schema.Attribute.SetMinMaxLength<{
 338:         minLength: 6;
 339:       }>;
 340:     firstname: Schema.Attribute.String &
 341:       Schema.Attribute.SetMinMaxLength<{
 342:         minLength: 1;
 343:       }>;
 344:     isActive: Schema.Attribute.Boolean &
 345:       Schema.Attribute.Private &
 346:       Schema.Attribute.DefaultTo<false>;
 347:     lastname: Schema.Attribute.String &
 348:       Schema.Attribute.SetMinMaxLength<{
 349:         minLength: 1;
 350:       }>;
 351:     locale: Schema.Attribute.String & Schema.Attribute.Private;
 352:     localizations: Schema.Attribute.Relation<'oneToMany', 'admin::user'> &
 353:       Schema.Attribute.Private;
 354:     password: Schema.Attribute.Password &
 355:       Schema.Attribute.Private &
 356:       Schema.Attribute.SetMinMaxLength<{
 357:         minLength: 6;
 358:       }>;
 359:     preferedLanguage: Schema.Attribute.String;
 360:     publishedAt: Schema.Attribute.DateTime;
 361:     registrationToken: Schema.Attribute.String & Schema.Attribute.Private;
 362:     resetPasswordToken: Schema.Attribute.String & Schema.Attribute.Private;
 363:     roles: Schema.Attribute.Relation<'manyToMany', 'admin::role'> &
 364:       Schema.Attribute.Private;
 365:     updatedAt: Schema.Attribute.DateTime;
 366:     updatedBy: Schema.Attribute.Relation<'oneToOne', 'admin::user'> &
 367:       Schema.Attribute.Private;
 368:     username: Schema.Attribute.String;
 369:   };
 370: }
 371: 
 372: export interface ApiAboutAbout extends Struct.SingleTypeSchema {
 373:   collectionName: 'abouts';
 374:   info: {
 375:     description: 'Write about yourself and the content you create';
 376:     displayName: 'About';
 377:     pluralName: 'abouts';
 378:     singularName: 'about';
 379:   };
 380:   options: {
 381:     draftAndPublish: false;
 382:   };
 383:   attributes: {
 384:     blocks: Schema.Attribute.DynamicZone<
 385:       ['shared.media', 'shared.quote', 'shared.rich-text', 'shared.slider']
 386:     >;
 387:     createdAt: Schema.Attribute.DateTime;
 388:     createdBy: Schema.Attribute.Relation<'oneToOne', 'admin::user'> &
 389:       Schema.Attribute.Private;
 390:     locale: Schema.Attribute.String & Schema.Attribute.Private;
 391:     localizations: Schema.Attribute.Relation<'oneToMany', 'api::about.about'> &
 392:       Schema.Attribute.Private;
 393:     publishedAt: Schema.Attribute.DateTime;
 394:     title: Schema.Attribute.String;
 395:     updatedAt: Schema.Attribute.DateTime;
 396:     updatedBy: Schema.Attribute.Relation<'oneToOne', 'admin::user'> &
 397:       Schema.Attribute.Private;
 398:   };
 399: }
 400: 
 401: export interface ApiArticleArticle extends Struct.CollectionTypeSchema {
 402:   collectionName: 'articles';
 403:   info: {
 404:     description: 'Create your blog content';
 405:     displayName: 'Article';
 406:     pluralName: 'articles';
 407:     singularName: 'article';
 408:   };
 409:   options: {
 410:     draftAndPublish: true;
 411:   };
 412:   attributes: {
 413:     author: Schema.Attribute.Relation<'manyToOne', 'api::author.author'>;
 414:     blocks: Schema.Attribute.DynamicZone<
 415:       ['shared.media', 'shared.quote', 'shared.rich-text', 'shared.slider']
 416:     >;
 417:     category: Schema.Attribute.Relation<'manyToOne', 'api::category.category'>;
 418:     cover: Schema.Attribute.Media<'images' | 'files' | 'videos'>;
 419:     createdAt: Schema.Attribute.DateTime;
 420:     createdBy: Schema.Attribute.Relation<'oneToOne', 'admin::user'> &
 421:       Schema.Attribute.Private;
 422:     description: Schema.Attribute.Text &
 423:       Schema.Attribute.SetMinMaxLength<{
 424:         maxLength: 240;
 425:       }>;
 426:     locale: Schema.Attribute.String & Schema.Attribute.Private;
 427:     localizations: Schema.Attribute.Relation<
 428:       'oneToMany',
 429:       'api::article.article'
 430:     > &
 431:       Schema.Attribute.Private;
 432:     publishedAt: Schema.Attribute.DateTime;
 433:     slug: Schema.Attribute.UID<'title'>;
 434:     tags: Schema.Attribute.Relation<'manyToMany', 'api::tag.tag'>;
 435:     title: Schema.Attribute.String;
 436:     updatedAt: Schema.Attribute.DateTime;
 437:     updatedBy: Schema.Attribute.Relation<'oneToOne', 'admin::user'> &
 438:       Schema.Attribute.Private;
 439:   };
 440: }
 441: 
 442: export interface ApiAuthorAuthor extends Struct.CollectionTypeSchema {
 443:   collectionName: 'authors';
 444:   info: {
 445:     description: 'Create authors for your content';
 446:     displayName: 'Author';
 447:     pluralName: 'authors';
 448:     singularName: 'author';
 449:   };
 450:   options: {
 451:     draftAndPublish: false;
 452:   };
 453:   attributes: {
 454:     articles: Schema.Attribute.Relation<'oneToMany', 'api::article.article'>;
 455:     avatar: Schema.Attribute.Media<'images' | 'files' | 'videos'>;
 456:     bio: Schema.Attribute.Text;
 457:     createdAt: Schema.Attribute.DateTime;
 458:     createdBy: Schema.Attribute.Relation<'oneToOne', 'admin::user'> &
 459:       Schema.Attribute.Private;
 460:     email: Schema.Attribute.String;
 461:     locale: Schema.Attribute.String & Schema.Attribute.Private;
 462:     localizations: Schema.Attribute.Relation<
 463:       'oneToMany',
 464:       'api::author.author'
 465:     > &
 466:       Schema.Attribute.Private;
 467:     name: Schema.Attribute.String;
 468:     publishedAt: Schema.Attribute.DateTime;
 469:     socials: Schema.Attribute.JSON;
 470:     updatedAt: Schema.Attribute.DateTime;
 471:     updatedBy: Schema.Attribute.Relation<'oneToOne', 'admin::user'> &
 472:       Schema.Attribute.Private;
 473:   };
 474: }
 475: 
 476: export interface ApiCategoryCategory extends Struct.CollectionTypeSchema {
 477:   collectionName: 'categories';
 478:   info: {
 479:     description: 'Organize your content into categories';
 480:     displayName: 'Category';
 481:     pluralName: 'categories';
 482:     singularName: 'category';
 483:   };
 484:   options: {
 485:     draftAndPublish: false;
 486:   };
 487:   attributes: {
 488:     articles: Schema.Attribute.Relation<'oneToMany', 'api::article.article'>;
 489:     createdAt: Schema.Attribute.DateTime;
 490:     createdBy: Schema.Attribute.Relation<'oneToOne', 'admin::user'> &
 491:       Schema.Attribute.Private;
 492:     description: Schema.Attribute.Text;
 493:     locale: Schema.Attribute.String & Schema.Attribute.Private;
 494:     localizations: Schema.Attribute.Relation<
 495:       'oneToMany',
 496:       'api::category.category'
 497:     > &
 498:       Schema.Attribute.Private;
 499:     name: Schema.Attribute.String;
 500:     publishedAt: Schema.Attribute.DateTime;
 501:     slug: Schema.Attribute.UID;
 502:     updatedAt: Schema.Attribute.DateTime;
 503:     updatedBy: Schema.Attribute.Relation<'oneToOne', 'admin::user'> &
 504:       Schema.Attribute.Private;
 505:   };
 506: }
 507: 
 508: export interface ApiGlobalGlobal extends Struct.SingleTypeSchema {
 509:   collectionName: 'globals';
 510:   info: {
 511:     description: 'Define global settings';
 512:     displayName: 'Global';
 513:     pluralName: 'globals';
 514:     singularName: 'global';
 515:   };
 516:   options: {
 517:     draftAndPublish: false;
 518:   };
 519:   attributes: {
 520:     createdAt: Schema.Attribute.DateTime;
 521:     createdBy: Schema.Attribute.Relation<'oneToOne', 'admin::user'> &
 522:       Schema.Attribute.Private;
 523:     defaultSeo: Schema.Attribute.Component<'shared.seo', false>;
 524:     favicon: Schema.Attribute.Media<'images' | 'files' | 'videos'>;
 525:     locale: Schema.Attribute.String & Schema.Attribute.Private;
 526:     localizations: Schema.Attribute.Relation<
 527:       'oneToMany',
 528:       'api::global.global'
 529:     > &
 530:       Schema.Attribute.Private;
 531:     publishedAt: Schema.Attribute.DateTime;
 532:     siteDescription: Schema.Attribute.Text & Schema.Attribute.Required;
 533:     siteName: Schema.Attribute.String & Schema.Attribute.Required;
 534:     updatedAt: Schema.Attribute.DateTime;
 535:     updatedBy: Schema.Attribute.Relation<'oneToOne', 'admin::user'> &
 536:       Schema.Attribute.Private;
 537:   };
 538: }
 539: 
 540: export interface ApiTagTag extends Struct.CollectionTypeSchema {
 541:   collectionName: 'tags';
 542:   info: {
 543:     description: '';
 544:     displayName: 'Tags';
 545:     pluralName: 'tags';
 546:     singularName: 'tag';
 547:   };
 548:   options: {
 549:     draftAndPublish: false;
 550:   };
 551:   attributes: {
 552:     article: Schema.Attribute.Relation<'manyToMany', 'api::article.article'>;
 553:     createdAt: Schema.Attribute.DateTime;
 554:     createdBy: Schema.Attribute.Relation<'oneToOne', 'admin::user'> &
 555:       Schema.Attribute.Private;
 556:     locale: Schema.Attribute.String & Schema.Attribute.Private;
 557:     localizations: Schema.Attribute.Relation<'oneToMany', 'api::tag.tag'> &
 558:       Schema.Attribute.Private;
 559:     name: Schema.Attribute.String;
 560:     publishedAt: Schema.Attribute.DateTime;
 561:     updatedAt: Schema.Attribute.DateTime;
 562:     updatedBy: Schema.Attribute.Relation<'oneToOne', 'admin::user'> &
 563:       Schema.Attribute.Private;
 564:   };
 565: }
 566: 
 567: export interface PluginContentReleasesRelease
 568:   extends Struct.CollectionTypeSchema {
 569:   collectionName: 'strapi_releases';
 570:   info: {
 571:     displayName: 'Release';
 572:     pluralName: 'releases';
 573:     singularName: 'release';
 574:   };
 575:   options: {
 576:     draftAndPublish: false;
 577:   };
 578:   pluginOptions: {
 579:     'content-manager': {
 580:       visible: false;
 581:     };
 582:     'content-type-builder': {
 583:       visible: false;
 584:     };
 585:   };
 586:   attributes: {
 587:     actions: Schema.Attribute.Relation<
 588:       'oneToMany',
 589:       'plugin::content-releases.release-action'
 590:     >;
 591:     createdAt: Schema.Attribute.DateTime;
 592:     createdBy: Schema.Attribute.Relation<'oneToOne', 'admin::user'> &
 593:       Schema.Attribute.Private;
 594:     locale: Schema.Attribute.String & Schema.Attribute.Private;
 595:     localizations: Schema.Attribute.Relation<
 596:       'oneToMany',
 597:       'plugin::content-releases.release'
 598:     > &
 599:       Schema.Attribute.Private;
 600:     name: Schema.Attribute.String & Schema.Attribute.Required;
 601:     publishedAt: Schema.Attribute.DateTime;
 602:     releasedAt: Schema.Attribute.DateTime;
 603:     scheduledAt: Schema.Attribute.DateTime;
 604:     status: Schema.Attribute.Enumeration<
 605:       ['ready', 'blocked', 'failed', 'done', 'empty']
 606:     > &
 607:       Schema.Attribute.Required;
 608:     timezone: Schema.Attribute.String;
 609:     updatedAt: Schema.Attribute.DateTime;
 610:     updatedBy: Schema.Attribute.Relation<'oneToOne', 'admin::user'> &
 611:       Schema.Attribute.Private;
 612:   };
 613: }
 614: 
 615: export interface PluginContentReleasesReleaseAction
 616:   extends Struct.CollectionTypeSchema {
 617:   collectionName: 'strapi_release_actions';
 618:   info: {
 619:     displayName: 'Release Action';
 620:     pluralName: 'release-actions';
 621:     singularName: 'release-action';
 622:   };
 623:   options: {
 624:     draftAndPublish: false;
 625:   };
 626:   pluginOptions: {
 627:     'content-manager': {
 628:       visible: false;
 629:     };
 630:     'content-type-builder': {
 631:       visible: false;
 632:     };
 633:   };
 634:   attributes: {
 635:     contentType: Schema.Attribute.String & Schema.Attribute.Required;
 636:     createdAt: Schema.Attribute.DateTime;
 637:     createdBy: Schema.Attribute.Relation<'oneToOne', 'admin::user'> &
 638:       Schema.Attribute.Private;
 639:     entryDocumentId: Schema.Attribute.String;
 640:     isEntryValid: Schema.Attribute.Boolean;
 641:     locale: Schema.Attribute.String & Schema.Attribute.Private;
 642:     localizations: Schema.Attribute.Relation<
 643:       'oneToMany',
 644:       'plugin::content-releases.release-action'
 645:     > &
 646:       Schema.Attribute.Private;
 647:     publishedAt: Schema.Attribute.DateTime;
 648:     release: Schema.Attribute.Relation<
 649:       'manyToOne',
 650:       'plugin::content-releases.release'
 651:     >;
 652:     type: Schema.Attribute.Enumeration<['publish', 'unpublish']> &
 653:       Schema.Attribute.Required;
 654:     updatedAt: Schema.Attribute.DateTime;
 655:     updatedBy: Schema.Attribute.Relation<'oneToOne', 'admin::user'> &
 656:       Schema.Attribute.Private;
 657:   };
 658: }
 659: 
 660: export interface PluginI18NLocale extends Struct.CollectionTypeSchema {
 661:   collectionName: 'i18n_locale';
 662:   info: {
 663:     collectionName: 'locales';
 664:     description: '';
 665:     displayName: 'Locale';
 666:     pluralName: 'locales';
 667:     singularName: 'locale';
 668:   };
 669:   options: {
 670:     draftAndPublish: false;
 671:   };
 672:   pluginOptions: {
 673:     'content-manager': {
 674:       visible: false;
 675:     };
 676:     'content-type-builder': {
 677:       visible: false;
 678:     };
 679:   };
 680:   attributes: {
 681:     code: Schema.Attribute.String & Schema.Attribute.Unique;
 682:     createdAt: Schema.Attribute.DateTime;
 683:     createdBy: Schema.Attribute.Relation<'oneToOne', 'admin::user'> &
 684:       Schema.Attribute.Private;
 685:     locale: Schema.Attribute.String & Schema.Attribute.Private;
 686:     localizations: Schema.Attribute.Relation<
 687:       'oneToMany',
 688:       'plugin::i18n.locale'
 689:     > &
 690:       Schema.Attribute.Private;
 691:     name: Schema.Attribute.String &
 692:       Schema.Attribute.SetMinMax<
 693:         {
 694:           max: 50;
 695:           min: 1;
 696:         },
 697:         number
 698:       >;
 699:     publishedAt: Schema.Attribute.DateTime;
 700:     updatedAt: Schema.Attribute.DateTime;
 701:     updatedBy: Schema.Attribute.Relation<'oneToOne', 'admin::user'> &
 702:       Schema.Attribute.Private;
 703:   };
 704: }
 705: 
 706: export interface PluginReviewWorkflowsWorkflow
 707:   extends Struct.CollectionTypeSchema {
 708:   collectionName: 'strapi_workflows';
 709:   info: {
 710:     description: '';
 711:     displayName: 'Workflow';
 712:     name: 'Workflow';
 713:     pluralName: 'workflows';
 714:     singularName: 'workflow';
 715:   };
 716:   options: {
 717:     draftAndPublish: false;
 718:   };
 719:   pluginOptions: {
 720:     'content-manager': {
 721:       visible: false;
 722:     };
 723:     'content-type-builder': {
 724:       visible: false;
 725:     };
 726:   };
 727:   attributes: {
 728:     contentTypes: Schema.Attribute.JSON &
 729:       Schema.Attribute.Required &
 730:       Schema.Attribute.DefaultTo<'[]'>;
 731:     createdAt: Schema.Attribute.DateTime;
 732:     createdBy: Schema.Attribute.Relation<'oneToOne', 'admin::user'> &
 733:       Schema.Attribute.Private;
 734:     locale: Schema.Attribute.String & Schema.Attribute.Private;
 735:     localizations: Schema.Attribute.Relation<
 736:       'oneToMany',
 737:       'plugin::review-workflows.workflow'
 738:     > &
 739:       Schema.Attribute.Private;
 740:     name: Schema.Attribute.String &
 741:       Schema.Attribute.Required &
 742:       Schema.Attribute.Unique;
 743:     publishedAt: Schema.Attribute.DateTime;
 744:     stages: Schema.Attribute.Relation<
 745:       'oneToMany',
 746:       'plugin::review-workflows.workflow-stage'
 747:     >;
 748:     updatedAt: Schema.Attribute.DateTime;
 749:     updatedBy: Schema.Attribute.Relation<'oneToOne', 'admin::user'> &
 750:       Schema.Attribute.Private;
 751:   };
 752: }
 753: 
 754: export interface PluginReviewWorkflowsWorkflowStage
 755:   extends Struct.CollectionTypeSchema {
 756:   collectionName: 'strapi_workflows_stages';
 757:   info: {
 758:     description: '';
 759:     displayName: 'Stages';
 760:     name: 'Workflow Stage';
 761:     pluralName: 'workflow-stages';
 762:     singularName: 'workflow-stage';
 763:   };
 764:   options: {
 765:     draftAndPublish: false;
 766:     version: '1.1.0';
 767:   };
 768:   pluginOptions: {
 769:     'content-manager': {
 770:       visible: false;
 771:     };
 772:     'content-type-builder': {
 773:       visible: false;
 774:     };
 775:   };
 776:   attributes: {
 777:     color: Schema.Attribute.String & Schema.Attribute.DefaultTo<'#4945FF'>;
 778:     createdAt: Schema.Attribute.DateTime;
 779:     createdBy: Schema.Attribute.Relation<'oneToOne', 'admin::user'> &
 780:       Schema.Attribute.Private;
 781:     locale: Schema.Attribute.String & Schema.Attribute.Private;
 782:     localizations: Schema.Attribute.Relation<
 783:       'oneToMany',
 784:       'plugin::review-workflows.workflow-stage'
 785:     > &
 786:       Schema.Attribute.Private;
 787:     name: Schema.Attribute.String;
 788:     permissions: Schema.Attribute.Relation<'manyToMany', 'admin::permission'>;
 789:     publishedAt: Schema.Attribute.DateTime;
 790:     updatedAt: Schema.Attribute.DateTime;
 791:     updatedBy: Schema.Attribute.Relation<'oneToOne', 'admin::user'> &
 792:       Schema.Attribute.Private;
 793:     workflow: Schema.Attribute.Relation<
 794:       'manyToOne',
 795:       'plugin::review-workflows.workflow'
 796:     >;
 797:   };
 798: }
 799: 
 800: export interface PluginUploadFile extends Struct.CollectionTypeSchema {
 801:   collectionName: 'files';
 802:   info: {
 803:     description: '';
 804:     displayName: 'File';
 805:     pluralName: 'files';
 806:     singularName: 'file';
 807:   };
 808:   options: {
 809:     draftAndPublish: false;
 810:   };
 811:   pluginOptions: {
 812:     'content-manager': {
 813:       visible: false;
 814:     };
 815:     'content-type-builder': {
 816:       visible: false;
 817:     };
 818:   };
 819:   attributes: {
 820:     alternativeText: Schema.Attribute.String;
 821:     caption: Schema.Attribute.String;
 822:     createdAt: Schema.Attribute.DateTime;
 823:     createdBy: Schema.Attribute.Relation<'oneToOne', 'admin::user'> &
 824:       Schema.Attribute.Private;
 825:     ext: Schema.Attribute.String;
 826:     folder: Schema.Attribute.Relation<'manyToOne', 'plugin::upload.folder'> &
 827:       Schema.Attribute.Private;
 828:     folderPath: Schema.Attribute.String &
 829:       Schema.Attribute.Required &
 830:       Schema.Attribute.Private &
 831:       Schema.Attribute.SetMinMaxLength<{
 832:         minLength: 1;
 833:       }>;
 834:     formats: Schema.Attribute.JSON;
 835:     hash: Schema.Attribute.String & Schema.Attribute.Required;
 836:     height: Schema.Attribute.Integer;
 837:     locale: Schema.Attribute.String & Schema.Attribute.Private;
 838:     localizations: Schema.Attribute.Relation<
 839:       'oneToMany',
 840:       'plugin::upload.file'
 841:     > &
 842:       Schema.Attribute.Private;
 843:     mime: Schema.Attribute.String & Schema.Attribute.Required;
 844:     name: Schema.Attribute.String & Schema.Attribute.Required;
 845:     previewUrl: Schema.Attribute.String;
 846:     provider: Schema.Attribute.String & Schema.Attribute.Required;
 847:     provider_metadata: Schema.Attribute.JSON;
 848:     publishedAt: Schema.Attribute.DateTime;
 849:     related: Schema.Attribute.Relation<'morphToMany'>;
 850:     size: Schema.Attribute.Decimal & Schema.Attribute.Required;
 851:     updatedAt: Schema.Attribute.DateTime;
 852:     updatedBy: Schema.Attribute.Relation<'oneToOne', 'admin::user'> &
 853:       Schema.Attribute.Private;
 854:     url: Schema.Attribute.String & Schema.Attribute.Required;
 855:     width: Schema.Attribute.Integer;
 856:   };
 857: }
 858: 
 859: export interface PluginUploadFolder extends Struct.CollectionTypeSchema {
 860:   collectionName: 'upload_folders';
 861:   info: {
 862:     displayName: 'Folder';
 863:     pluralName: 'folders';
 864:     singularName: 'folder';
 865:   };
 866:   options: {
 867:     draftAndPublish: false;
 868:   };
 869:   pluginOptions: {
 870:     'content-manager': {
 871:       visible: false;
 872:     };
 873:     'content-type-builder': {
 874:       visible: false;
 875:     };
 876:   };
 877:   attributes: {
 878:     children: Schema.Attribute.Relation<'oneToMany', 'plugin::upload.folder'>;
 879:     createdAt: Schema.Attribute.DateTime;
 880:     createdBy: Schema.Attribute.Relation<'oneToOne', 'admin::user'> &
 881:       Schema.Attribute.Private;
 882:     files: Schema.Attribute.Relation<'oneToMany', 'plugin::upload.file'>;
 883:     locale: Schema.Attribute.String & Schema.Attribute.Private;
 884:     localizations: Schema.Attribute.Relation<
 885:       'oneToMany',
 886:       'plugin::upload.folder'
 887:     > &
 888:       Schema.Attribute.Private;
 889:     name: Schema.Attribute.String &
 890:       Schema.Attribute.Required &
 891:       Schema.Attribute.SetMinMaxLength<{
 892:         minLength: 1;
 893:       }>;
 894:     parent: Schema.Attribute.Relation<'manyToOne', 'plugin::upload.folder'>;
 895:     path: Schema.Attribute.String &
 896:       Schema.Attribute.Required &
 897:       Schema.Attribute.SetMinMaxLength<{
 898:         minLength: 1;
 899:       }>;
 900:     pathId: Schema.Attribute.Integer &
 901:       Schema.Attribute.Required &
 902:       Schema.Attribute.Unique;
 903:     publishedAt: Schema.Attribute.DateTime;
 904:     updatedAt: Schema.Attribute.DateTime;
 905:     updatedBy: Schema.Attribute.Relation<'oneToOne', 'admin::user'> &
 906:       Schema.Attribute.Private;
 907:   };
 908: }
 909: 
 910: export interface PluginUsersPermissionsPermission
 911:   extends Struct.CollectionTypeSchema {
 912:   collectionName: 'up_permissions';
 913:   info: {
 914:     description: '';
 915:     displayName: 'Permission';
 916:     name: 'permission';
 917:     pluralName: 'permissions';
 918:     singularName: 'permission';
 919:   };
 920:   options: {
 921:     draftAndPublish: false;
 922:   };
 923:   pluginOptions: {
 924:     'content-manager': {
 925:       visible: false;
 926:     };
 927:     'content-type-builder': {
 928:       visible: false;
 929:     };
 930:   };
 931:   attributes: {
 932:     action: Schema.Attribute.String & Schema.Attribute.Required;
 933:     createdAt: Schema.Attribute.DateTime;
 934:     createdBy: Schema.Attribute.Relation<'oneToOne', 'admin::user'> &
 935:       Schema.Attribute.Private;
 936:     locale: Schema.Attribute.String & Schema.Attribute.Private;
 937:     localizations: Schema.Attribute.Relation<
 938:       'oneToMany',
 939:       'plugin::users-permissions.permission'
 940:     > &
 941:       Schema.Attribute.Private;
 942:     publishedAt: Schema.Attribute.DateTime;
 943:     role: Schema.Attribute.Relation<
 944:       'manyToOne',
 945:       'plugin::users-permissions.role'
 946:     >;
 947:     updatedAt: Schema.Attribute.DateTime;
 948:     updatedBy: Schema.Attribute.Relation<'oneToOne', 'admin::user'> &
 949:       Schema.Attribute.Private;
 950:   };
 951: }
 952: 
 953: export interface PluginUsersPermissionsRole
 954:   extends Struct.CollectionTypeSchema {
 955:   collectionName: 'up_roles';
 956:   info: {
 957:     description: '';
 958:     displayName: 'Role';
 959:     name: 'role';
 960:     pluralName: 'roles';
 961:     singularName: 'role';
 962:   };
 963:   options: {
 964:     draftAndPublish: false;
 965:   };
 966:   pluginOptions: {
 967:     'content-manager': {
 968:       visible: false;
 969:     };
 970:     'content-type-builder': {
 971:       visible: false;
 972:     };
 973:   };
 974:   attributes: {
 975:     createdAt: Schema.Attribute.DateTime;
 976:     createdBy: Schema.Attribute.Relation<'oneToOne', 'admin::user'> &
 977:       Schema.Attribute.Private;
 978:     description: Schema.Attribute.String;
 979:     locale: Schema.Attribute.String & Schema.Attribute.Private;
 980:     localizations: Schema.Attribute.Relation<
 981:       'oneToMany',
 982:       'plugin::users-permissions.role'
 983:     > &
 984:       Schema.Attribute.Private;
 985:     name: Schema.Attribute.String &
 986:       Schema.Attribute.Required &
 987:       Schema.Attribute.SetMinMaxLength<{
 988:         minLength: 3;
 989:       }>;
 990:     permissions: Schema.Attribute.Relation<
 991:       'oneToMany',
 992:       'plugin::users-permissions.permission'
 993:     >;
 994:     publishedAt: Schema.Attribute.DateTime;
 995:     type: Schema.Attribute.String & Schema.Attribute.Unique;
 996:     updatedAt: Schema.Attribute.DateTime;
 997:     updatedBy: Schema.Attribute.Relation<'oneToOne', 'admin::user'> &
 998:       Schema.Attribute.Private;
 999:     users: Schema.Attribute.Relation<
1000:       'oneToMany',
1001:       'plugin::users-permissions.user'
1002:     >;
1003:   };
1004: }
1005: 
1006: export interface PluginUsersPermissionsUser
1007:   extends Struct.CollectionTypeSchema {
1008:   collectionName: 'up_users';
1009:   info: {
1010:     description: '';
1011:     displayName: 'User';
1012:     name: 'user';
1013:     pluralName: 'users';
1014:     singularName: 'user';
1015:   };
1016:   options: {
1017:     draftAndPublish: false;
1018:     timestamps: true;
1019:   };
1020:   attributes: {
1021:     blocked: Schema.Attribute.Boolean & Schema.Attribute.DefaultTo<false>;
1022:     confirmationToken: Schema.Attribute.String & Schema.Attribute.Private;
1023:     confirmed: Schema.Attribute.Boolean & Schema.Attribute.DefaultTo<false>;
1024:     createdAt: Schema.Attribute.DateTime;
1025:     createdBy: Schema.Attribute.Relation<'oneToOne', 'admin::user'> &
1026:       Schema.Attribute.Private;
1027:     email: Schema.Attribute.Email &
1028:       Schema.Attribute.Required &
1029:       Schema.Attribute.SetMinMaxLength<{
1030:         minLength: 6;
1031:       }>;
1032:     locale: Schema.Attribute.String & Schema.Attribute.Private;
1033:     localizations: Schema.Attribute.Relation<
1034:       'oneToMany',
1035:       'plugin::users-permissions.user'
1036:     > &
1037:       Schema.Attribute.Private;
1038:     password: Schema.Attribute.Password &
1039:       Schema.Attribute.Private &
1040:       Schema.Attribute.SetMinMaxLength<{
1041:         minLength: 6;
1042:       }>;
1043:     provider: Schema.Attribute.String;
1044:     publishedAt: Schema.Attribute.DateTime;
1045:     resetPasswordToken: Schema.Attribute.String & Schema.Attribute.Private;
1046:     role: Schema.Attribute.Relation<
1047:       'manyToOne',
1048:       'plugin::users-permissions.role'
1049:     >;
1050:     updatedAt: Schema.Attribute.DateTime;
1051:     updatedBy: Schema.Attribute.Relation<'oneToOne', 'admin::user'> &
1052:       Schema.Attribute.Private;
1053:     username: Schema.Attribute.String &
1054:       Schema.Attribute.Required &
1055:       Schema.Attribute.Unique &
1056:       Schema.Attribute.SetMinMaxLength<{
1057:         minLength: 3;
1058:       }>;
1059:   };
1060: }
1061: 
1062: declare module '@strapi/strapi' {
1063:   export module Public {
1064:     export interface ContentTypeSchemas {
1065:       'admin::api-token': AdminApiToken;
1066:       'admin::api-token-permission': AdminApiTokenPermission;
1067:       'admin::permission': AdminPermission;
1068:       'admin::role': AdminRole;
1069:       'admin::transfer-token': AdminTransferToken;
1070:       'admin::transfer-token-permission': AdminTransferTokenPermission;
1071:       'admin::user': AdminUser;
1072:       'api::about.about': ApiAboutAbout;
1073:       'api::article.article': ApiArticleArticle;
1074:       'api::author.author': ApiAuthorAuthor;
1075:       'api::category.category': ApiCategoryCategory;
1076:       'api::global.global': ApiGlobalGlobal;
1077:       'api::tag.tag': ApiTagTag;
1078:       'plugin::content-releases.release': PluginContentReleasesRelease;
1079:       'plugin::content-releases.release-action': PluginContentReleasesReleaseAction;
1080:       'plugin::i18n.locale': PluginI18NLocale;
1081:       'plugin::review-workflows.workflow': PluginReviewWorkflowsWorkflow;
1082:       'plugin::review-workflows.workflow-stage': PluginReviewWorkflowsWorkflowStage;
1083:       'plugin::upload.file': PluginUploadFile;
1084:       'plugin::upload.folder': PluginUploadFolder;
1085:       'plugin::users-permissions.permission': PluginUsersPermissionsPermission;
1086:       'plugin::users-permissions.role': PluginUsersPermissionsRole;
1087:       'plugin::users-permissions.user': PluginUsersPermissionsUser;
1088:     }
1089:   }
1090: }
```

## File: apps/cms/package.json
```json
 1: {
 2:   "name": "cms",
 3:   "version": "0.1.0",
 4:   "private": true,
 5:   "description": "A Strapi application",
 6:   "scripts": {
 7:     "build": "strapi build --debug",
 8:     "deploy": "strapi deploy",
 9:     "dev": "strapi develop --debug",
10:     "seed:example": "node ./scripts/seed.js",
11:     "start": "strapi start",
12:     "strapi": "strapi"
13:   },
14:   "dependencies": {
15:     "@strapi/plugin-cloud": "5.1.0",
16:     "@strapi/plugin-users-permissions": "5.1.0",
17:     "@strapi/strapi": "^5.1.0",
18:     "@strapi/provider-upload-aws-s3": "^5.1.1",
19:     "strapi-provider-upload-supabase": "file:dist/src/providers/supabase",
20:     "@aws-sdk/client-s3": "^3.679.0",
21:     "@aws-sdk/s3-request-presigner": "^3.679.0",
22:     "fs-extra": "^10.0.0",
23:     "mime-types": "^2.1.27",
24:     "pg": "^8.13.0",
25:     "react": "^18.0.0",
26:     "react-dom": "^18.0.0",
27:     "react-router-dom": "^6.0.0",
28:     "styled-components": "^6.0.0"
29:   },
30:   "devDependencies": {
31:     "@types/node": "^20",
32:     "@types/aws-sdk": "^0.0.42",
33:     "@types/react": "^18",
34:     "@types/react-dom": "^18",
35:     "typescript": "^5"
36:   },
37:   "engines": {
38:     "node": ">=18.0.0 <=20.x.x",
39:     "npm": ">=6.0.0"
40:   },
41:   "strapi": {
42:     "uuid": "da9f4f19-1c80-4a29-a422-833b1bb1cde5"
43:   }
44: }
```

## File: apps/cms/project.json
```json
 1: {
 2:   "name": "cms",
 3:   "$schema": "../../node_modules/nx/schemas/project-schema.json",
 4:   "projectType": "application",
 5:   "sourceRoot": "apps/cms",
 6:   "targets": {
 7:     "build": {
 8:       "executor": "nx:run-commands",
 9:       "options": {
10:         "command": "cd apps/cms && npm run build"
11:       }
12:     },
13:     "serve": {
14:       "executor": "nx:run-commands",
15:       "options": {
16:         "command": "cd apps/cms && npm run dev"
17:       }
18:     },
19:     "dev": {
20:       "executor": "nx:run-commands",
21:       "options": {
22:         "command": "cd apps/cms && npm run dev"
23:       }
24:     },
25:     "migrate": {
26:       "executor": "nx:run-commands",
27:       "options": {
28:         "command": "cd apps/cms && npx strapi database:migrate"
29:       }
30:     }
31:   }
32: }
```

## File: apps/cms/README.md
```markdown
 1: #  Getting started with Strapi
 2: 
 3: Strapi comes with a full featured [Command Line Interface](https://docs.strapi.io/dev-docs/cli) (CLI) which lets you scaffold and manage your project in seconds.
 4: 
 5: ### `develop`
 6: 
 7: Start your Strapi application with autoReload enabled. [Learn more](https://docs.strapi.io/dev-docs/cli#strapi-develop)
 8: 
 9: ```
10: npm run develop
11: # or
12: yarn develop
13: ```
14: 
15: ### `start`
16: 
17: Start your Strapi application with autoReload disabled. [Learn more](https://docs.strapi.io/dev-docs/cli#strapi-start)
18: 
19: ```
20: npm run start
21: # or
22: yarn start
23: ```
24: 
25: ### `build`
26: 
27: Build your admin panel. [Learn more](https://docs.strapi.io/dev-docs/cli#strapi-build)
28: 
29: ```
30: npm run build
31: # or
32: yarn build
33: ```
34: 
35: ##  Deployment
36: 
37: Strapi gives you many possible deployment options for your project including [Strapi Cloud](https://cloud.strapi.io). Browse the [deployment section of the documentation](https://docs.strapi.io/dev-docs/deployment) to find the best solution for your use case.
38: 
39: ```
40: yarn strapi deploy
41: ```
42: 
43: ##  Learn more
44: 
45: - [Resource center](https://strapi.io/resource-center) - Strapi resource center.
46: - [Strapi documentation](https://docs.strapi.io) - Official Strapi documentation.
47: - [Strapi tutorials](https://strapi.io/tutorials) - List of tutorials made by the core team and the community.
48: - [Strapi blog](https://strapi.io/blog) - Official Strapi blog containing articles made by the Strapi team and the community.
49: - [Changelog](https://strapi.io/changelog) - Find out about the Strapi product updates, new features and general improvements.
50: 
51: Feel free to check out the [Strapi GitHub repository](https://github.com/strapi/strapi). Your feedback and contributions are welcome!
52: 
53: ##  Community
54: 
55: - [Discord](https://discord.strapi.io) - Come chat with the Strapi community including the core team.
56: - [Forum](https://forum.strapi.io/) - Place to discuss, ask questions and find answers, show your Strapi project and get feedback or just talk with other Community members.
57: - [Awesome Strapi](https://github.com/strapi/awesome-strapi) - A curated list of awesome things related to Strapi.
58: 
59: ---
60: 
61: <sub> Psst! [Strapi is hiring](https://strapi.io/careers).</sub>
```

## File: apps/cms/tsconfig.json
```json
 1: {
 2:   "compilerOptions": {
 3:     "module": "CommonJS",
 4:     "moduleResolution": "Node",
 5:     "lib": ["ES2020"],
 6:     "target": "ES2019",
 7:     "strict": false,
 8:     "skipLibCheck": true,
 9:     "forceConsistentCasingInFileNames": true,
10:     "incremental": true,
11:     "esModuleInterop": true,
12:     "resolveJsonModule": true,
13:     "noEmitOnError": true,
14:     "noImplicitThis": true,
15:     "outDir": "dist",
16:     "rootDir": "."
17:   },
18:   "include": [
19:     // Include root files
20:     "./",
21:     // Include all ts files
22:     "./**/*.ts",
23:     // Include all js files
24:     "./**/*.js",
25:     // Force the JSON files in the src folder to be included
26:     "src/**/*.json"
27:   ],
28: 
29:   "exclude": [
30:     "node_modules/",
31:     "build/",
32:     "dist/",
33:     ".cache/",
34:     ".tmp/",
35: 
36:     // Do not include admin files in the server compilation
37:     "src/admin/",
38:     // Do not include test files
39:     "**/*.test.*",
40:     // Do not include plugins in the server compilation
41:     "src/plugins/**"
42:   ]
43: }
```

## File: layers/advert/.playground/app.config.ts
```typescript
1: export default defineAppConfig({
2:   myLayer: {
3:     name: 'My amazing Nuxt layer (overwritten)'
4:   }
5: })
```

## File: layers/advert/.playground/nuxt.config.ts
```typescript
1: export default defineNuxtConfig({
2:   extends: ['..'],
3:   modules: ['@nuxt/eslint']
4: })
```

## File: layers/advert/components/Advertisement.vue
```vue
  1: <script setup lang="ts">
  2: import { useStorage } from '@vueuse/core'
  3: import advertisements from '../assets/advertisements.json'
  4: 
  5: const showAds = ref(false)
  6: const userShowAds = useStorage('userShowAds', true)
  7: 
  8: interface Advertisement {
  9:   id: number
 10:   title: string
 11:   description: string
 12:   imageUrl: string
 13:   link: string
 14:   active: boolean
 15: }
 16: 
 17: interface AdMetric {
 18:   adId: number
 19:   impressions: number
 20:   clicks: number
 21:   uniqueViews: number // Changed to number
 22:   deviceType: string
 23:   viewTimes: number[]
 24: }
 25: 
 26: const activeAds = ref<Advertisement[]>([])
 27: const adMetrics = useStorage<Record<number, AdMetric>>('adMetrics', {})
 28: const viewedAds = useStorage<Set<number>>('viewedAds', new Set())
 29: const sendInterval = 10000 // 10 seconds
 30: 
 31: const loadActiveAds = () => {
 32:   activeAds.value = advertisements.filter((ad) => ad.active).slice(0, 3)
 33: }
 34: 
 35: const getDeviceType = () => {
 36:   const userAgent = navigator.userAgent
 37:   if (/mobile/i.test(userAgent)) return 'Mobile'
 38:   if (/tablet/i.test(userAgent)) return 'Tablet'
 39:   return 'Desktop'
 40: }
 41: 
 42: const trackImpression = (adId: number) => {
 43:   if (!adMetrics.value[adId]) {
 44:     adMetrics.value[adId] = {
 45:       adId,
 46:       impressions: 0,
 47:       clicks: 0,
 48:       uniqueViews: 0,
 49:       deviceType: getDeviceType(),
 50:       viewTimes: [],
 51:     }
 52:   }
 53:   adMetrics.value[adId].impressions++
 54:   adMetrics.value[adId].viewTimes.push(Date.now())
 55: 
 56:   // Increment uniqueViews only if it's the first time this ad is viewed
 57:   if (!viewedAds.value.has(adId)) {
 58:     adMetrics.value[adId].uniqueViews++
 59:     viewedAds.value.add(adId)
 60:   }
 61: }
 62: 
 63: const trackInteraction = (adId: number) => {
 64:   if (adMetrics.value[adId]) {
 65:     adMetrics.value[adId].clicks++
 66:   }
 67: }
 68: 
 69: const sendMetrics = async () => {
 70:   const metricsToSend = JSON.parse(JSON.stringify(adMetrics.value))
 71: 
 72:   try {
 73:     // Send metrics to admin server (not implemented)
 74:     await $fetch('/api/advertisement/metrics', {
 75:       method: 'POST',
 76:       body: { metrics: metricsToSend },
 77:     })
 78: 
 79:     console.log('Metrics sent successfully')
 80:     // Clear the local metrics after successful send
 81:     adMetrics.value = {}
 82:   } catch (error) {
 83:     console.error('Failed to send metrics:', error)
 84:   }
 85: }
 86: 
 87: const intervalId = ref(null as NodeJS.Timeout | null)
 88: onMounted(() => {
 89:   intervalId.value = setInterval(sendMetrics, sendInterval)
 90:   loadActiveAds()
 91:   activeAds.value.forEach((ad) => trackImpression(ad.id))
 92: })
 93: 
 94: watch(
 95:   activeAds,
 96:   (newAds) => {
 97:     newAds.forEach((ad) => trackImpression(ad.id))
 98:   },
 99:   { deep: true },
100: )
101: 
102: onUnmounted(() => {
103:   clearInterval(intervalId.value!)
104:   sendMetrics() // Send any remaining metrics before unmounting
105: })
106: </script>
107: 
108: <template>
109:   <aside class="mx-auto min-h-72 w-72 space-y-4 p-4">
110:     <div class="mb-4 flex items-center justify-between">
111:       <label
112:         for="show-ads-toggle"
113:         class="pr-2 text-sm"
114:       >
115:         Toggle Ads
116:       </label>
117:       <PrimeToggleSwitch
118:         v-model="showAds"
119:         input-id="show-ads-toggle"
120:       />
121:     </div>
122:     <div
123:       v-for="ad in activeAds"
124:       :key="ad.id"
125:       class="border-color overflow-hidden rounded-lg"
126:       :class="!showAds ? '' : 'border'"
127:     >
128:       <a
129:         :href="showAds ? ad.link : undefined"
130:         target="_blank"
131:         rel="noopener noreferrer"
132:         class="block h-full w-full"
133:         :class="{ invisible: !showAds }"
134:         @click="trackInteraction(ad.id)"
135:       >
136:         <div class="max-h-72 w-full">
137:           <NuxtImg
138:             v-if="showAds"
139:             :src="ad.imageUrl"
140:             :alt="ad.title"
141:             class="w-full object-cover"
142:           />
143:         </div>
144:         <div class="p-4">
145:           <h3
146:             v-if="showAds"
147:             class="text-lg font-semibold"
148:           >
149:             {{ ad.title }}
150:           </h3>
151:           <p
152:             v-if="showAds"
153:             class="text-sm"
154:           >
155:             {{ ad.description }}
156:           </p>
157:         </div>
158:       </a>
159:     </div>
160:   </aside>
161: </template>
```

## File: layers/advert/plugins/error-handler.ts
```typescript
 1: import { useErrorHandler } from '@ib/logger'
 2: 
 3: export default defineNuxtPlugin((nuxtApp) => {
 4:   const { handleError } = useErrorHandler()
 5: 
 6:   // Set up global error handlers
 7:   if (import.meta.client) {
 8:     window.addEventListener('error', (event) => {
 9:       handleError(event.error, 'Uncaught Exception')
10:     })
11: 
12:     window.addEventListener('unhandledrejection', (event) => {
13:       handleError(event.reason, 'Unhandled Promise Rejection')
14:     })
15:   }
16: })
```

## File: layers/advert/plugins/sentry.server.ts
```typescript
1: export default defineNuxtPlugin(() => {
2:   const environment = useRuntimeConfig().public.nodeEnv
3: })
```

## File: layers/advert/server/api/advertisement/metrics.get.ts
```typescript
 1: import { promises as fs } from 'fs'
 2: import { resolve } from 'path'
 3: import { defineEventHandler } from 'h3'
 4: 
 5: interface AdMetric {
 6:   adId: number
 7:   impressions: number
 8:   clicks: number
 9:   uniqueViews: number
10:   deviceType: string
11:   viewTimes: number[]
12: }
13: 
14: const adMetricsFilePath = resolve(process.cwd(), 'data', 'advertising', 'metrics.json')
15: 
16: export default defineEventHandler(async (event) => {
17:   try {
18:     const data = await fs.readFile(adMetricsFilePath, 'utf-8')
19:     const metrics: AdMetric[] = JSON.parse(data)
20: 
21:     // Calculate additional metrics
22:     const processedMetrics = Object.values(metrics).map((metric: AdMetric) => {
23:       const ctr = metric.impressions > 0 ? (metric.clicks / metric.impressions) * 100 : 0
24:       const frequency = metric.impressions / metric.uniqueViews
25:       const timeOfDay = metric.viewTimes.map((time) => new Date(time).getHours())
26: 
27:       return {
28:         ...metric,
29:         ctr: ctr.toFixed(2) + '%',
30:         frequency: frequency.toFixed(2),
31:         timeOfDay: timeOfDay.reduce(
32:           (acc, hour) => {
33:             acc[hour] = (acc[hour] || 0) + 1
34:             return acc
35:           },
36:           {} as Record<number, number>,
37:         ),
38:       }
39:     })
40: 
41:     return processedMetrics
42:   } catch (error) {
43:     console.error('Error reading ad metrics:', error)
44:     throw createError({
45:       statusCode: 500,
46:       statusMessage: 'Failed to read ad metrics',
47:     })
48:   }
49: })
```

## File: layers/advert/server/api/advertisement/metrics.post.ts
```typescript
 1: import { promises as fs } from 'fs'
 2: import { resolve } from 'path'
 3: import { defineEventHandler, readBody } from 'h3'
 4: 
 5: const adMetricsFilePath = resolve(process.cwd(), 'data', 'advertising', 'metrics.json')
 6: 
 7: interface AdMetric {
 8:   adId: number
 9:   impressions: number
10:   clicks: number
11:   uniqueViews: number
12:   deviceType: string
13:   viewTimes: number[]
14: }
15: 
16: let batchedMetrics: Record<number, AdMetric> = {}
17: let lastWriteTime = Date.now()
18: const WRITE_INTERVAL = 60000 // 1 minute
19: 
20: const writeMetricsToFile = async () => {
21:   try {
22:     let existingMetrics: Record<number, AdMetric> = {}
23:     try {
24:       const data = await fs.readFile(adMetricsFilePath, 'utf-8')
25:       existingMetrics = JSON.parse(data)
26:     } catch (error) {
27:       console.warn('No existing ad metrics found:', error)
28:       // File doesn't exist yet, start with empty object
29:     }
30: 
31:     // Merge batched metrics with existing metrics
32:     for (const [adId, metric] of Object.entries(batchedMetrics)) {
33:       if (!existingMetrics[adId]) {
34:         existingMetrics[adId] = metric
35:       } else {
36:         existingMetrics[adId].impressions += metric.impressions
37:         existingMetrics[adId].clicks += metric.clicks
38:         existingMetrics[adId].uniqueViews += metric.uniqueViews
39:         existingMetrics[adId].viewTimes.push(...metric.viewTimes)
40:       }
41:     }
42: 
43:     await fs.writeFile(adMetricsFilePath, JSON.stringify(existingMetrics, null, 2), 'utf-8')
44:     batchedMetrics = {} // Clear batched metrics after writing
45:     lastWriteTime = Date.now()
46:   } catch (error) {
47:     console.error('Error writing ad metrics:', error)
48:   }
49: }
50: 
51: export default defineEventHandler(async (event) => {
52:   const body = await readBody(event)
53:   const { metrics } = body as { metrics: Record<number, AdMetric> }
54: 
55:   if (!metrics) {
56:     return { success: false, message: 'No ad metrics received' }
57:   }
58: 
59:   console.log('Received ad metrics:', metrics)
60:   // Merge incoming metrics with batched metrics
61:   for (const [adId, metric] of Object.entries(metrics)) {
62:     if (!batchedMetrics[adId]) {
63:       batchedMetrics[adId] = metric
64:     } else {
65:       batchedMetrics[adId].impressions += metric.impressions
66:       batchedMetrics[adId].clicks += metric.clicks
67:       batchedMetrics[adId].uniqueViews += metric.uniqueViews
68:       batchedMetrics[adId].viewTimes.push(...metric.viewTimes)
69:     }
70:   }
71: 
72:   // Check if it's time to write to file
73:   if (Date.now() - lastWriteTime > WRITE_INTERVAL) {
74:     await writeMetricsToFile()
75:   }
76: 
77:   return { success: true, message: 'Ad metrics received and batched' }
78: })
```

## File: layers/advert/nuxt.config.ts
```typescript
1: import { defineNuxtConfig } from 'nuxt/config'
2: 
3: export default defineNuxtConfig({
4:   workspaceDir: '../../',
5:   srcDir: '.',
6: })
```

## File: layers/auth/.playground/app.config.ts
```typescript
1: export default defineAppConfig({
2:   myLayer: {
3:     name: 'My amazing Nuxt layer (overwritten)'
4:   }
5: })
```

## File: layers/auth/.playground/nuxt.config.ts
```typescript
1: export default defineNuxtConfig({
2:   extends: ['..'],
3:   modules: ['@nuxt/eslint']
4: })
```

## File: layers/auth/composables/user.current.store.ts
```typescript
  1: import { useLogger } from '@ib/logger'
  2: 
  3: const DOMAIN_KEY = 'currentUser'
  4: 
  5: export const useCurrentUser = defineStore(DOMAIN_KEY, () => {
  6:   const authUrl = useRuntimeConfig().public.aeAuthUrl
  7:   const logger = useLogger(DOMAIN_KEY)
  8:   const errors = useBaseError()
  9:   const loading = useLoadingStore()
 10:   const { fetch } = useBaseFetch()
 11:   const userId = useCookie('userId')
 12:   const user = useSupabaseUser()
 13: 
 14:   // check:critical - user should only be able to fetch their own full profile
 15:   // check:critical - user should only be able to update their own profile
 16:   // todo:high - allow user to update their profile info
 17:   // todo:med - merge currentUser and profile into one, store all required data everything in their session
 18:   // assign Posthog identify
 19: 
 20:   console.log('user', user.value)
 21: 
 22:   const profile = computed(() => ({
 23:     id: user.value?.id,
 24:     given_name: user.value?.user_metadata?.given_name,
 25:     email_confirmed_at: user.value?.email_confirmed_at,
 26:     confirmation_sent_at: user.value?.confirmation_sent_at,
 27:     confirmed_at: user.value?.confirmed_at,
 28:     created_at: user.value?.created_at,
 29:     surname: user.value?.user_metadata?.surname,
 30:     last_sign_in_at: user.value?.last_sign_in_at,
 31:     email: user.value?.email,
 32:     providers: user.value?.app_metadata.providers,
 33:     avatar: user.value?.user_metadata.avatar || user.value?.user_metadata.avatar_url,
 34:     provider: user.value?.provider,
 35:     user_role: user.value?.app_metadata?.role,
 36:     user_plan: user.value?.app_metadata?.plan,
 37:   }))
 38: 
 39:   // extract as util func
 40:   function hasValueChanged(newValue: any, currentValue: any): boolean {
 41:     console.log('hasValueChanged', newValue, currentValue)
 42:     if (
 43:       typeof newValue === 'string' ||
 44:       typeof newValue === 'boolean' ||
 45:       typeof newValue === 'number'
 46:     ) {
 47:       return newValue !== currentValue
 48:     } else if (Array.isArray(newValue)) {
 49:       return JSON.stringify(newValue) !== JSON.stringify(currentValue)
 50:     } else if (typeof newValue === 'object' && newValue !== null) {
 51:       return JSON.stringify(newValue) !== JSON.stringify(currentValue)
 52:     } else {
 53:       return newValue !== currentValue
 54:     }
 55:   }
 56: 
 57:   function cleanDataForUpdate(newData: any, previousData: any) {
 58:     const updatedData: any = {}
 59:     for (const key in newData) {
 60:       if (
 61:         Object.hasOwnProperty.call(newData, key) &&
 62:         hasValueChanged(newData[key], previousData[key])
 63:       ) {
 64:         updatedData[key] = newData[key]
 65:       }
 66:     }
 67: 
 68:     return { data: updatedData, noDataUpdated: Object.keys(updatedData).length === 0 }
 69:   }
 70: 
 71:   async function updateProfile(newData: any, isMock: boolean = false) {
 72:     logger.info('Starting updateProfile function', { newData, isMock })
 73:     const updatedData: any = {}
 74:     const toast = useNotification()
 75: 
 76:     logger.debug('Cleaning data for update')
 77:     // Compare newData with fullProfile and only include changed values
 78:     const { noDataUpdated, data } = cleanDataForUpdate(newData, profile.value)
 79: 
 80:     if (noDataUpdated) {
 81:       logger.info('No changes detected, no update necessary')
 82:       return
 83:     }
 84: 
 85:     logger.debug('Changes detected', { changedData: data })
 86: 
 87:     try {
 88:       logger.info('Sending update request to server')
 89:       let response
 90:       if (isMock) {
 91:         logger.info('Using mock API call')
 92:         // response = await mockApiCall(data)
 93:       } else {
 94:         response = await $fetch('/api/users/update', {
 95:           method: 'POST',
 96:           body: JSON.stringify(data),
 97:         })
 98:       }
 99:       logger.debug('Received response from server', { response })
100: 
101:       const validData = errors.server({
102:         response,
103:         devOnly: false,
104:         devMessage: 'Error updating user profile',
105:         userMessage: 'There was an error updating your profile after action',
106:       })
107: 
108:       if (response.error) {
109:         toast.error({ summary: 'Could not update profile', message: response.error.message })
110:         return
111:       } else {
112:         toast.success({
113:           summary: 'Profile updated successfully',
114:           message: 'Your profile was updated',
115:         })
116:       }
117: 
118:       logger.info('Successfully validated server response', { validData })
119: 
120:       // update state
121:       logger.debug('Updating user profile state')
122:       for (const key in data) {
123:         if (Object.hasOwnProperty.call(data, key)) {
124:           profile.value[key] = data[key]
125:           logger.debug(`Updating profile field: ${key}`, {
126:             newValue: data[key],
127:           })
128:         }
129:       }
130:       logger.info('Profile update completed successfully')
131:     } catch (error) {
132:       logger.error('Error occurred during profile update', { error })
133:       throw error // Re-throw the error for the caller to handle
134:     }
135:   }
136: 
137:   // Test function
138:   async function testUpdateProfile() {
139:     const testCases = [
140:       { name: 'John Doe', email: 'john@example.com' },
141:       { name: 'Jane Doe', email: 'error@example.com' }, // This will trigger an error
142:       {}, // This should result in no update
143:     ]
144: 
145:     for (const testCase of testCases) {
146:       try {
147:         console.log('Testing with data:', testCase)
148:         await updateProfile(testCase, true) // Use mock API
149:         console.log('Test passed successfully')
150:       } catch (error) {
151:         console.error('Test failed:', error.message)
152:       }
153:       console.log('---')
154:     }
155:   }
156: 
157:   type FileType = 'avatar'
158:   async function uploadImage(fileType: FileType, blob: Blob) {
159:     // currentFileName is the current file name in the database eg. avatar-drew-macgibbon.jpg
160:     const formData = new FormData()
161:     formData.append('file', blob)
162: 
163:     const response = await $fetch('/api/users/insert/image', {
164:       method: 'POST',
165:       body: formData,
166:       params: {
167:         fileType,
168:         userId: userId.value,
169:       },
170:     })
171: 
172:     console.log('fileName', response)
173: 
174:     const fileName = errors.server({
175:       response,
176:       devOnly: false,
177:       devMessage: `Error uploading ${fileType} image`,
178:       userMessage: `There was an error uploading your ${fileType}`,
179:     })
180: 
181:     let newData = {}
182: 
183:     console.log('fileName', fileName)
184: 
185:     if (fileType === 'avatar') {
186:       newData = {
187:         avatar: fileName,
188:       }
189:     }
190: 
191:     updateProfile(newData)
192:   }
193: 
194:   // first check if the user has an avatar in their profile
195:   // if not, check if the user has an avatar in their identities
196:   // cycle through identities check identities_data for picture
197: 
198:   return {
199:     haveUserSession: computed(() => !!profile.value),
200:     isAdmin: computed(
201:       () => profile.value?.user_role === 'admin' || profile.value?.user_role === 'super_admin',
202:     ),
203:     registeredWithProvider: computed(() => profile.value?.provider),
204:     profile,
205:     uploadImage,
206:     updateProfile,
207:     testUpdateProfile,
208:   }
209: })
210: 
211: if (import.meta.hot) {
212:   import.meta.hot.accept(acceptHMRUpdate(useCurrentUser, import.meta.hot))
213: }
```

## File: layers/auth/server/middleware/cors.ts
```typescript
 1: import { defineEventHandler, getRequestHeader, setResponseHeaders } from 'h3'
 2: 
 3: export default defineEventHandler((event) => {
 4:   const allowedDomains = ['astronera.org', 'up.railway.app', 'rlwy.net', 'localhost']
 5: 
 6:   const origin = getRequestHeader(event, 'origin') || ''
 7: 
 8:   const isAllowedOrigin = allowedDomains.some(
 9:     (domain) =>
10:       origin.startsWith('http://localhost:') || // Allow any localhost port
11:       origin.endsWith(`.${domain}`) || // Allow all subdomains
12:       origin === `https://${domain}`, // Allow apex domain
13:   )
14: 
15:   if (isAllowedOrigin || process.env.NODE_ENV !== 'production') {
16:     setResponseHeaders(event, {
17:       'Access-Control-Allow-Methods': 'GET,HEAD,PUT,PATCH,POST,DELETE',
18:       'Access-Control-Allow-Origin': origin,
19:       'Access-Control-Allow-Credentials': 'true',
20:       'Access-Control-Allow-Headers': 'Content-Type, Authorization, X-Requested-With',
21:       'Access-Control-Expose-Headers': 'Content-Length, X-JSON',
22:     })
23:   }
24: 
25:   console.log('CORS', origin, isAllowedOrigin)
26: 
27:   if (event.method === 'OPTIONS') {
28:     event.node.res.statusCode = 204
29:     event.node.res.statusMessage = 'No Content.'
30:     return 'OK'
31:   }
32: })
```

## File: layers/auth/nuxt.config.ts
```typescript
 1: import { fileURLToPath } from 'url'
 2: import { dirname, join, resolve } from 'path'
 3: import { defineNuxtConfig } from 'nuxt/config'
 4: import tsconfigPaths from 'vite-tsconfig-paths'
 5: 
 6: const currentDir = dirname(fileURLToPath(import.meta.url))
 7: 
 8: console.log('Node Env:', process.env.NODE_ENV)
 9: 
10: export default defineNuxtConfig({
11:   workspaceDir: '../../',
12:   srcDir: '.',
13: 
14:   modules: ['@nuxtjs/supabase'],
15: 
16:   supabase: {
17:     redirect: false,
18:     clientOptions: {
19:       auth: {
20:         flowType: 'pkce',
21:         detectSessionInUrl: true,
22:         persistSession: true,
23:         autoRefreshToken: true,
24:       },
25:     },
26:     cookieOptions: {
27:       domain:
28:         process.env.NODE_ENV === 'production'
29:           ? 'astronera.org' // This will work for all subdomains
30:           : 'localhost',
31:       maxAge: 60 * 60 * 8,
32:       path: '/',
33:       sameSite: 'lax',
34:       secure: process.env.NODE_ENV === 'production' ? true : false,
35:     },
36:     cookieName: 'sb',
37:   },
38: })
```

## File: layers/base/.playground/app.config.ts
```typescript
1: export default defineAppConfig({
2:   myLayer: {
3:     name: 'My amazing Nuxt layer (overwritten)',
4:   },
5: })
```

## File: layers/base/.playground/nuxt.config.ts
```typescript
1: export default defineNuxtConfig({
2:   extends: ['..'],
3:   modules: ['@nuxt/eslint'],
4: })
```

## File: layers/base/components/image/ImageHero.vue
```vue
 1: <script setup lang="ts">
 2: import type { TitleType, ImageType } from '../../types/content'
 3: 
 4: defineProps({
 5:   fit: {
 6:     type: String,
 7:     default: 'cover',
 8:   },
 9:   objectPosition: {
10:     type: String,
11:     default: 'center',
12:   },
13:   title: {
14:     type: Object as () => TitleType,
15:     required: true,
16:   },
17:   img: {
18:     type: Object as () => ImageType,
19:     required: true,
20:   },
21: })
22: 
23: // consider turning the images into short videos using AI
24: // consider using mix-blend-mode for cool text effect with video
25: </script>
26: 
27: <template>
28:   <div class="relative flex items-center justify-center">
29:     <IBImage
30:       :img="{
31:         src: img.src,
32:         alt: img.alt,
33:         width: img.width,
34:         height: img.height,
35:       }"
36:       :class="`w-full object-${fit} ${objectPosition} h-screen`"
37:     />
38:     <div
39:       class="absolute z-10 flex flex-col items-center justify-center gap-8 px-4 text-white lg:flex-row lg:gap-16 xl:px-8"
40:     >
41:       <slot />
42:       <div class="flex flex-col gap-4">
43:         <h2
44:           :class="`rounded-md bg-black/30 px-4 py-1 text-3xl font-bold shadow-xl lg:text-5xl xl:px-8 text-${title.centered ? 'center' : 'left'}`"
45:         >
46:           {{ title.main }}
47:         </h2>
48:         <p
49:           v-if="title.subtitle"
50:           :class="`inline-block w-auto max-w-2xl rounded-sm px-4 pb-4 text-xl font-semibold lg:text-3xl xl:px-8 text-${title.centered ? 'center' : 'left'}`"
51:         >
52:           {{ title.subtitle }}
53:         </p>
54:       </div>
55:     </div>
56:     <div class="absolute left-0 top-0 h-full w-full bg-black/50" />
57:   </div>
58: </template>
59: 
60: <style scoped></style>
```

## File: layers/base/components/image/ImageWithFallback.vue
```vue
 1: <script setup lang="ts">
 2: interface Image {
 3:   src: string
 4:   alt: string | null
 5:   caption: string | null
 6:   credit: string | null
 7: }
 8: 
 9: interface Options {
10:   width: number
11:   height: number
12:   sizes: string | undefined | null
13:   quality: number | undefined | null
14: }
15: 
16: defineProps({
17:   image: {
18:     type: Object as () => Image | undefined,
19:     default: undefined,
20:   },
21:   options: {
22:     type: Object as () => Options | undefined,
23:     default: () => ({
24:       width: 50,
25:       height: 50,
26:       sizes: null,
27:       quality: 80,
28:     }),
29:   },
30: })
31: </script>
32: 
33: <template>
34:   <div class="relative h-full w-full overflow-hidden rounded-md object-cover">
35:     <IBImage
36:       :img="{
37:         src: image?.src || 'hero-image.jpg',
38:         alt: image?.alt || 'this is a default fallback for when an image is not present',
39:         width: options?.width || 60,
40:         height: options?.height || 37,
41:         quality: options?.quality || 80,
42:       }"
43:       class="h-full w-full object-cover"
44:     />
45:     <div
46:       v-if="!image?.src"
47:       class="absolute left-0 top-0 z-50 flex h-full w-full items-center justify-center bg-black/40"
48:     >
49:       <h3 class="foreground rounded-lg px-3 py-1 text-base"> NO IMAGE </h3>
50:     </div>
51:   </div>
52: </template>
```

## File: layers/base/components/Background.vue
```vue
 1: <template>
 2:   <canvas
 3:     ref="canvas"
 4:     class="w-full h-full"
 5:   />
 6: </template>
 7: 
 8: <script setup lang="ts">
 9: const CANVAS_WIDTH = computed(() => (window ? window.innerWidth : 0))
10: const CANVAS_HEIGHT = computed(() => (window ? window.innerHeight + 800 : 0))
11: const STAR_COUNT = 300 // Number of stars
12: const COLORS = ['#ffffff', '#ffcccb', '#add8e6'] // White, red, blue
13: 
14: // Refs
15: const canvas = ref<HTMLCanvasElement | null>(null)
16: let ctx: CanvasRenderingContext2D | null = null
17: let animationFrameId: number
18: 
19: // Utility function to get random number within a range
20: function getRandom(min: number, max: number): number {
21:   return Math.random() * (max - min) + min
22: }
23: 
24: // Create stars array
25: const stars = Array.from({ length: STAR_COUNT }, () => ({
26:   x: getRandom(0, CANVAS_WIDTH.value),
27:   y: getRandom(0, CANVAS_HEIGHT.value),
28:   radius: getRandom(0.5, 2),
29:   color: COLORS[Math.floor(Math.random() * COLORS.length)],
30:   speed: 0.01, // Speed of movement
31:   initialX: 0,
32:   initialY: 0,
33: }))
34: 
35: // Initialize star positions
36: stars.forEach((star) => {
37:   star.initialX = star.x
38:   star.initialY = star.y
39: })
40: 
41: // Draw stars on canvas
42: function drawStars() {
43:   if (!ctx) {
44:     return
45:   }
46: 
47:   ctx.clearRect(0, 0, CANVAS_WIDTH.value, CANVAS_HEIGHT.value)
48: 
49:   stars.forEach((star) => {
50:     ctx.beginPath()
51:     ctx.arc(star.x, star.y, star.radius, 0, 2 * Math.PI, false)
52:     ctx.fillStyle = star.color
53:     ctx.shadowColor = star.color
54:     ctx.shadowBlur = 8
55:     ctx.fill()
56:     ctx.closePath()
57: 
58:     // Update star position to follow an inverted arc path
59:     star.x -= star.speed
60:     star.y =
61:       star.initialY - Math.sin((star.x / CANVAS_WIDTH.value) * Math.PI) * (CANVAS_HEIGHT.value / 4)
62: 
63:     // Wrap stars around edges
64:     if (star.x < 0) {
65:       star.x = CANVAS_WIDTH.value
66:       star.initialY = getRandom(0, CANVAS_HEIGHT.value)
67:     }
68:   })
69: 
70:   // Request next animation frame
71:   animationFrameId = requestAnimationFrame(drawStars)
72: }
73: 
74: // Set up canvas and start animation
75: onMounted(() => {
76:   if (canvas.value) {
77:     canvas.value.width = CANVAS_WIDTH.value
78:     canvas.value.height = CANVAS_HEIGHT.value
79:     ctx = canvas.value.getContext('2d')
80:     if (ctx) {
81:       ctx.fillStyle = 'black'
82:       ctx.fillRect(0, 0, CANVAS_WIDTH.value, CANVAS_HEIGHT.value)
83:       drawStars()
84:     }
85:   }
86: })
87: 
88: // Clean up animation on component unmount
89: onBeforeUnmount(() => {
90:   cancelAnimationFrame(animationFrameId)
91: })
92: </script>
93: 
94: <style scoped>
95: canvas {
96:   width: 100vw;
97:   height: 120vh;
98: }
99: </style>
```

## File: layers/base/components/Breadcrumbs.vue
```vue
 1: <script lang="ts" setup>
 2: const route = useRoute()
 3: 
 4: const generateBreadcrumbs = (path: string) => {
 5:   const pathParts = path.split('/').filter(Boolean)
 6:   let currentPath = ''
 7:   return pathParts.map((part) => {
 8:     currentPath += `/${part}`
 9:     return {
10:       to: currentPath,
11:       label: part.charAt(0).toUpperCase() + part.slice(1),
12:       ariaLabel: part.charAt(0).toUpperCase() + part.slice(1),
13:     }
14:   })
15: }
16: 
17: const links = computed(() => generateBreadcrumbs(route.path))
18: 
19: // Prepare links by filtering and adjusting labels
20: const formattedLinks = computed(() => {
21:   if (!links.value) return []
22:   console.log('Formatting links', links.value)
23:   return links.value
24:     .map((link) => {
25:       if (!link) return null // Skip if link is undefined or null
26: 
27:       // Filter out the home link if in app route
28:       if (link.to === '/') {
29:         console.log('Filtering out home link', link)
30:         return null
31:       }
32: 
33:       // Special handling for the 'astrotribe' path
34:       if (link.to === '/') {
35:         return { ...link, label: 'Home', ariaLabel: 'Home' }
36:       }
37: 
38:       if (link.to === '/ask') {
39:         return { ...link, label: 'Q&A', ariaLabel: 'Q&A' }
40:       }
41: 
42:       return link // Return unmodified link
43:     })
44:     .filter(Boolean) // Remove null entries
45: })
46: </script>
47: 
48: <template>
49:   <PrimeBreadcrumb
50:     v-if="formattedLinks.length"
51:     :model="formattedLinks"
52:     :pt="{
53:       root: 'foreground p-0 flex items-center justify-start',
54:       menu: '!mb-0',
55:     }"
56:   >
57:     <template #item="{ item }">
58:       <NuxtLink :to="item.to">
59:         <span
60:           class="text-primary font-semibold"
61:           :class="item.current ? 'link-active' : ''"
62:         >
63:           {{ item.label }}
64:         </span>
65:       </NuxtLink>
66:     </template>
67:   </PrimeBreadcrumb>
68: </template>
69: 
70: <style></style>
```

## File: layers/base/components/Glass.vue
```vue
  1: <script setup lang="ts">
  2: const uniqueId = useId()
  3: 
  4: const tailwindColors = [
  5:   'slate',
  6:   'gray',
  7:   'zinc',
  8:   'neutral',
  9:   'stone',
 10:   'red',
 11:   'orange',
 12:   'amber',
 13:   'yellow',
 14:   'lime',
 15:   'green',
 16:   'emerald',
 17:   'teal',
 18:   'cyan',
 19:   'sky',
 20:   'blue',
 21:   'indigo',
 22:   'violet',
 23:   'purple',
 24:   'fuchsia',
 25:   'pink',
 26:   'rose',
 27:   'primary', // Assuming you have a custom 'primary' color
 28: ] as const
 29: 
 30: type TailwindColor = (typeof tailwindColors)[number]
 31: 
 32: const props = defineProps({
 33:   color: { type: String as PropType<TailwindColor>, default: 'slate' },
 34:   bgOpacity: { type: Number, default: 20 },
 35:   gradientOpacity: { type: Number, default: 10 },
 36:   blurIntensity: { type: String, default: 'md' },
 37:   disableHover: { type: Boolean, default: false },
 38:   padding: { type: String, default: '6' },
 39:   loading: { type: Boolean, default: false },
 40:   ariaLabel: { type: String, default: 'Glass card' },
 41: })
 42: 
 43: const cardRef = ref<HTMLElement | null>(null)
 44: const gravityAreaRef = ref<HTMLElement | null>(null)
 45: 
 46: const {
 47:   handleMouseMove,
 48:   handleMouseLeave,
 49:   cardStyle,
 50:   spotlightStyle,
 51:   bgClasses,
 52:   borderClasses,
 53:   textClasses,
 54:   gradientClasses,
 55:   hoverClasses,
 56: } = useGlassCard(props, uniqueId)
 57: </script>
 58: 
 59: <template>
 60:   <div
 61:     :id="uniqueId"
 62:     class="relative"
 63:   >
 64:     <div
 65:       ref="gravityAreaRef"
 66:       class="pointer-events-none absolute -inset-[30%] z-0"
 67:     ></div>
 68:     <div
 69:       ref="cardRef"
 70:       :class="[
 71:         'glass-card relative overflow-hidden rounded-md shadow-xl',
 72:         'ring-2 ring-inset ring-white/10',
 73:         `backdrop-blur-${blurIntensity}`,
 74:         `p-${padding}`,
 75:         bgClasses,
 76:         borderClasses,
 77:         textClasses,
 78:         ...hoverClasses,
 79:       ]"
 80:       :style="cardStyle"
 81:       role="region"
 82:       :aria-label="ariaLabel"
 83:       @mousemove="(e) => handleMouseMove(e)"
 84:       @mouseleave="handleMouseLeave"
 85:     >
 86:       <div class="glass-card-content relative z-20">
 87:         <slot name="header"></slot>
 88:         <slot></slot>
 89:       </div>
 90:       <div
 91:         :class="['absolute inset-0 z-10 h-full w-full bg-gradient-to-br', gradientClasses]"
 92:       ></div>
 93:       <div
 94:         class="glass-effect"
 95:         :style="spotlightStyle"
 96:       ></div>
 97:       <div
 98:         v-if="loading"
 99:         class="animate-shimmer absolute inset-0 bg-gradient-to-r from-transparent via-white/10 to-transparent"
100:       ></div>
101:     </div>
102:   </div>
103: </template>
104: 
105: <style scoped>
106: .glass-card {
107:   transition: all 0.3s ease;
108: }
109: 
110: .glass-effect {
111:   position: absolute;
112:   inset: 0;
113:   pointer-events: none;
114:   transition: opacity 0.2s;
115: }
116: 
117: .glass-card-content {
118:   transition: transform 0.3s ease;
119: }
120: 
121: .glass-card:hover .glass-card-content {
122:   transform: translateY(-5px);
123: }
124: 
125: @keyframes shimmer {
126:   0% {
127:     transform: translateX(-100%);
128:   }
129:   100% {
130:     transform: translateX(100%);
131:   }
132: }
133: 
134: .animate-shimmer {
135:   animation: shimmer 1.5s infinite;
136: }
137: 
138: .spotlight {
139:   backdrop-filter: blur(2px) contrast(1.2);
140:   mix-blend-mode: overlay;
141: }
142: </style>
```

## File: layers/base/components/GlobalTimer.vue
```vue
  1: <script setup lang="ts">
  2: const isVisible = ref(true)
  3: const isTracking = ref(false)
  4: const elapsedTime = ref(0)
  5: const currentTask = ref('')
  6: let timer: NodeJS.Timeout | null = null
  7: let startTime: number
  8: let pausedTime = 0
  9: 
 10: function startTimer() {
 11:   if (!import.meta.client) return
 12: 
 13:   if (!isTracking.value) {
 14:     isTracking.value = true
 15:     startTime = Date.now() - pausedTime
 16:     timer = setInterval(() => {
 17:       elapsedTime.value = Math.floor((Date.now() - startTime) / 1000)
 18:     }, 1000)
 19:   }
 20: }
 21: 
 22: function pauseTimer() {
 23:   if (isTracking.value) {
 24:     isTracking.value = false
 25:     if (timer) {
 26:       clearInterval(timer)
 27:       timer = null
 28:     }
 29:     pausedTime = Date.now() - startTime
 30:   }
 31: }
 32: 
 33: function stopTimer() {
 34:   isTracking.value = false
 35:   isVisible.value = false
 36:   if (timer) {
 37:     clearInterval(timer)
 38:     timer = null
 39:   }
 40:   elapsedTime.value = 0
 41:   pausedTime = 0
 42:   currentTask.value = ''
 43: }
 44: 
 45: function showTimer(taskTitle: string) {
 46:   currentTask.value = taskTitle
 47:   isVisible.value = true
 48:   startTimer()
 49: }
 50: 
 51: function formatTime(seconds: number) {
 52:   const hours = Math.floor(seconds / 3600)
 53:   const minutes = Math.floor((seconds % 3600) / 60)
 54:   const secs = seconds % 60
 55:   return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`
 56: }
 57: 
 58: onUnmounted(() => {
 59:   if (timer) clearInterval(timer)
 60: })
 61: 
 62: defineExpose({
 63:   showTimer,
 64:   stopTimer,
 65: })
 66: </script>
 67: 
 68: <template>
 69:   <div
 70:     v-if="isVisible"
 71:     class="flex items-center gap-2 rounded-lg bg-gray-800 p-2 text-white shadow-lg"
 72:   >
 73:     <div class="text-sm font-bold">
 74:       {{ currentTask }}
 75:     </div>
 76:     <div class="text-xl">  {{ formatTime(elapsedTime) }} </div>
 77:     <div class="flex space-x-2">
 78:       <PrimeButton
 79:         v-if="!isTracking"
 80:         size="small"
 81:         class="rounded-full bg-green-500 p-2 hover:bg-green-600"
 82:         @click="startTimer"
 83:       >
 84:         <Icon
 85:           name="mdi:play"
 86:           size="24px"
 87:         />
 88:       </PrimeButton>
 89:       <PrimeButton
 90:         v-else
 91:         size="small"
 92:         class="rounded-full bg-yellow-500 p-2 hover:bg-yellow-600"
 93:         @click="pauseTimer"
 94:       >
 95:         <Icon
 96:           name="mdi:pause"
 97:           size="24px"
 98:         />
 99:       </PrimeButton>
100:       <PrimeButton
101:         size="small"
102:         class="rounded-full bg-red-500 p-2 hover:bg-red-600"
103:         @click="stopTimer"
104:       >
105:         <Icon
106:           name="mdi:stop"
107:           size="24px"
108:         />
109:       </PrimeButton>
110:     </div>
111:   </div>
112: </template>
```

## File: layers/base/components/Grid.vue
```vue
1: <script setup lang="ts"></script>
2: 
3: <template>
4:   <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 2xl:grid-cols-4 md:gap-4 xl:gap-8">
5:     <slot />
6:   </div>
7: </template>
8: 
9: <style scoped></style>
```

## File: layers/base/components/HelloWorld.vue
```vue
 1: <script setup lang="ts">
 2: const { myLayer } = useAppConfig()
 3: </script>
 4: 
 5: <template>
 6:   <div>
 7:     <h1>Hello World!</h1>
 8:     <pre>{{ myLayer }}</pre>
 9:   </div>
10: </template>
```

## File: layers/base/components/HoverCard.vue
```vue
 1: <script setup lang="ts">
 2: const enableHoverEffect = ref(false)
 3: const hoverPosition = ref(null as null | 'up' | 'down') // 'up', 'center', or 'down'
 4: 
 5: function checkHoverPosition(event) {
 6:   if (!enableHoverEffect.value) {
 7:     return // Do nothing if hover effects are disabled
 8:   }
 9:   const rect = event.target.getBoundingClientRect()
10:   const halfScreen = window.innerHeight / 2
11:   if (rect.top < halfScreen) {
12:     console.log('top')
13:     // If the card is in the top third, expand downwards
14:     hoverPosition.value = 'down'
15:   } else {
16:     console.log('bottom')
17:     // If the card is in the bottom third, expand upwards
18:     hoverPosition.value = 'up'
19:   }
20: }
21: 
22: const checkScreenSize = () => {
23:   enableHoverEffect.value = window.innerWidth >= 1024 // Tailwind's 'lg' breakpoint
24: }
25: 
26: const paddingSize = computed(() => (window.innerWidth >= 1280 ? 32 : 16))
27: 
28: onMounted(() => {
29:   window.addEventListener('resize', checkScreenSize)
30:   checkScreenSize()
31:   return () => window.removeEventListener('resize', checkScreenSize)
32: })
33: 
34: // ui:med:easy:1 - if there is only one card in the grid row, we need to set min h of 100% to prevent the card from collapsing
35: </script>
36: 
37: <template>
38:   <div
39:     class="group relative hover:z-50"
40:     @mouseenter="checkHoverPosition"
41:     @mouseleave="hoverPosition = null"
42:   >
43:     <div
44:       :class="[
45:         'transition-all duration-300 delay-200 p-4 border-b-2 md:border border-color overflow-hidden background',
46:         'flex flex-col gap-4 w-full h-full md:rounded-md md:shadow-md',
47:         {
48:           'lg:group-hover:absolute': enableHoverEffect && !!hoverPosition,
49:           'top-0': enableHoverEffect && hoverPosition === 'down',
50:           'bottom-0': enableHoverEffect && hoverPosition === 'up',
51:         },
52:       ]"
53:       :style="{
54:         height: enableHoverEffect && !!hoverPosition ? `calc(200% + ${paddingSize}px)` : '100%',
55:       }"
56:     >
57:       <slot></slot>
58:     </div>
59:   </div>
60: </template>
61: 
62: <style scoped>
63: /* Extra styles if needed */
64: </style>
```

## File: layers/base/components/Image.vue
```vue
 1: <script lang="ts" setup>
 2: const uuid = useId()
 3: 
 4: const props = defineProps({
 5:   img: {
 6:     type: Object,
 7:     required: true,
 8:   },
 9:   noShrink: {
10:     type: Boolean,
11:     default: false,
12:   },
13: })
14: 
15: const imageUrl = ref(null)
16: 
17: watch(
18:   () => props.img.src,
19:   (newVal) => {
20:     imageUrl.value = newVal
21:   },
22:   { immediate: true },
23: )
24: 
25: function loadFallbackImage(error: Error) {
26:   console.error('Image loading error:', error)
27:   imageUrl.value = `images/defaults/${props.img.type ?? 'fallback'}.jpg`
28: }
29: </script>
30: 
31: <template>
32:   <NuxtImg
33:     v-if="imageUrl"
34:     :key="`image-${uuid}`"
35:     v-bind="$attrs"
36:     :src="imageUrl"
37:     :alt="img.alt"
38:     :width="img.width"
39:     :height="img.height"
40:     :format="img.format"
41:     :quality="img.quality"
42:     :loading="img.loading"
43:     crossorigin="anonymous"
44:     :class="{ 'flex shrink-0': !noShrink }"
45:     @error="loadFallbackImage"
46:   />
47: </template>
```

## File: layers/base/components/InfiniteScroll.vue
```vue
 1: <script setup lang="ts">
 2: const emit = defineEmits(['update:scrollEnd'])
 3: const scrollContainer = ref<HTMLElement | null>(null)
 4: const observer = ref<IntersectionObserver | null>(null)
 5: 
 6: onMounted(() => {
 7:   if ('IntersectionObserver' in window) {
 8:     observer.value = new IntersectionObserver(
 9:       (entries) => {
10:         if (entries[0].isIntersecting) {
11:           emit('update:scrollEnd')
12:         }
13:       },
14:       {
15:         root: null,
16:         rootMargin: '200px', // Load more content when within 200px of the bottom
17:         threshold: 0.1, // Trigger when at least 10% of the target is visible
18:       },
19:     )
20: 
21:     if (scrollContainer.value) {
22:       observer.value.observe(scrollContainer.value)
23:     }
24:   } else {
25:     // Fallback for browsers that don't support IntersectionObserver
26:     window.addEventListener('scroll', handleScroll)
27:   }
28: })
29: 
30: onUnmounted(() => {
31:   if (observer.value && scrollContainer.value) {
32:     observer.value.unobserve(scrollContainer.value)
33:   }
34:   window.removeEventListener('scroll', handleScroll)
35: })
36: 
37: const handleScroll = () => {
38:   if (scrollContainer.value) {
39:     const rect = scrollContainer.value.getBoundingClientRect()
40:     if (rect.top <= window.innerHeight) {
41:       emit('update:scrollEnd')
42:     }
43:   }
44: }
45: </script>
46: 
47: <template>
48:   <div>
49:     <slot />
50:     <div
51:       ref="scrollContainer"
52:       class="h-10 bg-transparent"
53:       aria-hidden="true"
54:     />
55:   </div>
56: </template>
```

## File: layers/base/components/Loader.vue
```vue
 1: <script setup lang="ts">
 2: const loaderWidth = ref('100%')
 3: const loaderHeight = ref('100%')
 4: 
 5: defineProps({
 6:   width: {
 7:     type: String,
 8:     default: '100%',
 9:   },
10:   height: {
11:     type: String,
12:     default: '100%',
13:   },
14: })
15: </script>
16: 
17: <template>
18:   <div
19:     class="skeleton-loader"
20:     :style="{ width: loaderWidth, height: loaderHeight }"
21:   ></div>
22: </template>
23: 
24: <style scoped>
25: .skeleton-loader {
26:   background-color: #f3f3f3;
27:   animation: skeleton-loading 1s infinite linear;
28: }
29: 
30: @keyframes skeleton-loading {
31:   0% {
32:     background-position: -200px 0;
33:   }
34:   100% {
35:     background-position: 200px 0;
36:   }
37: }
38: </style>
```

## File: layers/base/components/Modal.vue
```vue
 1: <script setup lang="ts">
 2: const isOpen = ref(false)
 3: 
 4: const toggleModalOpen = () => {
 5:   isOpen.value = !isOpen.value
 6: }
 7: 
 8: const options = ref({
 9:   isOpen,
10:   toggleModalOpen,
11: })
12: </script>
13: 
14: <template>
15:   <div>
16:     <slot
17:       name="button"
18:       v-bind="options"
19:     />
20:     <PrimeDialog
21:       v-model:visible="isOpen"
22:       modal
23:       :pt="{
24:         root: 'max-w-2xl w-full',
25:         content: 'w-full aspect-square',
26:       }"
27:       :pt-options="{ mergeProps: true, mergeSections: true }"
28:     >
29:       <template #header>
30:         <slot name="modal:header" />
31:       </template>
32:       <slot name="modal:default" />
33:       <template #footer>
34:         <slot
35:           name="modal:footer"
36:           v-bind="options"
37:         />
38:       </template>
39:     </PrimeDialog>
40:   </div>
41: </template>
42: 
43: <style scoped></style>
```

## File: layers/base/components/NavHamburger.vue
```vue
 1: <!-- components/nav/NavHamburger.vue -->
 2: <template>
 3:   <button
 4:     class="md:hidden p-2 hover:bg-gray-800 rounded-lg transition-colors flex"
 5:     @click="toggleMobileNav"
 6:   >
 7:     <Icon
 8:       :name="isMobileSidebarOpen ? 'mdi:close' : 'mdi:menu'"
 9:       size="24px"
10:     />
11:   </button>
12: </template>
13: 
14: <script setup lang="ts">
15: const { isMobileSidebarOpen } = useNavigation()
16: 
17: const toggleMobileNav = () => {
18:   isMobileSidebarOpen.value = !isMobileSidebarOpen.value
19: }
20: </script>
```

## File: layers/base/components/NewLabel.vue
```vue
 1: <script setup lang="ts">
 2: const props = defineProps({
 3:   date: {
 4:     type: String,
 5:     required: true,
 6:   },
 7:   maxAge: {
 8:     type: Number,
 9:     required: true,
10:   },
11: })
12: 
13: const isWithinNumberOfDays = computed(() => {
14:   const currentDate = new Date()
15:   const itemDate = new Date(props.date)
16:   const differenceInDays = Math.floor(
17:     (currentDate.getTime() - itemDate.getTime()) / (1000 * 3600 * 24),
18:   )
19:   return differenceInDays <= props.maxAge
20: })
21: </script>
22: 
23: <template>
24:   <PrimeTag
25:     v-if="isWithinNumberOfDays"
26:     severity="success"
27:     value="NEW"
28:   />
29: </template>
```

## File: layers/base/components/Pagination.vue
```vue
 1: <script setup>
 2: import { onMounted, ref } from 'vue'
 3: import { useRoute } from 'vue-router'
 4: 
 5: // todo:high:1 - implement and test on component
 6: 
 7: const route = useRoute()
 8: const slug = route.params.slug // Dynamic slug based on the current route
 9: const items = ref([])
10: const currentPage = ref(1)
11: 
12: // Store and restore pagination state using session storage
13: const sessionStorageKey = `pagination-${slug}`
14: 
15: function restoreState() {
16:   const savedState = sessionStorage.getItem(sessionStorageKey)
17:   if (savedState) {
18:     const state = JSON.parse(savedState)
19:     currentPage.value = state.currentPage
20:     items.value = state.items
21:   }
22: }
23: 
24: function storeState() {
25:   const state = {
26:     currentPage: currentPage.value,
27:     items: items.value,
28:   }
29:   sessionStorage.setItem(sessionStorageKey, JSON.stringify(state))
30: }
31: 
32: async function fetchItems() {
33:   // Placeholder function to simulate fetching items
34:   const newItems = [{ id: Date.now(), content: `Item ${currentPage.value}` }]
35:   items.value.push(...newItems)
36:   currentPage.value += 1
37:   storeState()
38: }
39: 
40: function loadMore() {
41:   fetchItems()
42: }
43: 
44: onMounted(() => {
45:   restoreState()
46:   if (items.value.length === 0) {
47:     fetchItems()
48:   }
49: })
50: </script>
51: 
52: <template>
53:   <div>
54:     <ul v-if="items.length">
55:       <li
56:         v-for="item in items"
57:         :key="item.id"
58:       >
59:         {{ item.content }}
60:       </li>
61:     </ul>
62:     <button @click="loadMore"> Load More </button>
63:   </div>
64: </template>
```

## File: layers/base/components/Popover.vue
```vue
 1: <script setup lang="ts">
 2: const props = defineProps({
 3:   buttonLabel: { type: String, required: true },
 4: })
 5: 
 6: const popover = ref(null)
 7: 
 8: const toggle = (event) => {
 9:   popover.value?.toggle(event)
10: }
11: </script>
12: 
13: <template>
14:   <div>
15:     <PrimeButton
16:       type="button"
17:       size="small"
18:       severity="secondary"
19:       :label="buttonLabel"
20:       @click="toggle"
21:     />
22:     <PrimePopover ref="popover">
23:       <slot></slot>
24:     </PrimePopover>
25:   </div>
26: </template>
27: 
28: <style scoped></style>
```

## File: layers/base/components/Resizable.vue
```vue
 1: <script lang="ts" setup>
 2: const props = defineProps<{
 3:   slots: Record<string, string>
 4: }>()
 5: 
 6: const container = ref<HTMLElement | null>(null)
 7: const resizer = ref<HTMLElement | null>(null)
 8: const sizes = ref<number[]>([1, 1])
 9: 
10: const startResize = (e: MouseEvent) => {
11:   e.preventDefault()
12:   window.addEventListener('mousemove', resize)
13:   window.addEventListener('mouseup', stopResize)
14: }
15: 
16: const resize = (e: MouseEvent) => {
17:   if (!container.value) return
18:   const containerRect = container.value.getBoundingClientRect()
19:   const newLeftWidth = e.clientX - containerRect.left
20:   const containerWidth = containerRect.width
21: 
22:   sizes.value = [newLeftWidth / containerWidth, 1 - newLeftWidth / containerWidth]
23: }
24: 
25: const stopResize = () => {
26:   window.removeEventListener('mousemove', resize)
27:   window.removeEventListener('mouseup', stopResize)
28: }
29: 
30: onMounted(() => {
31:   if (resizer.value) {
32:     resizer.value.addEventListener('mousedown', startResize)
33:   }
34: })
35: 
36: onUnmounted(() => {
37:   if (resizer.value) {
38:     resizer.value.removeEventListener('mousedown', startResize)
39:   }
40:   window.removeEventListener('mousemove', resize)
41:   window.removeEventListener('mouseup', stopResize)
42: })
43: </script>
44: 
45: <template>
46:   <div
47:     ref="container"
48:     class="relative flex h-full w-full"
49:   >
50:     <div
51:       v-for="(componentId, index) in Object.values(slots)"
52:       :key="componentId"
53:       :class="['overflow-auto', index === 0 ? 'pr-4' : 'pl-4']"
54:       :style="{ flex: sizes[index] }"
55:     >
56:       <slot :name="componentId"></slot>
57:     </div>
58:     <div
59:       ref="resizer"
60:       class="w-2 cursor-col-resize bg-gray-200 hover:bg-gray-300"
61:       @mousedown="startResize"
62:     ></div>
63:   </div>
64: </template>
65: 
66: <style scoped>
67: /* Add any additional styles here */
68: </style>
```

## File: layers/base/components/Sidebar.vue
```vue
 1: <script setup lang="ts">
 2: const isSideVisible = ref(true)
 3: </script>
 4: 
 5: <template>
 6:   <div class="top-0 space-y-4 p-8 md:sticky">
 7:     <div class="flex flex-col justify-center md:justify-start">
 8:       <div class="flex gap-4">
 9:         <!-- <PrimeToggleButton
10:           v-model="isSideVisible"
11:           on-label="Hide"
12:           off-label="Show"
13:         >
14:           <Icon :name="isSideVisible ? 'mdi:eye' : 'mdi:sun'" />
15:         </PrimeToggleButton> -->
16:         <!-- <Transition name="slide-fade">
17:           <PrimeMessage
18:             v-show="isSideVisible"
19:             severity="info"
20:             :pt="{ root: '', text: 'text-sm text-left' }"
21:           >
22:             Filters Coming Soon
23:           </PrimeMessage>
24:         </Transition> -->
25:       </div>
26:     </div>
27:   </div>
28: </template>
29: 
30: <style scoped>
31: /*
32:   Enter and leave animations can use different
33:   durations and timing functions.
34: */
35: .slide-fade-enter-active {
36:   transition: all 0.3s ease-out;
37: }
38: 
39: .slide-fade-leave-active {
40:   transition: all 0.8s cubic-bezier(1, 0.5, 0.8, 1);
41: }
42: 
43: .slide-fade-enter-from,
44: .slide-fade-leave-to {
45:   transform: translateX(-20px);
46:   opacity: 0;
47: }
48: 
49: .slide-top-enter-active {
50:   transition: all 0.3s ease-out;
51: }
52: 
53: .slide-top-leave-active {
54:   transition: all 0.8s cubic-bezier(1, 0.5, 0.8, 1);
55: }
56: 
57: .slide-top-enter-from,
58: .slide-top-leave-to {
59:   transform: translateY(-20px);
60:   opacity: 0;
61: }
62: </style>
```

## File: layers/base/components/SideNav.vue
```vue
  1: <script setup lang="ts">
  2: const props = defineProps({
  3:   categories: {
  4:     type: Array,
  5:     required: true,
  6:   },
  7:   showDevHelpers: {
  8:     type: Boolean,
  9:     default: false,
 10:   },
 11:   isMobile: {
 12:     type: Boolean,
 13:     default: false,
 14:   },
 15:   isSidebarOpen: {
 16:     type: Boolean,
 17:     required: true,
 18:   },
 19:   isMobileSidebarOpen: {
 20:     type: Boolean,
 21:     required: true,
 22:   },
 23: })
 24: 
 25: const route = useRoute()
 26: const emit = defineEmits(['update:isSidebarOpen', 'update:isMobileSidebarOpen'])
 27: // Handle navigation - close mobile nav when navigating
 28: const handleNavigation = () => {
 29:   if (props.isMobile) {
 30:     emit('update:isMobileSidebarOpen', false)
 31:   }
 32: }
 33: 
 34: // Watch route changes to close mobile nav
 35: watch(
 36:   () => route.path,
 37:   () => {
 38:     if (props.isMobile) {
 39:       emit('update:isMobileSidebarOpen', false)
 40:     }
 41:   },
 42: )
 43: </script>
 44: 
 45: <template>
 46:   <div class="relative z-50">
 47:     <!-- Mobile Overlay -->
 48:     <div
 49:       v-if="isMobile"
 50:       class="fixed inset-0 z-[90] bg-black/50 transition-opacity duration-300"
 51:       :class="
 52:         isMobileSidebarOpen ? 'opacity-100 pointer-events-auto' : 'opacity-0 pointer-events-none'
 53:       "
 54:       @click="$emit('update:isMobileSidebarOpen', false)"
 55:     />
 56:     <div
 57:       class="flex flex-col background text-gray-300 shadow-lg transition-all duration-300 group"
 58:       :class="[
 59:         // Shared styles
 60:         'h-full',
 61: 
 62:         // Mobile styles
 63:         isMobile && [
 64:           'fixed left-0 top-0 bottom-0 z-[100]',
 65:           'w-[70vw]',
 66:           isMobileSidebarOpen ? 'translate-x-0' : '-translate-x-full',
 67:         ],
 68: 
 69:         // Desktop styles
 70:         !isMobile && ['relative', 'md:translate-x-0', isSidebarOpen ? 'md:w-60' : 'md:w-14'],
 71:       ]"
 72:     >
 73:       <!-- Toggle button (desktop only) -->
 74:       <button
 75:         v-if="!isMobile"
 76:         class="absolute !z-[1000] -right-3 top-24 hidden h-6 w-6 -translate-y-1/2 items-center justify-center rounded-full bg-primary-600 text-gray-300 transition-opacity duration-300 hover:bg-primary-400 group-hover:opacity-100 md:flex"
 77:         :class="[
 78:           'z-[110]', // Ensure button is above other elements
 79:           isSidebarOpen ? 'opacity-0' : 'opacity-100',
 80:         ]"
 81:         :title="isSidebarOpen ? 'Collapse sidebar' : 'Expand sidebar'"
 82:         @click="$emit('update:isSidebarOpen', !isSidebarOpen)"
 83:       >
 84:         <Icon
 85:           :name="isSidebarOpen ? 'mdi:chevron-left' : 'mdi:chevron-right'"
 86:           size="12px"
 87:         />
 88:       </button>
 89: 
 90:       <div class="flex h-full flex-col overflow-hidden">
 91:         <!-- Logo -->
 92:         <div
 93:           class="flex items-center px-4 py-3 transition-all duration-300"
 94:           :class="isMobile || isSidebarOpen ? 'gap-3' : 'justify-center'"
 95:         >
 96:           <div
 97:             class="flex items-center justify-center rounded-md border bg-white transition-all duration-300 delay-150"
 98:             :class="isMobile || isSidebarOpen ? 'h-10 w-10' : 'h-6 w-6'"
 99:           >
100:             <NuxtLink
101:               to="/"
102:               class="flex h-full w-full items-center justify-center"
103:             >
104:               <IBImage
105:                 :img="{ src: '/astronera-logo.jpg', width: 36, height: 36 }"
106:                 class="h-full w-full transition-all duration-300"
107:                 :class="isMobile || isSidebarOpen ? 'p-0.5' : 'p-1'"
108:                 no-shrink
109:               />
110:             </NuxtLink>
111:           </div>
112:           <Transition
113:             enter-active-class="transition-all duration-150 ease-out"
114:             leave-active-class="transition-all duration-150 ease-in"
115:             enter-from-class="opacity-0 -translate-x-4"
116:             leave-to-class="opacity-0 -translate-x-4"
117:           >
118:             <div
119:               v-if="isMobile || isSidebarOpen"
120:               class="flex cursor-pointer flex-col items-start justify-center text-sm font-bold uppercase leading-none tracking-normal"
121:             >
122:               Astron
123:               <strong class="font-extrabold text-primary-400">Era</strong>
124:             </div>
125:           </Transition>
126:         </div>
127: 
128:         <!-- Navigation Categories - always expanded on mobile -->
129:         <nav class="flex-1 space-y-4 px-2 py-4">
130:           <div
131:             v-for="category in categories"
132:             :key="category.id"
133:             class="space-y-1"
134:           >
135:             <div
136:               v-if="isMobile || isSidebarOpen"
137:               class="px-2 text-xs font-semibold uppercase text-gray-400"
138:             >
139:               {{ category.label }}
140:             </div>
141:             <ul>
142:               <li
143:                 v-for="item in category.items"
144:                 :key="item.slug"
145:               >
146:                 <NuxtLink
147:                   :to="item.slug"
148:                   class="flex items-center rounded-lg px-2 py-2 text-sm font-medium hover:bg-primary-700"
149:                   :class="{ 'bg-primary-800': route.path === item.slug }"
150:                   @click="handleNavigation"
151:                 >
152:                   <Icon
153:                     :name="item.icon"
154:                     size="20px"
155:                     class="mr-3 flex-shrink-0"
156:                   />
157:                   <span v-if="isMobile || isSidebarOpen">{{ item.label }}</span>
158:                 </NuxtLink>
159:               </li>
160:             </ul>
161:           </div>
162:         </nav>
163:       </div>
164:     </div>
165:   </div>
166: </template>
167: 
168: <style>
169: .transition-transform {
170:   transition-property: transform, width, height;
171: }
172: </style>
```

## File: layers/base/components/SocialBlock.vue
```vue
 1: <script setup lang="ts">
 2: interface Socials {
 3:   [key: string]: string
 4: }
 5: 
 6: const props = defineProps({
 7:   socials: {
 8:     type: Object as PropType<Socials>,
 9:     required: true,
10:   },
11:   size: {
12:     type: String,
13:     default: '24px',
14:   },
15: })
16: 
17: const socialIcon = (platform: string) => {
18:   switch (platform) {
19:     case 'linkedin':
20:       return 'mdi:linkedin'
21:     case 'youtube':
22:       return 'mdi:youtube'
23:     case 'instagram':
24:       return 'mdi:instagram'
25:     case 'facebook':
26:       return 'mdi:facebook'
27:     case 'twitter':
28:       return 'mdi:twitter'
29:     default:
30:       return ''
31:   }
32: }
33: 
34: const formattedSocials = computed(() => {
35:   if (!props.socials) return []
36:   return Object.entries(props.socials).map(([platform, url]) => {
37:     return {
38:       platform: platform.split('_')[0],
39:       url,
40:       icon: socialIcon(platform.split('_')[0]),
41:     }
42:   })
43: })
44: </script>
45: 
46: <template>
47:   <div
48:     v-if="formattedSocials.length > 0"
49:     class="flex gap-2"
50:   >
51:     <a
52:       v-for="social in formattedSocials"
53:       :key="`${social.platform}-icon`"
54:       class="flex cursor-pointer items-center"
55:       target="_blank"
56:       :href="social.url"
57:     >
58:       <Icon
59:         :name="social.icon"
60:         :size="size"
61:       />
62:     </a>
63:   </div>
64: </template>
65: 
66: <style scoped></style>
```

## File: layers/base/components/TabView.vue
```vue
 1: <script setup lang="ts">
 2: interface Tab {
 3:   title: string
 4:   slotName: string
 5:   value: string
 6: }
 7: 
 8: defineProps<{
 9:   tabs: Tab[]
10: }>()
11: </script>
12: 
13: <template>
14:   <PrimeTabs
15:     value="0"
16:     class="h-full"
17:     scrollable
18:     :pt="{
19:       root: 'w-full h-full',
20:     }"
21:     :pt-options="{ mergeSections: true }"
22:   >
23:     <PrimeTabList
24:       :pt="{
25:         root: 'gap-4 sticky top-0 left-0 z-50 flex text-nowrap flex-grow w-full overflow-scroll bg-black no-scrollbar border-b border-color',
26:       }"
27:       :pt-options="{ mergeSections: true, mergeProps: true }"
28:     >
29:       <PrimeTab
30:         v-for="tab in tabs"
31:         :key="tab.title"
32:         :value="tab.value"
33:         :pt="{
34:           root: ({ context }) => ({
35:             class: [
36:               'text-nowrap px-6 py-4 border-x border-color h-full',
37:               { 'bg-primary-900': context.active },
38:             ],
39:           }),
40:         }"
41:         :pt-options="{ mergeSections: true, mergeProps: true }"
42:       >
43:         {{ tab.title }}
44:       </PrimeTab>
45:     </PrimeTabList>
46:     <PrimeTabPanel
47:       v-for="tab in tabs"
48:       :key="`tab-index-${tab.title}`"
49:       :value="tab.value"
50:       :pt="{
51:         root: 'overflow-scroll h-full',
52:       }"
53:       :pt-options="{ mergeProps: true, mergeSections: true }"
54:     >
55:       <slot :name="tab.slotName" />
56:     </PrimeTabPanel>
57:   </PrimeTabs>
58: </template>
59: 
60: <style></style>
```

## File: layers/base/components/YT.client.vue
```vue
 1: <template>
 2:   <div id="player"></div>
 3: </template>
 4: 
 5: <script setup lang="ts">
 6: const player = ref(null)
 7: 
 8: onMounted(() => {
 9:   // Load the YouTube IFrame API dynamically if it's not already loaded
10:   if (!window.YT) {
11:     // Check if YT object is already present
12:     const tag = document.createElement('script')
13:     tag.src = 'https://www.youtube.com/iframe_api'
14:     const firstScriptTag = document.getElementsByTagName('script')[0]
15:     firstScriptTag.parentNode.insertBefore(tag, firstScriptTag)
16: 
17:     // Define the callback globally to initialize player when API is ready
18:     window.onYouTubeIframeAPIReady = initializePlayer
19:   } else {
20:     // Initialize the player immediately if YT is already loaded
21:     initializePlayer()
22:   }
23: })
24: 
25: function initializePlayer() {
26:   // Make sure the YT object and YT.Player are defined
27:   if (typeof YT !== 'undefined' && YT.Player) {
28:     player.value = new YT.Player('player', {
29:       // Ensure the element ID matches your template
30:       height: '390',
31:       width: '640',
32:       listType: 'user_uploads',
33:       list: 'Fireship', // Make sure 'Fireship' is a correct videoId or replace it with a valid one
34:       events: {
35:         onReady: onPlayerReady,
36:       },
37:     })
38:   }
39: }
40: 
41: function onPlayerReady(event) {
42:   event.target.playVideo()
43: }
44: 
45: onBeforeUnmount(() => {
46:   if (player.value) {
47:     player.value.destroy()
48:   }
49: })
50: </script>
```

## File: layers/base/composables/utils/arrays.ts
```typescript
1: export const removeDuplicates = <T>(arr: T[]): T[] => [...new Set(arr)]
2: 
3: export const sortBy = <T, K extends keyof T>(arr: T[], key: K): T[] =>
4:   arr.sort((a, b) => (a[key] > b[key] ? 1 : a[key] < b[key] ? -1 : 0))
```

## File: layers/base/composables/utils/hasValueChanged.ts
```typescript
 1: export function deepEqual(obj1: any, obj2: any): boolean {
 2:   if (obj1 === obj2) {
 3:     return true
 4:   }
 5: 
 6:   if (typeof obj1 !== 'object' || typeof obj2 !== 'object' || obj1 === null || obj2 === null) {
 7:     return false
 8:   }
 9: 
10:   if (Array.isArray(obj1) && Array.isArray(obj2)) {
11:     if (obj1.length !== obj2.length) {
12:       return false
13:     }
14:     for (let i = 0; i < obj1.length; i++) {
15:       if (!deepEqual(obj1[i], obj2[i])) {
16:         return false
17:       }
18:     }
19:     return true
20:   }
21: 
22:   if (Array.isArray(obj1) || Array.isArray(obj2)) {
23:     return false // One is an array, the other is not
24:   }
25: 
26:   const keys1 = Object.keys(obj1)
27:   const keys2 = Object.keys(obj2)
28: 
29:   if (keys1.length !== keys2.length) {
30:     return false
31:   }
32: 
33:   for (const key of keys1) {
34:     if (!keys2.includes(key) || !deepEqual(obj1[key], obj2[key])) {
35:       return false
36:     }
37:   }
38: 
39:   return true
40: }
41: 
42: export function hasValueChanged(newValue: any, currentValue: any): boolean {
43:   if (
44:     typeof newValue === 'string'
45:     || typeof newValue === 'boolean'
46:     || typeof newValue === 'number'
47:     || newValue === null
48:   ) {
49:     return newValue !== currentValue
50:   }
51: 
52:   if (Array.isArray(newValue) || typeof newValue === 'object') {
53:     return !deepEqual(newValue, currentValue)
54:   }
55: 
56:   return newValue !== currentValue
57: }
58: 
59: interface UpdateData {
60:   [key: string]: any
61: }
62: 
63: interface CleanDataResult {
64:   data: UpdateData
65:   noDataUpdated: boolean
66: }
67: 
68: export function wasRowDataUpdated(newData: UpdateData, previousData: UpdateData): CleanDataResult {
69:   const updatedData: UpdateData = {}
70: 
71:   Object.entries(newData).forEach(([key, value]) => {
72:     if (hasValueChanged(value, previousData[key])) {
73:       updatedData[key] = value
74:     }
75:   })
76: 
77:   return { data: updatedData, noDataUpdated: Object.keys(updatedData).length === 0 }
78: }
```

## File: layers/base/composables/utils/objects.ts
```typescript
1: export const pluck = <T, K extends keyof T>(objs: T[], key: K): T[K][] =>
2:   objs.map((obj) => obj[key])
```

## File: layers/base/composables/utils/strings.ts
```typescript
 1: export const slugify = (str: string): string => {
 2:   str = str.replace(/^\s+|\s+$/g, '')
 3:   str = str.toLowerCase()
 4: 
 5:   const from
 6:     = 'a/_,:;'
 7:   const to
 8:     = 'AAAAAACCCDEEEEEEEEIIIINNOOOOOORRSTUUUUUYYZaaaaaacccdeeeeeeeeiiiinnooooooorrstuuuuuyyzbBDdBAa------'
 9:   for (let i = 0, l = from.length; i < l; i++) {
10:     str = str.replace(new RegExp(from.charAt(i), 'g'), to.charAt(i))
11:   }
12: 
13:   str = str
14:     .replace(/[^a-z0-9 -]/g, '')
15:     .replace(/\s+/g, '-')
16:     .replace(/-+/g, '-')
17:   return str
18: }
19: 
20: export function upperCaseFirstLetter(str: string): string {
21:   const firstLetter = str.slice(0, 1)
22:   return firstLetter.toUpperCase() + str.substring(1)
23: }
24: 
25: export const stringIsNull = (value: any): boolean =>
26:   value === null || value === undefined || value === '' || value.length === 0
```

## File: layers/base/composables/utils/time.ts
```typescript
 1: export function toDateObject(inputDate = '2022-03-01T10:30:00-05:00') {
 2:   // !todo - add support for internationalization
 3:   // !todo - add support for dynamic length
 4:   const length = 'short'
 5:   // convert date to local time
 6:   const date = new Date(inputDate.toLocaleString())
 7: 
 8:   const formattedDate = new Intl.DateTimeFormat('en-US', {
 9:     weekday: length,
10:     year: 'numeric',
11:     month: length,
12:     day: 'numeric',
13:     hour: 'numeric',
14:     minute: 'numeric',
15:     timeZoneName: length,
16:   }).format(date)
17: 
18:   const dateArray = formattedDate.split(', ')
19: 
20:   return {
21:     weekday: dateArray[0],
22:     month: dateArray[1].split(' ')[0],
23:     day: dateArray[1].split(' ')[1],
24:     time: dateArray[3].split(' ')[0],
25:     ampm: dateArray[3].split(' ')[1],
26:     timezone: dateArray[3].split(' ')[2],
27:     year: dateArray[2],
28:   }
29: }
30: 
31: export function lastSeen(lastSeenTimestamp: string): string {
32:   const now = new Date()
33:   const lastSeen = new Date(lastSeenTimestamp)
34:   const secondsSinceLastSeen = Math.round((now.getTime() - lastSeen.getTime()) / 1000)
35: 
36:   if (secondsSinceLastSeen < 60) {
37:     return `${secondsSinceLastSeen} second${secondsSinceLastSeen === 1 ? '' : 's'} ago`
38:   }
39: 
40:   const minutesSinceLastSeen = Math.round(secondsSinceLastSeen / 60)
41: 
42:   if (minutesSinceLastSeen < 60) {
43:     return `${minutesSinceLastSeen} minute${minutesSinceLastSeen === 1 ? '' : 's'} ago`
44:   }
45: 
46:   const hoursSinceLastSeen = Math.round(minutesSinceLastSeen / 60)
47: 
48:   if (hoursSinceLastSeen < 24) {
49:     return `${hoursSinceLastSeen} hour${hoursSinceLastSeen === 1 ? '' : 's'} ago`
50:   }
51: 
52:   const daysSinceLastSeen = Math.round(hoursSinceLastSeen / 24)
53:   return `${daysSinceLastSeen} day${daysSinceLastSeen === 1 ? '' : 's'} ago`
54: }
```

## File: layers/base/composables/ab-test.ts
```typescript
 1: import type { DefineComponent } from 'vue'
 2: 
 3: export enum TestGoal {
 4:   SignUp = 'sign_up',
 5:   Purchase = 'purchase',
 6:   FeatureUsage = 'feature_usage',
 7:   TimeOnPage = 'time_on_page',
 8:   ClickThroughRate = 'click_through_rate',
 9: }
10: 
11: interface ABTestVariant<T> {
12:   name: string
13:   value: T
14: }
15: 
16: interface ABTestConfig<T> {
17:   experimentName: string
18:   variants: ABTestVariant<T>[]
19:   defaultVariant: ABTestVariant<T>
20:   goals: TestGoal[]
21: }
22: 
23: export function useABTest<T>({ experimentName, variants, defaultVariant, goals }: ABTestConfig<T>) {
24:   const { $posthog } = useNuxtApp()
25: 
26:   const selectedVariant = ref<ABTestVariant<T>>(defaultVariant)
27: 
28:   // Use PostHog's experiment feature to get the variant
29:   const variantName = $posthog.getFeatureFlag(experimentName)
30:   selectedVariant.value = variants.find((v) => v.name === variantName) || defaultVariant
31: 
32:   // Capture experiment exposure
33:   $posthog.capture('$experiment_started', {
34:     experiment: experimentName,
35:     variant: selectedVariant.value.name,
36:     goals: goals,
37:   })
38: 
39:   const value = computed(() => selectedVariant.value.value)
40: 
41:   // Function to track goal completion
42:   const trackGoal = (goal: TestGoal, properties: Record<string, any> = {}) => {
43:     $posthog.capture(goal, {
44:       ...properties,
45:       $experiment_name: experimentName,
46:       $variant: selectedVariant.value.name,
47:     })
48:   }
49: 
50:   return {
51:     variant: selectedVariant,
52:     value,
53:     trackGoal,
54:   }
55: }
56: 
57: // Helper function for component-based A/B tests
58: type ComponentVariant = ABTestVariant<DefineComponent<any, any, any>>
59: 
60: export function useComponentABTest(config: ABTestConfig<DefineComponent<any, any, any>>) {
61:   const { variant, trackGoal } = useABTest(config)
62: 
63:   const TestComponent = computed(() => ({
64:     render() {
65:       return h(variant.value.value.component)
66:     },
67:   }))
68: 
69:   return {
70:     TestComponent,
71:     trackGoal,
72:   }
73: }
```

## File: layers/base/composables/analytics.ts
```typescript
  1: import { ref, onMounted, onUnmounted } from 'vue'
  2: import { useRoute } from 'vue-router'
  3: 
  4: export enum UserAcquisitionMetric {
  5:   SignUpConversion = 'sign_up_conversion',
  6:   DemoRequest = 'demo_request',
  7:   ContactFormSubmission = 'contact_form_submission',
  8:   FeaturePageEngagement = 'feature_page_engagement',
  9:   BlogTraffic = 'blog_traffic',
 10: }
 11: 
 12: export enum OnboardingMetric {
 13:   StartRate = 'start_rate',
 14:   StepCompletion = 'step_completion',
 15:   DropOff = 'drop_off',
 16:   CompletionTime = 'completion_time',
 17: }
 18: 
 19: export enum UserEngagementMetric {
 20:   SessionDuration = 'session_duration',
 21:   ActionsPerSession = 'actions_per_session',
 22:   VisitFrequency = 'visit_frequency',
 23:   FeatureAdoption = 'feature_adoption',
 24: }
 25: 
 26: export enum ContentPerformanceMetric {
 27:   ArticleView = 'article_view',
 28:   ReadTime = 'read_time',
 29:   Share = 'share',
 30:   Like = 'like',
 31:   Comment = 'comment',
 32: }
 33: 
 34: export enum JobMarketMetric {
 35:   JobListing = 'job_listing',
 36:   JobView = 'job_view',
 37:   JobApplication = 'job_application',
 38:   CompanyProfileCreation = 'company_profile_creation',
 39:   CompanyFollow = 'company_follow',
 40: }
 41: 
 42: export enum TechnicalPerformanceMetric {
 43:   PageLoadTime = 'page_load_time',
 44:   APIResponseTime = 'api_response_time',
 45:   ErrorRate = 'error_rate',
 46:   Uptime = 'uptime',
 47: }
 48: 
 49: export type ContentType = 'blog_post' | 'news_article' | 'company_profile' | 'job_listing'
 50: 
 51: export type ErrorType = 'javascript_error' | 'api_error' | '404_error'
 52: 
 53: export interface AnalyticsEventProperties {
 54:   [key: string]: any
 55: }
 56: 
 57: export function useAnalytics() {
 58:   const { $posthog } = useNuxtApp()
 59:   const route = useRoute()
 60:   const pageEnterTime = ref(Date.now())
 61: 
 62:   const trackEvent = (eventName: string, properties?: AnalyticsEventProperties) => {
 63:     $posthog.capture(eventName, properties)
 64:   }
 65: 
 66:   const trackPageView = (properties?: AnalyticsEventProperties) => {
 67:     const timeSpent = Date.now() - pageEnterTime.value
 68:     $posthog.capture('$pageview', {
 69:       path: route.path,
 70:       title: document.title,
 71:       timeSpent,
 72:       ...properties,
 73:     })
 74:     pageEnterTime.value = Date.now()
 75:   }
 76: 
 77:   const identifyUser = (userId: string, properties?: AnalyticsEventProperties) => {
 78:     $posthog.identify(userId, properties)
 79:   }
 80: 
 81:   const trackError = (errorType: ErrorType, errorDetails: string, componentName?: string) => {
 82:     $posthog.capture('Error Occurred', {
 83:       errorType,
 84:       errorDetails,
 85:       componentName,
 86:     })
 87:   }
 88: 
 89:   const trackUserAcquisition = (
 90:     metric: UserAcquisitionMetric,
 91:     properties?: AnalyticsEventProperties,
 92:   ) => {
 93:     $posthog.capture(`User Acquisition - ${metric}`, properties)
 94:   }
 95: 
 96:   const trackOnboarding = (metric: OnboardingMetric, properties?: AnalyticsEventProperties) => {
 97:     $posthog.capture(`Onboarding - ${metric}`, properties)
 98:   }
 99: 
100:   const trackUserEngagement = (
101:     metric: UserEngagementMetric,
102:     properties?: AnalyticsEventProperties,
103:   ) => {
104:     $posthog.capture(`User Engagement - ${metric}`, properties)
105:   }
106: 
107:   const trackContentPerformance = (
108:     metric: ContentPerformanceMetric,
109:     contentType: ContentType,
110:     properties?: AnalyticsEventProperties,
111:   ) => {
112:     $posthog.capture(`Content Performance - ${contentType} - ${metric}`, properties)
113:   }
114: 
115:   const trackJobMarketActivity = (
116:     metric: JobMarketMetric,
117:     properties?: AnalyticsEventProperties,
118:   ) => {
119:     $posthog.capture(`Job Market - ${metric}`, properties)
120:   }
121: 
122:   const trackTechnicalPerformance = (
123:     metric: TechnicalPerformanceMetric,
124:     value: number,
125:     properties?: AnalyticsEventProperties,
126:   ) => {
127:     $posthog.capture(`Technical Performance - ${metric}`, { value, ...properties })
128:   }
129: 
130:   // Session tracking
131:   onMounted(() => {
132:     trackPageView()
133:     $posthog.capture('Session Started')
134:   })
135: 
136:   onUnmounted(() => {
137:     trackPageView()
138:     $posthog.capture('Session Ended', {
139:       sessionDuration: Date.now() - pageEnterTime.value,
140:     })
141:   })
142: 
143:   return {
144:     trackEvent,
145:     trackPageView,
146:     identifyUser,
147:     trackUserAcquisition,
148:     trackOnboarding,
149:     trackUserEngagement,
150:     trackContentPerformance,
151:     trackJobMarketActivity,
152:     trackTechnicalPerformance,
153:     trackError,
154:   }
155: }
156: 
157: // import {
158: //   UserAcquisitionMetric,
159: //   OnboardingMetric,
160: //   UserEngagementMetric,
161: //   ContentPerformanceMetric,
162: //   JobMarketMetric,
163: //   TechnicalPerformanceMetric,
164: //   ContentType,
165: //   ErrorType
166: // } from '~/types/analytics'
167: 
168: // const {
169: //   trackUserAcquisition,
170: //   trackOnboarding,
171: //   trackUserEngagement,
172: //   trackContentPerformance,
173: //   trackJobMarketActivity,
174: //   trackTechnicalPerformance,
175: //   trackError
176: // } = useAnalytics()
177: 
178: // // Track a sign-up conversion
179: // trackUserAcquisition(UserAcquisitionMetric.SignUpConversion, { source: 'organic' })
180: 
181: // // Track an onboarding step completion
182: // trackOnboarding(OnboardingMetric.StepCompletion, { step: 'personal_info', timeSpent: 120 })
183: 
184: // // Track a feature adoption
185: // trackUserEngagement(UserEngagementMetric.FeatureAdoption, { feature: 'job_search' })
186: 
187: // // Track a blog post share
188: // trackContentPerformance(ContentPerformanceMetric.Share, 'blog_post', { postId: '123', platform: 'twitter' })
189: 
190: // // Track a job application
191: // trackJobMarketActivity(JobMarketMetric.JobApplication, { jobId: '456', companyId: '789' })
192: 
193: // // Track page load time
194: // trackTechnicalPerformance(TechnicalPerformanceMetric.PageLoadTime, performance.now())
195: 
196: // // Track an error
197: // trackError(ErrorType.APIError, 'Failed to fetch job listings', 'JobSearchComponent')
```

## File: layers/base/composables/glass-card.ts
```typescript
  1: interface GlassCardProps {
  2:   color: string
  3:   bgOpacity: number
  4:   gradientOpacity: number
  5:   blurIntensity: string
  6:   disableHover: boolean
  7:   padding: string
  8:   loading: boolean
  9:   ariaLabel: string
 10: }
 11: 
 12: const cardStates = reactive<Record<string, any>>({})
 13: 
 14: export function useGlassCard(props: GlassCardProps, uniqueId: string) {
 15:   if (!cardStates[uniqueId]) {
 16:     cardStates[uniqueId] = {
 17:       tiltFactor: 0,
 18:       mouseX: 0,
 19:       mouseY: 0,
 20:       isOutside: true,
 21:       cardWidth: 0,
 22:       cardHeight: 0,
 23:     }
 24:   }
 25: 
 26:   const state = cardStates[uniqueId]
 27: 
 28:   const handleMouseMove = (event: MouseEvent) => {
 29:     const cardElement = document.getElementById(uniqueId)?.querySelector('.glass-card')
 30:     if (!cardElement) return
 31: 
 32:     const cardRect = cardElement.getBoundingClientRect()
 33: 
 34:     state.cardWidth = cardRect.width
 35:     state.cardHeight = cardRect.height
 36: 
 37:     const gravityArea = 100 // pixels around the card
 38:     const x = event.clientX - cardRect.left
 39:     const y = event.clientY - cardRect.top
 40: 
 41:     // Check if the mouse is within the gravity field
 42:     if (
 43:       x >= -gravityArea &&
 44:       x <= cardRect.width + gravityArea &&
 45:       y >= -gravityArea &&
 46:       y <= cardRect.height + gravityArea
 47:     ) {
 48:       state.mouseX = x
 49:       state.mouseY = y
 50:       state.isOutside = false
 51: 
 52:       // Calculate distance from the edge of the card
 53:       const distanceX = Math.max(0, -x, x - cardRect.width)
 54:       const distanceY = Math.max(0, -y, y - cardRect.height)
 55:       const distance = Math.sqrt(distanceX * distanceX + distanceY * distanceY)
 56: 
 57:       // Calculate tilt factor
 58:       if (x >= 0 && x <= cardRect.width && y >= 0 && y <= cardRect.height) {
 59:         state.tiltFactor = 1 // Cursor is directly over the card
 60:       } else {
 61:         // Smooth transition in the gravity area
 62:         state.tiltFactor = Math.max(0, 1 - distance / gravityArea)
 63:       }
 64:     } else {
 65:       state.tiltFactor = 0
 66:       state.isOutside = true
 67:     }
 68:   }
 69: 
 70:   const handleMouseLeave = () => {
 71:     state.tiltFactor = 0
 72:     state.isOutside = true
 73:   }
 74: 
 75:   const cardStyle = computed(() => {
 76:     if (state.isOutside) return {}
 77: 
 78:     const maxTilt = 4 // maximum tilt in degrees
 79: 
 80:     // Use cardWidth and cardHeight from state instead of getting them from cardRef
 81:     const centerX = state.cardWidth / 2
 82:     const centerY = state.cardHeight / 2
 83: 
 84:     const tiltY = ((state.mouseX - centerX) / centerX) * maxTilt * state.tiltFactor
 85:     const tiltX = ((centerY - state.mouseY) / centerY) * maxTilt * state.tiltFactor
 86: 
 87:     return {
 88:       transform: `perspective(1000px) rotateX(${tiltX}deg) rotateY(${tiltY}deg)`,
 89:       transition: state.isOutside ? 'transform 0.3s ease-out' : 'none',
 90:     }
 91:   })
 92: 
 93:   const spotlightColor = computed(() => {
 94:     const hue = (state.mouseX / state.cardWidth) * 360
 95:     return `hsl(${hue}, 100%, 70%)`
 96:   })
 97: 
 98:   const spotlightStyle = computed(() => {
 99:     if (state.isOutside) return { opacity: 0 }
100: 
101:     const spotlightSize = 300 // Fixed 300px radius
102:     const opacity = 0.07 + state.tiltFactor * 0.08
103: 
104:     return {
105:       background: `
106:       radial-gradient(circle ${spotlightSize}px at ${state.mouseX}px ${state.mouseY}px, 
107:       ${spotlightColor.value}, 
108:       transparent 70%),
109:       radial-gradient(circle ${spotlightSize * 0.8}px at ${state.mouseX}px ${state.mouseY}px, 
110:       ${spotlightColor.value}, 
111:       transparent 70%)
112:     `,
113:       opacity: opacity,
114:       transition: 'opacity 0.3s ease-out',
115:       mixBlendMode: 'soft-light',
116:     }
117:   })
118: 
119:   const bgClasses = computed(() => [
120:     `bg-${props.color}-950/${props.bgOpacity}`,
121:     `hover:bg-${props.color}-900/${props.bgOpacity + 10}`,
122:   ])
123: 
124:   const borderClasses = computed(() => [
125:     'border',
126:     'border-color',
127:     `hover:border-${props.color}-400/40`,
128:   ])
129: 
130:   const textClasses = computed(() => [`text-${props.color}-100`])
131: 
132:   const gradientClasses = computed(() => [
133:     `from-${props.color}-100/${props.gradientOpacity}`,
134:     `to-${props.color}-500/${props.gradientOpacity}`,
135:   ])
136: 
137:   const hoverClasses = computed(() =>
138:     props.disableHover
139:       ? []
140:       : ['hover:shadow-2xl', `hover:bg-${props.color}-800/${props.bgOpacity + 10}`],
141:   )
142: 
143:   return {
144:     handleMouseMove,
145:     handleMouseLeave,
146:     cardStyle,
147:     spotlightStyle,
148:     bgClasses,
149:     borderClasses,
150:     textClasses,
151:     gradientClasses,
152:     hoverClasses,
153:   }
154: }
```

## File: layers/base/composables/metrics.ts
```typescript
 1: function roundToNDecimalPlaces(value: number, n: number): number {
 2:   return Number(value.toFixed(n))
 3: }
 4: 
 5: function calculateMedian(arr: number[]): number {
 6:   const sorted = arr.slice().sort((a, b) => a - b)
 7:   const mid = Math.floor(sorted.length / 2)
 8:   return sorted.length % 2 !== 0 ? sorted[mid] : (sorted[mid - 1] + sorted[mid]) / 2
 9: }
10: 
11: function calculateStandardDeviation(valuesArray: number[]): number {
12:   const mean = valuesArray.reduce((a, b) => a + b) / valuesArray.length
13:   return Math.sqrt(
14:     valuesArray.map((x) => Math.pow(x - mean, 2)).reduce((a, b) => a + b) / valuesArray.length,
15:   )
16: }
17: 
18: function calculateMean(arr: number[]): number {
19:   return arr.reduce((a, b) => a + b) / arr.length
20: }
21: 
22: function calculateVariance(arr: number[]): number {
23:   const mean = calculateMean(arr)
24:   return arr.reduce((sum, value) => sum + Math.pow(value - mean, 2), 0) / arr.length
25: }
26: 
27: function calculateRange(arr: number[]): number {
28:   return Math.max(...arr) - Math.min(...arr)
29: }
30: 
31: function calculateSum(arr: number[]): number {
32:   return arr.reduce((a, b) => a + b, 0)
33: }
34: 
35: function calculateMode(arr: number[]): number | number[] {
36:   const frequency: { [key: number]: number } = {}
37:   let maxFreq = 0
38:   let modes: number[] = []
39: 
40:   arr.forEach((value) => {
41:     frequency[value] = (frequency[value] || 0) + 1
42:     if (frequency[value] > maxFreq) {
43:       maxFreq = frequency[value]
44:       modes = [value]
45:     } else if (frequency[value] === maxFreq) {
46:       modes.push(value)
47:     }
48:   })
49: 
50:   return modes.length === 1 ? modes[0] : modes
51: }
52: 
53: function calculateMin(arr: number[]): number {
54:   return Math.min(...arr)
55: }
56: 
57: function calculateMax(arr: number[]): number {
58:   return Math.max(...arr)
59: }
60: 
61: function calculatePercentile(arr: number[], percentile: number): number {
62:   if (percentile < 0 || percentile > 100) {
63:     throw new Error('Percentile must be between 0 and 100')
64:   }
65:   const sorted = arr.slice().sort((a, b) => a - b)
66:   const index = (percentile / 100) * (sorted.length - 1)
67:   const lower = Math.floor(index)
68:   const upper = lower + 1
69:   const weight = index % 1
70: 
71:   if (upper >= sorted.length) {
72:     return sorted[lower]
73:   }
74: 
75:   return sorted[lower] * (1 - weight) + sorted[upper] * weight
76: }
77: 
78: export function useBaseMetrics() {
79:   return {
80:     format: {
81:       roundToN: roundToNDecimalPlaces,
82:     },
83:     calculate: {
84:       median: calculateMedian,
85:       standardDeviation: calculateStandardDeviation,
86:       mean: calculateMean,
87:       variance: calculateVariance,
88:       range: calculateRange,
89:       sum: calculateSum,
90:       mode: calculateMode,
91:       min: calculateMin,
92:       max: calculateMax,
93:       percentile: calculatePercentile,
94:     },
95:   }
96: }
```

## File: layers/base/composables/modal.ts
```typescript
 1: export function useModal() {
 2:   // was used for news modals at one point
 3:   const currentPost = computed(() => news.value[currentIndex.value])
 4:   const nextPost = computed(() => news.value[nextIndex.value])
 5:   const previousPost = computed(() => news.value[previousIndex.value])
 6:   const isModalOpen = ref(false)
 7:   const currentIndex = ref(0)
 8:   const previousIndex = computed(() => (currentIndex.value > 0 ? currentIndex.value - 1 : 0))
 9:   const nextIndex = computed(() =>
10:     currentIndex.value < news.value.length - 1 ? currentIndex.value + 1 : currentIndex.value,
11:   )
12: 
13:   const toggleModal = (postIndex?: number) => {
14:     isModalOpen.value = !isModalOpen.value
15:     if (postIndex !== undefined) {
16:       currentIndex.value = postIndex
17:     }
18:   }
19: 
20:   const next = () => {
21:     if (currentIndex.value < news.value.length - 1) {
22:       currentIndex.value++
23:     }
24:   }
25: 
26:   const previous = () => {
27:     if (currentIndex.value > 0) {
28:       currentIndex.value--
29:     }
30:   }
31: }
```

## File: layers/base/composables/notification.ts
```typescript
 1: import type { useToast } from 'primevue/usetoast'
 2: 
 3: interface BaseNotification {
 4:   summary: string
 5:   message: string
 6: }
 7: 
 8: export function useNotification() {
 9:   const nuxtApp = useNuxtApp()
10:   const getToast: typeof useToast = () => nuxtApp.vueApp.config.globalProperties.$toast
11:   const toast = getToast()
12: 
13:   const success = ({ summary, message }: BaseNotification) => {
14:     toast.add({
15:       severity: 'success',
16:       summary: `Success: ${summary}`,
17:       detail: message,
18:       life: 5000,
19:       closable: true,
20:     })
21:   }
22: 
23:   const error = ({ summary, message }: BaseNotification) => {
24:     toast.add({
25:       severity: 'error',
26:       summary: `Error: ${summary}`,
27:       detail: message,
28:       life: 0,
29:       closable: true,
30:     })
31:   }
32: 
33:   const info = ({ summary, message }: BaseNotification) => {
34:     toast.add({
35:       severity: 'info',
36:       summary: `Info: ${summary}`,
37:       detail: message,
38:       life: 5000,
39:       closable: true,
40:     })
41:   }
42: 
43:   const warn = ({ summary, message }: BaseNotification) => {
44:     toast.add({
45:       severity: 'warn',
46:       summary: `Warning: ${summary}`,
47:       detail: message,
48:       life: 5000,
49:       closable: true,
50:     })
51:   }
52: 
53:   const feature = ({ summary, message }: BaseNotification) => {
54:     toast.add({
55:       severity: 'warn',
56:       group: 'cta',
57:       summary: summary,
58:       detail: message,
59:       life: 0,
60:       closable: true,
61:     })
62:   }
63: 
64:   return {
65:     success,
66:     error,
67:     info,
68:     warn,
69:     feature,
70:   }
71: }
```

## File: layers/base/composables/settings.store.ts
```typescript
 1: type SettingsKey = 'usersStore' | 'storeNews'
 2: 
 3: export const useSettingsStore = defineStore('settingsStore', () => {
 4:   const settings = ref({} as Settings)
 5:   const summaryLevel = ref('beginner' as SummaryLevel)
 6: 
 7:   function toggleSettings(key: SettingsKey) {
 8:     settings.value[key] = !settings.value[key]
 9:   }
10: 
11:   function isSettingsOn(key: SettingsKey) {
12:     return !settings.value[key]
13:   }
14: 
15:   const changeSummaryLevel = (level: 'beginner' | 'intermediate' | 'expert') => {
16:     summaryLevel.value = level
17:   }
18: 
19:   return {
20:     toggleSettings,
21:     isSettingsOn,
22:   }
23: })
24: 
25: if (import.meta.hot) {
26:   import.meta.hot.accept(acceptHMRUpdate(useSettingsStore, import.meta.hot))
27: }
```

## File: layers/base/composables/social.store.ts
```typescript
  1: import { useLogger } from '@ib/logger'
  2: 
  3: export const useSocialStore = defineStore('settingsStore', () => {
  4:   const errors = useBaseError()
  5:   const logger = useLogger('useSocialStore')
  6:   const { fetch } = useBaseFetch()
  7: 
  8:   const youtube = ref({})
  9:   async function getYoutubeAnalytics(channelName: string) {
 10:     logger.info(`getting youtube analytics for ${channelName}`)
 11:     const response = await fetch('/api/social/youtube/analytics', {
 12:       method: 'GET',
 13:       query: {
 14:         channelName,
 15:       },
 16:     })
 17: 
 18:     const data = errors.server({
 19:       response,
 20:       devOnly: false,
 21:       devMessage: 'error getting youtube analytics',
 22:       userMessage: 'something went wrong when getting youtube analytics',
 23:     })
 24: 
 25:     youtube.value = data
 26:   }
 27: 
 28:   const instagram = ref<any>(null)
 29:   async function getInstagramAnalytics(userId: string) {
 30:     const logger = useLogger('getInstagramAnalytics')
 31:     logger.info(`Fetching Instagram analytics for ${userId}`)
 32:     try {
 33:       const response = await $fetch(`/api/social/instagram/analytics?userId=${userId}`, {
 34:         method: 'GET',
 35:       })
 36: 
 37:       const data = errors.server({
 38:         response,
 39:         devOnly: false,
 40:         devMessage: 'Error getting Instagram analytics',
 41:         userMessage: 'Something went wrong when getting Instagram analytics',
 42:       })
 43: 
 44:       instagram.value = data
 45:     } catch (error) {
 46:       errors.client({
 47:         error,
 48:         devOnly: false,
 49:         devMessage: 'Error getting Instagram analytics',
 50:         userMessage: 'Something went wrong when getting Instagram analytics',
 51:       })
 52:     }
 53:   }
 54: 
 55:   const linkedin = ref<any>(null)
 56:   async function getLinkedInAnalytics(postId: string) {
 57:     const logger = useLogger('getLinkedInAnalytics')
 58:     logger.info(`Fetching LinkedIn analytics for post ${postId}`)
 59:     try {
 60:       const response = await $fetch(`/api/social/linkedin/analytics?postId=${postId}`, {
 61:         method: 'GET',
 62:       })
 63: 
 64:       const data = errors.server({
 65:         response,
 66:         devOnly: false,
 67:         devMessage: 'Error getting LinkedIn analytics',
 68:         userMessage: 'Something went wrong when getting LinkedIn analytics',
 69:       })
 70: 
 71:       linkedin.value = data
 72:     } catch (error) {
 73:       errors.client({
 74:         error,
 75:         devOnly: false,
 76:         devMessage: 'Error getting LinkedIn analytics',
 77:         userMessage: 'Something went wrong when getting LinkedIn analytics',
 78:       })
 79:     }
 80:   }
 81: 
 82:   const twitter = ref<any>(null)
 83:   async function getTwitterAnalytics(postId: string) {
 84:     const logger = useLogger('getTwitterAnalytics')
 85:     logger.info(`Fetching Twitter analytics for post ${postId}`)
 86:     try {
 87:       const response = await fetch(`/api/social/twitter/analytics?postId=${postId}`, {
 88:         method: 'GET',
 89:       })
 90: 
 91:       const data = errors.server({
 92:         response,
 93:         devOnly: false,
 94:         devMessage: 'Error getting Twitter analytics',
 95:         userMessage: 'Something went wrong when getting Twitter analytics',
 96:       })
 97: 
 98:       twitter.value = data
 99:     } catch (error) {
100:       errors.client({
101:         error,
102:         devOnly: false,
103:         devMessage: 'Error getting Twitter analytics',
104:         userMessage: 'Something went wrong when getting Twitter analytics',
105:       })
106:     }
107:   }
108: 
109:   return {
110:     youtube,
111:     getYoutubeAnalytics,
112:     //
113:     instagram,
114:     getInstagramAnalytics,
115:     //
116:     linkedin,
117:     getLinkedInAnalytics,
118:     //
119:     twitter,
120:     getTwitterAnalytics,
121:   }
122: })
123: 
124: if (import.meta.hot) {
125:   import.meta.hot.accept(acceptHMRUpdate(useSocialStore, import.meta.hot))
126: }
```

## File: layers/base/composables/useMediaQuery.ts
```typescript
 1: // composables/useMediaQuery.ts
 2: export const useMediaQuery = (query: string) => {
 3:   const matches = ref(false)
 4: 
 5:   if (import.meta.client) {
 6:     const mediaQuery = window.matchMedia(query)
 7:     matches.value = mediaQuery.matches
 8: 
 9:     const handler = (event: MediaQueryListEvent) => {
10:       matches.value = event.matches
11:     }
12: 
13:     // Watch for changes
14:     mediaQuery.addEventListener('change', handler)
15: 
16:     // Cleanup
17:     onUnmounted(() => {
18:       mediaQuery.removeEventListener('change', handler)
19:     })
20:   }
21: 
22:   return matches
23: }
```

## File: layers/base/composables/useNavigation.ts
```typescript
 1: // composables/useNavigation.ts
 2: export const useNavigation = () => {
 3:   const isSidebarOpen = useState('nav-sidebar-open', () => true)
 4:   const isMobileSidebarOpen = useState('nav-mobile-sidebar-open', () => false)
 5: 
 6:   // Create our own media query composable
 7:   const isMobile = useMediaQuery('(max-width: 768px)')
 8: 
 9:   // Close mobile nav on route changes
10:   const route = useRoute()
11:   
12:   watch(
13:     () => route.path,
14:     () => {
15:       isMobileSidebarOpen.value = false
16:     },
17:   )
18: 
19:   return {
20:     isSidebarOpen,
21:     isMobileSidebarOpen,
22:     isMobile,
23:   }
24: }
```

## File: layers/base/composables/utils.ts
```typescript
 1: import { wasRowDataUpdated } from './utils/hasValueChanged'
 2: import * as time from './utils/time'
 3: import * as strings from './utils/strings'
 4: import * as objects from './utils/objects'
 5: import * as arrays from './utils/arrays'
 6: 
 7: export function useUtils() {
 8:   return {
 9:     wasRowDataUpdated,
10:     time: {
11:       format: time.toDateObject,
12:       lastSeen: time.lastSeen,
13:     },
14:     strings: {
15:       firstUpper: strings.upperCaseFirstLetter,
16:       slugify: strings.slugify,
17:     },
18:     arrays: {
19:       removeDuplicates: arrays.removeDuplicates,
20:       sortBy: arrays.sortBy,
21:     },
22:     objects: {
23:       pluck: objects.pluck,
24:     },
25:   }
26: }
```

## File: layers/base/plugins/error-handler.ts
```typescript
 1: import { useErrorHandler } from '@ib/logger'
 2: 
 3: export default defineNuxtPlugin((nuxtApp) => {
 4:   const { handleError } = useErrorHandler()
 5: 
 6:   // Set up global error handlers
 7:   if (import.meta.client) {
 8:     window.addEventListener('error', (event) => {
 9:       handleError(event.error, 'Uncaught Exception')
10:     })
11: 
12:     window.addEventListener('unhandledrejection', (event) => {
13:       handleError(event.reason, 'Unhandled Promise Rejection')
14:     })
15:   }
16: })
```

## File: layers/base/plugins/posthog.client.ts
```typescript
 1: import posthog from 'posthog-js'
 2: 
 3: export default defineNuxtPlugin((nuxtApp) => {
 4:   const env = nuxtApp.$config.public
 5:   const env2 = useRuntimeConfig().public
 6: 
 7:   console.log('ENV Key:', env, env2)
 8:   console.log('NODE_ENV:', import.meta.env.NODE_ENV)
 9: 
10:   const posthogKey = env.posthogKey || env2.posthogKey
11:   const posthogUrl = env.posthogUrl || env2.posthogUrl
12: 
13:   // Initialize PostHog
14:   posthog.init(posthogKey, {
15:     api_host: posthogUrl,
16:     autocapture: false, // Disable autocapture as we'll handle events manually
17:     capture_pageview: false, // We'll capture pageviews manually for more control
18:     persistence: 'localStorage+cookie',
19:     // bootstrap: {
20:     //   distinctID: runtimeConfig.public.posthogDistinctId // Set this in your runtime config if you have a user ID
21:     // },
22:     loaded: (posthog) => {
23:       // This function is called once PostHog is loaded
24:       if (import.meta.env.NODE_ENV === 'development') {
25:         // Log to console in development mode
26:         posthog.debug()
27:       }
28:     },
29:   })
30: 
31:   // Capture page views
32:   nuxtApp.hook('page:finish', () => {
33:     posthog.capture('$pageview')
34:   })
35: 
36:   // Expose PostHog instance and utility functions
37:   return {
38:     provide: {
39:       posthog: {
40:         // Expose the raw PostHog instance
41:         raw: posthog,
42: 
43:         // Utility function to capture events
44:         capture: (eventName: string, properties?: Record<string, any>) => {
45:           posthog.capture(eventName, properties)
46:         },
47: 
48:         // Utility function for A/B testing
49:         getFeatureFlag: (flagName: string, defaultValue?: any) => {
50:           return posthog.getFeatureFlag(flagName, defaultValue)
51:         },
52: 
53:         // Utility function to identify users
54:         identify: (distinctId: string, properties?: Record<string, any>) => {
55:           posthog.identify(distinctId, properties)
56:         },
57: 
58:         // Utility function to reset user identity
59:         reset: () => {
60:           posthog.reset()
61:         },
62: 
63:         // Utility function to opt in/out of tracking
64:         optIn: () => {
65:           posthog.opt_in_capturing()
66:         },
67:         optOut: () => {
68:           posthog.opt_out_capturing()
69:         },
70: 
71:         // Utility function for registering super properties
72:         register: (properties: Record<string, any>) => {
73:           posthog.register(properties)
74:         },
75: 
76:         // Utility function for registering one-time super properties
77:         registerOnce: (properties: Record<string, any>) => {
78:           posthog.register_once(properties)
79:         },
80:       },
81:     },
82:   }
83: })
```

## File: layers/base/plugins/sentry.client.ts
```typescript
 1: import * as Sentry from '@sentry/vue'
 2: import { defineNuxtPlugin } from '#app'
 3: 
 4: export default defineNuxtPlugin((nuxtApp) => {
 5:   const app = nuxtApp.vueApp
 6:   const router = useRouter()
 7: 
 8:   Sentry.init({
 9:     app,
10:     dsn: 'https://eec364410b024a5a837f60e00d367513@o1175094.ingest.sentry.io/4504389151621120',
11:     integrations: [Sentry.browserTracingIntegration({ router }), Sentry.replayIntegration()],
12:     tracesSampleRate: process.env.NODE_ENV === 'production' ? 0.2 : 1.0,
13:     tracePropagationTargets: ['localhost', /^https:\/\/yourserver\.io\/api/],
14:     replaysSessionSampleRate: 0.1,
15:     replaysOnErrorSampleRate: 1.0,
16:     attachProps: true,
17:     trackComponents: true,
18:   })
19: 
20:   // Sentry.setUser(useSupabaseUser())
21:   Sentry.setTag('environment', process.env.NODE_ENV)
22: })
```

## File: layers/base/types/content.ts
```typescript
 1: import { z } from 'zod'
 2: 
 3: export const titleSchema = z.object({
 4:   centered: z.boolean().optional(),
 5:   label: z.string().optional(),
 6:   main: z.string(),
 7:   subtitle: z.string().optional(),
 8: })
 9: 
10: export const faqSchema = z.object({
11:   label: z.string(),
12:   description: z.string(),
13: })
14: 
15: export const imageSchema = z.object({
16:   src: z.string(),
17:   alt: z.string(),
18:   width: z.number().optional(),
19:   height: z.number().optional(),
20: })
21: 
22: export type ImageType = z.infer<typeof imageSchema>
23: export type TitleType = z.infer<typeof titleSchema>
24: export type FaqType = z.infer<typeof faqSchema>
```

## File: layers/base/types/database.ts
```typescript
 1: import type { Tables } from '../../../supabase/schema.gen'
 2: 
 3: export type RowUser = Tables<'user_profiles'>
 4: export type RowUserFollowers = Tables<'user_followers'>
 5: export type RowRole = Tables<'roles'>
 6: export type RowRegisterInterest = Tables<'register_interest'>
 7: 
 8: export type RowCategory = Tables<'categories'>
 9: export type RowTag = Tables<'tags'>
10: 
11: export type RowNews = Tables<'news'>
12: export type RowNewsTag = Tables<'news_tags'>
13: 
14: export type RowEmbedding = Tables<'embeddings'>
15: 
16: export type RowPaper = Tables<'papers'>
17: 
18: type ArrayToUnion<A> = A extends readonly (infer T)[] ? T : never
19: 
20: const userCardKeys = [
21:   'id',
22:   'given_name',
23:   'surname',
24:   'username',
25:   'avatar',
26:   'followed_count',
27:   'followers_count',
28:   'plan',
29: ] as const
30: 
31: export type UserCard = Pick<RowUser, ArrayToUnion<typeof userCardKeys>>
```

## File: layers/base/types/index.ts
```typescript
1: export * from './users'
2: export * from './other-type-file'
```

## File: layers/base/types/users.ts
```typescript
 1: // don't forget to add to this file if you make any changes in the database
 2: import * as z from 'zod'
 3: 
 4: export const LocationSchema = z.object({
 5:   id: z.number(),
 6:   created_at: z.string().optional(),
 7:   city: z.string(),
 8:   country: z.string(),
 9:   state: z.string(),
10:   address: z.string().nullable(),
11:   latitude: z.number().optional().nullable(),
12:   longitude: z.number().optional().nullable(),
13: })
14: 
15: export const UserRoleSchema = z.object({
16:   id: z.number(),
17:   name: z.string().nullable(),
18:   body: z.string().nullable().optional(),
19:   created_at: z.string().optional(),
20:   icon: z.string(),
21: })
22: 
23: export const IdName = z.object({
24:   id: z.number(),
25:   name: z.string(),
26: })
27: 
28: export const UserSkillSchema = z.object({
29:   id: z.number(),
30:   title: z.string().nullable(),
31:   body: z.string().nullable().optional(),
32:   total_endorsements: z.number(),
33:   admin_rating: z.number().nullable(),
34:   avg_rating: z.number().nullable(),
35:   created_at: z.string().optional(),
36: })
37: 
38: export const UserSocialSchema = z.object({
39:   id: z.number(),
40:   url: z.string(),
41:   platform: z.string(),
42:   username: z.string(),
43: })
44: 
45: export const UserBasicSchema = z.object({
46:   id: z.string(),
47:   given_name: z.string(),
48:   surname: z.string().nullable(),
49:   username: z.string().nullable(),
50:   avatar: z.string().nullable(),
51:   introduction: z.string().nullable(),
52:   followers_count: z.number().nullable(),
53:   followed_count: z.number().nullable(),
54:   is_following: z.boolean().nullable(),
55:   role: z.number(),
56: })
57: 
58: export const UserFullSchema = UserBasicSchema.extend({
59:   email: z.string(),
60:   dob: z.string().nullable(),
61:   gender_id: z.number().nullable(),
62:   created_at: z.string(),
63:   updated_at: z.string().nullable(),
64:   quote: z.string().nullable(),
65: })
66: 
67: export const UserRowSchema = z.object({
68:   given_name: z.string(),
69:   email: z.string(),
70:   surname: z.string().nullable(),
71:   username: z.string().nullable(),
72:   avatar: z.string().nullable(),
73:   introduction: z.string().nullable(),
74:   plan: z.string().nullish(),
75:   dob: z.string().nullable(),
76:   quote: z.string().nullable(),
77:   gender_id: z.number().nullable(),
78: })
79: 
80: export const UserRolesSchema = z.array(UserRoleSchema)
81: 
82: export type UserType = z.infer<typeof UserBasicSchema>
83: export type UserFullType = z.infer<typeof UserFullSchema>
84: export type UserRoleType = z.infer<typeof UserRoleSchema>
85: export type UserRowType = z.infer<typeof UserRowSchema>
86: export type UserSocialType = z.infer<typeof UserSocialSchema>
```

## File: layers/base/nuxt.config.ts
```typescript
 1: import { defineNuxtConfig } from 'nuxt/config'
 2: 
 3: export default defineNuxtConfig({
 4:   workspaceDir: '../../',
 5:   srcDir: '.',
 6: 
 7:   icon: {
 8:     serverBundle: {
 9:       collections: ['material-symbols', 'mdi'],
10:     },
11:   },
12: 
13:   eslint: {
14:     checker: true,
15:   },
16: 
17:   image: {
18:     providers: {
19:       supabase: {
20:         provider: '../../layers/base/supabase-provider.ts',
21:         options: {
22:           baseURL: process.env.NUXT_PUBLIC_SUPABASE_URL,
23:         },
24:       },
25:     },
26:     presets: {
27:       original: {
28:         modifiers: {
29:           width: 1920,
30:           height: 1080,
31:         },
32:       },
33:       mobile: {
34:         modifiers: {
35:           width: 768,
36:           height: 1024,
37:         },
38:       },
39:       thumbnail: {
40:         modifiers: {
41:           width: 300,
42:           height: 200,
43:         },
44:       },
45:     },
46:   },
47: 
48:   components: [
49:     {
50:       path: './components',
51:       pathPrefix: false,
52:       prefix: 'IB',
53:       global: true,
54:     },
55:   ],
56: })
```

## File: layers/base/supabase-provider.ts
```typescript
 1: export function getImage(
 2:   src,
 3:   {
 4:     modifiers = { width: null, height: null, format: null },
 5:     baseURL = process.env.NUXT_PUBLIC_SUPABASE_URL,
 6:   } = {},
 7: ) {
 8:   const { width, height, format } = modifiers
 9:   const [_, bucket, sizeName, imageFileName] = src.split('/')
10: 
11:   // Determine target size
12:   let targetSizeName = sizeName
13:   if (width && height) {
14:     if (width <= 300 && height <= 200) {
15:       targetSizeName = 'thumbnail'
16:     } else if (width <= 768 && height <= 1024) {
17:       targetSizeName = 'mobile'
18:     } else {
19:       targetSizeName = 'original'
20:     }
21:   }
22: 
23:   const imageNameWithoutExt = imageFileName.split('.')[0]
24:   const imageFormat = format || imageFileName.split('.')[1] || 'jpg'
25: 
26:   return {
27:     url: `${baseURL}/storage/v1/object/public/${bucket}/${targetSizeName}/${imageNameWithoutExt}.${imageFormat}`,
28:   }
29: }
```

## File: layers/crud/.playground/app.config.ts
```typescript
1: export default defineAppConfig({
2:   myLayer: {
3:     name: 'My amazing Nuxt layer (overwritten)'
4:   }
5: })
```

## File: layers/crud/.playground/nuxt.config.ts
```typescript
1: export default defineNuxtConfig({
2:   extends: ['..'],
3:   modules: ['@nuxt/eslint']
4: })
```

## File: layers/crud/components/Feedback.vue
```vue
  1: <script setup lang="ts">
  2: import { z } from 'zod'
  3: 
  4: const feedbackStore = useFeedbackStore()
  5: 
  6: defineProps({
  7:   cta: {
  8:     type: String,
  9:     required: true,
 10:     default: 'How could we improve?',
 11:   },
 12: })
 13: 
 14: interface FeedbackType {
 15:   name: string
 16:   value: string
 17: }
 18: 
 19: const feedbackTypes = [
 20:   { name: 'Bug Report', value: 'bug_report' },
 21:   { name: 'Feature Request', value: 'feature_request' },
 22:   { name: 'User Interface Issue', value: 'user_interface_issue' },
 23:   { name: 'Performance Issue', value: 'performance_issue' },
 24:   { name: 'Documentation', value: 'documentation' },
 25: ]
 26: 
 27: const route = useRoute()
 28: const { userId } = useCurrentUser()
 29: 
 30: const initialFeedback = () => ({
 31:   user_id: userId,
 32:   page_identifier: route.fullPath,
 33:   feedback_type: null,
 34:   message: '',
 35:   device_info: '',
 36:   content_status: 'new',
 37: })
 38: 
 39: const feedback = ref(initialFeedback())
 40: 
 41: const messagePlaceholder = computed(() => {
 42:   if (!feedback.value.feedback_type) {
 43:     return 'Please select a feedback type first'
 44:   }
 45: 
 46:   const type = feedback.value.feedback_type
 47:   if (!type) return ''
 48: 
 49:   switch (type.value) {
 50:     case 'bug_report':
 51:       return 'Describe the bug in detail...'
 52:     case 'feature_request':
 53:       return 'Describe the feature you would like to see...'
 54:     case 'user_interface_issue':
 55:       return 'What UI issue did you encounter?'
 56:     case 'performance_issue':
 57:       return 'Describe the performance issue...'
 58:     case 'documentation':
 59:       return 'What documentation issue did you find?'
 60:     default:
 61:       return 'Enter your message'
 62:   }
 63: })
 64: 
 65: const isMessageDisabled = computed(() => !feedback.value.feedback_type)
 66: 
 67: const messageLength = z.string().min(10)
 68: 
 69: const isMessageInvalid = computed(() => !messageLength.safeParse(feedback.value.message).success)
 70: 
 71: const resetFeedback = () => {
 72:   feedback.value = initialFeedback()
 73: }
 74: 
 75: const submitFeedback = async () => {
 76:   await feedbackStore.submitFeedback(feedback.value)
 77:   resetFeedback()
 78: }
 79: </script>
 80: 
 81: <template>
 82:   <div class="w-52">
 83:     <h2 class="text-lg mb-4 text-left font-bold">
 84:       {{ cta }}
 85:     </h2>
 86:     <form
 87:       class="w-52 space-y-4"
 88:       @submit.prevent="submitFeedback"
 89:     >
 90:       <PrimeSelect
 91:         v-model="feedback.feedback_type"
 92:         :pt="{ root: 'flex text-left pl-1' }"
 93:         :pt-options="{ mergeProps: true, mergeSections: true }"
 94:         :options="feedbackTypes"
 95:         option-label="name"
 96:         placeholder="Feedback Type"
 97:       />
 98:       <PrimeTextarea
 99:         v-show="feedback.feedback_type"
100:         v-model="feedback.message"
101:         class="w-full"
102:         :rows="5"
103:         :placeholder="messagePlaceholder"
104:         :disabled="isMessageDisabled"
105:         :invalid="isMessageInvalid"
106:       />
107:       <div>
108:         <PrimeButton
109:           v-show="feedback.feedback_type"
110:           class="flex w-full justify-between"
111:           :disabled="isMessageInvalid"
112:           :outlined="isMessageInvalid"
113:           @click="submitFeedback"
114:         >
115:           Submit Feedback
116:           <Icon name="mdi:send" />
117:         </PrimeButton>
118:       </div>
119:     </form>
120:   </div>
121: </template>
122: 
123: <style scoped></style>
```

## File: layers/crud/components/Upload.vue
```vue
 1: <script setup lang="ts">
 2: // const toast = useNotification()
 3: 
 4: const props = defineProps({
 5:   name: {
 6:     type: String,
 7:     required: true,
 8:   },
 9:   url: {
10:     type: String,
11:     required: true,
12:   },
13:   multiple: {
14:     type: Boolean,
15:     default: false,
16:   },
17:   accept: {
18:     type: String,
19:     default: '',
20:   },
21:   maxFileSize: {
22:     type: Number,
23:     default: 1000000,
24:   },
25: })
26: 
27: const onAdvancedUpload = () => {
28:   toast.success({ summary: 'File Uploaded', message: `${props.name} files uploaded` })
29: }
30: </script>
31: 
32: <template>
33:   <PrimeCard>
34:     <template #content>
35:       <PrimeFileUpload
36:         :name="name"
37:         :multiple="multiple"
38:         :accept="accept"
39:         :url="url"
40:         :max-file-size="maxFileSize"
41:         @upload="onAdvancedUpload()"
42:       >
43:         <template #empty>
44:           <p>Drag and drop files to here to upload.</p>
45:         </template>
46:       </PrimeFileUpload>
47:     </template>
48:   </PrimeCard>
49: </template>
```

## File: layers/crud/composables/audit.ts
```typescript
  1: export enum AuditLogLevel {
  2:   INFO = 'INFO',
  3:   WARNING = 'WARNING',
  4:   ERROR = 'ERROR',
  5:   CRITICAL = 'CRITICAL',
  6: }
  7: 
  8: export interface AuditLogEntry {
  9:   userId: string
 10:   action: string
 11:   details: any
 12:   level: AuditLogLevel
 13:   timestamp: string
 14:   ipAddress?: string
 15:   userAgent?: string
 16:   resourceId?: string
 17:   resourceType?: string
 18: }
 19: 
 20: interface AuditLogOptions {
 21:   level?: AuditLogLevel
 22:   resourceId?: string
 23:   resourceType?: string
 24:   skipDB?: boolean
 25: }
 26: 
 27: export function useAuditLog() {
 28:   const supabase = useSupabaseClient()
 29:   const user = useSupabaseUser()
 30:   const config = useRuntimeConfig()
 31: 
 32:   const logEvent = async (action: string, details: any, options: AuditLogOptions = {}) => {
 33:     const userId = user.value?.id || 'anonymous'
 34:     const timestamp = new Date().toISOString()
 35:     const level = options.level || AuditLogLevel.INFO
 36: 
 37:     const logEntry: AuditLogEntry = {
 38:       userId,
 39:       action,
 40:       details,
 41:       level,
 42:       timestamp,
 43:       ipAddress: useRequestHeaders(['x-forwarded-for'])['x-forwarded-for'] || '',
 44:       userAgent: useRequestHeaders(['user-agent'])['user-agent'] || '',
 45:       resourceId: options.resourceId,
 46:       resourceType: options.resourceType,
 47:     }
 48: 
 49:     // Remove any sensitive information from the log entry
 50:     sanitizeLogEntry(logEntry)
 51: 
 52:     // Log to console in development
 53:     if (import.meta.dev) {
 54:       console.log('Audit Log:', logEntry)
 55:     }
 56: 
 57:     if (!options.skipDB) {
 58:       try {
 59:         const { error } = await supabase.from('audit_logs').insert(logEntry)
 60: 
 61:         if (error) {
 62:           console.error('Error logging audit event to database:', error)
 63:         }
 64:       } catch (error) {
 65:         console.error('Error logging audit event to database:', error)
 66:       }
 67:     }
 68: 
 69:     // If configured, send logs to an external service
 70:     if (config.public.EXTERNAL_LOGGING_SERVICE) {
 71:       try {
 72:         await $fetch(config.public.EXTERNAL_LOGGING_SERVICE, {
 73:           method: 'POST',
 74:           body: JSON.stringify(logEntry),
 75:         })
 76:       } catch (error) {
 77:         console.error('Error sending log to external service:', error)
 78:       }
 79:     }
 80:   }
 81: 
 82:   const sanitizeLogEntry = (logEntry: AuditLogEntry) => {
 83:     // Remove sensitive information like passwords, tokens, etc.
 84:     if (logEntry.details && typeof logEntry.details === 'object') {
 85:       const sensitiveFields = ['password', 'token', 'secret', 'credit_card']
 86:       for (const field of sensitiveFields) {
 87:         if (field in logEntry.details) {
 88:           logEntry.details[field] = '[REDACTED]'
 89:         }
 90:       }
 91:     }
 92:   }
 93: 
 94:   const getAuditLogs = async (
 95:     filters: Partial<AuditLogEntry>,
 96:     pagination: { page: number, pageSize: number },
 97:   ) => {
 98:     let query = supabase.from('audit_logs').select('*')
 99: 
100:     // Apply filters
101:     Object.entries(filters).forEach(([key, value]) => {
102:       if (value !== undefined) {
103:         query = query.eq(key, value)
104:       }
105:     })
106: 
107:     // Apply pagination
108:     const { data, error, count } = await query
109:       .range(pagination.page * pagination.pageSize, (pagination.page + 1) * pagination.pageSize - 1)
110:       .order('timestamp', { ascending: false })
111: 
112:     if (error) {
113:       console.error('Error fetching audit logs:', error)
114:       throw error
115:     }
116: 
117:     return { logs: data, totalCount: count }
118:   }
119: 
120:   return {
121:     logEvent,
122:     getAuditLogs,
123:     AuditLogLevel,
124:   }
125: }
```

## File: layers/crud/composables/delete.ts
```typescript
 1: import { useErrorHandler, AppError, ErrorSeverity, ErrorType, useLogger } from '@ib/logger'
 2: import { useRateLimit } from './rate-limit'
 3: import { useHttpHandler } from './http-handler'
 4: import { getOrCreateStore } from './main.store'
 5: 
 6: export function useDeleteData<T extends { id: string | number }>(
 7:   tableName: string,
 8:   options: {
 9:     validateDelete?: (id: string | number) => boolean | Promise<boolean>
10:     refreshRelated?: () => Promise<void>
11:     rateLimitMs?: number
12:     auditLog?: (action: string, details: any) => Promise<void>
13:   } = {},
14: ) {
15:   const { remove } = useHttpHandler()
16:   const { handleError } = useErrorHandler()
17:   const logger = useLogger('useDeleteData')
18:   const store = getOrCreateStore<T>(tableName)()
19:   const { checkRateLimit } = useRateLimit()
20:   const isDeleting: Ref<boolean> = ref(false)
21:   let lastDeleteTime = 0
22: 
23:   const deleteData = async (id: string | number | (string | number)[]) => {
24:     isDeleting.value = true
25:     const startTime = Date.now()
26: 
27:     const deleteSingle = async (itemId: string | number): Promise<void> => {
28:       try {
29:         // Rate limiting
30:         if (options.rateLimitMs) {
31:           await checkRateLimit('useDeleteData', { limitMs: options.rateLimitMs })
32:         }
33: 
34:         // Validation
35:         if (options.validateDelete && !(await options.validateDelete(itemId))) {
36:           throw new AppError({
37:             type: ErrorType.VALIDATION_ERROR,
38:             message: 'Delete validation failed',
39:             severity: ErrorSeverity.MEDIUM,
40:             context: 'Data Validation',
41:           })
42:         }
43: 
44:         // Optimistic delete
45:         store.removeItem(itemId)
46: 
47:         // Perform the delete
48:         await remove(tableName, itemId)
49: 
50:         // Refresh related data if needed
51:         if (options.refreshRelated) {
52:           await options.refreshRelated()
53:         }
54: 
55:         // Audit logging
56:         if (options.auditLog) {
57:           await options.auditLog('DELETE', { tableName, id: itemId })
58:         }
59: 
60:         lastDeleteTime = Date.now()
61:       } catch (error: any) {
62:         // Revert optimistic delete
63:         const oldItem = store.getItemById(itemId)
64:         if (oldItem) {
65:           store.addItems([oldItem])
66:         }
67:         throw error
68:       }
69:     }
70: 
71:     try {
72:       if (Array.isArray(id)) {
73:         await Promise.all(id.map(deleteSingle))
74:       } else {
75:         await deleteSingle(id)
76:       }
77:     } catch (error: any) {
78:       handleError(error, 'Error deleting data')
79:       throw error
80:     } finally {
81:       isDeleting.value = false
82:     }
83:   }
84: 
85:   return {
86:     deleteData,
87:     isDeleting,
88:   }
89: }
```

## File: layers/crud/composables/fetch.ts
```typescript
  1: import { useLogger } from '@ib/logger'
  2: import type { FilterBy, DBTable } from '../server/utils/base.interface'
  3: import type { DomainKey } from './pagination.store'
  4: import { useCookie, useRequestHeaders } from '#imports'
  5: import type { FetchResult } from '#app'
  6: 
  7: export interface FetchInput {
  8:   domainKey: DomainKey
  9:   endpoint: string
 10:   pagination?: {
 11:     page: number
 12:     limit: number
 13:   }
 14:   criteria: {
 15:     dto: string
 16:     filterBy?: FilterBy<DBTable>
 17:   }
 18: }
 19: 
 20: function getDataStructure(obj: any): any {
 21:   if (Array.isArray(obj)) {
 22:     return obj.length > 0 ? [getDataStructure(obj[0])] : []
 23:   } else if (typeof obj === 'object' && obj !== null) {
 24:     const structure: Record<string, any> = {}
 25:     for (const key in obj) {
 26:       structure[key] = getDataStructure(obj[key])
 27:     }
 28:     return structure
 29:   } else {
 30:     return typeof obj
 31:   }
 32: }
 33: 
 34: export function useBaseFetch() {
 35:   const errors = useBaseError()
 36:   const paginationStore = usePaginationStore()
 37:   const loading = useLoadingStore()
 38:   const logger = useLogger('useBaseFetch')
 39:   const apiDataStore = useApiDataStore()
 40: 
 41:   const fetch = $fetch.create({
 42:     retryStatusCodes: [408, 409, 425, 500, 502, 503, 504],
 43:     headers: {
 44:       'X-USER-ID': useCookie('userId').value ?? 'no-user-id',
 45:       'cookie': useRequestHeaders(['cookie']).cookie ?? '',
 46:     },
 47:     onResponseError({ error, response, request, options }) {
 48:       console.error('onResponseError', response, response._data, error)
 49:     },
 50:     async onResponse({ request, response, options }) {
 51:       const url = request.toString()
 52:       const structure = getDataStructure(response._data)
 53:       console.log('Captured data structure for:', url, structure)
 54:       apiDataStore.setData(url, structure)
 55:     },
 56:   })
 57: 
 58:   async function fetchPaginatedData(params: FetchInput) {
 59:     const { domainKey, endpoint, criteria } = params
 60: 
 61:     if (loading.isLoading(domainKey)) {
 62:       return null
 63:     }
 64: 
 65:     if (paginationStore.isDataFinished(domainKey)) {
 66:       return null
 67:     }
 68: 
 69:     if (!paginationStore.getPagination(domainKey)) {
 70:       return null
 71:     }
 72: 
 73:     loading.setLoading(domainKey, true)
 74: 
 75:     try {
 76:       logger.info('fetchPaginatedData for', domainKey, endpoint, criteria)
 77:       const response = await fetch(endpoint, {
 78:         method: 'POST',
 79:         params: {
 80:           ...criteria,
 81:           pagination: paginationStore.getPaginationRange(domainKey),
 82:         },
 83:       })
 84: 
 85:       console.log('fetchPaginatedData RESPONSE', response)
 86: 
 87:       const data = errors.server({
 88:         response,
 89:         devOnly: false,
 90:         userMessage: `Sorry there was an error getting ${domainKey} from ${endpoint}`,
 91:         devMessage: `fetchPaginatedData errored selecting paginated ${domainKey} data from ${endpoint}`,
 92:       })
 93: 
 94:       if (!data || !data.length || data.length < paginationStore.getPagination(domainKey)!.limit) {
 95:         paginationStore.setDataFinished(domainKey)
 96:       }
 97: 
 98:       await loading.setLoadingInterval(domainKey, false, 1500)
 99:       paginationStore.incrementPagination(domainKey)
100: 
101:       return data
102:     } catch (error) {
103:       errors.client({
104:         error,
105:         devOnly: false,
106:         userMessage: `Sorry there was an error getting ${domainKey} from ${endpoint}`,
107:         devMessage: `fetchPaginatedData error for ${domainKey}`,
108:       })
109:     }
110:   }
111: 
112:   return {
113:     fetchPaginatedData,
114:     fetch,
115:   }
116: }
```

## File: layers/crud/composables/http-handler.ts
```typescript
  1: import type { PostgrestResponse, PostgrestError } from '@supabase/supabase-js'
  2: import {
  3:   useErrorHandler,
  4:   ErrorType,
  5:   useLogger,
  6:   ErrorSeverity,
  7:   AppError,
  8:   mapErrorSeverity,
  9:   mapErrorType,
 10:   retryableStatusCodes,
 11: } from '@ib/logger'
 12: import { getOrCreateStore } from './main.store'
 13: import { usePaginationStore, type PaginationType } from './pagination.store'
 14: 
 15: type FilterOperator =
 16:   | 'eq'
 17:   | 'neq'
 18:   | 'gt'
 19:   | 'gte'
 20:   | 'lt'
 21:   | 'lte'
 22:   | 'like'
 23:   | 'ilike'
 24:   | 'is'
 25:   | 'in'
 26:   | 'contains'
 27:   | 'containedBy'
 28:   | 'overlaps'
 29:   | 'textSearch'
 30:   | 'match'
 31:   | 'not'
 32:   | 'or'
 33:   | 'and'
 34:   | 'rangeGt'
 35:   | 'rangeGte'
 36:   | 'rangeLt'
 37:   | 'rangeLte'
 38:   | 'rangeAdjacent'
 39: 
 40: type FilterOptionValue = string | number | boolean | null | any[] | Record<string, unknown>
 41: 
 42: type FilterOption = {
 43:   [K in FilterOperator]?: K extends 'not'
 44:     ? FilterOption
 45:     : K extends 'or' | 'and'
 46:       ? string
 47:       : FilterOptionValue
 48: }
 49: 
 50: type Filters = Record<string, FilterOption>
 51: 
 52: interface SelectOptions<T> {
 53:   columns?: keyof T | Array<keyof T> | string
 54:   filters?: Filters
 55:   range?: { from: number; to: number }
 56:   order?: { column: keyof T; ascending: boolean }
 57: }
 58: 
 59: function applyFilter(query: any, column: string, filter: FilterOption): any {
 60:   const [operator, value] = Object.entries(filter)[0]
 61:   switch (operator) {
 62:     case 'eq':
 63:       return query.eq(column, value)
 64:     case 'neq':
 65:       return query.neq(column, value)
 66:     case 'gt':
 67:       return query.gt(column, value)
 68:     case 'gte':
 69:       return query.gte(column, value)
 70:     case 'lt':
 71:       return query.lt(column, value)
 72:     case 'lte':
 73:       return query.lte(column, value)
 74:     case 'like':
 75:       return query.like(column, value)
 76:     case 'ilike':
 77:       return query.ilike(column, value)
 78:     case 'is':
 79:       return query.is(column, value)
 80:     case 'in':
 81:       return query.in(column, value as any[])
 82:     case 'contains':
 83:       return query.contains(column, value)
 84:     case 'containedBy':
 85:       return query.containedBy(column, value)
 86:     case 'rangeGt':
 87:       return query.rangeGt(column, value)
 88:     case 'rangeGte':
 89:       return query.rangeGte(column, value)
 90:     case 'rangeLt':
 91:       return query.rangeLt(column, value)
 92:     case 'rangeLte':
 93:       return query.rangeLte(column, value)
 94:     case 'rangeAdjacent':
 95:       return query.rangeAdjacent(column, value)
 96:     case 'overlaps':
 97:       return query.overlaps(column, value)
 98:     case 'textSearch':
 99:       return query.textSearch(column, value as string, { config: 'english' })
100:     case 'match':
101:       return query.match(column, value as Record<string, unknown>)
102:     case 'not':
103:       return applyFilter(query.not(), column, value as FilterOption)
104:     case 'or':
105:       return query.or(value as string)
106:     case 'and':
107:       return query.and(value as string)
108:     default:
109:       console.warn(`Unsupported filter operator: ${operator}`)
110:       return query
111:   }
112: }
113: 
114: export function useHttpHandler() {
115:   const supabase = useSupabaseClient()
116:   const { handleError } = useErrorHandler()
117:   const logger = useLogger('HttpHandler')
118: 
119:   async function handleDatabaseOperation<T>(
120:     operation: () => Promise<PostgrestResponse<T>>,
121:     context: string,
122:     maxRetries: number = 3,
123:   ): Promise<T> {
124:     let retries = 0
125:     while (retries < maxRetries) {
126:       try {
127:         const response = await operation()
128:         // logger.debug(`${context} response:`, response)
129: 
130:         if (response.error) {
131:           throw response.error
132:         }
133:         return response.data as T
134:       } catch (error: unknown) {
135:         retries++
136:         logger.warn(`${context} failed. Attempt ${retries} of ${maxRetries}`)
137: 
138:         const pgError = error as PostgrestError
139:         const errorType = mapErrorType(pgError)
140:         const errorSeverity = mapErrorSeverity(pgError)
141: 
142:         if (
143:           retries >= maxRetries ||
144:           !Object.keys(retryableStatusCodes).includes(pgError.code?.toString() || '')
145:         ) {
146:           const appError = new AppError({
147:             type: errorType,
148:             message:
149:               pgError.message ||
150:               retryableStatusCodes[pgError.code as keyof typeof retryableStatusCodes] ||
151:               'Database operation failed',
152:             severity: errorSeverity,
153:             code: pgError.code,
154:             context: context,
155:             pgError: pgError.details || pgError.hint || pgError.message,
156:             operation: context,
157:           })
158:           throw handleError(appError)
159:         }
160: 
161:         // Exponential backoff with jitter
162:         const backoffTime = Math.min(1000 * 2 ** retries + Math.random() * 1000, 10000)
163:         await new Promise((resolve) => setTimeout(resolve, backoffTime))
164:       }
165:     }
166:     throw new Error('Max retries reached')
167:   }
168: 
169:   async function insert<T>(
170:     tableName: string,
171:     data: T,
172:     options: { columns?: string } = {},
173:   ): Promise<T> {
174:     return handleDatabaseOperation(
175:       async () =>
176:         await supabase
177:           .from(tableName)
178:           .insert(data)
179:           .select(options.columns || '*'),
180:       `Insert into ${tableName}`,
181:     )
182:   }
183: 
184:   async function update<T>(
185:     tableName: string,
186:     id: string | number,
187:     data: Partial<T>,
188:     options: { columns?: string } = {},
189:   ): Promise<T> {
190:     return handleDatabaseOperation(
191:       async () =>
192:         await supabase
193:           .from(tableName)
194:           .update(data)
195:           .eq('id', id)
196:           .select(options.columns || '*'),
197:       `Update ${tableName}`,
198:     )
199:   }
200: 
201:   async function remove(tableName: string, id: string | number): Promise<void> {
202:     await handleDatabaseOperation(
203:       async () => await supabase.from(tableName).delete().eq('id', id),
204:       `Delete from ${tableName}`,
205:     )
206:   }
207: 
208:   async function select<T>(tableName: string, options: SelectOptions<T> = {}): Promise<T[]> {
209:     let query = supabase.from(tableName).select(options.columns || '*')
210: 
211:     if (options.filters) {
212:       Object.entries(options.filters).forEach(([column, filterOption]) => {
213:         query = applyFilter(query, column, filterOption)
214:       })
215:     }
216: 
217:     if (options.range) {
218:       query = query.range(options.range.from, options.range.to)
219:     }
220: 
221:     if (options.order) {
222:       query = query.order(options.order.column, { ascending: options.order.ascending })
223:     }
224: 
225:     return handleDatabaseOperation(() => query, `Select from ${tableName}`)
226:   }
227: 
228:   return {
229:     insert,
230:     update,
231:     remove,
232:     select,
233:   }
234: }
```

## File: layers/crud/composables/insert.ts
```typescript
  1: import { useErrorHandler, AppError, ErrorType, ErrorSeverity, useLogger } from '@ib/logger'
  2: import { useHttpHandler } from './http-handler'
  3: import { getOrCreateStore } from './main.store'
  4: import { useRateLimit } from './rate-limit'
  5: 
  6: type InsertError =
  7:   | 'VALIDATION_ERROR'
  8:   | 'NETWORK_ERROR'
  9:   | 'SERVER_ERROR'
 10:   | 'RATE_LIMIT_ERROR'
 11:   | 'DUPLICATE_ERROR'
 12: 
 13: export function useInsertData<T extends { id: string | number }>(
 14:   tableName: string,
 15:   options: {
 16:     columns?: string
 17:     validateData?: (data: T) => boolean | Promise<boolean>
 18:     maxRetries?: number
 19:     refreshRelated?: () => Promise<void>
 20:     transformData?: (data: T) => T
 21:     onError?: (error: InsertError, details: any) => void
 22:     rateLimitMs?: number
 23:     auditLog?: (action: string, details: any) => Promise<void>
 24:     generateClientId?: () => string | number
 25:   } = {},
 26: ) {
 27:   const supabase = useSupabaseClient()
 28:   const { insert } = useHttpHandler()
 29:   const { handleError } = useErrorHandler()
 30:   const log = useLogger('useInsertData')
 31:   const store = getOrCreateStore<T>(tableName)()
 32:   const { checkRateLimit } = useRateLimit()
 33:   const isInserting: Ref<boolean> = ref(false)
 34:   let lastInsertTime = 0
 35: 
 36:   const insertData = async (data: T | T[]) => {
 37:     isInserting.value = true
 38:     const startTime = Date.now()
 39: 
 40:     const insertSingle = async (item: T): Promise<T> => {
 41:       try {
 42:         // Rate limiting
 43:         if (options.rateLimitMs) {
 44:           await checkRateLimit('useInsertData', { limitMs: options.rateLimitMs })
 45:         }
 46: 
 47:         // Validation
 48:         if (options.validateData && !(await options.validateData(item))) {
 49:           throw new AppError({
 50:             type: ErrorType.VALIDATION_ERROR,
 51:             message: 'Data validation failed',
 52:             severity: ErrorSeverity.MEDIUM,
 53:             context: 'Data Validation',
 54:           })
 55:         }
 56: 
 57:         // Data transformation
 58:         const transformedData = options.transformData ? options.transformData(item) : item
 59: 
 60:         // Generate client-side ID if needed
 61:         if (options.generateClientId && !transformedData.id) {
 62:           transformedData.id = options.generateClientId()
 63:         }
 64: 
 65:         // Optimistic insert
 66:         store.addItems([transformedData])
 67: 
 68:         // Perform the insert
 69:         const result = await insert(tableName, transformedData, { columns: options.columns })
 70: 
 71:         // Update store with actual server data
 72:         store.updateItem(result)
 73: 
 74:         // Refresh related data if needed
 75:         if (options.refreshRelated) {
 76:           await options.refreshRelated()
 77:         }
 78: 
 79:         // Audit logging
 80:         if (options.auditLog) {
 81:           await options.auditLog('INSERT', { tableName, newData: result })
 82:         }
 83: 
 84:         lastInsertTime = Date.now()
 85:         return result
 86:       } catch (error: any) {
 87:         // Revert optimistic insert
 88:         store.removeItem(item.id)
 89:         throw error // error handler in the HTTP handler deals with this
 90:       }
 91:     }
 92: 
 93:     try {
 94:       if (Array.isArray(data)) {
 95:         const results = await Promise.all(data.map(insertSingle))
 96:         isInserting.value = false
 97:         return results
 98:       } else {
 99:         const result = await insertSingle(data)
100:         isInserting.value = false
101:         return result
102:       }
103:     } catch (error: any) {
104:       handleError(error, 'Error inserting data')
105:       throw error // Re-throw to allow caller to handle if needed
106:     } finally {
107:       isInserting.value = false
108:     }
109:   }
110: 
111:   return {
112:     insertData,
113:     isInserting,
114:   }
115: }
```

## File: layers/crud/composables/loading.store.ts
```typescript
 1: import type { DomainKey } from './pagination.store'
 2: 
 3: type Loaders = {
 4:   [K in DomainKey]?: boolean
 5: }
 6: 
 7: export const useLoadingStore = defineStore('storeLoading', () => {
 8:   const loaders = ref({} as Loaders)
 9: 
10:   function setLoading(key: DomainKey, isLoading: boolean) {
11:     loaders.value[key] = isLoading
12:   }
13: 
14:   async function setLoadingInterval(key: DomainKey, isLoading: boolean, time: number) {
15:     await new Promise<void>((resolve) => {
16:       setTimeout(() => {
17:         setLoading(key, isLoading)
18:         resolve()
19:       }, time)
20:     })
21:   }
22: 
23:   function isLoading(key: DomainKey) {
24:     return !!loaders.value[key]
25:   }
26: 
27:   return {
28:     setLoadingInterval,
29:     setLoading,
30:     isLoading,
31:   }
32: })
33: 
34: if (import.meta.hot) {
35:   import.meta.hot.accept(acceptHMRUpdate(useLoadingStore, import.meta.hot))
36: }
```

## File: layers/crud/composables/local-storage.ts
```typescript
 1: import { useLogger } from '@ib/logger'
 2: 
 3: const CACHE_DURATION = 24 * 60 * 60 * 1000 // 24 hours in milliseconds
 4: const CACHE_VERSION = '1.0' // Increment this when data structure changes
 5: 
 6: const LocalStorageEnum = {
 7:   CATEGORIES: 'astronera-categories',
 8:   TAGS: 'astronera-tags',
 9: } as const
10: 
11: type LocalStorageKey = (typeof LocalStorageEnum)[keyof typeof LocalStorageEnum]
12: 
13: interface CachedData<T> {
14:   version: string
15:   timestamp: number
16:   data: T
17: }
18: 
19: export function useBaseLocalStorage() {
20:   const logger = useLogger('localStorage')
21: 
22:   function getCacheKey(key: LocalStorageKey): string {
23:     return `${key}-${CACHE_VERSION}`
24:   }
25: 
26:   function clearCache(key: LocalStorageKey): void {
27:     localStorage.removeItem(getCacheKey(key))
28:     logger.debug(`Cleared cache for: ${key}`)
29:   }
30: 
31:   function clearAllCaches(): void {
32:     Object.values(LocalStorageEnum).forEach(clearCache)
33:     logger.debug('Cleared all caches')
34:   }
35: 
36:   function getFromCache<T>(key: LocalStorageKey): T | null {
37:     const cacheKey = getCacheKey(key)
38:     const cachedItem = localStorage.getItem(cacheKey)
39: 
40:     if (!cachedItem) {
41:       logger.debug(`No cached data found for: ${key}`)
42:       return null
43:     }
44: 
45:     try {
46:       const parsedData = JSON.parse(cachedItem) as CachedData<T>
47:       const currentTime = Date.now()
48: 
49:       if (
50:         currentTime - parsedData.timestamp <= CACHE_DURATION &&
51:         parsedData.version === CACHE_VERSION
52:       ) {
53:         logger.debug(`Retrieved valid cached data for: ${key}`)
54:         return parsedData.data
55:       } else {
56:         logger.debug(`Cached data for ${key} is outdated or version mismatch`)
57:         clearCache(key)
58:         return null
59:       }
60:     } catch (error) {
61:       logger.error(`Error parsing cached data for ${key}:`, error)
62:       clearCache(key)
63:       return null
64:     }
65:   }
66: 
67:   function setCache<T>(key: LocalStorageKey, data: T): void {
68:     const cacheKey = getCacheKey(key)
69:     const cacheData: CachedData<T> = {
70:       version: CACHE_VERSION,
71:       timestamp: Date.now(),
72:       data,
73:     }
74:     localStorage.setItem(cacheKey, JSON.stringify(cacheData))
75:     logger.debug(`Cached data for: ${key}`)
76:   }
77: 
78:   async function getCachedOrFetch<T>(key: LocalStorageKey, fetchFn: () => Promise<T>): Promise<T> {
79:     const cachedData = getFromCache<T>(key)
80:     if (cachedData) return cachedData
81: 
82:     try {
83:       const fetchedData = await fetchFn()
84:       setCache(key, fetchedData)
85:       return fetchedData
86:     } catch (error) {
87:       logger.error(`Error fetching data for ${key}:`, error)
88:       throw error
89:     }
90:   }
91: 
92:   return {
93:     getFromCache,
94:     setCache,
95:     clearCache,
96:     clearAllCaches,
97:     getCachedOrFetch,
98:   }
99: }
```

## File: layers/crud/composables/main.store.ts
```typescript
 1: import { defineStore } from 'pinia'
 2: import { type Ref, ref } from 'vue'
 3: import type { DomainKey } from './pagination.store'
 4: 
 5: export function createBaseStore<T extends object>(domainKey: DomainKey) {
 6:   return defineStore(`${domainKey}Store`, () => {
 7:     const items = ref<T[]>([]) as Ref<T[]>
 8:     const itemsMap = computed(() => new Map(items.value.map((item) => [item.id, item])))
 9: 
10:     function setItems(newItems: T[]) {
11:       items.value = newItems
12:     }
13: 
14:     function addItems(newItems: T[]) {
15:       const newItemsMap = new Map(newItems.map((item) => [item.id, item]))
16:       items.value = [...items.value.filter((item) => !newItemsMap.has(item.id)), ...newItems]
17:     }
18: 
19:     function updateItem(updatedItem: T) {
20:       const index = items.value.findIndex((item) => item.id === updatedItem.id)
21:       if (index !== -1) {
22:         items.value[index] = { ...items.value[index], ...updatedItem }
23:       } else {
24:         items.value.push(updatedItem)
25:       }
26:     }
27: 
28:     function removeItem(id: string | number) {
29:       items.value = items.value.filter((item) => item.id !== id)
30:     }
31: 
32:     function clearItems() {
33:       items.value = []
34:     }
35: 
36:     function getItemById(id: string | number) {
37:       return itemsMap.value.get(id)
38:     }
39: 
40:     return {
41:       items,
42:       itemsMap,
43:       setItems,
44:       addItems,
45:       updateItem,
46:       removeItem,
47:       clearItems,
48:       getItemById,
49:     }
50:   })
51: }
52: 
53: const storeCache: Partial<Record<DomainKey, ReturnType<typeof createBaseStore>>> = {}
54: 
55: export function getOrCreateStore<T>(domainKey: DomainKey) {
56:   if (!storeCache[domainKey]) {
57:     storeCache[domainKey] = createBaseStore<T>(domainKey)
58:   }
59:   return storeCache[domainKey] as ReturnType<typeof createBaseStore<T>>
60: }
```

## File: layers/crud/composables/notification.ts
```typescript
 1: import type { useToast } from 'primevue/usetoast'
 2: 
 3: interface BaseNotification {
 4:   summary: string
 5:   message: string
 6: }
 7: 
 8: export function useNotification() {
 9:   const nuxtApp = useNuxtApp()
10:   const getToast: typeof useToast = () => nuxtApp.vueApp.config.globalProperties.$toast
11:   const toast = getToast()
12: 
13:   const success = ({ summary, message }: BaseNotification) => {
14:     toast.add({
15:       severity: 'success',
16:       summary: `Success: ${summary}`,
17:       detail: message,
18:       life: 5000,
19:       closable: true,
20:     })
21:   }
22: 
23:   const error = ({ summary, message }: BaseNotification) => {
24:     toast.add({
25:       severity: 'error',
26:       summary: `Error: ${summary}`,
27:       detail: message,
28:       life: 0,
29:       closable: true,
30:     })
31:   }
32: 
33:   const info = ({ summary, message }: BaseNotification) => {
34:     toast.add({
35:       severity: 'info',
36:       summary: `Info: ${summary}`,
37:       detail: message,
38:       life: 5000,
39:       closable: true,
40:     })
41:   }
42: 
43:   const warn = ({ summary, message }: BaseNotification) => {
44:     toast.add({
45:       severity: 'warn',
46:       summary: `Warning: ${summary}`,
47:       detail: message,
48:       life: 5000,
49:       closable: true,
50:     })
51:   }
52: 
53:   const feature = ({ summary, message }: BaseNotification) => {
54:     toast.add({
55:       severity: 'warn',
56:       group: 'cta',
57:       summary: summary,
58:       detail: message,
59:       life: 0,
60:       closable: true,
61:     })
62:   }
63: 
64:   return {
65:     success,
66:     error,
67:     info,
68:     warn,
69:     feature,
70:   }
71: }
```

## File: layers/crud/composables/pagination.store.ts
```typescript
 1: import { useLogger } from '@ib/logger'
 2: 
 3: export type DomainKey =
 4:   | 'users'
 5:   | 'news'
 6:   | 'events'
 7:   | 'venues'
 8:   | 'research'
 9:   | 'companies'
10:   | 'chats'
11:   | 'feedbacks'
12:   | 'currentUser'
13:   | 'chat'
14:   | 'auth'
15: 
16: export type PaginationType = {
17:   page: number
18:   limit: number
19: }
20: 
21: export interface PaginationInput {
22:   domainKey: DomainKey
23:   pagination: PaginationType
24:   force?: boolean
25: }
26: 
27: export const usePaginationStore = defineStore('paginationStore', () => {
28:   const logger = useLogger('paginationStore')
29:   const stores = reactive({} as Record<DomainKey, Ref<{ page: number; limit: number }>>)
30:   const dataFinished = ref({} as Record<DomainKey, boolean>)
31: 
32:   function initPagination(input: PaginationInput) {
33:     if (!stores[input.domainKey] || input.force) {
34:       // -1 for supabase because it is 0 indexed
35:       console.log('initPagination', input.force)
36:       stores[input.domainKey] = {
37:         page: input.pagination.page,
38:         limit: input.pagination.limit - 1,
39:       }
40:     }
41:   }
42: 
43:   function getPagination(domainKey: DomainKey) {
44:     if (!stores[domainKey]) {
45:       logger.warn(`Pagination settings for '${domainKey}' is not initialized.`)
46:       return null
47:     }
48: 
49:     return stores[domainKey]
50:   }
51: 
52:   function getPaginationRange(domainKey: DomainKey) {
53:     const pagination = getPagination(domainKey)
54:     if (pagination) {
55:       logger.info('getPaginationRange', pagination.limit, (pagination.page - 1) * pagination.limit)
56:       return {
57:         from: (pagination.page - 1) * pagination.limit,
58:         to: pagination.limit * pagination.page,
59:       }
60:     }
61:     return undefined
62:   }
63: 
64:   function incrementPagination(domainKey: DomainKey) {
65:     const currentPagination = getPagination(domainKey)
66:     if (currentPagination) {
67:       currentPagination.page++
68:     } else {
69:       logger.warn(`Attempted to increment pagination for an uninitialized store '${domainKey}'.`)
70:     }
71:   }
72: 
73:   function setDataFinished(domainKey: DomainKey) {
74:     if (stores[domainKey]) {
75:       dataFinished.value[domainKey] = true
76:     }
77:   }
78: 
79:   const isDataFinished = (domainKey: DomainKey) => dataFinished.value[domainKey]
80: 
81:   return {
82:     stores,
83:     isDataFinished,
84:     setDataFinished,
85:     initPagination,
86:     getPagination,
87:     incrementPagination,
88:     getPaginationRange,
89:   }
90: })
```

## File: layers/crud/composables/rate-limit.ts
```typescript
 1: interface RateLimitOptions {
 2:   limitMs: number
 3: }
 4: 
 5: export function useRateLimit() {
 6:   const lastActionTimes = ref<Map<string, number>>(new Map())
 7: 
 8:   const checkRateLimit = async (action: string, options: RateLimitOptions): Promise<void> => {
 9:     const now = Date.now()
10:     const lastActionTime = lastActionTimes.value.get(action) || 0
11:     const timeElapsed = now - lastActionTime
12: 
13:     if (timeElapsed < options.limitMs) {
14:       const waitTime = options.limitMs - timeElapsed
15:       await new Promise((resolve) => setTimeout(resolve, waitTime))
16:     }
17: 
18:     lastActionTimes.value.set(action, Date.now())
19:   }
20: 
21:   return {
22:     checkRateLimit,
23:   }
24: }
```

## File: layers/crud/composables/select.ts
```typescript
  1: import { useErrorHandler, AppError, ErrorType, ErrorSeverity, useLogger } from '@ib/logger'
  2: import { useHttpHandler } from './http-handler'
  3: import { getOrCreateStore } from './main.store'
  4: import { usePaginationStore, type PaginationType } from './pagination.store'
  5: import { useRateLimit } from './rate-limit'
  6: 
  7: export function useSelectData<T extends { id: string | number }>(
  8:   tableName: string,
  9:   options: {
 10:     columns?: string
 11:     filters?: Record<string, any>
 12:     orderBy?: { column: string; ascending?: boolean }
 13:     initialFetch?: boolean
 14:     pagination?: PaginationType
 15:     limit?: number
 16:     refreshRelated?: () => Promise<void>
 17:     rateLimitMs?: number
 18:     auditLog?: (action: string, details: any) => Promise<void>
 19:   } = {},
 20: ) {
 21:   const { select } = useHttpHandler()
 22:   const { handleError } = useErrorHandler()
 23:   const logger = useLogger('useSelectData')
 24:   const store = getOrCreateStore<T>(tableName)()
 25:   const { checkRateLimit } = useRateLimit()
 26: 
 27:   const isSelecting: Ref<boolean> = ref(false)
 28:   let lastSelectTime = 0
 29: 
 30:   let paginationStore: ReturnType<typeof usePaginationStore> | null = null
 31: 
 32:   if (options.pagination) {
 33:     paginationStore = usePaginationStore()
 34:     paginationStore.initPagination({
 35:       domainKey: tableName,
 36:       pagination: options.pagination,
 37:       force: true,
 38:     })
 39:   }
 40: 
 41:   const fetchData = async (forceFetch = false) => {
 42:     isSelecting.value = true
 43:     const startTime = Date.now()
 44: 
 45:     try {
 46:       // Rate limiting
 47:       if (options.rateLimitMs && !forceFetch) {
 48:         await checkRateLimit('useSelectData', { limitMs: options.rateLimitMs })
 49:       }
 50: 
 51:       const queryOptions: any = {
 52:         columns: options.columns || '*',
 53:         filters: options.filters,
 54:       }
 55: 
 56:       if (options.orderBy) {
 57:         queryOptions.order = {
 58:           column: options.orderBy.column,
 59:           ascending: options.orderBy.ascending ?? true,
 60:         }
 61:       }
 62: 
 63:       if (paginationStore) {
 64:         const pagination = paginationStore.getPaginationRange(tableName)
 65:         if (pagination) {
 66:           console.log('pagination', pagination)
 67:           queryOptions.range = pagination
 68:         } else {
 69:           throw new AppError({
 70:             type: ErrorType.VALIDATION_ERROR,
 71:             message: `Pagination not initialized for ${tableName}`,
 72:             severity: ErrorSeverity.MEDIUM,
 73:             context: 'Data Fetching',
 74:           })
 75:         }
 76:       } else if (options.limit) {
 77:         queryOptions.range = { from: 0, to: options.limit - 1 }
 78:       }
 79: 
 80:       const result = await select<T>(tableName, queryOptions)
 81:       console.log('Fetch result:', result)
 82: 
 83:       // Audit logging
 84:       if (options.auditLog) {
 85:         await options.auditLog('SELECT', { tableName, options: queryOptions })
 86:       }
 87: 
 88:       lastSelectTime = Date.now()
 89:       return result
 90:     } catch (error: any) {
 91:       handleError(error, 'Error selecting data')
 92:       throw error
 93:     } finally {
 94:       isSelecting.value = false
 95:     }
 96:   }
 97: 
 98:   const loadMore = async () => {
 99:     if (paginationStore) {
100:       console.log('loading more data')
101:       const newData = await fetchData()
102:       if (newData.length === 0) {
103:         paginationStore.setDataFinished(tableName)
104:       } else {
105:         store.addItems(newData)
106:         paginationStore.incrementPagination(tableName)
107:       }
108:     } else {
109:       const data = await fetchData()
110:       store.setItems(data)
111:     }
112: 
113:     // Refresh related data if needed
114:     if (options.refreshRelated) {
115:       await options.refreshRelated()
116:     }
117:   }
118: 
119:   const refresh = async () => {
120:     if (paginationStore) {
121:       paginationStore.initPagination({
122:         domainKey: tableName,
123:         pagination: options.pagination!,
124:         force: true,
125:       })
126:     }
127:     store.clearItems()
128:     await loadMore()
129:   }
130: 
131:   if (options.initialFetch) {
132:     loadMore()
133:   }
134: 
135:   return {
136:     store,
137:     loadMore,
138:     refresh,
139:     isSelecting,
140:   }
141: }
```

## File: layers/crud/composables/settings.store.ts
```typescript
 1: type SettingsKey = 'usersStore' | 'storeNews'
 2: 
 3: export const useSettingsStore = defineStore('settingsStore', () => {
 4:   const settings = ref({} as Settings)
 5:   const summaryLevel = ref('beginner' as SummaryLevel)
 6: 
 7:   function toggleSettings(key: SettingsKey) {
 8:     settings.value[key] = !settings.value[key]
 9:   }
10: 
11:   function isSettingsOn(key: SettingsKey) {
12:     return !settings.value[key]
13:   }
14: 
15:   const changeSummaryLevel = (level: 'beginner' | 'intermediate' | 'expert') => {
16:     summaryLevel.value = level
17:   }
18: 
19:   return {
20:     toggleSettings,
21:     isSettingsOn,
22:   }
23: })
24: 
25: if (import.meta.hot) {
26:   import.meta.hot.accept(acceptHMRUpdate(useSettingsStore, import.meta.hot))
27: }
```

## File: layers/crud/composables/update.ts
```typescript
 1: import { useErrorHandler, AppError, ErrorSeverity, ErrorType, useLogger } from '@ib/logger'
 2: import { useHttpHandler } from './http-handler'
 3: import { getOrCreateStore } from './main.store'
 4: import { useRateLimit } from './rate-limit'
 5: 
 6: export function useUpdateData<T extends { id: string | number }>(
 7:   tableName: string,
 8:   options: {
 9:     columns?: string
10:     validateData?: (data: Partial<T>) => boolean | Promise<boolean>
11:     refreshRelated?: () => Promise<void>
12:     transformData?: (data: Partial<T>) => Partial<T>
13:     rateLimitMs?: number
14:     auditLog?: (action: string, details: any) => Promise<void>
15:   } = {},
16: ) {
17:   const { update } = useHttpHandler()
18:   const { handleError } = useErrorHandler()
19:   const logger = useLogger('useUpdateData')
20:   const store = getOrCreateStore<T>(tableName)()
21:   const { checkRateLimit } = useRateLimit()
22: 
23:   const isUpdating: Ref<boolean> = ref(false)
24:   let lastUpdateTime = 0
25: 
26:   const updateData = async (id: string | number, data: Partial<T>) => {
27:     isUpdating.value = true
28:     const startTime = Date.now()
29:     let oldData: T | undefined = undefined
30: 
31:     try {
32:       // Rate limiting
33:       if (options.rateLimitMs) {
34:         await checkRateLimit('useUpdateData', { limitMs: options.rateLimitMs })
35:       }
36: 
37:       // Validation
38:       if (options.validateData && !(await options.validateData(data))) {
39:         throw new AppError({
40:           type: ErrorType.VALIDATION_ERROR,
41:           message: 'Data validation failed',
42:           severity: ErrorSeverity.MEDIUM,
43:           context: 'Data Validation',
44:         })
45:       }
46: 
47:       // Data transformation
48:       const transformedData = options.transformData ? options.transformData(data) : data
49: 
50:       // Optimistic update
51:       oldData = store.getItemById(id)
52:       if (!oldData) {
53:         throw new AppError({
54:           type: ErrorType.NOT_FOUND_ERROR,
55:           message: 'Item not found in store',
56:           severity: ErrorSeverity.MEDIUM,
57:           context: 'Data Update',
58:         })
59:       }
60:       store.updateItem({ ...oldData, ...transformedData, id })
61: 
62:       // Perform the update
63:       const result = await update(tableName, id, transformedData, { columns: options.columns })
64: 
65:       // Update store with actual server data
66:       store.updateItem(result)
67: 
68:       // Refresh related data if needed
69:       if (options.refreshRelated) {
70:         await options.refreshRelated()
71:       }
72: 
73:       // Audit logging
74:       if (options.auditLog) {
75:         await options.auditLog('UPDATE', { tableName, id, oldData, newData: result })
76:       }
77: 
78:       lastUpdateTime = Date.now()
79:       return result
80:     } catch (error: any) {
81:       // Revert optimistic update
82:       if (oldData) {
83:         store.updateItem(oldData)
84:       }
85:       handleError(error, 'Error updating data')
86:       throw error
87:     } finally {
88:       isUpdating.value = false
89:     }
90:   }
91: 
92:   return {
93:     updateData,
94:     isUpdating,
95:   }
96: }
```

## File: layers/crud/composables/upload.ts
```typescript
  1: import { v4 as uuidv4 } from 'uuid'
  2: import { useErrorHandler, AppError, ErrorType, ErrorSeverity, useLogger } from '@ib/logger'
  3: import { useRateLimit } from './rate-limit'
  4: 
  5: type FileType = 'profile' | 'document' | 'image' | 'video' | 'audio' | 'other'
  6: 
  7: interface UploadOptions {
  8:   bucket: string
  9:   path: string
 10:   fileType: FileType
 11:   userId?: string
 12:   metadata?: Record<string, string>
 13:   optimizeImage?: boolean
 14:   maxWidth?: number
 15:   maxHeight?: number
 16:   quality?: number
 17:   format?: 'jpeg' | 'jpg' | 'png' | 'webp'
 18:   rateLimitMs?: number
 19:   auditLog?: (action: string, details: any) => Promise<void>
 20:   onProgress?: (progress: number) => void
 21:   maxFileSize?: number
 22:   allowedMimeTypes?: string[]
 23:   serverSideOptimize?: boolean
 24:   useServerUpload?: boolean
 25:   replace?: boolean
 26: }
 27: 
 28: interface UploadResult {
 29:   path: string
 30:   publicUrl: string
 31:   size: number
 32:   mimeType: string
 33:   metadata: Record<string, string>
 34: }
 35: 
 36: export function useFileUpload() {
 37:   const supabase = useSupabaseClient()
 38:   const { handleError } = useErrorHandler()
 39:   const { checkRateLimit } = useRateLimit()
 40:   const isUploading: Ref<boolean> = ref(false)
 41:   const uploadProgress: Ref<number> = ref(0)
 42:   const lastUploadTime = ref(0)
 43:   const uploadQueue: Ref<File[]> = ref([])
 44:   const currentUpload: Ref<File | null> = ref(null)
 45: 
 46:   const isProcessing = computed(() => uploadQueue.value.length > 0 || currentUpload.value !== null)
 47: 
 48:   const getFilePath = (fileName: string, options: UploadOptions): string => {
 49:     const { bucket, path, fileType, userId, replace } = options
 50:     const timestamp = new Date().toISOString().replace(/[-:]/g, '').split('.')[0]
 51:     const uniqueId = uuidv4().slice(0, 8)
 52:     const userPath = userId ? `${userId}/` : ''
 53:     return `${bucket}/${fileType}/${userPath}${path || ''}/${replace ? '' : `${timestamp}_${uniqueId}_`}${fileName}`
 54:   }
 55: 
 56:   const validateFile = (file: File, options: UploadOptions): void => {
 57:     if (options.maxFileSize && file.size > options.maxFileSize) {
 58:       throw new AppError({
 59:         type: ErrorType.VALIDATION_ERROR,
 60:         message: `File size exceeds the maximum allowed size of ${options.maxFileSize} bytes`,
 61:         severity: ErrorSeverity.MEDIUM,
 62:         context: 'File Upload',
 63:       })
 64:     }
 65: 
 66:     if (options.allowedMimeTypes && !options.allowedMimeTypes.includes(file.type)) {
 67:       throw new AppError({
 68:         type: ErrorType.VALIDATION_ERROR,
 69:         message: `File type ${file.type} is not allowed`,
 70:         severity: ErrorSeverity.MEDIUM,
 71:         context: 'File Upload',
 72:       })
 73:     }
 74:   }
 75: 
 76:   const serverSideUpload = async (file: File, options: UploadOptions): Promise<UploadResult> => {
 77:     const formData = new FormData()
 78:     formData.append('file', file)
 79:     formData.append('userId', options.userId || '')
 80:     formData.append('fileType', options.fileType)
 81:     formData.append('bucket', options.bucket)
 82:     formData.append('path', options.path)
 83:     formData.append(
 84:       'optimizationOptions',
 85:       JSON.stringify({
 86:         maxWidth: options.maxWidth,
 87:         maxHeight: options.maxHeight,
 88:         quality: options.quality,
 89:         format: options.format,
 90:       }),
 91:     )
 92: 
 93:     const response = await $fetch('/api/upload', {
 94:       method: 'POST',
 95:       body: formData,
 96:       onUploadProgress: (progressEvent) => {
 97:         if (progressEvent.total) {
 98:           const progress = Math.round((progressEvent.loaded * 100) / progressEvent.total)
 99:           uploadProgress.value = progress
100:           options.onProgress?.(progress)
101:         }
102:       },
103:     })
104: 
105:     if (!response || !response.fileName) {
106:       throw new Error('Failed to upload file on server')
107:     }
108: 
109:     const publicUrl = supabase.storage.from(options.bucket).getPublicUrl(response.fileName)
110:       .data.publicUrl
111: 
112:     return {
113:       path: response.fileName,
114:       publicUrl,
115:       size: file.size,
116:       mimeType: file.type,
117:       metadata: {
118:         originalName: file.name,
119:         ...options.metadata,
120:       },
121:     }
122:   }
123: 
124:   const uploadFile = async (file: File, options: UploadOptions): Promise<UploadResult> => {
125:     isUploading.value = true
126:     uploadProgress.value = 0
127:     currentUpload.value = file
128: 
129:     try {
130:       validateFile(file, options)
131: 
132:       // Rate limiting
133:       if (options.rateLimitMs) {
134:         await checkRateLimit('fileUpload', { limitMs: options.rateLimitMs })
135:       }
136: 
137:       let result: UploadResult
138: 
139:       if (options.useServerUpload) {
140:         result = await serverSideUpload(file, options)
141:       } else {
142:         const filePath = getFilePath(file.name, options)
143:         const { data, error } = await supabase.storage.from(options.bucket).upload(filePath, file, {
144:           cacheControl: '3600',
145:           upsert: options.replace,
146:           contentType: file.type,
147:         })
148: 
149:         if (error) {
150:           throw new AppError({
151:             type: ErrorType.UPLOAD_ERROR,
152:             message: `Error uploading file: ${error.message}`,
153:             severity: ErrorSeverity.HIGH,
154:             context: 'File Upload',
155:           })
156:         }
157: 
158:         const {
159:           data: { publicUrl },
160:         } = supabase.storage.from(options.bucket).getPublicUrl(data.path)
161: 
162:         result = {
163:           path: data.path,
164:           publicUrl,
165:           size: file.size,
166:           mimeType: file.type,
167:           metadata: {
168:             originalName: file.name,
169:             ...options.metadata,
170:           },
171:         }
172:       }
173: 
174:       lastUploadTime.value = Date.now()
175: 
176:       return result
177:     } catch (error: any) {
178:       handleError(error, 'Error uploading file')
179:       throw error
180:     } finally {
181:       isUploading.value = false
182:       uploadProgress.value = 100
183:       currentUpload.value = null
184:       processQueue()
185:     }
186:   }
187: 
188:   const processQueue = async () => {
189:     if (uploadQueue.value.length > 0 && !isUploading.value) {
190:       const nextFile = uploadQueue.value.shift()
191:       if (nextFile) {
192:         await uploadFile(nextFile, {
193:           bucket: 'default',
194:           path: 'uploads',
195:           fileType: 'other',
196:         })
197:       }
198:     }
199:   }
200: 
201:   const queueUpload = (file: File, options: UploadOptions) => {
202:     uploadQueue.value.push(file)
203:     processQueue()
204:   }
205: 
206:   const cancelUpload = () => {
207:     if (currentUpload.value) {
208:       // Implement cancellation logic here
209:       // This might involve aborting the Supabase upload if possible
210:       currentUpload.value = null
211:       isUploading.value = false
212:       uploadProgress.value = 0
213:     }
214:   }
215: 
216:   const clearQueue = () => {
217:     uploadQueue.value = []
218:   }
219: 
220:   return {
221:     uploadFile,
222:     queueUpload,
223:     cancelUpload,
224:     clearQueue,
225:     isUploading,
226:     isProcessing,
227:     uploadProgress,
228:     currentUpload,
229:     uploadQueue,
230:   }
231: }
```

## File: layers/crud/composables/useApiDataStore.ts
```typescript
 1: // stores/apiData.ts
 2: import { defineStore } from 'pinia'
 3: import { ref } from 'vue'
 4: 
 5: interface ApiDataStructure {
 6:   [key: string]: any
 7: }
 8: 
 9: export const useApiDataStore = defineStore('apiData', () => {
10:   const apiData = ref<ApiDataStructure>({})
11: 
12:   const setData = (url: string, data: any): void => {
13:     apiData.value[url] = data
14:   }
15: 
16:   const getData = (url: string): any => {
17:     return apiData.value[url]
18:   }
19: 
20:   const clearData = (): void => {
21:     apiData.value = {}
22:   }
23: 
24:   return {
25:     apiData,
26:     setData,
27:     getData,
28:     clearData,
29:   }
30: })
```

## File: layers/crud/composables/useBaseError.ts
```typescript
  1: import { useLogger } from '@ib/logger'
  2: 
  3: interface ErrorMessage {
  4:   userMessage: string // User-friendly error message if needed
  5:   devMessage: string // Make bugfixing easy!
  6:   error: any
  7: }
  8: 
  9: interface ErrorServer extends Omit<ErrorMessage, 'error'> {
 10:   devOnly: boolean // default true - don't show toasts in production
 11:   featureRelated?: boolean // default false - log to feature-specific log
 12:   response: { data: any; error: any }
 13: }
 14: 
 15: interface ErrorClient extends ErrorMessage {
 16:   isServer?: boolean // default false
 17:   featureRelated?: boolean // default false - log to feature-specific log
 18:   devOnly: boolean
 19: }
 20: 
 21: export function useBaseError() {
 22:   // !todo:med:easy - add prefix to base error
 23: 
 24:   // const toast = useNotification()
 25:   const logger = useLogger('useBaseError')
 26:   const isAdmin = useRuntimeConfig().public.nodeEnv === 'development'
 27: 
 28:   // function handleErrorWithCodes(error: any) {
 29:   //   switch (error.statusCode) {
 30:   //     case 429:
 31:   //       toast.feature({
 32:   //         summary: error.statusMessage,
 33:   //         message: error.message,
 34:   //       })
 35:   //       break
 36:   //     case 403:
 37:   //       toast.error({
 38:   //         summary: error.statusMessage,
 39:   //         message: error.message,
 40:   //       })
 41:   //       break
 42:   //     default:
 43:   //       console.error('Unhandled feature error:', error)
 44:   //   }
 45:   // }
 46: 
 47:   function formatErrorMessage({ userMessage, devMessage, error }: ErrorMessage) {
 48:     const devError = `${devMessage}: ${JSON.stringify(error)}`
 49:     logger.error(devError)
 50:     const userError = userMessage || 'An unexpected error occurred. Please try again later.'
 51:     return isAdmin ? devError : userError
 52:   }
 53: 
 54:   function handleError({
 55:     userMessage,
 56:     devMessage,
 57:     devOnly = true,
 58:     isServer = false,
 59:     error,
 60:   }: ErrorClient) {
 61:     // Determine the appropriate user message
 62:     const errorMessage = formatErrorMessage({ error, userMessage, devMessage })
 63: 
 64:     // Add an error toast notification with an option to retry if an action is provided
 65: 
 66:     // Handle critical errors specifically if needed
 67:     if (!devOnly || isAdmin) {
 68:       // toast.error({
 69:       //   summary: 'Error',
 70:       //   message: errorMessage,
 71:       // })
 72:       // Here you could navigate to an error page, log out the user, etc.
 73:       console.error('Handling critical error for:', devMessage)
 74:     }
 75: 
 76:     throw createError({
 77:       message: `${isServer ? 'SERVER' : 'CLIENT'} ERROR: ${errorMessage}`,
 78:     })
 79:   }
 80: 
 81:   function handleServerError({ response, devMessage, devOnly, userMessage }: ErrorServer) {
 82:     if (response.error) {
 83:       console.log('FeatError', response.error)
 84:       handleError({
 85:         error: response.error,
 86:         devOnly,
 87:         userMessage,
 88:         isServer: true,
 89:         devMessage,
 90:       })
 91:     } else if (response.data) {
 92:       logger.info(`Successfully fetched ${response.data.length} items`)
 93:       return response.data
 94:     }
 95:     logger.info('Nothing returned from database')
 96:     return null
 97:   }
 98: 
 99:   return {
100:     server: handleServerError,
101:     client: handleError,
102:   }
103: }
```

## File: layers/crud/composables/user.current.store.ts
```typescript
  1: import { useLogger } from '@ib/logger'
  2: 
  3: const DOMAIN_KEY = 'currentUser'
  4: 
  5: export const useCurrentUser = defineStore(DOMAIN_KEY, () => {
  6:   const authUrl = useRuntimeConfig().public.aeAuthUrl
  7:   const logger = useLogger(DOMAIN_KEY)
  8:   const errors = useBaseError()
  9:   const loading = useLoadingStore()
 10:   const { fetch } = useBaseFetch()
 11:   const userId = useCookie('userId')
 12:   const user = useSupabaseUser()
 13: 
 14:   // check:critical - user should only be able to fetch their own full profile
 15:   // check:critical - user should only be able to update their own profile
 16:   // todo:high - allow user to update their profile info
 17:   // todo:med - merge currentUser and profile into one, store all required data everything in their session
 18:   // assign Posthog identify
 19: 
 20:   console.log('user', user.value)
 21: 
 22:   const profile = computed(() => ({
 23:     id: user.value?.id,
 24:     given_name: user.value?.user_metadata?.given_name,
 25:     email_confirmed_at: user.value?.email_confirmed_at,
 26:     confirmation_sent_at: user.value?.confirmation_sent_at,
 27:     confirmed_at: user.value?.confirmed_at,
 28:     created_at: user.value?.created_at,
 29:     surname: user.value?.user_metadata?.surname,
 30:     last_sign_in_at: user.value?.last_sign_in_at,
 31:     email: user.value?.email,
 32:     providers: user.value?.app_metadata.providers,
 33:     avatar: user.value?.user_metadata.avatar ?? user.value?.user_metadata.avatar_url,
 34:     provider: user.value?.provider,
 35:     user_role: user.value?.app_metadata?.role,
 36:     user_plan: user.value?.app_metadata?.plan,
 37:   }))
 38: 
 39:   // extract as util func
 40:   function hasValueChanged(newValue: any, currentValue: any): boolean {
 41:     console.log('hasValueChanged', newValue, currentValue)
 42:     if (
 43:       typeof newValue === 'string' ||
 44:       typeof newValue === 'boolean' ||
 45:       typeof newValue === 'number'
 46:     ) {
 47:       return newValue !== currentValue
 48:     } else if (Array.isArray(newValue)) {
 49:       return JSON.stringify(newValue) !== JSON.stringify(currentValue)
 50:     } else if (typeof newValue === 'object' && newValue !== null) {
 51:       return JSON.stringify(newValue) !== JSON.stringify(currentValue)
 52:     } else {
 53:       return newValue !== currentValue
 54:     }
 55:   }
 56: 
 57:   function cleanDataForUpdate(newData: any, previousData: any) {
 58:     const updatedData: any = {}
 59:     for (const key in newData) {
 60:       if (
 61:         Object.hasOwnProperty.call(newData, key) &&
 62:         hasValueChanged(newData[key], previousData[key])
 63:       ) {
 64:         updatedData[key] = newData[key]
 65:       }
 66:     }
 67: 
 68:     return { data: updatedData, noDataUpdated: Object.keys(updatedData).length === 0 }
 69:   }
 70: 
 71:   async function updateProfile(newData: any, isMock: boolean = false) {
 72:     logger.info('Starting updateProfile function', { newData, isMock })
 73:     const updatedData: any = {}
 74: 
 75:     logger.debug('Cleaning data for update')
 76:     // Compare newData with fullProfile and only include changed values
 77:     const { noDataUpdated, data } = cleanDataForUpdate(newData, profile.value)
 78: 
 79:     if (noDataUpdated) {
 80:       logger.info('No changes detected, no update necessary')
 81:       return
 82:     }
 83: 
 84:     logger.debug('Changes detected', { changedData: data })
 85: 
 86:     try {
 87:       logger.info('Sending update request to server')
 88:       let response
 89:       if (isMock) {
 90:         logger.info('Using mock API call')
 91:         // response = await mockApiCall(data)
 92:       } else {
 93:         response = await $fetch('/api/users/update', {
 94:           method: 'POST',
 95:           body: JSON.stringify(data),
 96:         })
 97:       }
 98:       logger.debug('Received response from server', { response })
 99: 
100:       const validData = errors.server({
101:         response,
102:         devOnly: false,
103:         devMessage: 'Error updating user profile',
104:         userMessage: 'There was an error updating your profile after action',
105:       })
106: 
107:       logger.info('Successfully validated server response', { validData })
108: 
109:       // update state
110:       logger.debug('Updating user profile state')
111:       for (const key in validData[0]) {
112:         if (Object.hasOwnProperty.call(validData[0], key)) {
113:           logger.debug(`Updating profile field: ${key}`, {
114:             newValue: validData[0][key],
115:           })
116:         }
117:       }
118:       logger.info('Profile update completed successfully')
119:     } catch (error) {
120:       logger.error('Error occurred during profile update', { error })
121:       throw error // Re-throw the error for the caller to handle
122:     }
123:   }
124: 
125:   // Test function
126:   async function testUpdateProfile() {
127:     const testCases = [
128:       { name: 'John Doe', email: 'john@example.com' },
129:       { name: 'Jane Doe', email: 'error@example.com' }, // This will trigger an error
130:       {}, // This should result in no update
131:     ]
132: 
133:     for (const testCase of testCases) {
134:       try {
135:         console.log('Testing with data:', testCase)
136:         await updateProfile(testCase, true) // Use mock API
137:         console.log('Test passed successfully')
138:       } catch (error) {
139:         console.error('Test failed:', error.message)
140:       }
141:       console.log('---')
142:     }
143:   }
144: 
145:   type FileType = 'avatar'
146:   async function uploadImage(fileType: FileType, blob: Blob) {
147:     // currentFileName is the current file name in the database eg. avatar-drew-macgibbon.jpg
148:     const formData = new FormData()
149:     formData.append('file', blob)
150: 
151:     const response = await $fetch('/api/users/insert/image', {
152:       method: 'POST',
153:       body: formData,
154:       params: {
155:         fileType,
156:         userId: userId.value,
157:       },
158:     })
159: 
160:     console.log('fileName', response)
161: 
162:     const fileName = errors.server({
163:       response,
164:       devOnly: false,
165:       devMessage: `Error uploading ${fileType} image`,
166:       userMessage: `There was an error uploading your ${fileType}`,
167:     })
168: 
169:     let newData = {}
170: 
171:     console.log('fileName', fileName)
172: 
173:     if (fileType === 'avatar') {
174:       newData = {
175:         avatar: fileName,
176:       }
177:     }
178: 
179:     updateProfile(newData)
180:   }
181: 
182:   // first check if the user has an avatar in their profile
183:   // if not, check if the user has an avatar in their identities
184:   // cycle through identities check identities_data for picture
185: 
186:   return {
187:     haveUserSession: computed(() => !!profile.value),
188:     isAdmin: computed(
189:       () => profile.value?.user_role === 'admin' || profile.value?.user_role === 'super_admin',
190:     ),
191:     registeredWithProvider: computed(() => profile.value?.provider),
192:     profile,
193:     uploadImage,
194:     updateProfile,
195:     testUpdateProfile,
196:   }
197: })
198: 
199: if (import.meta.hot) {
200:   import.meta.hot.accept(acceptHMRUpdate(useCurrentUser, import.meta.hot))
201: }
```

## File: layers/crud/server/utils/base.interface.ts
```typescript
 1: type DBTable = keyof Database['public']['Tables'] & keyof Database['public']['Views']
 2: type DBColumns<T extends DBTable> = keyof Tables<T>
 3: type TableSpecificColumns<T extends DBTable> = Partial<DBColumns<T>>
 4: 
 5: // full list of filters here: https://postgrest.org/en/v12/references/api/tables_views.html#operators
 6: 
 7: type FilterKey =
 8:   | 'eq'
 9:   | 'match'
10:   | 'neq'
11:   | 'not'
12:   | 'gte'
13:   | 'gt'
14:   | 'lt'
15:   | 'lte'
16:   | 'like'
17:   | 'ilike'
18:   | 'is'
19:   | 'in'
20:   | 'contains'
21:   | 'containedBy'
22:   | 'rangeGt'
23:   | 'rangeGte'
24:   | 'rangeLt'
25:   | 'rangeLte'
26:   | 'rangeAdjacent'
27:   | 'overlaps'
28:   | 'textSearch'
29: 
30: interface Pagination {
31:   page?: number
32:   limit?: number
33:   from: number
34:   to: number
35: }
36: 
37: export type GenericReturn<T> = Promise<T[] | T | null>
38: 
39: export type TableKey = keyof Database['public']['Tables'] | keyof Database['public']['Views']
40: 
41: export type FilterBy<T extends DBTable> = {
42:   columnName: TableSpecificColumns<T>
43:   operator: FilterKey
44:   value: string | boolean | number
45: }
46: 
47: type OrderBy<T extends DBTable> = {
48:   columnNames: TableSpecificColumns<T>[]
49:   ascending: boolean
50:   referenceTable?: string
51: }
52: 
53: type Conflict = {
54:   onConflict: string[]
55:   ignoreDuplicates: boolean
56:   count?: 'exact' | 'planned' | 'estimated'
57:   defaultToNull?: boolean
58: }
59: 
60: // todo: refactor to have options under select/insert/update/delete
61: // for instance we can group limit, pagination, selectStatement all under select
62: export interface BaseOperationInput<T, K extends DBTable> {
63:   tableName: K
64:   data?: T | T[]
65:   selectStatement?: string
66:   filterBy?: FilterBy<K> | false
67:   orderBy?: OrderBy<K> | false
68:   pagination?: Pagination | false
69:   limit?: number
70:   isSingle?: boolean
71:   isReturned?: boolean
72:   conflict?: Conflict
73: }
74: 
75: export interface SelectInput<T, K extends DBTable> extends BaseOperationInput<T, K> {
76:   selectStatement: string
77: }
78: 
79: export interface InsertInput<T, K extends DBTable> extends BaseOperationInput<T, K> {
80:   data: T | T[]
81: }
82: 
83: export interface UpsertInput<T, K extends DBTable> extends BaseOperationInput<T, K> {
84:   data: T | T[]
85:   conflict: Conflict
86: }
87: 
88: export interface UpdateInput<T, K extends DBTable> extends BaseOperationInput<T, K> {
89:   data: T | T[]
90:   filterBy: FilterBy<K>
91: }
92: 
93: export interface DeleteInput<T, K extends DBTable> extends BaseOperationInput<T, K> {
94:   data: T | T[]
95:   filterBy: FilterBy<K>
96: }
97: 
98: export type { Database, Tables, DBTable }
```

## File: layers/crud/nuxt.config.ts
```typescript
 1: export default defineNuxtConfig({
 2:   modules: ['@nuxtjs/supabase'],
 3: 
 4:   supabase: {
 5:     redirect: false,
 6:     clientOptions: {
 7:       auth: {
 8:         flowType: 'pkce',
 9:         detectSessionInUrl: true,
10:         persistSession: true,
11:         autoRefreshToken: true,
12:       },
13:     },
14:     cookieName: 'sb',
15:   },
16: })
```

## File: libs/logger/src/environment.d.ts
```typescript
 1: // src/environment.d.ts
 2: 
 3: declare global {
 4:   // Add Nuxt runtime config types
 5:   interface RuntimeConfig {
 6:     public: {
 7:       nodeEnv?: string
 8:       [key: string]: any
 9:     }
10:     [key: string]: any
11:   }
12: 
13:   // Add useRuntimeConfig function type
14:   type UseRuntimeConfig = () => RuntimeConfig
15: 
16:   const useRuntimeConfig: UseRuntimeConfig | undefined
17: }
18: 
19: export interface ImportMetaEnv {
20:   MODE: string
21:   DEV: boolean
22:   PROD: boolean
23:   [key: string]: any
24: }
25: 
26: export interface ImportMeta {
27:   url: string
28:   env: ImportMetaEnv
29:   readonly hot?: {
30:     accept: () => void
31:     dispose: () => void
32:     invalidate: () => void
33:     [key: string]: any
34:   }
35: }
36: 
37: export {}
```

## File: libs/logger/src/environment.ts
```typescript
 1: // src/environment.ts
 2: export const getEnvironment = () => {
 3:   // Check for Node.js environment more safely
 4:   const isNode = (() => {
 5:     try {
 6:       return typeof globalThis.process !== 'undefined' && !!globalThis.process?.versions?.node
 7:     } catch {
 8:       return false
 9:     }
10:   })()
11: 
12:   // Check for browser environment
13:   const isBrowser = (() => {
14:     try {
15:       return typeof window !== 'undefined'
16:     } catch {
17:       return false
18:     }
19:   })()
20: 
21:   // Check for development mode across different environments
22:   const isDev = (() => {
23:     try {
24:       // For Nuxt specific environment
25:       if (typeof globalThis.useRuntimeConfig === 'function') {
26:         const config = globalThis.useRuntimeConfig()
27:         return config.public.nodeEnv === 'development'
28:       }
29: 
30:       // Fallback checks
31:       return Boolean(
32:         import.meta?.env?.DEV ||
33:           import.meta?.env?.MODE === 'development' ||
34:           (typeof process !== 'undefined' && process.env.NODE_ENV === 'development'),
35:       )
36:     } catch {
37:       return false
38:     }
39:   })()
40: 
41:   return {
42:     isNode,
43:     isBrowser,
44:     isDev,
45:   }
46: }
```

## File: libs/logger/src/error-interface.ts
```typescript
  1: export interface ErrorMessage {
  2:   userMessage: string // User-friendly error message if needed
  3:   devMessage: string // Make bugfixing easy!
  4:   error: any
  5: }
  6: 
  7: export interface ErrorServer extends Omit<ErrorMessage, 'error'> {
  8:   featureRelated?: boolean // default false - log to feature-specific log
  9:   response: { data: any; error: any }
 10: }
 11: 
 12: // Retryable status codes with descriptions
 13: export const retryableStatusCodes: { [key: number]: string } = {
 14:   408: 'Request Timeout - The server timed out waiting for the request.',
 15:   409: 'Conflict - The request could not be completed due to a conflict with the current state of the target resource.',
 16:   425: 'Too Early - The server is unwilling to risk processing a request that might be replayed.',
 17:   500: 'Internal Server Error - The server encountered an unexpected condition that prevented it from fulfilling the request.',
 18:   502: 'Bad Gateway - The server, while acting as a gateway or proxy, received an invalid response from an inbound server.',
 19:   503: 'Service Unavailable - The server is currently unable to handle the request due to temporary overloading or maintenance of the server.',
 20:   504: 'Gateway Timeout - The server, while acting as a gateway or proxy, did not receive a timely response from an upstream server.',
 21: }
 22: 
 23: export enum ErrorSeverity {
 24:   LOW = 'low',
 25:   MEDIUM = 'medium',
 26:   HIGH = 'high',
 27:   CRITICAL = 'critical',
 28: }
 29: 
 30: export enum ErrorType {
 31:   UPLOAD_ERROR = 'UPLOAD_ERROR',
 32:   CONNECTION_ERROR = 'CONNECTION_ERROR',
 33:   AUTHENTICATION_ERROR = 'AUTHENTICATION_ERROR',
 34:   UNIQUE_VIOLATION = 'UNIQUE_VIOLATION',
 35:   FOREIGN_KEY_VIOLATION = 'FOREIGN_KEY_VIOLATION',
 36:   NOT_NULL_VIOLATION = 'NOT_NULL_VIOLATION',
 37:   CONSTRAINT_ERROR = 'CONSTRAINT_ERROR',
 38:   UNDEFINED_TABLE = 'UNDEFINED_TABLE',
 39:   UNDEFINED_PARAMETER = 'UNDEFINED_PARAMETER',
 40:   SYNTAX_ERROR = 'SYNTAX_ERROR',
 41:   DUPLICATE_ALIAS = 'DUPLICATE_ALIAS',
 42:   UNDEFINED_COLUMN = 'UNDEFINED_COLUMN',
 43:   DATA_EXCEPTION = 'DATA_EXCEPTION',
 44:   SERIALIZATION_FAILURE = 'SERIALIZATION_FAILURE',
 45:   DEADLOCK_DETECTED = 'DEADLOCK_DETECTED',
 46:   INSUFFICIENT_RESOURCES = 'INSUFFICIENT_RESOURCES',
 47:   RATE_LIMIT_ERROR = 'RATE_LIMIT_ERROR',
 48:   SERVER_ERROR = 'SERVER_ERROR',
 49:   UNKNOWN_ERROR = 'UNKNOWN_ERROR',
 50:   VALIDATION_ERROR = 'VALIDATION_ERROR',
 51:   NOT_FOUND_ERROR = 'NOT_FOUND_ERROR',
 52:   NETWORK_ERROR = 'NETWORK_ERROR',
 53: }
 54: 
 55: // Types
 56: export interface ErrorDetails {
 57:   type: ErrorType
 58:   message: string
 59:   severity: ErrorSeverity
 60:   stack?: string
 61:   code?: string | number
 62:   context?: string
 63:   pgError?: string
 64:   operation?: string
 65:   originalError?: any
 66: }
 67: 
 68: export interface ErrorHandlerOptions {
 69:   context?: string
 70:   userMessage?: string
 71:   devMessage?: string
 72:   throwError?: boolean
 73: }
 74: 
 75: export interface FetchErrorResponse {
 76:   data?: any
 77:   error?: any
 78: }
 79: 
 80: export function mapErrorSeverity(error: any): ErrorSeverity {
 81:   if (error.status >= 500) return ErrorSeverity.CRITICAL
 82:   if (error.status === 429) return ErrorSeverity.HIGH
 83: 
 84:   // Connection errors are critical
 85:   if (error.code?.startsWith('08')) return ErrorSeverity.CRITICAL
 86: 
 87:   // Authentication errors are high severity
 88:   if (error.code?.startsWith('28')) return ErrorSeverity.HIGH
 89: 
 90:   // Constraint violations are high severity
 91:   if (error.code?.startsWith('23')) return ErrorSeverity.HIGH
 92: 
 93:   // Query errors are medium severity
 94:   if (error.code?.startsWith('42')) return ErrorSeverity.MEDIUM
 95: 
 96:   // Data exceptions are medium severity
 97:   if (error.code?.startsWith('22')) return ErrorSeverity.MEDIUM
 98: 
 99:   // Transaction errors are high severity
100:   if (error.code === '40001' || error.code === '40P01') return ErrorSeverity.HIGH
101: 
102:   // System errors are critical
103:   if (error.code?.startsWith('53')) return ErrorSeverity.CRITICAL
104: 
105:   // Default to medium severity for unknown errors
106:   return ErrorSeverity.MEDIUM
107: }
108: 
109: export function mapErrorType(error: any): ErrorType {
110:   // Connection errors
111:   if (
112:     error.code === '08000' ||
113:     error.code === '08003' ||
114:     error.code === '08006' ||
115:     error.code === '08001' ||
116:     error.code === '08004'
117:   ) {
118:     return ErrorType.CONNECTION_ERROR
119:   }
120: 
121:   // Authentication errors
122:   if (error.code === '28000' || error.code === '28P01') {
123:     return ErrorType.AUTHENTICATION_ERROR
124:   }
125: 
126:   // Constraint violations
127:   if (error.code === '23505') return ErrorType.UNIQUE_VIOLATION
128:   if (error.code === '23503') return ErrorType.FOREIGN_KEY_VIOLATION
129:   if (error.code === '23502') return ErrorType.NOT_NULL_VIOLATION
130:   if (error.code?.startsWith('23') && !['23505', '23503', '23502'].includes(error.code))
131:     return ErrorType.CONSTRAINT_ERROR
132: 
133:   // Query errors
134:   if (error.code === '42P01') return ErrorType.UNDEFINED_TABLE
135:   if (error.code === '42P02') return ErrorType.UNDEFINED_PARAMETER
136:   if (error.code === '42601') return ErrorType.SYNTAX_ERROR
137:   if (error.code === '42P07') return ErrorType.DUPLICATE_ALIAS
138:   if (error.code === '42703') return ErrorType.UNDEFINED_COLUMN
139: 
140:   // Data errors
141:   if (error.code?.startsWith('22')) return ErrorType.DATA_EXCEPTION
142: 
143:   // Transaction errors
144:   if (error.code === '40001') return ErrorType.SERIALIZATION_FAILURE
145:   if (error.code === '40P01') return ErrorType.DEADLOCK_DETECTED
146: 
147:   // System errors
148:   if (
149:     error.code === '53000' ||
150:     error.code === '53100' ||
151:     error.code === '53200' ||
152:     error.code === '53300'
153:   ) {
154:     return ErrorType.INSUFFICIENT_RESOURCES
155:   }
156: 
157:   // HTTP-specific errors
158:   if (error.status === 429) return ErrorType.RATE_LIMIT_ERROR
159:   if (error.status >= 500) return ErrorType.SERVER_ERROR
160: 
161:   // Catch-all for unspecified errors
162:   return ErrorType.UNKNOWN_ERROR
163: }
164: 
165: export interface LogLevels {
166:   error: 0
167:   warn: 1
168:   info: 2
169:   http: 3
170:   verbose: 4
171:   debug: 5
172:   silly: 6
173: }
174: 
175: export class AppError extends Error {
176:   details: ErrorDetails
177: 
178:   constructor(details: ErrorDetails) {
179:     super(details.message)
180:     this.details = details
181:     this.name = 'AppError'
182:   }
183: }
184: 
185: export interface Logger {
186:   error: (message: string, ...args: any[]) => void
187:   warn: (message: string, ...args: any[]) => void
188:   info: (message: string, ...args: any[]) => void
189:   verbose: (message: string, ...args: any[]) => void
190:   debug: (message: string, ...args: any[]) => void
191:   silly: (message: string, ...args: any[]) => void
192:   http: (message: string, ...args: any[]) => void
193: }
```

## File: libs/logger/src/handler.ts
```typescript
  1: // utils/error-handler.ts
  2: import { createLogger } from './logger'
  3: import { getEnvironment } from './environment'
  4: import {
  5:   ErrorType,
  6:   ErrorSeverity,
  7:   AppError,
  8:   mapErrorType,
  9:   mapErrorSeverity,
 10:   retryableStatusCodes,
 11:   type ErrorHandlerOptions,
 12:   type FetchErrorResponse,
 13: } from './error-interface'
 14: 
 15: export class ErrorHandler {
 16:   private logger
 17:   private env = getEnvironment()
 18: 
 19:   constructor(private context = 'ErrorHandler') {
 20:     this.logger = createLogger(context)
 21:   }
 22: 
 23:   private determineErrorType(error: any): ErrorType {
 24:     if (error instanceof AppError) return error.details.type
 25:     return mapErrorType(error)
 26:   }
 27: 
 28:   private determineSeverity(error: any): ErrorSeverity {
 29:     if (error instanceof AppError) return error.details.severity
 30:     return mapErrorSeverity(error)
 31:   }
 32: 
 33:   private formatErrorMessage(options: {
 34:     userMessage?: string
 35:     devMessage: string
 36:     error: any
 37:   }): string {
 38:     const { userMessage, devMessage, error } = options
 39:     const devError = `${devMessage}: ${JSON.stringify(error)}`
 40:     this.logger.error(devError)
 41:     return this.env.isDev ? devError : userMessage || 'An unexpected error occurred'
 42:   }
 43: 
 44:   private normalizeError(error: Error | AppError, context?: string): AppError {
 45:     if (error instanceof AppError) {
 46:       return error
 47:     }
 48: 
 49:     const errorType = this.determineErrorType(error)
 50:     const severity = this.determineSeverity(error)
 51: 
 52:     return new AppError({
 53:       type: errorType,
 54:       message: error.message,
 55:       severity,
 56:       stack: error.stack,
 57:       context,
 58:       code: (error as any).code,
 59:       pgError: (error as any).details || (error as any).hint,
 60:       operation: context,
 61:       originalError: error,
 62:     })
 63:   }
 64: 
 65:   private getErrorStatusCode(errorType: ErrorType): number {
 66:     switch (errorType) {
 67:       case ErrorType.AUTHENTICATION_ERROR:
 68:         return 401
 69:       case ErrorType.VALIDATION_ERROR:
 70:         return 400
 71:       case ErrorType.NOT_FOUND_ERROR:
 72:         return 404
 73:       case ErrorType.RATE_LIMIT_ERROR:
 74:         return 429
 75:       case ErrorType.CONSTRAINT_ERROR:
 76:       case ErrorType.UNIQUE_VIOLATION:
 77:       case ErrorType.FOREIGN_KEY_VIOLATION:
 78:         return 409
 79:       default:
 80:         return 500
 81:     }
 82:   }
 83: 
 84:   handleError(error: Error | AppError, options: ErrorHandlerOptions = {}) {
 85:     const appError = this.normalizeError(error, options.context)
 86: 
 87:     this.logger.error(`${appError.details.type}: ${appError.message}`, {
 88:       ...appError.details,
 89:       stack: this.env.isDev ? appError.stack : undefined,
 90:     })
 91: 
 92:     // Handle server-side errors
 93:     if (this.env.isNode) {
 94:       const errorMessage = this.formatErrorMessage({
 95:         userMessage: options.userMessage || appError.message,
 96:         devMessage: options.devMessage || appError.details.type,
 97:         error: appError,
 98:       })
 99: 
100:       if (options.throwError) {
101:         const serverError = new Error()
102:         serverError.message = `SERVER ERROR: ${errorMessage}`
103:         ;(serverError as any).statusCode = this.getErrorStatusCode(appError.details.type)
104:         ;(serverError as any).statusMessage = appError.message
105:         ;(serverError as any).data = {
106:           error: {
107:             type: appError.details.type,
108:             message: appError.message,
109:             severity: appError.details.severity,
110:             details: this.env.isDev ? appError.details : undefined,
111:           },
112:         }
113:         throw serverError
114:       }
115:     }
116: 
117:     // Handle critical errors
118:     if (appError.details.severity === ErrorSeverity.CRITICAL) {
119:       // Add critical error handling logic
120:       this.handleCriticalError(appError)
121:     }
122: 
123:     return appError
124:   }
125: 
126:   handleFetchError({
127:     response,
128:     devMessage,
129:     userMessage,
130:   }: {
131:     response: FetchErrorResponse
132:     devMessage: string
133:     userMessage?: string
134:   }) {
135:     if (response.error) {
136:       this.logger.error(`FETCH Error: ${response.error}`)
137:       return this.handleError(response.error, { userMessage, devMessage })
138:     }
139: 
140:     if (response.data) {
141:       this.logger.info(
142:         `Successfully fetched ${Array.isArray(response.data) ? response.data.length : 1} items`,
143:       )
144:       return response.data
145:     }
146: 
147:     this.logger.info('Nothing returned from fetch')
148:     return this.handleError(new Error('No data found'), {
149:       userMessage: 'Resource not found',
150:       devMessage: 'Fetch returned empty response',
151:     })
152:   }
153: 
154:   handleDBError(response: FetchErrorResponse, context: string) {
155:     if (response.error) {
156:       return this.handleError(response.error, {
157:         context,
158:         devMessage: `Database error in ${context}`,
159:         userMessage: 'Database operation failed',
160:       })
161:     }
162:     return response.data
163:   }
164: 
165:   private handleCriticalError(error: AppError) {
166:     // Implement critical error handling
167:     this.logger.error('CRITICAL ERROR:', error.details)
168:     // Could trigger alerts, notifications, etc.
169:   }
170: }
171: 
172: // Factory function
173: export function createErrorHandler(context = 'ErrorHandler') {
174:   const handler = new ErrorHandler(context)
175: 
176:   return {
177:     handleError: handler.handleError.bind(handler),
178:     handleFetchError: handler.handleFetchError.bind(handler),
179:     handleDBError: handler.handleDBError.bind(handler),
180:   }
181: }
182: 
183: // Convenience function for framework integration
184: export const useErrorHandler = (context = 'ErrorHandler') => {
185:   return createErrorHandler(context)
186: }
```

## File: libs/logger/src/logger.ts
```typescript
  1: // utils/logger.ts
  2: import { createConsola } from 'consola'
  3: import type { ConsolaInstance } from 'consola'
  4: import type { Logger, LogLevels } from './error-interface'
  5: import { getEnvironment } from './environment'
  6: 
  7: export class BaseLogger implements Logger {
  8:   protected logger: ConsolaInstance | Logger
  9:   protected env = getEnvironment()
 10: 
 11:   constructor(tag = '') {
 12:     this.logger = createConsola({
 13:       level: this.env.isDev ? 10 : 3,
 14:       formatOptions: {
 15:         date: this.env.isNode,
 16:         colors: true,
 17:       },
 18:     }).withTag(tag.toUpperCase())
 19:   }
 20: 
 21:   error(message: string, ...args: any[]) {
 22:     this.logger.error(message, ...args)
 23:   }
 24: 
 25:   warn(message: string, ...args: any[]) {
 26:     this.logger.warn(message, ...args)
 27:   }
 28: 
 29:   info(message: string, ...args: any[]) {
 30:     this.logger.info(message, ...args)
 31:   }
 32: 
 33:   verbose(message: string, ...args: any[]) {
 34:     if (this.env.isDev) {
 35:       this.logger.verbose(message, ...args)
 36:     }
 37:   }
 38: 
 39:   debug(message: string, ...args: any[]) {
 40:     if (this.env.isDev) {
 41:       this.logger.debug(message, ...args)
 42:     }
 43:   }
 44: 
 45:   silly(message: string, ...args: any[]) {
 46:     if (this.env.isDev) {
 47:       this.logger.info(message, ...args)
 48:     }
 49:   }
 50: 
 51:   http(message: string, ...args: any[]) {
 52:     this.logger.info(message, ...args)
 53:   }
 54: }
 55: 
 56: let winstonPackage: typeof import('winston') | undefined = undefined
 57: 
 58: export class NodeLogger extends BaseLogger {
 59:   private winstonLogger: any
 60: 
 61:   constructor(tag = '') {
 62:     super(tag)
 63: 
 64:     if (this.env.isNode) {
 65:       this.initWinston(tag).catch((err) => {
 66:         this.logger.error('Failed to initialize Winston:', err)
 67:       })
 68:     }
 69:   }
 70: 
 71:   private async initWinston(tag: string) {
 72:     try {
 73:       if (!winstonPackage) {
 74:         winstonPackage = await import('winston')
 75:       }
 76: 
 77:       const format = winstonPackage.format.combine(
 78:         winstonPackage.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss:ms' }),
 79:         winstonPackage.format.cli(),
 80:         winstonPackage.format.printf(
 81:           (info) => `${info['timestamp']} ${info.level}: [${tag}] ${info.message}`,
 82:         ),
 83:       )
 84: 
 85:       this.winstonLogger = winstonPackage.createLogger({
 86:         levels: {
 87:           error: 0,
 88:           warn: 1,
 89:           info: 2,
 90:           http: 3,
 91:           verbose: 4,
 92:           debug: 5,
 93:           silly: 6,
 94:         },
 95:         level: this.env.isDev ? 'silly' : 'info',
 96:         format,
 97:         transports: [
 98:           new winstonPackage.transports.Console(),
 99:           ...(this.env.isDev
100:             ? []
101:             : [
102:                 new winstonPackage.transports.File({
103:                   filename: './data/logs/error.log',
104:                   level: 'error',
105:                 }),
106:                 new winstonPackage.transports.File({
107:                   filename: './data/logs/combined.log',
108:                 }),
109:               ]),
110:         ],
111:       })
112:     } catch (err) {
113:       this.logger.warn('Winston not available, falling back to console logger')
114:     }
115:   }
116: 
117:   override error(message: string, ...args: any[]) {
118:     if (this.winstonLogger) {
119:       this.winstonLogger.error(message, ...args)
120:     } else {
121:       super.error(message, ...args)
122:     }
123:   }
124: 
125:   override warn(message: string, ...args: any[]) {
126:     if (this.winstonLogger) {
127:       this.winstonLogger.warn(message, ...args)
128:     } else {
129:       super.warn(message, ...args)
130:     }
131:   }
132: 
133:   override info(message: string, ...args: any[]) {
134:     if (this.winstonLogger) {
135:       this.winstonLogger.info(message, ...args)
136:     } else {
137:       super.info(message, ...args)
138:     }
139:   }
140: 
141:   override verbose(message: string, ...args: any[]) {
142:     if (this.winstonLogger && this.env.isDev) {
143:       this.winstonLogger.verbose(message, ...args)
144:     } else {
145:       super.verbose(message, ...args)
146:     }
147:   }
148: 
149:   override debug(message: string, ...args: any[]) {
150:     if (this.winstonLogger && this.env.isDev) {
151:       this.winstonLogger.debug(message, ...args)
152:     } else {
153:       super.debug(message, ...args)
154:     }
155:   }
156: 
157:   override silly(message: string, ...args: any[]) {
158:     if (this.winstonLogger && this.env.isDev) {
159:       this.winstonLogger.silly(message, ...args)
160:     } else {
161:       super.silly(message, ...args)
162:     }
163:   }
164: 
165:   override http(message: string, ...args: any[]) {
166:     if (this.winstonLogger) {
167:       this.winstonLogger.http(message, ...args)
168:     } else {
169:       super.http(message, ...args)
170:     }
171:   }
172: }
173: 
174: // Factory function to create the appropriate logger
175: export const createLogger = (tag = '') => {
176:   const env = getEnvironment()
177:   return env.isNode ? new NodeLogger(tag) : new BaseLogger(tag)
178: }
179: 
180: // Async version for when we want to ensure Winston is loaded
181: export const createLoggerAsync = async (tag = '') => {
182:   const logger = createLogger(tag)
183:   if (logger instanceof NodeLogger) {
184:     // Wait for Winston to initialize if needed
185:     await new Promise((resolve) => setTimeout(resolve, 100))
186:   }
187:   return logger
188: }
189: 
190: // Framework-specific wrappers if needed
191: export const useLogger = (tag = '') => {
192:   return createLogger(tag)
193: }
194: 
195: export const useLoggerAsync = async (tag = '') => {
196:   return await createLoggerAsync(tag)
197: }
```

## File: libs/logger/index.d.ts
```typescript
1: import type { Consola } from 'consola'
2: 
3: export * from './src/environment.d'
4: 
5: export function useLogger(tag?: string): Consola
```

## File: libs/logger/index.ts
```typescript
1: export * from './src/logger'
2: export * from './src/handler'
3: export * from './src/error-interface'
```

## File: shared-runtime.config.ts
```typescript
 1: import { config } from 'dotenv'
 2: 
 3: config()
 4: 
 5: export default defineNuxtConfig({
 6:   runtimeConfig: {
 7:     public: {
 8:       strapiUrl: process.env.NUXT_PUBLIC_STRAPI_URL,
 9:       formbricksEnvironment: process.env.NUXT_PUBLIC_FORMBRICKS_ENVIRONMENT,
10:       formbricksHost: process.env.NUXT_PUBLIC_FORMBRICKS_HOST,
11:       supabaseUrl: process.env.NUXT_PUBLIC_SUPABASE_URL,
12:       supabaseKey: process.env.NUXT_PUBLIC_SUPABASE_KEY,
13:       aeAuthUrl: process.env.NUXT_PUBLIC_AE_AUTH_URL,
14:       aeLoginUrl: process.env.NUXT_PUBLIC_AE_LOGIN_URL,
15:       aeAppUrl: process.env.NUXT_PUBLIC_AE_APP_URL,
16:       aeAdminUrl: process.env.NUXT_PUBLIC_AE_ADMIN_URL,
17:       aeMonitoringUrl: process.env.NUXT_PUBLIC_AE_MONITORING_URL,
18:       aeWebsiteUrl: process.env.NUXT_PUBLIC_AE_WEBSITE_URL,
19:       nodeEnv: process.env.NUXT_PUBLIC_NODE_ENV,
20:       logLevel: process.env.NUXT_PUBLIC_LOG_LEVEL,
21:       posthogKey: process.env.NUXT_PUBLIC_POSTHOG_KEY,
22:       posthogUrl: process.env.NUXT_PUBLIC_POSTHOG_URL,
23:       studioTokens: process.env.NUXT_PUBLIC_STUDIO_TOKENS,
24:       scraperUrl: process.env.NUXT_PUBLIC_SCRAPER_URL,
25:       devHelper: {
26:         enabled: true,
27:         features: {
28:           networkErrorClassifier: true,
29:           infiniteLoopDetector: true,
30:           unhandledPromiseRejectionTracker: true,
31:           environmentConsistencyChecker: true,
32:         },
33:       },
34:     },
35:     strapiUrl: process.env.NUXT_STRAPI_URL,
36:     supabaseServiceKey: process.env.NUXT_SUPABASE_SERVICE_KEY,
37:     googleApiKey: process.env.NUXT_GOOGLE_API_KEY,
38:     nasaApiKey: process.env.NUXT_NASA_API_KEY,
39:     openaiApiKey: process.env.NUXT_OPENAI_API_KEY,
40:     openaiOrg: process.env.NUXT_OPENAI_ORG,
41:     redisFlushKey: process.env.NUXT_REDIS_FLUSH_KEY,
42:     scraperKey: process.env.NUXT_SCRAPER_KEY,
43:     razorpayKey: process.env.NUXT_RAZORPAY_KEY,
44:     razorpaySecret: process.env.NUXT_RAZORPAY_SECRET,
45:     razorpayTestKey: process.env.NUXT_RAZORPAY_TEST_KEY,
46:     razorpayTestSecret: process.env.NUXT_RAZORPAY_TEST_SECRET,
47:   },
48: })
```
