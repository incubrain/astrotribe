{"timestamp":"2024-12-16T07:10:14.838Z","action":"generateControllers","data":"// base.controller.ts\nimport { Injectable, UnauthorizedException } from '@nestjs/common';\nimport { Request } from 'express';\nimport { verify } from 'jsonwebtoken';\nimport { Prisma, app_role_enum } from '@prisma/client';\nimport { PrismaService } from '../services/prisma.service';\nimport { ConfigService } from '../services/config.service';\nimport { PaginatedResponse } from '../types/pagination.types';\nimport { PaginationService } from '../services/pagination.service';\n\n@Injectable()\nexport abstract class BaseController {\n  protected abstract readonly modelName: keyof Prisma.TypeMap['model'];\n\n  constructor(\n    protected readonly prisma: PrismaService,\n    protected readonly config: ConfigService,\n    protected readonly paginationService: PaginationService\n  ) {}\n\n  protected get model(): any {\n    return this.prisma[this.modelName];\n  }\n\n  async findAll(query: PaginatedQuery) {\n    const { page = 1, limit = 10, include, ...filters } = query;\n    const includes = include?.reduce((acc, rel) => ({ ...acc, [rel]: true }), {});\n\n    const [data, total] = await Promise.all([\n      this.model.findMany({\n        where: filters,\n        include: includes,\n        skip: (page - 1) * limit,\n        take: limit,\n      }),\n      this.model.count({ where: filters }),\n    ]);\n\n    return this.handlePaginatedSuccess(data, this.paginationService.getPaginationMeta(total, page, limit));\n  }\n\n  async findOne(id: string, include?: string[]) {\n    const includes = include?.reduce((acc, rel) => ({ ...acc, [rel]: true }), {});\n    const data = await this.model.findUnique({\n      where: { id },\n      include: includes,\n    });\n    return this.handleSuccess(data);\n  }\n\n  async create(data: unknown) {\n    const result = await this.model.create({ data });\n    return this.handleSuccess(result);\n  }\n\n  async update(id: string, data: unknown) {\n    const result = await this.model.update({\n      where: { id },\n      data,\n    });\n    return this.handleSuccess(result);\n  }\n\n  async remove(id: string) {\n    await this.model.delete({ where: { id } });\n    return this.handleSuccess({ id });\n  }\n\n  protected async getUserFromRequest(req: Request) {\n    const authHeader = req.headers.authorization;\n    if (!authHeader) {\n      throw new UnauthorizedException('No authorization header');\n    }\n\n    const token = authHeader.replace('Bearer ', '');\n    try {\n      const decoded = verify(token, this.config.get('JWT_SECRET')) as { userId: string };\n      \n      const user = await this.prisma.user_profiles.findUnique({\n        where: { id: decoded.userId },\n        select: {\n          id: true,\n          email: true,\n          role: true,\n          is_active: true,\n        }\n      });\n\n      if (!user || !user.is_active) {\n        throw new UnauthorizedException('Invalid or inactive user');\n      }\n\n      return user;\n    } catch (error) {\n      throw new UnauthorizedException('Invalid token');\n    }\n  }\n\n  protected async validateRequest(req: Request) {\n    const user = await this.getUserFromRequest(req);\n    if (!user) {\n      throw new UnauthorizedException('Unauthorized');\n    }\n    return user;\n  }\n\n  protected async checkPermission(userRole: app_role_enum) {\n    const permission = await this.prisma.role_permissions.findFirst({\n      where: {\n        role: userRole,\n        table_name: this.modelName,\n      }\n    });\n\n    if (!permission) {\n      throw new UnauthorizedException('Insufficient permissions');\n    }\n  }\n\n  protected handleSuccess<R>(data: R) {\n    return {\n      success: true,\n      data,\n      timestamp: new Date().toISOString(),\n    };\n  }\n\n  protected handlePaginatedSuccess<R>(data: R[], meta: any) {\n    const paginatedResponse: PaginatedResponse<R> = {\n      data,\n      meta,\n      success: true,\n      timestamp: new Date().toISOString()\n    };\n    return paginatedResponse;\n  }\n\n  protected handleError(error: any) {\n    console.error('Error:', error);\n    return {\n      success: false,\n      error: error.message || 'An unexpected error occurred',\n      timestamp: new Date().toISOString(),\n      code: error.code || 'UNKNOWN_ERROR'\n    };\n  }\n}"}
{"timestamp":"2024-12-16T07:10:14.839Z","action":"generatecore/types/pagination.types.ejs","data":"export interface PaginatedResponse<T> {\n  data: T[];\n  meta: {\n    total: number;\n    page: number;\n    limit: number;\n    totalPages: number;\n  };\n  success: boolean;\n  timestamp: string;\n}\n\nexport interface PaginationMeta {\n  total: number;\n  page: number;\n  limit: number;\n  totalPages: number;\n}\n\nexport interface PaginatedQuery {\n  page?: number;\n  limit?: number;\n  search?: string;\n  sortBy?: string;\n  sortOrder?: 'asc' | 'desc';\n}\n"}
{"timestamp":"2024-12-16T07:10:14.839Z","action":"generateMiddleware","data":"// auth.middleware.ejs\nimport { Injectable, NestMiddleware, UnauthorizedException, ForbiddenException } from '@nestjs/common';\nimport { app_plan_enum, app_role_enum } from '@prisma/client';\nimport { Request, Response, NextFunction } from 'express';\nimport { PrismaService } from '../services/prisma.service';\nimport { ConfigService } from '../services/config.service';\n\ninterface MaterializedPermissions {\n  [tableName: string]: {\n    select: boolean;\n    insert: boolean;\n    update: boolean;\n    delete: boolean;\n  }\n}\n\ninterface UserProfile {\n  id: string;\n  email: string;\n  role: app_role_enum;\n  plan: app_plan_enum;\n  is_active?: boolean;\n}\n\n@Injectable()\nexport class AuthMiddleware implements NestMiddleware {\n  constructor(\n    private readonly prisma: PrismaService,\n    private readonly config: ConfigService\n  ) {}\n\n  async use(req: Request, res: Response, next: NextFunction) {\n    try {\n      // Get the token from Supabase Auth\n      const token = this.extractToken(req);\n      \n      // Get user profile using the token's email\n      const user = await this.getUserProfile(token.email);\n      \n      // Get materialized permissions for the user's role\n      const permissions = await this.getMaterializedPermissions(user.role);\n      \n      // Check if user has permission for this operation\n      const hasPermission = await this.checkPermission(\n        req.method,\n        this.getTableNameFromPath(req.path),\n        permissions\n      );\n\n      if (!hasPermission) {\n        throw new ForbiddenException('Insufficient permissions');\n      }\n\n      // Attach user and permissions to request\n      (req as any).user = user;\n      (req as any).permissions = permissions;\n\n      next();\n    } catch (error: any) {\n      this.handleError(res, error);\n    }\n  }\n\n  private async getUserProfile(email: string): Promise<UserProfile> {\n    const profile = await this.prisma.user_profiles.findUnique({\n      where: { email },\n      select: {\n        id: true,\n        email: true,\n        role: true,\n        plan: true,\n        last_seen: true\n      }\n    });\n\n    if (!profile) {\n      throw new UnauthorizedException('User profile not found');\n    }\n\n    return profile;\n  }\n\n  private async getMaterializedPermissions(role: app_role_enum): Promise<MaterializedPermissions> {\n    const materializedPerms = await this.prisma.role_permissions_materialized.findUnique({\n      where: { role }\n    });\n\n    if (!materializedPerms) {\n      throw new ForbiddenException('No permissions found for role');\n    }\n\n    return materializedPerms.permissions as MaterializedPermissions;\n  }\n\n  private checkPermission(\n    method: string,\n    tableName: string,\n    permissions: MaterializedPermissions\n  ): boolean {\n    const tablePermissions = permissions[tableName];\n    if (!tablePermissions) return false;\n\n    // Map HTTP methods to permission types\n    const methodPermissionMap = {\n      'GET': 'select',\n      'POST': 'insert',\n      'PUT': 'update',\n      'PATCH': 'update',\n      'DELETE': 'delete'\n    };\n\n    const requiredPermission = methodPermissionMap[method];\n    return tablePermissions[requiredPermission] || false;\n  }\n\n  private getTableNameFromPath(path: string): string {\n    // Extract table name from path (e.g., /api/user_profiles -> user_profiles)\n    const parts = path.split('/').filter(Boolean);\n    return parts[parts.length - 1];\n  }\n\n  private extractToken(req: Request): { email: string } {\n    const authHeader = req.headers.authorization;\n    if (!authHeader) {\n      throw new UnauthorizedException('No authorization header');\n    }\n\n    // Here you would actually decode and verify the Supabase JWT\n    // This is just a placeholder - you'll need to implement proper JWT verification\n    const token = authHeader.replace('Bearer ', '');\n    try {\n      // You'll need to implement proper Supabase token validation here\n      return { email: 'placeholder' }; // Replace with actual token decode\n    } catch (error: any) {\n      throw new UnauthorizedException('Invalid token', error.message);\n    }\n  }\n\n  private handleError(res: Response, error: any) {\n    const status = error instanceof UnauthorizedException ? 401 : \n                   error instanceof ForbiddenException ? 403 : 500;\n\n    res.status(status).json({\n      success: false,\n      error: error.message || 'Authentication error',\n      timestamp: new Date().toISOString(),\n    });\n  }\n}"}
{"timestamp":"2024-12-16T07:10:14.841Z","action":"generateUtils","data":"// utils/auth.utils.ejs\nimport { UnauthorizedException } from '@nestjs/common';\nimport { verify } from 'jsonwebtoken';\n\nexport class AuthUtils {\n  static verifyToken(token: string, secret: string): any {\n    try {\n      return verify(token, secret);\n    } catch (error) {\n      throw new UnauthorizedException('Invalid token');\n    }\n  }\n\n  static extractTokenFromHeader(authHeader: string): string {\n    if (!authHeader) {\n      throw new UnauthorizedException('No authorization header');\n    }\n    const [type, token] = authHeader.split(' ');\n    if (type !== 'Bearer') {\n      throw new UnauthorizedException('Invalid authorization type');\n    }\n    return token;\n  }\n}\n// utils/permission.utils.ejs\nexport class PermissionUtils {\n  static canAccess(userPermissions: string[], requiredPermissions: string[]): boolean {\n    return requiredPermissions.every(required =>\n      userPermissions.some(userPerm => this.matchPermission(userPerm, required)),\n    );\n  }\n\n  private static matchPermission(userPerm: string, required: string): boolean {\n    const userParts = userPerm.split(':');\n    const requiredParts = required.split(':');\n\n    if (userParts[0] === '*') return true;\n    if (userParts.length !== requiredParts.length) return false;\n\n    return userParts.every((part, i) => part === '*' || part === requiredParts[i]);\n  }\n}\n"}
{"timestamp":"2024-12-16T07:10:14.841Z","action":"generateTypes","data":"// types/permission.types.ejs\nexport enum PermissionAction {\n  CREATE = 'CREATE',\n  READ = 'READ',\n  UPDATE = 'UPDATE',\n  DELETE = 'DELETE',\n  MANAGE = 'MANAGE'\n}\n\nexport enum ResourceType {\n  USER = 'USER',\n  CONTENT = 'CONTENT',\n  SETTINGS = 'SETTINGS',\n  BILLING = 'BILLING'\n}\n\nexport interface Permission {\n  action: PermissionAction;\n  resource: ResourceType;\n  conditions?: Record<string, any>;\n}\n\n// types/plan.types.ejs\nexport enum PlanType {\n  FREE = 'FREE',\n  BASIC = 'BASIC',\n  PREMIUM = 'PREMIUM',\n  ENTERPRISE = 'ENTERPRISE'\n}\n\nexport interface PlanFeature {\n  name: string;\n  limit?: number;\n  enabled: boolean;\n}\n\nexport interface Plan {\n  id: string;\n  name: string;\n  type: PlanType;\n  features: PlanFeature[];\n  price: number;\n}"}
{"timestamp":"2024-12-16T07:10:14.842Z","action":"generatecore/services/pagination.service.ejs","data":"import { Injectable } from '@nestjs/common';\nimport { PaginatedResponse, PaginationMeta } from '../types/pagination.types';\nimport { PaginationParams } from '../dto/pagination.dto';\n\n@Injectable()\nexport class PaginationService {\n  paginate<T>(data: T[], count: number, params: PaginationParams): PaginatedResponse<T> {\n    const { page = 1, limit = 10 } = params;\n    const totalPages = Math.ceil(count / limit);\n\n    const meta: PaginationMeta = {\n      total: count,\n      page,\n      limit,\n      totalPages,\n    };\n\n    return { data, meta };\n  }\n\n  getPaginationParams(params: PaginationParams): { skip: number; take: number } {\n    const page = params.page || 1;\n    const limit = params.limit || 10;\n    return {\n      skip: (page - 1) * limit,\n      take: limit,\n    };\n  }\n}"}
{"timestamp":"2024-12-16T07:10:14.842Z","action":"generateGuards","data":"// guards/roles.guard.ejs\nimport { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';\nimport { Reflector } from '@nestjs/core';\nimport { ROLES_KEY } from '../decorators/roles.decorator';\n\n@Injectable()\nexport class RolesGuard implements CanActivate {\n  constructor(private reflector: Reflector) {}\n\n  canActivate(context: ExecutionContext): boolean {\n    const requiredRoles = this.reflector.getAllAndOverride<string[]>(ROLES_KEY, [\n      context.getHandler(),\n      context.getClass(),\n    ]);\n    if (!requiredRoles) {\n      return true;\n    }\n    const { user } = context.switchToHttp().getRequest();\n    return requiredRoles.some(role => user.roles?.includes(role));\n  }\n}\n// guards/permissions.guard.ejs\nimport { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';\nimport { Reflector } from '@nestjs/core';\nimport { PERMISSIONS_KEY } from '../decorators/permissions.decorator';\nimport { PrismaService } from '../services/prisma.service';\n\n@Injectable()\nexport class PermissionGuard implements CanActivate {\n  constructor(\n    private reflector: Reflector,\n    private prisma: PrismaService,\n  ) {}\n\n  async canActivate(context: ExecutionContext): Promise<boolean> {\n    const requiredPermissions = this.reflector.getAllAndOverride<string[]>(PERMISSIONS_KEY, [\n      context.getHandler(),\n      context.getClass(),\n    ]);\n\n    if (!requiredPermissions) {\n      return true;\n    }\n\n    const { user, params } = context.switchToHttp().getRequest();\n    if (!user) return false;\n\n    const userPermissions = await this.prisma.role_permissions.findMany({\n      where: {\n        roleId: user.roleId,\n      },\n    });\n\n    return requiredPermissions.every(permission =>\n      userPermissions.some(up => up.permission === permission),\n    );\n  }\n}\n\n// guards/plan.guard.ejs\nimport { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';\nimport { Reflector } from '@nestjs/core';\nimport { PLAN_KEY } from '../decorators/plan.decorator';\nimport { PrismaService } from '../services/prisma.service';\n\n@Injectable()\nexport class PlanGuard implements CanActivate {\n  constructor(\n    private reflector: Reflector,\n    private prisma: PrismaService,\n  ) {}\n\n  async canActivate(context: ExecutionContext): Promise<boolean> {\n    const requiredPlans = this.reflector.getAllAndOverride<string[]>(PLAN_KEY, [\n      context.getHandler(),\n      context.getClass(),\n    ]);\n\n    if (!requiredPlans) {\n      return true;\n    }\n\n    const { user } = context.switchToHttp().getRequest();\n    if (!user) return false;\n\n    const userSubscription = await this.prisma.subscription.findFirst({\n      where: {\n        userId: user.id,\n        status: 'ACTIVE',\n      },\n      include: {\n        plan: true,\n      },\n    });\n\n    return requiredPlans.includes(userSubscription?.plan?.name);\n  }\n}\n"}
{"timestamp":"2024-12-16T07:10:14.843Z","action":"generateServices","data":"// core/services/prisma.service.ejs\nimport { Injectable, OnModuleInit, OnModuleDestroy } from '@nestjs/common';\nimport { PrismaClient } from '@prisma/client';\nimport { ConfigService } from './config.service';\n\n@Injectable()\nexport class PrismaService extends PrismaClient implements OnModuleInit, OnModuleDestroy {\n  constructor(private configService: ConfigService) {\n    super({\n      datasources: {\n        db: {\n          url: configService.get('DATABASE_URL'),\n        },\n      },\n      \n      \n    });\n    \n  }\n\n  async onModuleInit() {\n    await this.$connect();\n    \n  }\n\n  async onModuleDestroy() {\n    await this.$disconnect();\n  }\n\n  \n}import { Injectable } from '@nestjs/common';\nimport * as dotenv from 'dotenv';\n\n@Injectable()\nexport class ConfigService {\n  private readonly envConfig: { [key: string]: string };\n\n  constructor() {\n    dotenv.config();\n    this.envConfig = process.env;\n  }\n\n  get(key: string): string {\n    const value = this.envConfig[key];\n    if (!value) {\n      throw new Error(`Configuration key \"${key}\" is not defined`);\n    }\n    return value;\n  }\n\n  getOptional(key: string, defaultValue: string = ''): string {\n    return this.envConfig[key] || defaultValue;\n  }\n\n  getNumber(key: string): number {\n    const value = this.get(key);\n    const parsed = parseInt(value, 10);\n    if (isNaN(parsed)) {\n      throw new Error(`Configuration key \"${key}\" is not a valid number`);\n    }\n    return parsed;\n  }\n\n  getBoolean(key: string): boolean {\n    const value = this.get(key).toLowerCase();\n    return value === 'true' || value === '1';\n  }\n} import { Injectable, LoggerService as NestLoggerService } from '@nestjs/common';\n\n@Injectable()\nexport class LoggerService implements NestLoggerService {\n  log(message: string, context?: string) {\n    console.log(`[${context || 'LOG'}] ${message}`);\n  }\n\n  error(message: string, trace?: string, context?: string) {\n    console.error(`[${context || 'ERROR'}] ${message}`, trace);\n  }\n\n  warn(message: string, context?: string) {\n    console.warn(`[${context || 'WARN'}] ${message}`);\n  }\n\n  debug(message: string, context?: string) {\n    console.debug(`[${context || 'DEBUG'}] ${message}`);\n  }\n\n  verbose(message: string, context?: string) {\n    console.log(`[${context || 'VERBOSE'}] ${message}`);\n  }\n} // core/services/base.service.ts\nimport { Injectable } from '@nestjs/common';\nimport { PrismaClient, Prisma } from '@prisma/client';\nimport { PrismaService } from './prisma.service';\nimport { PaginationService } from './pagination.service';\nimport { PaginationParams } from '../dto/pagination.dto';\n\n@Injectable()\n@Injectable()\nexport abstract class BaseService<\n  Model,\n  CreateInput extends Prisma.TypeMap['model'][keyof Prisma.TypeMap['model']]['create']['data'],\n  UpdateInput extends Prisma.TypeMap['model'][keyof Prisma.TypeMap['model']]['update']['data'],\n> {\n  protected readonly prisma: PrismaClient;\n\n  constructor(\n    protected readonly prismaService: PrismaService,\n    protected readonly paginationService: PaginationService,\n    protected readonly modelName: keyof Prisma.TypeMap['model'],\n  ) {\n    this.prisma = this.prismaService;\n  }\n\n  protected get model(): Prisma.TypeMap['model'][typeof this.modelName] {\n    return this.prisma[this.modelName];\n  }\n\n  async findAll(query: PaginationParams & Partial<Model>): Promise<PaginatedResponse<Model>> {\n    const { page, limit, include, search, ...filters } = query;\n    const where = { ...filters };\n    const includes = include?.reduce((acc, rel) => ({ ...acc, [rel]: true }), {});\n\n    return this.executePrismaQuery(async () => {\n      const [data, total] = await Promise.all([\n        this.model.findMany({\n          where,\n          include: includes,\n          skip: (page - 1) * limit,\n          take: limit,\n        }),\n        this.model.count({ where }),\n      ]);\n\n      return this.paginationService.paginate(data, total, { page, limit });\n    });\n  }\n\n  async findOne(id: string, include?: string[]): Promise<Model | null> {\n    return this.executePrismaQuery(() =>\n      this.model.findUnique({\n        where: { id },\n        include: include?.reduce((acc, rel) => ({ ...acc, [rel]: true }), {}),\n      }),\n    );\n  }\n\n  async create(data: CreateInput): Promise<Model> {\n    return this.executePrismaQuery(() => this.model.create({ data }));\n  }\n\n  async update(id: string, data: UpdateInput): Promise<Model> {\n    return this.executePrismaQuery(() =>\n      this.model.update({\n        where: { id },\n        data,\n      }),\n    );\n  }\n\n  async remove(id: string): Promise<void> {\n    await this.executePrismaQuery(() => \n      this.model.delete({ where: { id } })\n    );\n  }\n\n  protected handleError(error: any): never {\n    console.error('Database operation failed:', error);\n\n    if (error instanceof Prisma.PrismaClientKnownRequestError) {\n      switch (error.code) {\n        case 'P2002':\n          throw new Error('Duplicate entry');\n        case 'P2003':\n          throw new Error('Referenced record not found');\n        case 'P2021':\n          throw new Error('Table not found');\n        case 'P2025':\n          throw new Error('Record not found');\n        case 'P2010':\n          throw new Error('Invalid query');\n        default:\n          throw new Error(`Database error: ${error.message}`);\n      }\n    }\n\n    if (error instanceof Prisma.PrismaClientValidationError) {\n      throw new Error(`Validation error: ${error.message}`);\n    }\n\n    if (error.code) {\n      switch (error.code) {\n        case '23505':\n          throw new Error('Duplicate entry');\n        case '23503':\n          throw new Error('Referenced record not found');\n        case '42P01':\n          throw new Error('Table not found');\n        case '42703':\n          throw new Error('Column not found');\n      }\n    }\n\n    throw new Error('An unexpected error occurred');\n  }\n\n  protected async executeQuery<R>(\n    operation: () => Promise<R | { data: R | null; error: any }>,\n  ): Promise<R> {\n    try {\n      const result = await operation();\n      return result as R;\n    } catch (error) {\n      return this.handleError(error);\n    }\n  }\n\n  protected async executePrismaQuery<R>(\n    operation: () => Promise<R>,\n  ): Promise<R> {\n    try {\n      return await operation();\n    } catch (error) {\n      return this.handleError(error);\n    }\n  }\n}"}
{"timestamp":"2024-12-16T07:10:14.843Z","action":"generatePipes","data":"// pipes/validation.pipe.ejs\nimport { PipeTransform, Injectable, ArgumentMetadata, BadRequestException } from '@nestjs/common';\nimport { validate } from 'class-validator';\nimport { plainToInstance } from 'class-transformer';\n\n@Injectable()\nexport class ValidationPipe implements PipeTransform<any> {\n  async transform(value: any, { metatype }: ArgumentMetadata) {\n    if (!metatype || !this.toValidate(metatype)) {\n      return value;\n    }\n    const object = plainToInstance(metatype, value);\n    const errors = await validate(object);\n    if (errors.length > 0) {\n      throw new BadRequestException('Validation failed');\n    }\n    return value;\n  }\n\n  private toValidate(metatype: Function): boolean {\n    const types: Function[] = [String, Boolean, Number, Array, Object];\n    return !types.includes(metatype);\n  }\n}\n// pipes/transformation.pipe.ejs\nimport { PipeTransform, Injectable, ArgumentMetadata } from '@nestjs/common';\n\n@Injectable()\nexport class TransformationPipe implements PipeTransform {\n  constructor(private readonly transformFn: (value: any) => any) {}\n\n  transform(value: any, metadata: ArgumentMetadata) {\n    return this.transformFn(value);\n  }\n}\n\n\n\n// pipes/type-conversion.pipe.ejs\nimport { PipeTransform, Injectable, ArgumentMetadata, BadRequestException } from '@nestjs/common';\n\n@Injectable()\nexport class TypeConversionPipe implements PipeTransform {\n  constructor(private readonly targetType: 'number' | 'boolean' | 'string') {}\n\n  transform(value: any, metadata: ArgumentMetadata) {\n    if (value === undefined) return value;\n\n    try {\n      switch (this.targetType) {\n        case 'number':\n          return Number(value);\n        case 'boolean':\n          return value === 'true' || value === '1' || value === true;\n        case 'string':\n          return String(value);\n        default:\n          return value;\n      }\n    } catch (error) {\n      throw new BadRequestException(`Type conversion failed: ${error.message}`);\n    }\n  }\n}// pipes/trim.pipe.ejs\nimport { PipeTransform, Injectable, ArgumentMetadata } from '@nestjs/common';\n\n@Injectable()\nexport class TrimPipe implements PipeTransform {\n  transform(value: any, metadata: ArgumentMetadata) {\n    if (!value) return value;\n\n    if (typeof value === 'string') {\n      return value.trim();\n    }\n\n    if (Array.isArray(value)) {\n      return value.map(item => \n        typeof item === 'string' ? item.trim() : item\n      );\n    }\n\n    if (typeof value === 'object') {\n      return Object.keys(value).reduce((acc, key) => ({\n        ...acc,\n        [key]: typeof value[key] === 'string' ? value[key].trim() : value[key]\n      }), {});\n    }\n\n    return value;\n  }\n}"}
{"timestamp":"2024-12-16T07:10:14.844Z","action":"generatecore/dto/pagination.dto.ejs","data":"import { IsOptional, IsNumber, IsString } from 'class-validator';\nimport { Type } from 'class-transformer';\n\nexport class PaginationParams {\n  @IsOptional()\n  @IsNumber()\n  @Type(() => Number)\n  page?: number = 1;\n\n  @IsOptional()\n  @IsNumber()\n  @Type(() => Number)\n  limit?: number = 10;\n\n  @IsOptional()\n  @IsString()\n  sort?: string;\n}"}
{"timestamp":"2024-12-16T07:10:14.844Z","action":"generatecore/interceptors/pagination.interceptor.ejs","data":"// templates/core/interceptors/pagination.interceptor.ejs\nimport { Injectable, NestInterceptor, ExecutionContext, CallHandler } from '@nestjs/common';\nimport { Observable } from 'rxjs';\nimport { map } from 'rxjs/operators';\nimport { PaginatedResponse } from '../types/pagination.types';\n\n@Injectable()\nexport class PaginationInterceptor<T> implements NestInterceptor<T, PaginatedResponse<T>> {\n  intercept(context: ExecutionContext, next: CallHandler): Observable<PaginatedResponse<T>> {\n    return next.handle().pipe(\n      map(data => {\n        // If data is already paginated, return as is\n        if (this.isPaginated(data)) {\n          return data;\n        }\n\n        // Get pagination params from request query\n        const request = context.switchToHttp().getRequest();\n        const { page = 1, limit = 10 } = request.query;\n\n        // If data is an array, paginate it\n        if (Array.isArray(data)) {\n          const total = data.length;\n          const totalPages = Math.ceil(total / limit);\n          const start = (page - 1) * limit;\n          const end = start + limit;\n\n          return {\n            data: data.slice(start, end),\n            meta: {\n              total,\n              page: Number(page),\n              limit: Number(limit),\n              totalPages\n            }\n          };\n        }\n\n        // If not an array, wrap in paginated response\n        return {\n          data: [data],\n          meta: {\n            total: 1,\n            page: 1,\n            limit: 1,\n            totalPages: 1\n          }\n        };\n      })\n    );\n  }\n\n  private isPaginated(data: any): data is PaginatedResponse<T> {\n    return (\n      data &&\n      'data' in data &&\n      'meta' in data &&\n      'total' in data.meta &&\n      'page' in data.meta &&\n      'limit' in data.meta &&\n      'totalPages' in data.meta\n    );\n  }\n}"}
{"timestamp":"2024-12-16T07:10:14.844Z","action":"generateDecorators","data":"// decorators/roles.decorator.ejs\nimport { SetMetadata } from '@nestjs/common';\n\nexport const ROLES_KEY = 'roles';\nexport const Roles = (...roles: string[]) => SetMetadata(ROLES_KEY, roles);\n// decorators/permissions.decorator.ejs\nimport { SetMetadata } from '@nestjs/common';\n\nexport const PERMISSIONS_KEY = 'permissions';\nexport const RequirePermissions = (...permissions: string[]) =>\n  SetMetadata(PERMISSIONS_KEY, permissions);// decorators/plan.decorator.ejs\nimport { SetMetadata } from '@nestjs/common';\n\nexport const PLAN_KEY = 'plan';\nexport const RequirePlan = (...plans: string[]) => SetMetadata(PLAN_KEY, plans);\n// decorators/validate.decorator.ejs\nimport { registerDecorator, ValidationOptions, ValidationArguments } from 'class-validator';\n\nexport function IsCustomValue(property: string, validationOptions?: ValidationOptions) {\n  return function (object: Object, propertyName: string) {\n    registerDecorator({\n      name: 'isCustomValue',\n      target: object.constructor,\n      propertyName: propertyName,\n      constraints: [property],\n      options: validationOptions,\n      validator: {\n        validate(value: any, args: ValidationArguments) {\n          const [relatedPropertyName] = args.constraints;\n          const relatedValue = (args.object as any)[relatedPropertyName];\n          return typeof value === 'string' && typeof relatedValue === 'string';\n        },\n      },\n    });\n  };\n}\n\n// decorators/current-user.decorator.ejs\nimport { createParamDecorator, ExecutionContext } from '@nestjs/common';\n\nexport const CurrentUser = createParamDecorator((data: unknown, ctx: ExecutionContext) => {\n  const request = ctx.switchToHttp().getRequest();\n  return request.user;\n});\n"}
{"timestamp":"2024-12-16T07:22:56.564Z","action":"generateMiddleware","data":"// auth.middleware.ejs\nimport { Injectable, NestMiddleware, UnauthorizedException, ForbiddenException } from '@nestjs/common';\nimport { app_plan_enum, app_role_enum } from '@prisma/client';\nimport { Request, Response, NextFunction } from 'express';\nimport { PrismaService } from '../services/prisma.service';\nimport { ConfigService } from '../services/config.service';\n\ninterface MaterializedPermissions {\n  [tableName: string]: {\n    select: boolean;\n    insert: boolean;\n    update: boolean;\n    delete: boolean;\n  }\n}\n\ninterface UserProfile {\n  id: string;\n  email: string;\n  role: app_role_enum;\n  plan: app_plan_enum;\n  is_active?: boolean;\n}\n\n@Injectable()\nexport class AuthMiddleware implements NestMiddleware {\n  constructor(\n    private readonly prisma: PrismaService,\n    private readonly config: ConfigService\n  ) {}\n\n  async use(req: Request, res: Response, next: NextFunction) {\n    try {\n      // Get the token from Supabase Auth\n      const token = this.extractToken(req);\n      \n      // Get user profile using the token's email\n      const user = await this.getUserProfile(token.email);\n      \n      // Get materialized permissions for the user's role\n      const permissions = await this.getMaterializedPermissions(user.role);\n      \n      // Check if user has permission for this operation\n      const hasPermission = await this.checkPermission(\n        req.method,\n        this.getTableNameFromPath(req.path),\n        permissions\n      );\n\n      if (!hasPermission) {\n        throw new ForbiddenException('Insufficient permissions');\n      }\n\n      // Attach user and permissions to request\n      (req as any).user = user;\n      (req as any).permissions = permissions;\n\n      next();\n    } catch (error: any) {\n      this.handleError(res, error);\n    }\n  }\n\n  private async getUserProfile(email: string): Promise<UserProfile> {\n    const profile = await this.prisma.user_profiles.findUnique({\n      where: { email },\n      select: {\n        id: true,\n        email: true,\n        role: true,\n        plan: true,\n        last_seen: true\n      }\n    });\n\n    if (!profile) {\n      throw new UnauthorizedException('User profile not found');\n    }\n\n    return profile;\n  }\n\n  private async getMaterializedPermissions(role: app_role_enum): Promise<MaterializedPermissions> {\n    const materializedPerms = await this.prisma.role_permissions_materialized.findUnique({\n      where: { role }\n    });\n\n    if (!materializedPerms) {\n      throw new ForbiddenException('No permissions found for role');\n    }\n\n    return materializedPerms.permissions as MaterializedPermissions;\n  }\n\n  private checkPermission(\n    method: string,\n    tableName: string,\n    permissions: MaterializedPermissions\n  ): boolean {\n    const tablePermissions = permissions[tableName];\n    if (!tablePermissions) return false;\n\n    // Map HTTP methods to permission types\n    const methodPermissionMap = {\n      'GET': 'select',\n      'POST': 'insert',\n      'PUT': 'update',\n      'PATCH': 'update',\n      'DELETE': 'delete'\n    };\n\n    const requiredPermission = methodPermissionMap[method];\n    return tablePermissions[requiredPermission] || false;\n  }\n\n  private getTableNameFromPath(path: string): string {\n    // Extract table name from path (e.g., /api/user_profiles -> user_profiles)\n    const parts = path.split('/').filter(Boolean);\n    return parts[parts.length - 1];\n  }\n\n  private extractToken(req: Request): { email: string } {\n    const authHeader = req.headers.authorization;\n    if (!authHeader) {\n      throw new UnauthorizedException('No authorization header');\n    }\n\n    // Here you would actually decode and verify the Supabase JWT\n    // This is just a placeholder - you'll need to implement proper JWT verification\n    const token = authHeader.replace('Bearer ', '');\n    try {\n      // You'll need to implement proper Supabase token validation here\n      return { email: 'placeholder' }; // Replace with actual token decode\n    } catch (error: any) {\n      throw new UnauthorizedException('Invalid token', error.message);\n    }\n  }\n\n  private handleError(res: Response, error: any) {\n    const status = error instanceof UnauthorizedException ? 401 : \n                   error instanceof ForbiddenException ? 403 : 500;\n\n    res.status(status).json({\n      success: false,\n      error: error.message || 'Authentication error',\n      timestamp: new Date().toISOString(),\n    });\n  }\n}"}
{"timestamp":"2024-12-16T07:22:56.564Z","action":"generateControllers","data":"// base.controller.ts\nimport { Injectable, UnauthorizedException } from '@nestjs/common';\nimport { Request } from 'express';\nimport { verify } from 'jsonwebtoken';\nimport { Prisma, app_role_enum } from '@prisma/client';\nimport { PrismaService } from '../services/prisma.service';\nimport { ConfigService } from '../services/config.service';\nimport { PaginatedResponse } from '../types/pagination.types';\nimport { PaginationService } from '../services/pagination.service';\n\n@Injectable()\nexport abstract class BaseController {\n  protected abstract readonly modelName: keyof Prisma.TypeMap['model'];\n\n  constructor(\n    protected readonly prisma: PrismaService,\n    protected readonly config: ConfigService,\n    protected readonly paginationService: PaginationService\n  ) {}\n\n  protected get model(): any {\n    return this.prisma[this.modelName];\n  }\n\n  async findAll(query: PaginatedQuery) {\n    const { page = 1, limit = 10, include, ...filters } = query;\n    const includes = include?.reduce((acc, rel) => ({ ...acc, [rel]: true }), {});\n\n    const [data, total] = await Promise.all([\n      this.model.findMany({\n        where: filters,\n        include: includes,\n        skip: (page - 1) * limit,\n        take: limit,\n      }),\n      this.model.count({ where: filters }),\n    ]);\n\n    return this.handlePaginatedSuccess(data, this.paginationService.getPaginationMeta(total, page, limit));\n  }\n\n  async findOne(id: string, include?: string[]) {\n    const includes = include?.reduce((acc, rel) => ({ ...acc, [rel]: true }), {});\n    const data = await this.model.findUnique({\n      where: { id },\n      include: includes,\n    });\n    return this.handleSuccess(data);\n  }\n\n  async create(data: unknown) {\n    const result = await this.model.create({ data });\n    return this.handleSuccess(result);\n  }\n\n  async update(id: string, data: unknown) {\n    const result = await this.model.update({\n      where: { id },\n      data,\n    });\n    return this.handleSuccess(result);\n  }\n\n  async remove(id: string) {\n    await this.model.delete({ where: { id } });\n    return this.handleSuccess({ id });\n  }\n\n  protected async getUserFromRequest(req: Request) {\n    const authHeader = req.headers.authorization;\n    if (!authHeader) {\n      throw new UnauthorizedException('No authorization header');\n    }\n\n    const token = authHeader.replace('Bearer ', '');\n    try {\n      const decoded = verify(token, this.config.get('JWT_SECRET')) as { userId: string };\n      \n      const user = await this.prisma.user_profiles.findUnique({\n        where: { id: decoded.userId },\n        select: {\n          id: true,\n          email: true,\n          role: true,\n          is_active: true,\n        }\n      });\n\n      if (!user || !user.is_active) {\n        throw new UnauthorizedException('Invalid or inactive user');\n      }\n\n      return user;\n    } catch (error) {\n      throw new UnauthorizedException('Invalid token');\n    }\n  }\n\n  protected async validateRequest(req: Request) {\n    const user = await this.getUserFromRequest(req);\n    if (!user) {\n      throw new UnauthorizedException('Unauthorized');\n    }\n    return user;\n  }\n\n  protected async checkPermission(userRole: app_role_enum) {\n    const permission = await this.prisma.role_permissions.findFirst({\n      where: {\n        role: userRole,\n        table_name: this.modelName,\n      }\n    });\n\n    if (!permission) {\n      throw new UnauthorizedException('Insufficient permissions');\n    }\n  }\n\n  protected handleSuccess<R>(data: R) {\n    return {\n      success: true,\n      data,\n      timestamp: new Date().toISOString(),\n    };\n  }\n\n  protected handlePaginatedSuccess<R>(data: R[], meta: any) {\n    const paginatedResponse: PaginatedResponse<R> = {\n      data,\n      meta,\n      success: true,\n      timestamp: new Date().toISOString()\n    };\n    return paginatedResponse;\n  }\n\n  protected handleError(error: any) {\n    console.error('Error:', error);\n    return {\n      success: false,\n      error: error.message || 'An unexpected error occurred',\n      timestamp: new Date().toISOString(),\n      code: error.code || 'UNKNOWN_ERROR'\n    };\n  }\n}"}
{"timestamp":"2024-12-16T07:22:56.565Z","action":"generatecore/types/pagination.types.ejs","data":"export interface PaginatedResponse<T> {\n  data: T[];\n  meta: {\n    total: number;\n    page: number;\n    limit: number;\n    totalPages: number;\n  };\n  success: boolean;\n  timestamp: string;\n}\n\nexport interface PaginationMeta {\n  total: number;\n  page: number;\n  limit: number;\n  totalPages: number;\n}\n\nexport interface PaginatedQuery {\n  page?: number;\n  limit?: number;\n  search?: string;\n  sortBy?: string;\n  sortOrder?: 'asc' | 'desc';\n}\n"}
{"timestamp":"2024-12-16T07:22:56.566Z","action":"generateTypes","data":"// types/permission.types.ejs\nexport enum PermissionAction {\n  CREATE = 'CREATE',\n  READ = 'READ',\n  UPDATE = 'UPDATE',\n  DELETE = 'DELETE',\n  MANAGE = 'MANAGE'\n}\n\nexport enum ResourceType {\n  USER = 'USER',\n  CONTENT = 'CONTENT',\n  SETTINGS = 'SETTINGS',\n  BILLING = 'BILLING'\n}\n\nexport interface Permission {\n  action: PermissionAction;\n  resource: ResourceType;\n  conditions?: Record<string, any>;\n}\n\n// types/plan.types.ejs\nexport enum PlanType {\n  FREE = 'FREE',\n  BASIC = 'BASIC',\n  PREMIUM = 'PREMIUM',\n  ENTERPRISE = 'ENTERPRISE'\n}\n\nexport interface PlanFeature {\n  name: string;\n  limit?: number;\n  enabled: boolean;\n}\n\nexport interface Plan {\n  id: string;\n  name: string;\n  type: PlanType;\n  features: PlanFeature[];\n  price: number;\n}"}
{"timestamp":"2024-12-16T07:22:56.566Z","action":"generateUtils","data":"// utils/auth.utils.ejs\nimport { UnauthorizedException } from '@nestjs/common';\nimport { verify } from 'jsonwebtoken';\n\nexport class AuthUtils {\n  static verifyToken(token: string, secret: string): any {\n    try {\n      return verify(token, secret);\n    } catch (error) {\n      throw new UnauthorizedException('Invalid token');\n    }\n  }\n\n  static extractTokenFromHeader(authHeader: string): string {\n    if (!authHeader) {\n      throw new UnauthorizedException('No authorization header');\n    }\n    const [type, token] = authHeader.split(' ');\n    if (type !== 'Bearer') {\n      throw new UnauthorizedException('Invalid authorization type');\n    }\n    return token;\n  }\n}\n// utils/permission.utils.ejs\nexport class PermissionUtils {\n  static canAccess(userPermissions: string[], requiredPermissions: string[]): boolean {\n    return requiredPermissions.every(required =>\n      userPermissions.some(userPerm => this.matchPermission(userPerm, required)),\n    );\n  }\n\n  private static matchPermission(userPerm: string, required: string): boolean {\n    const userParts = userPerm.split(':');\n    const requiredParts = required.split(':');\n\n    if (userParts[0] === '*') return true;\n    if (userParts.length !== requiredParts.length) return false;\n\n    return userParts.every((part, i) => part === '*' || part === requiredParts[i]);\n  }\n}\n"}
{"timestamp":"2024-12-16T07:22:56.566Z","action":"generatecore/services/pagination.service.ejs","data":"import { Injectable } from '@nestjs/common';\nimport { PaginatedResponse, PaginationMeta } from '../types/pagination.types';\nimport { PaginationParams } from '../dto/pagination.dto';\n\n@Injectable()\nexport class PaginationService {\n  paginate<T>(data: T[], count: number, params: PaginationParams): PaginatedResponse<T> {\n    const { page = 1, limit = 10 } = params;\n    const totalPages = Math.ceil(count / limit);\n\n    const meta: PaginationMeta = {\n      total: count,\n      page,\n      limit,\n      totalPages,\n    };\n\n    return { data, meta };\n  }\n\n  getPaginationParams(params: PaginationParams): { skip: number; take: number } {\n    const page = params.page || 1;\n    const limit = params.limit || 10;\n    return {\n      skip: (page - 1) * limit,\n      take: limit,\n    };\n  }\n}"}
{"timestamp":"2024-12-16T07:22:56.567Z","action":"generateGuards","data":"// guards/roles.guard.ejs\nimport { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';\nimport { Reflector } from '@nestjs/core';\nimport { ROLES_KEY } from '../decorators/roles.decorator';\n\n@Injectable()\nexport class RolesGuard implements CanActivate {\n  constructor(private reflector: Reflector) {}\n\n  canActivate(context: ExecutionContext): boolean {\n    const requiredRoles = this.reflector.getAllAndOverride<string[]>(ROLES_KEY, [\n      context.getHandler(),\n      context.getClass(),\n    ]);\n    if (!requiredRoles) {\n      return true;\n    }\n    const { user } = context.switchToHttp().getRequest();\n    return requiredRoles.some(role => user.roles?.includes(role));\n  }\n}\n// guards/permissions.guard.ejs\nimport { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';\nimport { Reflector } from '@nestjs/core';\nimport { PERMISSIONS_KEY } from '../decorators/permissions.decorator';\nimport { PrismaService } from '../services/prisma.service';\n\n@Injectable()\nexport class PermissionGuard implements CanActivate {\n  constructor(\n    private reflector: Reflector,\n    private prisma: PrismaService,\n  ) {}\n\n  async canActivate(context: ExecutionContext): Promise<boolean> {\n    const requiredPermissions = this.reflector.getAllAndOverride<string[]>(PERMISSIONS_KEY, [\n      context.getHandler(),\n      context.getClass(),\n    ]);\n\n    if (!requiredPermissions) {\n      return true;\n    }\n\n    const { user, params } = context.switchToHttp().getRequest();\n    if (!user) return false;\n\n    const userPermissions = await this.prisma.role_permissions.findMany({\n      where: {\n        roleId: user.roleId,\n      },\n    });\n\n    return requiredPermissions.every(permission =>\n      userPermissions.some(up => up.permission === permission),\n    );\n  }\n}\n\n// guards/plan.guard.ejs\nimport { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';\nimport { Reflector } from '@nestjs/core';\nimport { PLAN_KEY } from '../decorators/plan.decorator';\nimport { PrismaService } from '../services/prisma.service';\n\n@Injectable()\nexport class PlanGuard implements CanActivate {\n  constructor(\n    private reflector: Reflector,\n    private prisma: PrismaService,\n  ) {}\n\n  async canActivate(context: ExecutionContext): Promise<boolean> {\n    const requiredPlans = this.reflector.getAllAndOverride<string[]>(PLAN_KEY, [\n      context.getHandler(),\n      context.getClass(),\n    ]);\n\n    if (!requiredPlans) {\n      return true;\n    }\n\n    const { user } = context.switchToHttp().getRequest();\n    if (!user) return false;\n\n    const userSubscription = await this.prisma.subscription.findFirst({\n      where: {\n        userId: user.id,\n        status: 'ACTIVE',\n      },\n      include: {\n        plan: true,\n      },\n    });\n\n    return requiredPlans.includes(userSubscription?.plan?.name);\n  }\n}\n"}
{"timestamp":"2024-12-16T07:22:56.567Z","action":"generateServices","data":"// core/services/prisma.service.ejs\nimport { Injectable, OnModuleInit, OnModuleDestroy } from '@nestjs/common';\nimport { PrismaClient } from '@prisma/client';\nimport { ConfigService } from './config.service';\n\n@Injectable()\nexport class PrismaService extends PrismaClient implements OnModuleInit, OnModuleDestroy {\n  constructor(private configService: ConfigService) {\n    super({\n      datasources: {\n        db: {\n          url: configService.get('DATABASE_URL'),\n        },\n      },\n      \n      \n    });\n    \n  }\n\n  async onModuleInit() {\n    await this.$connect();\n    \n  }\n\n  async onModuleDestroy() {\n    await this.$disconnect();\n  }\n\n  \n}import { Injectable } from '@nestjs/common';\nimport * as dotenv from 'dotenv';\n\n@Injectable()\nexport class ConfigService {\n  private readonly envConfig: { [key: string]: string };\n\n  constructor() {\n    dotenv.config();\n    this.envConfig = process.env;\n  }\n\n  get(key: string): string {\n    const value = this.envConfig[key];\n    if (!value) {\n      throw new Error(`Configuration key \"${key}\" is not defined`);\n    }\n    return value;\n  }\n\n  getOptional(key: string, defaultValue: string = ''): string {\n    return this.envConfig[key] || defaultValue;\n  }\n\n  getNumber(key: string): number {\n    const value = this.get(key);\n    const parsed = parseInt(value, 10);\n    if (isNaN(parsed)) {\n      throw new Error(`Configuration key \"${key}\" is not a valid number`);\n    }\n    return parsed;\n  }\n\n  getBoolean(key: string): boolean {\n    const value = this.get(key).toLowerCase();\n    return value === 'true' || value === '1';\n  }\n} import { Injectable, LoggerService as NestLoggerService } from '@nestjs/common';\n\n@Injectable()\nexport class LoggerService implements NestLoggerService {\n  log(message: string, context?: string) {\n    console.log(`[${context || 'LOG'}] ${message}`);\n  }\n\n  error(message: string, trace?: string, context?: string) {\n    console.error(`[${context || 'ERROR'}] ${message}`, trace);\n  }\n\n  warn(message: string, context?: string) {\n    console.warn(`[${context || 'WARN'}] ${message}`);\n  }\n\n  debug(message: string, context?: string) {\n    console.debug(`[${context || 'DEBUG'}] ${message}`);\n  }\n\n  verbose(message: string, context?: string) {\n    console.log(`[${context || 'VERBOSE'}] ${message}`);\n  }\n} // core/services/base.service.ts\nimport { Injectable } from '@nestjs/common';\nimport { PrismaClient, Prisma } from '@prisma/client';\nimport { PrismaService } from './prisma.service';\nimport { PaginationService } from './pagination.service';\nimport { PaginationParams } from '../dto/pagination.dto';\n\n@Injectable()\n@Injectable()\nexport abstract class BaseService<\n  Model,\n  CreateInput extends Prisma.TypeMap['model'][keyof Prisma.TypeMap['model']]['create']['data'],\n  UpdateInput extends Prisma.TypeMap['model'][keyof Prisma.TypeMap['model']]['update']['data'],\n> {\n  protected readonly prisma: PrismaClient;\n\n  constructor(\n    protected readonly prismaService: PrismaService,\n    protected readonly paginationService: PaginationService,\n    protected readonly modelName: keyof Prisma.TypeMap['model'],\n  ) {\n    this.prisma = this.prismaService;\n  }\n\n  protected get model(): Prisma.TypeMap['model'][typeof this.modelName] {\n    return this.prisma[this.modelName];\n  }\n\n  async findAll(query: PaginationParams & Partial<Model>): Promise<PaginatedResponse<Model>> {\n    const { page, limit, include, search, ...filters } = query;\n    const where = { ...filters };\n    const includes = include?.reduce((acc, rel) => ({ ...acc, [rel]: true }), {});\n\n    return this.executePrismaQuery(async () => {\n      const [data, total] = await Promise.all([\n        this.model.findMany({\n          where,\n          include: includes,\n          skip: (page - 1) * limit,\n          take: limit,\n        }),\n        this.model.count({ where }),\n      ]);\n\n      return this.paginationService.paginate(data, total, { page, limit });\n    });\n  }\n\n  async findOne(id: string, include?: string[]): Promise<Model | null> {\n    return this.executePrismaQuery(() =>\n      this.model.findUnique({\n        where: { id },\n        include: include?.reduce((acc, rel) => ({ ...acc, [rel]: true }), {}),\n      }),\n    );\n  }\n\n  async create(data: CreateInput): Promise<Model> {\n    return this.executePrismaQuery(() => this.model.create({ data }));\n  }\n\n  async update(id: string, data: UpdateInput): Promise<Model> {\n    return this.executePrismaQuery(() =>\n      this.model.update({\n        where: { id },\n        data,\n      }),\n    );\n  }\n\n  async remove(id: string): Promise<void> {\n    await this.executePrismaQuery(() => \n      this.model.delete({ where: { id } })\n    );\n  }\n\n  protected handleError(error: any): never {\n    console.error('Database operation failed:', error);\n\n    if (error instanceof Prisma.PrismaClientKnownRequestError) {\n      switch (error.code) {\n        case 'P2002':\n          throw new Error('Duplicate entry');\n        case 'P2003':\n          throw new Error('Referenced record not found');\n        case 'P2021':\n          throw new Error('Table not found');\n        case 'P2025':\n          throw new Error('Record not found');\n        case 'P2010':\n          throw new Error('Invalid query');\n        default:\n          throw new Error(`Database error: ${error.message}`);\n      }\n    }\n\n    if (error instanceof Prisma.PrismaClientValidationError) {\n      throw new Error(`Validation error: ${error.message}`);\n    }\n\n    if (error.code) {\n      switch (error.code) {\n        case '23505':\n          throw new Error('Duplicate entry');\n        case '23503':\n          throw new Error('Referenced record not found');\n        case '42P01':\n          throw new Error('Table not found');\n        case '42703':\n          throw new Error('Column not found');\n      }\n    }\n\n    throw new Error('An unexpected error occurred');\n  }\n\n  protected async executeQuery<R>(\n    operation: () => Promise<R | { data: R | null; error: any }>,\n  ): Promise<R> {\n    try {\n      const result = await operation();\n      return result as R;\n    } catch (error) {\n      return this.handleError(error);\n    }\n  }\n\n  protected async executePrismaQuery<R>(\n    operation: () => Promise<R>,\n  ): Promise<R> {\n    try {\n      return await operation();\n    } catch (error) {\n      return this.handleError(error);\n    }\n  }\n}"}
{"timestamp":"2024-12-16T07:22:56.568Z","action":"generatePipes","data":"// pipes/validation.pipe.ejs\nimport { PipeTransform, Injectable, ArgumentMetadata, BadRequestException } from '@nestjs/common';\nimport { validate } from 'class-validator';\nimport { plainToInstance } from 'class-transformer';\n\n@Injectable()\nexport class ValidationPipe implements PipeTransform<any> {\n  async transform(value: any, { metatype }: ArgumentMetadata) {\n    if (!metatype || !this.toValidate(metatype)) {\n      return value;\n    }\n    const object = plainToInstance(metatype, value);\n    const errors = await validate(object);\n    if (errors.length > 0) {\n      throw new BadRequestException('Validation failed');\n    }\n    return value;\n  }\n\n  private toValidate(metatype: Function): boolean {\n    const types: Function[] = [String, Boolean, Number, Array, Object];\n    return !types.includes(metatype);\n  }\n}\n// pipes/transformation.pipe.ejs\nimport { PipeTransform, Injectable, ArgumentMetadata } from '@nestjs/common';\n\n@Injectable()\nexport class TransformationPipe implements PipeTransform {\n  constructor(private readonly transformFn: (value: any) => any) {}\n\n  transform(value: any, metadata: ArgumentMetadata) {\n    return this.transformFn(value);\n  }\n}\n\n\n\n// pipes/type-conversion.pipe.ejs\nimport { PipeTransform, Injectable, ArgumentMetadata, BadRequestException } from '@nestjs/common';\n\n@Injectable()\nexport class TypeConversionPipe implements PipeTransform {\n  constructor(private readonly targetType: 'number' | 'boolean' | 'string') {}\n\n  transform(value: any, metadata: ArgumentMetadata) {\n    if (value === undefined) return value;\n\n    try {\n      switch (this.targetType) {\n        case 'number':\n          return Number(value);\n        case 'boolean':\n          return value === 'true' || value === '1' || value === true;\n        case 'string':\n          return String(value);\n        default:\n          return value;\n      }\n    } catch (error) {\n      throw new BadRequestException(`Type conversion failed: ${error.message}`);\n    }\n  }\n}// pipes/trim.pipe.ejs\nimport { PipeTransform, Injectable, ArgumentMetadata } from '@nestjs/common';\n\n@Injectable()\nexport class TrimPipe implements PipeTransform {\n  transform(value: any, metadata: ArgumentMetadata) {\n    if (!value) return value;\n\n    if (typeof value === 'string') {\n      return value.trim();\n    }\n\n    if (Array.isArray(value)) {\n      return value.map(item => \n        typeof item === 'string' ? item.trim() : item\n      );\n    }\n\n    if (typeof value === 'object') {\n      return Object.keys(value).reduce((acc, key) => ({\n        ...acc,\n        [key]: typeof value[key] === 'string' ? value[key].trim() : value[key]\n      }), {});\n    }\n\n    return value;\n  }\n}"}
{"timestamp":"2024-12-16T07:22:56.568Z","action":"generatecore/dto/pagination.dto.ejs","data":"import { IsOptional, IsNumber, IsString } from 'class-validator';\nimport { Type } from 'class-transformer';\n\nexport class PaginationParams {\n  @IsOptional()\n  @IsNumber()\n  @Type(() => Number)\n  page?: number = 1;\n\n  @IsOptional()\n  @IsNumber()\n  @Type(() => Number)\n  limit?: number = 10;\n\n  @IsOptional()\n  @IsString()\n  sort?: string;\n}"}
{"timestamp":"2024-12-16T07:22:56.568Z","action":"generateDecorators","data":"// decorators/roles.decorator.ejs\nimport { SetMetadata } from '@nestjs/common';\n\nexport const ROLES_KEY = 'roles';\nexport const Roles = (...roles: string[]) => SetMetadata(ROLES_KEY, roles);\n// decorators/permissions.decorator.ejs\nimport { SetMetadata } from '@nestjs/common';\n\nexport const PERMISSIONS_KEY = 'permissions';\nexport const RequirePermissions = (...permissions: string[]) =>\n  SetMetadata(PERMISSIONS_KEY, permissions);// decorators/plan.decorator.ejs\nimport { SetMetadata } from '@nestjs/common';\n\nexport const PLAN_KEY = 'plan';\nexport const RequirePlan = (...plans: string[]) => SetMetadata(PLAN_KEY, plans);\n// decorators/validate.decorator.ejs\nimport { registerDecorator, ValidationOptions, ValidationArguments } from 'class-validator';\n\nexport function IsCustomValue(property: string, validationOptions?: ValidationOptions) {\n  return function (object: Object, propertyName: string) {\n    registerDecorator({\n      name: 'isCustomValue',\n      target: object.constructor,\n      propertyName: propertyName,\n      constraints: [property],\n      options: validationOptions,\n      validator: {\n        validate(value: any, args: ValidationArguments) {\n          const [relatedPropertyName] = args.constraints;\n          const relatedValue = (args.object as any)[relatedPropertyName];\n          return typeof value === 'string' && typeof relatedValue === 'string';\n        },\n      },\n    });\n  };\n}\n\n// decorators/current-user.decorator.ejs\nimport { createParamDecorator, ExecutionContext } from '@nestjs/common';\n\nexport const CurrentUser = createParamDecorator((data: unknown, ctx: ExecutionContext) => {\n  const request = ctx.switchToHttp().getRequest();\n  return request.user;\n});\n"}
{"timestamp":"2024-12-16T07:22:56.568Z","action":"generatecore/interceptors/pagination.interceptor.ejs","data":"// templates/core/interceptors/pagination.interceptor.ejs\nimport { Injectable, NestInterceptor, ExecutionContext, CallHandler } from '@nestjs/common';\nimport { Observable } from 'rxjs';\nimport { map } from 'rxjs/operators';\nimport { PaginatedResponse } from '../types/pagination.types';\n\n@Injectable()\nexport class PaginationInterceptor<T> implements NestInterceptor<T, PaginatedResponse<T>> {\n  intercept(context: ExecutionContext, next: CallHandler): Observable<PaginatedResponse<T>> {\n    return next.handle().pipe(\n      map(data => {\n        // If data is already paginated, return as is\n        if (this.isPaginated(data)) {\n          return data;\n        }\n\n        // Get pagination params from request query\n        const request = context.switchToHttp().getRequest();\n        const { page = 1, limit = 10 } = request.query;\n\n        // If data is an array, paginate it\n        if (Array.isArray(data)) {\n          const total = data.length;\n          const totalPages = Math.ceil(total / limit);\n          const start = (page - 1) * limit;\n          const end = start + limit;\n\n          return {\n            data: data.slice(start, end),\n            meta: {\n              total,\n              page: Number(page),\n              limit: Number(limit),\n              totalPages\n            }\n          };\n        }\n\n        // If not an array, wrap in paginated response\n        return {\n          data: [data],\n          meta: {\n            total: 1,\n            page: 1,\n            limit: 1,\n            totalPages: 1\n          }\n        };\n      })\n    );\n  }\n\n  private isPaginated(data: any): data is PaginatedResponse<T> {\n    return (\n      data &&\n      'data' in data &&\n      'meta' in data &&\n      'total' in data.meta &&\n      'page' in data.meta &&\n      'limit' in data.meta &&\n      'totalPages' in data.meta\n    );\n  }\n}"}
{"timestamp":"2024-12-16T07:25:20.019Z","action":"generateControllers","data":"// base.controller.ts\nimport { Injectable, UnauthorizedException } from '@nestjs/common';\nimport { Request } from 'express';\nimport { verify } from 'jsonwebtoken';\nimport { Prisma, app_role_enum } from '@prisma/client';\nimport { PrismaService } from '../services/prisma.service';\nimport { ConfigService } from '../services/config.service';\nimport { PaginatedResponse } from '../types/pagination.types';\nimport { PaginationService } from '../services/pagination.service';\n\n@Injectable()\nexport abstract class BaseController {\n  protected abstract readonly modelName: keyof Prisma.TypeMap['model'];\n\n  constructor(\n    protected readonly prisma: PrismaService,\n    protected readonly config: ConfigService,\n    protected readonly paginationService: PaginationService\n  ) {}\n\n  protected get model(): any {\n    return this.prisma[this.modelName];\n  }\n\n  async findAll(query: PaginatedQuery) {\n    const { page = 1, limit = 10, include, ...filters } = query;\n    const includes = include?.reduce((acc, rel) => ({ ...acc, [rel]: true }), {});\n\n    const [data, total] = await Promise.all([\n      this.model.findMany({\n        where: filters,\n        include: includes,\n        skip: (page - 1) * limit,\n        take: limit,\n      }),\n      this.model.count({ where: filters }),\n    ]);\n\n    return this.handlePaginatedSuccess(data, this.paginationService.getPaginationMeta(total, page, limit));\n  }\n\n  async findOne(id: string, include?: string[]) {\n    const includes = include?.reduce((acc, rel) => ({ ...acc, [rel]: true }), {});\n    const data = await this.model.findUnique({\n      where: { id },\n      include: includes,\n    });\n    return this.handleSuccess(data);\n  }\n\n  async create(data: unknown) {\n    const result = await this.model.create({ data });\n    return this.handleSuccess(result);\n  }\n\n  async update(id: string, data: unknown) {\n    const result = await this.model.update({\n      where: { id },\n      data,\n    });\n    return this.handleSuccess(result);\n  }\n\n  async remove(id: string) {\n    await this.model.delete({ where: { id } });\n    return this.handleSuccess({ id });\n  }\n\n  protected async getUserFromRequest(req: Request) {\n    const authHeader = req.headers.authorization;\n    if (!authHeader) {\n      throw new UnauthorizedException('No authorization header');\n    }\n\n    const token = authHeader.replace('Bearer ', '');\n    try {\n      const decoded = verify(token, this.config.get('JWT_SECRET')) as { userId: string };\n      \n      const user = await this.prisma.user_profiles.findUnique({\n        where: { id: decoded.userId },\n        select: {\n          id: true,\n          email: true,\n          role: true,\n          is_active: true,\n        }\n      });\n\n      if (!user || !user.is_active) {\n        throw new UnauthorizedException('Invalid or inactive user');\n      }\n\n      return user;\n    } catch (error) {\n      throw new UnauthorizedException('Invalid token');\n    }\n  }\n\n  protected async validateRequest(req: Request) {\n    const user = await this.getUserFromRequest(req);\n    if (!user) {\n      throw new UnauthorizedException('Unauthorized');\n    }\n    return user;\n  }\n\n  protected async checkPermission(userRole: app_role_enum) {\n    const permission = await this.prisma.role_permissions.findFirst({\n      where: {\n        role: userRole,\n        table_name: this.modelName,\n      }\n    });\n\n    if (!permission) {\n      throw new UnauthorizedException('Insufficient permissions');\n    }\n  }\n\n  protected handleSuccess<R>(data: R) {\n    return {\n      success: true,\n      data,\n      timestamp: new Date().toISOString(),\n    };\n  }\n\n  protected handlePaginatedSuccess<R>(data: R[], meta: any) {\n    const paginatedResponse: PaginatedResponse<R> = {\n      data,\n      meta,\n      success: true,\n      timestamp: new Date().toISOString()\n    };\n    return paginatedResponse;\n  }\n\n  protected handleError(error: any) {\n    console.error('Error:', error);\n    return {\n      success: false,\n      error: error.message || 'An unexpected error occurred',\n      timestamp: new Date().toISOString(),\n      code: error.code || 'UNKNOWN_ERROR'\n    };\n  }\n}"}
{"timestamp":"2024-12-16T07:25:20.019Z","action":"generateMiddleware","data":"// auth.middleware.ejs\nimport { Injectable, NestMiddleware, UnauthorizedException, ForbiddenException } from '@nestjs/common';\nimport { app_plan_enum, app_role_enum } from '@prisma/client';\nimport { Request, Response, NextFunction } from 'express';\nimport { PrismaService } from '../services/prisma.service';\nimport { ConfigService } from '../services/config.service';\n\ninterface MaterializedPermissions {\n  [tableName: string]: {\n    select: boolean;\n    insert: boolean;\n    update: boolean;\n    delete: boolean;\n  }\n}\n\ninterface UserProfile {\n  id: string;\n  email: string;\n  role: app_role_enum;\n  plan: app_plan_enum;\n  is_active?: boolean;\n}\n\n@Injectable()\nexport class AuthMiddleware implements NestMiddleware {\n  constructor(\n    private readonly prisma: PrismaService,\n    private readonly config: ConfigService\n  ) {}\n\n  async use(req: Request, res: Response, next: NextFunction) {\n    try {\n      // Get the token from Supabase Auth\n      const token = this.extractToken(req);\n      \n      // Get user profile using the token's email\n      const user = await this.getUserProfile(token.email);\n      \n      // Get materialized permissions for the user's role\n      const permissions = await this.getMaterializedPermissions(user.role);\n      \n      // Check if user has permission for this operation\n      const hasPermission = await this.checkPermission(\n        req.method,\n        this.getTableNameFromPath(req.path),\n        permissions\n      );\n\n      if (!hasPermission) {\n        throw new ForbiddenException('Insufficient permissions');\n      }\n\n      // Attach user and permissions to request\n      (req as any).user = user;\n      (req as any).permissions = permissions;\n\n      next();\n    } catch (error: any) {\n      this.handleError(res, error);\n    }\n  }\n\n  private async getUserProfile(email: string): Promise<UserProfile> {\n    const profile = await this.prisma.user_profiles.findUnique({\n      where: { email },\n      select: {\n        id: true,\n        email: true,\n        role: true,\n        plan: true,\n        last_seen: true\n      }\n    });\n\n    if (!profile) {\n      throw new UnauthorizedException('User profile not found');\n    }\n\n    return profile;\n  }\n\n  private async getMaterializedPermissions(role: app_role_enum): Promise<MaterializedPermissions> {\n    const materializedPerms = await this.prisma.role_permissions_materialized.findUnique({\n      where: { role }\n    });\n\n    if (!materializedPerms) {\n      throw new ForbiddenException('No permissions found for role');\n    }\n\n    return materializedPerms.permissions as MaterializedPermissions;\n  }\n\n  private checkPermission(\n    method: string,\n    tableName: string,\n    permissions: MaterializedPermissions\n  ): boolean {\n    const tablePermissions = permissions[tableName];\n    if (!tablePermissions) return false;\n\n    // Map HTTP methods to permission types\n    const methodPermissionMap = {\n      'GET': 'select',\n      'POST': 'insert',\n      'PUT': 'update',\n      'PATCH': 'update',\n      'DELETE': 'delete'\n    };\n\n    const requiredPermission = methodPermissionMap[method];\n    return tablePermissions[requiredPermission] || false;\n  }\n\n  private getTableNameFromPath(path: string): string {\n    // Extract table name from path (e.g., /api/user_profiles -> user_profiles)\n    const parts = path.split('/').filter(Boolean);\n    return parts[parts.length - 1];\n  }\n\n  private extractToken(req: Request): { email: string } {\n    const authHeader = req.headers.authorization;\n    if (!authHeader) {\n      throw new UnauthorizedException('No authorization header');\n    }\n\n    // Here you would actually decode and verify the Supabase JWT\n    // This is just a placeholder - you'll need to implement proper JWT verification\n    const token = authHeader.replace('Bearer ', '');\n    try {\n      // You'll need to implement proper Supabase token validation here\n      return { email: 'placeholder' }; // Replace with actual token decode\n    } catch (error: any) {\n      throw new UnauthorizedException('Invalid token', error.message);\n    }\n  }\n\n  private handleError(res: Response, error: any) {\n    const status = error instanceof UnauthorizedException ? 401 : \n                   error instanceof ForbiddenException ? 403 : 500;\n\n    res.status(status).json({\n      success: false,\n      error: error.message || 'Authentication error',\n      timestamp: new Date().toISOString(),\n    });\n  }\n}"}
{"timestamp":"2024-12-16T07:25:20.020Z","action":"generatecore/types/pagination.types.ejs","data":"export interface PaginatedResponse<T> {\n  data: T[];\n  meta: {\n    total: number;\n    page: number;\n    limit: number;\n    totalPages: number;\n  };\n  success: boolean;\n  timestamp: string;\n}\n\nexport interface PaginationMeta {\n  total: number;\n  page: number;\n  limit: number;\n  totalPages: number;\n}\n\nexport interface PaginatedQuery {\n  page?: number;\n  limit?: number;\n  search?: string;\n  sortBy?: string;\n  sortOrder?: 'asc' | 'desc';\n}\n"}
{"timestamp":"2024-12-16T07:25:20.021Z","action":"generateUtils","data":"// utils/auth.utils.ejs\nimport { UnauthorizedException } from '@nestjs/common';\nimport { verify } from 'jsonwebtoken';\n\nexport class AuthUtils {\n  static verifyToken(token: string, secret: string): any {\n    try {\n      return verify(token, secret);\n    } catch (error) {\n      throw new UnauthorizedException('Invalid token');\n    }\n  }\n\n  static extractTokenFromHeader(authHeader: string): string {\n    if (!authHeader) {\n      throw new UnauthorizedException('No authorization header');\n    }\n    const [type, token] = authHeader.split(' ');\n    if (type !== 'Bearer') {\n      throw new UnauthorizedException('Invalid authorization type');\n    }\n    return token;\n  }\n}\n// utils/permission.utils.ejs\nexport class PermissionUtils {\n  static canAccess(userPermissions: string[], requiredPermissions: string[]): boolean {\n    return requiredPermissions.every(required =>\n      userPermissions.some(userPerm => this.matchPermission(userPerm, required)),\n    );\n  }\n\n  private static matchPermission(userPerm: string, required: string): boolean {\n    const userParts = userPerm.split(':');\n    const requiredParts = required.split(':');\n\n    if (userParts[0] === '*') return true;\n    if (userParts.length !== requiredParts.length) return false;\n\n    return userParts.every((part, i) => part === '*' || part === requiredParts[i]);\n  }\n}\n"}
{"timestamp":"2024-12-16T07:25:20.021Z","action":"generateTypes","data":"// types/permission.types.ejs\nexport enum PermissionAction {\n  CREATE = 'CREATE',\n  READ = 'READ',\n  UPDATE = 'UPDATE',\n  DELETE = 'DELETE',\n  MANAGE = 'MANAGE'\n}\n\nexport enum ResourceType {\n  USER = 'USER',\n  CONTENT = 'CONTENT',\n  SETTINGS = 'SETTINGS',\n  BILLING = 'BILLING'\n}\n\nexport interface Permission {\n  action: PermissionAction;\n  resource: ResourceType;\n  conditions?: Record<string, any>;\n}\n\n// types/plan.types.ejs\nexport enum PlanType {\n  FREE = 'FREE',\n  BASIC = 'BASIC',\n  PREMIUM = 'PREMIUM',\n  ENTERPRISE = 'ENTERPRISE'\n}\n\nexport interface PlanFeature {\n  name: string;\n  limit?: number;\n  enabled: boolean;\n}\n\nexport interface Plan {\n  id: string;\n  name: string;\n  type: PlanType;\n  features: PlanFeature[];\n  price: number;\n}"}
{"timestamp":"2024-12-16T07:25:20.021Z","action":"generatecore/services/pagination.service.ejs","data":"import { Injectable } from '@nestjs/common';\nimport { PaginatedResponse, PaginationMeta } from '../types/pagination.types';\nimport { PaginationParams } from '../dto/pagination.dto';\n\n@Injectable()\nexport class PaginationService {\n  paginate<T>(data: T[], count: number, params: PaginationParams): PaginatedResponse<T> {\n    const { page = 1, limit = 10 } = params;\n    const totalPages = Math.ceil(count / limit);\n\n    const meta: PaginationMeta = {\n      total: count,\n      page,\n      limit,\n      totalPages,\n    };\n\n    return { data, meta };\n  }\n\n  getPaginationParams(params: PaginationParams): { skip: number; take: number } {\n    const page = params.page || 1;\n    const limit = params.limit || 10;\n    return {\n      skip: (page - 1) * limit,\n      take: limit,\n    };\n  }\n}"}
{"timestamp":"2024-12-16T07:25:20.022Z","action":"generateGuards","data":"// guards/roles.guard.ejs\nimport { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';\nimport { Reflector } from '@nestjs/core';\nimport { ROLES_KEY } from '../decorators/roles.decorator';\n\n@Injectable()\nexport class RolesGuard implements CanActivate {\n  constructor(private reflector: Reflector) {}\n\n  canActivate(context: ExecutionContext): boolean {\n    const requiredRoles = this.reflector.getAllAndOverride<string[]>(ROLES_KEY, [\n      context.getHandler(),\n      context.getClass(),\n    ]);\n    if (!requiredRoles) {\n      return true;\n    }\n    const { user } = context.switchToHttp().getRequest();\n    return requiredRoles.some(role => user.roles?.includes(role));\n  }\n}\n// guards/permissions.guard.ejs\nimport { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';\nimport { Reflector } from '@nestjs/core';\nimport { PERMISSIONS_KEY } from '../decorators/permissions.decorator';\nimport { PrismaService } from '../services/prisma.service';\n\n@Injectable()\nexport class PermissionGuard implements CanActivate {\n  constructor(\n    private reflector: Reflector,\n    private prisma: PrismaService,\n  ) {}\n\n  async canActivate(context: ExecutionContext): Promise<boolean> {\n    const requiredPermissions = this.reflector.getAllAndOverride<string[]>(PERMISSIONS_KEY, [\n      context.getHandler(),\n      context.getClass(),\n    ]);\n\n    if (!requiredPermissions) {\n      return true;\n    }\n\n    const { user, params } = context.switchToHttp().getRequest();\n    if (!user) return false;\n\n    const userPermissions = await this.prisma.role_permissions.findMany({\n      where: {\n        roleId: user.roleId,\n      },\n    });\n\n    return requiredPermissions.every(permission =>\n      userPermissions.some(up => up.permission === permission),\n    );\n  }\n}\n\n// guards/plan.guard.ejs\nimport { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';\nimport { Reflector } from '@nestjs/core';\nimport { PLAN_KEY } from '../decorators/plan.decorator';\nimport { PrismaService } from '../services/prisma.service';\n\n@Injectable()\nexport class PlanGuard implements CanActivate {\n  constructor(\n    private reflector: Reflector,\n    private prisma: PrismaService,\n  ) {}\n\n  async canActivate(context: ExecutionContext): Promise<boolean> {\n    const requiredPlans = this.reflector.getAllAndOverride<string[]>(PLAN_KEY, [\n      context.getHandler(),\n      context.getClass(),\n    ]);\n\n    if (!requiredPlans) {\n      return true;\n    }\n\n    const { user } = context.switchToHttp().getRequest();\n    if (!user) return false;\n\n    const userSubscription = await this.prisma.subscription.findFirst({\n      where: {\n        userId: user.id,\n        status: 'ACTIVE',\n      },\n      include: {\n        plan: true,\n      },\n    });\n\n    return requiredPlans.includes(userSubscription?.plan?.name);\n  }\n}\n"}
{"timestamp":"2024-12-16T07:25:20.023Z","action":"generateServices","data":"// core/services/prisma.service.ejs\nimport { Injectable, OnModuleInit, OnModuleDestroy } from '@nestjs/common';\nimport { PrismaClient } from '@prisma/client';\nimport { ConfigService } from './config.service';\n\n@Injectable()\nexport class PrismaService extends PrismaClient implements OnModuleInit, OnModuleDestroy {\n  constructor(private configService: ConfigService) {\n    super({\n      datasources: {\n        db: {\n          url: configService.get('DATABASE_URL'),\n        },\n      },\n      \n      \n    });\n    \n  }\n\n  async onModuleInit() {\n    await this.$connect();\n    \n  }\n\n  async onModuleDestroy() {\n    await this.$disconnect();\n  }\n\n  \n}import { Injectable } from '@nestjs/common';\nimport * as dotenv from 'dotenv';\n\n@Injectable()\nexport class ConfigService {\n  private readonly envConfig: { [key: string]: string };\n\n  constructor() {\n    dotenv.config();\n    this.envConfig = process.env;\n  }\n\n  get(key: string): string {\n    const value = this.envConfig[key];\n    if (!value) {\n      throw new Error(`Configuration key \"${key}\" is not defined`);\n    }\n    return value;\n  }\n\n  getOptional(key: string, defaultValue: string = ''): string {\n    return this.envConfig[key] || defaultValue;\n  }\n\n  getNumber(key: string): number {\n    const value = this.get(key);\n    const parsed = parseInt(value, 10);\n    if (isNaN(parsed)) {\n      throw new Error(`Configuration key \"${key}\" is not a valid number`);\n    }\n    return parsed;\n  }\n\n  getBoolean(key: string): boolean {\n    const value = this.get(key).toLowerCase();\n    return value === 'true' || value === '1';\n  }\n} import { Injectable, LoggerService as NestLoggerService } from '@nestjs/common';\n\n@Injectable()\nexport class LoggerService implements NestLoggerService {\n  log(message: string, context?: string) {\n    console.log(`[${context || 'LOG'}] ${message}`);\n  }\n\n  error(message: string, trace?: string, context?: string) {\n    console.error(`[${context || 'ERROR'}] ${message}`, trace);\n  }\n\n  warn(message: string, context?: string) {\n    console.warn(`[${context || 'WARN'}] ${message}`);\n  }\n\n  debug(message: string, context?: string) {\n    console.debug(`[${context || 'DEBUG'}] ${message}`);\n  }\n\n  verbose(message: string, context?: string) {\n    console.log(`[${context || 'VERBOSE'}] ${message}`);\n  }\n} // core/services/base.service.ts\nimport { Injectable } from '@nestjs/common';\nimport { PrismaClient, Prisma } from '@prisma/client';\nimport { PrismaService } from './prisma.service';\nimport { PaginationService } from './pagination.service';\nimport { PaginationParams } from '../dto/pagination.dto';\n\n@Injectable()\n@Injectable()\nexport abstract class BaseService<\n  Model,\n  CreateInput extends Prisma.TypeMap['model'][keyof Prisma.TypeMap['model']]['create']['data'],\n  UpdateInput extends Prisma.TypeMap['model'][keyof Prisma.TypeMap['model']]['update']['data'],\n> {\n  protected readonly prisma: PrismaClient;\n\n  constructor(\n    protected readonly prismaService: PrismaService,\n    protected readonly paginationService: PaginationService,\n    protected readonly modelName: keyof Prisma.TypeMap['model'],\n  ) {\n    this.prisma = this.prismaService;\n  }\n\n  protected get model(): Prisma.TypeMap['model'][typeof this.modelName] {\n    return this.prisma[this.modelName];\n  }\n\n  async findAll(query: PaginationParams & Partial<Model>): Promise<PaginatedResponse<Model>> {\n    const { page, limit, include, search, ...filters } = query;\n    const where = { ...filters };\n    const includes = include?.reduce((acc, rel) => ({ ...acc, [rel]: true }), {});\n\n    return this.executePrismaQuery(async () => {\n      const [data, total] = await Promise.all([\n        this.model.findMany({\n          where,\n          include: includes,\n          skip: (page - 1) * limit,\n          take: limit,\n        }),\n        this.model.count({ where }),\n      ]);\n\n      return this.paginationService.paginate(data, total, { page, limit });\n    });\n  }\n\n  async findOne(id: string, include?: string[]): Promise<Model | null> {\n    return this.executePrismaQuery(() =>\n      this.model.findUnique({\n        where: { id },\n        include: include?.reduce((acc, rel) => ({ ...acc, [rel]: true }), {}),\n      }),\n    );\n  }\n\n  async create(data: CreateInput): Promise<Model> {\n    return this.executePrismaQuery(() => this.model.create({ data }));\n  }\n\n  async update(id: string, data: UpdateInput): Promise<Model> {\n    return this.executePrismaQuery(() =>\n      this.model.update({\n        where: { id },\n        data,\n      }),\n    );\n  }\n\n  async remove(id: string): Promise<void> {\n    await this.executePrismaQuery(() => \n      this.model.delete({ where: { id } })\n    );\n  }\n\n  protected handleError(error: any): never {\n    console.error('Database operation failed:', error);\n\n    if (error instanceof Prisma.PrismaClientKnownRequestError) {\n      switch (error.code) {\n        case 'P2002':\n          throw new Error('Duplicate entry');\n        case 'P2003':\n          throw new Error('Referenced record not found');\n        case 'P2021':\n          throw new Error('Table not found');\n        case 'P2025':\n          throw new Error('Record not found');\n        case 'P2010':\n          throw new Error('Invalid query');\n        default:\n          throw new Error(`Database error: ${error.message}`);\n      }\n    }\n\n    if (error instanceof Prisma.PrismaClientValidationError) {\n      throw new Error(`Validation error: ${error.message}`);\n    }\n\n    if (error.code) {\n      switch (error.code) {\n        case '23505':\n          throw new Error('Duplicate entry');\n        case '23503':\n          throw new Error('Referenced record not found');\n        case '42P01':\n          throw new Error('Table not found');\n        case '42703':\n          throw new Error('Column not found');\n      }\n    }\n\n    throw new Error('An unexpected error occurred');\n  }\n\n  protected async executeQuery<R>(\n    operation: () => Promise<R | { data: R | null; error: any }>,\n  ): Promise<R> {\n    try {\n      const result = await operation();\n      return result as R;\n    } catch (error) {\n      return this.handleError(error);\n    }\n  }\n\n  protected async executePrismaQuery<R>(\n    operation: () => Promise<R>,\n  ): Promise<R> {\n    try {\n      return await operation();\n    } catch (error) {\n      return this.handleError(error);\n    }\n  }\n}"}
{"timestamp":"2024-12-16T07:25:20.023Z","action":"generatePipes","data":"// pipes/validation.pipe.ejs\nimport { PipeTransform, Injectable, ArgumentMetadata, BadRequestException } from '@nestjs/common';\nimport { validate } from 'class-validator';\nimport { plainToInstance } from 'class-transformer';\n\n@Injectable()\nexport class ValidationPipe implements PipeTransform<any> {\n  async transform(value: any, { metatype }: ArgumentMetadata) {\n    if (!metatype || !this.toValidate(metatype)) {\n      return value;\n    }\n    const object = plainToInstance(metatype, value);\n    const errors = await validate(object);\n    if (errors.length > 0) {\n      throw new BadRequestException('Validation failed');\n    }\n    return value;\n  }\n\n  private toValidate(metatype: Function): boolean {\n    const types: Function[] = [String, Boolean, Number, Array, Object];\n    return !types.includes(metatype);\n  }\n}\n// pipes/transformation.pipe.ejs\nimport { PipeTransform, Injectable, ArgumentMetadata } from '@nestjs/common';\n\n@Injectable()\nexport class TransformationPipe implements PipeTransform {\n  constructor(private readonly transformFn: (value: any) => any) {}\n\n  transform(value: any, metadata: ArgumentMetadata) {\n    return this.transformFn(value);\n  }\n}\n\n\n\n// pipes/type-conversion.pipe.ejs\nimport { PipeTransform, Injectable, ArgumentMetadata, BadRequestException } from '@nestjs/common';\n\n@Injectable()\nexport class TypeConversionPipe implements PipeTransform {\n  constructor(private readonly targetType: 'number' | 'boolean' | 'string') {}\n\n  transform(value: any, metadata: ArgumentMetadata) {\n    if (value === undefined) return value;\n\n    try {\n      switch (this.targetType) {\n        case 'number':\n          return Number(value);\n        case 'boolean':\n          return value === 'true' || value === '1' || value === true;\n        case 'string':\n          return String(value);\n        default:\n          return value;\n      }\n    } catch (error) {\n      throw new BadRequestException(`Type conversion failed: ${error.message}`);\n    }\n  }\n}// pipes/trim.pipe.ejs\nimport { PipeTransform, Injectable, ArgumentMetadata } from '@nestjs/common';\n\n@Injectable()\nexport class TrimPipe implements PipeTransform {\n  transform(value: any, metadata: ArgumentMetadata) {\n    if (!value) return value;\n\n    if (typeof value === 'string') {\n      return value.trim();\n    }\n\n    if (Array.isArray(value)) {\n      return value.map(item => \n        typeof item === 'string' ? item.trim() : item\n      );\n    }\n\n    if (typeof value === 'object') {\n      return Object.keys(value).reduce((acc, key) => ({\n        ...acc,\n        [key]: typeof value[key] === 'string' ? value[key].trim() : value[key]\n      }), {});\n    }\n\n    return value;\n  }\n}"}
{"timestamp":"2024-12-16T07:25:20.023Z","action":"generatecore/dto/pagination.dto.ejs","data":"import { IsOptional, IsNumber, IsString } from 'class-validator';\nimport { Type } from 'class-transformer';\n\nexport class PaginationParams {\n  @IsOptional()\n  @IsNumber()\n  @Type(() => Number)\n  page?: number = 1;\n\n  @IsOptional()\n  @IsNumber()\n  @Type(() => Number)\n  limit?: number = 10;\n\n  @IsOptional()\n  @IsString()\n  sort?: string;\n}"}
{"timestamp":"2024-12-16T07:25:20.024Z","action":"generatecore/interceptors/pagination.interceptor.ejs","data":"// templates/core/interceptors/pagination.interceptor.ejs\nimport { Injectable, NestInterceptor, ExecutionContext, CallHandler } from '@nestjs/common';\nimport { Observable } from 'rxjs';\nimport { map } from 'rxjs/operators';\nimport { PaginatedResponse } from '../types/pagination.types';\n\n@Injectable()\nexport class PaginationInterceptor<T> implements NestInterceptor<T, PaginatedResponse<T>> {\n  intercept(context: ExecutionContext, next: CallHandler): Observable<PaginatedResponse<T>> {\n    return next.handle().pipe(\n      map(data => {\n        // If data is already paginated, return as is\n        if (this.isPaginated(data)) {\n          return data;\n        }\n\n        // Get pagination params from request query\n        const request = context.switchToHttp().getRequest();\n        const { page = 1, limit = 10 } = request.query;\n\n        // If data is an array, paginate it\n        if (Array.isArray(data)) {\n          const total = data.length;\n          const totalPages = Math.ceil(total / limit);\n          const start = (page - 1) * limit;\n          const end = start + limit;\n\n          return {\n            data: data.slice(start, end),\n            meta: {\n              total,\n              page: Number(page),\n              limit: Number(limit),\n              totalPages\n            }\n          };\n        }\n\n        // If not an array, wrap in paginated response\n        return {\n          data: [data],\n          meta: {\n            total: 1,\n            page: 1,\n            limit: 1,\n            totalPages: 1\n          }\n        };\n      })\n    );\n  }\n\n  private isPaginated(data: any): data is PaginatedResponse<T> {\n    return (\n      data &&\n      'data' in data &&\n      'meta' in data &&\n      'total' in data.meta &&\n      'page' in data.meta &&\n      'limit' in data.meta &&\n      'totalPages' in data.meta\n    );\n  }\n}"}
{"timestamp":"2024-12-16T07:25:20.024Z","action":"generateDecorators","data":"// decorators/roles.decorator.ejs\nimport { SetMetadata } from '@nestjs/common';\n\nexport const ROLES_KEY = 'roles';\nexport const Roles = (...roles: string[]) => SetMetadata(ROLES_KEY, roles);\n// decorators/permissions.decorator.ejs\nimport { SetMetadata } from '@nestjs/common';\n\nexport const PERMISSIONS_KEY = 'permissions';\nexport const RequirePermissions = (...permissions: string[]) =>\n  SetMetadata(PERMISSIONS_KEY, permissions);// decorators/plan.decorator.ejs\nimport { SetMetadata } from '@nestjs/common';\n\nexport const PLAN_KEY = 'plan';\nexport const RequirePlan = (...plans: string[]) => SetMetadata(PLAN_KEY, plans);\n// decorators/validate.decorator.ejs\nimport { registerDecorator, ValidationOptions, ValidationArguments } from 'class-validator';\n\nexport function IsCustomValue(property: string, validationOptions?: ValidationOptions) {\n  return function (object: Object, propertyName: string) {\n    registerDecorator({\n      name: 'isCustomValue',\n      target: object.constructor,\n      propertyName: propertyName,\n      constraints: [property],\n      options: validationOptions,\n      validator: {\n        validate(value: any, args: ValidationArguments) {\n          const [relatedPropertyName] = args.constraints;\n          const relatedValue = (args.object as any)[relatedPropertyName];\n          return typeof value === 'string' && typeof relatedValue === 'string';\n        },\n      },\n    });\n  };\n}\n\n// decorators/current-user.decorator.ejs\nimport { createParamDecorator, ExecutionContext } from '@nestjs/common';\n\nexport const CurrentUser = createParamDecorator((data: unknown, ctx: ExecutionContext) => {\n  const request = ctx.switchToHttp().getRequest();\n  return request.user;\n});\n"}
