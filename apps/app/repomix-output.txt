================================================================
Directory Structure
================================================================
components/
  bookmark/
    BookmarkButton.vue
    BookmarkCard.vue
    BookmarkGridAnimated.vue
    BookmarkViewFolder.vue
  companies/
    CompaniesCell.vue
    CompaniesComingSoon.vue
    CompaniesScrolling.vue
    CompaniesSkeleton.vue
    CompaniesTable.vue
  company/
    CompanyCard.vue
    CompanyCardSkeleton.vue
  feed/
    FeedGrid.vue
    FeedHot.vue
    FeedHotToggle.vue
    FeedRecent.vue
    FeedSkeleton.vue
    FeedTitle.vue
  nav/
    NavAppTop.vue
    NavMobiBottom.vue
    NavMobiSlideover.vue
  news/
    NewsActions.vue
    NewsCard.vue
    NewsCardSkeleton.vue
    NewsModal.vue
    NewsSummaryLevel.vue
  post/
    PostCard.vue
  research/
    ResearchCard.vue
  search/
    SearchBar.vue
  vote/
    VoteAnimate.vue
    VoteButton.vue
  AppBackButton.vue
  BlackFridayBanner.client.vue
  ConfirmationDialog.vue
  DeleteConfirmation.vue
  EmptyState.vue
  FeatureRanking.vue
  FrontiersMessage.vue
  FuzzySearch.vue
  LoadingState.vue
  PaymentButton.vue
  RoleOverride.vue
  TestSelect.vue
  TurnstileChallenge.client.vue
  UploadCropper.vue
composables/
  users/
    user-settings.store.ts
    user.admin.composable.ts
  category-tags.store.ts
  chat.store.ts
  chunks.store.ts
  feedback.store.ts
  onboarding.composable.ts
  useBookmarkManager.ts
  useBookmarkStore.ts
  useBookmarkView.ts
  useEvents.ts
  useFeatureRequestStore.ts
  useFeatureSurvey.ts
  useFeedNavigation.ts
  useFolderStore.ts
  usePages.ts
  usePayments.ts
  usePlan.ts
  usePWA.ts
  useRoleOverride.ts
  useSettingsNavigation.ts
  useSettingsProfile.ts
  useSettingsSecurity.ts
  useTodaysPosts.ts
  useUserMetricsStore.ts
  useVotesStore.ts
layouts/
  default.vue
  settings.vue
pages/
  feed/
    [feed].vue
    add.vue
  news/
    index.vue
  achievements.vue
  ask.vue
  companies.vue
  events.vue
  index.vue
  newsletter.vue
  offline.vue
  onboarding.vue
  research.vue
  test.vue
plugins/
  -formbricks.client.ts
  pwa.client.ts
  role-overide.client.ts
server/
  api/
    ai/
      ask.ts
    bookmarks/
      [id].delete.ts
      counts.ts
      index.ts
      move.patch.ts
      toggle.ts
    feature/
      [action].ts
    feedback/
      index.post.ts
    feeds/
      index.ts
    folders/
      [id].delete.ts
      [id].patch.ts
      index.ts
    users/
      metrics/
        [action].ts
      metrics.ts
      update.post.ts
    votes/
      [contentType]/
        [id].get.ts
        [id].post.ts
      user/
        [voteType].get.ts
      user.get.ts
    webhook/
      database.ts
    upload.ts
  middleware/
    feature-limit.ts
  utils/
    openai/
      callOpenAI.ts
      openaiClient.ts
    storage/
      storageSupabase.ts
    agents.ts
    errors.ts
    featureLimits.ts
    formatter.ts
    generateServerToken.ts
    groqClient.ts
    notificationManager.ts
    rateLimiter.ts
    validator.ts
  tsconfig.json
shared/
  constants.ts
  index.ts
types/
  bookmarks.ts
  folder.ts
  toasts.ts
.env.example
app.config.ts
app.vue
components.d.ts
error.vue
project.json
prompt-app-download.ts
README.md
vitest.setup.ts

================================================================
Files
================================================================

================
File: components/bookmark/BookmarkButton.vue
================
<!-- components/BookmarkButton.vue -->
<script setup lang="ts">
interface Props {
  content: any
}

const props = defineProps<Props>()
const bookmarkStore = useBookmarkStore()

// Add more defensive checks for content properties
const contentId = computed(() => props.content?.id)
const contentType = computed(() => props.content?.content_type || 'news')

// Check if bookmarked, supporting the new content structure with extra error handling
const bookmarked = computed(() => {
  if (!contentId.value) return false
  return bookmarkStore.isBookmarked(contentId.value, contentType.value)
})

const showFeedback = ref(false)
const fadeOutComplete = ref(true)

const handleClick = async () => {
  if (!contentId.value) {
    console.error('Cannot bookmark: content has no ID')
    return
  }

  try {
    await bookmarkStore.handleToggleBookmark(props.content)
    showFeedback.value = true
    fadeOutComplete.value = false

    setTimeout(() => {
      showFeedback.value = false
    }, 1500)
  } catch (error) {
    console.error('Failed to toggle bookmark:', error)
  }
}
</script>

<template>
  <div class="relative">
    <!-- Floating feedback text -->
    <Transition @after-leave="fadeOutComplete = true">
      <div
        v-if="showFeedback"
        class="floating-feedback absolute -top-8 left-1/2 -translate-x-1/2 text-sm font-bold"
      >
        <span class="golden-text">BOOKMARKED!</span>
        <div class="sparkles"></div>
      </div>
    </Transition>

    <!-- Bookmark button -->
    <button
      class="hover:text-primary-600 flex items-center justify-center h-full"
      @click="handleClick"
    >
      <Icon
        :name="bookmarked ? 'mdi:bookmark' : 'mdi:bookmark-outline'"
        size="20px"
        :class="[
          { 'text-amber-500': bookmarked },
          'transition-all duration-300',
          'hover:scale-110',
          'active:scale-95',
        ]"
      />
    </button>
  </div>
</template>

<style scoped>
.floating-feedback {
  animation: floatUp 1.5s ease-out forwards;
  pointer-events: none;
}

.golden-text {
  background: linear-gradient(to right, #bf953f, #fcf6ba, #b38728, #fbf5b7, #aa771c);
  -webkit-background-clip: text;
  background-clip: text;
  color: transparent;
  text-shadow: 0 0 10px rgba(251, 191, 36, 0.3);
}

.sparkles {
  position: absolute;
  inset: -5px -10px;
  z-index: -1;
}

.sparkles::before,
.sparkles::after {
  content: '';
  position: absolute;
  width: 4px;
  height: 4px;
  border-radius: 50%;
  background: #fbbf24;
  animation: sparkle 1s ease-in-out infinite;
  box-shadow:
    0 0 3px #fbbf24,
    0 0 6px #fbbf24,
    0 0 9px #fbbf24;
}

.sparkles::before {
  left: 20%;
  animation-delay: -0.4s;
}

.sparkles::after {
  right: 20%;
  animation-delay: -0.2s;
}

@keyframes floatUp {
  0% {
    opacity: 0;
    transform: translate(-50%, 0) scale(0.8);
  }
  20% {
    opacity: 1;
    transform: translate(-50%, -5px) scale(1);
  }
  80% {
    opacity: 1;
    transform: translate(-50%, -15px) scale(1);
  }
  100% {
    opacity: 0;
    transform: translate(-50%, -20px) scale(0.8);
  }
}

@keyframes sparkle {
  0%,
  100% {
    opacity: 0;
    transform: scale(0.3) rotate(0deg);
  }
  50% {
    opacity: 1;
    transform: scale(1) rotate(180deg);
  }
}

/* Additional sparkles using pseudo-elements on floating-feedback */
.floating-feedback::before,
.floating-feedback::after {
  content: '✦';
  position: absolute;
  color: #fbbf24;
  font-size: 12px;
  opacity: 0;
  animation: floatingSparkle 1.5s ease-out forwards;
}

.floating-feedback::before {
  left: -15px;
  animation-delay: 0.2s;
}

.floating-feedback::after {
  right: -15px;
  animation-delay: 0.4s;
}

@keyframes floatingSparkle {
  0% {
    opacity: 0;
    transform: translate(0, 0) rotate(0deg);
  }
  30% {
    opacity: 1;
    transform: translate(-5px, -5px) rotate(45deg);
  }
  70% {
    opacity: 1;
    transform: translate(-10px, -10px) rotate(90deg);
  }
  100% {
    opacity: 0;
    transform: translate(-15px, -15px) rotate(180deg);
  }
}

.v-enter-active,
.v-leave-active {
  transition: opacity 0.15s ease;
}

.v-enter-from,
.v-leave-to {
  opacity: 0;
}
</style>

================
File: components/bookmark/BookmarkCard.vue
================
<script setup lang="ts">
import { useTimeAgo } from '@vueuse/core'
import type { BaseBookmark } from '~/types/bookmark'

interface Props {
  bookmark: BaseBookmark
  selectable?: boolean
  isSelected?: boolean
}

const props = defineProps<Props>()
defineEmits<{
  (e: 'select', id: string): void
}>()

const bookmarkStore = useBookmarkStore()

const isBookmarked = computed(() =>
  bookmarkStore.isBookmarked(props.bookmark.content_id, props.bookmark.content_type),
)

const handleBookmark = async () => {
  try {
    await bookmarkStore.handleToggleBookmark({
      id: props.bookmark.content_id,
      type: props.bookmark.content_type,
      title: props.bookmark.metadata.title,
      url: props.bookmark.metadata.url,
      description: props.bookmark.metadata.description,
      thumbnail: props.bookmark.metadata.featured_image,
      author: props.bookmark.metadata.author,
    })
  } catch (error: any) {
    console.error('Error handling bookmark:', error)
  }
}

const handleDoiClick = () => {
  if (props.bookmark.metadata.doi_url) {
    window.open(props.bookmark.metadata.doi_url, '_blank', 'noopener,noreferrer')
  }
}

const contentTypeIcon = computed(() => {
  switch (props.bookmark.content_type) {
    case 'news':
      return 'mdi:newspaper'
    case 'research':
      return 'mdi:file-document'
    case 'newsletters':
      return 'mdi:email-newsletter'
    case 'companies':
      return 'mdi:domain'
    default:
      return 'mdi:bookmark'
  }
})
</script>

<template>
  <div class="rounded-lg relative border border-color w-full h-full">
    <div
      v-if="selectable"
      class="absolute w-full h-10 inset-0 z-10 flex items-start justify-end p-2 bg-black/5"
      :class="[isSelected ? 'opacity-100' : 'opacity-0 group-hover:opacity-100 transition-opacity']"
    >
      <PrimeCheckbox
        :model-value="isSelected"
        :binary="true"
        @update:model-value="$emit('select', bookmark.id)"
      />
    </div>

    <div
      class="p-4 flex flex-col justify-between h-full"
      :class="{ 'opacity-75': isSelected }"
    >
      <!-- Header -->
      <div>
        <div class="flex items-center justify-between mb-2">
          <div class="flex items-center gap-2">
            <Icon
              :name="contentTypeIcon"
              size="20px"
              class="text-primary-500"
            />
            <span class="text-sm capitalize">{{ bookmark.content_type }}</span>
          </div>
          <span class="text-sm text-gray-500">{{
            useTimeAgo(bookmark.metadata.published_at || bookmark.created_at).value
          }}</span>
        </div>

        <h2 class="text-xl font-bold mb-2">{{ bookmark.metadata.title }}</h2>

        <!-- Additional metadata -->
        <div
          v-if="
            bookmark.metadata.author || bookmark.metadata.published_in || bookmark.metadata.category
          "
          class="flex items-center text-sm mb-4 text-gray-500"
        >
          <template v-if="bookmark.metadata.author">
            <span>{{ bookmark.metadata.author }}</span>
          </template>
          <template v-if="bookmark.metadata.published_in">
            <span>{{ bookmark.metadata.published_in }}</span>
          </template>
          <template v-if="bookmark.metadata.category">
            <span>{{ bookmark.metadata.category }}</span>
          </template>
        </div>
      </div>

      <!-- Body -->
      <div>
        <div
          v-if="bookmark.metadata.featured_image"
          class="mb-4"
        >
          <NuxtImg
            :provider="bookmark.metadata.featured_image ? 'supabase' : undefined"
            :src="bookmark.metadata.featured_image || 'fallback-image.jpg'"
            :alt="bookmark.metadata.title"
            class="w-full h-auto rounded-lg"
            width="400"
            height="200"
          />
        </div>

        <p
          v-if="bookmark.metadata.description"
          class="text-sm text-gray-600 mb-4 line-clamp-3"
        >
          {{ bookmark.metadata.description }}
        </p>

        <!-- Actions -->
        <div class="flex items-center justify-between">
          <div class="flex items-center gap-4">
            <Icon
              v-if="bookmark.metadata.doi_url"
              name="mdi:file-document-outline"
              size="20px"
              class="text-gray-500 hover:text-gray-700 cursor-pointer"
              @click="handleDoiClick"
            />
            <span
              v-if="bookmark.metadata.score"
              class="text-sm text-gray-500"
            >
              Score: {{ bookmark.metadata.score }}
            </span>
          </div>
          <div class="flex items-center gap-4">
            <button
              class="hover:text-gray-600"
              @click="handleBookmark"
            >
              <Icon
                :name="isBookmarked ? 'mdi:bookmark' : 'mdi:bookmark-outline'"
                size="20px"
                :class="{ 'text-primary-500': isBookmarked }"
              />
            </button>
            <NuxtLink
              :to="bookmark.metadata.url"
              target="_blank"
              rel="noopener noreferrer nofollow"
              class="hover:text-gray-600"
            >
              <Icon
                name="mdi:link-variant"
                size="20px"
              />
            </NuxtLink>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>

================
File: components/bookmark/BookmarkGridAnimated.vue
================
<script setup lang="ts">
import { gsap } from 'gsap'

defineProps({
  bookmarks: {
    type: Array as PropType<Bookmark[]>,
    required: true,
  },
  isSelected: {
    type: Function as PropType<(id: string) => boolean>,
    required: true,
  },
  toggleSelection: {
    type: Function as PropType<(id: string) => void>,
    required: true,
  },
})

const positions = new Map()

const getPosition = (el: Element) => {
  const { top, left, width, height } = el.getBoundingClientRect()
  return { top, left, width, height }
}

const beforeLeave = (el: Element) => {
  const pos = getPosition(el)
  positions.set(el, pos)
  el.style.position = 'absolute'
  el.style.top = pos.top + 'px'
  el.style.left = pos.left + 'px'
  el.style.width = pos.width + 'px'
  el.style.height = pos.height + 'px'
}

const leave = (el: Element, done: () => void) => {
  gsap.to(el, {
    opacity: 0,
    scale: 0.8,
    duration: 0.3,
    onComplete: done,
  })
}

const enter = (el: Element, done: () => void) => {
  gsap.from(el, {
    opacity: 0,
    scale: 0.8,
    duration: 0.5,
    onComplete: done,
  })
}

const afterEnter = (el: Element) => {
  el.style.removeProperty('position')
  el.style.removeProperty('top')
  el.style.removeProperty('left')
  el.style.removeProperty('width')
  el.style.removeProperty('height')
}
</script>

<template>
  <TransitionGroup
    class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4 lg:gap-8"
    tag="div"
    :css="false"
    @before-leave="beforeLeave"
    @leave="leave"
    @enter="enter"
    @after-enter="afterEnter"
  >
    <div
      v-for="bookmark in bookmarks"
      :key="bookmark.id"
      :data-index="bookmark.id"
      class="relative group transition-all duration-300"
    >
      <BookmarkCard
        :bookmark="bookmark"
        :selectable="true"
        :is-selected="isSelected(bookmark.id)"
        class="h-full w-full"
        @select="toggleSelection"
      />
    </div>
  </TransitionGroup>
</template>

================
File: components/bookmark/BookmarkViewFolder.vue
================
<template>
  <PrimeDialog
    v-model:visible="showNewFolderModal"
    modal
    header="Create New Folder"
  >
    <div class="space-y-4 flex flex-col">
      <PrimeInputText
        v-model="newFolderName"
        :feedback="true"
        placeholder="Enter Folder Name"
      />
      <div class="flex gap-2">
        <PrimeCheckbox
          id="default"
          v-model="makeDefault"
          binary
        />
        <label for="default">Make Default</label>
      </div>
    </div>
    <template #footer>
      <PrimeButton
        label="Cancel"
        severity="secondary"
        @click="showNewFolderModal = false"
      />
      <PrimeButton
        severity="danger"
        label="Create"
        @click="createFolder"
      />
    </template>
  </PrimeDialog>
  <div class="space-y-6">
    <div class="flex items-center justify-between mb-4">
      <h2 class="text-xl font-semibold">Folders</h2>
      <PrimeButton
        :disabled="!folderUsage.isUnlimited && folderUsage.used >= folderUsage.limit"
        class="p-button-primary"
        @click="showNewFolderModal = true"
      >
        <div class="flex items-center gap-2">
          <Icon name="mdi:folder-plus" />
          <span
            >New Folder ({{ folderUsage.used }}/{{
              folderUsage.isUnlimited ? '∞' : folderUsage.limit
            }})</span
          >
        </div>
      </PrimeButton>
    </div>

    <!-- Folders Grid -->
    <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4">
      <div
        v-for="folder in folderStore.folders"
        :key="folder.id"
        class="relative p-4 hover:shadow-md transition-shadow border border-color rounded-lg cursor-pointer group overflow-hidden"
        :class="{ 'bg-primary-900': folderStore.selectedFolderId === folder.id }"
        @click="handleFolderSelect(folder)"
      >
        <!-- Static color strip -->
        <div
          class="absolute top-0 left-0 right-0 h-[5px]"
          :style="{ backgroundColor: folder.color }"
        />

        <!-- Main Content -->
        <div class="flex items-center justify-between mt-2">
          <div class="flex items-center gap-2 w-full relative">
            <!-- Normal title view -->
            <h3
              v-if="editingFolderId !== folder.id"
              class="font-medium flex-1"
            >
              {{ folder.name }}
            </h3>

            <!-- Edit title mode -->
            <div
              v-if="editingFolderId === folder.id"
              class="flex items-center w-full gap-2"
              @click.stop
            >
              <input
                v-model="editingName"
                class="min-w-0 flex-1 bg-transparent border-b border-primary-500 focus:outline-none px-1"
                @keyup.enter="saveEdit(folder)"
                @keyup.esc="cancelEdit"
                ref="editInput"
                autocomplete="off"
              />
              <button
                class="shrink-0 p-1 hover:text-primary-500 transition-colors border border-color flex text-white rounded-full"
                @click="saveEdit(folder)"
              >
                <Icon
                  name="mdi:check"
                  class="w-4 h-4"
                />
              </button>
            </div>

            <Icon
              v-if="folder.is_favorite"
              name="mdi:star"
              class="w-4 h-4 text-yellow-400 shrink-0"
            />
          </div>

          <!-- Mobile-only action button -->
          <button
            class="p-2 md:hidden rounded-full hover:bg-gray-100 dark:hover:bg-gray-800"
            @click.stop="toggleActions(folder.id)"
          >
            <Icon
              name="mdi:dots-vertical"
              class="w-4 h-4"
            />
          </button>
        </div>

        <p class="mt-2 text-sm text-muted-foreground">
          {{ bookmarkStore.getBookmarkCount(folder.id) }} bookmarks
        </p>

        <!-- Sliding Action Panel -->
        <div
          v-show="!editingFolderId || editingFolderId !== folder.id"
          class="absolute top-0 right-0 h-full w-1/3 bg-card shadow-lg transform transition-transform bg-primary-900 border-l border-color duration-200 translate-x-full group-hover:translate-x-0"
          :class="{ '!translate-x-0': activeActionsFolder === folder.id }"
        >
          <div class="grid grid-cols-2 items-center justify-center h-full gap-1 p-2">
            <!-- Color Selector -->
            <button
              class="w-full h-full flex items-center justify-center hover:bg-gray-100 dark:hover:bg-gray-800 transition-colors p-2"
              @click.stop
            >
              <div
                class="w-full h-full rounded cursor-pointer"
                :style="{ backgroundColor: folder.color }"
              >
                <input
                  type="color"
                  :value="folder.color"
                  class="opacity-0 absolute w-full h-full"
                  @input="(e) => updateFolder(folder, { color: e.target.value })"
                />
              </div>
            </button>

            <!-- Other Actions -->
            <button
              v-for="action in getActions(folder)"
              :key="action.title"
              class="w-full h-full foreground hover:bg-gray-100 dark:hover:bg-gray-800 transition-colors"
              :class="action.buttonClass"
              @click.stop="action.handler(folder)"
              :title="action.title"
            >
              <Icon
                :name="action.icon"
                class="w-4 h-4"
                :class="action.iconClass"
              />
            </button>
          </div>
        </div>
      </div>
    </div>

    <div
      v-if="!folderUsage.isUnlimited && folderUsage.used >= folderUsage.limit"
      class="bg-amber-300 p-2 text-black rounded flex items-center justify-between"
    >
      <span>Upgrade to <b>Pro</b> plan to create more folders</span>
      <NuxtLink
        to="/settings/payments"
        class="text-black gap-2 border-black border-2 flex rounded items-center bg-white p-2"
      >
        <Icon
          class="text-amber-500"
          name="mdi-star"
        />
        <b>Upgrade</b>
      </NuxtLink>
    </div>
  </div>
</template>

<script setup lang="ts">
import type { Folder } from '~/types/folder'

const folderStore = useFolderStore()
const bookmarkStore = useBookmarkStore()
const { handleFolderSelect } = useBookmarkView()
const { getFeatureUsage } = usePlan()
const toast = useNotification()

const newFolderName = ref('')
const makeDefault = ref(false)

const editingFolderId = ref<string | null>(null)
const editingName = ref('')
const editInput = ref<HTMLInputElement | null>(null)
const activeActionsFolder = ref<string | null>(null)
const showNewFolderModal = ref(false)

const folderUsage = computed(() => getFeatureUsage('BOOKMARK_FOLDERS', folderStore.folders.length))
const currentFolderId = computed(() => folderStore.getDefaultFolder).value?.id

console.log('folderStore.folders', folderStore.getDefaultFolder, currentFolderId)
// Start editing folder name
const startEdit = (folder: Folder) => {
  activeActionsFolder.value = null // Hide action panel
  editingFolderId.value = folder.id
  editingName.value = folder.name
  nextTick(() => {
    if (editInput.value) {
      editInput.value.focus()
      editInput.value.select() // Auto select the text
    }
  })
}

// Save edited name
const saveEdit = async (folder: Folder) => {
  if (editingName.value.trim() && editingName.value !== folder.name) {
    await updateFolder(folder, { name: editingName.value })
  }
  editingFolderId.value = null
}

// Cancel editing
const cancelEdit = () => {
  editingFolderId.value = null
}

// Update folder with new data
const updateFolder = async (folder: Folder, data: Partial<Folder>) => {
  try {
    await folderStore.updateFolder(folder.id, data)
  } catch (error: any) {
    console.error('Error updating folder:', error)
    toast.error({ summary: 'Could not update folder', message: error.message })
  }
}

const getActions = (folder: Folder) => {
  const baseActions = [
    {
      title: 'Edit Name',
      icon: 'mdi:pencil',
      handler: startEdit,
      buttonClass: '',
      iconClass: '',
    },
    {
      title: 'Toggle Favorite',
      icon: folder.is_favorite ? 'mdi:star' : 'mdi:star-outline',
      handler: toggleFavorite,
      buttonClass: '',
      iconClass: folder.is_favorite ? 'text-yellow-400' : '',
    },
  ]

  if (!folder.is_default) {
    baseActions.push({
      title: 'Delete',
      icon: 'mdi:trash',
      handler: handleDelete,
      buttonClass: 'text-red-500',
      iconClass: '',
    })
  }

  return baseActions
}

const toggleActions = (folderId: string) => {
  activeActionsFolder.value = activeActionsFolder.value === folderId ? null : folderId
}

const toggleFavorite = async (folder: Folder) => {
  await folderStore.updateFolder(folder.id, {
    is_favorite: !folder.is_favorite,
  })
}

const handleDelete = async (folder: Folder) => {
  const success = await folderStore.deleteFolder(folder.id)
  if (success) {
    if (currentFolderId?.value === folder.id) {
      currentFolderId.value = null
    }
    await bookmarkStore.fetchBookmarks()
    await bookmarkStore.fetchBookmarkCounts()
    activeActionsFolder.value = null
  }
}

const createFolder = async () => {
  const folder: Partial<Folder> = {
    name: newFolderName.value,
    is_default: makeDefault.value,
  }

  try {
    await folderStore.createFolder(folder)
    toast.success({
      summary: 'Folder created',
      message: `Folder ${newFolderName.value} was created successfully`,
    })
    showNewFolderModal.value = false
    newFolderName.value = ''
    makeDefault.value = ''
  } catch (error: any) {
    console.error('Error Creating Folder', error)
    toast.error({ summary: 'Could not create folder', message: error.message })
  }
}

// Close active actions panel when clicking outside
onMounted(() => {
  document.addEventListener('click', (e) => {
    const target = e.target as HTMLElement

    // If clicking outside folder card
    if (!target.closest('.folder-card')) {
      activeActionsFolder.value = null
      if (editingFolderId.value) {
        cancelEdit()
      }
    }
  })

  try {
    folderStore.fetchFolders()
    bookmarkStore.fetchBookmarks()
  } catch (error: any) {
    console.error('Error initializing data:', error)
  }
})

onUnmounted(() => {
  document.removeEventListener('click', () => {})
})
</script>

================
File: components/companies/CompaniesCell.vue
================
<script setup lang="ts">
interface SocialMedia {
  id: string
  facebook_url: string
  twitter_url: string
  linkedin_url: string
  instagram_url: string
  youtube_url: string
}

interface Company {
  id: string
  founding_year: number
  name: string
  description: string
  logo_url: string
  url: string
  is_government: boolean
  keywords: Array<string>
  category?: string
  city?: string
  country?: string
  social_media?: SocialMedia
  job_url?: string
}

const props = defineProps({
  company: Object as PropType<Company>
})

const currentlyOpen = ref(false)

const fallbackImage = '/images/companies_fallback.png'; // The fallback image

// Define a ref to hold the image source
const image = ref(props.company.logo_url);

// Method to change the image source to the fallback
const onError = () => {
  image.value = fallbackImage;
};

const getIcon = (key: string) => {
  if (key.includes('email')) {
    return 'mdi:email'
  } else if (key.includes('youtube')) {
    return 'mdi:youtube'
  } else if (key.includes('facebook')) {
    return 'mdi:facebook'
  } else if (key.includes('twitter')) {
    return 'mdi:twitter'
  } else if (key.includes('linkedin')) {
    return 'mdi:linkedin'
  } else if (key.includes('instagram')) {
    return 'mdi:instagram'
  } else {
    return ''
  }
}
</script>

<template>
  <tr class="relative border border-primary-500 rounded-xl flex flex-col p-5 mt-1 mb-1 gap-2 text-lg text-white shadow-md">
    <!-- Company name at the top -->
    <td class="px-4 w-full" colspan="3">
      <h2 class="text-2xl font-bold w-full">{{ company.name }}</h2>
    </td>
    
    <!-- Main content row -->
    <div class="flex gap-2 w-full">
      <!-- Logo column -->
      <td class="px-2 py-3 w-1/5">
        <div class="flex flex-col items-center">
          <IBImage
            :img="{ src: image, alt: company.name, width: '200', height: '200' }"
            @error="onError"
            class="rounded-xl bg-white p-2"
          />
        </div>
      </td>
      
      <!-- Description column -->
      <td class="px-4 flex flex-col gap-2 justify-between w-3/5 flex-2 py-3 whitespace-wrap max-w-xs text-left">
        <p v-if="company.description" class="align-middle">
          {{ company.description.slice(0, 1).toUpperCase() }}{{ company.description.length <= 240 || currentlyOpen
              ? company.description.slice(1)
              : `${company.description.slice(1, 241)}...` }}
          <p v-if="company.description.length > 240" class="text-primary-300 cursor-pointer" @click="currentlyOpen = !currentlyOpen">
            {{ currentlyOpen ? 'Read Less' : 'Read More' }}
          </p>
        </p>
        <p v-else class="w-full min-h-[1em]">&nbsp;</p>
        <NuxtLink v-if="company.url" :to="company.url" target="_blank" external>
          <PrimeButton outlined severity="contrast">Company Website</PrimeButton>
        </NuxtLink>
      </td>
      
      <!-- Company details column -->
      <td class="flex py-3 w-1/5 flex-1 flex-col">
        <p v-if="company.founding_year"><b>Founding Year:</b> {{ company.founding_year }}</p>
        <p v-if="company.city"><b>Location:</b> {{ company.city }}, {{ company.country }}</p>
        <p v-if="company.category"><b>Category:</b> {{ company.category }}</p>
        <div v-if="company.social_media" class="flex flex-col md:flex-row mt-auto items-center justify-between">
          <div>
            <NuxtLink
              v-for="(url, key) in company.social_media"
              v-show="url && key !== 'id'"
              :key="company.social_media.id"
              :to="url"
              target="_blank"
              external
            >
              <PrimeButton outlined>
                <Icon :name="getIcon(key)" size="36px" class="text-white" />
              </PrimeButton>
            </NuxtLink>
          </div>
          <NuxtLink v-if="company.job_url" :to="company.job_url" target="_blank" external>
            <PrimeButton outlined severity="contrast" class="shiny-button font-bold">Jobs</PrimeButton>
          </NuxtLink>
        </div>
      </td>
    </div>
    
    <!-- Government badge -->
    <td v-if="company.is_government" class="absolute text-xs top-2 right-2 p-2 bg-gray-600 text-black rounded-xl">
      <h3>Government</h3>
    </td>
  </tr>
</template>
<style scoped>
  .shiny-button {
      position: relative;
      display: inline-block;
      cursor: pointer;
      overflow: hidden;
      transition: transform 0.2s ease;
  }

  /* Shine Effect */
  .shiny-button::before {
      content: "";
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: rgba(255, 255, 255, 0.4);
      transform: skewX(-45deg);
      animation: shine 10s infinite linear;
  }

  /* Shine Animation */
  @keyframes shine {
      0% { left: -100%; }
      5% { left: 150%; }
      100% { left: 150%; }
  }

  /* Hover Effect */
  .shiny-button:hover {
      transform: scale(1.05);
  }
</style>

================
File: components/companies/CompaniesComingSoon.vue
================
<script setup lang="ts">
const partners = [
  { name: 'Aadyah Aerospace', id: useId(), type: 'Private Space' },
  { name: 'Aeroin Space', id: useId(), type: 'Private Space' },
  { name: 'Agnikul', id: useId(), type: 'Private Space' },
  { name: 'Astrogate Labs', id: useId(), type: 'Private Space' },
  { name: 'Bellatrix Aerospace', id: useId(), type: 'Private Space' },
  { name: 'CNSA', id: useId(), type: 'Space Agency' },
  { name: 'CSA', id: useId(), type: 'Space Agency' },
  { name: 'Dhruva Space', id: useId(), type: 'Private Space' },
  { name: 'ESA', id: useId(), type: 'Space Agency' },
  { name: 'ISRO', id: useId(), type: 'Space Agency' },
  { name: 'JAXA', id: useId(), type: 'Space Agency' },
  { name: 'NASA', id: useId(), type: 'Space Agency' },
  { name: 'Pixxel', id: useId(), type: 'Private Space' },
  { name: 'Roscosmos', id: useId(), type: 'Space Agency' },
  { name: 'Skyroot Aerospace', id: useId(), type: 'Private Space' },
]

const isLaunching = ref(false)

const triggerLaunch = () => {
  isLaunching.value = true
  // Reset after animation completes (optional)
  setTimeout(() => {
    isLaunching.value = false
  }, 2000) // Match this with animation duration
}
</script>

<template>
  <div class="hoverflow-hidden">
    <div class="mx-auto px-4 py-8 flex flex-col gap-8">
      <!-- Title section -->
      <div
        class="flex items-center justify-center relative gap-2 mx-auto underline decoration-primary-600 underline-offset-8"
      >
        <h1 class="text-2xl font-bold text-white">Companies!</h1>
        <Icon
          class="-rotate-45 relative"
          name="ph:rocket-launch-duotone"
          size="32"
        />
        <h1 class="text-2xl font-bold text-white">Launching</h1>
        <Icon
          class="-rotate-45 relative -top-4"
          name="ph:rocket-launch-duotone"
          size="32"
        />
        <h1 class="text-2xl font-bold text-white">Real...</h1>
        <Icon
          class="-rotate-45 relative -top-8"
          name="ph:rocket-launch-duotone"
          size="32"
        />
        <h1 class="text-2xl font-bold text-white">Soon...</h1>
        <Icon
          class="-rotate-45 absolute -right-12 -top-12"
          name="ph:rocket-launch-duotone"
          size="32"
          @click="triggerLaunch"
        />
      </div>

      <!-- Scrolling layers -->
      <div class="space-y-4">
        <CompaniesScrolling
          :partners="partners"
          direction="left"
        />
        <CompaniesScrolling
          :partners="partners"
          direction="right"
        />
        <CompaniesScrolling
          :partners="partners"
          direction="left"
        />
        <CompaniesScrolling
          :partners="partners"
          direction="right"
        />
      </div>
    </div>
  </div>
</template>

<style scoped></style>

================
File: components/companies/CompaniesScrolling.vue
================
<script setup lang="ts">
import EmblaCarousel, { type EmblaCarouselType, type EmblaOptionsType } from 'embla-carousel'
import AutoScroll from 'embla-carousel-auto-scroll'

interface Partner {
  name: string
  id: string
  type: string
}

const props = defineProps<{
  partners: Partner[]
  direction?: 'left' | 'right'
}>()

const emblaRef = ref<HTMLElement | null>(null)
let emblaApi: EmblaCarouselType | undefined

onMounted(() => {
  const OPTIONS: EmblaOptionsType = { loop: true }

  if (emblaRef.value) {
    emblaApi = EmblaCarousel(emblaRef.value, OPTIONS, [
      AutoScroll({
        playOnInit: true,
        speed: props.direction === 'left' ? -1 : 1,
      }),
    ])
  }
})

onUnmounted(() => {
  emblaApi?.destroy()
})
</script>

<template>
  <div
    ref="emblaRef"
    class="embla overflow-hidden"
  >
    <div class="embla__container flex">
      <div
        v-for="partner in partners"
        :key="`${partner.name}-${partner.id}`"
        class="embla__slide mx-2"
      >
        <div
          class="bg-primary-900/50 w-20 max-w-20 rounded-xl p-2 flex flex-col items-center justify-center group hover:bg-primary-800/50 transition-colors"
        >
          <NuxtImg
            :src="`/images/logos/${partner.name.toLowerCase().replace(' ', '-')}-logo.jpg`"
            :alt="partner.name"
            class="w-full h-full object-contain opacity-70 group-hover:opacity-100 rounded-lg overflow-hidden"
          />
        </div>
      </div>
    </div>
  </div>
</template>

================
File: components/companies/CompaniesSkeleton.vue
================
<template>
  <table
    class="min-w-full select-none border-collapse text-primary-500 table-auto bg-transparent rounded-lg"
  >
    <tbody>
      <!-- Repeat Skeleton Rows for a Loading Effect -->
      <tr
        v-for="index in 5"
        :key="index"
        class="relative p-5 mt-1 mb-1 border border-primary-500 rounded-xl gap-2 shadow-md bg-gray-800 animate-pulse"
      >
        <!-- Logo Skeleton -->
        <td class="px-4 py-3 text-center">
          <PrimeSkeleton
            shape="circle"
            width="50px"
            height="50px"
            class="rounded-full"
          />
        </td>

        <!-- Company Name Skeleton -->
        <td class="px-4 py-3">
          <PrimeSkeleton
            width="120px"
            height="76px"
          />
        </td>

        <!-- Description Skeleton -->
        <td class="px-4 py-3 whitespace-wrap max-w-xs text-center">
          <PrimeSkeleton
            width="200px"
            height="12px"
            class="mb-2"
          />
          <PrimeSkeleton
            width="180px"
            height="12px"
          />
        </td>

        <!-- Government Badge Skeleton -->
        <td class="absolute top-2 right-2 p-2">
          <PrimeSkeleton
            width="60px"
            height="20px"
          />
        </td>
      </tr>
    </tbody>
  </table>
</template>

================
File: components/companies/CompaniesTable.vue
================
<script setup lang="ts">
interface SocialMedia {
  id: string
  facebook_url: string
  twitter_url: string
  linkedin_url: string
  instagram_url: string
  youtube_url: string
}

interface Company {
  id: string
  founding_year: number
  name: string
  description: string
  logo_url: string
  url: string
  is_government: boolean
  keywords: Array<string>
  category?: string
  city?: string
  country?: string
  social_media?: SocialMedia
  job_url?: string
}

defineProps({
  companies: Array<Company>,
})
</script>

<template>
  <table
    class="table-fixed min-w-full select-none border-collapse text-primary-500 table-auto bg-transparent rounded-lg"
  >
    <tbody>
      <CompaniesCell
        v-for="company in companies"
        :company="company"
        :key="company.id"
      />
    </tbody>
  </table>
</template>

================
File: components/company/CompanyCard.vue
================
<script setup lang="ts">
defineProps({
  company: {
    type: Object as () => Record<string, any>,
    required: true,
  },
})

const { getCategoryName } = useCategoryTagStore()

// What to display:
// Company location(s)
// Category
// Tags?
// Name
// Link to website
// Number of news updates
// Scrape Frequency?
// Sector
// Founded Year
// Description - probably a summary of all articles by chatGPT
// Logo
// isHiring (check job board to see, maybe linkedin) - add later, just scrape Linkedin Jobs for now
// isFunded
// valuation
// companySize
// primaryLocation
// country
//
</script>

<template>
  <div class="border-color border-b-2 px-4 py-8">
    <div>
      <div class="space-y-4 pb-4">
        <div class="flex items-center gap-4">
          <IBImage
            v-if="company.logo_url"
            class="border-color rounded-full border"
            :img="{
              src: `companies/${company.logo_url}`,
              width: '60',
              height: '60',
            }"
          />
          <div>
            <h3 class="text-balance text-xl font-semibold md:max-h-16">
              {{ company.name }}
            </h3>
            <p
              v-if="company.category_id !== 16"
              class="text-sm"
            >
              {{ getCategoryName(company.category_id) }}
            </p>
          </div>
          <!-- <span class="text-sm w-auto">
            Scraped: {{ useTimeAgo(company.scraped_at).value }}
          </span> -->
        </div>
      </div>
    </div>
    <div class="flex flex-col gap-4">
      <div class="flex items-center gap-2">
        <PrimeTag severity="info">
          {{ company.is_government ? 'Government' : 'Private' }}
        </PrimeTag>
        <PrimeTag
          v-if="company.founding_year"
          severity="info"
        >
          founded: {{ company.founding_year }}
        </PrimeTag>
        <IBNewLabel
          :date="company.created_at!"
          :max-age="14"
        />
      </div>
      <p
        v-if="company.description"
        class="text-sm"
      >
        {{ company.description }}
      </p>
      <div class="flex w-full items-center justify-between pt-4">
        <div>
          <IBSocialBlock
            v-if="company.social_media"
            :socials="company.social_media"
          />
        </div>
        <NuxtLink
          :to="company.url"
          target="_blank"
          rel="noopener"
        >
          <PrimeButton
            label="Website"
            size="small"
            outlined
          />
        </NuxtLink>
      </div>
    </div>
  </div>
</template>

================
File: components/company/CompanyCardSkeleton.vue
================
<script setup lang="ts"></script>

<template>
  <div class="border-b-2 border-color px-4 py-8">
    <div>
      <div class="space-y-4 pb-4">
        <div class="flex gap-4 items-center">
          <PrimeSkeleton
            :pt="{
              root: 'max-w-16 min-h-16 rounded-full',
            }"
          />

          <div class="w-full space-y-2">
            <PrimeSkeleton class="max-w-64 min-h-6 rounded-md" />
            <PrimeSkeleton class="max-w-48 h-4 rounded-md" />
          </div>
        </div>
      </div>
    </div>
    <div class="flex flex-col gap-4">
      <div class="flex gap-2 items-center">
        <PrimeSkeleton class="max-w-32 min-h-6 rounded-md" />
        <PrimeSkeleton class="max-w-16 min-h-6 rounded-md" />
      </div>
      <PrimeSkeleton class="w-full min-h-24 rounded-md" />

      <div class="w-full flex justify-between items-center pt-4">
        <PrimeSkeleton class="max-w-32 min-h-6 rounded-md" />
        <PrimeSkeleton class="max-w-24 min-h-10 rounded-md" />
      </div>
    </div>
  </div>
</template>

================
File: components/feed/FeedGrid.vue
================
<!-- NewsFeedGrid.vue -->
<script setup lang="ts">
// Updated to handle the new unified content structure
defineProps<{
  items: Array<any> // Can be News, SponsoredAd, or any content type from the unified table
}>()
</script>

<template>
  <div
    class="mx-auto w-full grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 md:col-start-2 gap-4 md:gap-8 p-4 md:p-8 max-w-[940px]"
  >
    <template
      v-for="(item, index) in items"
      :key="item.id"
    >
      <div
        :id="`feed-item-${index}`"
        class="grid-item"
      >
        <NewsCard
          v-if="item.type !== 'sponsored'"
          :news="item"
        />
        <AdsFeedCard
          v-else
          :ad="item.content"
        />
      </div>
    </template>
  </div>
</template>

================
File: components/feed/FeedHot.vue
================
<!-- HotFeed.vue -->
<script setup lang="ts">
// Update to use the new contents table with content_type filter
const { store, loadMore } = useSelectData<any>('contents', {
  // Updated to query the contents table with news content_type
  orderBy: { column: 'hot_score', ascending: false },
  filters: { content_type: { eq: 'news' }, is_active: { eq: true }, deleted_at: { is: null } },
  columns: `
    id, 
    content_type,
    title, 
    url, 
    created_at, 
    hot_score,
    published_at, 
    description, 
    author, 
    featured_image, 
    source_id,
    company_id,
    details
  `,
  pagination: { page: 1, limit: 21 },
  initialFetch: true,
  storeKey: 'hotFeed',
})

const { items: newsItems } = storeToRefs(store)
const displayedFeed = ref<Array<any>>([])
const loading = useLoadingStore()

// Ads integration
const { integrateAdsIntoFeed, resetAdTracking, isLoading: adsLoading } = useAdsStore()

// Update feed with ads
const updateDisplayedFeed = (items: any[], isFullRefresh = false) => {
  if (isFullRefresh) {
    resetAdTracking()
    displayedFeed.value = integrateAdsIntoFeed(items, true)
  } else {
    const integratedChunk = integrateAdsIntoFeed(items, false)
    displayedFeed.value = [...displayedFeed.value, ...integratedChunk]
  }
}

// Watch for changes in news items
watch(newsItems, (newVal) => {
  if (displayedFeed.value.length === 0) {
    // Initial load
    updateDisplayedFeed(newVal, true)
  } else {
    // Handle infinite scroll updates
    const addedItems = newVal.slice(displayedFeed.value.length)
    updateDisplayedFeed(addedItems, false)
  }
})

const showSkeletonGrid = computed(() => loading.isLoading('hotFeed') || adsLoading.value)
</script>

<template>
  <div class="min-h-[800px]">
    <Transition
      name="fade"
      mode="out-in"
    >
      <IBInfiniteScroll
        v-if="!showSkeletonGrid"
        :threshold="1400"
        @update:scroll-end="loadMore"
      >
        <FeedGrid :items="displayedFeed" />
      </IBInfiniteScroll>

      <FeedSkeleton v-else />
    </Transition>
  </div>
</template>

<style scoped>
.fade-enter-active,
.fade-leave-active {
  transition: opacity 0.3s ease;
}

.fade-enter-from,
.fade-leave-to {
  opacity: 0;
}
</style>

================
File: components/feed/FeedHotToggle.vue
================
<script setup lang="ts">
const props = defineProps<{
  modelValue: 'created_at' | 'hot_score'
}>()

const emit = defineEmits<{
  'update:modelValue': ['created_at' | 'hot_score']
}>()

const isAnimating = ref(false)

function handleToggle(value: 'created_at' | 'hot_score') {
  emit('update:modelValue', value)
  if (value === 'hot_score') {
    isAnimating.value = true
    setTimeout(() => {
      isAnimating.value = false
    }, 1000)
  }
}
</script>

<template>
  <div class="flex justify-center gap-4 p-8">
    <button
      class="px-4 py-2 rounded-md transition-colors duration-200"
      :class="{
        'bg-blue-600 text-white hover:bg-blue-700': modelValue === 'created_at',
        'bg-gray-100 text-gray-700 hover:bg-gray-200': modelValue !== 'created_at',
      }"
      @click="handleToggle('created_at')"
    >
      <div class="flex items-center gap-2">
        <span>Latest</span>
        <Icon
          name="material-symbols:hourglass-top"
          size="22px"
        />
      </div>
    </button>

    <button
      class="px-4 py-2 rounded-md transition-colors duration-200"
      :class="{
        'bg-red-600 text-white hover:bg-red-700': modelValue === 'hot_score',
        'bg-gray-100 text-gray-700 hover:bg-gray-200': modelValue !== 'hot_score',
      }"
      @click="handleToggle('hot_score')"
    >
      <div class="flex items-center gap-2">
        <span>Hot</span>
        <Icon
          name="mdi:fire"
          size="22px"
          class="transition-transform"
          :class="{
            'animate-wiggle': isAnimating,
          }"
        />
      </div>
    </button>
  </div>
</template>

<style scoped>
@keyframes wiggle {
  0% {
    transform: rotate(0deg) scale(1);
  }
  25% {
    transform: rotate(-12deg) scale(1.2);
  }
  50% {
    transform: rotate(10deg) scale(1.1);
  }
  75% {
    transform: rotate(-8deg) scale(1.1);
  }
  100% {
    transform: rotate(0deg) scale(1);
  }
}

.animate-wiggle {
  animation: wiggle 1s ease-in-out;
}
</style>

================
File: components/feed/FeedRecent.vue
================
<!-- RecentFeed.vue -->
<script setup lang="ts">
interface SponsoredAd {
  id: string
  type: 'sponsored'
  content: Ad
  sortIndex: number
  adIndex: number
}

// Update to use the new contents table
const { store, loadMore } = useSelectData<any>('contents', {
  // Updated query for the unified contents table
  orderBy: { column: 'published_at', ascending: false },
  filters: { content_type: { eq: 'news' }, is_active: { eq: true }, deleted_at: { is: null } },
  columns: `
    id, 
    content_type,
    title, 
    url, 
    created_at, 
    hot_score,
    published_at, 
    description, 
    author, 
    featured_image, 
    source_id,
    company_id,
    details
  `,
  pagination: { page: 1, limit: 21 },
  initialFetch: true,
  storeKey: 'recentFeed',
})

const { items: newsItems } = storeToRefs(store)
const displayedFeed = ref<Array<any | SponsoredAd>>([])
const loading = useLoadingStore()

// Ads integration
const { integrateAdsIntoFeed, resetAdTracking, isLoading: adsLoading } = useAdsStore()

// Update feed with ads
const updateDisplayedFeed = (items: any[], isFullRefresh = false) => {
  if (isFullRefresh) {
    resetAdTracking()
    displayedFeed.value = integrateAdsIntoFeed(items, true)
  } else {
    const integratedChunk = integrateAdsIntoFeed(items, false)
    displayedFeed.value = [...displayedFeed.value, ...integratedChunk]
  }
}

// Watch for changes in news items
watch(newsItems, (newVal) => {
  if (displayedFeed.value.length === 0) {
    // Initial load
    updateDisplayedFeed(newVal, true)
  } else {
    // Handle infinite scroll updates
    const addedItems = newVal.slice(displayedFeed.value.length)
    updateDisplayedFeed(addedItems, false)
  }
})

// Handle loading states
const showSkeletonGrid = computed(() => loading.isLoading('recentFeed') || adsLoading.value)

// Debug logs
onMounted(() => {
  console.log('RecentFeed mounted')
})

watch(displayedFeed, (newVal) => {
  console.log('DisplayedFeed updated:', {
    length: newVal.length,
    firstThreeIds: newVal.slice(0, 3).map((item) => item.id),
  })
})
</script>

<template>
  <div class="min-h-[800px]">
    <Transition
      name="fade"
      mode="out-in"
    >
      <IBInfiniteScroll
        v-if="!showSkeletonGrid"
        :threshold="1400"
        @update:scroll-end="loadMore"
      >
        <FeedGrid :items="displayedFeed" />
      </IBInfiniteScroll>

      <FeedSkeleton v-else />
    </Transition>
  </div>
</template>

<style scoped>
.fade-enter-active,
.fade-leave-active {
  transition: opacity 0.3s ease;
}

.fade-enter-from,
.fade-leave-to {
  opacity: 0;
}
</style>

================
File: components/feed/FeedSkeleton.vue
================
<template>
  <div
    class="mx-auto w-full grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 md:col-start-2 gap-4 md:gap-8 p-4 md:p-8 max-w-[940px]"
  >
    <NewsCardSkeleton
      v-for="n in 6"
      :key="`skeleton-${n}`"
    />
  </div>
</template>

================
File: components/feed/FeedTitle.vue
================
<script setup lang="ts">
// components/FeedTitle.vue
interface Props {
  title: string
  filters?: {
    categories?: Array<{ id: number }>
    sources?: Array<{ id: number }>
  }
}

const props = withDefaults(defineProps<Props>(), {
  title: 'News Feed',
  filters: () => ({}),
})

const currentTime = ref(new Date())

const formattedTime = computed(() => {
  return new Intl.DateTimeFormat(undefined, {
    hour: 'numeric',
    minute: 'numeric',
    hour12: true,
    timeZoneName: 'short',
  }).format(currentTime.value)
})

const { todaysPosts, fetchTodaysPosts, hasInitialized } = useTodaysPosts(props.filters)

let timeTimer: NodeJS.Timer
let postTimer: NodeJS.Timer

onMounted(() => {
  // Initial fetch
  fetchTodaysPosts()

  // Update time every minute
  timeTimer = setInterval(() => {
    currentTime.value = new Date()
  }, 60000)

  // Update post count every 5 minutes, but only after initial mount
  postTimer = setInterval(() => {
    hasInitialized.value = false // Reset the flag for periodic updates
    fetchTodaysPosts()
  }, 300000)
})

onUnmounted(() => {
  clearInterval(timeTimer)
  clearInterval(postTimer)
})
</script>

<template>
  <div class="bg-primary-950">
    <div class="max-w-[940px] mx-auto px-4 py-6 md:px-8">
      <div class="flex items-center justify-between">
        <h1 class="text-2xl font-bold text-white">{{ title }}</h1>
        <div class="text-gray-400 text-sm space-y-1 text-right">
          <div>{{ formattedTime }}</div>
          <div>{{ todaysPosts }} posts today</div>
        </div>
      </div>
    </div>
  </div>
</template>

================
File: components/nav/NavAppTop.vue
================
<script setup lang="ts">
const router = useRouter()
const userStore = useCurrentUser()
const toast = useNotification()
const supabase = useSupabaseClient()
const { profile, isAdmin } = storeToRefs(userStore)
const { adminURL, loginURL, authURL } = useRuntimeConfig().public

const profileMenu = ref(null)
const toggleMenu = (e) => {
  profileMenu.value?.toggle(e)
}

const items = computed(() => {
  const menuItems = [
    {
      label: 'Settings',
      command: () => router.push('/settings/account'), // Updated from '/settings/profile'
    },
    {
      label: 'Logout',
      command: signOut,
    },
  ]

  if (isAdmin.value) {
    menuItems.splice(2, 0, {
      label: 'Admin',
      command: () => navigateTo(adminURL, { external: true }),
    })
  }

  return menuItems
})

const signOut = async () => {
  const { error } = await supabase.auth.signOut()

  if (error) {
    console.error(error.message)
    toast.error({ summary: 'Could not log out', message: error.message })
  } else {
    return navigateTo(String(`${authURL}${loginURL}`), { external: true })
  }
}

const loading = useLoadingStore()
const isLoading = computed(() => loading.isLoading('currentUser'))

const avatarUrl = ref(null)
const fallbackLoaded = ref(false)

// Generate fallback avatar URL using UI Avatars
const getFallbackAvatarUrl = (name: string) => {
  const initials =
    name
      ?.split(' ')
      .map((word) => word[0])
      .join('')
      .toUpperCase() || 'U'
  return `https://ui-avatars.com/api/?name=${initials}&background=random&size=128`
}

watch(
  profile,
  (newProfile) => {
    if (newProfile?.avatar) {
      avatarUrl.value = newProfile.avatar
      fallbackLoaded.value = false
    } else {
      // Use name from profile for the fallback avatar, or default to 'User'
      avatarUrl.value = getFallbackAvatarUrl(newProfile?.full_name || 'User')
      fallbackLoaded.value = true
    }
  },
  { immediate: true },
)

const handleImageError = () => {
  if (!fallbackLoaded.value) {
    // Only load fallback if we haven't already tried
    avatarUrl.value = getFallbackAvatarUrl(profile.value?.full_name || 'User')
    fallbackLoaded.value = true
  }
  console.log('Avatar image load error, using fallback')
}
</script>

<template>
  <div
    class="foreground border-color sticky left-0 top-0 z-50 flex min-h-[60px] w-full flex-row items-center justify-between gap-4 border-b px-4 py-1"
  >
    <!-- start -->
    <div class="flex items-center gap-4">
      <IBNavHamburger />
      <IBBreadcrumbs class="hidden text-sm lg:block" />
    </div>
    <!-- center -->
    <div class="flex w-full max-w-[70%] gap-4 px-4 py-2 lg:max-w-xl" />
    <!-- end -->
    <ClientOnly>
      <div
        v-if="isLoading || !profile?.user_role"
        class="flex items-center justify-end gap-4"
      >
        <PrimeSkeleton class="min-h-4 min-w-10 rounded-md" />
        <PrimeSkeleton
          :pt="{
            root: 'min-w-10 min-h-10 rounded-full',
          }"
        />
      </div>
      <div
        v-else-if="profile?.user_role"
        class="flex items-center justify-center gap-4"
        ><NuxtLink
          v-if="profile.user_plan"
          to="/settings/payments"
        >
          <PrimeTag class="bg-transparent text-nowrap rounded border border-white"
            >{{ profile.user_plan }} plan active
          </PrimeTag>
        </NuxtLink>
        <PrimeTag v-if="profile.user_role">
          {{ profile.user_role }}
        </PrimeTag>
        <PrimeAvatar
          v-if="avatarUrl"
          :image="avatarUrl"
          size="normal"
          shape="circle"
          class="cursor-pointer"
          aria-haspopup="true"
          aria-controls="overlay_menu"
          @error="handleImageError"
          @click="toggleMenu"
        />
        <PrimeMenu
          id="overlay_menu"
          ref="profileMenu"
          :model="items"
          :popup="true"
        />
      </div>
    </ClientOnly>
  </div>
</template>

================
File: components/nav/NavMobiBottom.vue
================
// components/nav/NavMobiBottom.vue
<script setup lang="ts">
const { appLinks } = usePages()

// Function to get main navigation items from categories
const mainNavItems = computed(() => {
  // For mobile, we'll show:
  // 1. Home from 'main' category
  // 2. Feed from 'news' category
  // 3. Profile links
  const items = []

  // Get home from main
  const mainCategory = appLinks.value.find((cat) => cat.id === 'main')
  if (mainCategory?.items?.[0]) {
    items.push(mainCategory.items[0])
  }

  // Get feed from news
  const newsCategory = appLinks.value.find((cat) => cat.id === 'news')
  if (newsCategory?.items?.[0]) {
    items.push(newsCategory.items[0])
  }

  // Get profile section
  // const profileCategory = appLinks.value.find((cat) => cat.id === 'profile')
  // if (profileCategory?.items?.[0]) {
  //   // Add first profile item (or you can create a specific profile route)
  //   items.push({
  //     id: profileCategory.items[0].id,
  //     label: 'Profile',
  //     slug: '/profile',
  //     icon: 'mdi:account-circle-outline',
  //   })
  // }

  return items
})

// Active route handling
const route = useRoute()
const isActive = (slug: string) => {
  if (slug === '/') {
    return route.path === '/'
  }
  return route.path.startsWith(slug)
}
</script>

<template>
  <div
    class="fixed bottom-0 left-0 flex-row w-full items-center justify-between foreground p-2 h-[var(--mobi-bottom-nav-height)] border-t border-color"
  >
    <ul class="flex flex-row items-center justify-center w-full h-full">
      <li
        v-for="item in mainNavItems"
        :key="item.id"
        class="flex items-center justify-center w-full h-full cursor-pointer"
      >
        <NuxtLink
          :to="item.slug"
          class="flex flex-col justify-center items-center gap-1 px-2"
          :class="{ 'text-primary-500': isActive(item.slug) }"
        >
          <ClientOnly>
            <Icon
              :name="item.icon"
              size="24px"
            />
            <span class="text-xs">{{ item.label }}</span>
          </ClientOnly>
        </NuxtLink>
      </li>
    </ul>
  </div>
</template>

<style scoped>
.router-link-active {
  @apply text-primary-500;
}

/* Optional: Add transition for active state */
.router-link-active .icon {
  @apply transform scale-110 transition-transform;
}
</style>

================
File: components/nav/NavMobiSlideover.vue
================
<template>
  <div>
    <PrimeButton
      variant="link"
      :padded="false"
      @click="isOpen = true"
    >
      <Icon
        name="mdi:menu"
        class="text-white"
        size="24px"
      />
    </PrimeButton>
    <PrimeDrawer v-model:visible="isOpen">
      <div class="border-color border-r">
        <div class="foreground flex w-full items-center justify-between p-8">
          <NuxtLink
            class="flex items-center gap-4"
            to="/"
            @click="isOpen = false"
          >
            <div class="flex aspect-square rounded-full bg-white p-2">
              <IBImage
                :img="{
                  src: '/astronera-logo.jpg',
                  alt: 'Astron Era Logo',
                }"
                class="h-8 w-8 md:h-12 md:w-12"
              />
            </div>
            <h3 class="text-xl"> AstronEra </h3>
          </NuxtLink>
          <PrimeButton
            variant="solid"
            icon="mdi:chevron-left"
            @click="isOpen = false"
          >
            Return
          </PrimeButton>
        </div>
        <div v-show="links">
          <NuxtLink
            v-for="link in links"
            :key="link.id"
            :to="link.slug"
            class="border-color flex w-full items-center justify-end border-b px-8 py-3 text-sm font-medium"
            @click="isOpen = false"
          >
            {{ link.name }}
            <Icon
              :name="getIcon(link.name)"
              class="ml-2"
              size="24px"
            />
          </NuxtLink>
        </div>
      </div>
    </PrimeDrawer>
  </div>
</template>

<script setup lang="ts">
const isOpen = ref(false)

const getIcon = (val: string) => {
  if (val === 'Contact') return 'material-symbols:info'
  if (val === 'About') return 'material-symbols:call'
  if (val === 'Preview') return 'material-symbols:globe-asia'
  if (val === 'Team') return 'material-symbols:emoji-people'
  if (val === 'Blog') return 'material-symbols:article'
  if (val === 'Community') return 'material-symbols:groups-rounded'
  if (val === 'Conference') return 'mdi:presentation'
}

defineProps({
  links: {
    type: Array as PropType<object[]>,
    required: true,
  },
})
</script>

<style scoped></style>

================
File: components/news/NewsActions.vue
================
<!-- components/NewsActions.vue -->
<script setup lang="ts">
interface Props {
  score: number
  commentsCount?: number
  bookmarked: boolean
  url: string
  content: any // Updated to accept any content from the unified content table
  onSourceVisit: () => Promise<void>
  cardSide: 'front' | 'back'
}

defineProps<Props>()
</script>

<template>
  <div
    class="flex items-center justify-between"
    :class="{ 'border-t border-primary-900 pt-4': cardSide === 'back' }"
  >
    <div class="flex items-center gap-4">
      <div
        :class="[
          'flex items-center justify-center py-1 px-2 rounded-xl',
          cardSide === 'front' ? 'bg-primary-950' : 'bg-primary-900',
        ]"
      >
        <VoteButton
          :content-id="content.id"
          :content-type="content.content_type || 'news'"
          direction="up"
          :card-side="cardSide"
        />
        <span class="text-sm font-medium pl-1 pr-2">{{ score }}</span>
        <VoteButton
          :content-id="content.id"
          :content-type="content.content_type || 'news'"
          direction="down"
          :card-side="cardSide"
        />
      </div>
      <!-- <button
        v-if="commentsCount"
        class="flex items-center gap-2 hover:text-primary-600"
        @click="$emit('open-modal', 'Comments')"
      >
        <Icon
          name="mdi:comment-outline"
          size="20px"
        />
        <span v-if="cardSide === 'back' && commentsCount">{{ commentsCount }}</span>
      </button> -->
    </div>
    <div class="flex items-center gap-2 justify-center">
      <BookmarkButton :content="content" />
      <NuxtLink
        :to="url"
        target="_blank"
        rel="noopener noreferrer nofollow"
        :class="[
          'hover:text-primary-600',
          cardSide === 'back'
            ? 'flex items-center gap-1.5 group p-1 rounded-full bg-primary-500'
            : '',
        ]"
        @click="onSourceVisit"
      >
        <Icon
          name="mdi:link-variant"
          size="20px"
        />
      </NuxtLink>
    </div>
  </div>
</template>

================
File: components/news/NewsCard.vue
================
<script setup lang="ts">
import { useTimeAgo } from '@vueuse/core'
import { ref, onMounted } from 'vue'

// Updated interface to match new content structure
interface NewsCardT {
  id: string
  content_type: string
  title: string
  url: string
  hot_score: number
  vote_count?: number
  created_at: string
  updated_at: string
  published_at: string | null
  featured_image: string | null
  author: string | null
  description: string | null
  source_id: string | null
  company_id: string | null
  details: {
    // Type-specific details stored in JSONB
    categories?: Array<{ name: string; isPrimary: boolean }>
    tags?: string[]
    summaries?: {
      undefined?: Array<{ id: string; summary: string; version: number }> | null
      beginner?: Array<{ id: string; summary: string; version: number }> | null
      intermediate?: Array<{ id: string; summary: string; version: number }> | null
      expert?: Array<{ id: string; summary: string; version: number }> | null
    }
    company_name?: string
    company_logo?: string
  }
}

interface Props {
  news: NewsCardT
}

const props = defineProps<Props>()

// Helper to get data from either direct properties or details JSONB
const getContentProperty = <T,>(
  directValue: T | null | undefined,
  detailsPath?: string,
  defaultValue?: T,
): T | undefined => {
  if (directValue !== null && directValue !== undefined) {
    return directValue
  }

  if (detailsPath && props.news.details) {
    const pathParts = detailsPath.split('.')
    let value: any = props.news.details

    for (const part of pathParts) {
      if (!value || typeof value !== 'object') return defaultValue
      value = value[part]
    }

    return value !== null && value !== undefined ? value : defaultValue
  }

  return defaultValue
}

// Update computed properties
const sourceDisplay = computed(() => {
  const companyName = getContentProperty(null, 'company_name')
  const author = props.news.author

  if (companyName && author) {
    return `${author} • ${companyName}`
  } else if (companyName) {
    return companyName
  } else if (author) {
    return author
  }
  return 'Unknown source'
})

const hasSummary = computed(() => {
  const summaries = getContentProperty<any>(null, 'summaries.undefined')
  return summaries?.[0]?.summary !== undefined
})

const summary = computed(() => {
  if (hasSummary.value) {
    const summaries = getContentProperty<any>(null, 'summaries.undefined')
    return summaries[0].summary
  }
  return props.news.description
})

const voteStore = useVoteStore()
const isFlipped = ref(false)

const showModal = ref(false)
const modalContent = ref('')
const votes = ref(props.news.hot_score || 0)

const currentVote = computed(() => voteStore.getVoteType(props.news.id))
const displayScore = computed(() => voteStore.getScore(props.news.id) ?? props.news.vote_count ?? 0)

const bookmarkStore = useBookmarkStore()
const isBookmarked = computed(() =>
  bookmarkStore.isBookmarked(props.news.id, props.news.content_type),
)

const formatSourceName = (name: string) => {
  // Remove common suffixes like .com, .org, etc. (we might need them for things like space.com, astronomy.com etc)
  // .replace(/\.(com|org|net|io|ai)$/, '')
  return name
}

const readTime = computed(() => {
  // Calculate read time based on content length
  // This is a placeholder, replace with actual logic
  return '2m read time'
})

onMounted(async () => {
  try {
    if (voteStore.getScore(props.news.id) == null)
      voteStore.setVotes(props.news.id, props.news.hot_score || 0)
  } catch (error: any) {
    console.error('Error fetching vote status:', error)
  }
})

const handleVoteChange = ({ change }: { voteType: number | null; change: number }) => {
  votes.value += change
}

const openModal = (feature: string) => {
  modalContent.value = `The ${feature} feature is coming soon! Stay tuned for updates.`
  showModal.value = true
}

const imageSource = computed(() => {
  // if (props.news.featured_image) {
  //   return props.news.featured_image
  // }
  // You can choose either random or deterministic fallbacks
  // return getRandomFallbackImage() // Random each time
  return 'fallback-news.jpg'
  // return null
})

// Handle clicks for touch devices
const handleClick = (event: MouseEvent) => {
  const target = event.target as HTMLElement
  if (target.closest('a') || target.closest('button')) {
    event.stopPropagation()
    return
  }
  isFlipped.value = !isFlipped.value
}

// Handle hover states
const handleMouseEnter = () => {
  isFlipped.value = true
}

const handleMouseLeave = () => {
  isFlipped.value = false
}

// METRICS
const { trackNewsVisit } = useUserMetricsStore()
let cleanupVisit: (() => Promise<void>) | null = null

// Track when user visits source
const handleSourceVisit = async () => {
  cleanupVisit = await trackNewsVisit(props.news.id)
}

// Clean up when component is unmounted
onBeforeUnmount(async () => {
  if (cleanupVisit) {
    await cleanupVisit()
  }
})
</script>

<template>
  <div
    class="group relative h-[450px] perspective-1000 hover:cursor-pointer"
    @click="handleClick"
    @mouseenter="handleMouseEnter"
    @mouseleave="handleMouseLeave"
  >
    <div
      class="relative w-full h-full transition-all duration-500 transform-style-preserve-3d border rounded-lg"
      :class="[
        { 'rotate-y-180': isFlipped },
        isBookmarked ? 'border-amber-500/30 ' : 'border-color',
      ]"
    >
      <!-- Front of card -->
      <div class="absolute w-full h-full backface-hidden">
        <div class="p-4 flex flex-col justify-between h-full">
          <div>
            <div class="flex items-center gap-2 mb-2">
              <!-- Company logo or random image -->
              <div class="flex-shrink-0 w-6 h-6 rounded-full overflow-hidden">
                <NuxtImg
                  :src="
                    news.details?.company_logo ?? `https://picsum.photos/24/24?random=${news.id}`
                  "
                  alt="Source"
                  class="w-full h-full object-cover"
                  width="24"
                  height="24"
                />
              </div>
              <!-- Source and author info -->
              <div class="flex flex-col min-w-0">
                <span
                  v-if="news.details?.company_name"
                  class="font-medium text-sm truncate"
                >
                  {{ formatSourceName(news.details.company_name) }}
                </span>
                <span
                  v-if="news.author"
                  class="text-xs text-gray-400 truncate"
                >
                  {{ news.author }}
                </span>
              </div>
            </div>
            <h3
              class="text-xl font-bold mb-2 line-clamp-3 min-h-[3.5rem]"
              :title="news.title"
            >
              {{ news.title }}
            </h3>
            <div class="flex items-center text-sm mb-4">
              {{ useTimeAgo(new Date(news.published_at ?? news.created_at)).value }}
              <span class="mx-2">•</span>
              <span>{{ readTime }}</span>
            </div>
          </div>
          <div>
            <div
              v-if="imageSource"
              class="mb-4"
            >
              <div class="relative w-full pb-[56.25%]">
                <div
                  class="absolute z-50 w-full h-full flex items-center justify-center text-white font-bold text-xl"
                >
                  <h5> IMAGES SOON </h5>
                </div>
                <!-- :provider="news.featured_image ? 'supabase' : undefined" -->
                <NuxtImg
                  :src="imageSource"
                  :alt="news.title"
                  class="absolute inset-0 w-full h-full object-cover rounded-lg"
                  sizes="sm:100vw md:50vw lg:400px"
                />
              </div>
            </div>
            <NewsActions
              :content="news"
              :score="displayScore"
              :comments-count="null"
              :bookmarked="isBookmarked"
              :url="news.url"
              :current-vote="currentVote"
              card-side="front"
              :on-source-visit="handleSourceVisit"
              @vote-change="handleVoteChange"
              @open-modal="openModal"
            />
          </div>
        </div>
      </div>

      <!-- Back of card -->
      <div
        class="absolute w-full h-full backface-hidden rotate-y-180 bg-primary-950 rounded-lg p-4 flex flex-col"
      >
        <!-- Back side content -->
        <div class="flex-grow overflow-hidden flex flex-col">
          <h3
            class="text-xl font-bold mb-4 line-clamp-1"
            :title="news.title"
          >
            {{ news.title }}</h3
          >
          <div
            v-if="hasSummary"
            class="flex items-center w-full justify-center gap-2 pb-4 text-xs"
          >
            <p class="text-sm overflow-y-auto flex-grow">
              {{ summary }}
            </p>
          </div>
          <div
            v-else
            class="flex items-center w-full justify-center gap-2 pb-4 text-xs"
          >
            <p class="text-sm overflow-y-auto flex-grow">
              {{ news.description }}
            </p>
          </div>
        </div>

        <!-- Back side actions -->
        <NewsActions
          :score="displayScore"
          :comments-count="null"
          :bookmarked="isBookmarked"
          :url="news.url"
          :current-vote="currentVote"
          card-side="back"
          :content="news"
          :on-source-visit="handleSourceVisit"
          @vote-change="handleVoteChange"
          @open-modal="openModal"
        />
      </div>
    </div>
  </div>
</template>

<style scoped>
.perspective-1000 {
  perspective: 1000px;
}

.transform-style-preserve-3d {
  transform-style: preserve-3d;
}

.backface-hidden {
  backface-visibility: hidden;
}

.rotate-y-180 {
  transform: rotateY(180deg);
}

/* Optional: Add a smooth transition for the hover effect */
.transition-transform {
  transition-property: transform;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 500ms;
}

/* Optional: Add hover state styles */
@media (hover: hover) {
  .hover\:cursor-pointer:hover {
    cursor: pointer;
  }
}
</style>

================
File: components/news/NewsCardSkeleton.vue
================
<template>
  <div class="border-b border-color">
    <!-- Avatar skeleton -->
    <div class="p-6 flex gap-4">
      <PrimeSkeleton
        shape="circle"
        size="4rem"
        class="flex-shrink-0"
      />
    </div>

    <!-- Image skeleton -->
    <div class="overflow-hidden w-full">
      <PrimeSkeleton
        width="100%"
        height="220px"
        class="mb-2"
      />
    </div>

    <!-- Text content skeletons -->
    <div class="flex flex-col gap-4 p-4">
      <PrimeSkeleton
        width="8rem"
        height="1rem"
      />
      <PrimeSkeleton
        width="16rem"
        height="1rem"
      />
      <PrimeSkeleton
        width="8rem"
        height="1rem"
      />

      <!-- Button skeleton -->
      <div class="w-full flex justify-end p-2">
        <PrimeSkeleton
          width="8rem"
          height="3rem"
        />
      </div>
    </div>
  </div>
</template>

<script setup lang="ts"></script>

================
File: components/news/NewsModal.vue
================
<template>
  <div class="foreground relative h-full w-full">
    <div
      class="background sticky left-0 top-0 z-20 flex h-auto w-full items-center justify-between px-4 py-2"
    >
      <h3 class="lg:text-lg text-sm font-semibold">
        {{ posts[currentIndex].title }}
      </h3>
      <div class="flex items-center gap-2">
        <PrimeButton
          to="https://tailwindcss.com/docs/content"
          target="_blank"
          icon="material-symbols:chrome-reader-mode-rounded"
          class="flex items-center justify-end lg:after:content-['Full_Article']"
        />
        <PrimeButton
          icon="mdi:close"
          variant="link"
          @click="$emit('closeNewsModal')"
        />
      </div>
    </div>
    <div class="grid h-full w-full grid-cols-1 gap-4 overflow-scroll py-4 xl:grid-cols-4">
      <div class="grid grid-cols-2 gap-4 xl:col-start-4"> </div>
      <div
        v-if="posts[currentIndex].media"
        class="col-start-1 lg:mt-0 xl:col-span-3 xl:row-span-2 xl:row-start-1"
      >
        <LazyImageCarousel
          :media="posts[currentIndex].media"
          class="w-full"
        />
      </div>
      <div
        v-else
        class="col-start-1 overflow-hidden xl:col-span-3 xl:row-span-2 xl:row-start-1"
      >
        <IBImageWithFallback
          :image="undefined"
          :options="{ width: 100, height: 60, quality: 50, sizes: undefined }"
        />
      </div>
      <div class="flex flex-col gap-4">
        <ul class="space-y-2 px-4 pb-8">
          <li
            v-for="sum in posts[currentIndex].summary[summaryLevel]"
            :key="sum"
            class="flex items-start gap-2"
          >
            <Icon
              name="mdi:star"
              class="mt-[3px] flex-shrink-0 text-yellow-500"
              size="18px"
            />
            <p class="flex-grow text-sm leading-snug">
              {{ sum }}
            </p>
          </li>
        </ul>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import type { NewsCardT } from '@/types/news'

defineProps({
  posts: {
    type: Array as () => NewsCardT[],
    required: true,
  },
  currentIndex: {
    type: Number,
    required: true,
  },
  summaryLevel: {
    type: String,
    required: true,
  },
  nextIndex: {
    type: Number,
    required: true,
  },
  previousIndex: {
    type: Number,
    required: true,
  },
  nextPost: {
    type: Function,
    required: true,
  },
  previousPost: {
    type: Function,
    required: true,
  },
})
</script>

================
File: components/news/NewsSummaryLevel.vue
================
<script setup lang="ts">
const summaryLevels = [
  [
    {
      label: 'Beginner',
      value: 'beginner',
      click: () => news.changeSummaryLevel('beginner'),
    },
  ],
  [
    {
      label: 'Intermediate',
      value: 'intermediate',
      click: () => news.changeSummaryLevel('intermediate'),
    },
  ],
  [
    {
      label: 'Expert',
      value: 'expert',
      click: () => news.changeSummaryLevel('expert'),
    },
  ],
]

const selectedLevel = ref('beginner')
</script>

<template>
  <div class="flex w-full gap-2">
    <PrimeButton @click="news.scrapeBlogs"> Scrape Blogs </PrimeButton>
    <PrimeButton @click="storeImage"> Store Image </PrimeButton>
    <PrimeButton @click="news.getBlogs"> Get Blogs </PrimeButton>
    <div class="mb-4 flex w-full justify-end gap-2">
      <PrimeSelect
        v-model="selectedLevel"
        :options="summaryLevels"
        option-label="label"
        placeholder="Choose Summary Level"
        checkmark
        :highlight-on-select="false"
        mode="hover"
        :popper="{ placement: 'bottom-start' }"
      >
        <PrimeButton
          color="white"
          :label="news.summaryLevel"
          trailing-icon="heroicons:chevron-down-20-solid"
        />
      </PrimeSelect>
    </div>
  </div>
</template>

================
File: components/post/PostCard.vue
================
<template>
  <div
    v-for="article in store.articles"
    :key="article.id"
    class="group grid origin-left scale-x-0 animate-swipe-in grid-rows-4 overflow-hidden rounded-md shadow-sm"
  >
    <IBImage
      :img="{
        src: s.image.single({
          bucket: 'articles',
          folderPath: `${article.id}`,
          file: article.id,
          isPrivate: false,
        }),
        alt: article.title,
        loading: 'lazy',
      }"
    />
    <div
      class="relative col-span-1 col-start-1 row-span-2 row-start-3 w-full transition-all duration-500 ease-in-out"
    >
      <div class="foreground absolute bottom-0 w-full p-8">
        <NuxtLink :to="`/news/article/${article.id}`">
          <button
            class="absolute left-0 right-0 top-[-20px] mx-auto h-[40px] w-[80%] rounded-md bg-[#440439] px-8 font-bold shadow-lg before:content-['Category'] group-hover:before:content-['Read_more']"
          />
        </NuxtLink>
        <h1 class="pb-4 text-2xl font-semibold">
          {{ article.title }}
        </h1>
        <p
          class="h-[0px] overflow-hidden text-sm transition-all duration-500 ease-in-out group-hover:h-[100px]"
        >
          {{ article.body }}
        </p>
        <!-- <p class="mt-4 text-sm"> {{ article.publisheAt }}</p> -->
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
const store = useArticlesStore()
const s = useStorage()
await store.getArticles()
// const p = useArticlesStore()
</script>

<style scoped></style>

================
File: components/research/ResearchCard.vue
================
<template>
  <div class="rounded-md border border-color background flex flex-col justify-between">
    <div>
      <div class="space-y-3 p-4">
        <div class="flex gap-2">
          <span class="text-sm w-auto">
            {{ useTimeAgo(research.published_at ?? research.created_at).value }}
          </span>
        </div>
        <h4 class="text-balance text-xl"> {{ research.title.slice(0, 120) }}... </h4>
        <p
          v-if="research.description"
          class="text-sm"
        >
          {{ research.description.slice(0, 360) }}...
        </p>
      </div>
    </div>
    <div class="p-4 flex justify-end items-center">
      <NuxtLink
        :to="getResearchUrl()"
        target="_blank"
        rel="noopener"
      >
        <PrimeButton
          label="Read on Axive"
          size="small"
          outlined
        />
      </NuxtLink>
    </div>
  </div>
</template>

<script setup lang="ts">
// Updated to use the new unified content structure
defineProps({ research: { type: Object, required: true } })

// Helper to get URL based on the new structure
function getResearchUrl() {
  const research = props.research

  // Check if the URL is in the standard field or in details JSONB
  let url = research.url

  if (!url && research.details?.url) {
    url = research.details.url
  }

  // Add version if available
  const version = research.details?.version || research.version
  if (url && version) {
    return `${url}v${version}`
  }

  return url || '#'
}
</script>

================
File: components/search/SearchBar.vue
================
<script setup lang="ts">
const props = defineProps<{
  selectedPrompt?: string
  systemPrompt?: string
}>()

const chatStore = useChatStore()
const { question, isLoading } = storeToRefs(chatStore)

watch(
  () => props.selectedPrompt,
  (newPrompt) => {
    if (newPrompt) {
      question.value = newPrompt
    }
  },
)

const submitQuestion = async () => {
  if (question.value.trim()) {
    await chatStore.submitQuestion({
      question: question.value,
      systemPrompt: props.systemPrompt,
    })
    question.value = ''
  }
}
</script>

<template>
  <div class="w-full">
    <div class="mx-auto flex w-full max-w-3xl items-center">
      <div
        class="foreground border-color flex w-full items-center rounded-lg border px-2 py-1 pr-2"
      >
        <!-- <PrimeButton
          rounded
          :pt="{ root: 'p-5 flex justify-center items-center relative' }"
          severity="secondary"
        >
          <Icon
            :name="textSearchType === 'fts' ? 'mdi:card-text-outline' : 'mdi:format-list-numbered'"
            class="absolute"
                      size="24px"

          />
        </PrimeButton> -->
        <PrimeTextarea
          ref="messageInput"
          v-model="question"
          auto-resize
          placeholder="Ask Your Question..."
          class="flex resize-none max-h-[120px] w-full items-center justify-center bg-transparent px-4 py-2 outline-none"
          :pt="{ root: 'border-none' }"
          @keyup.enter="submitQuestion"
        />
        <PrimeButton
          pt:root:class="p-0"
          link
          @click="submitQuestion"
        >
          <Icon
            :name="isLoading ? 'mdi:loading' : 'mdi:send'"
            class="font-bold text-primary-500"
            size="24px"
            :class="isLoading ? 'animate-spin' : ''"
          />
        </PrimeButton>
      </div>
    </div>
  </div>
</template>

<style scoped></style>

================
File: components/vote/VoteAnimate.vue
================
<script setup lang="ts">
import { ref } from 'vue'

interface Props {
  direction?: 'up' | 'down' | 'none'
  showParticles?: boolean
  contentId: string
}

const props = withDefaults(defineProps<Props>(), {
  direction: 'none',
  showParticles: false,
})

const isAnimating = ref(false)

const createParticles = () => {
  // Debug logging
  console.log('Creating particles for ID:', props.contentId)

  const element = document.querySelector(`#vote-animate-${props.contentId}`)
  if (!element) {
    console.warn('Target element not found:', `#vote-animate-${props.contentId}`)
    return
  }

  const rect = element.getBoundingClientRect()
  console.log('Element position:', rect)

  const particles = 5
  const particleClass = `particle-${props.contentId}`

  // Remove any existing particles first
  document.querySelectorAll(`.${particleClass}`).forEach((el) => el.remove())

  for (let i = 0; i < particles; i++) {
    const particle = document.createElement('div')
    particle.className = particleClass

    // Position particle at button center
    const startX = rect.left + rect.width / 2
    const startY = rect.top + rect.height / 2

    // Calculate random angle and distance
    const angle = Math.random() * Math.PI * 2
    const distance = 30 + Math.random() * 20 // 30-50px distance

    // Calculate end position
    const endX = startX + Math.cos(angle) * distance
    const endY = startY + Math.sin(angle) * distance

    // Set initial position
    particle.style.cssText = `
      position: absolute;
      left: ${startX}px;
      top: ${startY}px;
      width: 8px;
      height: 8px;
      background-color: #3B82F6;
      border-radius: 50%;
      pointer-events: none;
      z-index: 9999;
      transform-origin: center center;
    `

    document.body.appendChild(particle)

    // Force a reflow
    void particle.offsetWidth

    // Add animation styles
    particle.style.transition = 'all 500ms ease-out'
    particle.style.transform = 'translate(0, 0) scale(1)'
    particle.style.opacity = '1'

    // Animate to end position
    requestAnimationFrame(() => {
      particle.style.transform = `translate(${endX - startX}px, ${endY - startY}px) scale(0)`
      particle.style.opacity = '0'
    })

    // Cleanup
    setTimeout(() => {
      if (particle.parentElement) {
        particle.parentElement.removeChild(particle)
      }
    }, 1000)
  }
}

const triggerAnimation = () => {
  console.log('Animation triggered, showParticles:', props.showParticles)
  isAnimating.value = true

  if (props.showParticles) {
    createParticles()
  }

  setTimeout(() => {
    isAnimating.value = false
  }, 300)
}

defineExpose({ triggerAnimation })
</script>

<template>
  <div
    :id="`vote-animate-${contentId}`"
    class="relative inline-block"
    :class="{
      'scale-animation': isAnimating,
      'translate-up': isAnimating && direction === 'up',
      'translate-down': isAnimating && direction === 'down',
    }"
  >
    <slot />
  </div>
</template>

<style>
.animation-wrapper {
  transition: transform 0.2s ease;
  position: relative; /* Ensure this is positioned relative to its parent */
}

.scale-animation {
  animation: popAnimation 300ms ease-in-out;
}

.translate-up {
  transform: translateY(-2px);
}

.translate-down {
  transform: translateY(2px);
}

@keyframes popAnimation {
  0% {
    transform: scale(1);
  }
  50% {
    transform: scale(1.15);
  }
  100% {
    transform: scale(1);
  }
}
</style>

================
File: components/vote/VoteButton.vue
================
// components/VoteButton.vue
<script setup lang="ts">
import { computed, ref } from 'vue'

interface Props {
  contentId: string
  contentType?: string
  count?: number
  direction: 'up' | 'down'
  cardSide: 'front' | 'back'
}

const props = withDefaults(defineProps<Props>(), { contentType: 'news', count: 0 })

const voteStore = useVoteStore()
const notification = useNotification()
const animationRef = ref()

// Convert direction to vote type (1 for up, -1 for down)
const voteType = computed(() => (props.direction === 'up' ? 1 : -1))

const currentVoteType = computed(() => voteStore.getVoteType(props.contentId))
const isPending = computed(() => voteStore.isVotePending(props.contentId))

const isActive = computed(() => {
  return props.direction === 'up' ? currentVoteType.value === 1 : currentVoteType.value === -1
})

onMounted(async () => {
  await voteStore.fetchUserVotes()
})

const handleVote = async () => {
  try {
    // Pass the content type from the new unified structure
    await voteStore.submitVote(props.contentId, voteType.value, props.contentType)
    // Optionally trigger animation
    if (animationRef.value) {
      animationRef.value.triggerAnimation()
    }
  } catch (error) {
    notification.error({ summary: 'Vote Error', message: 'Failed to submit vote' })
  }
}
</script>

<template>
  <div class="relative flex items-center justify-center">
    <VoteAnimate
      ref="animationRef"
      :direction="direction"
      :show-particles="direction === 'up'"
      :content-id="`${contentId}_${cardSide}_${direction}`"
    >
      <button
        class="p-1 rounded-md flex transition-all duration-200 disabled:opacity-50 disabled:cursor-not-allowed"
        :class="[
          'hover:bg-gray-100 dark:hover:bg-gray-800',
          {
            'text-green-500 hover:text-green-600 hover:bg-green-50 dark:hover:bg-green-900/20':
              direction === 'up' && isActive,
            'text-red-500 hover:text-red-600 hover:bg-red-50 dark:hover:bg-red-900/20':
              direction === 'down' && isActive,
            'text-gray-700 dark:text-gray-300 hover:text-gray-600 dark:hover:text-gray-400':
              !isActive,
          },
        ]"
        :disabled="isPending"
        @click="handleVote"
      >
        <Icon
          :name="direction === 'up' ? 'mdi:arrow-up' : 'mdi:arrow-down'"
          class="flex transition-transform duration-200"
          size="20px"
          :class="{ 'scale-125': isActive }"
        />
      </button>
    </VoteAnimate>
  </div>
</template>

<style>
/* Only keeping minimal required custom CSS for the scale transition */
.scale-125 {
  transform: scale(1.25);
}
</style>

================
File: components/AppBackButton.vue
================
<script setup lang="ts"></script>

<template>
  <div class="background flex items-center justify-center gap-2 rounded-md p-2">
    <NuxtLink to="/">
      <PrimeButton label="Go back"> Go Home </PrimeButton>
    </NuxtLink>
    <!-- <AppThemeToggle v-slot="{ toggle, isDark }">
      <Icon
        :name="isDark ? 'heroicons:sun' : 'heroicons:moon'"
        class="cursor-pointer"
                      size="24px"

        @click="toggle"
      />
    </AppThemeToggle> -->
  </div>
</template>

<style scoped></style>

================
File: components/BlackFridayBanner.client.vue
================
<script setup lang="ts">
interface Course {
  id: string
  title: string
  subtitle: string
  link: string
  duration: string
  originalPrice: number
  discountPrice: number
  imageUrl: string
  highlights: string[]
  isNew?: boolean
}

const courses: Course[] = [
  {
    id: 'astronomers-starter-pack',
    title: "Astronomer's Starter Pack",
    subtitle: 'Unravel the Mysteries of the Cosmos',
    link: 'https://www.udemy.com/course/astronomers-starter-pack/?referralCode=D448B234A51124F8A4FC',
    duration: '2 hours',
    originalPrice: 1499,
    discountPrice: 399,
    imageUrl: '/images/course-2.webp', // Path to DALL-E generated image
    isNew: true,
    highlights: [
      'Explore galaxy formation',
      'Understand black holes',
      'Study massive pulsars',
      'Learn about AGNs',
    ],
  },
  {
    id: 'observational-astronomy',
    title: 'Observational Astronomy',
    subtitle: 'For Scientific Applications',
    link: 'https://www.udemy.com/course/observational-astronomy-for-scientific-applications/?referralCode=5A7CE7E94086C6662DF0',
    duration: '3.5 hours',
    originalPrice: 2499,
    discountPrice: 399,
    imageUrl: '/images/course-2.webp', // Path to DALL-E generated image
    highlights: [
      'Conduct home experiments',
      'Master image processing',
      'Track satellites',
      'Hunt exoplanets',
    ],
  },
]

// Use local storage to maintain course rotation
const storageKey = 'lastShownCourseIndex'
const getLastShownIndex = () => {
  const stored = localStorage.getItem(storageKey)
  return stored ? parseInt(stored) : -1
}

const currentCourse = computed(() => {
  const lastIndex = getLastShownIndex()
  const newIndex = (lastIndex + 1) % courses.length
  localStorage.setItem(storageKey, newIndex.toString())
  return courses[newIndex]
})

const formatPrice = (price: number) => {
  return new Intl.NumberFormat('en-IN', {
    style: 'currency',
    currency: 'INR',
    maximumFractionDigits: 0,
  }).format(price)
}

const discountPercentage = computed(() => {
  const course = currentCourse.value
  return Math.round(((course.originalPrice - course.discountPrice) / course.originalPrice) * 100)
})
</script>

<template>
  <div class="bg-gradient-to-r from-purple-900 via-indigo-900 to-blue-900 border-b border-gray-800">
    <div class="max-w-[940px] mx-auto px-4 py-8 md:px-8">
      <!-- Main container with relative positioning for background image -->
      <div class="relative overflow-hidden rounded-xl">
        <!-- Background image with overlay -->
        <div class="absolute inset-0">
          <img
            :src="currentCourse.imageUrl"
            :alt="currentCourse.title"
            class="w-full h-full object-cover"
          />
          <div
            class="absolute inset-0 bg-gradient-to-r from-gray-900/95 via-gray-900/90 to-gray-900/80"
          ></div>
        </div>

        <!-- Content -->
        <div class="relative p-8">
          <!-- Header -->
          <div class="flex flex-wrap items-center gap-3 mb-6">
            <span class="bg-yellow-500 text-black font-bold px-4 py-1.5 rounded-full text-sm"
              >BLACK FRIDAY</span
            >
            <span class="text-yellow-500 font-medium">3 days left!</span>
          </div>

          <!-- Course Info -->
          <div class="max-w-2xl">
            <h2 class="text-3xl md:text-4xl font-bold text-white mb-3">
              {{ currentCourse.title }}
            </h2>
            <p class="text-xl text-gray-200 mb-8">
              {{ currentCourse.subtitle }}
            </p>

            <!-- Course Highlights -->
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-8">
              <div
                v-for="highlight in currentCourse.highlights"
                :key="highlight"
                class="flex items-center gap-3 text-gray-200"
              >
                <Icon
                  name="mdi:check-circle"
                  class="text-green-400 flex-shrink-0"
                  size="20"
                />
                <span class="text-lg">{{ highlight }}</span>
              </div>
            </div>

            <!-- Price and CTA -->
            <div class="flex flex-wrap items-center gap-6">
              <div class="flex items-baseline gap-3">
                <span class="text-3xl font-bold text-white">{{
                  formatPrice(currentCourse.discountPrice)
                }}</span>
                <span class="text-xl text-gray-400 line-through">{{
                  formatPrice(currentCourse.originalPrice)
                }}</span>
                <span class="text-green-400 font-medium text-lg"
                  >{{ discountPercentage }}% off</span
                >
              </div>
              <a
                :href="currentCourse.link"
                target="_blank"
                class="inline-flex items-center gap-2 bg-blue-500 hover:bg-blue-600 text-white px-8 py-3 rounded-full transition-all text-lg font-medium hover:scale-105"
              >
                <Icon
                  name="mdi:rocket-launch"
                  size="20"
                />
                Enroll Now
              </a>
            </div>

            <!-- Money Back Guarantee -->
            <div class="mt-6 text-gray-300 flex items-center gap-2">
              <Icon
                name="mdi:shield-check"
                class="text-green-400"
              />
              30-Day Money-Back Guarantee
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>

<style scoped>
.stars-small,
.stars-medium,
.stars-large {
  position: absolute;
  inset: 0;
  background-image: radial-gradient(1px, rgba(255, 255, 255, 0.5) 1px, transparent 0),
    radial-gradient(2px, rgba(255, 255, 255, 0.3) 1px, transparent 0),
    radial-gradient(3px, rgba(255, 255, 255, 0.2) 1px, transparent 0);
  background-size:
    100px 100px,
    200px 200px,
    300px 300px;
  animation: stars-animation 100s linear infinite;
}

@keyframes stars-animation {
  from {
    transform: translateY(0);
  }
  to {
    transform: translateY(-100%);
  }
}
</style>

================
File: components/ConfirmationDialog.vue
================
<template>
  <PrimeConfirmDialog>
    <template #message="slotProps">
      <div class="flex items-start gap-3">
        <Icon
          v-if="slotProps.message?.icon"
          :name="slotProps.message.icon"
          class="text-2xl"
        />
        <p>{{ slotProps.message?.message }}</p>
      </div>
    </template>
  </PrimeConfirmDialog>
</template>

================
File: components/DeleteConfirmation.vue
================
<script setup lang="ts">
import { computed } from 'vue'

const props = defineProps<{
  show: boolean
  itemName?: string
}>()

const emit = defineEmits<{
  (e: 'confirm'): void
  (e: 'cancel'): void
  (e: 'update:show', value: boolean): void
}>()

const isVisible = computed({
  get: () => props.show,
  set: (value) => emit('update:show', value),
})
</script>

<template>
  <PrimeDialog
    v-model:visible="isVisible"
    modal
    header="Confirm Delete"
    :style="{ width: '90vw', maxWidth: '400px' }"
  >
    <p>Are you sure you want to delete {{ itemName || 'this item' }}?</p>
    <template #footer>
      <PrimeButton
        label="Cancel"
        class="p-button-text"
        @click="$emit('cancel')"
      />
      <PrimeButton
        label="Delete"
        class="p-button-danger"
        @click="$emit('confirm')"
      />
    </template>
  </PrimeDialog>
</template>

================
File: components/EmptyState.vue
================
<script setup lang="ts">
defineProps<{
  isSearching: boolean
}>()
</script>

<template>
  <div class="flex flex-col items-center justify-center h-64 text-gray-500">
    <Icon
      name="mdi:bookmark-outline"
      class="w-12 h-12"
    />
    <p class="mt-4 text-lg">No bookmarks found</p>
    <p class="text-sm">
      {{ isSearching ? 'Try a different search term' : 'Start by bookmarking some articles' }}
    </p>
  </div>
</template>

================
File: components/FeatureRanking.vue
================
<script setup lang="ts">
import { onMounted } from 'vue'

interface Feature {
  id: string
  title: string
  description: string
  status: 'planned' | 'in_progress' | 'completed'
  upvotes: number
  downvotes: number
  priority_score: number
  engagement_score: number
}

const featureStore = useFeatureRequestStore()

onMounted(() => {
  featureStore.fetchFeatures()
})

// Update handleVote function
const handleVote = async (featureId: string, voteType: 1 | -1) => {
  try {
    if (voteType === -1) {
      await featureStore.voteOnFeature(featureId, voteType, '')
    } else {
      await featureStore.voteOnFeature(featureId, voteType)
    }
    // After successful vote, hide the feature
    featureStore.hideFeature(featureId)
  } catch (error: any) {
    console.error('Error voting on feature:', error)
  }
}
</script>

<template>
  <div class="space-y-4">
    <div class="flex items-center justify-between">
      <h3 class="text-lg font-semibold">Shape Our Roadmap</h3>
      <p class="text-sm text-gray-400">Vote on features</p>
    </div>

    <div
      v-if="featureStore.isLoading"
      class="space-y-2 relative"
    >
      <div
        v-for="n in 3"
        :key="n"
        class="h-24 bg-gray-800/50 animate-pulse rounded-lg"
      />
    </div>

    <div
      v-else
      class="space-y-2"
    >
      <TransitionGroup
        name="list"
        tag="div"
        class="space-y-4"
      >
        <div
          v-for="feature in featureStore.visibleFeatures"
          :key="feature.id"
          class="w-full"
        >
          <div
            class="group relative bg-gray-800/50 p-4 rounded-lg border border-gray-700 transition-all duration-300 hover:bg-gray-800"
          >
            <!-- Feature Status Badge -->
            <div class="absolute top-3 right-3">
              <span
                class="px-2 py-1 text-xs rounded-full"
                :class="{
                  'bg-blue-900/50 text-blue-200': feature.status === 'planned',
                  'bg-amber-900/50 text-amber-200': feature.status === 'in_progress',
                  'bg-green-900/50 text-green-200': feature.status === 'completed',
                }"
              >
                {{ feature.status }}
              </span>
            </div>

            <!-- Content -->
            <div class="mb-4">
              <h4 class="text-lg font-medium mb-2">{{ feature.title }}</h4>
              <p class="text-sm text-gray-400">{{ feature.description }}</p>
            </div>

            <!-- Action Bar -->
            <div class="flex items-center justify-end">
              <!-- Actions -->
              <div class="flex items-center gap-2">
                <!-- Upvote -->
                <button
                  class="p-2 hover:bg-gray-700 rounded border border-gray-700 transition-colors duration-200 flex items-center gap-1"
                  :class="{
                    'bg-green-800/50 border-green-700':
                      featureStore.getFeatureVote(feature.id) === 1,
                  }"
                  @click="handleVote(feature.id, 1)"
                >
                  <Icon
                    name="material-symbols:thumb-up"
                    class="w-5 h-5"
                  />
                  <span class="text-sm">{{ feature.upvotes }}</span>
                </button>

                <!-- Downvote -->
                <button
                  class="p-2 hover:bg-gray-700 rounded border border-gray-700 transition-colors duration-200 flex items-center gap-1"
                  :class="{
                    'bg-red-800/50 border-red-700': featureStore.getFeatureVote(feature.id) === -1,
                  }"
                  @click="handleVote(feature.id, -1)"
                >
                  <Icon
                    name="material-symbols:thumb-down"
                    class="w-5 h-5"
                  />
                  <span class="text-sm">{{ feature.downvotes }}</span>
                </button>
              </div>
            </div>
          </div>
        </div>
      </TransitionGroup>
    </div>
  </div>
</template>

<style scoped>
.list-move,
.list-enter-active,
.list-leave-active {
  transition: all 0.4s ease;
}

.list-enter-from,
.list-leave-to {
  opacity: 0;
  transform: translateY(30px);
}

.list-leave-active {
  position: absolute;
  width: calc(100% - 2rem);
}

.list-leave-active .group {
  width: 100%;
}
</style>

================
File: components/FrontiersMessage.vue
================
<script setup lang="ts">
defineProps<{
  isOpen: boolean
}>()

const emit = defineEmits<{
  'update:isOpen': [value: boolean]
  'close': []
}>()

const message = {
  header: 'Starter Plan: A Little More Time, A Lot More Magic',
  body: `
  We know you're eagerly waiting for the launch of our Stardust Plan, and trust us—we're just as excited! But we've decided to hold off the release just a little longer, because why rush when we can make it even better?
  The new launch date is February 5, 2025, and we promise it'll be worth the wait. We're taking this extra time to add some final touches that will make your experience even more extraordinary.
  Thanks for your patience—big things are coming!
  `,
}

const handleClose = () => {
  emit('update:isOpen', false)
  emit('close')
}
</script>

<template>
  <PrimeDialog
    :visible="isOpen"
    @update:visible="handleClose"
    modal
    :header="message.header"
    class="w-[75%] md:w-[50%]"
  >
    {{ message.body }}
  </PrimeDialog>
</template>

<style scoped></style>

================
File: components/FuzzySearch.vue
================
<script setup lang="ts">
import Fuse from 'fuse.js'
import type { FuseResult, IFuseOptions } from 'fuse.js'

interface Props<T> {
  modelValue: string
  placeholder?: string
  data: T[]
  fuseOptions?: IFuseOptions<T>
  debounceMs?: number
}

const props = withDefaults(defineProps<Props<any>>(), {
  placeholder: 'Search...',
  debounceMs: 300,
  fuseOptions: () => ({
    threshold: 0.3,
    shouldSort: true,
  }),
})

const emit = defineEmits<{
  'update:modelValue': [value: string]
  'results': [results: FuseResult<any>[]]
}>()

const searchValue = computed({
  get: () => props.modelValue,
  set: (value) => emit('update:modelValue', value),
})

// Debounced search function
const debouncedSearch = useDebounceFn((query: string) => {
  if (!query.trim()) {
    emit('results', [])
    return
  }

  const fuse = new Fuse(props.data, props.fuseOptions)
  const results = fuse.search(query)
  emit('results', results)
}, props.debounceMs)

// Watch for changes in search value or data
watch(
  [() => searchValue.value, () => props.data],
  ([newQuery]) => {
    debouncedSearch(newQuery)
  },
  { immediate: true },
)
</script>

<template>
  <div class="relative flex-1 w-full">
    <PrimeIconField class="w-full">
      <PrimeInputText
        v-model="searchValue"
        :placeholder="placeholder"
        class="w-full !pr-10"
      />
      <Icon
        name="mdi:magnify"
        class="text-gray-400 absolute right-3 top-1/2 -translate-y-1/2"
      />
    </PrimeIconField>
  </div>
</template>

================
File: components/LoadingState.vue
================
<script setup lang="ts">
defineProps<{
  message?: string
}>()
</script>

<template>
  <div class="flex items-center justify-center h-64">
    <div class="flex flex-col items-center gap-4">
      <Icon
        name="mdi:loading"
        class="w-8 h-8 text-gray-400 animate-spin"
      />
      <span class="text-gray-500">{{ message || 'Loading...' }}</span>
    </div>
  </div>
</template>

================
File: components/PaymentButton.vue
================
<!-- components/payments/RazorpayButton.vue -->
<script setup lang="ts">
interface PlanDetails {
  id: string
  external_plan_id: string
  name: string
  description: string
  amount: number
  currency?: string
  interval?: string
  subscription_id?: string
}

interface CustomerInfo {
  name?: string
  email?: string
  contact?: string
}

interface Props {
  plan: PlanDetails
  customer?: CustomerInfo
  buttonLabel?: string
  buttonIcon?: string
  theme?: {
    color?: string
    logo?: string
  }
  notes?: Record<string, string>
}

const razorpay = usePayments('razorpay')
const toast = useNotification()

const props = withDefaults(defineProps<Props>(), {
  buttonLabel: 'Pay Now',
  buttonIcon: 'pi pi-credit-card',
  theme: () => ({ color: '#4F46E5', logo: '/astronera-logo.jpg' }),
  customer: () => ({}),
  notes: () => ({}),
})

const emit = defineEmits<{
  'payment-success': [response: any]
  'payment-error': [error: any]
  'payment-closed': []
}>()

const { razorpayKey } = useRuntimeConfig()
const loading = ref(false)
const isRazorpayLoaded = ref(false)

const razorpayOptions = computed(() => ({
  key: razorpayKey,
  subscription_id: props.plan.subscription_id,
  subscriptionStartsLater: false,
  amount: props.plan.amount * 100, // Razorpay expects amount in paise
  currency: props.plan.currency || 'INR',
  name: props.plan.name,
  description: props.plan.description,
  image: props.theme.logo,
  handler: function (response: any) {
    emit('payment-success', response)
    unloadRazorpay()
  },
  modal: {
    ondismiss: function () {
      emit('payment-closed')
      loading.value = false
      unloadRazorpay()
    },
  },
  prefill: {
    name: props.customer.name,
    email: props.customer.email,
    contact: props.customer.contact,
  },
  capture: true,
  notes: props.notes,
  theme: {
    color: props.theme.color,
  },
}))

let rzp: any

// Watch for changes in razorpayOptions and recreate instance if needed
watch(
  () => razorpayOptions.value,
  (newOptions) => {
    if (isRazorpayLoaded.value) {
      rzp = new (window as any).Razorpay(newOptions)
    }
  },
  { deep: true },
)

const loadRazorpay = async () => {
  // Create a Promise to ensure the script is fully loaded before proceeding
  await new Promise((resolve, reject) => {
    const script = document.createElement('script')
    script.src = 'https://checkout.razorpay.com/v1/checkout.js'
    script.async = true
    script.onload = () => {
      isRazorpayLoaded.value = true
      resolve(true)
    }
    script.onerror = () => {
      console.error('Failed to load Razorpay script')
      reject(new Error('Razorpay script failed to load'))
    }
    document.head.appendChild(script)
  })

  // Initialize Razorpay after script is loaded
  rzp = new (window as any).Razorpay(razorpayOptions.value)
}

const unloadRazorpay = () => {
  // Locate the Razorpay script by its src
  const script = document.querySelector(
    'script[src="https://checkout.razorpay.com/v1/checkout.js"]',
  )
  if (script) {
    // Remove the script from the DOM
    script.remove()
    isRazorpayLoaded.value = false
    console.log('Razorpay script removed from DOM')
  }
}

const createSubscription = async () => {
  const subscription = await razorpay.createOrder({
    plan_id: props.plan.id,
    external_plan_id: props.plan.external_plan_id,
    total_count: props.plan.interval === 'monthly' ? 1200 : 100,
  })

  if (subscription.start_at > Date.now() / 1000) {
    razorpayOptions.value.subscriptionStartsLater = true
  }
  razorpayOptions.value.subscription_id = subscription.id
}

const handlePayment = async () => {
  loading.value = true
  if (!razorpayOptions.value.subscription_id) await createSubscription()

  if (razorpayOptions.value.subscriptionStartsLater) {
    toast.success({
      summary: 'Subscription Created',
      message:
        'Your new subscription will start and will be charged at the end of your current subscription',
    })
    return
  }

  await loadRazorpay()

  try {
    rzp.open()
  } catch (error: any) {
    emit('payment-error', error)
    loading.value = false
  }
}

onUnmounted(() => {
  loading.value = false
  unloadRazorpay()
})
</script>

<template>
  <PrimeButton
    :label="buttonLabel"
    :icon="buttonIcon"
    :loading="loading"
    @click="handlePayment"
  />
</template>

================
File: components/RoleOverride.vue
================
<template>
  <div
    v-if="isDev"
    class="relative"
  >
    <div
      class="px-4 py-1 flex items-center justify-between z-[1000] transition-colors duration-200"
      :class="bannerColorClass"
    >
      <div class="flex text-sm items-center space-x-2">
        <span class="text-white">
          {{ currentRole ? `Viewing as ${currentRole}` : 'Using original role' }}
        </span>
        <span
          v-if="actualRole && actualRole !== currentRole"
          class="text-red-200 font-medium text-sm"
        >
          (Warning: Actual role is {{ actualRole }})
        </span>
      </div>

      <div class="flex items-center space-x-2">
        <select
          v-model="currentRole"
          :disabled="isChangingRole"
          class="text-xs px-2 py-1 rounded bg-opacity-20 bg-white text-white border border-white/20 focus:outline-none focus:ring-2 focus:ring-white/50 disabled:opacity-50"
          @change="handleRoleChange"
        >
          <option value="">Original Role</option>
          <option
            v-for="role in availableRoles"
            :key="role"
            :value="role"
          >
            {{ role }}
          </option>
        </select>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed } from 'vue'

const isDev = computed(() => {
  const config = useRuntimeConfig()
  return config.public.nodeEnv === 'development'
})

const { setRoleOverride, getCurrentRole } = useRoleOverride()
const currentRole = ref('')
const actualRole = ref('')
const isChangingRole = ref(false)

const checkRole = () => {
  const role = getCurrentRole()
  // Only update if actually different to prevent unnecessary re-renders
  if (actualRole.value !== role) {
    actualRole.value = role
  }
}

onMounted(() => {
  checkRole()
  const interval = setInterval(checkRole, 2000)
  onUnmounted(() => clearInterval(interval)) // Clean up the interval
})

const availableRoles = ['super_admin', 'admin', 'user', 'guest']

const handleRoleChange = async () => {
  try {
    isChangingRole.value = true
    await setRoleOverride(currentRole.value || null)
    // Check a few times after change to ensure we catch the update
    const checks = [100, 500, 1000, 2000] // Check at different intervals
    checks.forEach((delay) => setTimeout(checkRole, delay))
  } catch (error: any) {
    console.error('Failed to change role:', error)
    // Maybe reset the select?
    currentRole.value = actualRole.value
  } finally {
    isChangingRole.value = false
  }
}

const bannerColorClass = computed(() => {
  switch (currentRole.value) {
    case 'super_admin':
      return 'bg-red-600'
    case 'admin':
      return 'bg-purple-600'
    case 'user':
      return 'bg-blue-600'
    case 'guest':
      return 'bg-gray-600'
    default:
      return 'bg-green-600'
  }
})
</script>

================
File: components/TestSelect.vue
================
<script setup lang="ts">
import { ref, computed } from 'vue'

interface TestData {
  id: string | number
  [key: string]: any
}

// Test configuration options
const testConfig = ref({
  tableName: 'user_profiles', // can be changed to test different tables
  columns: '*',
  enablePagination: true,
  pageSize: 20,
  enableOrdering: true,
  orderColumn: 'created_at',
  orderAscending: false,
  enableFilters: false,
  filterColumn: '',
  filterValue: '',
})

// Computed configuration object for useSelectData
const selectConfig = computed(() => {
  const paginationConfig = testConfig.value.enablePagination
    ? { page: 1, limit: testConfig.value.pageSize }
    : undefined

  const orderByConfig = testConfig.value.enableOrdering
    ? {
        column: testConfig.value.orderColumn,
        ascending: testConfig.value.orderAscending,
      }
    : undefined

  const filtersConfig =
    testConfig.value.enableFilters && testConfig.value.filterColumn
      ? {
          [testConfig.value.filterColumn]: { eq: testConfig.value.filterValue },
        }
      : undefined

  return {
    columns: testConfig.value.columns,
    initialFetch: true,
    pagination: paginationConfig,
    orderBy: orderByConfig,
    filters: filtersConfig,
  }
})

// Initialize useSelectData with the computed config
const { store, loadMore, refresh, isSelecting } = useSelectData<TestData>(
  testConfig.value.tableName,
  selectConfig.value,
)

// Get the items from the store
const { items } = storeToRefs(store)

// Debug logging
watch(
  items,
  (newItems) => {
    console.log('Items updated:', newItems)
  },
  { deep: true },
)

// Methods
const handleRefresh = async () => {
  console.log('Refreshing with config:', selectConfig.value)
  await refresh()
}

const handleLoadMore = async () => {
  console.log('Loading more with config:', selectConfig.value)
  await loadMore()
}

const switchTable = (newTable: string) => {
  testConfig.value.tableName = newTable
  refresh()
}
</script>

<template>
  <div class="p-4">
    <div class="mb-8 space-y-4 bg-gray-100 p-4 rounded-lg">
      <h2 class="text-xl font-bold">Test Configuration</h2>

      <!-- Table Selection -->
      <div class="flex gap-4 items-center">
        <label class="font-medium">Table:</label>
        <select
          v-model="testConfig.tableName"
          class="border rounded p-1"
        >
          <option value="user_profiles">Users</option>
          <option value="news">News</option>
          <option value="comments">Comments</option>
        </select>
      </div>

      <!-- Columns -->
      <div class="flex gap-4 items-center">
        <label class="font-medium">Columns:</label>
        <input
          v-model="testConfig.columns"
          class="border rounded p-1"
          placeholder="e.g. id, name, email"
        />
      </div>

      <!-- Pagination -->
      <div class="space-y-2">
        <div class="flex gap-4 items-center">
          <label class="font-medium">Enable Pagination:</label>
          <input
            type="checkbox"
            v-model="testConfig.enablePagination"
          />
        </div>
        <div
          v-if="testConfig.enablePagination"
          class="flex gap-4 items-center ml-4"
        >
          <label>Page Size:</label>
          <input
            type="number"
            v-model="testConfig.pageSize"
            class="border rounded p-1 w-20"
          />
        </div>
      </div>

      <!-- Ordering -->
      <div class="space-y-2">
        <div class="flex gap-4 items-center">
          <label class="font-medium">Enable Ordering:</label>
          <input
            type="checkbox"
            v-model="testConfig.enableOrdering"
          />
        </div>
        <div
          v-if="testConfig.enableOrdering"
          class="flex gap-4 items-center ml-4"
        >
          <label>Order Column:</label>
          <input
            v-model="testConfig.orderColumn"
            class="border rounded p-1"
          />
          <label>Ascending:</label>
          <input
            type="checkbox"
            v-model="testConfig.orderAscending"
          />
        </div>
      </div>

      <!-- Filters -->
      <div class="space-y-2">
        <div class="flex gap-4 items-center">
          <label class="font-medium">Enable Filters:</label>
          <input
            type="checkbox"
            v-model="testConfig.enableFilters"
          />
        </div>
        <div
          v-if="testConfig.enableFilters"
          class="space-y-2 ml-4"
        >
          <div class="flex gap-4 items-center">
            <label>Filter Column:</label>
            <input
              v-model="testConfig.filterColumn"
              class="border rounded p-1"
            />
          </div>
          <div class="flex gap-4 items-center">
            <label>Filter Value:</label>
            <input
              v-model="testConfig.filterValue"
              class="border rounded p-1"
            />
          </div>
        </div>
      </div>
    </div>

    <!-- Actions -->
    <div class="flex gap-4 mb-4">
      <button
        @click="handleRefresh"
        class="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600"
        :disabled="isSelecting"
      >
        Refresh Data
      </button>
      <button
        @click="handleLoadMore"
        class="bg-green-500 text-white px-4 py-2 rounded hover:bg-green-600"
        :disabled="isSelecting"
      >
        Load More
      </button>
    </div>

    <!-- Loading State -->
    <div
      v-if="isSelecting"
      class="mb-4"
    >
      Loading...
    </div>

    <!-- Results -->
    <div class="space-y-4">
      <h3 class="text-lg font-bold">Results</h3>
      <pre class="bg-gray-100 p-4 rounded overflow-auto max-h-96">{{ items }}</pre>
    </div>

    <!-- Debug Info -->
    <div class="mt-8 space-y-4">
      <h3 class="text-lg font-bold">Current Configuration</h3>
      <pre class="bg-gray-100 p-4 rounded overflow-auto">{{ selectConfig }}</pre>
    </div>
  </div>
</template>

================
File: components/TurnstileChallenge.client.vue
================
<template>
  <div>
    <div class="cf-turnstile"></div>
  </div>
</template>

<script setup lang="ts">
const props = defineProps({
  onValidToken: {
    type: Function,
    required: true,
  },
})

const scriptLoaded = ref(false)
const turnstileWidgetId = ref(null)

const emit = defineEmits(['error', 'expired', 'success'])
const config = useRuntimeConfig()
const colorMode = useColorMode()

const TURNSTILE_URL = 'https://challenges.cloudflare.com/turnstile/v0/api.js?render=explicit'

// Load Turnstile script
useHead({
  script: [
    {
      src: TURNSTILE_URL,
      async: true,
      defer: true,
      onload: () => {
        console.log('Turnstile script loaded successfully')
        scriptLoaded.value = true
      },
      onerror: () => {
        console.error('Failed to load Turnstile script')
      },
    },
  ],
})

const onSuccess = async (token) => {
  try {
    // Call server API to validate token
    const response = await $fetch('/validate-turnstile', {
      method: 'POST',
      body: { token },
    })

    if (response.success) {
      props.onValidToken(token)
      emit('success', token)
    } else {
      console.error('Turnstile validation failed')
      emit('error', new Error('Validation failed'))
    }
  } catch (error: any) {
    console.error('Error validating Turnstile token:', error)
    emit('error', error)
  }
}

const onError = (error: any) => {
  console.error('Turnstile error:', error)
  emit('error', error)
}

const onExpired = () => {
  console.warn('Turnstile token expired')
  emit('expired')
}

const reset = () => {
  const cloudflareCookies = ['__cf_bm', 'cf_clearance', '__cfwaitingroom']

  cloudflareCookies.forEach((cookieName) => {
    document.cookie = `${cookieName}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;`
  })

  if (window.turnstile && turnstileWidgetId.value) {
    window.turnstile.reset(turnstileWidgetId.value)
  }
}

const renderTurnstile = () => {
  if (window.turnstile) {
    if (turnstileWidgetId.value) {
      window.turnstile.remove(turnstileWidgetId.value)
    }

    turnstileWidgetId.value = window.turnstile.render('.cf-turnstile', {
      'sitekey': config.public.turnstileSiteKey,
      'theme': colorMode.value === 'dark' ? 'dark' : 'light',
      'callback': props.onValidToken,
      'error-callback': onError,
      'expired-callback': onExpired,
    })
  }
}

onMounted(() => {
  if (document.querySelector(`script[src="${TURNSTILE_URL}"]`)) {
    renderTurnstile()
  }

  watch(scriptLoaded, (loaded) => {
    if (loaded) {
      renderTurnstile()
    }
  })
})

// Expose reset method to parent components
defineExpose({ reset })
</script>

================
File: components/UploadCropper.vue
================
<script setup lang="ts">
import type { CropperResult, ImageTransforms } from 'vue-advanced-cropper'
import { Cropper, Preview } from 'vue-advanced-cropper'
import 'vue-advanced-cropper/dist/style.css'
import { useCurrentUser, useFileUpload, useNotification } from '#imports'

type CropperConfigTypes = 'avatar' | 'default'

const MAX_FILE_SIZE = 5 * 1024 * 1024 // 5 MB
const emit = defineEmits(['profile-pic-update'])
const uploadInput = ref(null as HTMLInputElement | null)
const image = ref<string>('')

const props = defineProps({
  cropperType: {
    type: String as PropType<CropperConfigTypes>,
    required: true,
  },
  bucket: {
    type: String,
    required: false,
    default: 'profile',
  },
  requireCropping: {
    type: Boolean,
    default: true,
  },
})

const config = computed(() => cropperConfigs[props.cropperType])

export interface CropperConfig {
  name: string
  minHeight: number
  minWidth: number
  maxHeight?: number
  maxWidth?: number
  stencilComponent?: string
  canvas: {
    minWidth: number
    minHeight: number
    maxWidth: number
    maxHeight: number
  }
  stencilSize?: {
    width: number
    height: number
  }
  stencilProps: {
    handlers?: Record<string, any>
    movable: boolean
    resizable?: boolean
    aspectRatio?: number
  }
}

const cropperConfigs: Record<CropperConfigTypes, CropperConfig> = {
  default: {
    name: 'Default',
    minWidth: 160,
    minHeight: 160,
    canvas: {
      minHeight: 0,
      minWidth: 0,
      maxHeight: 480,
      maxWidth: 480,
    },
    stencilProps: {
      aspectRatio: 1,
      movable: true,
    },
  },
  avatar: {
    name: 'avatar',
    minHeight: 160,
    minWidth: 160,
    canvas: {
      minHeight: 0,
      minWidth: 0,
      maxHeight: 480,
      maxWidth: 480,
    },
    stencilProps: {
      aspectRatio: 1,
      movable: true,
    },
  },
}
const { uploadFile, isUploading, uploadProgress } = useFileUpload()
const userStore = useCurrentUser()
const { profile } = storeToRefs(userStore)
const toast = useNotification()

// Checks & Utils
type Compression = 'lossy' | 'lossless' | 'alpha' | 'animation'
function checkWebpFeature(feature: Compression): Promise<boolean> {
  return new Promise((resolve) => {
    const kTestImages = {
      lossy: 'UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA',
      lossless: 'UklGRhoAAABXRUJQVlA4TA0AAAAvAAAAEAcQERGIiP4HAA==',
      alpha:
        'UklGRkoAAABXRUJQVlA4WAoAAAAQAAAAAAAAAAAAQUxQSAwAAAARBxAR/Q9ERP8DAABWUDggGAAAABQBAJ0BKgEAAQAAAP4AAA3AAP7mtQAAAA==',
      animation:
        'UklGRlIAAABXRUJQVlA4WAoAAAASAAAAAAAAAAAAQU5JTQYAAAD/////AABBTk1GJgAAAAAAAAAAAAAAAAAAAGQAAABWUDhMDQAAAC8AAAAQBxAREYiI/gcA',
    }

    const img = new Image()
    img.onload = () => resolve(true)
    img.onerror = () => resolve(false)
    img.src = 'data:image/webp;base64,' + kTestImages[feature]
  })
}

const webpSupport = ref(false)
onMounted(async () => {
  for (const feature of ['lossy', 'lossless', 'alpha', 'animation'] as Compression[]) {
    const result = await checkWebpFeature(feature)
    if (result) {
      webpSupport.value = true
      break
    }
  }
})

async function uploadImage(blob: Blob) {
  try {
    const supabase = useSupabaseClient()

    const result = await uploadFile(new File([blob], 'image.webp', { type: 'image/webp' }), {
      bucket: props.bucket,
      fileType: 'image',
      userId: profile.value.id,
      serverSideOptimize: true,
      maxWidth: 1200,
      maxHeight: 1200,
      quality: 90,
      format: 'webp',
      maxFileSize: MAX_FILE_SIZE,
      allowedMimeTypes: ['image/jpeg', 'image/jpg', 'image/png', 'image/webp'],
      replace: props.cropperType === 'avatar',
      onProgress: (progress) => {
        console.log(`Upload progress: ${progress}%`)
      },
    })

    if (props.cropperType === 'avatar') {
      emit('profile-pic-update', result.publicUrl)
    }

    return result
  } catch (error: any) {
    setError(`Failed to upload image: ${error.message}`)
    throw error
  }
}

// Cropper
const cropper = ref(null as typeof Cropper | null)
const crop = async (toggleModalOpen: () => void) => {
  if (!cropper.value) {
    setError('No cropper instance in crop function.')
    toggleModalOpen()
    return
  }

  const { canvas } = cropper.value.getResult()
  if (!canvas) {
    setError('Cropper failed to get canvas')
    toggleModalOpen()
    return
  }

  const exportMimeType = webpSupport.value ? 'image/webp' : 'image/jpeg'

  canvas.toBlob(
    async (blob) => {
      if (!blob) {
        setError('Failed to convert canvas to blob.')
        return
      }
      try {
        await uploadImage(blob)
        toggleModalOpen()
      } catch (error: any) {
        console.error('Error uploading cropped image:', error)
      }
    },
    exportMimeType,
    0.9,
  )
}

async function handleFileChange(e: Event, toggleModalOpen: () => void) {
  const input = e.target as HTMLInputElement
  if (!input.files?.length) return

  const file = input.files[0]

  if (!validateFileSize(file.size)) {
    return
  }

  try {
    if (props.requireCropping) {
      image.value = await readFileAsDataURL(file)
      if (!(await checkImageDimensions(image.value, props.cropperType))) {
        return
      }
      toggleModalOpen()
    } else {
      await uploadImage(file)
    }
  } catch (error: any) {
    setError(`An error occurred while processing the file: ${error.message}`)
  } finally {
    if (input) input.value = ''
  }
}

const preview = reactive<CropperResult>({
  image: {
    width: 0,
    height: 0,
    transforms: {} as ImageTransforms,
    src: null,
  },
  visibleArea: {
    width: 0,
    height: 0,
    left: 0,
    top: 0,
  },
  coordinates: {
    left: 0,
    top: 0,
    width: 0,
    height: 0,
  },
})

function onChange({ coordinates, image, canvas }: CropperResult) {
  // realtime changes in the cropper
  if (!coordinates || !image) return

  preview.coordinates = coordinates
  preview.image = image
}

// original file
type CropperConfigDimensions = {
  [key in CropperConfigTypes]: { minWidth: number; minHeight: number }
}

function checkImageDimensions(imageSrc: string, cropperType: CropperConfigTypes): Promise<boolean> {
  const dimensions: CropperConfigDimensions = {
    default: { minWidth: 800, minHeight: 600 },
    avatar: { minWidth: 160, minHeight: 160 },
  }

  return new Promise((resolve) => {
    const img = new Image()
    img.onload = () => {
      const { minWidth, minHeight } = dimensions[cropperType]
      console.log('cropper mins', minHeight, minWidth, img.width, img.height)
      if (img.width >= minWidth && img.height >= minHeight) {
        resolve(true)
      } else {
        setError(
          `Image dimensions must be at least ${minWidth}x${minHeight}px for ${cropperType}. (dimensions ${img.width}x${img.height})`,
        )
        resolve(false)
      }
    }
    img.onerror = () => {
      setError('Failed to load image for dimension check.')
      resolve(false)
    }
    img.src = imageSrc
  })
}

function readFileAsDataURL(file: File): Promise<string> {
  return new Promise((resolve, reject) => {
    const reader = new FileReader()
    reader.onload = () => resolve(reader.result as string)
    reader.onerror = () => reject(reader.error)
    reader.onerror = () => {
      setError(`Failed to read the file: ${reader.error?.message}`)
      reject(new Error(`Failed to read the file: ${reader.error?.message}`))
    }

    reader.readAsDataURL(file)
  })
}

function validateFileSize(fileSize: number): boolean {
  if (fileSize > MAX_FILE_SIZE) {
    setError('File is too large. Please select a file smaller than 5MB.')
    return false
  }
  return true
}

const setError = (error: string) => {
  toast.error({
    summary: 'Error',
    message: error,
  })
}
</script>

<template>
  <div class="space-y-24">
    <IBModal>
      <template #button="{ toggleModalOpen }">
        <label
          v-ripple
          :for="`myFile-${cropperType}`"
          class="cursor-pointer border-color bg-primary rounded-lg border px-2 py-1 text-sm"
        >
          Upload {{ cropperType }}
        </label>
        <input
          :id="`myFile-${cropperType}`"
          ref="uploadInput"
          type="file"
          accept="image/jpg, image/jpeg, image/png, image/webp"
          name="filename"
          class="hidden"
          @change="handleFileChange($event, toggleModalOpen)"
        />
      </template>
      <template #modal:header>
        <h2 class="text-xl font-semibold"> Crop your image </h2>
      </template>
      <template #modal:default>
        <Cropper
          v-if="requireCropping"
          ref="cropper"
          :src="image"
          :min-width="config.minWidth"
          :min-height="config.minHeight"
          :canvas="config.canvas"
          :stencil-props="config.stencilProps"
          :debounce="false"
          @change="onChange"
          @error="setError('error loading image')"
        />
        <div
          v-else-if="isUploading"
          class="text-center"
        >
          <p>Uploading: {{ uploadProgress }}%</p>
          <PrimeProgressBar :value="uploadProgress" />
        </div>
      </template>
      <template #modal:footer="{ toggleModalOpen }">
        <div
          v-if="requireCropping"
          class="flex items-center justify-center gap-4"
        >
          <p>Image preview</p>
          <Preview
            v-if="preview.image && config.minWidth"
            class="rounded-full"
            :width="Math.floor(config.minWidth / 3)"
            :height="Math.floor(config.minHeight / 3)"
            :image="preview.image"
            :coordinates="preview.coordinates"
          />
          <PrimeButton
            :disabled="isUploading"
            @click="crop(toggleModalOpen)"
          >
            {{ isUploading ? 'Uploading...' : 'Crop & Upload' }}
          </PrimeButton>
        </div>
      </template>
    </IBModal>
  </div>
</template>

<style scoped></style>

================
File: composables/users/user-settings.store.ts
================
type SettingsKey = 'usersStore' | 'storeNews'

export const useUserSettingsStore = defineStore('settingsStore', () => {
  const settings = ref({} as Settings)

  function toggleSettings(key: SettingsKey) {
    settings.value[key] = !settings.value[key]
  }

  function isSettingsOn(key: SettingsKey) {
    return !settings.value[key]
  }

  return {
    settings,
    toggleSettings,
    isSettingsOn,
  }
})

if (import.meta.hot) {
  import.meta.hot.accept(acceptHMRUpdate(useUserSettingsStore, import.meta.hot))
}

================
File: composables/users/user.admin.composable.ts
================
import { emailUnvalidatedUserSchema } from '../../..auth/types/auth'
import type { UserRowType } from '~/types/users'

interface NewUser {
  email: string
  password: string
}

const DOMAIN_KEY = 'useAdmin'

export function useAdmin() {
  const errors = useBaseError()
  const log = useLogger(DOMAIN_KEY)
  const utils = useUtils()
  const client = useSupabaseClient()
  const toast = useNotification()
  const createdUsers = ref([] as NewUser[])

  const register = async ({ email, password }: { email: string; password: string }) => {
    const { data, error } = await client.auth.signUp({
      email,
      password,
    })
    if (error) {
      throw createError({
        statusCode: 401,
        message: error.message,
      })
    }

    const validatedUser = emailUnvalidatedUserSchema.safeParse(data.user)

    if (!validatedUser.success) {
      throw createError(validatedUser.error)
    }

    return validatedUser.data
  }

  async function addProfilePicture(userId: string, file: File) {
    try {
      const { data, error } = await client.storage
        .from('profile-public')
        .upload(`${userId}/avatar/${file.name}`, file)
      if (error) {
        throw createError(
          `Error uploading profile picture for user with ID ${userId}: ${error.message}`,
        )
      }
      console.log(`Profile picture uploaded successfully for user with ID ${userId}`)
    } catch (error: any) {
      console.error(`Error uploading profile picture for user with ID ${userId}:`, error)
    }
  }

  async function registerManyUsers() {
    const users: UserRowType[] = []
    for (const user of users) {
      // Extract the given name and surname
      const givenName = user.given_name.charAt(0).toUpperCase() + user.given_name.slice(1)
      const surname = user.surname.charAt(0).toUpperCase() + user.surname.slice(1)

      // Construct the password
      const password = `${givenName}${surname}12345$`

      // Register the user
      try {
        // const newUser = await register({ email: user.email, password })
        // we handle user profile creation with a database trigger
        // now seed the database with the user data
        // createdUsers.value.push({ email: user.email, password })

        // Locate the profile image file based on the user's given name and surname
        const imageName = `${givenName.toLowerCase()}-${surname.toLowerCase()}.jpg`
        const imagePath = `/data/seed/avatars/${imageName}` // Adjust the path as necessary
        const imageFile = new File([await fetch(imagePath).then((r) => r.blob())], imageName, {
          type: 'image/jpeg',
        })

        console.log('file exists', imageFile.size)
        // Upload the profile image
        await addProfilePicture(newUser.id, imageFile)

        // update user profile with data
        await updateSingle(user, newUser.id)
      } catch (error: any) {
        console.error(`Failed to register user with email ${user.email}:`, error)
      }
    }
  }

  async function updateUser(newData: any, oldData: any) {
    log.info(`Updating user with email ${newData.email}`)
    // we should first parse the data to check if anything has changed and then filter out any undefined values
    try {
      const { noDataUpdated, data: updatedData } = utils.wasRowDataUpdated(newData, oldData)

      if (noDataUpdated) {
        log.info('No changes detected, no update necessary')
        return
      }

      const response = await $fetch('/api/users/update', {
        method: 'POST',
        body: {
          data: updatedData,
          id: newData.id,
        },
      })

      const data = errors.server({
        response,
        devOnly: false,
        showSuccess: true,
        devMessage: `Error updating user with email ${newData.email}`,
        userMessage: `There was an error updating user with email ${newData.email}`,
      })

      log.info(`User with email ${data.email} updated successfully`)
      toast.success({
        summary: 'Success',
        message: `User with email ${data.email} updated successfully`,
      })

      // maybe update state here
    } catch (error: any) {
      errors.client({
        error,
        devOnly: false,
        devMessage: `Error updating user with email ${newData.email}`,
        userMessage: `There was an error updating user with email ${newData.email}`,
      })
    }
  }

  return {
    registerManyUsers,
    updateUser,
    createdUsers,
  }
}

================
File: composables/category-tags.store.ts
================
import { z } from 'zod'

const CategorySchema = z.object({
  id: z.number(),
  name: z.string(),
  body: z.string().nullish(),
  created_at: z.string().optional(),
  updated_at: z.string().optional(),
})

const TagSchema = z.object({
  id: z.number(),
  name: z.string(),
  body: z.string().nullish(),
  created_at: z.string().optional(),
  updated_at: z.string().optional(),
})

type Category = z.infer<typeof CategorySchema>
type Tag = z.infer<typeof TagSchema>

export const useCategoryTagStore = defineStore('categoryTagStore', () => {
  const logger = useLogger('categoryTagStore')
  const categories = ref<Category[]>([])
  const tags = ref<Tag[]>([])
  const localStorage = useBaseLocalStorage()
  const errors = useBaseError()

  const client = useSupabaseClient()

  async function getCategories() {
    try {
      categories.value = await localStorage.getCachedOrFetch('astronera-categories', async () => {
        const { data, error } = await client.from('categories').select('id, name')
        if (error) throw error
        return z.array(CategorySchema).parse(data)
      })
    } catch (error: any) {
      logger.error('Error fetching categories:', error)
      errors.server({
        error,
        devOnly: true,
        devMessage: 'Error Fetching Categories from DB',
        userMessage: 'There was an error getting Categories from the database',
      })
    }
  }

  async function getTags() {
    try {
      tags.value = await localStorage.getCachedOrFetch('astronera-tags', async () => {
        const { data, error } = await client.from('tags').select('id, name')
        if (error) throw error
        return z.array(TagSchema).parse(data)
      })
    } catch (error: any) {
      logger.error('Error fetching tags:', error)
      errors.server({
        error,
        devOnly: true,
        devMessage: 'Error Fetching Tags from DB',
        userMessage: 'There was an error getting Tags from the database',
      })
    }
  }

  const getCategoryName = computed(
    () => (categoryId: number) =>
      categories.value.find((category) => category.id === categoryId)?.name,
  )

  const getTagName = computed(
    () => (tagId: number) => tags.value.find((tag) => tag.id === tagId)?.name,
  )

  return {
    categories,
    tags,
    getCategories,
    getTags,
    getCategoryName,
    getTagName,
    clearAllCaches: localStorage.clearAllCaches,
  }
})

if (import.meta.hot) {
  import.meta.hot.accept(acceptHMRUpdate(useCategoryTagStore, import.meta.hot))
}

================
File: composables/chat.store.ts
================
import { z } from 'zod'

const ChatCompletionSchema = z.object({
  id: z.string(),
  object: z.string(),
  created: z.number(),
  model: z.string(),
  system_fingerprint: z.string(),
  choices: z.array(
    z.object({
      index: z.number(),
      message: z.object({
        role: z.string(),
        content: z.string(),
      }),
      finish_reason: z.string(),
      logprobs: z.null(),
    }),
  ),
  usage: z.object({
    prompt_tokens: z.number(),
    completion_tokens: z.number(),
    total_tokens: z.number(),
    prompt_time: z.number(),
    completion_time: z.number(),
    total_time: z.number(),
  }),
  x_groq: z.object({
    id: z.string(),
  }),
})

type Chat = z.infer<typeof ChatCompletionSchema>

export const useChatStore = defineStore('chatStore', () => {
  const { fetch } = useBaseFetch()
  const loading = useLoadingStore()
  const client = useSupabaseClient()
  const errors = useBaseError()

  const domainKey = 'chat'
  const logger = useLogger(domainKey)

  const chat = ref({} as Chat)
  const messages = ref<Array<{ role: 'user' | 'assistant' | 'system'; content: string }>>([])

  const question = ref('' as string)

  // function handleNavigation() {
  //   const route = useRoute()
  //   if (route.path === '/ask') {
  //     return
  //   }
  //   navigateTo('/ask')
  // }

  async function insertSearchData(userId: string) {
    const response = await client
      .from('searches')
      .insert({
        input: question.value,
        created_at: new Date().toISOString(),
        user_id: userId,
      })
      .select()

    return errors.server({
      response,
      devOnly: true,
      devMessage: 'error inserting search data',
      userMessage: 'something went wrong when inserting search data',
    })
  }

  async function insertResponseData(searchId: number, questionResponseData: Chat) {
    const response = await client.from('responses').insert({
      search_id: searchId,
      output: questionResponseData.choices[0]?.message?.content,
      created_at: new Date().toISOString(),
    })
    return errors.server({
      response,
      devOnly: true,
      devMessage: 'error inserting response data',
      userMessage: 'something went wrong when inserting response data',
    })
  }

  function addMessage(role: 'user' | 'assistant' | 'system', content: string) {
    messages.value.push({ role, content })
  }

  async function submitQuestion(args: { question: string; systemPrompt: string }) {
    console.log('searchMessage', args)

    if (loading.isLoading(domainKey)) {
      return null
    }

    loading.setLoading(domainKey, true)

    try {
      addMessage('user', args.question)

      const messageHistory = messages.value.slice(-5) // Get last 5 messages

      const formattedMessages = [
        ...(args.systemPrompt ? [{ role: 'system', content: args.systemPrompt }] : []),
        ...messageHistory,
      ]

      const questionResponse = await fetch('/api/ai/ask', {
        method: 'POST',
        body: JSON.stringify({
          messages: formattedMessages,
        }),
        headers: {
          'Content-Type': 'application/json',
        },
      })

      const questionResponseData: Chat = errors.server({
        response: questionResponse,
        devOnly: true,
        devMessage: 'error fetching question response',
        userMessage: 'something went wrong when fetching question response',
      })

      addMessage('assistant', questionResponseData.choices[0]?.message?.content)

      // const search = await insertSearchData(userId)
      // insertResponseData(search[0].id, questionResponseData)
    } catch (error: any) {
      console.error('Error submitting question and handling response:', error)
    } finally {
      await loading.setLoadingInterval(domainKey, false, 1000)
    }
  }

  return {
    isLoading: computed(() => loading.isLoading(domainKey)),
    chat,
    question,
    messages,
    addMessage,
    submitQuestion,
  }
})

if (import.meta.hot) {
  import.meta.hot.accept(acceptHMRUpdate(useChatStore, import.meta.hot))
}

================
File: composables/chunks.store.ts
================
interface BaseNotification {
  summary: string
  message: string
}

export const useChunksStore = defineStore('chunksStore', () => {
  const log = useLogger('chunksStore')
  const toast = useNotification()
  const client = useSupabaseClient()

  const chunks = ref<any[]>([])

  async function flagChunk(chunkId: number, is_flagged: boolean) {
    console.log('flagChunk:', chunkId, is_flagged)
    try {
      const { data, error } = await client
        .from('research_embeddings')
        .update({ is_flagged: !is_flagged })
        .eq('id', chunkId)
        .select()

      console.log('flagChunk: res', data, error)
      if (error) {
        throw new Error(error.message)
      }

      if (!data || data.length === 0) {
        return
      }

      const updatedChunk = data[0]

      if (updatedChunk.is_flagged) {
        flaggedChunks.value.push(updatedChunk)
        chunks.value = chunks.value.filter((chunk: any) => chunk.id !== updatedChunk.id)
      } else {
        flaggedChunks.value = flaggedChunks.value.filter(
          (chunk: any) => chunk.id !== updatedChunk.id,
        )
        chunks.value.push(updatedChunk)
      }
    } catch (error: any) {
      throw new Error(error.message)
    }
  }

  const flaggedChunks = ref<any[]>([])
  async function fetchChunks(isFlagged: boolean = false, maxChunks: number = 100) {
    try {
      let query = client
        .from('research_embeddings')
        .select('id, research_id, chunk, url, is_flagged')
        .eq('is_flagged', isFlagged)
        .range(0, maxChunks)
      console.log('working 1')

      if (isFlagged) {
        query = query.order('updated_at', { ascending: false })
      } else {
        console.log('working 2')
        query = query.order('created_at', { ascending: false })
      }

      const { data, error } = await query
      console.log('working 3', data, error)

      if (error) {
        throw new Error(error.message)
      }

      if (isFlagged) {
        flaggedChunks.value.push(...data)
      } else {
        chunks.value.push(...data)
      }
    } catch (error: any) {
      log.error('fetchChunks:', error)
      throw new Error(error.message)
    }
  }

  const similarChunks = ref<any[]>([])
  interface SimilarDocs {
    search: string
    searchType: 'fts' | 'vector'
    matchThreshold?: number
    matchCount?: number
  }

  async function fetchSimilarDocuments({
    search,
    searchType,
    matchThreshold = 0.41,
    matchCount = 25,
  }: SimilarDocs) {
    try {
      const userId = useCookie('userId').value!
      let response

      if (searchType === 'vector') {
        response = await client.functions.invoke('openai', {
          method: 'POST',
          body: {
            query: search,
            match_threshold: matchThreshold,
            match_count: matchCount,
            user_id: userId,
          },
        })

        if (!response.data) {
          return
        }
      } else {
        const formattedSearch = search.replaceAll(' ', ' & ')
        response = await client.from('research').select().textSearch('fts', formattedSearch)
      }

      similarChunks.value.push(...response.data)
    } catch (error: any) {
      throw new Error(error.message)
    }
  }

  async function deleteChunk(chunkId: number) {
    log.info('deleteChunk:', chunkId)
    try {
      const { error } = await client.from('research_embeddings').delete().eq('id', chunkId)

      console.log('deleteChunk: res', error)
      if (error) {
        throw new Error(error.message)
      }

      flaggedChunks.value = flaggedChunks.value.filter((chunk: any) => chunk.id !== chunkId)
      toast.info({ summary: 'Chunk Deleted', message: 'The chunk has been deleted' })
    } catch (error: any) {
      toast.error({ summary: 'Error Deleting Chunk', message: error.message })
      throw new Error(error.message)
    }
  }

  function cleanText(text: string) {
    // Regular expression to match the pattern [chars(num/char/|)]
    const withoutPlaceholders = text.replace(/\[research_.*?\([^\)]+\)\]/g, '')

    return withoutPlaceholders
      .replace(/undefined/g, '')
      .replace(/ ,/g, ',')
      .replace(/ ,/g, '')
      .replace(/ :/g, ':')
      .replace(/ \./g, '.')
      .replace(/ ;/g, ';')
      .replace(/ \(/g, '(')
      .replace(/ \)/g, ')')
      .replace(/\s+/g, ' ')
      .trim()
  }

  return {
    flagChunk,
    fetchChunks,
    fetchSimilarDocuments,
    deleteChunk,
    cleanText,
    chunks,
    similarChunks,
    flaggedChunks,
  }
})

if (import.meta.hot) {
  import.meta.hot.accept(acceptHMRUpdate(useChunksStore, import.meta.hot))
}

================
File: composables/feedback.store.ts
================
export const useFeedbackStore = defineStore('feedbackStore', () => {
  const { fetch } = useBaseFetch()
  const storeKey = 'feedbacks'
  const logger = useLogger(storeKey)
  const loading = useLoadingStore()
  const toast = useNotification()

  async function submitFeedback(newFeedback: any) {
    console.log('newFeedback', newFeedback)

    if (loading.isLoading(storeKey)) {
      return null
    }

    loading.setLoading(storeKey, true)

    try {
      const response = await fetch('/api/feedback', {
        method: 'POST',
        body: newFeedback,
      })

      toast.info({ summary: 'Feedback Sent', message: response.message })
    } catch (error: any) {
      toast.error({ summary: 'Feedback Not Sent', message: error.message })
      logger.error('Error submitting question and handling response:', error)
    } finally {
      await loading.setLoadingInterval(storeKey, false, 1000)
    }
  }

  return {
    submitFeedback,
  }
})

if (import.meta.hot) {
  import.meta.hot.accept(acceptHMRUpdate(useFeedbackStore, import.meta.hot))
}

================
File: composables/onboarding.composable.ts
================
import { ref, reactive } from 'vue'
import { type ZodSchema, z } from 'zod'

const accountDetailsSchema = z.object({
  dateOfBirth: z.date().max(new Date(), 'Date of birth cannot be in the future'),
})

const professionalInfoSchema = z.object({
  occupation: z.string().min(1, 'Please select an occupation'),
  organization: z.string().min(2, 'Organization name must be at least 2 characters'),
  experience: z
    .number()
    .min(0, 'Experience cannot be negative')
    .max(100, 'Experience cannot exceed 100 years'),
})

export interface SignupForm {
  dateOfBirth: Date | null
  occupation: string
  organization: string
  experience: number | null
  interests: string[]
}

export function useOnboarding() {
  const form = reactive<SignupForm>({
    dateOfBirth: null,
    occupation: '',
    organization: '',
    experience: null,
    interests: [],
  })

  const errors = reactive<Partial<Record<keyof SignupForm, string>>>({})

  const validateAndUpdate = (schema: ZodSchema) => {
    const result = schema.safeParse(form)
    if (result.success) {
      Object.keys(errors).forEach((key) => delete errors[key as keyof SignupForm])
      return true
    } else {
      result.error.issues.forEach((issue) => {
        errors[issue.path[0] as keyof SignupForm] = issue.message
      })
      return false
    }
  }

  return {
    form,
    errors,
    validateAndUpdate,
    professionalInfoSchema,
    accountDetailsSchema,
  }
}

================
File: composables/useBookmarkManager.ts
================
export const useBookmarkManager = () => {
  const selectedIds = ref<string[]>([])
  const targetFolderId = ref<string | null>(null)
  const { moveBookmarks, fetchBookmarks, fetchBookmarkCounts } = useBookmarkStore()
  const confirm = useConfirm()

  const hasSelection = computed(() => selectedIds.value.length > 0)
  const selectionCount = computed(() => selectedIds.value.length)
  const isSelected = (bookmarkId: string) => selectedIds.value.includes(bookmarkId)

  const toggleSelection = (bookmarkId: string) => {
    const index = selectedIds.value.indexOf(bookmarkId)
    if (index === -1) {
      selectedIds.value.push(bookmarkId)
    } else {
      selectedIds.value.splice(index, 1)
    }
  }

  const clearSelection = () => {
    selectedIds.value = []
  }

  const handleMove = async (targetFolder: string) => {
    if (!selectedIds.value.length) return

    try {
      await moveBookmarks(selectedIds.value, targetFolder)
      // Refresh bookmarks
      await fetchBookmarks({})
      await fetchBookmarkCounts()
      // Clear selection
      clearSelection()
    } catch (error: any) {
      console.error('Failed to move bookmarks:', error)
    }
  }

  const handleDelete = async (bookmarkId: string | string[]) => {
    const ids = Array.isArray(bookmarkId) ? bookmarkId : [bookmarkId]
    const bookmarkStore = useBookmarkStore()
    const { bookmarks } = storeToRefs(bookmarkStore)
    const optimisticUpdate = useOptimisticUpdate()

    try {
      await optimisticUpdate.execute({
        key: 'delete-bookmarks',
        apiCall: async () => {
          return Promise.all(ids.map((id) => $fetch(`/api/bookmarks/${id}`, { method: 'DELETE' })))
        },
        optimisticUpdate: () => {
          // Update local state
          bookmarks.value = bookmarks.value.filter((b) => !ids.includes(b.id))
          // Update selection state
          selectedIds.value = selectedIds.value.filter((id) => !ids.includes(id))
        },
        rollback: async () => {
          // Revert by refetching
          await bookmarkStore.fetchBookmarks({})
        },
      })
      await fetchBookmarkCounts()
    } catch (error: any) {
      console.error('Failed to delete bookmarks:', error)
    }
  }

  return {
    selectedIds,
    targetFolderId,
    hasSelection,
    selectionCount,
    isSelected,
    toggleSelection,
    clearSelection,
    handleMove,
    handleDelete,
  }
}

================
File: composables/useBookmarkStore.ts
================
// useBookmarkStore.ts
import { defineStore } from 'pinia'
import Fuse from 'fuse.js'

interface BookmarkContent {
  id: string
  type: string
  title: string
  description?: string
  thumbnail?: string
  url?: string
  author?: string
  folder_id?: string
}

interface BookmarkParams {
  content_type?: string
  folder_id?: string
  include_subfolders?: boolean
}

interface Bookmark {
  id: string
  user_id: string
  folder_id: string | null
  content_type: string
  content_id: string
  metadata: {
    title: string
    author?: string
    description?: string
    thumbnail?: string
    url?: string
  }
  created_at: string
  folder?: { id: string; name: string; color: string; is_favorite: boolean }
}

// stores/useBookmarkStore.ts
export const useBookmarkStore = defineStore('bookmarks', () => {
  const bookmarks = ref<Bookmark[]>([])
  const bookmarksByFolder = ref<Map<string, Bookmark[]>>(new Map())
  const showBookmarkFeedback = ref(false)

  const folderBookmarkCounts = ref<Record<string, number>>({})

  const loading = ref(false)
  const error = ref<string | null>(null)
  const currentFolderId = ref<string | null>(null)
  const includeSubfolders = ref(true)
  const searchQuery = ref('')

  const { execute: executeOptimistic } = useOptimisticUpdate()

  const organizeBookmarksByFolder = (bookmarksList: Bookmark[]) => {
    const folderMap = new Map<string, Bookmark[]>()

    bookmarksList.forEach((bookmark) => {
      const folderId = bookmark.folder_id || 'uncategorized'
      if (!folderMap.has(folderId)) {
        folderMap.set(folderId, [])
      }
      folderMap.get(folderId)?.push(bookmark)
    })

    bookmarksByFolder.value = folderMap
  }

  // Get bookmark count for a folder
  const fetchBookmarkCounts = async () => {
    try {
      console.log('Fetching bookmark counts...')
      const response = await $fetch('/api/bookmarks/counts')
      console.log('Bookmark counts response:', response)

      if (!response?.data) {
        console.error('No data received from bookmark counts endpoint')
        return
      }

      const oldCounts = { ...folderBookmarkCounts.value }
      folderBookmarkCounts.value = response.data.reduce(
        (acc: Record<string, number>, item: any) => {
          acc[item.folder_id || 'uncategorized'] = item.count
          return acc
        },
        {},
      )

      console.log('Old counts:', oldCounts)
      console.log('New counts:', folderBookmarkCounts.value)
    } catch (error: any) {
      console.error('Failed to fetch bookmark counts:', error)
    }
  }

  // Fetch bookmarks with optional folder filter
  const fetchBookmarks = async (params: BookmarkParams = {}) => {
    loading.value = true
    error.value = null
    try {
      // Add error handling and diagnostics
      const response = await $fetch('/api/bookmarks', {
        params: {
          folder_id: params.folder_id || null,
          include_subfolders: params.include_subfolders ?? includeSubfolders.value,
        },
        // Add error handling
        onResponseError(error) {
          console.error('Bookmark API response error:', error.response?._data || error)
        },
      })

      bookmarks.value = response.data || []
      organizeBookmarksByFolder(bookmarks.value)
    } catch (e) {
      // Improved error logging
      console.error('Failed to fetch bookmarks:', e)
      error.value = e.message || 'Failed to fetch bookmarks'
      bookmarks.value = []
      bookmarksByFolder.value = new Map()
    } finally {
      loading.value = false
    }
  }

  // Get bookmarks for a specific folder
  const getBookmarkCount = (folderId: string) => {
    return folderBookmarkCounts.value[folderId] || 0
  }

  const toggleBookmark = async (content: BookmarkContent) => {
    // For this function, we need to adapt to the new schema
    // content.type is used in the original function, but the API endpoint
    // now expects content_type based on the content_types table

    const existingBookmark = bookmarks.value.find(
      (b) => b.content_id === content.id && b.content_type === content.type,
    )

    return executeOptimistic({
      key: `bookmark-${content.id}`,
      apiCall: () =>
        $fetch('/api/bookmarks/toggle', {
          method: 'POST',
          body: {
            content_id: content.id,
            content_type: content.type, // Matches the content_type in content_types table
            folder_id: content.folder_id,
            metadata: {
              title: content.title,
              description: content.description,
              thumbnail: content.thumbnail,
              url: content.url,
              author: content.author,
            },
          },
        }),
      optimisticUpdate: () => {
        if (existingBookmark) {
          bookmarks.value = bookmarks.value.filter((b) => b.id !== existingBookmark.id)
        } else {
          // Add optimistic bookmark with temporary id
          const optimisticBookmark = {
            id: `temp-${content.id}`,
            content_id: content.id,
            content_type: content.type,
            folder_id: content.folder_id,
            metadata: {
              title: content.title,
              description: content.description,
              thumbnail: content.thumbnail,
              url: content.url,
              author: content.author,
            },
            created_at: new Date().toISOString(),
          }
          bookmarks.value = [...bookmarks.value, optimisticBookmark]
        }
        organizeBookmarksByFolder(bookmarks.value)
      },
      rollback: () => {
        // Revert to previous state
        if (existingBookmark) {
          bookmarks.value = [...bookmarks.value, existingBookmark]
        } else {
          bookmarks.value = bookmarks.value.filter((b) => b.id !== `temp-${content.id}`)
        }
        organizeBookmarksByFolder(bookmarks.value)
      },
    })
  }

  const moveBookmarks = async (bookmarkIds: string[], targetFolderId: string) => {
    return executeOptimistic({
      key: `move-${bookmarkIds.join('-')}`,
      apiCall: () =>
        $fetch('/api/bookmarks/move', { method: 'PATCH', body: { bookmarkIds, targetFolderId } }),
      optimisticUpdate: () => {
        const previousState = [...bookmarks.value]
        bookmarks.value = bookmarks.value.map((bookmark) =>
          bookmarkIds.includes(bookmark.id) ? { ...bookmark, folder_id: targetFolderId } : bookmark,
        )
        organizeBookmarksByFolder(bookmarks.value)
        return { previousState }
      },
      rollback: (context) => {
        if (context?.previousState) {
          bookmarks.value = context.previousState
          organizeBookmarksByFolder(bookmarks.value)
        }
      },
    })
  }

  const removeBookmarks = async (bookmarkIds: string[]) => {
    return executeOptimistic({
      key: `remove-${bookmarkIds.join('-')}`,
      apiCall: () => $fetch('/api/bookmarks/batch', { method: 'DELETE', body: { bookmarkIds } }),
      optimisticUpdate: () => {
        const previousState = [...bookmarks.value]
        bookmarks.value = bookmarks.value.filter((b) => !bookmarkIds.includes(b.id))
        organizeBookmarksByFolder(bookmarks.value)
        return { previousState }
      },
      rollback: (context) => {
        if (context?.previousState) {
          bookmarks.value = context.previousState
          organizeBookmarksByFolder(bookmarks.value)
        }
      },
    })
  }

  const isBookmarked = computed(() => (contentId: string, contentType: string = 'news') => {
    return bookmarks.value.some(
      (bookmark) => bookmark.content_id === contentId && bookmark.content_type === contentType,
    )
  })

  const filteredBookmarks = computed(() => {
    let filtered = bookmarks.value

    // Filter by folder
    if (currentFolderId.value) {
      filtered = filtered.filter((bookmark) => {
        if (includeSubfolders.value) {
          // TODO: Add logic for subfolder inclusion when implemented
          return bookmark.folder_id === currentFolderId.value
        }
        return bookmark.folder_id === currentFolderId.value
      })
    }

    // Filter by search
    if (searchQuery.value) {
      const fuse = new Fuse(filtered, {
        keys: [
          'metadata.title',
          'metadata.description',
          'metadata.author',
          'metadata.abstract',
          'metadata.name',
        ],
        threshold: 0.3,
        shouldSort: true,
      })
      return fuse.search(searchQuery.value).map((result) => result.item)
    }

    return filtered
  })

  const setCurrentFolder = async (folderId: string | null) => {
    currentFolderId.value = folderId
    await fetchBookmarks({ folder_id: folderId, include_subfolders: includeSubfolders.value })
  }

  const setIncludeSubfolders = async (include: boolean) => {
    includeSubfolders.value = include
    if (currentFolderId.value) {
      await fetchBookmarks({ folder_id: currentFolderId.value, include_subfolders: include })
    }
  }

  const setSearchQuery = (query: string) => {
    searchQuery.value = query
  }

  // Reset state
  const resetFilters = async () => {
    currentFolderId.value = null
    includeSubfolders.value = true
    searchQuery.value = ''
    await fetchBookmarks()
  }

  const handleToggleBookmark = async (content: any) => {
    const folderStore = useFolderStore()
    const defaultFolderId = folderStore.getDefaultFolder?.id
    try {
      // More robust error handling and content validation
      if (!content || !content.id) {
        console.error('Cannot bookmark: Invalid content object', content)
        return
      }

      // Need to handle the new content structure with safer property access
      const bookmarkData = {
        id: content.id,
        type: content.content_type || 'news',
        title: content.title || content.metadata?.title || 'Untitled',
        thumbnail: content.featured_image || content.metadata?.featured_image || null,
        url: content.url || content.metadata?.url || null,
        author: content.author || content.metadata?.author || null,
        description: content.description || content.metadata?.description || null,
        folder_id: defaultFolderId,
      }

      console.log('Bookmarking content:', bookmarkData)
      await toggleBookmark(bookmarkData)
      showBookmarkFeedback.value = true
      setTimeout(() => {
        showBookmarkFeedback.value = false
      }, 1000)
    } catch (error: any) {
      console.error('Error handling bookmark:', error)
    }
  }

  return {
    bookmarks,
    loading,
    error,
    bookmarksByFolder,
    currentFolderId,
    includeSubfolders,
    searchQuery,

    // Computed
    filteredBookmarks,
    showBookmarkFeedback,

    // Actions
    handleToggleBookmark,
    removeBookmarks,
    fetchBookmarks,
    setCurrentFolder,
    setIncludeSubfolders,
    setSearchQuery,
    resetFilters,
    getBookmarkCount,
    fetchBookmarkCounts,

    moveBookmarks,
    toggleBookmark,
    isBookmarked,
  }
})

================
File: composables/useBookmarkView.ts
================
// useBookmarkView.ts
import { set } from 'zod'
import type { Folder } from '../types/bookmarks'

export const useBookmarkView = () => {
  const viewMode = ref<'grid' | 'list'>('grid')
  const searchQuery = ref('')
  const includeSubfolders = ref(true)
  const showNewFolderModal = ref(false)

  const handleFolderSelect = async (folder: Folder) => {
    const { fetchBookmarks } = useBookmarkStore()
    const { setSelectedFolder } = useFolderStore()
    setSelectedFolder(folder.id)
    await fetchBookmarks({
      folder_id: folder.id,
      include_subfolders: includeSubfolders.value,
    })
  }

  const debouncedSearch = useDebounceFn((query: string) => {
    // Implement search logic here
    console.log('Searching:', query)
  }, 300)

  watch(searchQuery, (newQuery) => {
    debouncedSearch(newQuery)
  })

  return {
    viewMode,
    searchQuery,
    includeSubfolders,
    showNewFolderModal,
    handleFolderSelect,
  }
}

================
File: composables/useEvents.ts
================
import { ref } from 'vue'
import { io, Socket } from 'socket.io-client'

export interface Event {
  module: 'payment' | 'subscription'
  type: 'created' | 'updated' | 'deleted'
  data: {
    subscription: any
    changes?: any
    timestamp: string
  }
}

// Singleton instance
let socketInstance: Socket | null = null

export const useEvents = () => {
  const currentUser = useCurrentUser()
  const lastEvent = ref<Event | null>(null)
  const isConnected = ref(false)

  // Only create a new socket if one doesn't exist
  if (!socketInstance) {
    socketInstance = io(`${useRuntimeConfig().public.apiURL}/event`, {
      transports: ['websocket'],
      reconnection: true,
      reconnectionDelay: 1000,
      reconnectionDelayMax: 5000,
      reconnectionAttempts: 5,
    })
  }

  // Set up event listeners
  socketInstance.on('connect', () => {
    console.log('Socket connected')
    isConnected.value = true
  })

  socketInstance.on('disconnect', () => {
    console.log('Socket disconnected')
    isConnected.value = false
  })

  socketInstance.on('paymentEvent', async (event: Event) => {
    if (event.module == 'subscription') await currentUser.refreshUserStore()
    lastEvent.value = event
  })

  // Clean up listeners on component unmount
  onUnmounted(() => {
    socketInstance?.off('connect')
    socketInstance?.off('disconnect')
    socketInstance?.off('paymentEvent')
  })

  return {
    lastEvent,
    isConnected,
  }
}

================
File: composables/useFeatureRequestStore.ts
================
// stores/useFeatureRequestStore.ts
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'

interface FeatureRequest {
  id: string
  title: string
  description: string
  status: 'planned' | 'in_progress' | 'completed'
  upvotes: number
  downvotes: number
  priority_score: number
  engagement_score: number
}

export const useFeatureRequestStore = defineStore('features', () => {
  // State
  const features = ref<FeatureRequest[]>([])
  const hiddenFeatureIds = ref(new Set<string>())
  const userVotes = ref(new Map<string, 1 | -1>())
  const isLoading = ref(false)
  const error = ref<Error | null>(null)

  // Getters
  const visibleFeatures = computed(() => {
    return features.value.filter((feature) => !hiddenFeatureIds.value.has(feature.id)).slice(0, 3)
  })

  const hasMoreFeatures = computed(() => {
    return features.value.filter((f) => !hiddenFeatureIds.value.has(f.id)).length > 3
  })

  const getFeatureVote = (featureId: string) => {
    return userVotes.value.get(featureId) || 0
  }

  // Actions
  async function fetchFeatures() {
    isLoading.value = true
    try {
      const { data } = await useSupabaseClient()
        .from('feature_requests')
        .select('*')
        .order('priority_score', { ascending: true })
        .limit(10)

      features.value = data || []

      // Also fetch user's votes
      await fetchUserVotes()
    } catch (error: any) {
      console.error('Error fetching features:', error)
      error.value = error as Error
    } finally {
      isLoading.value = false
    }
  }

  async function fetchUserVotes() {
    const {
      data: { user },
    } = await useSupabaseClient().auth.getUser()
    if (!user) return

    const { data } = await useSupabaseClient()
      .from('feature_votes')
      .select('feature_id, vote_type')
      .eq('user_id', user.id)

    if (data) {
      userVotes.value = new Map(data.map((vote) => [vote.feature_id, vote.vote_type]))
    }
  }

  async function voteOnFeature(featureId: string, voteType: 1 | -1, feedback?: string) {
    const {
      data: { user },
    } = await useSupabaseClient().auth.getUser()
    if (!user) return

    const { error } = await useSupabaseClient().from('feature_votes').upsert({
      feature_id: featureId,
      user_id: user.id,
      vote_type: voteType,
      feedback,
    })

    if (!error) {
      userVotes.value.set(featureId, voteType)
      hideFeature(featureId)
      await fetchFeatures() // Refresh features to get updated scores
    }
  }

  function hideFeature(featureId: string) {
    hiddenFeatureIds.value.add(featureId)
  }

  return {
    // State
    features,
    isLoading,
    error,

    // Getters
    visibleFeatures,
    hasMoreFeatures,
    getFeatureVote,

    // Actions
    fetchFeatures,
    voteOnFeature,
    hideFeature,
  }
})

================
File: composables/useFeatureSurvey.ts
================
// composables/useFeatureSurvey.ts
export function useFeatureSurvey() {
  const { $posthog } = useNuxtApp()
  const survey = ref(null)
  const response = ref('')
  const isLoading = ref(true)
  const isSubmitted = ref(false)

  // Track feature request interactions
  const trackSurveyInteraction = (action: 'shown' | 'submitted' | 'dismissed', properties = {}) => {
    $posthog.capture(`feature_survey_${action}`, {
      location: 'homepage',
      ...properties,
    })
  }

  const closeSurvey = () => {
    if (survey.value) {
      localStorage.setItem(`featureSurvey_${survey.value.id}`, 'true')
      survey.value = null
    }
  }

  const submitSurvey = async () => {
    if (!survey.value || !response.value.trim()) return

    trackSurveyInteraction('submitted', {
      response: response.value,
    })

    // You might want to also store this in your database
    await $posthog.capture('feature_request', {
      request: response.value,
      priority: 'user_submitted',
    })

    isSubmitted.value = true
    response.value = ''
    setTimeout(() => {
      closeSurvey()
      isSubmitted.value = false
    }, 3000)
  }

  const dismissSurvey = () => {
    trackSurveyInteraction('dismissed')
    closeSurvey()
  }

  onMounted(() => {
    // Check if user has already submitted a feature request recently
    const lastSubmission = localStorage.getItem('lastFeatureRequest')
    const cooldownPeriod = 7 * 24 * 60 * 60 * 1000 // 7 days

    if (lastSubmission && Date.now() - parseInt(lastSubmission) < cooldownPeriod) {
      isLoading.value = false
      return
    }

    // Create our own survey object instead of fetching from PostHog
    survey.value = {
      id: 'feature-request-' + Date.now(),
      name: 'Feature Request',
      questions: [
        {
          question: 'What features would you like to see in AstroTribe?',
        },
      ],
    }

    trackSurveyInteraction('shown')
    isLoading.value = false
  })

  return {
    survey,
    response,
    isLoading,
    isSubmitted,
    submitSurvey,
    dismissSurvey,
  }
}

================
File: composables/useFeedNavigation.ts
================
// composables/useFeedNavigation.ts
export const useFeedNavigation = () => {
  const feedName = useState<string>('currentFeedName', () => '')
  const { appLinks } = usePages()

  const getFeedName = (feedId: string): string => {
    const newsCategory = appLinks.value.find((cat) => cat.id === 'news')
    const myFeeds = newsCategory?.items.find((item) => item.id === 'my-feeds')
    const feed = myFeeds?.children?.find((feed) => feed.id === feedId)
    return feed?.label || feedId
  }

  const setCurrentFeedName = (feedId: string) => {
    feedName.value = getFeedName(feedId)
  }

  return {
    feedName: readonly(feedName),
    setCurrentFeedName,
  }
}

================
File: composables/useFolderStore.ts
================
import { useConfirm } from 'primevue/useconfirm'
import consola from 'consola'
import type { Folder } from '~/types/folder'

export const useFolderStore = defineStore('folders', () => {
  const error = ref<string | null>(null)
  const confirm = useConfirm()
  const logger = consola
  const loading = ref(false)

  const folders = ref<Folder[]>([])
  const selectedFolderId = ref<string | null>(null)
  const includeSubfolders = ref(true)

  // Computed properties for convenience
  const getDefaultFolder = computed(() => folders.value.find((f) => f.is_default) || null)
  const getFavorites = computed(() => folders.value.filter((f) => f.is_favorite) || [])

  const setSelectedFolder = (folderId: string | null) => {
    selectedFolderId.value = folderId
  }

  const setIncludeSubfolders = (value: boolean) => {
    includeSubfolders.value = value
  }

  const fetchFolders = async () => {
    console.log('Fetching folders...')
    loading.value = true
    error.value = null

    try {
      const response = await $fetch('/api/folders')
      console.log('Folders response:', response)

      if (!response.data) {
        console.warn('No data in response')
      }

      folders.value = response.data || []
      console.log('Folders updated:', folders.value)
    } catch (e) {
      console.error('Error fetching folders:', e)
      error.value = 'Failed to fetch folders'
      folders.value = []
    } finally {
      loading.value = false
    }
  }

  const flatFolders = computed(() => {
    const flattened: Folder[] = []

    const flatten = (items: Folder[], depth = 0) => {
      items.forEach((item) => {
        flattened.push({ ...item, depth })
        if (item.children?.length) {
          flatten(item.children, depth + 1)
        }
      })
    }

    flatten(folders.value)
    return flattened
  })

  const createFolder = async (folder: Partial<Folder>) => {
    loading.value = true
    try {
      const data = await $fetch('/api/folders', {
        method: 'POST',
        body: folder,
      })

      if (data) {
        await fetchFolders()
      }
      return data
    } catch (error: any) {
      logger.error(error, {
        context: 'createFolder',
        userMessage: 'Failed to create folder',
      })
      throw error
    } finally {
      loading.value = false
    }
  }

  const updateFolder = async (folderId: string, updates: Partial<Folder>) => {
    loading.value = true
    try {
      const data = await $fetch(`/api/folders/${folderId}`, {
        method: 'PATCH',
        body: updates,
      })

      if (data) {
        await fetchFolders()
      }
      return data
    } catch (error: any) {
      logger.error(error, {
        context: 'updateFolder',
        userMessage: 'Failed to update folder',
      })
      throw error
    } finally {
      loading.value = false
    }
  }

  const deleteFolder = async (folderId: string) => {
    loading.value = true

    try {
      // First get the default folder
      const defaultFolder = getDefaultFolder.value
      if (!defaultFolder) {
        throw new Error('Default folder not found')
      }

      // Show confirmation dialog
      return new Promise((resolve) => {
        confirm.require({
          message: 'What would you like to do with the bookmarks in this folder?',
          header: 'Delete Folder',
          icon: 'pi pi-exclamation-triangle',
          acceptLabel: 'Delete all bookmarks',
          rejectLabel: 'Move to default folder',
          accept: async () => {
            try {
              const data = await $fetch(`/api/folders/${folderId}`, {
                method: 'DELETE',
                body: {
                  strategy: 'delete_all',
                },
              })

              if (data !== null) {
                await fetchFolders()
              }
              resolve(true)
            } catch (error: any) {
              logger.error(error, {
                context: 'deleteFolder',
                userMessage: 'Failed to delete folder',
              })
              resolve(false)
            } finally {
              loading.value = false
            }
          },
          reject: async () => {
            // Move to default folder
            const result = await handleMoveAndDelete(folderId, defaultFolder.id)
            resolve(result)
          },
        })
      })
    } catch (error: any) {
      logger.error(error, {
        context: 'deleteFolder',
        userMessage: 'Failed to delete folder',
      })
      loading.value = false
      return false
    }
  }

  const handleMoveAndDelete = async (folderId: string, defaultFolderId: string) => {
    try {
      const data = await $fetch(`/api/folders/${folderId}`, {
        method: 'DELETE',
        body: {
          strategy: 'move_to_default',
          defaultFolderId,
        },
      })

      if (data !== null) {
        await fetchFolders()
      }
      return true
    } catch (error: any) {
      logger.error(error, {
        context: 'handleMoveAndDelete',
        userMessage: 'Failed to move bookmarks and delete folder',
      })
      return false
    } finally {
      loading.value = false
    }
  }

  return {
    folders,
    loading,
    error,
    selectedFolderId,
    includeSubfolders,
    setSelectedFolder,
    setIncludeSubfolders,
    fetchFolders,
    createFolder,
    updateFolder,
    deleteFolder,
    flatFolders,
    getDefaultFolder,
    getFavorites,
  }
})

================
File: composables/usePages.ts
================
import { storeToRefs } from 'pinia'
import { ref } from 'vue'

export interface PageType {
  id: string
  label: string
  slug: string
  icon: string
  children?: PageType[]
  isExpanded?: boolean
}

export interface NavigationCategory {
  id: string
  label: string
  items: PageType[]
}

export interface BreadcrumbLink {
  to: string
  label: string
  ariaLabel: string
}

const UUID_REGEX = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i

const createFeedItem = {
  id: 'create_feed',
  label: '+ Create Feed',
  slug: '/feed/add',
  icon: 'mdi:plus',
}

const upgradePlan = {
  id: 'upgrade_plan',
  label: 'Upgrade to create custom feeds',
  slug: '/settings/payments',
  icon: 'mdi:star',
}

const navigationCategories = ref([
  {
    id: 'main',
    label: 'Main',
    items: [
      {
        id: '1',
        label: 'Home',
        slug: '/',
        icon: 'material-symbols:home-rounded',
      },
      {
        id: '2',
        label: 'Companies',
        slug: '/companies',
        icon: 'material-symbols:domain',
      },
      {
        id: '3',
        label: 'Opportunities',
        slug: '/opportunities',
        icon: 'material-symbols:work',
      },
    ],
  },
  {
    id: 'news',
    label: 'News',
    items: [
      {
        id: '2',
        label: 'Feed',
        slug: '/news',
        icon: 'mdi:newspaper-variant-outline',
      },
      {
        id: 'my-feeds',
        label: 'My Feeds',
        slug: '#',
        icon: 'mdi:rss',
        isExpanded: false,
        children: [],
      },
    ],
  },
  {
    id: 'profile',
    label: 'Profile',
    items: [
      {
        id: '4',
        label: 'Bookmarks',
        slug: '/profile/bookmarks',
        icon: 'mdi:bookmark-outline',
      },
    ],
  },
] as NavigationCategory[])

export default function usePages() {
  const client = useSupabaseClient()
  const currentUser = useCurrentUser()
  const route = useRoute()
  const { getFeatureUsage } = usePlan()

  const { profile } = storeToRefs(currentUser)

  const getFeedName = (feedId: string): string => {
    // Return empty string if it's a UUID
    if (UUID_REGEX.test(feedId)) {
      const newsCategory = navigationCategories.value.find((cat) => cat.id === 'news')
      const myFeeds = newsCategory?.items.find((item) => item.id === 'my-feeds')
      const feed = myFeeds?.children?.find((feed) => feed.id === feedId)
      return feed?.label || ''
    }
    return feedId
  }

  const generateBreadcrumbs = (path: string): BreadcrumbLink[] => {
    const pathParts = path.split('/').filter(Boolean)
    let currentPath = ''

    return pathParts
      .map((part): BreadcrumbLink | null => {
        currentPath += `/${part}`

        // Skip home link
        if (currentPath === '/' || (UUID_REGEX.test(part) && !getFeedName(part))) {
          return null
        }

        // Handle feeds
        if (currentPath.startsWith('/feed/')) {
          if (part === 'feed') {
            return {
              to: currentPath,
              label: 'Feeds',
              ariaLabel: 'Feeds',
            }
          }
          return {
            to: currentPath,
            label: getFeedName(part),
            ariaLabel: getFeedName(part),
          }
        }

        // Default handling
        return {
          to: currentPath,
          label: part.charAt(0).toUpperCase() + part.slice(1),
          ariaLabel: part.charAt(0).toUpperCase() + part.slice(1),
        }
      })
      .filter(Boolean) as BreadcrumbLink[]
  }

  const breadcrumbs = computed(() => generateBreadcrumbs(route.path))

  const currentFeedName = computed(() => {
    if (route.path.startsWith('/feed/')) {
      const feedId = route.params.feed as string
      return getFeedName(feedId)
    }
    return ''
  })

  // Existing feed management functions
  const addFeed = (id: string, label: string) => {
    const newsCategory = navigationCategories.value.find((cat) => cat.id === 'news')
    const myFeeds = newsCategory?.items.find((item) => item.id === 'my-feeds')

    if (myFeeds && !myFeeds.children.some((feed) => feed.id === id)) {
      myFeeds.children.splice(1, 0, {
        id,
        label,
        slug: `/feed/${id}`,
        icon: 'mdi:newspaper-variant-multiple-outline',
      })
    }

    checkUsage(myFeeds)
  }

  const initializeFeeds = () => {
    if (profile.value.id) {
      const toast = useNotification()
      client
        .from('feeds')
        .select('id, name')
        .eq('user_id', profile.value.id)
        .then(({ data, error }) => {
          if (error) {
            toast.error({
              summary: 'Failed to get custom feeds',
              message: 'Could not get custom feeds',
            })
            return
          }

          const newsCategory = navigationCategories.value.find((cat) => cat.id === 'news')
          const myFeeds = newsCategory?.items.find((item) => item.id === 'my-feeds')

          if (myFeeds) {
            data.forEach((feed) => {
              if (!myFeeds.children.some((item) => item.id === feed.id)) {
                myFeeds.children.push({
                  id: feed.id,
                  label: feed.name,
                  slug: `/feed/${feed.id}`,
                  icon: 'mdi:newspaper-variant-multiple-outline',
                })
              }
            })
            checkUsage(myFeeds)
          }
        })
    }
  }

  const deleteFeed = (feedId: string) => {
    const newsCategory = navigationCategories.value.find((cat) => cat.id === 'news')
    const myFeeds = newsCategory?.items.find((item) => item.id === 'my-feeds')

    if (myFeeds) {
      const index = myFeeds.children.findIndex((item) => item.id === feedId)
      if (index > -1) {
        myFeeds.children.splice(index, 1)
      }
    }

    checkUsage(myFeeds)
  }

  const checkUsage = (myFeeds: Record<string, any>) => {
    const feeds = myFeeds.children.filter(
      (feed) => feed.id !== 'create_feed' && feed.id !== 'upgrade_plan',
    )

    const usage = getFeatureUsage('CUSTOM_FEEDS', feeds.length)
    const shouldShowUpgrade = !usage.isUnlimited && usage.used >= usage.limit

    myFeeds.children = shouldShowUpgrade ? [upgradePlan, ...feeds] : [createFeedItem, ...feeds]
  }

  onMounted(initializeFeeds)

  return {
    appLinks: navigationCategories,
    breadcrumbs,
    currentFeedName,
    addFeed,
    deleteFeed,
  }
}

================
File: composables/usePayments.ts
================
import { ref } from 'vue'
import { useRuntimeConfig } from '#app'

export const usePayments = (provider: 'razorpay' | 'stripe') => {
  const supabase = useSupabaseClient()
  const isLoading = ref(false)
  const error = ref(null)
  const currentUser = useCurrentUser()
  const { profile } = storeToRefs(currentUser)

  const initializePayment = async (options: any) => {
    isLoading.value = true
    error.value = null

    try {
      if (provider === 'razorpay') {
        const razorpay = new (window as any).Razorpay({
          key: 'rzp_test_lV0OE0NDIg6Hr6',
          ...options,
        })
        razorpay.open()
      } else if (provider === 'stripe') {
        // Placeholder for Stripe implementation
        console.log('Stripe payment initialization', options)
      }
    } catch (error: any) {
      console.error(`Error initializing payment with ${provider}:`, error)
    } finally {
      isLoading.value = false
    }
  }

  const createOrder = async (plan: Record<string, any>) => {
    isLoading.value = true
    error.value = null

    const { plan_id, external_plan_id, total_count } = plan

    const oldSubscription = await fetchSubscriptions({
      where: {
        plan_id: { not: plan_id },
        name: plan.name,
        status: { In: ['cancelled', 'completed', 'expired'] },
      },
    })

    const start_at = oldSubscription?.[0]?.current_end

    try {
      const response = await $fetch(`/api/payment/${provider}/subscriptions/create`, {
        method: 'POST',
        body: {
          plan_id,
          external_plan_id,
          start_at: start_at && new Date(start_at).getTime() / 1000,
          user_id: profile.value.id,
          total_count,
          provider,
        },
      })

      return response
    } catch (error: any) {
      console.error(`Error creating order with ${provider}:`, error)
    } finally {
      isLoading.value = false
    }
  }

  const verifyPayment = async (paymentData: any) => {
    isLoading.value = true
    error.value = null

    try {
      const response = await $fetch(`/api/payment/${provider}/verify-payment`, {
        method: 'POST',
        body: paymentData,
      })
      return response
    } catch (error: any) {
      console.error(`Error verifying payment with ${provider}:`, error)
    } finally {
      isLoading.value = false
    }
  }

  const fetchPlans = async () => {
    isLoading.value = true
    error.value = null

    try {
      const response = await $fetch(`/api/payment/${provider}/plans`)

      return response
    } catch (error: any) {
      console.error(`Error verifying payment with ${provider}:`, error)
    } finally {
      isLoading.value = false
    }
  }

  const fetchSubscriptions = async (query?: Record<string, any>) => {
    isLoading.value = true
    error.value = null

    try {
      const response = await $fetch(`/api/payment/${provider}/subscriptions`, {
        query: { ...(query ? query : {}), user_id: profile.value.id },
      })

      console.log('Subscriptions RESPONSE', response)

      return response
    } catch (error: any) {
      console.error(`Error verifying payment with ${provider}:`, error)
    } finally {
      isLoading.value = false
    }
  }

  return {
    isLoading,
    error,
    initializePayment,
    createOrder,
    verifyPayment,
    fetchPlans,
    fetchSubscriptions,
  }
}

================
File: composables/usePlan.ts
================
import { storeToRefs } from 'pinia'
import { FEATURES } from '#shared/constants'

// composables/usePlan.ts
export enum PlanType {
  FREE = 'free',
  PRO = 'pro',
}

export interface PlanFeature {
  name: string
  limit: { [PlanType.FREE]: number; [PlanType.PRO]: number }
  description: string
  comingSoon?: boolean
}

export const usePlan = () => {
  // For now, we'll assume everyone is on free plan
  // Later this can be updated based on your auth/subscription system
  const currentUser = useCurrentUser()
  const { profile } = storeToRefs(currentUser)

  const userPlan = ref<PlanType>(profile.value.user_plan == 'free' ? PlanType.FREE : PlanType.PRO)

  // Utility functions
  const getFeatureLimit = (featureKey: keyof typeof FEATURES) => {
    return FEATURES[featureKey].limit[userPlan.value]
  }

  const isFeatureAvailable = (featureKey: keyof typeof FEATURES) => {
    const feature = FEATURES[featureKey]
    return !feature.comingSoon && getFeatureLimit(featureKey) !== 0
  }

  const checkFeatureLimit = async (
    featureKey: keyof typeof FEATURES,
    currentCount: number,
  ): Promise<boolean> => {
    const limit = getFeatureLimit(featureKey)
    return limit === -1 || currentCount < limit
  }

  const getUpgradeMessage = (featureKey: keyof typeof FEATURES) => {
    const feature = FEATURES[featureKey]
    if (userPlan.value === PlanType.FREE) {
      return feature.limit.pro === -1
        ? `Upgrade to Pro for unlimited ${feature.name}`
        : `Upgrade to Pro for up to ${feature.limit.pro} ${feature.name}`
    }
    return ''
  }

  // This can be used to show remaining quota
  const getFeatureUsage = (featureKey: keyof typeof FEATURES, currentCount: number) => {
    const limit = getFeatureLimit(featureKey)

    return {
      used: currentCount,
      limit,
      remaining: limit === -1 ? -1 : limit - currentCount,
      isUnlimited: limit === -1,
    }
  }

  return {
    FEATURES,
    userPlan,
    getFeatureLimit,
    isFeatureAvailable,
    checkFeatureLimit,
    getUpgradeMessage,
    getFeatureUsage,
  }
}

================
File: composables/usePWA.ts
================
export const usePWA = () => {
  const nuxtApp = useNuxtApp()
  const { $pwaState, $pwaActions } = nuxtApp

  if (!$pwaState || !$pwaActions) {
    throw new Error('PWA plugin not installed')
  }

  return {
    // States
    isInstallable: $pwaState.isInstallable,
    isUpdateAvailable: $pwaState.isUpdateAvailable,
    isOfflineReady: $pwaState.isOfflineReady,
    isPWAInstalled: $pwaState.isPWAInstalled,
    hasError: $pwaState.hasError,
    isActivated: $pwaState.isActivated,

    // Actions
    install: $pwaActions.install,
    update: $pwaActions.update,
    cancelInstall: $pwaActions.cancelInstall,
    cancelUpdate: $pwaActions.cancelUpdate,
  }
}

================
File: composables/useRoleOverride.ts
================
import { ref, watch } from 'vue'
import { useSupabaseUser, useSupabaseClient } from '#imports'

export const useRoleOverride = () => {
  const roleOverride = ref<string | null>(null)
  const supabase = useSupabaseClient()
  const user = useSupabaseUser()
  const isUpdating = ref(false)

  const updateRole = async (newRole: string | null) => {
    try {
      isUpdating.value = true
      const response = await $fetch('/api/dev/update-role', {
        method: 'POST',
        body: { role: newRole },
      })

      if (response.error) {
        console.error('Failed to update role:', response.error)
        throw response.error
      }

      // Force refresh the session to get new metadata
      const { data: session, error: refreshError } = await supabase.auth.refreshSession()

      if (refreshError) {
        console.error('Failed to refresh session:', refreshError)
        throw refreshError
      }

      console.log('Session refreshed:', session?.user?.app_metadata)

      if (newRole) {
        const originalRole = user.value?.app_metadata?.role
        console.log('Storing original role:', originalRole)
        if (!sessionStorage.getItem('originalRole')) {
          sessionStorage.setItem('originalRole', originalRole)
        }
      } else {
        sessionStorage.removeItem('originalRole')
      }

      return session
    } catch (error: any) {
      console.error('Role update failed:', error)
      throw error
    } finally {
      isUpdating.value = false
    }
  }

  watch(
    roleOverride,
    async (newRole) => {
      if (!user.value || isUpdating.value) return
      await updateRole(newRole)
    },
    { immediate: false },
  )

  return {
    roleOverride,
    setRoleOverride: (role: string | null) => {
      if (!isUpdating.value) {
        roleOverride.value = role
      }
    },
    getCurrentRole: () => user.value?.app_metadata?.role,
  }
}

================
File: composables/useSettingsNavigation.ts
================
import { computed } from 'vue'

export interface SettingsRoute {
  key: string
  label: string
  url: string
  icon?: string
  visible: boolean
  disabled: boolean
  children?: SettingsRoute[]
}

export interface TitleType {
  main: string
  subtitle?: string
}

export interface SettingsItem {
  id: string
  label: string
  tip?: string
  placeholder?: string
  type: string
  disabled?: boolean
  value?: any
}

export function useSettingsNavigation() {
  const user = useCurrentUser()

  const settingsRoutes = computed<SettingsRoute[]>(() => [
    {
      key: 'settings-account',
      label: 'Account Profile',
      url: '/settings/account',
      icon: 'material-symbols:home',
      visible: true,
      disabled: false,
    },
    {
      key: 'settings-security',
      label: 'Security',
      url: '/settings/security',
      icon: 'material-symbols:key',
      visible: true,
      disabled: false,
      children: [
        {
          key: 'settings-password',
          label: 'Password',
          url: '/settings/security/password',
          visible: user.profile?.providers?.includes('email'),
          disabled: false,
        },
      ],
    },
    {
      key: 'settings-payments',
      label: 'Payments',
      url: '/settings/payments',
      icon: 'mdi:credit-card',
      visible: true,
      disabled: false,
    },
    {
      key: 'settings-contact',
      label: 'Contact Us',
      url: '/settings/contact',
      icon: 'mdi:phone-classic',
      visible: true,
      disabled: false,
    },
    // {
    //   key: 'settings-notifications',
    //   label: 'Notifications',
    //   url: '/settings/notifications',
    //   icon: 'material-symbols:notifications',
    //   visible: true,
    //   disabled: false,
    // },
  ])

  return {
    settingsRoutes,
  }
}

================
File: composables/useSettingsProfile.ts
================
import { z } from 'zod'

const ProfileValidation = z.object({
  given_name: z.string().min(1, 'Given Name is required'),
  surname: z.string().min(1, 'Surname is required'),
  username: z.string(),
  email: z.string().email(),
  avatar: z.string().optional(),
  introduction: z.string().min(240, 'At least 240 characters required').optional(),
  quote: z.string().min(10, 'At least 10 characters required').optional(),
})

type ProfileData = z.infer<typeof ProfileValidation>

export function useSettingsProfile() {
  const currentUser = useCurrentUser()
  const supabase = useSupabaseClient()
  const toast = useNotification()

  const profile = ref<ProfileData>({
    given_name: '',
    surname: '',
    username: '',
    email: '',
    avatar: '',
  })

  const isUpdating = ref(false)

  // Initialize profile data
  watch(
    () => currentUser.profile,
    (newProfile) => {
      if (newProfile) {
        profile.value = {
          given_name: newProfile.given_name || '',
          surname: newProfile.surname || '',
          username: newProfile.username || '',
          email: newProfile.email || '',
          avatar: newProfile.avatar || '',
          introduction: newProfile.introduction,
          quote: newProfile.quote,
        }
      }
    },
    { immediate: true },
  )

  // Update profile
  async function updateProfile(data: Partial<ProfileData>) {
    try {
      isUpdating.value = true

      // Validate data
      const validatedData = ProfileValidation.partial().parse(data)

      // Update profile in Supabase
      const { error } = await supabase
        .from('user_profiles')
        .update(validatedData)
        .eq('id', currentUser.profile?.id)

      if (error) throw error

      // Update local state
      Object.assign(profile.value, validatedData)

      // Update user store
      currentUser.updateProfile(validatedData)

      toast.success({
        summary: 'Profile Updated',
        message: 'Your profile has been successfully updated',
      })
    } catch (error: any) {
      console.error('Profile update failed:', error)
      toast.error({
        summary: 'Update Failed',
        message: error.message || 'Failed to update profile',
      })
    } finally {
      isUpdating.value = false
    }
  }

  // Update avatar specifically
  async function updateAvatar(avatarUrl: string) {
    return updateProfile({ avatar: avatarUrl })
  }

  return {
    profile,
    isUpdating,
    updateProfile,
    updateAvatar,
  }
}

================
File: composables/useSettingsSecurity.ts
================
// composables/useSettingsSecurity.ts
export function useSettingsSecurity() {
  const supabase = useSupabaseClient()
  const currentUser = useCurrentUser()
  const toast = useNotification()

  interface TurnstileOptions {
    token: string
    reset: () => void
  }

  // Linked Identities
  async function getLinkedIdentities() {
    const { data, error } = await supabase.auth.getUserIdentities()
    if (error) {
      toast.error({
        summary: 'Error',
        message: 'Could not fetch linked accounts',
      })
      return []
    }
    return data?.identities || []
  }

  async function linkIdentity(
    provider: 'email' | 'twitter' | 'google' | 'facebook' | 'linkedin_oidc',
  ) {
    const { data, error } = await supabase.auth.linkIdentity({ provider })
    if (error) {
      toast.error({
        summary: 'Error',
        message: 'Could not link account',
      })
    }
    return { data, error }
  }

  async function unlinkIdentity(identity: any) {
    const { data, error } = await supabase.auth.unlinkIdentity(identity)
    if (error) {
      toast.error({
        summary: 'Error',
        message: 'Could not unlink account',
      })
    }
    return { data, error }
  }

  // Password Management
  async function setPassword(password: string) {
    const { error } = await supabase.auth.updateUser({ password })

    await linkIdentity('email')
    if (error) {
      toast.error({
        summary: 'Error',
        message: 'Could not set password',
      })
      return false
    }
    return true
  }

  // 2FA Management
  async function setupTwoFactor() {
    const { data, error } = await supabase.auth.mfa.enroll({
      factorType: 'totp',
    })
    if (error) {
      toast.error({
        summary: 'Error',
        message: 'Could not setup 2FA',
      })
      return null
    }
    return data
  }

  async function verifyTwoFactor(code: string, factorId: string) {
    const { data, error } = await supabase.auth.mfa.challenge({
      factorId,
      code,
    })
    if (error) {
      toast.error({
        summary: 'Error',
        message: 'Invalid verification code',
      })
      return false
    }
    return true
  }

  async function verifyLogin(options: TurnstileOptions, password?: string) {
    if (!password) {
      const { error } = await supabase.auth.signInWithOAuth({
        provider: currentUser.profile.providers[0],
        options: { skipBrowserRedirect: true, catpchaToken: options.token },
      })

      return error
    } else {
      const { error } = await supabase.auth.signInWithPassword({
        email: currentUser.profile.email,
        password,
        options: { captchaToken: options.token },
      })

      return error
    }
  }

  async function deleteAccount(options: TurnstileOptions, password?: string) {
    const error = await verifyLogin(options, password)
    const { authURL } = useRuntimeConfig().public

    if (error) {
      toast.error({ summary: 'Deletion Failed', message: error.message })
      options.reset()
      return
    }

    const { error: deleteError } = await supabase.rpc('delete_user', {
      user_id: currentUser.profile.id,
    })

    if (deleteError) {
      toast.error({ summary: 'Deletion Failed', message: deleteError.message })
      options.reset()
      return
    }

    toast.success({ summary: 'Account Deleted', message: 'Redirecting...' })
    await supabase.auth.signOut()

    setTimeout(() => navigateTo(authURL, { external: true }), 1000)
  }

  return {
    getLinkedIdentities,
    linkIdentity,
    unlinkIdentity,
    deleteAccount,
    setPassword,
    setupTwoFactor,
    verifyTwoFactor,
  }
}

================
File: composables/useTodaysPosts.ts
================
// composables/useTodaysPosts.ts
export function useTodaysPosts(filters?: {
  categories?: Array<{ id: number }>
  sources?: Array<{ id: number }>
}) {
  const todaysPosts = ref(0)
  const hasInitialized = ref(false)
  const supabase = useSupabaseClient()

  const fetchTodaysPosts = async () => {
    // Skip if we've already initialized
    if (hasInitialized.value) return

    const now = new Date()
    const startOfDay = new Date(now.getFullYear(), now.getMonth(), now.getDate())
    const endOfDay = new Date(startOfDay)
    endOfDay.setDate(startOfDay.getDate() + 1)

    const startISO = startOfDay.toISOString()
    const endISO = endOfDay.toISOString()

    try {
      // Build query with the new unified content structure
      let query = supabase
        .from('contents')
        .select('id', { count: 'exact', head: true })
        .gte('published_at', startISO)
        .lt('published_at', endISO)
        .eq('is_active', true)
        .is('deleted_at', null)

      // Add filters for content sources and categories
      if (filters?.sources?.length || filters?.categories?.length) {
        const orConditions = []

        // Filter by sources if provided
        if (filters.sources?.length) {
          orConditions.push(`source_id.in.(${filters.sources.map((s) => s.id).join(',')})`)
        }

        // Filter by categories - assuming categories are in the details JSONB
        if (filters.categories?.length) {
          // This approach depends on how categories are stored in your details JSONB
          // If stored directly as category_id:
          orConditions.push(
            `details->>'category_id'.in.(${filters.categories.map((c) => c.id).join(',')})`,
          )

          // If you're using an array of categories in the details:
          // You would need a different approach or a custom SQL function
        }

        if (orConditions.length > 0) {
          query = query.or(orConditions.join(','))
        }
      }

      const { count, error } = await query

      if (error) {
        console.error("Error fetching today's posts:", error)
        return
      }

      todaysPosts.value = count || 0
      hasInitialized.value = true
    } catch (err) {
      console.error('Error in fetchTodaysPosts:', err)
    }
  }

  return { todaysPosts, fetchTodaysPosts, hasInitialized }
}

================
File: composables/useUserMetricsStore.ts
================
// stores/useMetricsStore.ts
import { defineStore } from 'pinia'

export const useUserMetricsStore = defineStore('metrics', () => {
  const metrics = ref(null)
  const isLoading = ref(true)
  const error = ref(null)

  // Computed values from metrics
  const currentLevel = computed(() => metrics.value?.current_level || 0)
  const levelProgress = computed(() => {
    if (!metrics.value) return 0
    const { current_xp, xp_to_next_level } = metrics.value
    return Math.round((current_xp / xp_to_next_level) * 100)
  })

  const totalVotes = computed(() => metrics.value?.total_votes || 0)
  const upvoteCount = computed(() => metrics.value?.upvote_count || 0)
  const downvoteCount = computed(() => metrics.value?.downvote_count || 0)
  const todayVoteCount = computed(() => metrics.value?.today_activity.votes.length || 0)
  const voteAccuracy = computed(() => metrics.value?.vote_accuracy || 0)

  const remainingDailyVotes = computed(() => 10 - todayVoteCount.value)
  const dailyProgress = computed(() => (todayVoteCount.value / 10) * 100)

  // Streaks
  const currentStreak = computed(() => metrics.value?.current_streak || 0)
  const bestStreak = computed(() => metrics.value?.best_streak || 0)

  const achievementStats = computed(() => {
    if (!metrics.value?.achievements) return { completed: 0, total: 0 }

    let completed = 0
    let total = 0

    Object.values(metrics.value.achievements).forEach((category) => {
      Object.values(category as Record<string, boolean>).forEach((achieved) => {
        total++
        if (achieved) completed++
      })
    })

    return { completed, total }
  })

  const recentAchievements = computed(() => {
    if (!metrics.value?.achievements) return []

    const achievements: { category: string; name: string; achieved: boolean }[] = []

    Object.entries(metrics.value.achievements).forEach(([category, items]) => {
      Object.entries(items as Record<string, boolean>).forEach(([name, achieved]) => {
        achievements.push({ category, name, achieved })
      })
    })

    return achievements.filter((a) => a.achieved).slice(0, 3)
  })

  // Actions
  async function fetchMetrics() {
    try {
      isLoading.value = true
      const data = await $fetch('/api/users/metrics/get')
      metrics.value = data
    } catch (err) {
      error.value = err
      console.error('Error fetching metrics:', err)
    } finally {
      isLoading.value = false
    }
  }

  async function trackSourceVisit(sourceUrl: string, timeSpent: number) {
    const response = await $fetch('/api/users/metrics/track-source-visit', {
      method: 'POST',
      body: { sourceUrl, timeSpent },
    })
    metrics.value = response // Update store with new metrics
    return response
  }

  async function updateTitle(title: string) {
    const response = await $fetch('/api/users/metrics/update-title', {
      method: 'POST',
      body: { title },
    })
    metrics.value = response // Update store with new metrics
    return response
  }

  const trackNewsVisit = async (newsId: string) => {
    const startTime = Date.now()
    return async () => {
      const timeSpent = Math.floor((Date.now() - startTime) / 1000)
      const response = await $fetch('/api/users/metrics/track-source-visit', {
        method: 'POST',
        body: { newsId, timeSpent },
      })
      metrics.value = response // Update store with new metrics
      return response
    }
  }

  // Initialize metrics when store is created
  function init() {
    fetchMetrics()
  }

  return {
    // State
    metrics,
    isLoading,
    error,

    // Getters
    currentLevel,
    levelProgress,
    totalVotes,
    upvoteCount,
    downvoteCount,
    todayVoteCount,
    voteAccuracy,
    remainingDailyVotes,
    dailyProgress,
    currentStreak,
    bestStreak,
    achievementStats,
    recentAchievements,

    // Actions
    init,
    fetchMetrics,
    trackSourceVisit,
    updateTitle,
    trackNewsVisit,
  }
})

================
File: composables/useVotesStore.ts
================
// stores/useVoteStore.ts
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'

interface VoteResponse {
  success: boolean
  action: 'voted' | 'removed'
}

interface VoteMetrics {
  votes: Array<{
    id: string
    content_id: string
    vote_type: number
    created_at: string
    news_score: number
  }>
  votesByDate: Record<string, any[]>
  streakData: any[]
}

export const useVoteStore = defineStore('votes', () => {
  // Original vote store state
  const votes = ref<Record<string, number>>({})
  const userVotes = ref<Record<string, number>>({})
  const pendingVotes = ref<Record<string, Promise<VoteResponse>>>({})
  const { execute: executeOptimistic } = useOptimisticUpdate()

  // Metrics state
  const metrics = ref<VoteMetrics | null>(null)
  const isLoading = ref(false)
  const error = ref<Error | null>(null)

  // Original getters
  const getVoteType = computed(() => {
    return (contentId: string): number | null => userVotes.value[contentId] ?? null
  })

  const getScore = computed(() => {
    return (contentId: string): number | null => votes.value[contentId] ?? null
  })

  const isVotePending = computed(() => {
    return (contentId: string): boolean => !!pendingVotes.value[contentId]
  })

  // Metrics getters
  const totalVotes = computed(() => metrics.value?.votes.length ?? 0)

  const upvoteCount = computed(
    () => metrics.value?.votes.filter((v) => v.vote_type === 1).length ?? 0,
  )

  const downvoteCount = computed(
    () => metrics.value?.votes.filter((v) => v.vote_type === -1).length ?? 0,
  )

  const voteAccuracy = computed(() => {
    if (!metrics.value?.votes.length) return 0

    const alignedVotes = metrics.value.votes.filter((vote) => {
      if (vote.news_score === 0) return true
      return (
        (vote.news_score > 0 && vote.vote_type === 1) ||
        (vote.news_score < 0 && vote.vote_type === -1)
      )
    })

    return Math.round((alignedVotes.length / metrics.value.votes.length) * 100)
  })

  const streakInfo = computed(() => {
    if (!metrics.value?.votesByDate) return { current: 0, best: 0 }

    const dates = Object.keys(metrics.value.votesByDate).sort()
    if (!dates.length) return { current: 0, best: 0 }

    let currentStreak = 0
    let bestStreak = 0

    const today = new Date().toISOString().split('T')[0]
    const yesterday = new Date(Date.now() - 86400000).toISOString().split('T')[0]

    if (metrics.value.votesByDate[today]) {
      currentStreak = 1
      let checkDate = new Date(Date.now() - 86400000)

      while (true) {
        const dateStr = checkDate.toISOString().split('T')[0]
        if (metrics.value.votesByDate[dateStr]) {
          currentStreak++
          checkDate = new Date(checkDate.getTime() - 86400000)
        } else {
          break
        }
      }
    } else if (metrics.value.votesByDate[yesterday]) {
      currentStreak = 1
      let checkDate = new Date(Date.now() - 2 * 86400000)

      while (true) {
        const dateStr = checkDate.toISOString().split('T')[0]
        if (metrics.value.votesByDate[dateStr]) {
          currentStreak++
          checkDate = new Date(checkDate.getTime() - 86400000)
        } else {
          break
        }
      }
    }

    let tempStreak = 0
    for (let i = 0; i < dates.length; i++) {
      const currentDate = new Date(dates[i])
      const nextDate = i < dates.length - 1 ? new Date(dates[i + 1]) : null

      if (!tempStreak) tempStreak = 1
      else if (nextDate) {
        const daysDiff = Math.floor((nextDate.getTime() - currentDate.getTime()) / 86400000)
        if (daysDiff === 1) tempStreak++
        else {
          bestStreak = Math.max(bestStreak, tempStreak)
          tempStreak = 1
        }
      }
    }
    bestStreak = Math.max(bestStreak, tempStreak, currentStreak)

    return { current: currentStreak, best: bestStreak }
  })

  const todayVoteCount = computed(() => {
    if (!metrics.value?.votesByDate) return 0
    const today = new Date().toISOString().split('T')[0]
    return metrics.value.votesByDate[today]?.length ?? 0
  })

  // User votes tracking
  const fetchUserVotes = async () => {
    if (isLoading.value) return

    isLoading.value = true
    error.value = null

    try {
      // Updated to get votes for all content types from content_interactions
      const response = await $fetch('/api/votes/user')
      userVotes.value = response.votes
    } catch (err) {
      console.error('Error fetching votes:', err)
      error.value = err as Error
      throw err
    } finally {
      isLoading.value = false
    }
  }

  const fetchVotedPosts = async (voteType: 1 | -1) => {
    try {
      // Get voted posts for specific vote type
      const response = await $fetch(`/api/votes/user/${voteType}`)
      return response
    } catch (err) {
      console.error('Error fetching voted posts:', err)
      error.value = err as Error
      throw err
    }
  }

  const setVotes = (contentId: string, score: number) => {
    votes.value[contentId] = score
  }

  const submitVote = async (contentId: string, voteType: number, contentType: string = 'news') => {
    if (pendingVotes.value[contentId]) {
      return
    }

    const currentVote = getVoteType.value(contentId)
    const isRemoving = currentVote === voteType
    const oldVote = currentVote
    const oldScore = votes.value[contentId]

    return executeOptimistic({
      // Use contentId as key to prevent duplicate votes
      key: contentId,

      // Define API call
      apiCall: () =>
        $fetch(`/api/votes/${contentType}/${contentId}`, { method: 'POST', body: { voteType } }),

      // Optimistic update function
      optimisticUpdate: () => {
        // Update user vote
        userVotes.value = { ...userVotes.value, [contentId]: isRemoving ? null : voteType }

        // Update score
        const change = isRemoving ? -voteType : oldVote ? voteType * 2 : voteType
        votes.value = { ...votes.value, [contentId]: votes.value[contentId] + change }

        return { success: true, change }
      },

      // Rollback function
      rollback: () => {
        userVotes.value = { ...userVotes.value, [contentId]: oldVote }
        votes.value = { ...votes.value, [contentId]: oldScore }
      },
    })
  }

  // User metrics
  const fetchMetrics = async () => {
    if (isLoading.value) return

    isLoading.value = true
    error.value = null

    try {
      // Get metrics using the updated endpoint that works with content_interactions
      const response = await $fetch('/api/users/metrics')
      metrics.value = response as VoteMetrics
    } catch (err) {
      console.error('Error fetching metrics:', err)
      error.value = err as Error
      throw err
    } finally {
      isLoading.value = false
    }
  }

  return {
    // State
    votes,
    userVotes,
    isLoading,
    error,

    // Original getters
    getScore,
    getVoteType,
    isVotePending,

    // Metrics getters
    totalVotes,
    upvoteCount,
    downvoteCount,
    voteAccuracy,
    streakInfo,
    todayVoteCount,

    // Original actions
    setVotes,
    fetchUserVotes,
    submitVote,
    fetchVotedPosts,

    // New metrics action
    fetchMetrics,
  }
})

================
File: layouts/default.vue
================
<script setup lang="ts">
const { appLinks } = usePages()
const { isSidebarOpen, isMobileSidebarOpen, isMobile } = useNavigation()
const showPrelaunchMessage = useCookie<boolean>('frontiers_message', { default: () => true })

const handleMessageClose = () => {
  showPrelaunchMessage.value = false
}
</script>

<template>
  <div class="h-screen flex flex-col relative background">
    <RoleOverride />
    <div class="w-full flex backgroun d overflow-hidden lg:py-4 lg:pr-4 h-full">
      <IBMenuSidebar
        v-model:is-sidebar-open="isSidebarOpen"
        v-model:is-mobile-sidebar-open="isMobileSidebarOpen"
        :categories="appLinks"
        :is-mobile="isMobile"
      />
      <div
        class="w-full h-full pb-[var(--mobi-bottom-nav-height)] lg:pb-0 relative flex flex-col rounded-lg overflow-hidden"
      >
        <NavAppTop />
        <div class="overflow-y-scroll h-full foreground">
          <div class="h-full">
            <slot />
          </div>
        </div>
      </div>
      <NavMobiBottom class="lg:hidden" />
    </div>
  </div>
</template>

================
File: layouts/settings.vue
================
<script setup lang="ts">
const { settingsRoutes } = useSettingsNavigation()
</script>

<template>
  <div class="flex flex-col h-screen">
    <NuxtLayout name="default">
      <div class="min-h-screen flex flex-col p-4 bg-black md:flex-row md:gap-8 lg:p-8">
        <SettingsNavigation :routes="settingsRoutes" />
        <div class="min-w-2xl max-w-6xl flex-grow">
          <slot />
        </div>
      </div>
    </NuxtLayout>
  </div>
</template>

================
File: pages/feed/[feed].vue
================
<script setup lang="ts">
const route = useRoute()
const feedId = computed(() => String(route.params.feed))
const { deleteFeed, currentFeedName } = usePages()

console.log('feedId', feedId.value)

const isLoadingDependencies = ref(true)
// Load feed categories and sources
const { store: categoriesStore, isSelecting: isLoadingCategories } = useSelectData(
  'feed_categories',
  {
    columns: 'id, feed_id, categories(id, name)',
    filters: { feed_id: { eq: feedId.value } },
    orderBy: { column: 'created_at', ascending: false },
    initialFetch: true,
    storeKey: `feedCategories_${feedId.value}`,
  },
)

const { store: sourcesStore, isSelecting: isLoadingSources } = useSelectData('feed_sources', {
  columns: 'id, feed_id, content_source_id, content_sources(id, url, content_type)',
  filters: { feed_id: { eq: feedId.value } },
  orderBy: { column: 'created_at', ascending: false },
  initialFetch: true,
  storeKey: `feedSources_${feedId.value}`,
})

const { items: proxyCategories } = storeToRefs(categoriesStore)
const { items: proxySources } = storeToRefs(sourcesStore)

const categories = computed(() => proxyCategories.value.map((item) => toRaw(item).categories))
const sources = computed(() => proxySources.value.map((item) => toRaw(item).content_sources))

// Watch for dependencies to load
watchEffect(() => {
  isLoadingDependencies.value = isLoadingCategories.value || isLoadingSources.value
})

// Initialize news only after dependencies are loaded
// Updated to use new content table structure
const newsQuery = computed(() => {
  // Start with base filters for unified content table
  const queryFilters: Record<string, FilterOption> = {}

  // Add content_type filter for news type
  queryFilters['content_type'] = { eq: 'news' }

  // Add source filtering if available
  if (sources.value?.length && sources.value[0]) {
    queryFilters['source_id'] = { in: sources.value.map((source) => source.id) }
  }

  // Add category filtering if available - assumes categories are in details JSONB
  if (categories.value?.length && categories.value[0]) {
    const categoryIds = categories.value.map((category) => category.id)

    // Create a condition for JSONB details field containing category_id
    // Note: This implementation might need to be adjusted based on your exact JSONB structure
    queryFilters['details->category_id'] = { in: categoryIds.join(',') }
  }

  // Content must be active and not deleted
  queryFilters['is_active'] = { eq: true }
  queryFilters['deleted_at'] = { is: null }

  return {
    // Updated to query the contents table with needed fields
    columns: `
      id, 
      content_type,
      title, 
      url, 
      created_at, 
      hot_score,
      published_at, 
      description, 
      author, 
      featured_image, 
      source_id,
      company_id,
      details
    `,
    filters: queryFilters,
    orderBy: { column: 'published_at', ascending: false },
    pagination: { page: 1, limit: 20 },
    storeKey: `customFeed_${feedId.value}`,
    enabled: !isLoadingDependencies.value,
  }
})

const news = computed(() => newsStore?.items || [])

// Create news store only when query is ready
const {
  store: newsStore,
  loadMore: loadMoreFunc,
  refresh: refreshNews,
  isSelecting: isLoadingNews,
} = useSelectData<any>('contents', newsQuery)

// Watch for query changes to refresh
watch(
  newsQuery,
  () => {
    if (newsQuery.value && refreshNews) {
      newsStore.clearItems()
      refreshNews()
    }
  },
  { deep: true },
)

// Safe loadMore function
const handleLoadMore = async () => {
  if (isLoadingNews.value || !loadMoreFunc) return

  try {
    await loadMoreFunc()
  } catch (error: any) {
    console.error('Error loading more news:', error)
  }
}

// Loading states
const loading = useLoadingStore()
const isLoading = computed(
  () =>
    isLoadingDependencies.value ||
    isLoadingNews.value ||
    loading.isLoading(`customFeed_${feedId.value}`),
)

onUnmounted(() => {
  newsStore?.clearItems()
})

// URL formatting helper
const formatSourceUrl = (url: string) => {
  try {
    const urlObj = new URL(url)
    return urlObj.hostname.replace('www.', '')
  } catch {
    return url
  }
}
const { topBannerAd } = useAdsStore()

// UI state
const showFiltersModal = ref(false)

// Clean up store when component is unmounted
onUnmounted(() => {
  newsStore.clearItems()
})
</script>

<template>
  <div>
    <FeedTitle
      :title="currentFeedName"
      :filters="{ categories, sources }"
    />

    <BlackFridayBanner />

    <!-- <AdsBanner
      v-if="topBannerAd"
      :ad="topBannerAd"
    /> -->

    <IBInfiniteScroll
      :threshold="1400"
      @update:scroll-end="handleLoadMore"
    >
      <div
        class="mx-auto w-full grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 md:col-start-2 gap-4 md:gap-8 p-4 md:p-8 max-w-[940px]"
      >
        <NewsCard
          v-for="item in news"
          :key="`news-post-${item.id}`"
          :news="item"
        />
        <NewsCardSkeleton v-show="isLoading" />
      </div>
    </IBInfiniteScroll>

    <PrimeDialog
      v-model:visible="showFiltersModal"
      modal
      header="Feed Filters"
      :style="{ width: '50vw' }"
    >
      <div class="space-y-6">
        <div v-if="categories.length">
          <h3 class="text-lg font-semibold mb-3">Categories</h3>
          <div class="flex flex-wrap gap-2">
            <PrimeChip
              v-for="category in categories"
              :key="category.id"
              :label="category.name"
              class="bg-primary-700 border border-primary-600"
            />
          </div>
        </div>

        <div v-if="sources.length">
          <h3 class="text-lg font-semibold mb-3">Sources</h3>
          <div class="flex flex-wrap gap-2">
            <PrimeChip
              v-for="source in sources"
              :key="source.id"
              :label="formatSourceUrl(source.url)"
              :title="source.url"
              class="bg-secondary-700 border border-secondary-600"
            >
              <template #extra>
                <span class="text-xs ml-1 opacity-75">{{ source.content_type }}</span>
              </template>
            </PrimeChip>
          </div>
        </div>
      </div>
    </PrimeDialog>
  </div>
</template>

================
File: pages/feed/add.vue
================
<script setup lang="ts">
const { store: categoriesStore } = useSelectData('categories', {
  columns: 'id, name',
  orderBy: { column: 'name', ascending: true },
  initialFetch: true,
})

// Fetch content sources directly (not through contents anymore)
const { store: sourcesStore } = useSelectData('content_sources', {
  columns: `
    id,
    url,
    companies (
      id,
      name,
      logo_url,
      category,
      description
    )
  `,
  orderBy: { column: 'created_at', ascending: true },
  initialFetch: true,
})

// Toggle source selection - using the content_source id directly now
const toggleSource = (sourceId: number) => {
  // Now it's definitely a number/bigint
  if (selectedSourceIds.value.has(sourceId)) {
    selectedSourceIds.value.delete(sourceId)
  } else {
    selectedSourceIds.value.add(sourceId)
  }
}

const name = ref('')
const selectedCategories = ref([])
const selectedSourceIds = ref(new Set())
const categorySearch = ref('')
const sourceSearch = ref('')

const { items: categories } = storeToRefs(categoriesStore)
const { items: sources } = storeToRefs(sourcesStore)

// Computed property for filtered sources based on search
const filteredSources = computed(() => {
  if (!sourceSearch.value) return sources.value

  const search = sourceSearch.value.toLowerCase()
  return sources.value.filter(
    (source) =>
      source.title?.toLowerCase().includes(search) ||
      source.companies?.name?.toLowerCase().includes(search),
  )
})

const save = async () => {
  const toast = useNotification()

  const feed = {
    name: name.value,
    selectedCategories: selectedCategories.value,
    selectedSourceIds: selectedSourceIds.value,
  }

  try {
    const data = await $fetch('/api/feeds', {
      method: 'POST',
      body: feed,
    })

    toast.success({ summary: 'Feed added', message: `${feed.name} was created successfully` })
    navigateTo('/')
  } catch (error: any) {
    toast.error({ summary: 'Error creating feed', message: error.message })
  }
}

const reset = () => {
  name.value = ''
  selectedCategories.value = []
  selectedSourceIds.value = new Set()
  categorySearch.value = ''
  sourceSearch.value = ''
}
</script>

<template>
  <div class="max-w-6xl mx-auto p-4">
    <div class="mb-6">
      <h1 class="text-2xl font-semibold mb-2">Create New Feed</h1>
      <p class="text-gray-500">Select categories and sources for your personalized feed</p>
    </div>

    <div class="space-y-6">
      <!-- Feed Name -->
      <PrimeCard>
        <template #title>Feed Details</template>
        <template #content>
          <PrimeInputText
            v-model="name"
            placeholder="Enter feed name"
            class="w-full mb-4"
          />
        </template>
      </PrimeCard>

      <!-- Categories Selection -->
      <PrimeCard>
        <template #title>Categories</template>
        <template #subtitle>Select topics you're interested in</template>
        <template #content>
          <PrimeMultiSelect
            v-model="selectedCategories"
            :options="categories"
            option-label="name"
            :filter="true"
            placeholder="Search and select categories"
            class="w-full"
            display="chip"
          >
            <template #header>
              <div class="font-medium px-3 py-2">
                Available Categories
                <span
                  v-if="selectedCategories.length"
                  class="text-sm text-primary-500 ml-2"
                >
                  ({{ selectedCategories.length }} selected)
                </span>
              </div>
            </template>

            <template #option="{ option }">
              <div class="flex items-center px-3 py-2">
                <div>{{ option.name }}</div>
              </div>
            </template>

            <template #footer>
              <div class="p-3 flex justify-between">
                <PrimeButton
                  label="Select All"
                  severity="secondary"
                  text
                  size="small"
                  icon="pi pi-check-circle"
                  @click="selectedCategories = [...categories]"
                />
                <PrimeButton
                  label="Clear All"
                  severity="danger"
                  text
                  size="small"
                  icon="pi pi-times"
                  @click="selectedCategories = []"
                />
              </div>
            </template>
          </PrimeMultiSelect>
        </template>
      </PrimeCard>

      <!-- Sources Selection -->
      <PrimeCard class="max-h-[540px] overflow-scroll">
        <template #title>Sources</template>
        <template #subtitle>Follow specific news sources</template>
        <template #content>
          <!-- Search input -->
          <div class="mb-4 sticky top-0">
            <PrimeInputText
              v-model="sourceSearch"
              placeholder="Search sources"
              class="w-full"
            />
          </div>

          <!-- Source cards grid -->
          <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4">
            <button
              v-for="source in filteredSources"
              :key="source.id"
              class="flex items-center p-4 rounded-lg border border-gray-800 transition-colors text-left"
              :class="{
                'bg-primary-900 border-primary-700': selectedSourceIds.has(source.id),
                'hover:border-primary-700': !selectedSourceIds.has(source.id),
              }"
              @click="toggleSource(source.id)"
            >
              <div class="flex items-center gap-3 w-full">
                <div class="w-10 h-10 rounded-full overflow-hidden flex-shrink-0">
                  <img
                    :src="
                      source.companies?.logo_url ||
                      `/api/placeholder/40/40?text=${source.companies?.name?.[0] || 'S'}`
                    "
                    :alt="source.companies?.name"
                    class="w-full h-full object-cover"
                  />
                </div>
                <div class="flex-grow min-w-0">
                  <div class="font-medium truncate">{{ source.companies?.name }}</div>
                  <div class="text-sm text-gray-400 truncate">{{ source.url }}</div>
                </div>
                <Icon
                  v-if="selectedSourceIds.has(source.id)"
                  name="mdi:check-circle"
                  class="text-primary-500 flex-shrink-0"
                  size="20"
                />
              </div>
            </button>
          </div>
        </template>
      </PrimeCard>

      <!-- Actions -->
      <div class="flex justify-end gap-4">
        <PrimeButton
          label="Reset"
          severity="secondary"
          outlined
          @click="reset"
        />
        <PrimeButton
          label="Create Feed"
          :disabled="!name || (!selectedCategories.length && !selectedSourceIds.size)"
          @click="save"
        />
      </div>
    </div>
  </div>
</template>

================
File: pages/news/index.vue
================
<!-- NewsFeed.vue -->
<script setup lang="ts">
const sortingMethod = ref<'created_at' | 'hot_score'>('created_at')

const { topBannerAd } = useAdsStore()

// No changes needed to this component since it only uses the FeedRecent and FeedHot components
// which will be updated separately to work with the new database structure
</script>

<template>
  <div>
    <FeedTitle title="News Feed" />
    <!-- <AdsBanner
      v-if="topBannerAd"
      :ad="topBannerAd"
    /> -->

    <!-- <AdsDiscountBanner /> -->

    <FeedHotToggle v-model="sortingMethod" />

    <Transition
      name="fade"
      mode="out-in"
    >
      <FeedRecent v-if="sortingMethod === 'created_at'" />
      <FeedHot v-else />
    </Transition>
  </div>
</template>

================
File: pages/achievements.vue
================
<template>
  <div class="min-h-screen flex justify-center items-center">
    <div class="max-w-md mx-auto p-8 background rounded-xl shadow-lg text-center space-y-6 w-full">
      <!-- Achievements Header with Icon -->
      <div class="flex flex-col items-center">
        <Icon
          name="mdi:star-circle-outline"
          size="48px"
          class="text-yellow-500 text-6xl mb-4"
        />
        <h1 class="text-3xl font-bold">Achievements</h1>
      </div>
      <!-- Coming Soon Notice with Icon -->
      <div class="flex flex-col items-center">
        <Icon
          name="material-symbols:hourglass-empty-rounded"
          class="text-blue-500 text-5xl mb-2"
        />
        <p class="text-xl">Coming Soon!</p>
      </div>
      <!-- Game Related Icon for Flair -->
      <div class="flex justify-center space-x-4 mt-6">
        <Icon
          name="game-icons:laurels-trophy"
          class="text-red-500 text-4xl"
        />
        <Icon
          name="game-icons:achievement"
          class="text-green-500 text-4xl"
        />
        <Icon
          name="mdi:firework"
          class="text-orange-500 text-4xl"
        />
      </div>
    </div>
  </div>
</template>

<script setup lang="ts"></script>

<style scoped></style>

================
File: pages/ask.vue
================
<script setup lang="ts">
interface ChatAgent {
  id: number
  name: string
  features: string[]
  systemMessage: string
  enabled: boolean
  starterPrompts: string[]
}

interface Message {
  role: 'user' | 'assistant'
  content: string
}

const agents: ChatAgent[] = [
  {
    id: 1,
    name: 'Astronomy Communicator',
    features: [
      'Break down complex astronomy concepts',
      'Explain in an engaging, Carl Sagan-inspired style',
      'Make astronomy accessible to all',
    ],
    systemMessage:
      'You are an enthusiastic astronomy science communicator who can break down even the most complex topics into something easy to understand. Channel the spirit of Carl Sagan in your explanations, using vivid imagery and relatable analogies. Your goal is to inspire wonder and curiosity about the cosmos in every interaction.',
    enabled: true,
    starterPrompts: [
      'Can you explain black holes in a way that would captivate a 10-year-old?',
      "What's the most mind-blowing fact about our universe that you can share?",
      "How would you describe the concept of light-years to someone who's never heard of it before?",
    ],
  },
  {
    id: 2,
    name: 'Space Tech Analyst',
    features: [
      'Research astronomy and space tech companies',
      'Provide insights for job seekers and competitors',
      'Analyze company profiles and trends',
    ],
    systemMessage:
      'You are an astronomy and space tech company researcher. Your database contains information on numerous companies in the field. Your role is to answer questions about these companies, help users find potential employers, and perform competitor analysis. Provide detailed, factual information and insightful comparisons when asked.',
    enabled: true,
    starterPrompts: [
      'What are the top 3 companies currently leading in commercial space flight, and how do they compare?',
      "I'm an aerospace engineer looking for job opportunities. Which companies should I be watching?",
      'Can you provide a brief analysis of the current trends in the satellite industry?',
    ],
  },
  {
    id: 3,
    name: 'Space News Reporter',
    features: [
      'Report on latest astronomy and space news',
      'Provide expert analysis on recent developments',
      'Offer context and implications of news stories',
    ],
    systemMessage:
      'You are an expert news reporter specializing in astronomy and space news. Your knowledge is based on a constantly updated database of news articles. When asked, provide the latest developments in the field, offer expert analysis, and explain the significance of recent news stories. Your reporting should be accurate, engaging, and informative.',
    enabled: true,
    starterPrompts: [
      "What's the most significant space exploration news from the past week?",
      'Can you give me an update on the latest developments in the search for exoplanets?',
      'What are the potential implications of the most recent Mars rover discoveries?',
    ],
  },
  {
    id: 4,
    name: 'Astronomy Fact Generator',
    features: [
      'Share random, fascinating astronomy facts',
      'Cover a wide range of astronomical topics',
      'Provide brief, engaging explanations',
    ],
    systemMessage:
      'You are an astronomy fact generator. Your purpose is to share interesting and fun facts about astronomy and space. When prompted, randomly select a topic from your vast knowledge base and provide a fascinating fact along with a brief, engaging explanation. Your facts should spark curiosity and encourage further exploration of astronomical topics.',
    enabled: true,
    starterPrompts: [
      "Tell me an interesting fact about Saturn's rings.",
      'Share a mind-blowing fact about the scale of the universe.',
      "What's a surprising fact about stars that most people don't know?",
    ],
  },
  {
    id: 5,
    name: 'Research Assistant',
    features: [
      'Find relevant astronomy papers',
      'Summarize key findings',
      'Suggest related research',
    ],
    systemMessage:
      'You are a research assistant specializing in astronomy and astrophysics. Your role is to help users find relevant scientific papers, summarize key findings, and suggest related research. Provide concise, accurate information and guide users towards valuable resources in their area of interest.',
    enabled: false,
    starterPrompts: [
      'Can you find recent papers on dark matter detection methods?',
      'What are the key findings from the latest research on exoplanet atmospheres?',
      "I'm interested in radio astronomy. What are some fundamental papers I should read to get started?",
    ],
  },
  {
    id: 6,
    name: 'Space Station Life Simulator',
    features: [
      'Describe daily routines in space',
      'Explain space-specific challenges',
      'Simulate space station experiences',
    ],
    systemMessage:
      'You are a Space Station Life Simulator, an expert on daily life and challenges of living in space. Your role is to provide accurate, detailed, and engaging descriptions of life aboard a space station, drawing from real astronaut experiences and scientific knowledge.',
    enabled: true,
    starterPrompts: [
      "What's the most challenging aspect of personal hygiene in space?",
      "Describe a typical 'day' for an astronaut on the International Space Station.",
      'How do astronauts exercise in zero gravity, and why is it so important?',
    ],
  },
  {
    id: 7,
    name: 'Dark Matter & Energy Theorist',
    features: [
      'Explain current dark matter theories',
      'Discuss dark energy research',
      'Explore implications for the universe',
    ],
    systemMessage:
      'You are a Dark Matter & Energy Theorist, well-versed in current theories and research on these mysterious components of the universe. Your goal is to explain complex concepts in an understandable way, discuss ongoing research, and explore the implications for our understanding of the universe.',
    enabled: true,
    starterPrompts: [
      "What's the strongest evidence we have for the existence of dark matter?",
      'How does dark energy affect the expansion of the universe?',
      'What are some alternative theories to dark matter and dark energy?',
    ],
  },
  {
    id: 8,
    name: 'Rocket Science Explainer',
    features: [
      'Break down rocket propulsion basics',
      'Explain different types of rockets',
      'Discuss challenges in rocketry',
    ],
    systemMessage:
      'You are a Rocket Science Explainer, adept at breaking down the principles of rocketry and propulsion systems. Your role is to make complex rocket science concepts accessible to a general audience, explaining how rockets work and the challenges involved in space launch systems.',
    enabled: true,
    starterPrompts: [
      'Can you explain how a rocket generates thrust in simple terms?',
      'What are the main differences between liquid and solid fuel rockets?',
      "What's the concept behind reusable rockets, and why are they important?",
    ],
  },
  {
    id: 9,
    name: 'Astrobiology Specialist',
    features: [
      'Discuss potential for extraterrestrial life',
      'Explain habitable zone concepts',
      'Describe astrobiology research methods',
    ],
    systemMessage:
      'You are an Astrobiology Specialist, focusing on the potential for life in the universe and related research. Your role is to discuss the conditions necessary for life, explain current research in astrobiology, and explore the implications of potentially finding life beyond Earth.',
    enabled: true,
    starterPrompts: [
      'What are the key factors that make a planet potentially habitable?',
      'How do scientists search for signs of life on other planets?',
      'What would be the implications if we found microbial life on Mars?',
    ],
  },
  {
    id: 10,
    name: 'Cosmic Calendar Creator',
    features: [
      'Inform about upcoming astronomical events',
      'Explain significance of celestial phenomena',
      'Provide viewing tips for events',
    ],
    systemMessage:
      'You are a Cosmic Calendar Creator, an expert on upcoming astronomical events and phenomena. Your role is to inform users about interesting celestial events, explain their significance, and provide tips on how to best observe or appreciate these cosmic occurrences.',
    enabled: true,
    starterPrompts: [
      'What are the most exciting astronomical events coming up in the next month?',
      'Can you explain what causes a solar eclipse and when the next one will be visible?',
      'How can I best prepare to view the next meteor shower?',
    ],
  },
  {
    id: 11,
    name: 'Astrophotography Coach',
    features: [
      'Offer tips for capturing celestial images',
      'Explain astrophotography equipment',
      'Provide post-processing guidance',
    ],
    systemMessage:
      'You are an Astrophotography Coach, skilled in the art and science of capturing stunning astronomical images. Your role is to offer tips and techniques for astrophotography, explain equipment choices, and provide guidance on image processing to help users create beautiful cosmic photographs.',
    enabled: true,
    starterPrompts: [
      "What's the best way to start astrophotography on a budget?",
      'Can you explain the technique of stacking in astrophotography?',
      'What settings should I use to photograph the Milky Way?',
    ],
  },
  {
    id: 12,
    name: 'Space Mission Planner',
    features: [
      'Explain space mission planning stages',
      'Discuss challenges in space exploration',
      'Describe different types of space missions',
    ],
    systemMessage:
      'You are a Space Mission Planner, an expert in the complexities of planning and executing space missions. Your role is to help users understand the various stages of mission planning, the challenges involved, and the different types of missions undertaken in space exploration.',
    enabled: true,
    starterPrompts: [
      'What are the key stages in planning a mission to Mars?',
      'How do space agencies choose landing sites for planetary missions?',
      'What are the main challenges in planning a long-duration space mission?',
    ],
  },
  {
    id: 13,
    name: 'Cosmic Scale Visualizer',
    features: [
      'Provide comparisons for cosmic scales',
      'Explain distances in space',
      'Visualize sizes of celestial objects',
    ],
    systemMessage:
      'You are a Cosmic Scale Visualizer, adept at helping users comprehend the vast distances and sizes in the universe. Your role is to provide relatable comparisons, explain cosmic distances in understandable terms, and help visualize the scale of celestial objects and cosmic structures.',
    enabled: true,
    starterPrompts: [
      'Can you explain the size of our solar system using a relatable analogy?',
      'How can we visualize the distance to the nearest star beyond our Sun?',
      "What's a good way to understand the scale of the Milky Way galaxy?",
    ],
  },
]

const chatStore = useChatStore()

definePageMeta({ name: 'Q&A' })

const selectedAgent = ref(null as ChatAgent | null)
const message = ref('')
const conversation = ref<Message[]>([])
const selectedStarterPrompts = ref([] as string[])

const selectAgent = (agent: ChatAgent) => {
  if (agent.enabled) {
    selectedAgent.value = selectedAgent.value?.id === agent.id ? null : agent
    selectedStarterPrompts.value = selectedAgent.value?.starterPrompts || []
    conversation.value = []
  }
}

const closeAgent = () => {
  selectedAgent.value = null
  selectedStarterPrompts.value = []
  conversation.value = []
}

const selectPrompt = (prompt: string) => {
  message.value = prompt
  selectedStarterPrompts.value = []
}

const responsiveOptions = ref([
  {
    breakpoint: '1199px',
    numVisible: 3,
    numScroll: 3,
  },
  {
    breakpoint: '991px',
    numVisible: 2,
    numScroll: 2,
  },
  {
    breakpoint: '767px',
    numVisible: 1,
    numScroll: 1,
  },
])
</script>

<template>
  <div class="flex h-[calc(100vh-32px)] flex-col">
    <div
      class="mx-auto grid h-full max-w-[1000px] grid-cols-1 overflow-scroll p-4 md:grid-cols-[1fr_minmax(200px,700px)_1fr]"
    >
      <div class="w-full md:col-span-3 md:col-start-1 md:row-start-1">
        <div class="space-y-2 pb-6 text-center">
          <h1 class="text-5xl font-semibold"> Galactic Guide </h1>
          <div class="flex gap-2 pt-2">
            <PrimeMessage
              severity="info"
              class="flex w-full justify-center"
            >
              3 question limit per 30 min
            </PrimeMessage>
            <PrimeMessage
              severity="warn"
              class="flex w-full justify-center"
            >
              Always validate answers.
            </PrimeMessage>
          </div>
        </div>
        <PrimeCarousel
          :value="agents"
          :num-visible="3"
          :num-scroll="3"
          :responsive-options="responsiveOptions"
        >
          <template #item="slotProps">
            <div
              class="m-2 rounded border border-color p-4"
              :class="{
                'cursor-pointer transition-shadow hover:shadow-lg': slotProps.data.enabled,
                'opacity-50': !slotProps.data.enabled,
              }"
              @click="slotProps.data.enabled && selectAgent(slotProps.data)"
            >
              <div class="mb-4 font-medium">
                {{ slotProps.data.name }}
              </div>
              <div class="mb-4">
                <ul class="list-disc pl-5">
                  <li
                    v-for="feature in slotProps.data.features"
                    :key="feature"
                    class="text-sm"
                  >
                    {{ feature }}
                  </li>
                </ul>
              </div>
              <div class="flex items-center justify-between">
                <PrimeTag
                  :value="slotProps.data.enabled ? 'Enabled' : 'Disabled'"
                  :severity="slotProps.data.enabled ? 'success' : 'danger'"
                />

                <PrimeTag
                  v-if="selectedAgent?.id === slotProps.data.id"
                  value="Selected"
                  severity="info"
                />
              </div>
            </div>
          </template>
        </PrimeCarousel>
      </div>
      <div
        class="mx-auto flex h-full w-full flex-col justify-between gap-4 md:col-start-2 md:row-start-2 xl:gap-8"
      >
        <div
          v-if="chatStore.messages.length"
          class="space-y-4 pb-4 xl:space-y-8 xl:pb-8"
        >
          <div
            v-for="(msg, index) in chatStore.messages"
            :key="index"
            :class="msg.role"
          >
            <p class="pb-2 pl-2">
              <strong class="pb-4">{{ msg.role === 'user' ? 'You' : 'Assistant' }}</strong>
            </p>
            <div class="w-full rounded-md bg-primary-950 p-4 text-surface-300">
              <MDC
                :value="msg.content"
                class="prose prose-invert"
              />
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Fixed Bottom Bar -->

    <div class="foreground border-color flex-shrink-0 border-t p-4">
      <div class="mx-auto max-w-[600px]">
        <div
          v-if="selectedStarterPrompts.length"
          class="space-y-2 pb-2"
        >
          <div class="flex justify-center items-center">
            <p class="text-center flex-grow font-semibold"> Example Questions </p>
            <PrimeButton
              severity="secondary"
              class="text-end ml-auto text-white font-semibold"
              @click="closeAgent"
            >
              X
            </PrimeButton>
          </div>
          <PrimeButton
            v-for="prompt in selectedStarterPrompts"
            :key="prompt"
            severity="secondary"
            outlined
            class="mb-2 mr-2 flex w-full items-start justify-start text-left"
            @click="selectPrompt(prompt)"
          >
            {{ prompt }}
          </PrimeButton>
        </div>
        <SearchBar
          :selected-prompt="message"
          :system-prompt="selectedAgent?.systemMessage"
        />
      </div>
    </div>
  </div>
</template>

<style scoped></style>

================
File: pages/companies.vue
================
<script setup lang="ts">
definePageMeta({ name: 'Companies' })

const currentUser = useCurrentUser()
const { profile } = storeToRefs(currentUser)

const isUserBasic = profile.value.user_plan === 'free'
const showDialog = ref(isUserBasic)
const loading = useLoadingStore()

const searchQuery = ref('')
const searchResults = ref<any[]>([])
const searchFuseOptions = {
  keys: ['name', 'description', 'categories.name', 'founding_year'],
  threshold: 0.3,
  shouldSort: true,
}

const handleSearchResults = (results: FuseResult<any>[]) => {
  console.log('Search results:', results)
  searchResults.value = results.map((result) => result.item)
}

// Ads integration
const { isLoading: adsLoading } = useAdsStore()

const { store, loadMore } = useSelectData('companies', {
  orderBy: { column: 'logo_url', ascending: true },
  columns: `id, name, description, logo_url, founding_year, url, is_government, category, keywords, job_url,
  categories(id, name),
  social_media(id, facebook_url, linkedin_url, twitter_url, instagram_url, youtube_url),
  addresses(id, countries(name), cities(name))`,
  pagination: {
    page: 1,
    limit: 20,
  },
  filters: { content_status: { eq: 'published' } },
  initialFetch: true,
  storeKey: 'companiesFeed',
})

const handleScroll = () => {
  if (!isUserBasic) loadMore()
}

const { items } = storeToRefs(store)

const companies = computed(() =>
  items.value.map((company) => ({
    ...company,
    city: company.addresses?.[0]?.cities?.name,
    country: company.addresses?.[0]?.countries?.name,
    category: company.categories?.name,
  })),
)

const showSkeletonGrid = computed(() => loading.isLoading('companiesFeed') || adsLoading.value)

const filteredCompanies = computed(() => {
  let filtered = companies.value ?? []

  // Filter by search
  if (searchQuery.value && searchResults.value?.length) {
    return searchResults.value
  }

  return filtered
})
</script>

<template>
  <div
    :class="{ 'h-full overflow-hidden blur-sm pointer-events-none': isUserBasic }"
    @wheel="(event) => isUserBasic && event.preventDefault()"
    @touchmove="(event) => isUserBasic && event.preventDefault()"
  >
    <div class="w-full">
      <FuzzySearch
        v-model="searchQuery"
        :data="companies"
        :fuse-options="searchFuseOptions"
        placeholder="Search companies..."
        class="w-full"
        @results="handleSearchResults"
      />
    </div>
    <Transition
      name="fade"
      mode="out-in"
    >
      <IBInfiniteScroll
        v-if="!showSkeletonGrid"
        :threshold="1400"
        :disabled="isUserBasic"
        @update:scroll-end="handleScroll"
      >
        <CompaniesTable :companies="filteredCompanies" />
      </IBInfiniteScroll>
      <CompaniesSkeleton v-else />
    </Transition>
  </div>
  <PrimeDialog
    v-model:visible="showDialog"
    :modal="true"
    header="🚀 Upgrade Your Plan"
    class="w-[80vw] md:w-[30vw] rounded-md"
  >
    <div class="flex flex-col items-center gap-4 p-6 text-center">
      <!-- Upgrade Icon -->
      <Icon
        name="mdi:crown"
        size="48px"
        class="text-yellow-500"
      />

      <!-- Upgrade Message -->
      <h3 class="text-lg font-semibold text-white"> Unlock Premium Features! </h3>
      <p class="text-white text-sm">
        Upgrade your plan to access all companies and premium insights.
      </p>

      <!-- Buttons -->
      <div class="flex gap-3 mt-4">
        <NuxtLink to="/settings/payments">
          <PrimeButton
            severity="success"
            class="px-6 py-2 flex items-center gap-2"
          >
            <Icon
              name="mdi:star"
              size="20px"
              class="text-yellow-400"
            />
            Upgrade Now
          </PrimeButton>
        </NuxtLink>
      </div>
    </div>
  </PrimeDialog>
</template>

================
File: pages/events.vue
================
<script setup lang="ts">
const domainKey = 'events'
const eventsStore = useEventsStore()
const { events } = storeToRefs(eventsStore)

const haveEvents = computed(() => events.value !== null && events.value.length > 0)

const fetchInput = ref({
  domainKey,
  endpoint: '/api/events/select/cards',
  criteria: {
    dto: 'select:events:card',
  },
}) as Ref<FetchInput>

watchEffect(() => {
  if (haveEvents.value === false) {
    console.log('Fetching events')
    eventsStore.loadEvents(fetchInput.value)
  }
})

const loading = useLoadingStore()
const isLoading = computed(() => loading.isLoading(domainKey))

definePageMeta({ name: 'Events' })
</script>

<template>
  <div>
    <IBInfiniteScroll
      :domain-key="domainKey"
      :pagination="{
        page: 1,
        limit: 20,
      }"
      @update:scroll-end="eventsStore.loadEvents(fetchInput)"
    >
      <div
        v-if="haveEvents"
        class="grid grid-cols-1 md:grid-cols-2 md:gap-4 lg:grid-cols-3 xl:grid-cols-4 xl:gap-8"
      >
        <EventCard
          v-for="(event, i) in events"
          :key="`events-post-${i}`"
          :events="event"
        />
      </div>
      <div
        v-else
        class="grid grid-cols-1 md:grid-cols-2 md:gap-4 lg:grid-cols-3 2xl:grid-cols-4 2xl:gap-8"
      >
        <div class="foreground space-y-1 rounded-md p-8 shadow-md">
          <h3 class="pb-4 text-xl font-semibold"> No events to show, check back soon. </h3>
          <p>
            We have regularly scheduled events and are in the process of getting this page working.
          </p>
        </div>
      </div>
    </IBInfiniteScroll>
  </div>
</template>

================
File: pages/index.vue
================
<script setup lang="ts">
definePageMeta({
  name: 'AstroTribe',
})

const userStore = useCurrentUser()
const metricsStore = useUserMetricsStore()
const { profile } = storeToRefs(userStore)
const {
  isLoading,
  currentLevel,
  levelProgress,
  remainingDailyVotes,
  dailyProgress,
  currentStreak,
  downvoteCount,
  upvoteCount,
  todayVoteCount,
  totalVotes,
  voteAccuracy,
  achievementStats,
  recentAchievements,
} = storeToRefs(metricsStore)

// Initialize metrics
onMounted(() => {
  metricsStore.init()
})
</script>

<template>
  <div class="grid w-full min-h-screen gap-6 p-6">
    <!-- Welcome Section -->
    <div class="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-6">
      <!-- Welcome Card -->
      <div
        class="bg-gray-900/50 flex flex-col rounded-xl p-6 border border-gray-800 md:col-span-2 xl:col-span-1 xl:row-span-2"
      >
        <div class="space-y-4">
          <div class="flex items-center justify-between">
            <h1 class="text-2xl font-bold">Welcome {{ profile.given_name }} 👋</h1>
            <div
              class="flex items-center gap-2 px-3 py-1 bg-blue-500/10 rounded-full border border-blue-500/20"
            >
              <Icon
                name="game-icons:star-medal"
                class="text-blue-400"
              />
              <span class="text-blue-400 font-medium">Level {{ currentLevel }}</span>
            </div>
          </div>
          <FeatureRanking class="mt-4" />
        </div>
        <Feedback />
      </div>

      <!-- Stats Grid -->
      <MetricStatCard
        title="Total Votes"
        :value="totalVotes"
        icon="game-icons:trophy"
        class="md:col-span-1"
        color="yellow"
        :loading="isLoading"
      >
        <template #footer>
          <div class="mt-4 flex gap-4">
            <span
              class="px-3 py-1 rounded-full bg-green-500/10 border border-green-500/20 text-green-400"
            >
              ↑{{ upvoteCount }}
            </span>
            <span
              class="px-3 py-1 rounded-full bg-red-500/10 border border-red-500/20 text-red-400"
            >
              ↓{{ downvoteCount }}
            </span>
          </div>
        </template>
      </MetricStatCard>
      <MetricStatCard
        title="Today's Progress"
        :value="`${todayVoteCount}/10`"
        icon="game-icons:laurels-trophy"
        color="green"
        class="md:col-span-1"
        :loading="isLoading"
      >
        <template #footer>
          <div class="mt-4 space-y-2">
            <MetricProgressBar
              :value="todayVoteCount"
              :max="10"
              color="green"
              :loading="isLoading"
            />
            <p class="text-sm text-gray-400">
              {{ remainingDailyVotes < 0 ? 0 : remainingDailyVotes }} votes remaining today
            </p>
          </div>
        </template>
      </MetricStatCard>

      <!-- Achievements Section -->
      <div
        class="bg-gray-900/50 rounded-xl p-6 border border-gray-800 md:col-span-2 xl:col-span-1 xl:col-start-3 xl:row-start-1 xl:row-span-2"
      >
        <div class="space-y-6">
          <div class="flex items-center justify-between">
            <h3 class="text-lg font-semibold">Achievements</h3>
            <span class="text-sm text-gray-400">
              {{ achievementStats.completed }}/{{ achievementStats.total }}
            </span>
          </div>
          <div
            v-if="currentStreak > 0"
            class="flex items-center gap-2 px-4 py-2 bg-orange-500/10 rounded-lg border border-orange-500/20"
          >
            <Icon
              name="mdi:fire"
              class="text-orange-400"
            />
            <span class="text-orange-400 font-medium">{{ currentStreak }} Day Streak!</span>
          </div>

          <!-- Recent Achievements -->
          <div class="space-y-4">
            <div
              v-for="achievement in recentAchievements"
              :key="achievement.name"
              class="flex items-center gap-3 p-3 bg-gray-800/50 rounded-lg border border-gray-700"
            >
              <div class="p-2 bg-yellow-500/10 rounded-lg">
                <Icon
                  name="game-icons:medal"
                  class="text-yellow-400"
                />
              </div>
              <div>
                <h4 class="font-medium">{{ achievement.name }}</h4>
                <p class="text-sm text-gray-400">{{ achievement.category }}</p>
              </div>
            </div>
          </div>

          <NuxtLink
            to="/achievements"
            class="flex items-center justify-center gap-2 px-4 py-2 bg-gray-800 rounded-lg hover:bg-gray-700 transition-colors"
          >
            <span>View All Achievements</span>
            <Icon name="mdi:chevron-right" />
          </NuxtLink>
        </div>
      </div>
    </div>

    <!-- Bottom Stats Row -->
    <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
      <!-- <MetricLevelProgress
        :level="currentLevel"
        :progress="levelProgress"
        :loading="isLoading"
      />

      <MetricStatCard
        title="Vote Accuracy"
        :value="`${voteAccuracy}%`"
        icon="game-icons:bullseye"
        color="purple"
        :loading="isLoading"
      >
        <template #footer>
          <div class="mt-4">
            <MetricProgressBar
              :value="voteAccuracy"
              :max="100"
              color="purple"
              :loading="isLoading"
            />
          </div>
        </template>
      </MetricStatCard> -->
    </div>
  </div>
</template>

<style scoped></style>

================
File: pages/newsletter.vue
================
<!-- components/SpaceNewsDashboard.vue -->
<template>
  <div class="min-h-screen bg-gray-900 text-gray-100 p-6">
    <!-- Header -->
    <div class="mb-8">
      <div class="flex justify-between items-center mb-6">
        <div>
          <h1 class="text-2xl font-bold">Space Tech Daily</h1>
          <div class="flex items-center text-sm text-gray-400">
            <Icon
              name="mdi:calendar"
              class="w-4 h-4 mr-1"
            />
            Saturday, January 11, 2025
          </div>
        </div>
        <div class="flex items-center gap-4 text-sm">
          <div class="flex items-center gap-2">
            <Icon
              name="mdi:weather-sunny"
              class="w-4 h-4 text-yellow-500"
            />
            <span>Solar Activity: Moderate</span>
          </div>
          <div class="flex items-center gap-2">
            <Icon
              name="mdi:earth"
              class="w-4 h-4 text-blue-500"
            />
            <span>Active Missions: 18</span>
          </div>
        </div>
      </div>

      <!-- Category Bar -->
      <div class="flex justify-between items-center">
        <div class="flex gap-2">
          <PrimeButton
            v-for="cat in categories"
            :key="cat.name"
            :class="[cat.name === 'All' ? 'bg-blue-600' : 'bg-gray-800', 'text-sm']"
          >
            {{ cat.name }}
            <PrimeBadge
              :value="cat.count"
              class="ml-2 bg-gray-700"
            />
          </PrimeButton>
        </div>

        <div class="flex gap-2">
          <PrimeButton class="p-button-outlined">
            <Icon
              name="mdi:magnify"
              class="w-4 h-4"
            />
          </PrimeButton>
          <PrimeButton class="p-button-outlined">
            <Icon
              name="mdi:filter-variant"
              class="w-4 h-4"
            />
          </PrimeButton>
          <PrimeButton class="p-button-outlined">
            <Icon
              name="mdi:bookmark-outline"
              class="w-4 h-4"
            />
          </PrimeButton>
        </div>
      </div>
    </div>

    <!-- Trending Topics -->
    <PrimeCard class="mb-6 bg-gray-800 border-gray-700">
      <template #content>
        <div class="flex items-center gap-6">
          <span class="font-semibold text-sm">Trending Topics:</span>
          <div
            v-for="topic in trendingTopics"
            :key="topic.topic"
            class="flex items-center gap-2"
          >
            <span class="text-sm font-medium">{{ topic.topic }}</span>
            <PrimeBadge
              :value="topic.trend"
              class="bg-blue-900 text-blue-200"
            />
          </div>
        </div>
      </template>
    </PrimeCard>

    <!-- Main Content Grid -->
    <div class="grid grid-cols-4 gap-6">
      <!-- News Timeline -->
      <div class="col-span-3 space-y-8">
        <div
          v-for="(block, blockIdx) in timeBlocks"
          :key="blockIdx"
          class="relative"
        >
          <!-- Time Marker -->
          <div class="flex items-center gap-2 mb-3">
            <div class="h-2 w-2 rounded-full bg-blue-500"></div>
            <span class="text-sm font-medium text-gray-400">{{ block.time }}</span>
          </div>

          <!-- News Cards -->
          <div class="space-y-3">
            <PrimeCard
              v-for="(event, eventIdx) in block.events"
              :key="eventIdx"
              class="bg-gray-800 border-l-4 hover:bg-gray-750 transition-colors cursor-pointer"
              :class="event.impact === 'high' ? 'border-l-blue-500' : 'border-l-gray-700'"
            >
              <template #content>
                <div class="flex justify-between items-start gap-4">
                  <div class="flex-grow">
                    <h3 class="font-medium mb-2">{{ event.title }}</h3>
                    <p class="text-sm text-gray-400 mb-3">{{ event.summary }}</p>
                    <div class="flex items-center gap-3">
                      <PrimeBadge
                        :value="event.category"
                        class="bg-gray-700"
                      />
                      <PrimeBadge
                        :value="event.region"
                        :class="getRegionColor(event.region)"
                      />
                      <span class="text-xs text-gray-500">{{ event.source }}</span>
                    </div>
                  </div>
                  <Icon
                    name="mdi:arrow-top-right"
                    class="w-4 h-4 text-gray-600"
                  />
                </div>
              </template>
            </PrimeCard>
          </div>

          <!-- Timeline Connector -->
          <div
            v-if="blockIdx < timeBlocks.length - 1"
            class="absolute left-1 top-6 w-0.5 h-12 bg-gray-700"
          ></div>
        </div>
      </div>

      <!-- Sidebar -->
      <div class="space-y-4">
        <!-- Coming Up -->
        <PrimeCard class="bg-gray-800 border-gray-700">
          <template #content>
            <h2 class="font-semibold mb-3">Coming Up</h2>
            <div class="space-y-3">
              <div
                v-for="(event, idx) in upcomingEvents"
                :key="idx"
              >
                <div class="font-medium">{{ event.title }}</div>
                <div class="text-sm text-gray-400"> {{ event.time }} • {{ event.location }} </div>
              </div>
            </div>
          </template>
        </PrimeCard>

        <!-- At a Glance -->
        <PrimeCard class="bg-gray-800 border-gray-700">
          <template #content>
            <h2 class="font-semibold mb-3">At a Glance</h2>
            <div class="space-y-3">
              <div
                v-for="(stat, idx) in stats"
                :key="idx"
                class="flex justify-between items-center"
              >
                <span class="text-gray-400">{{ stat.label }}</span>
                <span class="font-medium">{{ stat.value }}</span>
              </div>
            </div>
          </template>
        </PrimeCard>
      </div>
    </div>
  </div>
</template>

<script setup>
const categories = [
  { name: 'All', count: 24 },
  { name: 'Research', count: 8 },
  { name: 'Launches', count: 3 },
  { name: 'Operations', count: 6 },
  { name: 'Announcements', count: 7 },
]

const trendingTopics = [
  { topic: 'JWST Discoveries', trend: '+120%' },
  { topic: 'SpaceX Raptor', trend: '+80%' },
  { topic: 'Lunar Mining', trend: '+45%' },
]

const timeBlocks = [
  {
    time: 'Last 6 hours',
    events: [
      {
        title: 'JWST Discovers Unexpected Structures in Distant Galaxy',
        category: 'Research',
        source: 'Nature',
        summary:
          'Early observations reveal complex formations previously unseen at this distance...',
        region: 'Global',
        impact: 'high',
      },
      {
        title: 'SpaceX Completes Static Fire Test',
        category: 'Operations',
        source: 'Space News',
        summary: 'Successful test of Raptor engines paves way for orbital flight...',
        region: 'NA',
        impact: 'medium',
      },
    ],
  },
  {
    time: '6-12 hours ago',
    events: [
      {
        title: 'ESA-NASA Announce Joint Mission Plans',
        category: 'Announcements',
        source: 'ESA Press',
        summary: 'New collaboration targets advanced planetary defense systems...',
        region: 'EU',
        impact: 'high',
      },
    ],
  },
]

const upcomingEvents = [
  {
    title: 'ISS Visible Pass',
    time: 'Next 6 hours',
    location: 'Northern Hemisphere',
  },
  {
    title: 'Meteor Shower Peak',
    time: 'Tomorrow',
    location: 'Global',
  },
]

const stats = [
  { label: 'Active Spacecraft', value: '242' },
  { label: 'Planned Launches', value: '5' },
  { label: 'Ongoing Missions', value: '18' },
]

const getRegionColor = (region) => {
  const colors = {
    NA: 'bg-blue-900 text-blue-200',
    EU: 'bg-yellow-900 text-yellow-200',
    AS: 'bg-red-900 text-red-200',
    Global: 'bg-green-900 text-green-200',
  }
  return colors[region] || 'bg-gray-900 text-gray-200'
}
</script>

================
File: pages/offline.vue
================
<template>
  <div class="flex flex-col items-center justify-center p-4 h-full">
    <div class="max-w-md w-full text-center space-y-6">
      <div class="flex justify-center">
        <Icon
          name="material-symbols:wifi-off"
          class="w-20 h-20"
        />
      </div>

      <h1 class="text-3xl font-bold"> No Internet Connection </h1>

      <div class="space-y-4">
        <p class="">
          The page you're trying to access requires an internet connection. Please check your
          connection and try again.
        </p>

        <Button
          class="inline-flex items-center px-4 py-2 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
          @click="reload"
        >
          Try Again
        </Button>
      </div>

      <div class="text-sm">
        <p>Some features may still be available offline</p>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
const { $isOffline } = useNuxtApp()

// Watch for online status changes
watch($isOffline, (offline) => {
  if (!offline) {
    // Optionally reload when connection is restored
    window.location.reload()
  }
})

const reload = () => {
  window.location.reload()
}
</script>

================
File: pages/onboarding.vue
================
<template>
  <div class="p-4">
    <h1 class="mb-4 text-3xl font-bold"> Complete Your Profile </h1>
    <PrimeStepper
      v-model:value="activeStep"
      linear
    >
      <PrimeStepList>
        <PrimeStep value="1"> Personal Info </PrimeStep>
        <PrimeStep value="2"> Professional Info </PrimeStep>
        <PrimeStep value="3"> Interests </PrimeStep>
      </PrimeStepList>
      <PrimeStepPanels>
        <PrimeStepPanel value="1">
          <OnboardingAccount @next="nextStep" />
        </PrimeStepPanel>
        <PrimeStepPanel value="2">
          <OnboardingProfessional
            @next="nextStep"
            @prev="prevStep"
          />
        </PrimeStepPanel>
        <PrimeStepPanel value="3">
          <OnboardingInterests
            @prev="prevStep"
            @submit="handleSubmit"
          />
        </PrimeStepPanel>
      </PrimeStepPanels>
    </PrimeStepper>
  </div>
</template>

<script setup lang="ts">
const activeStep = ref('1')
const { form } = useOnboarding()

const nextStep = () => {
  activeStep.value = String(Number(activeStep.value) + 1)
}

const prevStep = () => {
  activeStep.value = String(Number(activeStep.value) - 1)
}

const handleSubmit = () => {
  console.log('Form submitted:', form)
  // You can add your API call here
}
</script>

================
File: pages/research.vue
================
<script setup lang="ts">
const researchStore = useResearchStore()
const domainKey = 'research'

const { research } = storeToRefs(researchStore)
const haveResearch = computed(() => research.value !== null && research.value.length > 0)

// Updated to use the new contents table structure
const fetchInput = ref({
  domainKey,
  endpoint: '/api/research/select/cards',
  criteria: {
    // This should be updated in your API endpoint to use the contents table with content_type = 'research'
    dto: 'select:research:card',
  },
})

// Initialize the store with research data if not already loaded
const initializeResearch = async () => {
  if (!haveResearch.value) {
    // Option 1: Use the loadResearch method if you're updating the API endpoint
    await researchStore.loadResearch(fetchInput.value)

    // Option 2: Alternative approach - use the selectData composable directly with the new table
    /*
    const { store, refresh } = useSelectData('contents', {
      filters: {
        content_type: { eq: 'research' },
        is_active: { eq: true },
        deleted_at: { is: null }
      },
      columns: `
        id,
        content_type,
        title,
        url,
        created_at,
        hot_score,
        published_at,
        description,
        author,
        featured_image,
        source_id,
        company_id,
        details
      `,
      pagination: { page: 1, limit: 20 },
      initialFetch: true
    })

    // Use store data or update your research store
    research.value = store.items
    */
  }
}

watchEffect(() => {
  initializeResearch()
})

definePageMeta({ name: 'Research' })
</script>

<template>
  <div class="relative flex h-full w-full flex-col">
    <!-- <SummaryLevel /> -->
    <IBInfiniteScroll
      :domain-key="domainKey"
      :pagination="{ page: 1, limit: 20 }"
      @update:scroll-end="researchStore.loadResearch(fetchInput)"
    >
      <div class="mx-auto grid grid-cols-1 md:grid-cols-2 md:gap-4 xl:grid-cols-3 xl:gap-8">
        <ResearchCard
          v-for="(item, index) in research"
          :key="`research-post-${index}`"
          :research="item"
        />
      </div>
    </IBInfiniteScroll>
  </div>
</template>

================
File: pages/test.vue
================
<template>
  <div>
    <TestSelect />
  </div>
</template>

<script setup lang="ts"></script>

<style scoped></style>

================
File: plugins/-formbricks.client.ts
================
// plugins/formbricks.client.ts
import type {} from '@formbricks/js'

declare global {
  interface Window {
    formbricks: FormbricksAPI
  }
}

export default defineNuxtPlugin((nuxtApp) => {
  const { formbricksHost, formbricksEnvironment } = useRuntimeConfig().public

  if (import.meta.client) {
    // Add Formbricks script tag
    const script = document.createElement('script')
    script.src = 'https://cdn.formbricks.com/formbricks.js'
    script.async = true
    script.defer = true
    document.head.appendChild(script)

    // Initialize once script loads
    script.onload = () => {
      window.formbricks?.init({
        environmentId: formbricksEnvironment,
        apiHost: formbricksHost,
      })
      console.log('Formbricks initialized')
    }
  }

  // Register route change handler
  nuxtApp.hook('page:finish', () => {
    if (import.meta.client && window.formbricks) {
      window.formbricks.registerRouteChange()
    }
  })

  // Provide formbricks to the app
  return {
    provide: {
      formbricks: import.meta.client ? window.formbricks : undefined,
    },
  }
})

================
File: plugins/pwa.client.ts
================
export default defineNuxtPlugin(() => {
  const notification = useNotification()
  const isOffline = ref(!navigator.onLine)
  const { $pwa } = useNuxtApp()

  if (import.meta.dev && import.meta.client) {
    console.log('Development mode: Cleaning up service workers...')

    if ('serviceWorker' in navigator) {
      navigator.serviceWorker
        .getRegistrations()
        .then((registrations) => {
          registrations.forEach((registration) => {
            registration.unregister()
            console.log('Service worker unregistered:', registration.scope)
          })
        })
        .catch((error: any) => {
          console.error('Service worker cleanup failed:', error)
        })
    }
  }

  if (import.meta.client) {
    // Handle online/offline status
    window.addEventListener('online', () => {
      isOffline.value = false
      notification.success({
        summary: 'Connection Restored',
        message: 'Your internet connection has been restored',
      })
    })

    window.addEventListener('offline', () => {
      isOffline.value = true
      notification.warn({
        summary: 'Offline Mode',
        message: 'You are currently offline. Some features may be limited',
      })
    })

    // PWA functionality
    if ($pwa) {
      // Handle offline ready
      watch(
        () => $pwa.offlineReady.value,
        (ready) => {
          if (ready) {
            notification.success({
              summary: 'App Ready',
              message: 'Content has been cached for offline use',
            })
          }
        },
      )

      // Handle updates
      watch(
        () => $pwa.needRefresh.value,
        (needRefresh) => {
          if (needRefresh) {
            notification.info({
              summary: 'Update Available',
              message: 'Click here to update to the latest version',
            })
          }
        },
      )
    }
  }

  return {
    provide: {
      isOffline: readonly(isOffline),
    },
  }
})

================
File: plugins/role-overide.client.ts
================
// plugins/role-override.ts
export default defineNuxtPlugin((nuxtApp) => {
  // Initialize role override system
  if (import.meta.dev) {
    const { roleOverride } = useRoleOverride()

    // You could add development-only watches or logging here
    watch(roleOverride, (newRole) => {
      console.log(`[DEV] Role override changed to: ${newRole || 'original role'}`)
    })
  }
})

================
File: server/api/ai/ask.ts
================
import { openAI } from '~/server/utils/openai/callOpenAI'
import { serverSupabaseUser } from '#supabase/server'

export default defineEventHandler({
  onRequest: [rateLimiter],
  onBeforeResponse: [],
  handler: async (event) => {
    const log = useServerLogger('API:ASK')
    const { messages } = await readBody(event)

    if (!Array.isArray(messages) || messages.length === 0) {
      return {
        statusCode: 400,
        error: {
          message: 'messages must be a non-empty array',
        },
      }
    }

    const isValidMessage = (msg) =>
      msg &&
      typeof msg === 'object' &&
      ['system', 'user', 'assistant'].includes(msg.role) &&
      typeof msg.content === 'string'

    if (!messages.every(isValidMessage)) {
      return {
        statusCode: 400,
        error: {
          message: 'Invalid message format',
        },
      }
    }

    console.log('messages', messages)

    try {
      const user = await serverSupabaseUser(event)
      let chatCompletion

      const plan = user?.app_metadata?.plan

      if (plan === 'free') {
        console.log('getGroqChatCompletion')
        chatCompletion = await getGroqChatCompletion(messages)
      } else if (plan === 'pro' || plan === 'expert') {
        console.log('openAI.createChatCompletion')
        chatCompletion = openAI.createChatCompletion(messages)
      } else {
        log.warn('no user plan', plan)
      }

      return {
        error: null,
        statusCode: 200,
        data: chatCompletion || '',
      }
    } catch (error: any) {
      log.error('error', error)
      return {
        data: null,
        error,
        statusCode: 500,
      }
    }
  },
})

================
File: server/api/bookmarks/[id].delete.ts
================
import { serverSupabaseUser, serverSupabaseClient } from '#supabase/server'

// server/api/bookmarks/[id].delete.ts
export default defineEventHandler(async (event) => {
  const user = await serverSupabaseUser(event)
  const bookmarkId = event.context.params.id

  if (!user) {
    throw createError({
      statusCode: 401,
      message: 'Unauthorized',
    })
  }

  const supabase = await serverSupabaseClient(event)

  const { error } = await supabase
    .from('bookmarks')
    .delete()
    .eq('id', bookmarkId)
    .eq('user_id', user.id)

  if (error) {
    throw createError({
      statusCode: 500,
      message: 'Failed to delete bookmark',
    })
  }

  return { success: true }
})

================
File: server/api/bookmarks/counts.ts
================
// server/api/bookmarks/counts.ts
import { serverSupabaseServiceRole, serverSupabaseUser } from '#supabase/server'

export default defineEventHandler(async (event) => {
  console.log('fetch bookmark counts endpoint fired')
  try {
    const user = await serverSupabaseUser(event)
    if (!user) {
      throw createError({ statusCode: 401, message: 'Unauthorized' })
    }

    const supabase = serverSupabaseServiceRole(event)

    // The get_bookmark_counts_by_folder function should be updated if necessary
    // to work with the new schema, but the interface remains the same
    const { data, error } = await supabase.rpc('get_bookmark_counts_by_folder', {
      user_id_param: user.id,
    })

    if (error) throw error

    console.log('FETCHED DATA', data?.length)

    // Transform the data to include uncategorized bookmarks
    const transformedData = data.map((item: any) => ({
      folder_id: item.folder_id || 'uncategorized',
      count: parseInt(item.count),
    }))

    console.log('TRANSFORMED DATA', transformedData)

    return { data: transformedData }
  } catch (error: any) {
    console.error('Error fetching bookmark counts:', error)
    throw createError({
      statusCode: error.statusCode || 500,
      message: error.message || 'Internal server error',
    })
  }
})

================
File: server/api/bookmarks/index.ts
================
// server/api/bookmarks/index.ts
import { serverSupabaseUser, serverSupabaseClient } from '#supabase/server'

export default defineEventHandler(async (event) => {
  try {
    const { folder_id = null, include_subfolders = false } = getQuery(event)
    const user = await serverSupabaseUser(event)
    const supabase = await serverSupabaseClient(event)

    if (!user) {
      throw createError({ statusCode: 401, message: 'Unauthorized' })
    }

    // Basic query without joins to reduce potential errors
    let query = supabase
      .from('bookmarks')
      .select(
        `
        id,
        user_id,
        content_id,
        content_type,
        created_at,
        updated_at,
        folder_id,
        metadata
      `,
      )
      .eq('user_id', user.id)

    // Apply folder filters
    if (folder_id) {
      if (include_subfolders) {
        // Get folder path for subfolder filtering
        const { data: folderData } = await supabase
          .from('bookmark_folders')
          .select('path')
          .eq('id', folder_id)
          .single()

        if (folderData?.path) {
          const { data: subFolderIds } = await supabase
            .from('bookmark_folders')
            .select('id')
            .like('path', `${folderData.path}%`)

          if (subFolderIds?.length) {
            query = query.in('folder_id', [folder_id, ...subFolderIds.map((f) => f.id)])
          } else {
            query = query.eq('folder_id', folder_id)
          }
        } else {
          query = query.eq('folder_id', folder_id)
        }
      } else {
        query = query.eq('folder_id', folder_id)
      }
    }

    query = query.order('created_at', { ascending: false })

    const { data: bookmarks, error: bookmarksError } = await query
    if (bookmarksError) {
      console.error('Bookmark query error:', bookmarksError)
      throw bookmarksError
    }

    if (!bookmarks?.length) return { data: [] }

    // Get folders data separately if needed
    const folderIds = bookmarks
      .map((b) => b.folder_id)
      .filter((id) => id !== null && id !== undefined)

    let folders = []
    if (folderIds.length > 0) {
      const { data: folderData, error: folderError } = await supabase
        .from('bookmark_folders')
        .select('id, name, color, is_favorite')
        .in('id', folderIds)

      if (!folderError) {
        folders = folderData
      } else {
        console.warn('Failed to fetch folder data:', folderError)
      }
    }

    const folderMap = (folders || []).reduce((map, folder) => {
      map[folder.id] = folder
      return map
    }, {})

    // Prepare the response without trying to join with contents
    const normalizedBookmarks = bookmarks.map((bookmark) => {
      return {
        id: bookmark.id,
        user_id: bookmark.user_id,
        content_id: bookmark.content_id,
        content_type: bookmark.content_type,
        created_at: bookmark.created_at,
        updated_at: bookmark.updated_at,
        folder_id: bookmark.folder_id,
        folder: bookmark.folder_id ? folderMap[bookmark.folder_id] || null : null,
        metadata: bookmark.metadata || {},
      }
    })

    return { data: normalizedBookmarks }
  } catch (error: any) {
    console.error('Error in bookmark endpoint:', error)
    throw createError({
      statusCode: error.statusCode || 500,
      message: error.message || 'Internal server error',
    })
  }
})

================
File: server/api/bookmarks/move.patch.ts
================
import { serverSupabaseUser, serverSupabaseClient } from '#supabase/server'

export default defineEventHandler(async (event: H3Event) => {
  try {
    const user = await serverSupabaseUser(event)
    if (!user) {
      throw createError({ statusCode: 401, message: 'Unauthorized' })
    }

    const supabase = await serverSupabaseClient(event)
    const { bookmarkIds, targetFolderId } = await readBody(event)

    // Verify user owns these bookmarks
    const { data: bookmarks, error: verifyError } = await supabase
      .from('bookmarks')
      .select('id')
      .in('id', bookmarkIds)
      .eq('user_id', user.id)

    if (verifyError || !bookmarks?.length) {
      throw createError({ statusCode: 400, message: 'Invalid bookmark selection' })
    }

    // Move bookmarks to new folder
    const { error: updateError } = await supabase
      .from('bookmarks')
      .update({ folder_id: targetFolderId, updated_at: new Date().toISOString() })
      .in('id', bookmarkIds)
      .eq('user_id', user.id)

    if (updateError) throw updateError

    // Also update the folder_id in content_interactions for analytics
    const { data: interactions, error: fetchError } = await supabase
      .from('bookmarks')
      .select('content_id')
      .in('id', bookmarkIds)
      .eq('user_id', user.id)

    if (!fetchError && interactions?.length) {
      const contentIds = interactions.map((b) => b.content_id)

      // Update interaction records with the new folder_id
      await supabase
        .from('content_interactions')
        .update({
          details: supabase.rpc('jsonb_set_field', {
            current_data: supabase.raw('details'),
            field_path: 'folder_id',
            new_value: JSON.stringify(targetFolderId),
          }),
        })
        .in('content_id', contentIds)
        .eq('user_id', user.id)
        .eq('interaction_type', 'bookmark')
    }

    return { success: true }
  } catch (err) {
    console.error('Move bookmarks error:', err)
    throw createError({
      statusCode: err.statusCode || 500,
      message: err.message || 'Internal server error',
    })
  }
})

================
File: server/api/bookmarks/toggle.ts
================
import { serverSupabaseUser, serverSupabaseClient } from '#supabase/server'

export default defineEventHandler(async (event) => {
  const body = await readBody(event)
  const user = await serverSupabaseUser(event)
  const { content_id, content_type, folder_id, metadata } = body

  if (!user) {
    return createError({
      status: 401,
      message: 'Unauthorized',
    })
  }

  const supabase = await serverSupabaseClient(event)

  try {
    // Check if bookmark exists
    const { data: existing } = await supabase
      .from('bookmarks')
      .select('id')
      .eq('user_id', user.id)
      .eq('content_id', content_id)
      .eq('content_type', content_type)
      .maybeSingle()

    if (existing) {
      // Remove bookmark
      const { error: deleteError } = await supabase
        .from('bookmarks')
        .delete()
        .match({ id: existing.id })

      if (deleteError) {
        console.error('Failed to remove bookmark:', deleteError)
        throw createError({
          statusCode: 500,
          message: 'Failed to remove bookmark',
        })
      }

      // Also try to remove the bookmark interaction, but don't fail if it doesn't exist
      try {
        await supabase.from('content_interactions').delete().match({
          content_id,
          user_id: user.id,
          interaction_type: 'bookmark',
        })
      } catch (interactionError) {
        console.warn(
          'Failed to remove bookmark interaction, but bookmark was removed:',
          interactionError,
        )
      }

      return {
        bookmarked: false,
      }
    }

    // Get default folder if needed
    let targetFolderId = folder_id
    if (!targetFolderId) {
      const { data: defaultFolder } = await supabase
        .from('bookmark_folders')
        .select('id')
        .eq('user_id', user.id)
        .eq('is_default', true)
        .single()

      targetFolderId = defaultFolder?.id
    }

    // Create new bookmark
    const bookmarkData = {
      user_id: user.id,
      content_id,
      content_type,
      folder_id: targetFolderId,
      metadata: {
        ...metadata,
        bookmarked_at: new Date().toISOString(),
      },
    }

    const { data: newBookmark, error: bookError } = await supabase
      .from('bookmarks')
      .insert(bookmarkData)
      .select()
      .single()

    if (bookError) {
      console.error('Failed to create bookmark:', bookError)
      throw createError({
        statusCode: 500,
        message: 'Failed to create bookmark: ' + bookError.message,
      })
    }

    // Try to create a bookmark interaction for analytics
    // But don't fail if this step fails
    try {
      await supabase.from('content_interactions').insert({
        content_id,
        user_id: user.id,
        interaction_type: 'bookmark',
        details: {
          folder_id: targetFolderId,
        },
      })
    } catch (interactionError) {
      console.warn(
        'Failed to create bookmark interaction, but bookmark was created:',
        interactionError,
      )
    }

    return {
      bookmarked: true,
      data: newBookmark,
    }
  } catch (error: any) {
    console.error('Error in bookmark toggle:', error)
    throw createError({
      statusCode: error.statusCode || 500,
      message: error.message || 'Internal server error',
    })
  }
})

================
File: server/api/feature/[action].ts
================
import { serverSupabaseClient, serverSupabaseUser } from '#supabase/server'

export default defineEventHandler(async (event) => {
  const client = await serverSupabaseClient(event)
  const user = await serverSupabaseUser(event)
  const action = event.context.params?.action

  if (!user) {
    throw createError({
      statusCode: 401,
      message: 'Unauthorized',
    })
  }

  switch (action) {
    case 'list': {
      const { data: features, error: listError } = await client
        .from('feature_requests')
        .select('*')
        .order('priority')

      if (listError) throw createError({ statusCode: 500, message: listError.message })
      return features
    }

    case 'rank': {
      const body = await readBody(event)
      const { rankings } = body

      const { error: rankError } = await client.from('feature_votes').upsert(
        {
          user_id: user.id,
          rankings: rankings,
          updated_at: new Date().toISOString(),
        },
        {
          onConflict: 'user_id',
        },
      )

      if (rankError) throw createError({ statusCode: 500, message: rankError.message })
      return { success: true }
    }

    default:
      throw createError({
        statusCode: 400,
        message: 'Invalid action',
      })
  }
})

================
File: server/api/feedback/index.post.ts
================
import { serverSupabaseClient, serverSupabaseUser } from '#supabase/server'

export default defineEventHandler(async (event) => {
  const supabase = await serverSupabaseClient(event)
  const currentUser = await serverSupabaseUser(event)

  try {
    const body = await readBody(event)

    await supabase.from('feedbacks').insert({
      user_id: currentUser.id,
      ...body,
    })
  } catch (error: any) {
    return { message: error.message }
  }

  return { status: 200, message: 'Successfully submitted feedback' }
})

================
File: server/api/feeds/index.ts
================
import type { H3Event } from 'h3'

interface Category {
  readonly id: string
  readonly feed_id: string
  readonly category_id: string
}

export default defineEventHandler(async (event: H3Event) => {
  const { addFeed } = usePages()
  if (event.method === 'POST') {
    try {
      const client = useSupabaseClient()
      const { name, selectedCategories, selectedSourceIds } = await readBody(event)
      const { profile } = useCurrentUser()

      if (profile?.id) {
        if (!name.trim()) {
          throw createError({ statusCode: 400, message: 'Feed name is required' })
        }

        if (!selectedCategories.length && !selectedSourceIds.size) {
          throw createError({
            statusCode: 400,
            message: 'At least one category needs to be selected',
          })
        }

        // Get current folder count
        const { count } = await client
          .from('feeds')
          .select('*', { count: 'exact' })
          .eq('user_id', profile.id)

        // Validate feature limit
        await validateFeatureLimit(event, 'CUSTOM_FEEDS', count || 0)

        // Create feed
        const { data: feedData, error: feedError } = await client
          .from('feeds')
          .insert({ user_id: profile.id, name })
          .select('id')
          .single()

        if (feedError) throw feedError

        const feed_id = feedData.id

        // Insert categories
        if (selectedCategories.length) {
          const { error: categoriesError } = await client
            .from('feed_categories')
            .insert(
              selectedCategories.map((category: Category) => ({
                feed_id,
                category_id: category.id,
              })),
            )

          if (categoriesError) throw categoriesError
        }

        // Insert sources - Updated to work with new content_sources table
        if (selectedSourceIds.size) {
          const { error: sourcesError } = await client
            .from('feed_sources')
            .insert(
              Array.from(selectedSourceIds).map((sourceId) => ({
                feed_id,
                content_source_id: sourceId,
              })),
            )

          if (sourcesError) throw sourcesError
        }
        addFeed(feed_id, name.value)

        return { feed_id, name }
      }
    } catch (error: any) {
      console.error('Feeds API Error:', error)
      throw createError({
        statusCode: error.statusCode || 500,
        message: error.message || 'Internal server error',
      })
    }
  } else if (event.method === 'GET') {
    // Get feed content
    const client = useSupabaseClient()
    const { profile } = useCurrentUser()
    const { feed_id } = getQuery(event)

    if (!profile?.id) {
      throw createError({ statusCode: 401, message: 'Unauthorized' })
    }

    try {
      // First, get the feed's sources and categories
      const [{ data: sources }, { data: categories }] = await Promise.all([
        client.from('feed_sources').select('content_source_id').eq('feed_id', feed_id),
        client.from('feed_categories').select('category_id').eq('feed_id', feed_id),
      ])

      const sourceIds = sources?.map((s) => s.content_source_id) || []
      const categoryIds = categories?.map((c) => c.category_id) || []

      // Now query the unified contents table with the appropriate filters
      let query = client
        .from('contents')
        .select(
          `
          id, 
          content_type, 
          title, 
          description, 
          url, 
          published_at, 
          author, 
          featured_image, 
          hot_score,
          source_id,
          company_id,
          details
        `,
        )
        .is('deleted_at', null)
        .eq('is_active', true)
        .order('published_at', { ascending: false })
        .limit(50)

      // Add filters based on feed configuration
      if (sourceIds.length > 0) {
        query = query.in('source_id', sourceIds)
      }

      // For categories, we need to use a different approach since they might be in the details JSONB
      if (categoryIds.length > 0) {
        // This assumes category info is stored in details->category_id
        // Adjust according to your actual JSONB structure
        const categoryFilters = categoryIds
          .map((id) => `details->>'category_id' = '${id}'`)
          .join(' OR ')

        query = query.or(categoryFilters)
      }

      const { data: contents, error } = await query

      if (error) throw error

      return { data: contents }
    } catch (error: any) {
      console.error('Feed content fetch error:', error)
      throw createError({ statusCode: 500, message: 'Failed to fetch feed content' })
    }
  }
})

================
File: server/api/folders/[id].delete.ts
================
// server/api/folders/[id].delete.ts
import type { H3Event } from 'h3'
import { serverSupabaseUser, serverSupabaseClient } from '#supabase/server'

export default defineEventHandler(async (event: H3Event) => {
  try {
    const user = await serverSupabaseUser(event)
    if (!user) {
      throw createError({ statusCode: 401, message: 'Unauthorized' })
    }

    const supabase = await serverSupabaseClient(event)
    const id = getRouterParam(event, 'id')
    const body = await readBody(event)
    const { strategy, defaultFolderId } = body as {
      strategy: 'delete_all' | 'move_to_default'
      defaultFolderId?: string
    }

    // First try to update/delete bookmarks
    if (strategy === 'delete_all') {
      const { error: deleteError } = await supabase
        .from('bookmarks')
        .delete()
        .eq('folder_id', id)
        .eq('user_id', user.id)

      if (deleteError) {
        console.error('Delete bookmarks error:', deleteError)
        throw deleteError
      }
    } else {
      const { error: updateError } = await supabase
        .from('bookmarks')
        .update({ folder_id: defaultFolderId })
        .eq('folder_id', id)
        .eq('user_id', user.id)

      if (updateError) {
        console.error('Update bookmarks error:', updateError)
        throw updateError
      }
    }

    // Then delete the folder
    const { error: folderError } = await supabase
      .from('bookmark_folders')
      .delete()
      .eq('id', id)
      .eq('user_id', user.id)

    if (folderError) {
      console.error('Delete folder error:', folderError)
      throw folderError
    }

    return { success: true }
  } catch (err) {
    console.error('Folder Delete Error:', err)
    throw createError({
      statusCode: err.statusCode || 500,
      message: err.message || 'Internal server error',
    })
  }
})

================
File: server/api/folders/[id].patch.ts
================
// server/api/folders/[id].patch.ts
import type { H3Event } from 'h3'
import { serverSupabaseUser, serverSupabaseClient } from '#supabase/server'

export default defineEventHandler(async (event: H3Event) => {
  try {
    const user = await serverSupabaseUser(event)
    if (!user) {
      throw createError({ statusCode: 401, message: 'Unauthorized' })
    }

    const supabase = await serverSupabaseClient(event)
    const id = event.context.params.id
    const updates = await readBody(event)

    // Validate updates
    if (updates.name !== undefined && !updates.name.trim()) {
      throw createError({
        statusCode: 400,
        message: 'Folder name cannot be empty',
      })
    }

    const { data, error } = await supabase
      .from('bookmark_folders')
      .update(updates)
      .eq('id', id)
      .eq('user_id', user.id)
      .select()
      .single()

    if (error) throw error
    return { data }
  } catch (err) {
    console.error('Folder Update Error:', err)
    throw createError({
      statusCode: err.statusCode || 500,
      message: err.message || 'Internal server error',
    })
  }
})

================
File: server/api/folders/index.ts
================
// server/api/folders/index.ts
import type { H3Event } from 'h3'
import { serverSupabaseUser, serverSupabaseClient } from '#supabase/server'

export default defineEventHandler(async (event: H3Event) => {
  try {
    const user = await serverSupabaseUser(event)
    if (!user) {
      throw createError({ statusCode: 401, message: 'Unauthorized: No user object' })
    }

    const supabase = await serverSupabaseClient(event)

    // GET /api/folders
    if (event.method === 'GET') {
      const { data, error } = await supabase
        .from('bookmark_folders')
        .select('*')
        .eq('user_id', user.id)
        .order('position')

      if (error) throw error
      return { data }
    }

    // POST /api/folders
    if (event.method === 'POST') {
      const body = await readBody(event)

      // Validate required fields
      if (!body.name?.trim()) {
        throw createError({
          statusCode: 400,
          statusMessage: 'Folder name is required',
        })
      }

      // Get current folder count
      const { count } = await supabase
        .from('bookmark_folders')
        .select('*', { count: 'exact' })
        .eq('user_id', user.id)

      // Validate feature limit
      await validateFeatureLimit(event, 'BOOKMARK_FOLDERS', count || 0)

      // Insert new folder
      const { data, error: insertError } = await supabase
        .from('bookmark_folders')
        .insert({
          ...body,
          user_id: user.id,
          position: count || 0,
        })
        .select()
        .single()

      if (insertError) throw insertError
      return { data }
    }

    throw createError({ statusCode: 405, statusMessage: 'Method not allowed' })
  } catch (err) {
    console.error('Folder API Error:', err)
    throw createError({
      statusCode: err?.statusCode || 500,
      statusMessage: err?.message || 'Internal server error',
    })
  }
})

================
File: server/api/users/metrics/[action].ts
================
// server/api/users/metrics/[action].ts
import { serverSupabaseClient, serverSupabaseUser } from '#supabase/server'

export default defineEventHandler(async (event) => {
  const client = await serverSupabaseClient(event)
  const user = await serverSupabaseUser(event)
  const action = event.context.params?.action

  if (!user) {
    throw createError({
      statusCode: 401,
      message: 'Unauthorized',
    })
  }

  try {
    switch (action) {
      case 'get':
        return await getUserMetrics(client, user.id)

      case 'track-source-visit': {
        const { newsId, timeSpent } = await readBody(event)
        return await trackSourceVisit(client, user.id, newsId, timeSpent)
      }

      case 'get-achievements':
        return await getAchievements(client, user.id)

      case 'update-title': {
        const { title } = await readBody(event)
        return await updateTitle(client, user.id, title)
      }

      case 'get-reading-time': {
        const { newsId: id } = await readBody(event)
        return await getReadingTime(client, user.id, id)
      }

      default:
        throw createError({
          statusCode: 400,
          message: 'Invalid action',
        })
    }
  } catch (error: any) {
    console.error(`Metrics API error (${action}):`, error)
    throw createError({
      statusCode: 500,
      message: 'Failed to process metrics action',
    })
  }
})

async function getUserMetrics(client: any, userId: string) {
  // Get user metrics, they should already exist due to our DB triggers
  const { data: metrics, error } = await client
    .from('user_metrics')
    .select('*')
    .eq('user_id', userId)
    .single()

  if (error) throw error

  // Get today's activity for real-time tracking
  const today = new Date().toISOString().split('T')[0]
  const { data: todayVotes } = await client
    .from('votes')
    .select('created_at, vote_type')
    .eq('user_id', userId)
    .gte('created_at', `${today}T00:00:00`)
    .order('created_at', { ascending: false })

  const { data: todayBookmarks } = await client
    .from('bookmarks')
    .select('created_at')
    .eq('user_id', userId)
    .gte('created_at', `${today}T00:00:00`)

  return {
    ...metrics,
    today_activity: {
      votes: todayVotes || [],
      bookmarks: todayBookmarks || [],
    },
  }
}

async function trackSourceVisit(client: any, userId: string, newsId: string, timeSpent: number) {
  // First record the visit
  const { error: visitError } = await client.from('content_source_visits').insert({
    user_id: userId,
    content_id: newsId,
  })

  if (visitError) throw visitError

  // Update reading time if provided
  if (timeSpent) {
    const { error: timeError } = await client
      .from('user_metrics')
      .update({
        total_reading_time: timeSpent,
      })
      .eq('user_id', userId)

    if (timeError) throw timeError
  }

  return await getUserMetrics(client, userId)
}

async function getAchievements(client: any, userId: string) {
  const { data: metrics, error } = await client
    .from('user_metrics')
    .select('achievements')
    .eq('user_id', userId)
    .single()

  if (error) throw error

  // Get completed achievements count
  const completedCount = countCompletedAchievements(metrics.achievements)

  return {
    achievements: metrics.achievements,
    stats: {
      completed: completedCount,
      total: getTotalAchievements(metrics.achievements),
    },
  }
}

async function updateTitle(client: any, userId: string, newTitle: string) {
  const { data: metrics, error } = await client
    .from('user_metrics')
    .select('titles')
    .eq('user_id', userId)
    .single()

  if (error) throw error

  // Verify title is unlocked
  if (!metrics.titles.unlocked_titles.includes(newTitle)) {
    throw createError({
      statusCode: 400,
      message: 'Title not unlocked',
    })
  }

  const { data: updatedMetrics, error: updateError } = await client
    .from('user_metrics')
    .update({
      titles: {
        ...metrics.titles,
        current_title: newTitle,
      },
    })
    .eq('user_id', userId)
    .select()
    .single()

  if (updateError) throw updateError
  return updatedMetrics
}

async function getReadingTime(client: any, userId: string, newsId: string) {
  const { data, error } = await client
    .from('source_visits')
    .select('created_at')
    .eq('user_id', userId)
    .eq('content_id', newsId)
    .order('created_at', { ascending: false })
    .limit(1)

  if (error) throw error

  return {
    lastVisit: data?.[0]?.created_at || null,
  }
}

// Utility functions
function updateFavoriteSources(currentSources: string[], newSource: string) {
  const sourceList = [...(currentSources || [])]
  if (!sourceList.includes(newSource)) {
    sourceList.push(newSource)
  }
  return sourceList.slice(-5) // Keep only last 5 sources
}

function countCompletedAchievements(achievements: any) {
  let count = 0
  for (const category in achievements) {
    for (const achievement in achievements[category]) {
      if (achievements[category][achievement] === true) {
        count++
      }
    }
  }
  return count
}

function getTotalAchievements(achievements: any) {
  let count = 0
  for (const category in achievements) {
    count += Object.keys(achievements[category]).length
  }
  return count
}

================
File: server/api/users/metrics.ts
================
// server/api/users/metrics.ts
import { serverSupabaseClient, serverSupabaseUser } from '#supabase/server'

export default defineEventHandler(async (event) => {
  const client = await serverSupabaseClient(event)
  const user = await serverSupabaseUser(event)

  if (!user) {
    throw createError({ statusCode: 401, message: 'Unauthorized' })
  }

  try {
    // Get all user votes from content_interactions (votes)
    const { data: votes, error: votesError } = await client
      .from('content_interactions')
      .select(
        `
        id, 
        content_id, 
        created_at, 
        details
      `,
      )
      .eq('user_id', user.id)
      .eq('interaction_type', 'vote')
      .order('created_at', { ascending: false })

    if (votesError) throw votesError

    // If we have votes, get the corresponding content items for score/accuracy calculation
    if (votes && votes.length > 0) {
      const contentIds = votes.map((vote) => vote.content_id)

      // Get content items for accuracy calculation
      const { data: contentItems, error: contentError } = await client
        .from('contents')
        .select('id, hot_score')
        .in('id', contentIds)

      if (contentError) throw contentError

      // Create a lookup map for content scores
      const contentScores =
        contentItems?.reduce(
          (acc, content) => {
            acc[content.id] = content.hot_score
            return acc
          },
          {} as Record<string, number>,
        ) || {}

      // Combine votes with content scores
      const votesWithScores = votes.map((vote) => ({
        id: vote.id,
        content_id: vote.content_id,
        created_at: vote.created_at,
        vote_type: vote.details?.vote_type || 0, // Extract from JSONB
        news_score: contentScores[vote.content_id] || 0,
      }))

      return {
        votes: votesWithScores,
        streakData: votes, // For streak calculation
        // Group votes by date for easier processing
        votesByDate: votes.reduce(
          (acc, vote) => {
            const date = new Date(vote.created_at).toISOString().split('T')[0]
            if (!acc[date]) acc[date] = []
            acc[date].push(vote)
            return acc
          },
          {} as Record<string, any[]>,
        ),
      }
    }

    return { votes: [], streakData: [], votesByDate: {} }
  } catch (error: any) {
    console.error('Get user metrics error:', error)
    throw createError({ statusCode: 500, message: 'Failed to get user metrics' })
  }
})

================
File: server/api/users/update.post.ts
================
import { serverSupabaseClient } from '#supabase/server'

export default defineEventHandler(async (event) => {
  try {
    const body = await readBody(event)

    const supabase = await serverSupabaseClient(event)

    const { data } = await supabase.auth.getUser()
    const { user } = data

    if (user && user.email) {
      const response = await supabase.from('user_profiles').update(body).eq('id', user.id)

      if (response.error) {
        return {
          error: response.error,
          data: [],
          status: 500,
          message: 'Error Updating User',
        }
      } else {
        return {
          error: null,
          data: [],
          status: 200,
          message: 'User Updated',
        }
      }
    }

    return {
      error: null,
      data: [],
      status: 500,
      message: 'Something went wrong',
    }
  } catch (error: any) {
    return {
      error,
      data: [],
      status: 500,
      message: 'Error',
    }
  }
})

================
File: server/api/votes/[contentType]/[id].get.ts
================
import { serverSupabaseClient, serverSupabaseUser } from '#supabase/server'

export default defineEventHandler(async (event) => {
  const client = await serverSupabaseClient(event)
  const user = await serverSupabaseUser(event)

  if (!user) {
    throw createError({ statusCode: 401, message: 'Unauthorized' })
  }

  const { contentType, id } = event.context.params

  // Validate content type is handled by the system
  const { data: validContentType, error: typeError } = await client
    .from('content_types')
    .select('type_name')
    .eq('type_name', contentType)
    .single()

  if (typeError || !validContentType) {
    throw createError({ statusCode: 400, message: 'Invalid content type' })
  }

  try {
    // Query the content_interactions table for votes by this user on this content
    const { data, error } = await client
      .from('content_interactions')
      .select('details')
      .match({ content_id: id, user_id: user.id, interaction_type: 'vote' })
      .single()

    if (error && error.code !== 'PGRST116') throw error

    // Extract vote_type from details JSONB if it exists
    const voteType = data?.details?.vote_type || null

    return { voteType }
  } catch (error: any) {
    console.error('Get vote error:', error)
    throw createError({ statusCode: 500, message: 'Failed to get vote status' })
  }
})

================
File: server/api/votes/[contentType]/[id].post.ts
================
import { serverSupabaseClient, serverSupabaseUser } from '#supabase/server'

export default defineEventHandler(async (event) => {
  const client = await serverSupabaseClient(event)
  const user = await serverSupabaseUser(event)

  if (!user) {
    throw createError({ statusCode: 401, message: 'Unauthorized' })
  }

  const { contentType, id } = getRouterParams(event)
  const { voteType } = await readBody(event)

  // Validate content type exists
  const { data: validContentType, error: typeError } = await client
    .from('content_types')
    .select('type_name')
    .eq('type_name', contentType)
    .single()

  if (typeError || !validContentType) {
    throw createError({ statusCode: 400, message: 'Invalid content type' })
  }

  // Validate vote type
  if (![1, -1].includes(voteType)) {
    throw createError({ statusCode: 400, message: 'Invalid vote type' })
  }

  try {
    // First, check if content exists
    const { data: contentExists, error: contentError } = await client
      .from('contents')
      .select('id')
      .eq('id', id)
      .single()

    if (contentError || !contentExists) {
      throw createError({ statusCode: 404, message: 'Content not found' })
    }

    // Check if user already voted
    const { data: existingVote, error: voteError } = await client
      .from('content_interactions')
      .select('id, details')
      .match({ content_id: id, user_id: user.id, interaction_type: 'vote' })
      .single()

    if (voteError && voteError.code !== 'PGRST116') throw voteError

    const existingVoteType = existingVote?.details?.vote_type || null

    // Handle vote removal if same vote type is sent
    if (existingVoteType === voteType) {
      // Remove the vote
      const { error: deleteError } = await client
        .from('content_interactions')
        .delete()
        .eq('id', existingVote.id)

      if (deleteError) throw deleteError

      // Update content hot_score (decrease by voteType)
      await client.rpc('update_content_score', { content_id: id, score_change: -voteType })

      return { success: true, action: 'removed' }
    }

    // Calculate score change
    let scoreChange = voteType
    if (existingVoteType) {
      // If changing vote type (e.g., from +1 to -1), we need to account for both
      scoreChange = voteType - existingVoteType
    }

    // Insert or update the vote
    if (existingVote) {
      // Update existing vote
      const { error: updateError } = await client
        .from('content_interactions')
        .update({ details: { ...existingVote.details, vote_type: voteType } })
        .eq('id', existingVote.id)

      if (updateError) throw updateError
    } else {
      // Insert new vote
      const { error: insertError } = await client
        .from('content_interactions')
        .insert({
          content_id: id,
          user_id: user.id,
          interaction_type: 'vote',
          details: { vote_type: voteType },
        })

      if (insertError) throw insertError
    }

    // Update content hot_score
    await client.rpc('update_content_score', { content_id: id, score_change: scoreChange })

    return { success: true, action: 'voted' }
  } catch (error: any) {
    console.error('Vote error:', error)
    throw createError({ statusCode: 500, message: 'Failed to process vote' })
  }
})

// You will need to create this function in your database:
/*
CREATE OR REPLACE FUNCTION update_content_score(
  content_id UUID,
  score_change INTEGER
) RETURNS VOID AS $$
BEGIN
  UPDATE contents
  SET hot_score = hot_score + score_change
  WHERE id = content_id;
END;
$$ LANGUAGE plpgsql;
*/

================
File: server/api/votes/user/[voteType].get.ts
================
import { serverSupabaseClient, serverSupabaseUser } from '#supabase/server'

export default defineEventHandler(async (event) => {
  const client = await serverSupabaseClient(event)
  const user = await serverSupabaseUser(event)

  if (!user) {
    throw createError({ statusCode: 401, message: 'Unauthorized' })
  }

  const voteType = parseInt(event.context.params.voteType) // 1 for upvotes, -1 for downvotes

  if (![1, -1].includes(voteType)) {
    throw createError({ statusCode: 400, message: 'Invalid vote type' })
  }

  try {
    // Get content IDs from interactions with the specified vote type
    const { data: interactionData, error: interactionError } = await client
      .from('content_interactions')
      .select('content_id')
      .eq('interaction_type', 'vote')
      .eq('user_id', user.id)
      .contains('details', { vote_type: voteType })

    if (interactionError) throw interactionError

    const contentIds = interactionData.map((item) => item.content_id)

    if (contentIds.length === 0) {
      return []
    }

    // Query the contents table for items with the specified content IDs
    // This assumes we're primarily interested in content with type 'news'
    const { data: contentsData, error: contentsError } = await client
      .from('contents')
      .select(
        `
        id, 
        content_type,
        title, 
        url, 
        created_at, 
        hot_score,
        published_at, 
        description, 
        author, 
        featured_image, 
        source_id,
        company_id,
        details
      `,
      )
      .in('id', contentIds)
      .eq('content_type', 'news')
      .order('published_at', { ascending: false })

    if (contentsError) throw contentsError

    return contentsData || []
  } catch (error: any) {
    console.error('Get voted news error:', error)
    throw createError({ statusCode: 500, message: 'Failed to get voted news' })
  }
})

================
File: server/api/votes/user.get.ts
================
import { serverSupabaseClient, serverSupabaseUser } from '#supabase/server'

export default defineEventHandler(async (event) => {
  const client = await serverSupabaseClient(event)
  const user = await serverSupabaseUser(event)

  if (!user) {
    throw createError({ statusCode: 401, message: 'Unauthorized' })
  }

  try {
    // Updated to query content_interactions table for vote type interactions
    const { data, error } = await client
      .from('content_interactions')
      .select('content_id, details')
      .eq('interaction_type', 'vote')
      .eq('user_id', user.id)

    if (error) throw error

    // Transform into a more efficient lookup object
    // Extract vote_type from details JSONB
    const voteLookup = data.reduce(
      (acc, interaction) => {
        const voteType = interaction.details?.vote_type
        if (voteType !== undefined) {
          acc[interaction.content_id] = voteType
        }
        return acc
      },
      {} as Record<string, number>,
    )

    return { votes: voteLookup }
  } catch (error: any) {
    console.error('Get votes error:', error)
    throw createError({ statusCode: 500, message: 'Failed to get votes' })
  }
})

================
File: server/api/webhook/database.ts
================
export default defineEventHandler(async (event) => {
  const data = await readBody(event)

  console.log('SUPABASE DB WEBHOOK EVENT', data)
})

================
File: server/api/upload.ts
================
import crypto from 'crypto'
import { defineEventHandler, createError } from 'h3'
import { PDFDocument } from 'pdf-lib'
import lame from 'node-lame'
import ffmpeg from 'fluent-ffmpeg'
import { serverSupabaseClient } from '#supabase/server'

// Base optimizer interface
interface FileOptimizer {
  optimize(
    buffer: Buffer,
    options: any,
  ): Promise<{
    data: Buffer
    extension: string
    mimeType: string
  }>
}

// Image optimizer using Sharp
// class ImageOptimizer implements FileOptimizer {
//   async optimize(buffer: Buffer, options: any) {
//     const { maxWidth = 1920, maxHeight = 1080, quality = 80 } = options
//     const optimized = await sharp(buffer)
//       .resize(maxWidth, maxHeight, { fit: 'inside', withoutEnlargement: true })
//       .webp({ quality })
//       .toBuffer()
//     return { data: optimized, extension: 'webp', mimeType: 'image/webp' }
//   }
// }

// PDF optimizer using pdf-lib
class PDFOptimizer implements FileOptimizer {
  async optimize(buffer: Buffer, options: any) {
    const pdfDoc = await PDFDocument.load(buffer)
    // Implement PDF optimization logic here
    const optimized = await pdfDoc.save({ useObjectStreams: false })
    return { data: Buffer.from(optimized), extension: 'pdf', mimeType: 'application/pdf' }
  }
}

class VideoOptimizer implements FileOptimizer {
  async optimize(buffer: Buffer, options: any) {
    const {
      maxWidth = 1920,
      maxHeight = 1080,
      videoBitrate = '1000k',
      audioBitrate = '128k',
    } = options

    return new Promise((resolve, reject) => {
      ffmpeg()
        .input(buffer)
        .videoFilters(
          `scale='min(${maxWidth},iw)':min'(${maxHeight},ih)':force_original_aspect_ratio=decrease`,
        )
        .videoBitrate(videoBitrate)
        .audioBitrate(audioBitrate)
        .toFormat('mp4')
        .on('end', (stdout, stderr) => {
          resolve({ data: stdout, extension: 'mp4', mimeType: 'video/mp4' })
        })
        .on('error', reject)
        .pipe()
    })
  }
}

class AudioOptimizer implements FileOptimizer {
  async optimize(buffer: Buffer, options: any) {
    const { bitrate = 128 } = options

    const encoder = new lame.Lame({
      output: 'buffer',
      bitrate: bitrate,
    }).setBuffer(buffer)

    const encodedBuffer = await encoder.encode()
    return { data: encodedBuffer, extension: 'mp3', mimeType: 'audio/mpeg' }
  }
}

// Optimizer factory
class OptimizerFactory {
  private optimizers: Map<string, FileOptimizer> = new Map()

  register(mimeType: string, optimizer: FileOptimizer) {
    this.optimizers.set(mimeType, optimizer)
  }

  getOptimizer(mimeType: string): FileOptimizer | undefined {
    return this.optimizers.get(mimeType)
  }
}

// Create and configure the optimizer factory
const optimizerFactory = new OptimizerFactory()
// optimizerFactory.register('image', new ImageOptimizer())
optimizerFactory.register('application/pdf', new PDFOptimizer())
optimizerFactory.register('video', new VideoOptimizer())
optimizerFactory.register('audio', new AudioOptimizer())

export default defineEventHandler(async (event) => {
  console.log('File optimization and upload eventHandler')
  const form = await readMultipartFormData(event)
  if (!form?.length) {
    throw createError({ statusCode: 400, statusMessage: 'No form data provided' })
  }

  const userId = form.find((item) => item.name === 'userId')?.data.toString()
  const fileType = form.find((item) => item.name === 'fileType')?.data.toString()
  const bucket = form.find((item) => item.name === 'bucket')?.data.toString()
  const path = form.find((item) => item.name === 'path')?.data.toString()
  const optimizationOptions = JSON.parse(
    form.find((item) => item.name === 'optimizationOptions')?.data.toString() || '{}',
  )

  const file = form.find((item) => item.name === 'file')
  if (!file) {
    throw createError({ statusCode: 400, statusMessage: 'No file provided' })
  }

  if (!userId || !fileType || !bucket || !path) {
    throw createError({ statusCode: 400, statusMessage: 'Missing required parameters' })
  }

  const fileName = `${fileType}-${crypto.randomUUID()}`
  const mimeType = file.type || 'application/octet-stream'

  console.log('Processing file:', userId, fileType, fileName, mimeType)

  try {
    let optimizedFile: Buffer
    let finalExtension: string
    let finalMimeType: string

    const optimizerKey = mimeType.split('/')[0]
    const optimizer =
      optimizerFactory.getOptimizer(optimizerKey) || optimizerFactory.getOptimizer(mimeType)

    if (optimizer) {
      const result = await optimizer.optimize(file.data, optimizationOptions)
      optimizedFile = result.data
      finalExtension = result.extension
      finalMimeType = result.mimeType
    } else {
      console.log('No optimizer found for this file type, uploading as-is')
      optimizedFile = file.data
      finalExtension = mimeType.split('/')[1]
      finalMimeType = mimeType
    }

    const client = await serverSupabaseClient(event)
    const { error } = await client.storage
      .from(bucket)
      .upload(`${path}/${fileName}.${finalExtension}`, optimizedFile, {
        contentType: finalMimeType,
        cacheControl: '3600',
        upsert: true,
      })

    if (error) {
      throw createError({ statusCode: 500, statusMessage: error.message })
    }

    // If this is a profile-related upload, update the user_profiles table
    if (bucket === 'user-profiles' && ['avatar', 'cover-photo'].includes(fileType)) {
      const { error: updateError, data } = await client
        .from('user_profiles')
        .update({ [fileType]: `${fileName}.${finalExtension}` })
        .eq('id', userId)
        .select()

      if (updateError) {
        console.error('Error updating user profile:', updateError)
      } else {
        console.log('User profile updated:', data)
      }
    }

    return {
      statusCode: 200,
      body: JSON.stringify({
        message: 'File successfully uploaded and optimized',
        fileName: `${fileName}.${finalExtension}`,
      }),
    }
  } catch (error: any) {
    console.error('Error processing file:', error)
    throw createError({ statusCode: 500, statusMessage: error.message })
  }
})

================
File: server/middleware/feature-limit.ts
================
import { handleFeatureLimitError } from '../utils/errors'
import { validateFeatureLimit } from '../utils/featureLimits'
import { serverSupabaseUser, serverSupabaseClient } from '#supabase/server'

export default defineEventHandler(async (event) => {
  // Only check POST requests
  if (event.method !== 'POST') return

  // Get the path to determine which feature to check
  const path = getRequestPath(event)

  // Map endpoints to features
  const featureMap: Record<string, string> = {
    '/api/bookmarks': 'BOOKMARKS',
    '/api/folders': 'BOOKMARK_FOLDERS',
    '/api/feeds': 'CUSTOM_FEEDS',
  }

  const feature = featureMap[path]
  if (!feature) return // Not a feature-limited endpoint

  try {
    const user = await serverSupabaseUser(event)

    if (!user) {
      throw createError({
        statusCode: 401,
        message: 'Unauthorized',
      })
    }

    const supabase = await serverSupabaseClient(event)

    // Get the table name from the path
    let table = path.split('/')[2] // 'bookmarks' or 'folders'

    if (table === 'folders') {
      table = 'bookmark_folders'
    }

    // Check current count
    const { count } = await supabase
      .from(table)
      .select('*', { count: 'exact' })
      .eq('user_id', user.id)

    await validateFeatureLimit(event, feature, count ?? 0)
  } catch (error: any) {
    handleFeatureLimitError(error)
  }
})

================
File: server/utils/openai/callOpenAI.ts
================
import openAiClient from './openaiClient'

type CallOpenAIConfig = {
  temperature?: number // Controls randomness: lower is more deterministic.
  max_tokens?: number // Maximum number of tokens to generate.
  top_p?: number // Nucleus sampling: higher allows more diversity.
}

// Asynchronous function to call the OpenAI API with specified parameters.

interface OpenAIInput {
  prompt: string
  systemMessage: string
  config?: CallOpenAIConfig
}

const createChatCompletion = async ({ prompt, systemMessage, config }: OpenAIInput) => {
  try {
    // Make an API call to OpenAI's chat completion endpoint.
    const response = await openAiClient.chat.completions.create({
      model: 'gpt-3.5-turbo', // Specifies the model to use.
      messages: [
        // An array of messages that precedes the function call.
        { role: 'system', content: systemMessage },
        { role: 'user', content: prompt },
      ],
      temperature: config?.temperature || 0.5,
      max_tokens: config?.max_tokens || 600,
      top_p: config?.top_p || 0.7,
    })

    return response
  } catch (error: any) {
    console.error('Error calling OpenAI API', error)
    throw createError({ message: error.message || 'Failed to call OpenAI API' })
  }
}

export const openAI = {
  createChatCompletion,
}

================
File: server/utils/openai/openaiClient.ts
================
import OpenAI from 'openai/index.mjs'

const openaiClient = new OpenAI({
  organization: process.env.OPENAI_ORG_ID,
  project: process.env.OPENAI_PROJECT_ID,
})

export default openaiClient

================
File: server/utils/storage/storageSupabase.ts
================
type FileType = 'venue-logo' | 'venue-featured-image' | 'venue-images' | 'user-avatar'

const defaultFileOptions: Record<FileType, string> = {
  'venue-logo': 'logo.jpg',
  'venue-featured-image': 'featured-image.jpg',
  'venue-images': 'images/',
  'user-avatar': 'avatar.jpg',
}

type BucketKey = 'profile-public' | 'posts' | 'venues'

const selectBucket: Record<FileType, BucketKey> = {
  'venue-logo': 'venues',
  'venue-images': 'venues',
  'venue-featured-image': 'venues',
  'user-avatar': 'profile-public',
}

interface UrlConstructorOptions {
  baseURL: string
  bucket: BucketKey
  file: string | null
  folderPath: string
  fileType: FileType
  isPrivate?: boolean
  transform?: {
    width?: number
    height?: number
    fit?: 'contain' | 'cover' | 'fill'
    quality?: number
  } | null
}

const stringIsNull = (value: any): boolean =>
  value === null || value === undefined || value === '' || value.length === 0

export const constructUrl = (options: UrlConstructorOptions) => {
  const {
    baseURL,
    bucket,
    file,
    folderPath,
    fileType,
    isPrivate = false,
    transform = null,
  } = options

  if (stringIsNull(file)) {
    console.log('No file provided, using default file for', fileType)
    return `images/defaults/${defaultFileOptions[fileType]}`
  }

  if (file && file.startsWith('http')) {
    return file
  }

  const filePath = `${folderPath}/${file}`
  const accessType = isPrivate ? 'private' : 'public'
  const path = transform
    ? `/render/image/${accessType}/${bucket}/${filePath}`
    : `/storage/v1/object/${accessType}/${bucket}/${filePath}`
  const url = new URL(path, baseURL)

  if (transform) {
    Object.entries(transform).forEach(([key, value]) => {
      if (value !== undefined) {
        url.searchParams.append(key, value.toString())
      }
    })
  }

  return url.href
}

export interface GetImageUrlOptions
  extends Omit<UrlConstructorOptions, 'baseURL' | 'bucket' | 'isPrivate' | 'folderPath'> {
  data: any
}

function getFileProperty(fileType: FileType, data: any) {
  switch (fileType) {
    case 'user-avatar':
      return {
        file: data.avatar,
        fileCategory: 'avatar',
      }
    default:
      throw createError({ message: 'Invalid fileType in getFileProperty' })
  }
}

function formatImageInput(fileType: FileType, data: any) {
  const { file, fileCategory } = getFileProperty(fileType, data)
  return {
    bucket: selectBucket[fileType],
    folderPath: `${data.id}/${fileCategory}`,
    isPrivate: false,
    file,
  }
}

export const getImageURL = ({ data, fileType, transform }: GetImageUrlOptions): string => {
  const baseURL = useRuntimeConfig().public.supabaseURL
  const { bucket, folderPath, isPrivate, file } = formatImageInput(fileType, data)
  if (!baseURL) {
    throw createError({
      message: 'baseURL not defined in getImageURL',
    })
  }

  if (!fileType) {
    throw createError({ message: 'fileType is required in constructUrl' })
  }

  return constructUrl({
    baseURL,
    bucket,
    file,
    fileType,
    folderPath,
    isPrivate,
    transform,
  })
}

export interface GetStorageImagesOptions extends Omit<UrlConstructorOptions, 'baseURL' | 'file'> {}

// export async function getStorageImages(options: GetStorageImagesOptions): Promise<string[]> {
//   const { bucket, fileType, folderPath, isPrivate, transform } = options
//   const baseURL = useRuntimeConfig().public.supabaseURL
//   if (!bucket || !folderPath) {
//     console.error('Bucket and folder are required parameters')
//     return []
//   }

//   const images: string[] = []

//   const { data, error } = await client.storage.from(bucket).list(folderPath)

//   if (error) {
//     console.error(`Error fetching images from ${bucket}:`, error)
//     return []
//   }

//   if (!data || data.length === 0) {
//     console.info(`No data returned from Supabase for bucket ${bucket}`)

//     // use constructUrl to create a default image URL
//     const defaultUrlOptions: UrlConstructorOptions = {
//       baseURL,
//       bucket,
//       file: null,
//       folderPath: '',
//       fileType,
//       isPrivate
//     }
//     return [constructUrl(defaultUrlOptions)]
//   }

//   // If you want to store full URLs
//   await data.forEach((file: FileObject) => {
//     if (!file.name.startsWith('.')) {
//       // use constructUrl to create image URLs
//       const urlOptions: UrlConstructorOptions = {
//         baseURL,
//         bucket,
//         file: file.name,
//         folderPath,
//         fileType,
//         isPrivate,
//         transform
//       }
//       images.push(constructUrl(urlOptions))
//     }
//   })

//   return images
// }

================
File: server/utils/agents.ts
================
export const agents = [
  {
    id: 1,
    name: 'Research Assistant',
    features: ['Find Papers', 'Bullet two'],
    systemMessage: 'This is an example base prompt',
  },
  {
    id: 2,
    name: 'Summarizer',
    features: ['Summarize all content consicely', 'Bullet two'],
    systemMessage: 'This is an example base prompt',
  },
]

================
File: server/utils/errors.ts
================
export const handleFeatureLimitError = (error: any) => {
  // Feature limit errors
  if (error.statusCode === 403) {
    throw createError({
      statusCode: 403,
      message: error.message || 'Feature limit reached',
      data: {
        code: 'FEATURE_LIMIT_REACHED',
      },
    })
  }

  // Auth errors
  if (error.statusCode === 401) {
    throw createError({
      statusCode: 401,
      message: 'Authentication required',
      data: {
        code: 'AUTH_REQUIRED',
      },
    })
  }

  // Validation errors
  if (error.statusCode === 400) {
    throw createError({
      statusCode: 400,
      message: error.message || 'Invalid request',
      data: {
        code: 'VALIDATION_ERROR',
      },
    })
  }

  // Default error
  throw createError({
    statusCode: error.statusCode || 500,
    message: error.message || 'An unexpected error occurred',
    data: {
      code: 'INTERNAL_SERVER_ERROR',
    },
  })
}

================
File: server/utils/featureLimits.ts
================
import { FEATURES } from '#shared/constants'

enum PlanType {
  FREE = 'free',
  PRO = 'pro',
}

export const validateFeatureLimit = async (
  event: H3Event,
  feature: string,
  currentCount: number,
) => {
  // For now, assume free plan

  const currentUser = useCurrentUser()
  const { profile } = storeToRefs(currentUser)

  const userPlan = ref<PlanType>(profile.value.user_plan == 'free' ? PlanType.FREE : PlanType.PRO)

  const limit = FEATURES[feature].limit[userPlan]

  if (limit !== -1 && currentCount >= limit) {
    throw createError({
      statusCode: 403,
      message: `You have reached the ${FEATURES[feature].name.toLowerCase()} limit for your plan.`,
    })
  }
}

================
File: server/utils/formatter.ts
================
import { z } from 'zod'

// use .default("") to set defaults, I think this makes more sense than setting defaults in the database
// can add a .catch(catchValue) value to set a value if the parsing fails

const uuid = z.string().uuid()
const string = z.string()
const stringNullish = z.string().nullish()
const stringNull = z.string().nullable()
const stringOptional = z.string().optional()

export const datetimeOffset = (
  errorMsg: string = 'Invalid datetime string! Must be UTC.',
  offset?: boolean,
) => ({
  optional: z
    .string()
    .datetime({ message: errorMsg, offset: offset ?? true })
    .optional(),
  nullish: z
    .string()
    .datetime({ message: errorMsg, offset: offset ?? true })
    .nullish(),
})

export const formatAvatarUrl = (user: any) => {
  return getImageURL({
    fileType: 'user-avatar',
    data: user,
  })
}

export type UserDTOKey = 'select:user:card' | 'select:user:profile' | 'select:user:settings'

export function roleIconMapping(role: AppRoleEnum): string {
  switch (role) {
    case 'admin':
      return 'material-symbols:shield-lock' // ADMIN
    case 'moderator':
      return 'material-symbols:manage-accounts' // MODERATOR
    case 'mentor':
      return 'mdi:account-school' // MENTOR
    case 'astroguide':
      return 'mdi:telescope' // ASTROGUIDE
    case 'user':
      return 'material-symbols:account-circle' // USER
    default:
      return 'material-symbols:account-circle' // DEFAULT
  }
}

export const formatDob = (date: string) => new Date(date).toISOString()

// todo:easy:1 add moderator to role table in supabase

// logic:med:med:4 - create a set of rules for formatting data to and from the database, add to DTOs
export const rules = {
  toDB: {
    uuid,
    string,
    stringNullish,
    stringNull,
    stringOptional,
    datetimeOffset,
  },
  toClient: {
    uuid: (userData: any) => uuid.parse(userData),
    string: (userData: any) => string.parse(userData),
    stringNullish: (userData: any) => stringNullish.parse(userData),
    stringNull: (userData: any) => stringNull.parse(userData),
    stringOptional: (userData: any) => stringOptional.parse(userData),
  },
}

================
File: server/utils/generateServerToken.ts
================
import jwt from 'jsonwebtoken'
import { useRuntimeConfig } from '#imports'

export function generateServerToken() {
  const config = useRuntimeConfig()
  return jwt.sign({ sender: 'AstronEra' }, config.scraperKey, {
    algorithm: 'HS256',
    expiresIn: '1h',
  })
}

================
File: server/utils/groqClient.ts
================
import { Groq } from 'groq-sdk/index.mjs'

const groq = new Groq({
  apiKey: process.env.GROQ_API_KEY,
})

interface AgentInput {
  message: string
  systemPrompt: string
}

interface Message {
  role: 'user' | 'assistant'
  content: string
}

export async function getGroqChatCompletion(messages: Message[]) {
  return await groq.chat.completions.create({
    messages: messages,
    model: 'llama3-70b-8192',
    // Controls randomness: lowering results in less random completions.
    // As the temperature approaches zero, the model will become
    // deterministic and repetitive.
    temperature: 0.3,

    // The maximum number of tokens to generate. Requests can use up to
    // 2048 tokens shared between prompt and completion.
    max_tokens: 1500,
    // Controls diversity via nucleus sampling: 0.5 means half of all
    // likelihood-weighted options are considered.
    top_p: 0.6,

    // A stop sequence is a predefined or user-specified text string that
    // signals an AI to stop generating content, ensuring its responses
    // remain focused and concise. Examples include punctuation marks and
    // markers like "[end]".
    // stop: 'None',

    // If set, partial message deltas will be sent.
    // streaming is not supported in JSON mode
    stream: false,
    // Enable JSON mode by setting the response format
    // response_format: { type: 'json_object' }
  })
}

================
File: server/utils/notificationManager.ts
================
// src/utils/notificationService.ts

import axios from 'axios'

interface NotificationOptions {
  message: string
  severity: 'low' | 'medium' | 'high' | 'critical'
  context?: Record<string, any>
}

class NotificationService {
  private whatsappApiURL: string
  private whatsappApiToken: string

  constructor() {
    const config = useRuntimeConfig().public
    this.whatsappApiURL = config.whatsappURL
    this.whatsappApiToken = config.whatsappToken
  }

  async sendNotification(options: NotificationOptions): Promise<void> {
    const { message, severity, context } = options
    const log = useLogger('app')

    try {
      const formattedMessage = this.formatMessage(message, severity, context)
      await this.sendToWhatsApp(formattedMessage)
      // log.info('Notification sent successfully', { severity, context })
    } catch (error) {
      // log.error('Failed to send notification', { error, severity, context })
    }
  }

  private formatMessage(message: string, severity: string, context?: Record<string, any>): string {
    let formattedMessage = `[${severity.toUpperCase()}] ${message}`
    if (context) {
      formattedMessage += '\nContext: ' + JSON.stringify(context, null, 2)
    }
    return formattedMessage
  }

  private async sendToWhatsApp(message: string): Promise<void> {
    await axios.post(this.whatsappApiURL, {
      message,
      token: this.whatsappApiToken,
    })
  }
}

export const notificationService = new NotificationService()

================
File: server/utils/rateLimiter.ts
================
import { serverSupabaseUser } from '#supabase/server'

type PlanKey = 'free' | 'basic' | 'intermediate' | 'premium'
type FeatureKey = 'ask'

const rateLimitConfig = {
  free: {
    ask: {
      interval: 1800000,
      maxRequests: 3,
    },
  },
  basic: {
    ask: {
      interval: 1800000,
      maxRequests: 10,
    },
  },
  intermediate: {
    ask: {
      interval: 1800000,
      maxRequests: 20,
    },
  },
  premium: {
    ask: {
      interval: 1800000,
      maxRequests: 30,
    },
  },
}

// consider using   const ip = getRequestIP(event); // "192.0.2.0"
// consider using   const userAgent = getRequestHeader(event, 'user-agent');
// consider using   const referer = getRequestHeader(event, 'referer');
// getRequestFingerprint(event, opts) instead of correlation-id

// this can probably be improved once we have role based access implmented
// all info can be appended to the event.context object

interface RateLimitInfo {
  requestCount: number
  expiresAt: number
}

const getFeatureFromPath = (path: string): FeatureKey => {
  const feature = path.split('/').pop()?.split('?')[0] as FeatureKey
  console.log('getFeatureFromPath', feature)
  return feature
}

export async function rateLimiter() {
  const event = useEvent()
  const feature = getFeatureFromPath(event.path)
  const user = await serverSupabaseUser(event)

  if (!user) {
    throw createError({ message: 'User not found, You must be logged in to use this endpoint' })
  }
  const userPlan = (user?.app_metadata.plan as PlanKey) ?? 'free'
  const storage = useStorage('session')
  const storageKey = `rateLimit:endpoint:${userPlan}:${user?.id}`
  const settings = rateLimitConfig[userPlan][feature]

  let rateLimit = await storage.getItem<RateLimitInfo>(storageKey)
  if (!rateLimit || rateLimit.expiresAt < Date.now()) {
    console.info('Rate limit not found, or it has expired')
    rateLimit = {
      requestCount: 1,
      expiresAt: Date.now() + settings.interval,
    }
  }

  if (rateLimit.requestCount > settings.maxRequests) {
    throw createError({
      statusCode: 429,
      statusMessage: `Exceeded ${feature.charAt(0).toUpperCase()}${feature.slice(1)} Limits`,
      message: `You have exceeded your limit of ${settings.maxRequests}
       requests in the last ${settings.interval / 60000} minutes`,
    })
  }

  rateLimit.requestCount++

  await storage.setItem(storageKey, rateLimit)
}

================
File: server/utils/validator.ts
================
import type { H3Event } from 'h3'
import type { AnyZodObject } from 'zod'

export async function validateBody(event: H3Event, parser: AnyZodObject) {
  const validatedBody = await readValidatedBody(event, parser.safeParse)

  if (!validatedBody.success) {
    throw createError({
      statusCode: 422,
      statusMessage: 'Unprocessable Entity: Feedback Format',
      message: JSON.stringify(validatedBody.error.errors),
    })
  }

  return validatedBody.data
}

================
File: server/tsconfig.json
================
{
  "extends": "../.nuxt/tsconfig.server.json",
  "compilerOptions": {
    "esModuleInterop": true,
    "paths": {
      "#shared/*": ["../shared/*"]
    }
  }
}

================
File: shared/constants.ts
================
export const FEATURES = {
  BOOKMARK_FOLDERS: {
    name: 'Bookmark Folders',
    limit: {
      free: 3,
      pro: -1, // unlimited
    },
    description: 'Organize your bookmarks into folders',
  },
  BOOKMARKS: {
    name: 'Bookmarks',
    limit: {
      free: 100,
      pro: -1,
    },
    description: 'Save articles for later',
  },
  CUSTOM_FOLDER_COLORS: {
    name: 'Custom Folder Colors',
    limit: {
      free: 0,
      pro: -1,
    },
    description: 'Personalize your folders with custom colors',
    comingSoon: true,
  },
  CUSTOM_FEEDS: {
    name: 'Custom Feed',
    limit: {
      free: 0,
      pro: -1,
    },
    description: 'Personalize your feeds',
  },
} as const

================
File: shared/index.ts
================
export * from './constants'

================
File: types/bookmarks.ts
================
// types/bookmark.ts
export interface BookmarkContent {
  id: string
  type: string
  title: string
  description?: string
  thumbnail?: string
  url?: string
  created_at?: string
  authorName?: string
}

export interface BookmarkParams {
  content_type?: string
  folder_id?: string
  include_subfolders?: boolean
}

export interface Bookmark {
  id: string
  user_id: string
  folder_id: string | null
  content_type: string
  content_id: string
  metadata: {
    title: string
    description?: string
    thumbnail?: string
    url?: string
    created_at?: string
    authorName?: string
  }
  created_at: string
  folder?: {
    id: string
    name: string
    color: string
    is_favorite: boolean
    path?: string
  }
}

export interface Folder {
  id: string
  name: string
  color: string
  parent_id: string | null
  is_default: boolean
  is_favorite: boolean
  position: number
  path: string
  children?: Folder[]
}

================
File: types/folder.ts
================
export interface Folder {
  id: string
  name: string
  color: string
  parent_id: string | null
  is_default: boolean
  is_favorite: boolean
  position: number
  path: string
  children?: Folder[]
}

================
File: types/toasts.ts
================
import { z } from 'zod'

export const ToastActionSchema = z.object({
  variant: z.string(),
  color: z.string(),
  label: z.string(),
})

export const ToastSchema = z.object({
  id: z.union([z.string(), z.number()]),
  title: z.string(),
  description: z.string().optional(),
  icon: z.string().optional(),
  color: z.string().optional(),
  timeout: z.number().optional(),
  ui: z.unknown().optional(),
  avatar: z.unknown().optional(),
  closeButton: z.unknown().optional(),
  actions: z.array(ToastActionSchema).optional(),
  callback: z.function().optional(),
})

export const ToastStateSchema = z.object({
  toasts: z.array(ToastSchema),
})

export type ToastType = z.infer<typeof ToastSchema>
export type ToastActionType = z.infer<typeof ToastActionSchema>
export type ToastStateType = z.infer<typeof ToastStateSchema>

================
File: .env.example
================
# Private
NUXT_NASA_API_KEY=""

NUXT_SUPABASE_SERVICE_KEY=""
NUXT_SUPABASE_DB_PASS=""
# Public
NUXT_PUBLIC_SUPABASE_URL=""
NUXT_PUBLIC_SUPABASE_KEY=""

NUXT_PUBLIC_STUDIO_TOKENS=""
NUXT_PUBLIC_POSTHOG_KEY=""


NUXT_GOOGLE_API_KEY=""


# OPENAI
OPENAI_API_KEY="" # this is referenced directly by OpenAI client
OPENAI_ORG_ID=""
OPENAI_PROJECT_ID=""

# SUPABASE AUTH FOR LOCAL DEV

# https://www.linkedin.com/developers/apps/219179818/auth
SUPABASE_AUTH_LINKEDIN_CLIENT_ID=""
SUPABASE_AUTH_LINKEDIN_SECRET=""

# https://developer.twitter.com/en/portal/projects/1775789415266181120/apps/28613353/settings
# App Name: AstronEra
SUPABASE_AUTH_TWITTER_API_KEY=""
SUPABASE_AUTH_TWITTER_API_SECRET=""

# CALLBACKS
# DEV: https://fwuwxknrxpzxcbwkwicp.supabase.co/auth/v1/callback
# PROD: https://idsifamzvzlpgnmlnldw.supabase.co/auth/v1/callback
# LOCAL: http://localhost:54321/auth/v1/callback

================
File: app.config.ts
================
// This supports HMR
export default defineAppConfig({
  title: 'AstronEra - AstroTribe',
})

================
File: app.vue
================
<script setup lang="ts">
useHead({
  htmlAttrs: {
    lang: 'en',
  },
  meta: [
    {
      name: 'viewport',
      content: 'width=device-width, initial-scale=1',
    },
  ],
  link: [
    {
      rel: 'icon',
      type: 'image/png',
      href: '/favicon.png',
    },
  ],
})

const catTagStore = useCategoryTagStore()
const currentUser = useCurrentUser()
const folderStore = useFolderStore()
const bookmarkStore = useBookmarkStore()

onMounted(async () => {
  document.documentElement.classList.add('dark')
  try {
    await Promise.all([
      currentUser.refreshUserStore(),
      folderStore.fetchFolders(),
      bookmarkStore.fetchBookmarks(),
      bookmarkStore.fetchBookmarkCounts(),
    ])
  } catch (error: any) {
    console.error('Error initializing data:', error)
  }
})
</script>

<template>
  <div class="h-full w-full">
    <NuxtLoadingIndicator />
    <Head>
      <link
        rel="manifest"
        href="/manifest.webmanifest"
      />
    </Head>
    <NuxtPwaAssets />
    <NuxtLayout>
      <NuxtPage />
    </NuxtLayout>
    <PrimeToast position="bottom-right" />
    <ReferralCapture />
    <!-- <Notification /> -->
  </div>
</template>

<style>
html {
  margin: 0;
  padding: 0;
}

#__nuxt {
  width: 100%;
  height: 100%;
  padding: 0;
  margin: 0;
}

.layout-enter-active,
.layout-leave-active {
  transition: all 0.4s;
}

.layout-enter-from,
.layout-leave-to {
  opacity: 0;
  filter: blur(1rem);
}
</style>

================
File: components.d.ts
================
/* eslint-disable */
// @ts-nocheck
// Generated by unplugin-vue-components
// Read more: https://github.com/vuejs/core/pull/3399
export {}

/* prettier-ignore */
declare module 'vue' {
  export interface GlobalComponents {
    PrimeAvatar: typeof import('primevue/avatar')['default']
    PrimeBadge: typeof import('primevue/badge')['default']
    PrimeBreadcrumb: typeof import('primevue/breadcrumb')['default']
    PrimeButton: typeof import('primevue/button')['default']
    PrimeCalendar: typeof import('primevue/calendar')['default']
    PrimeCard: typeof import('primevue/card')['default']
    PrimeCarousel: typeof import('primevue/carousel')['default']
    PrimeChart: typeof import('primevue/chart')['default']
    PrimeCheckbox: typeof import('primevue/checkbox')['default']
    PrimeChip: typeof import('primevue/chip')['default']
    PrimeColumn: typeof import('primevue/column')['default']
    PrimeConfirmPopup: typeof import('primevue/confirmpopup')['default']
    PrimeDataTable: typeof import('primevue/datatable')['default']
    PrimeDatePicker: typeof import('primevue/datepicker')['default']
    PrimeDialog: typeof import('primevue/dialog')['default']
    PrimeIconField: typeof import('primevue/iconfield')['default']
    PrimeInputNumber: typeof import('primevue/inputnumber')['default']
    PrimeInputText: typeof import('primevue/inputtext')['default']
    PrimeMenu: typeof import('primevue/menu')['default']
    PrimeMessage: typeof import('primevue/message')['default']
    PrimeMultiSelect: typeof import('primevue/multiselect')['default']
    PrimePassword: typeof import('primevue/password')['default']
    PrimePopover: typeof import('primevue/popover')['default']
    PrimeProgressBar: typeof import('primevue/progressbar')['default']
    PrimeProgressSpinner: typeof import('primevue/progressspinner')['default']
    PrimeSelect: typeof import('primevue/select')['default']
    PrimeSelectButton: typeof import('primevue/selectbutton')['default']
    PrimeSkeleton: typeof import('primevue/skeleton')['default']
    PrimeStep: typeof import('primevue/step')['default']
    PrimeStepList: typeof import('primevue/steplist')['default']
    PrimeStepPanel: typeof import('primevue/steppanel')['default']
    PrimeStepPanels: typeof import('primevue/steppanels')['default']
    PrimeStepper: typeof import('primevue/stepper')['default']
    PrimeTab: typeof import('primevue/tab')['default']
    PrimeTabList: typeof import('primevue/tablist')['default']
    PrimeTabPanel: typeof import('primevue/tabpanel')['default']
    PrimeTabs: typeof import('primevue/tabs')['default']
    PrimeTag: typeof import('primevue/tag')['default']
    PrimeTextarea: typeof import('primevue/textarea')['default']
    PrimeToast: typeof import('primevue/toast')['default']
    PrimeToggleButton: typeof import('primevue/togglebutton')['default']
    RouterLink: typeof import('vue-router')['RouterLink']
    RouterView: typeof import('vue-router')['RouterView']
  }
  export interface ComponentCustomProperties {
    Ripple: typeof import('primevue/ripple')['default']
  }
}

================
File: error.vue
================
<template>
  <div class="flex h-auto items-center justify-center foreground min-h-screen">
    <div class="max-w-md rounded-lg p-8 shadow-lg background">
      <h1 class="mb-4 text-3xl font-bold text-primary-600">An error occurred</h1>
      <p class="text-lg mb-4">
        {{ error?.message || error }}
      </p>
      <p
        v-if="error?.errorId"
        class="mb-2 text-sm text-gray-600"
      >
        Error ID: {{ error.errorId }}
      </p>
      <p
        v-if="error?.stack"
        class="mb-4 overflow-auto text-xs text-gray-500"
      >
        <strong>Stack trace:</strong><br />
        {{ error.stack }}
      </p>
      <div class="flex justify-between">
        <button
          v-if="error?.retryAction"
          class="rounded bg-blue-500 px-4 py-2 text-white hover:bg-blue-600"
          @click="handleRetry"
        >
          Retry
        </button>
        <button
          class="rounded bg-gray-300 px-4 py-2 text-gray-800 hover:bg-gray-400"
          @click="handleHome"
        >
          Go to Home
        </button>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
const props = defineProps<{
  error: Error | any
}>()

const router = useRouter()
const { clearError } = useError()

const handleRetry = () => {
  if (props.error?.retryAction && typeof props.error.retryAction === 'function') {
    props.error.retryAction()
  }
}

const handleHome = () => {
  clearError()
  router.push('/')
}
</script>

================
File: project.json
================
{
  "name": "@astronera/app",
  "$schema": "../../node_modules/nx/schemas/project-schema.json",
  "projectType": "application",
  "sourceRoot": "packages/app",
  "// targets": "to see all targets run: nx show project @astronera/app --web",
  "targets": {
    "build": {
      "executor": "nx:run-commands",
      "options": {
        "command": "cd apps/app && pnpx nuxi build"
      },
      "dependsOn": [
        {
          "target": "build",
          "projects": [
            "@astronera/logging",
            "@astronera/base",
            "@astronera/supabase",
            "@astronera/crud",
            "@astronera/advert",
            "@astronera/referral"
          ]
        }
      ]
    },
    "serve": {
      "executor": "nx:run-commands",
      "options": {
        "command": "cd apps/app && pnpx nuxi dev --no-port-scanning"
      }
    },

    "lint": {
      "executor": "nx:run-commands",
      "options": {
        "command": "eslint --config eslint.config.js ."
      }
    },

    "test": {
      "executor": "nx:run-commands",
      "options": {
        "command": "cd apps/app && vitest run --coverage",
        "env": {
          "NUXT_PUBLIC_NODE_ENV": "test",
          "VITEST_MODE": "true"
        }
      }
    },
    "test:watch": {
      "executor": "nx:run-commands",
      "options": {
        "command": "cd apps/app && vitest",
        "env": {
          "NUXT_PUBLIC_NODE_ENV": "test",
          "VITEST_MODE": "true"
        }
      }
    },
    "start": {
      "executor": "nx:run-commands",
      "options": {
        "command": "node .output/server/index.mjs",
        "cwd": "apps/app"
      },
      "dependsOn": ["build"]
    },
    "test:ui": {
      "executor": "nx:run-commands",
      "options": {
        "command": "cd apps/app && vitest --ui"
      }
    },
    "test:coverage": {
      "executor": "nx:run-commands",
      "options": {
        "command": "cd apps/app && vitest run --coverage"
      }
    }
  }
}

================
File: prompt-app-download.ts
================
function isMobileDevice() {
  return /Mobi|Android|iPhone/i.test(navigator.userAgent)
}

let deferredPrompt

window.addEventListener('beforeinstallprompt', (e) => {
  // Prevent the mini-infobar from appearing on mobile
  e.preventDefault()
  // Stash the event so it can be triggered later
  deferredPrompt = e

  // Check if the device is mobile
  if (isMobileDevice()) {
    // Show your custom install button or prompt
    showInstallButton()
  }
})

function showInstallButton() {
  // Display your custom install UI for mobile users
  const installButton = document.getElementById('install-button')
  installButton.style.display = 'block'

  installButton.addEventListener('click', async () => {
    // Hide the install button
    installButton.style.display = 'none'

    // Show the install prompt
    deferredPrompt.prompt()

    // Wait for the user to respond to the prompt
    const { outcome } = await deferredPrompt.userChoice
    if (outcome === 'accepted') {
      console.log('User accepted the install prompt')
    } else {
      console.log('User dismissed the install prompt')
    }
    deferredPrompt = null
  })
}

================
File: README.md
================
<h1 align="center" style="margin-top: 0px;">AstroTribe</h1>
<!-- <p align="center" style="margin-bottom: 0px !important;">
  <img width="200" src="https://github.com/Drew-Macgibbon/design-portfolio/blob/main/public/readme/doom-logo.png" align="center">
</p> -->
<p align="center" >The AstroTribe App is a social network for astronomers and wannabe astronomers around the globe.</p>

<p align="center">
  <a href="https://astronera.org/">Production</a> --- |  .  | --- <a href="https://astrotribe.vercel.app/">Development</a>
</p>

We're currently working towards an open beta release. If you'd like to be notified when we launch,
register your interest [here](https://astrotribe.vercel.app/register)

### Contributing:

Clone the `develop` Branch Create your Feature Branch `git checkout -b feature/amazing-feature` Open
a Pull Request against `develop` when the feature is ready for review

### Development Setup:

supabase: http://localhost:54323/project/default

#### Find Work:

##### Domain / Category

1. **`infra:` Infrastructure & Foundations**

   - **Scope**: This domain encompasses all backend infrastructure elements critical to application
     functionality. It includes the management of server environments, authentication systems,
     application programming interfaces (APIs), data storage solutions, logging systems, and any
     other foundational services or protocols that support application operations.
   - **Example Tasks**: Set up secure authentication methods, optimize API performance, implement
     comprehensive logging systems, and configure cloud storage solutions.

2. **`logic:` Business Logic & Processing**

   - **Scope**: Focuses on the core functionality that users interact with directly. This domain
     includes the creation and maintenance of the operational logic that drives the application's
     primary features—from user inputs leading to actions (like button clicks) to data processing
     and output formatting.
   - **Example Tasks**: Develop a new feature that formats user data for reports, refactor
     validation logic to enhance security, create storage procedures for user inputs.

3. **`design:` User Interface & Experience Design**

   - **Scope**: Dedicated to the aesthetic and functional design of user interfaces and the
     underlying software architecture. This domain covers everything from UI/UX design for improved
     user interaction to strategic database and software architecture planning for efficient data
     management and flow.
   - **Example Tasks**: Redesign the user interface for enhanced usability, create a responsive
     design for mobile platforms, plan and model a new database schema for scalability.

4. **`test:` Quality Assurance & Testing**

   - **Scope**: Ensures that all features operate as intended before they reach end-users. This
     domain involves developing and maintaining a robust testing framework, including unit tests,
     integration tests, system tests, and ensuring new functionalities are covered as they are
     developed.
   - **Example Tasks**: Write integration tests for a new API endpoint, update existing tests to
     cover recent changes in business logic, automate regression testing scenarios.

5. **`bug:` Issue Resolution & Debugging**
   - **Scope**: A cross-domain responsibility focused on identifying, tracking, and resolving bugs
     throughout the application. This domain ensures that issues are promptly addressed to maintain
     the integrity and performance of the application across all other domains.
   - **Example Tasks**: Fix a critical bug affecting user login, resolve a recurring error in data
     formatting, debug a performance issue in database queries.

##### Search for Jobs

Key = category | priority | difficulty | time estimate

<!-- // teams work in small groups on single feature end to end -->

**Remove '~' from your search, it's for doc search exclusion**

```ts
// Frontend Work
//
// ~infra:low:easy:1 - Routine Check: Perform daily server status check.
// ~logic:med:med:2 - Update Rollout: Deploy new software updates to the server cluster.
// ~design:high:challenge:4 - Infrastructure Overhaul: Redesign the network architecture for increased efficiency.
// ~test:urgent:hard:8 - Disaster Recovery: Implement immediate fixes following a critical system failure.
// ~bug:critical:extreme:12 - Full System Rebuild: Reconstruct server environment and restore all critical services post-major outage.
```

**Backend uses a ! prefix**

```ts
// Backend Work (! prefix)
//
// ~!infra:low:easy:1
```

**Database uses # for comments**

```bash
# Database Work (# for comments)
#
# ~infra:low:easy:1
```

#### Stack

- Nuxt
- Vercel
- Supabase

#### Links

- Dev Site: https://astrotribe-git-develop-incubrain.vercel.app

#### Supabase:

install supabase locally if you don't have it already.

```bash
brew install supabase/tap/supabase
```

```bash
// make sure docker is open
// download the images
supabase start
//
supabase login
// link the local project to production
supabase link --project-ref <project-id>
// pull down the database
supabase db pull
```

#### Migrations:

```bash
// create a migration based on changes made in local studio
supabase db diff -f new_employee
// reset db to verify changes
supabase db reset
```

<!-- 11:28 battery full -->

================
File: vitest.setup.ts
================
// apps/app/vitest.setup.ts
import { vi } from 'vitest'

// Mock Supabase Client
vi.mock('#imports', async () => {
  const actual = await vi.importActual<object>('#imports')
  return {
    ...actual,
    useSupabaseClient: () => ({
      auth: {
        getSession: vi.fn().mockResolvedValue({
          data: {
            session: {
              user: {
                id: 'e8976b16-02a9-4595-a8a9-6457548eec12',
                app_metadata: { role: 'user', plan: 'free' },
              },
            },
          },
          error: null,
        }),
      },
    }),
  }
})

// Mock PostHog
vi.mock('posthog-js', () => ({
  default: {
    init: vi.fn(),
    debug: vi.fn(),
    capture: vi.fn(),
  },
}))

// Mock Formbricks
vi.mock('@formbricks/js', () => ({
  default: {
    init: vi.fn(),
    registerRouteChange: vi.fn(),
  },
}))

// Mock `navigateTo`
vi.mock('#app', async () => {
  const actual = await vi.importActual<object>('#app')
  return {
    ...actual,
    navigateTo: vi.fn(),
  }
})



================================================================
End of Codebase
================================================================
