core/
  base.generator.ts
  config-manager.ts
  config-validator.ts
  default-config.ts
decorators/
  custom.decorators.ts
modules/
  documentation.ts
  interfaces.ts
  openapi-metadata.ts
  schemas.ts
  transformers.ts
  type-guard.ts
  validators.ts
template/
  dto.template.ts
  interface.template.ts
  request.dto.template.ts
  response.dto.template.ts
  schema.template.ts
templates/
  api/
    metadata.api.hbs
  base/
    base-types.hbs
    documentation.hbs
    helpers.hbs
    imports.hbs
    property.hbs
    type-helpers.hbs
  dto/
    model.dto.hbs
    relationships.dto.hbs
    request.dto.hbs
    response.dto.hbs
    view.dto.hbs
  guard/
    type.guard.hbs
  interface/
    model.interface.hbs
    relationships.interface.hbs
    view.interface.hbs
  schema/
    model.schema.hbs
    schema.utilities.hbs
    transform.hbs
    transform.methods.hbs
    validation.helpers.hbs
    validation.schema.hbs
  index.hbs
  template.engine.ts
  template.helpers.ts
  template.system.ts
types/
  config.types.ts
  documentation.types.ts
  field.types.ts
  index.ts
  model.types.ts
  postgresql.types.ts
  rules.types.ts
  template.types.ts
  view.types.ts
utils/
  documentation-parser.ts
  field-parser.ts
  file-manager.ts
  type-mapper.ts
config.ts
index.ts

================================================================
Repository Files
================================================================

================
File: core/base.generator.ts
================
// tools/generators/dto/core/base.generator.ts
import { FileManager } from '../utils/file-manager'
import { FieldParser } from '../utils/field-parser'
import { DocumentationParser } from '../utils/documentation-parser'
import { TypeMapper } from '../utils/type-mapper'
import { OpenAPIMetadataGenerator } from '../modules/openapi-metadata'
import { ValidationGenerator } from '../modules/validators'
import type {
  GeneratorOptions,
  ModelMetadata,
  GeneratedFile,
  RelationshipMetadata,
  ViewMetadata,
  ComputedColumnMetadata,
  ValidationRule,
  DocumentationMetadata,
  FieldMetadata,
} from '../types'
import type { DMMF } from '@prisma/generator-helper'
import { join } from 'path'
import { TemplateEngine } from '../templates/template.engine'

/**
 * Base generator class that orchestrates the DTO generation process.
 * This class coordinates between different modules while maintaining
 * separation of concerns.
 */
export abstract class BaseGenerator {
  protected fileManager: FileManager
  protected fieldParser: FieldParser
  protected documentationParser: DocumentationParser
  protected typeMapper: TypeMapper
  protected openApiGenerator: OpenAPIMetadataGenerator
  protected isReady = false

  constructor(
    protected readonly dmmf: DMMF.Document,
    protected readonly options: GeneratorOptions,
  ) {
    this.fileManager = new FileManager(options.outputPath)
    this.documentationParser = new DocumentationParser()
    this.typeMapper = new TypeMapper()
    this.openApiGenerator = new OpenAPIMetadataGenerator(this.typeMapper)
    this.fieldParser = new FieldParser()
    console.log('Generator options:', {
      outputPath: this.options.outputPath,
      typescript: this.options.typescript,
      validation: this.options.validation,
      documentation: this.options.documentation,
    })
  }

  async ensureInitialized(): Promise<void> {
    if (!this.isReady) {
      console.log('Initialization required. Running initialize()...')
      await this.initialize()
      this.isReady = true
    }
  }

  async initialize(): Promise<void> {
    if (this.isReady) {
      return
    }

    const __dirname = new URL('.', import.meta.url).pathname
    const templatesPath = join(__dirname, '..', 'templates')
    console.log('Initializing template engine with templates path:', templatesPath)

    try {
      await TemplateEngine.initialize(templatesPath)
      this.isReady = true
      console.log('Template engine initialized successfully')
    } catch (error) {
      console.error('Error initializing template engine:', error)
      throw error
    }
  }

  /**
   * Main generation process that coordinates all generator modules.
   * Each step is isolated and can be enabled/disabled via options.
   */
  async generate(): Promise<void> {
    // Create necessary directories
    console.log('Creating directories...')
    await this.fileManager.initializeDirectory()

    // Process each model
    console.log('Processing models from DMMF...')
    console.log('Number of models:', this.dmmf.datamodel.models.length)

    for (const model of this.dmmf.datamodel.models) {
      console.log(`Processing model: ${model.name}`)
      const metadata = await this.processModel(model)

      // Generate different artifacts based on options
      const files: GeneratedFile[] = []

      if (this.options.typescript?.generateInterfaces) {
        console.log(`Generating interface for ${model.name}`)
        files.push(await this.generateInterface(metadata))
      }

      // Always generate DTOs
      console.log(`Generating DTO for ${model.name}`)
      files.push(await this.generateValidatedDTO(metadata))

      if (this.options.typescript?.generateTypeGuards) {
        console.log(`Generating type guard for ${model.name}`)
        files.push(await this.generateTypeGuard(metadata))
      }

      if (this.options.validation?.useZod) {
        console.log(`Generating Zod schema for ${model.name}`)
        files.push(await this.generateZodSchema(metadata))
      }

      // Write all generated files
      console.log(`Writing ${files.length} files for ${model.name}`)
      await Promise.all(
        files.map((file) => {
          console.log(`Writing file: ${file.path}`)
          return this.fileManager.writeFile(file.path, file.content)
        }),
      )
    }

    // Generate auxiliary files
    if (this.options.documentation?.enabled) {
      console.log('Generating documentation...')
      await this.generateDocumentation()
    }

    console.log('Generating index file...')
    await this.generateIndexFile()
    console.log('Generating utility files...')
    await this.generateUtilityFiles()
  }

  /**
   * Processes a Prisma model into our internal metadata format, now with view support.
   * This method examines model attributes to determine if it represents a view and
   * extracts view-specific metadata when applicable.
   */
  protected async processModel(model: DMMF.Model): Promise<ModelMetadata> {
    const documentation = this.documentationParser.parseModelDocumentation(model)
    const fields = await Promise.all(
      model.fields.map((field) => this.fieldParser.parseField(field)),
    )

    // Determine if this model represents a view by checking Prisma metadata
    const isView = this.isModelAView(model)
    let viewMetadata: ViewMetadata | undefined

    if (isView) {
      viewMetadata = await this.extractViewMetadata(model)
    }

    return {
      name: model.name,
      documentation,
      fields,
      relations: this.processRelationships(model),
      isView,
      viewMetadata,
    }
  }

  /**
   * Determines if a Prisma model represents a database view by examining
   * its attributes and documentation.
   */
  private isModelAView(model: DMMF.Model): boolean {
    // Check for view-specific markers in the model's documentation
    const viewMarker = model.documentation?.includes('@view')

    // Check for Prisma-specific view attributes
    const hasViewAttribute =
      model.documentation?.includes('@view') || model.documentation?.includes('@@view')

    return viewMarker || hasViewAttribute || false
  }

  /**
   * Extracts detailed metadata about a view from its Prisma model definition.
   * This includes the view's source query, dependencies, and computed columns.
   */
  private async extractViewMetadata(model: DMMF.Model): Promise<ViewMetadata> {
    const viewMetadata: ViewMetadata = {
      sourceQuery: this.extractSourceQuery(model),
      materialized: this.isViewMaterialized(model),
      updatable: this.isViewUpdatable(model),
      dependencies: this.extractViewDependencies(model),
      computedColumns: [],
    }

    // Process computed columns
    viewMetadata.computedColumns = await this.extractComputedColumns(model)

    return viewMetadata
  }

  /**
   * Extracts the SQL query that defines a view from model documentation.
   * This is typically specified in a special documentation comment.
   */
  private extractSourceQuery(model: DMMF.Model): string {
    const queryMatch = model.documentation?.match(/@view-query\s+{([^}]+)}/)
    return queryMatch ? queryMatch[1].trim() : ''
  }

  /**
   * Determines if a view is materialized by checking its attributes.
   */
  private isViewMaterialized(model: DMMF.Model): boolean {
    return model.documentation?.includes('@materialized') || false
  }

  /**
   * Checks if a view is updatable based on its definition and constraints.
   */
  private isViewUpdatable(model: DMMF.Model): boolean {
    return model.documentation?.includes('@updatable') || false
  }

  /**
   * Extracts a list of tables and views that this view depends on.
   */
  private extractViewDependencies(model: DMMF.Model): string[] {
    const dependencyMatch = model.documentation?.match(/@dependencies\s+\[(.*?)\]/)
    if (!dependencyMatch) return []

    return dependencyMatch[1]
      .split(',')
      .map((dep) => dep.trim())
      .filter(Boolean)
  }

  /**
   * Extracts information about computed columns in the view.
   */
  private async extractComputedColumns(model: DMMF.Model): Promise<ComputedColumnMetadata[]> {
    const computedColumns: ComputedColumnMetadata[] = []

    for (const field of model.fields) {
      if (this.isComputedColumn(field)) {
        computedColumns.push({
          name: field.name,
          expression: this.extractComputedExpression(field),
          dependsOn: this.extractColumnDependencies(field),
          returnType: field.type,
        })
      }
    }

    return computedColumns
  }

  /**
   * Determines if a field represents a computed column.
   */
  private isComputedColumn(field: DMMF.Field): boolean {
    return field.documentation?.includes('@computed') || false
  }

  /**
   * Extracts the SQL expression that computes a column's value.
   */
  private extractComputedExpression(field: DMMF.Field): string {
    const expressionMatch = field.documentation?.match(/@computed-expression\s+{([^}]+)}/)
    return expressionMatch ? expressionMatch[1].trim() : ''
  }

  /**
   * Extracts the list of fields that a computed column depends on.
   */
  private extractColumnDependencies(field: DMMF.Field): string[] {
    const dependencyMatch = field.documentation?.match(/@depends-on\s+\[(.*?)\]/)
    if (!dependencyMatch) return []

    return dependencyMatch[1]
      .split(',')
      .map((dep) => dep.trim())
      .filter(Boolean)
  }

  /**
   * Generates validation rules appropriate for a view-based DTO.
   * Views require special handling as some fields may be computed
   * or derived from complex expressions.
   */
  protected generateViewValidationRules(metadata: ModelMetadata): ValidationRule[] {
    const rules: ValidationRule[] = []

    if (!metadata.isView) return rules

    // Add view-specific validation rules
    rules.push({
      decorator: 'IsViewDTO',
      message: `This DTO represents a view: ${metadata.name}`,
    })

    // Handle computed columns differently
    metadata.viewMetadata?.computedColumns.forEach((column) => {
      rules.push({
        decorator: 'IsComputed',
        params: [column.name],
        message: `${column.name} is a computed field`,
      })
    })

    return rules
  }

  /**
   * Abstract methods that must be implemented by specific generators
   */
  protected abstract generateInterface(metadata: ModelMetadata): Promise<GeneratedFile>
  protected abstract generateValidatedDTO(metadata: ModelMetadata): Promise<GeneratedFile>
  protected abstract generateTypeGuard(metadata: ModelMetadata): Promise<GeneratedFile>
  protected abstract generateZodSchema(metadata: ModelMetadata): Promise<GeneratedFile>
  protected abstract generateDocumentation(): Promise<void>
  protected abstract generateIndexFile(): Promise<void>
  protected abstract generateUtilityFiles(): Promise<void>

  /**
   * Processes model relationships to build a complete picture
   * of how models are connected
   */
  private processRelationships(model: DMMF.Model): RelationshipMetadata[] {
    return model.fields
      .filter((field) => field.relationName)
      .map((field) => ({
        name: field.name,
        type: field.type,
        relationType: this.determineRelationType(field),
        isRequired: field.isRequired,
        isArray: field.isList,
        foreign: {
          model: field.type,
          field: field.relationFromFields?.[0] || '',
        },
      }))
  }

  private determineRelationType(field: DMMF.Field): RelationshipMetadata['relationType'] {
    if (field.isList) {
      return field.relationToFields?.length ? 'many-to-many' : 'one-to-many'
    }
    return field.relationToFields?.length ? 'many-to-one' : 'one-to-one'
  }
}

================
File: core/config-manager.ts
================
// tools/generators/dto/core/config-manager.ts

import { cosmiconfig } from 'cosmiconfig'
import { defaultConfig } from './default-config'
import { ConfigValidator } from './config-validator'
import type {
  GeneratorConfig,
  ValidationRuleDefinition,
  TypeConverter,
  PluginConfig,
  GeneratorOptions,
} from '../types'

/**
 * Manages the configuration for the DTO generator, handling loading,
 * validation, and merging of configuration from multiple sources.
 */
export class ConfigurationManager {
  private config: GeneratorConfig

  constructor() {
    this.config = defaultConfig
  }

  /**
   * Loads configuration from all available sources and merges them
   * according to priority. Sources are loaded in this order:
   * 1. Default configuration
   * 2. Configuration file (.dtogenrc, package.json)
   * 3. Environment variables
   * 4. Command line arguments
   */
  async loadConfiguration(options: Partial<GeneratorOptions> = {}): Promise<GeneratorConfig> {
    // Load configuration file using cosmiconfig
    const explorer = cosmiconfig('dtogen')
    const result = await explorer.search()
    const fileConfig = result?.config || {}

    // Load environment variables
    const envConfig = this.loadEnvironmentConfig()

    // Convert GeneratorOptions to GeneratorConfig
    const configFromOptions: Partial<GeneratorConfig> = {
      outputPath: options.outputPath,
      prettierConfig: options.prettierConfig,
      validation: {
        enabledRules: options.validation?.enabled
          ? [
              'IsNotEmpty',
              'IsOptional',
              'IsString',
              'IsNumber',
              'IsBoolean',
              'IsDate',
              'IsEmail',
              'MinLength',
              'MaxLength',
              'Min',
              'Max',
            ]
          : [],
        customRules: [],
        messageTemplates: {
          required: '${field} is required',
          string: '${field} must be a string',
          number: '${field} must be a number',
          boolean: '${field} must be a boolean',
          date: '${field} must be a valid date',
          email: '${field} must be a valid email address',
          minLength: '${field} must be at least ${min} characters',
          maxLength: '${field} must be at most ${max} characters',
        },
        validators: {},
      },
    }

    // Merge configurations with priority
    this.config = this.mergeConfigurations([
      defaultConfig,
      fileConfig,
      envConfig,
      configFromOptions,
    ])

    // Validate final configuration
    await ConfigValidator.validateConfig(this.config)

    return this.config
  }

  /**
   * Registers a custom type mapping that can be used in the generator.
   * This allows adding support for new database types or overriding
   * existing type mappings.
   */
  registerCustomType(dbType: string, tsType: string, converter?: TypeConverter): void {
    this.config.types.customMappings[dbType] = tsType
    if (converter) {
      this.config.types.typeConverters[dbType] = converter
    }
  }

  /**
   * Registers a custom validation rule that can be used in generated DTOs.
   * This allows adding new validation decorators and rules beyond
   * what's built into the system.
   */
  registerValidationRule(rule: ValidationRuleDefinition): void {
    this.config.validation.customRules.push(rule)
  }

  /**
   * Registers a plugin that extends the generator's functionality.
   * Plugins can add new generators, modify the generation process,
   * or add new features to the generated code.
   */
  registerPlugin(plugin: PluginConfig): void {
    this.config.plugins.push(plugin)
  }

  /**
   * Gets the current configuration, optionally filtered to a specific section.
   */
  getConfig<K extends keyof GeneratorConfig>(section?: K): GeneratorConfig | GeneratorConfig[K] {
    if (section) {
      return this.config[section]
    }
    return this.config
  }

  /**
   * Merges multiple configuration objects, handling deep merging of
   * nested configuration options and arrays.
   */
  private mergeConfigurations(configs: Partial<GeneratorConfig>[]): GeneratorConfig {
    return configs.reduce((merged, config) => {
      return this.deepMerge(merged, config)
    }, {} as GeneratorConfig) as GeneratorConfig
  }

  /**
   * Loads configuration from environment variables, converting them
   * to the appropriate configuration structure.
   */
  private loadEnvironmentConfig(): Partial<GeneratorConfig> {
    const config: Partial<GeneratorConfig> = {}

    // Map environment variables to configuration options
    Object.entries(process.env).forEach(([key, value]) => {
      if (key.startsWith('DTOGEN_')) {
        this.setConfigValue(config, key.slice(7).toLowerCase(), value ?? '')
      }
    })

    return config
  }

  /**
   * Sets a configuration value from a flat key path, handling
   * nested configuration options.
   */
  private setConfigValue(config: any, key: string, value: string): void {
    const parts = key.split('_')
    let current = config

    for (let i = 0; i < parts.length - 1; i++) {
      const part = parts[i]
      current[part] = current[part] || {}
      current = current[part]
    }

    const lastPart = parts[parts.length - 1]
    current[lastPart] = this.parseConfigValue(value)
  }

  /**
   * Parses a configuration value, converting strings to appropriate
   * types (boolean, number, etc.)
   */
  private parseConfigValue(value: string): any {
    if (value.toLowerCase() === 'true') return true
    if (value.toLowerCase() === 'false') return false
    if (!isNaN(Number(value))) return Number(value)
    try {
      return JSON.parse(value)
    } catch {
      return value
    }
  }

  /**
   * Performs a deep merge of configuration objects, properly handling
   * arrays and nested objects.
   */
  private deepMerge(target: any, source: any): any {
    if (!source) return target

    Object.keys(source).forEach((key) => {
      if (source[key] instanceof Object && !Array.isArray(source[key])) {
        target[key] = this.deepMerge(target[key] || {}, source[key])
      } else {
        target[key] = source[key]
      }
    })

    return target
  }
}

================
File: core/config-validator.ts
================
// tools/generators/dto/core/config-validator.ts

import { existsSync } from 'fs'
import type { GeneratorConfig, TypeConverter, ValidationRuleDefinition } from '../types'

/**
 * Validates the generator configuration to ensure all required options
 * are present and valid. This helps catch configuration errors early
 * in the generation process.
 */
export class ConfigValidator {
  /**
   * Main validation method that coordinates all validation checks
   */
  static async validateConfig(config: GeneratorConfig): Promise<void> {
    this.validateBasicConfig(config)
    this.validateTypeSystem(config.types)
    this.validateValidation(config.validation)
    this.validateTemplates(config.templates)
    this.validatePlugins(config.plugins)
    this.validateOutput(config.output)
    await this.validateHooks(config.hooks)
  }

  /**
   * Validates basic configuration options including paths and essential settings
   */
  private static validateBasicConfig(config: GeneratorConfig): void {
    if (!config.outputPath) {
      throw new Error('Output path must be specified')
    }

    // Validate prettier configuration if specified
    if (config.prettierConfig && !existsSync(config.prettierConfig)) {
      throw new Error(`Prettier config file not found: ${config.prettierConfig}`)
    }
  }

  /**
   * Validates type system configuration including custom mappings and converters
   */
  private static validateTypeSystem(types: GeneratorConfig['types']): void {
    // Validate custom type mappings
    Object.entries(types.customMappings).forEach(([dbType, tsType]) => {
      if (typeof tsType !== 'string') {
        throw new Error(`Invalid TypeScript type mapping for ${dbType}`)
      }
    })

    // Validate type converters
    Object.entries(types.typeConverters).forEach(([type, converter]) => {
      this.validateTypeConverter(type, converter)
    })

    // Validate generic type configurations
    types.genericTypes.forEach((genericType) => {
      if (genericType.typeParameters < 1) {
        throw new Error(`Generic type ${genericType.name} must have at least one type parameter`)
      }
      if (!genericType.template.includes('${type}')) {
        throw new Error(`Generic type ${genericType.name} template must include \${type}`)
      }
    })
  }

  /**
   * Validates validation configuration including custom rules
   */
  private static validateValidation(validation: GeneratorConfig['validation']): void {
    // Validate custom rules
    validation.customRules.forEach((rule) => {
      this.validateCustomRule(rule)
    })

    // Ensure required message templates exist
    const requiredTemplates = ['required', 'string', 'number', 'boolean']
    requiredTemplates.forEach((template) => {
      if (!validation.messageTemplates[template]) {
        throw new Error(`Missing required message template: ${template}`)
      }
    })
  }

  /**
   * Validates template configuration including paths and overrides
   */
  private static validateTemplates(templates: GeneratorConfig['templates']): void {
    // Validate template paths exist
    templates.templatePaths?.forEach((path) => {
      if (!existsSync(path)) {
        throw new Error(`Template path not found: ${path}`)
      }
    })

    // Validate template overrides
    Object.entries(templates.overrides || {}).forEach(([name, template]) => {
      if (typeof template !== 'string') {
        throw new Error(`Invalid template override for ${name}`)
      }
    })
  }

  /**
   * Validates plugin configuration including plugin existence and options
   */
  private static validatePlugins(plugins: GeneratorConfig['plugins']): void {
    plugins.forEach((plugin) => {
      if (!plugin.name) {
        throw new Error('Plugin must have a name')
      }
      if (plugin.generators?.some((g) => !g.name || !g.generate)) {
        throw new Error(`Invalid generator in plugin ${plugin.name}`)
      }
    })
  }

  /**
   * Validates output configuration including format and structure
   */
  private static validateOutput(output: GeneratorConfig['output']): void {
    const validFormats = ['typescript', 'javascript']
    if (!validFormats.includes(output.format)) {
      throw new Error(`Invalid output format: ${output.format}`)
    }

    const validModuleSystems = ['esm', 'commonjs']
    if (!validModuleSystems.includes(output.moduleSystem)) {
      throw new Error(`Invalid module system: ${output.moduleSystem}`)
    }
  }

  /**
   * Validates hook configuration ensuring all hooks are functions
   */
  private static async validateHooks(hooks: GeneratorConfig['hooks']): Promise<void> {
    Object.entries(hooks).forEach(([name, hook]) => {
      if (hook && typeof hook !== 'function') {
        throw new Error(`Invalid hook: ${name}`)
      }
    })
  }

  /**
   * Validates a type converter ensuring it has all required methods
   */
  private static validateTypeConverter(type: string, converter: TypeConverter): void {
    const requiredMethods = ['toTypeScript', 'toDatabase', 'validate']
    requiredMethods.forEach((method) => {
      if (typeof converter[method] !== 'function') {
        throw new Error(`Type converter for ${type} missing required method: ${method}`)
      }
    })
  }

  /**
   * Validates a custom validation rule ensuring it has all required properties
   */
  private static validateCustomRule(rule: ValidationRuleDefinition): void {
    if (!rule.name || !rule.decorator || !rule.validate) {
      throw new Error('Custom validation rule missing required properties')
    }
    if (typeof rule.validate !== 'function') {
      throw new Error(`Invalid validator function for rule: ${rule.name}`)
    }
  }
}

================
File: core/default-config.ts
================
// tools/generators/dto/core/default-config.ts

import type { GeneratorConfig } from '../types'

/**
 * Default configuration for the DTO generator.
 * This provides sensible defaults for all configuration options
 * while allowing overrides through other configuration sources.
 */
export const defaultConfig: GeneratorConfig = {
  // Base configuration with essential paths
  templatesPath: './templates',
  outputPath: 'src/generated',
  prettierConfig: undefined,

  // Type system configuration with standard type mappings
  types: {
    defaultMappings: {
      // PostgreSQL to TypeScript type mappings
      varchar: 'string',
      text: 'string',
      char: 'string',
      int2: 'number',
      int4: 'number',
      int8: 'number',
      float4: 'number',
      float8: 'number',
      decimal: 'number',
      numeric: 'number',
      bool: 'boolean',
      timestamp: 'Date',
      timestamptz: 'Date',
      date: 'Date',
      time: 'string',
      timetz: 'string',
      interval: 'string',
      uuid: 'string',
      json: 'Record<string, any>',
      jsonb: 'Record<string, any>',
      bytea: 'Buffer',
    },
    customMappings: {},
    typeConverters: {},
    genericTypes: [
      {
        name: 'Array',
        typeParameters: 1,
        template: '${type}[]',
      },
      {
        name: 'Nullable',
        typeParameters: 1,
        template: '${type} | null',
      },
    ],
  },

  // Validation configuration
  validation: {
    enabledRules: [
      'IsNotEmpty',
      'IsOptional',
      'IsString',
      'IsNumber',
      'IsBoolean',
      'IsDate',
      'IsEmail',
      'MinLength',
      'MaxLength',
      'Min',
      'Max',
    ],
    customRules: [],
    messageTemplates: {
      required: '${field} is required',
      string: '${field} must be a string',
      number: '${field} must be a number',
      boolean: '${field} must be a boolean',
      date: '${field} must be a valid date',
      email: '${field} must be a valid email address',
      minLength: '${field} must be at least ${min} characters',
      maxLength: '${field} must be at most ${max} characters',
    },
    validators: {},
  },

  // Template configuration
  templates: {
    templatePaths: [],
    overrides: {},
    variables: {
      projectName: 'Generated DTOs',
      author: 'DTO Generator',
      version: '1.0.0',
    },
    functions: {},
  },

  // Plugin configuration
  plugins: [],

  // Output configuration
  output: {
    format: 'typescript',
    moduleSystem: 'esm',
    fileNaming: {
      case: 'kebab',
      prefix: '',
      suffix: '.dto',
    },
    structure: {
      baseDir: 'src/generated',
      separateDirectories: true,
      generateIndex: true,
    },
  },

  // Hooks configuration
  hooks: {},
}

================
File: decorators/custom.decorators.ts
================
// tools/generators/dto/decorators/custom.decorators.ts
import { TemplateSystem } from '../templates/template.system'

/**
 * Registry of custom decorators that can be used in DTO generation.
 * This allows users to extend the system with their own decorators.
 */
export function registerCustomDecorators(): void {
  // Register a custom logging decorator
  TemplateSystem.registerDecorator('Log', {
    importStatement: `import { Log } from '@/decorators/log.decorator'`,
    generate: (params?: string[]) => {
      const level = params?.[0] || 'debug'
      return `@Log('${level}')`
    },
  })

  // Register a custom validation decorator
  TemplateSystem.registerDecorator('ValidateBusinessRule', {
    importStatement: `import { ValidateBusinessRule } from '@/decorators/validation.decorator'`,
    generate: (params?: string[]) => {
      const [ruleName, errorMessage] = params || []
      return `@ValidateBusinessRule('${ruleName}', '${errorMessage}')`
    },
  })

  // Register a custom transformation decorator
  TemplateSystem.registerDecorator('TransformToDTO', {
    importStatement: `import { TransformToDTO } from '@/decorators/transform.decorator'`,
    generate: (params?: string[]) => {
      const dtoName = params?.[0]
      return `@TransformToDTO(${dtoName})`
    },
  })
}

================
File: modules/documentation.ts
================
// tools/generators/dto/modules/documentation.ts

import type {
  ModelMetadata,
  DocumentationMetadata,
  FieldMetadata,
  GeneratorOptions,
  EndpointMetadata,
  ValidationRule,
  RelationshipMetadata,
} from '../types'
import { FileManager } from '../utils/file-manager'

/**
 * Enhanced DocumentationGenerator that creates comprehensive documentation
 * covering API usage, database structure, and OpenAPI specifications.
 */
export class DocumentationGenerator {
  constructor(
    private readonly models: ModelMetadata[],
    private readonly options: GeneratorOptions,
    private readonly fileManager: FileManager,
  ) {}

  /**
   * Main generation process that coordinates the creation of all
   * documentation artifacts. Each piece of documentation serves a
   * different purpose and audience.
   */
  async generate(): Promise<void> {
    // Create the main API documentation
    await this.generateAPIDocumentation()

    // Create OpenAPI specification
    await this.generateOpenAPISpec()

    // Generate database documentation
    await this.generateDatabaseDocs()

    // Generate relationship diagrams
    await this.generateRelationshipDiagrams()

    // Generate example usage documentation
    await this.generateExampleDocs()
  }

  /**
   * Generates comprehensive API documentation including controller
   * usage, endpoint descriptions, and request/response examples.
   */
  private async generateAPIDocumentation(): Promise<void> {
    let content = '# API Documentation\n\n'

    // Add overview section
    content += this.generateOverview()

    // Generate documentation for each controller
    for (const model of this.models) {
      content += this.generateControllerDocs(model)
    }

    // Add authentication and error handling sections
    content += this.generateAuthenticationDocs()
    content += this.generateErrorHandlingDocs()

    await this.fileManager.writeFile('docs/API.md', content)
  }

  /**
   * Generates controller-specific documentation including all endpoints,
   * request/response formats, and validation rules.
   */
  private generateControllerDocs(model: ModelMetadata): string {
    let doc = `## ${model.name} Controller\n\n`
    doc += `${model.documentation.description}\n\n`

    // Base path information
    doc += `**Base Path:** \`/${model.name.toLowerCase()}\`\n\n`

    // Document each endpoint
    const endpoints = this.getControllerEndpoints(model)
    endpoints.forEach((endpoint) => {
      doc += this.generateEndpointDocs(endpoint, model)
    })

    return doc
  }

  /**
   * Generates detailed endpoint documentation including request/response
   * formats, validation rules, and example usage.
   */
  private generateEndpointDocs(endpoint: EndpointMetadata, model: ModelMetadata): string {
    let doc = `### ${endpoint.description}\n\n`

    // Method and path
    doc += `\`${endpoint.method} ${endpoint.path}\`\n\n`

    // Authentication requirements
    if (endpoint.auth) {
      doc += '**Authentication Required**\n\n'
    }

    // Request body documentation
    if (endpoint.requestBody) {
      doc += '#### Request Body\n\n'
      doc += this.generateTypeTable(endpoint.requestBody)
      doc += '\n\n#### Example Request\n\n'
      doc += '```json\n' + JSON.stringify(endpoint.example.request, null, 2) + '\n```\n\n'
    }

    // Response documentation
    doc += '#### Response\n\n'
    doc += this.generateTypeTable(endpoint.response)
    doc += '\n\n#### Example Response\n\n'
    doc += '```json\n' + JSON.stringify(endpoint.example.response, null, 2) + '\n```\n\n'

    // Validation rules
    doc += '#### Validation Rules\n\n'
    doc += this.generateValidationTable(model.fields)

    return doc
  }

  /**
   * Generates OpenAPI/Swagger specification file that can be used
   * with Swagger UI or other API documentation tools.
   */
  private async generateOpenAPISpec(): Promise<void> {
    const spec = {
      openapi: '3.0.0',
      info: {
        title: this.options.documentation.title,
        version: this.options.documentation.version,
        description: this.options.documentation.description,
      },
      paths: {},
      components: {
        schemas: {},
        securitySchemes: this.generateSecuritySchemes(),
      },
    }

    // Generate paths and schemas for each model
    for (const model of this.models) {
      spec.paths = {
        ...spec.paths,
        ...this.generateOpenAPIPaths(model),
      }
      spec.components.schemas = {
        ...spec.components.schemas,
        ...this.generateOpenAPISchemas(model),
      }
    }

    await this.fileManager.writeFile('docs/openapi.json', JSON.stringify(spec, null, 2))
  }

  /**
   * Generates database documentation including table structures,
   * relationships, and constraints.
   */
  private async generateDatabaseDocs(): Promise<void> {
    let content = '# Database Documentation\n\n'

    // Overview of database structure
    content += this.generateDatabaseOverview()

    // Document each table/view
    for (const model of this.models) {
      content += this.generateTableDocs(model)
    }

    // Add sections for indexes and constraints
    content += this.generateIndexDocs()
    content += this.generateConstraintDocs()

    await this.fileManager.writeFile('docs/DATABASE.md', content)
  }

  /**
   * Generates relationship diagrams using Mermaid syntax to visualize
   * database structure and entity relationships.
   */
  private async generateRelationshipDiagrams(): Promise<void> {
    let diagram = 'erDiagram\n'

    // Add entities
    this.models.forEach((model) => {
      diagram += this.generateEntityBlock(model)
    })

    // Add relationships
    this.models.forEach((model) => {
      model.relationships.forEach((rel) => {
        diagram += this.generateRelationshipLine(model, rel)
      })
    })

    await this.fileManager.writeFile('docs/diagrams/relationships.mmd', diagram)
  }

  /**
   * Generates detailed usage examples including common scenarios,
   * edge cases, and error handling.
   */
  private async generateExampleDocs(): Promise<void> {
    for (const model of this.models) {
      const examples = this.generateModelExamples(model)
      await this.fileManager.writeFile(`docs/examples/${model.name.toLowerCase()}.md`, examples)
    }
  }

  /**
   * Helper method to generate a table of type information for
   * request/response documentation.
   */
  private generateTypeTable(fields: FieldMetadata[]): string {
    return `| Field | Type | Required | Description |
|-------|------|----------|-------------|
${fields
  .map(
    (field) =>
      `| ${field.name} | ${field.type} | ${field.isRequired ? 'Yes' : 'No'} | ${field.documentation.description} |`,
  )
  .join('\n')}`
  }

  /**
   * Helper method to generate a table of validation rules for
   * a set of fields.
   */
  private generateValidationTable(fields: FieldMetadata[]): string {
    return `| Field | Validation Rules |
|-------|------------------|
${fields
  .map((field) => `| ${field.name} | ${this.formatValidationRules(field.validationRules)} |`)
  .join('\n')}`
  }

  /**
   * Helper method to generate an entity block in Mermaid syntax
   * for the relationship diagram.
   */
  private generateEntityBlock(model: ModelMetadata): string {
    return `  ${model.name} {
${model.fields.map((field) => `    ${field.type} ${field.name}`).join('\n')}
  }\n`
  }

  /**
   * Helper method to generate a relationship line in Mermaid syntax
   * for the relationship diagram.
   */
  private generateRelationshipLine(
    model: ModelMetadata,
    relationship: RelationshipMetadata,
  ): string {
    const cardinality = this.getRelationshipCardinality(relationship)
    return `  ${model.name} ${cardinality} ${relationship.foreign.model}\n`
  }

  /**
   * Determines the cardinality symbol for relationship diagrams.
   * This helps visualize how entities are related to each other.
   */
  private getRelationshipCardinality(relationship: RelationshipMetadata): string {
    const cardinalityMap = {
      'one-to-one': '||--||',
      'one-to-many': '||--{',
      'many-to-one': '}--||',
      'many-to-many': '}--{',
    }

    return cardinalityMap[relationship.relationType] || '||--||'
  }

  /**
   * Formats validation rules into a human-readable string.
   * This makes validation requirements clear in the documentation.
   */
  private formatValidationRules(rules: ValidationRule[]): string {
    if (!rules.length) return 'No validation rules'

    return rules
      .map((rule) => {
        if (rule.params) {
          return `${rule.decorator}(${rule.params.join(', ')})`
        }
        return rule.decorator
      })
      .join(', ')
  }

  /**
   * Generates comprehensive examples for a model, including common use cases
   * and edge cases that demonstrate proper usage.
   */
  private generateModelExamples(model: ModelMetadata): string {
    let examples = `# ${model.name} Examples\n\n`

    // Create example
    examples += `## Creating a ${model.name}\n\n`
    examples += '```typescript\n'
    examples += this.generateCreateExample(model)
    examples += '\n```\n\n'

    // Update example
    examples += `## Updating a ${model.name}\n\n`
    examples += '```typescript\n'
    examples += this.generateUpdateExample(model)
    examples += '\n```\n\n'

    // Query examples
    examples += `## Querying ${model.name}s\n\n`
    examples += '```typescript\n'
    examples += this.generateQueryExamples(model)
    examples += '\n```\n\n'

    // Error handling examples
    examples += `## Error Handling\n\n`
    examples += '```typescript\n'
    examples += this.generateErrorHandlingExamples(model)
    examples += '\n```\n'

    return examples
  }

  /**
   * Generates documentation for database constraints including foreign keys,
   * unique constraints, and check constraints.
   */
  private generateConstraintDocs(): string {
    let docs = '## Database Constraints\n\n'

    // Foreign Key Constraints
    docs += '### Foreign Key Constraints\n\n'
    this.models.forEach((model) => {
      model.relationships.forEach((rel) => {
        docs += `- ${model.name}.${rel.name} → ${rel.foreign.model}.${rel.foreign.field}\n`
      })
    })

    // Unique Constraints
    docs += '\n### Unique Constraints\n\n'
    this.models.forEach((model) => {
      const uniqueConstraints = this.getUniqueConstraints(model)
      uniqueConstraints.forEach((constraint) => {
        docs += `- ${model.name}: (${constraint.fields.join(', ')})\n`
      })
    })

    // Check Constraints
    docs += '\n### Check Constraints\n\n'
    this.models.forEach((model) => {
      const checkConstraints = this.getCheckConstraints(model)
      checkConstraints.forEach((constraint) => {
        docs += `- ${model.name}.${constraint.field}: ${constraint.condition}\n`
      })
    })

    return docs
  }

  /**
   * Generates documentation for database indexes including
   * their types, covered columns, and purposes.
   */
  private generateIndexDocs(): string {
    let docs = '## Database Indexes\n\n'

    this.models.forEach((model) => {
      docs += `### ${model.name} Indexes\n\n`

      const indexes = this.getModelIndexes(model)
      indexes.forEach((index) => {
        docs += `#### ${index.name}\n\n`
        docs += `- **Type:** ${index.type}\n`
        docs += `- **Columns:** ${index.columns.join(', ')}\n`
        docs += `- **Purpose:** ${index.purpose}\n\n`
      })
    })

    return docs
  }

  /**
   * Generates detailed documentation for a database table/view
   * including its structure, constraints, and usage.
   */
  private generateTableDocs(model: ModelMetadata): string {
    let docs = `## ${model.name}\n\n`
    docs += `${model.documentation.description}\n\n`

    // Table structure
    docs += '### Columns\n\n'
    docs += this.generateColumnTable(model.fields)

    // Primary Key
    docs += '\n### Primary Key\n\n'
    docs += this.getPrimaryKeyInfo(model)

    // Foreign Keys
    docs += '\n### Foreign Keys\n\n'
    model.relationships.forEach((rel) => {
      docs += `- ${rel.name} → ${rel.foreign.model} (${rel.relationType})\n`
    })

    // Indexes
    docs += '\n### Indexes\n\n'
    const indexes = this.getModelIndexes(model)
    indexes.forEach((index) => {
      docs += `- ${index.name} (${index.type}): ${index.columns.join(', ')}\n`
    })

    return docs
  }

  /**
   * Generates an overview of the database structure including
   * its schema, major entities, and their relationships.
   */
  private generateDatabaseOverview(): string {
    let overview = '## Database Overview\n\n'

    // List all entities
    overview += '### Entities\n\n'
    this.models.forEach((model) => {
      overview += `- **${model.name}**: ${model.documentation.description}\n`
    })

    // Key relationships
    overview += '\n### Key Relationships\n\n'
    this.models.forEach((model) => {
      model.relationships.forEach((rel) => {
        overview += `- ${model.name} ${this.getRelationshipCardinality(rel)} ${rel.foreign.model}\n`
      })
    })

    // Database notes
    overview += '\n### Important Notes\n\n'
    overview += '- All timestamps are stored in UTC\n'
    overview += '- Soft deletes are implemented using `deleted_at` column\n'
    overview += '- Foreign keys are enforced at the database level\n'

    return overview
  }

  /**
   * Generates OpenAPI parameter definition for ID parameters.
   * This is commonly used in endpoints that operate on specific resources.
   */
  private generateIdParameter(): any {
    return {
      name: 'id',
      in: 'path',
      required: true,
      description: 'Unique identifier of the resource',
      schema: {
        type: 'string',
        format: 'uuid',
      },
    }
  }

  /**
   * Creates a detailed example of creating a new entity.
   * This shows developers what fields are required and how to structure
   * their creation requests.
   */
  private generateCreateExample(model: ModelMetadata): string {
    const example = model.fields
      .filter((field) => !field.isComputed && field.name !== 'id')
      .reduce(
        (acc, field) => {
          acc[field.name] = this.generateExampleValue(field)
          return acc
        },
        {} as Record<string, any>,
      )

    return `// POST /${model.name.toLowerCase()}
const createPayload = ${JSON.stringify(example, null, 2)};

const response = await api.post('/${model.name.toLowerCase()}', createPayload);
`
  }

  /**
   * Creates a detailed example of updating an existing entity.
   * This demonstrates how to modify existing resources through the API.
   */
  private generateUpdateExample(model: ModelMetadata): string {
    const example = model.fields
      .filter((field) => !field.isComputed && !field.isRequired && field.name !== 'id')
      .reduce(
        (acc, field) => {
          acc[field.name] = this.generateExampleValue(field)
          return acc
        },
        {} as Record<string, any>,
      )

    return `// PATCH /${model.name.toLowerCase()}/{id}
const updatePayload = ${JSON.stringify(example, null, 2)};

const response = await api.patch('/${model.name.toLowerCase()}/123', updatePayload);
`
  }

  /**
   * Creates examples of different query operations.
   * This shows how to filter, sort, and paginate results.
   */
  private generateQueryExamples(model: ModelMetadata): string {
    return `// Basic query - Get all ${model.name}s
const allItems = await api.get('/${model.name.toLowerCase()}');

// Pagination
const pagedItems = await api.get('/${model.name.toLowerCase()}', {
params: {
  page: 1,
  limit: 10
}
});

// Filtering
const filteredItems = await api.get('/${model.name.toLowerCase()}', {
params: {
  filter: {
    ${model.fields[0].name}: 'value'
  }
}
});

// Sorting
const sortedItems = await api.get('/${model.name.toLowerCase()}', {
params: {
  sort: '${model.fields[0].name}:desc'
}
});
`
  }

  /**
   * Creates examples of error handling scenarios.
   * This helps developers understand how to handle various error cases.
   */
  private generateErrorHandlingExamples(model: ModelMetadata): string {
    return `// Handle validation errors
try {
const response = await api.post('/${model.name.toLowerCase()}', {});
} catch (error) {
if (error.response?.status === 422) {
  const validationErrors = error.response.data.errors;
  console.error('Validation failed:', validationErrors);
}
}

// Handle not found errors
try {
const response = await api.get('/${model.name.toLowerCase()}/nonexistent');
} catch (error) {
if (error.response?.status === 404) {
  console.error('Resource not found');
}
}

// Handle authentication errors
try {
const response = await api.get('/${model.name.toLowerCase()}');
} catch (error) {
if (error.response?.status === 401) {
  console.error('Authentication required');
}
}
`
  }

  /**
   * Gets the unique constraints for a model.
   * This extracts unique constraints from model metadata to document
   * data integrity rules.
   */
  private getUniqueConstraints(model: ModelMetadata): Array<{ fields: string[] }> {
    const constraints: Array<{ fields: string[] }> = []

    // Single-field unique constraints
    model.fields
      .filter((field) => field.validationRules.some((rule) => rule.decorator === 'IsUnique'))
      .forEach((field) => {
        constraints.push({ fields: [field.name] })
      })

    // Composite unique constraints from model metadata
    const compositeUnique = model.documentation.description.match(/@unique\s+\[(.*?)\]/g)
    if (compositeUnique) {
      compositeUnique.forEach((constraint) => {
        const fields = constraint
          .replace('@unique [', '')
          .replace(']', '')
          .split(',')
          .map((field) => field.trim())
        constraints.push({ fields })
      })
    }

    return constraints
  }

  /**
   * Gets the check constraints for a model.
   * This extracts check constraints from model metadata to document
   * business rules enforced at the database level.
   */
  private getCheckConstraints(model: ModelMetadata): Array<{ field: string; condition: string }> {
    const constraints: Array<{ field: string; condition: string }> = []

    model.fields.forEach((field) => {
      const checkConstraint = field.documentation.description.match(/@check\s+{([^}]+)}/)
      if (checkConstraint) {
        constraints.push({
          field: field.name,
          condition: checkConstraint[1].trim(),
        })
      }
    })

    return constraints
  }

  /**
   * Gets the indexes defined for a model.
   * This extracts index information from model metadata to document
   * performance optimization structures.
   */
  private getModelIndexes(model: ModelMetadata): Array<{
    name: string
    type: string
    columns: string[]
    purpose: string
  }> {
    const indexes: Array<{
      name: string
      type: string
      columns: string[]
      purpose: string
    }> = []

    // Extract index information from model metadata
    const indexMatches = model.documentation.description.match(/@index\s+{([^}]+)}/g)
    if (indexMatches) {
      indexMatches.forEach((indexStr) => {
        const [name, type, columnsStr, purpose] = indexStr
          .replace('@index {', '')
          .replace('}', '')
          .split('|')
          .map((s) => s.trim())

        indexes.push({
          name,
          type,
          columns: columnsStr.split(',').map((c) => c.trim()),
          purpose,
        })
      })
    }

    return indexes
  }

  /**
   * Generates a formatted table of column information.
   * This creates a markdown table documenting all columns in a model.
   */
  private generateColumnTable(fields: FieldMetadata[]): string {
    let table = '| Column | Type | Nullable | Default | Description |\n'
    table += '|--------|------|----------|----------|-------------|\n'

    fields.forEach((field) => {
      table += `| ${field.name} | ${field.type} | ${field.isRequired ? 'No' : 'Yes'} | ${
        field.documentation.description.match(/@default\s+([^\s]+)/)?.[1] || 'NULL'
      } | ${field.documentation.description.split('.')[0]} |\n`
    })

    return table
  }

  /**
   * Gets primary key information for a model.
   * This documents the primary key structure and constraints.
   */
  private getPrimaryKeyInfo(model: ModelMetadata): string {
    const pkFields = model.fields.filter((field) =>
      field.validationRules.some((rule) => rule.decorator === 'IsPrimaryKey'),
    )

    if (pkFields.length === 0) {
      return 'Primary Key: id (auto-generated UUID)'
    }

    return `Primary Key: ${pkFields.map((field) => field.name).join(', ')}`
  }

  /**
   * Generates OpenAPI schema definitions for all our models.
   * These schemas define the structure and validation rules for our API's
   * data models in a format that OpenAPI tools can understand.
   */
  private generateOpenAPISchemas(model: ModelMetadata): Record<string, any> {
    const schemas: Record<string, any> = {}

    // Generate the main model schema
    schemas[model.name] = {
      type: 'object',
      description: model.documentation.description,
      properties: this.generateSchemaProperties(model.fields),
      required: this.getRequiredFields(model.fields),
    }

    // Generate schemas for nested types and related models
    model.relationships.forEach((relationship) => {
      if (!schemas[relationship.foreign.model]) {
        const relatedModel = this.findModelByName(relationship.foreign.model)
        if (relatedModel) {
          schemas[relationship.foreign.model] = {
            type: 'object',
            description: relatedModel.documentation.description,
            properties: this.generateSchemaProperties(relatedModel.fields),
            required: this.getRequiredFields(relatedModel.fields),
          }
        }
      }
    })

    return schemas
  }

  /**
   * Generates OpenAPI path definitions for our API endpoints.
   * This includes all the CRUD operations and their request/response
   * specifications, making our API self-documenting.
   */
  private generateOpenAPIPaths(model: ModelMetadata): Record<string, any> {
    const basePath = `/${model.name.toLowerCase()}`
    const paths: Record<string, any> = {}

    // GET collection endpoint
    paths[basePath] = {
      get: {
        summary: `Get all ${model.name}s`,
        description: `Retrieves a list of ${model.name} entities`,
        tags: [model.name],
        parameters: this.generateQueryParameters(model),
        responses: {
          '200': {
            description: 'Successful response',
            content: {
              'application/json': {
                schema: {
                  type: 'array',
                  items: { $ref: `#/components/schemas/${model.name}` },
                },
              },
            },
          },
          ...this.generateCommonResponses(),
        },
      },
      post: {
        summary: `Create a new ${model.name}`,
        description: `Creates a new ${model.name} entity`,
        tags: [model.name],
        requestBody: {
          required: true,
          content: {
            'application/json': {
              schema: { $ref: `#/components/schemas/${model.name}` },
            },
          },
        },
        responses: {
          '201': {
            description: 'Created successfully',
            content: {
              'application/json': {
                schema: { $ref: `#/components/schemas/${model.name}` },
              },
            },
          },
          ...this.generateCommonResponses(),
        },
      },
    }

    // Individual resource endpoints
    paths[`${basePath}/{id}`] = {
      get: {
        summary: `Get a specific ${model.name}`,
        description: `Retrieves a single ${model.name} entity by ID`,
        tags: [model.name],
        parameters: [this.generateIdParameter()],
        responses: {
          '200': {
            description: 'Successful response',
            content: {
              'application/json': {
                schema: { $ref: `#/components/schemas/${model.name}` },
              },
            },
          },
          ...this.generateCommonResponses(),
        },
      },
      patch: {
        summary: `Update a ${model.name}`,
        description: `Updates an existing ${model.name} entity`,
        tags: [model.name],
        parameters: [this.generateIdParameter()],
        requestBody: {
          required: true,
          content: {
            'application/json': {
              schema: { $ref: `#/components/schemas/${model.name}` },
            },
          },
        },
        responses: {
          '200': {
            description: 'Updated successfully',
            content: {
              'application/json': {
                schema: { $ref: `#/components/schemas/${model.name}` },
              },
            },
          },
          ...this.generateCommonResponses(),
        },
      },
      delete: {
        summary: `Delete a ${model.name}`,
        description: `Deletes a ${model.name} entity`,
        tags: [model.name],
        parameters: [this.generateIdParameter()],
        responses: {
          '204': {
            description: 'Deleted successfully',
          },
          ...this.generateCommonResponses(),
        },
      },
    }

    return paths
  }

  /**
   * Generates security scheme definitions for our API.
   * This tells API consumers how to authenticate their requests,
   * whether through JWT tokens, API keys, or other methods.
   */
  private generateSecuritySchemes(): Record<string, any> {
    return {
      bearerAuth: {
        type: 'http',
        scheme: 'bearer',
        bearerFormat: 'JWT',
        description: 'JWT token authentication',
      },
      apiKeyAuth: {
        type: 'apiKey',
        in: 'header',
        name: 'X-API-KEY',
        description: 'API key authentication',
      },
    }
  }

  /**
   * Helper method to generate schema properties from field metadata.
   * This converts our internal field definitions into OpenAPI-compatible
   * property definitions.
   */
  private generateSchemaProperties(fields: FieldMetadata[]): Record<string, any> {
    const properties: Record<string, any> = {}

    fields.forEach((field) => {
      properties[field.name] = {
        type: this.mapTypeToOpenAPI(field.type),
        description: field.documentation.description,
        example: field.documentation.example,
      }

      // Add format for special types
      if (field.type === 'Date') {
        properties[field.name].format = 'date-time'
      }

      // Add validation constraints
      if (field.validationRules.length > 0) {
        this.addValidationToSchema(properties[field.name], field.validationRules)
      }
    })

    return properties
  }

  /**
   * Helper method to find required fields in a model.
   * This helps generate accurate OpenAPI schemas that reflect
   * our data validation rules.
   */
  private getRequiredFields(fields: FieldMetadata[]): string[] {
    return fields.filter((field) => field.isRequired).map((field) => field.name)
  }

  /**
   * Helper method to map our internal types to OpenAPI types.
   * This ensures our API documentation uses standard OpenAPI type definitions.
   */
  private mapTypeToOpenAPI(type: string): string {
    const typeMap: Record<string, string> = {
      string: 'string',
      number: 'number',
      boolean: 'boolean',
      Date: 'string',
      Object: 'object',
      Array: 'array',
    }

    return typeMap[type] || 'string'
  }

  /**
   * Helper method to add validation rules to OpenAPI schemas.
   * This ensures our API documentation includes all validation constraints.
   */
  private addValidationToSchema(schema: any, rules: ValidationRule[]): void {
    rules.forEach((rule) => {
      switch (rule.decorator) {
        case 'MinLength':
          schema.minLength = rule.params?.[0]
          break
        case 'MaxLength':
          schema.maxLength = rule.params?.[0]
          break
        case 'Min':
          schema.minimum = rule.params?.[0]
          break
        case 'Max':
          schema.maximum = rule.params?.[0]
          break
        case 'Pattern':
          schema.pattern = rule.params?.[0]
          break
      }
    })
  }

  /**
   * Helper method to find a model by its name.
   * Used when generating related model schemas.
   */
  private findModelByName(name: string): ModelMetadata | undefined {
    return this.models.find((model) => model.name === name)
  }

  /**
   * Retrieves all available endpoints for a given controller.
   * This method analyzes the model metadata to determine what
   * endpoints should be available based on the model's properties
   * and relationships.
   */
  private getControllerEndpoints(model: ModelMetadata): EndpointMetadata[] {
    const basePath = `/${model.name.toLowerCase()}`
    const endpoints: EndpointMetadata[] = [
      // GET collection endpoint
      {
        method: 'GET',
        path: basePath,
        description: `Retrieve all ${model.name}s`,
        auth: true,
        response: {
          type: 'array',
          items: model,
        },
        example: {
          request: null,
          response: this.generateCollectionExample(model),
        },
      },
      // POST create endpoint
      {
        method: 'POST',
        path: basePath,
        description: `Create a new ${model.name}`,
        auth: true,
        requestBody: model,
        response: model,
        example: {
          request: this.generateCreateExample(model),
          response: this.generateSingleExample(model),
        },
      },
      // GET single item endpoint
      {
        method: 'GET',
        path: `${basePath}/:id`,
        description: `Retrieve a single ${model.name} by ID`,
        auth: true,
        response: model,
        example: {
          request: null,
          response: this.generateSingleExample(model),
        },
      },
      // PATCH update endpoint
      {
        method: 'PATCH',
        path: `${basePath}/:id`,
        description: `Update an existing ${model.name}`,
        auth: true,
        requestBody: model,
        response: model,
        example: {
          request: this.generateUpdateExample(model),
          response: this.generateSingleExample(model),
        },
      },
      // DELETE endpoint
      {
        method: 'DELETE',
        path: `${basePath}/:id`,
        description: `Delete a ${model.name}`,
        auth: true,
        response: null,
        example: {
          request: null,
          response: null,
        },
      },
    ]

    // Add relationship endpoints if they exist
    model.relationships.forEach((relationship) => {
      endpoints.push(this.generateRelationshipEndpoint(model, relationship))
    })

    return endpoints
  }

  /**
   * Generates the documentation for error handling across the API.
   * This includes standard error responses, validation errors,
   * and business logic errors.
   */
  private generateErrorHandlingDocs(): string {
    let docs = '## Error Handling\n\n'
    docs +=
      'This API uses conventional HTTP response codes to indicate the success or failure of requests.\n\n'

    // Standard error codes
    docs += '### HTTP Status Codes\n\n'
    docs += '| Code | Description |\n'
    docs += '|------|-------------|\n'
    docs += '| 200  | Success - The request was processed successfully |\n'
    docs += '| 201  | Created - A new resource was created successfully |\n'
    docs +=
      '| 400  | Bad Request - The request could not be understood or was missing required parameters |\n'
    docs += '| 401  | Unauthorized - Authentication failed or user lacks necessary permissions |\n'
    docs += '| 404  | Not Found - Resource not found |\n'
    docs += '| 422  | Validation Error - Request validation failed |\n'
    docs += '| 500  | Server Error - Something went wrong on our end |\n\n'

    // Validation errors
    docs += '### Validation Errors\n\n'
    docs +=
      'When a request fails validation, the response will include detailed error information:\n\n'
    docs += '```json\n'
    docs += `{
  "statusCode": 422,
  "message": "Validation failed",
  "errors": [
    {
      "field": "email",
      "message": "Must be a valid email address"
    }
  ]
}\n`
    docs += '```\n\n'

    // Business logic errors
    docs += '### Business Logic Errors\n\n'
    docs += 'These errors occur when a request violates business rules:\n\n'
    docs += '```json\n'
    docs += `{
  "statusCode": 400,
  "message": "Cannot delete an active subscription",
  "code": "ACTIVE_SUBSCRIPTION"
}\n`
    docs += '```\n'

    return docs
  }

  /**
   * Generates documentation about authentication mechanisms
   * and security requirements for the API.
   */
  private generateAuthenticationDocs(): string {
    let docs = '## Authentication\n\n'
    docs +=
      'This API uses JWT Bearer token authentication. All authenticated endpoints require a valid JWT token.\n\n'

    // Token acquisition
    docs += '### Obtaining a Token\n\n'
    docs += 'To obtain a token, make a POST request to the authentication endpoint:\n\n'
    docs += '```bash\n'
    docs += 'curl -X POST /auth/login \\\n'
    docs += '  -H "Content-Type: application/json" \\\n'
    docs += '  -d \'{"email": "user@example.com", "password": "yourpassword"}\'\n'
    docs += '```\n\n'

    // Using tokens
    docs += '### Using the Token\n\n'
    docs += 'Include the token in the Authorization header of your requests:\n\n'
    docs += '```bash\n'
    docs += 'curl -X GET /api/resource \\\n'
    docs += '  -H "Authorization: Bearer your.jwt.token"\n'
    docs += '```\n\n'

    // Token refresh
    docs += '### Token Refresh\n\n'
    docs += 'Tokens expire after 24 hours. Use the refresh endpoint to obtain a new token:\n\n'
    docs += '```bash\n'
    docs += 'curl -X POST /auth/refresh \\\n'
    docs += '  -H "Authorization: Bearer your.refresh.token"\n'
    docs += '```\n'

    return docs
  }

  /**
   * Generates a high-level overview of the API, including its
   * purpose, main features, and general usage guidelines.
   */
  private generateOverview(): string {
    let overview = '## Overview\n\n'
    overview += 'This API provides a RESTful interface for managing application resources. '
    overview += 'It follows REST principles and uses standard HTTP methods for operations.\n\n'

    // Base URL
    overview += '### Base URL\n\n'
    overview += '```\n'
    overview += 'https://api.example.com/v1\n'
    overview += '```\n\n'

    // Versioning
    overview += '### API Versioning\n\n'
    overview += 'The API version is included in the URL path. The current version is `v1`.\n\n'

    // Content Types
    overview += '### Content Types\n\n'
    overview += 'The API accepts and returns JSON data. All requests must include:\n\n'
    overview += '```\n'
    overview += 'Content-Type: application/json\n'
    overview += 'Accept: application/json\n'
    overview += '```\n\n'

    // Rate Limiting
    overview += '### Rate Limiting\n\n'
    overview +=
      'Requests are limited to 100 per minute per API key. Rate limit information is included in response headers:\n\n'
    overview += '```\n'
    overview += 'X-RateLimit-Limit: 100\n'
    overview += 'X-RateLimit-Remaining: 95\n'
    overview += 'X-RateLimit-Reset: 1623456789\n'
    overview += '```\n'

    return overview
  }

  /**
   * Generates documentation for endpoints that handle relationships between models.
   * This creates documentation for nested resources and related entity endpoints,
   * showing how to access and manipulate related data.
   */
  private generateRelationshipEndpoint(
    model: ModelMetadata,
    relationship: RelationshipMetadata,
  ): EndpointMetadata {
    const basePath = `/${model.name.toLowerCase()}`
    const relationPath = relationship.name.toLowerCase()

    // The structure changes based on the relationship type
    if (
      relationship.relationType === 'one-to-many' ||
      relationship.relationType === 'many-to-many'
    ) {
      return {
        method: 'GET',
        path: `${basePath}/:id/${relationPath}`,
        description: `Retrieve all ${relationship.name} for a ${model.name}`,
        auth: true,
        response: {
          type: 'array',
          items: {
            type: relationship.foreign.model,
          },
        },
        example: {
          request: null,
          response: this.generateRelationshipExample(relationship),
        },
      }
    } else {
      return {
        method: 'GET',
        path: `${basePath}/:id/${relationPath}`,
        description: `Retrieve the ${relationship.name} for a ${model.name}`,
        auth: true,
        response: {
          type: relationship.foreign.model,
        },
        example: {
          request: null,
          response: this.generateSingleExample(this.findModelByName(relationship.foreign.model)),
        },
      }
    }
  }

  /**
   * Generates an example of a single resource response.
   * This creates realistic example data for each field in the model,
   * helping developers understand what the API returns.
   */
  private generateSingleExample(model: ModelMetadata | undefined): any {
    if (!model) return {}

    const example: Record<string, any> = {}

    model.fields.forEach((field) => {
      // Use explicit example if provided in documentation
      if (field.documentation.example !== undefined) {
        example[field.name] = field.documentation.example
        return
      }

      // Generate sensible defaults based on field type
      example[field.name] = this.generateExampleValue(field)
    })

    return example
  }

  /**
   * Generates an example of a collection response.
   * This creates an array of example resources, showing how
   * list endpoints return multiple items.
   */
  private generateCollectionExample(model: ModelMetadata): any[] {
    // Generate three example items to show variation
    return [
      this.generateSingleExample(model),
      this.generateSingleExample(model),
      this.generateSingleExample(model),
    ].map((example, index) => ({
      ...example,
      id: index + 1, // Ensure unique IDs in collection
    }))
  }

  /**
   * Generates common response definitions used across multiple endpoints.
   * This includes standard error responses and validation failures that
   * might occur in any endpoint.
   */
  private generateCommonResponses(): Record<string, any> {
    return {
      '400': {
        description: 'Bad Request - The request could not be understood',
        content: {
          'application/json': {
            schema: {
              type: 'object',
              properties: {
                statusCode: {
                  type: 'number',
                  example: 400,
                },
                message: {
                  type: 'string',
                  example: 'Invalid request parameters',
                },
                errors: {
                  type: 'array',
                  items: {
                    type: 'object',
                    properties: {
                      field: {
                        type: 'string',
                      },
                      message: {
                        type: 'string',
                      },
                    },
                  },
                },
              },
            },
          },
        },
      },
      '401': {
        description: 'Unauthorized - Authentication is required',
        content: {
          'application/json': {
            schema: {
              type: 'object',
              properties: {
                statusCode: {
                  type: 'number',
                  example: 401,
                },
                message: {
                  type: 'string',
                  example: 'Authentication required',
                },
              },
            },
          },
        },
      },
      '403': {
        description: 'Forbidden - Insufficient permissions',
        content: {
          'application/json': {
            schema: {
              type: 'object',
              properties: {
                statusCode: {
                  type: 'number',
                  example: 403,
                },
                message: {
                  type: 'string',
                  example: 'Insufficient permissions to access this resource',
                },
              },
            },
          },
        },
      },
      '404': {
        description: 'Not Found - The requested resource does not exist',
        content: {
          'application/json': {
            schema: {
              type: 'object',
              properties: {
                statusCode: {
                  type: 'number',
                  example: 404,
                },
                message: {
                  type: 'string',
                  example: 'Resource not found',
                },
              },
            },
          },
        },
      },
    }
  }

  /**
   * Helper method to generate realistic example values for different field types.
   * This creates appropriate sample data based on the field's type and validation rules.
   */
  private generateExampleValue(field: FieldMetadata): any {
    switch (field.type) {
      case 'string':
        return this.generateStringExample(field)
      case 'number':
        return this.generateNumberExample(field)
      case 'boolean':
        return true
      case 'Date':
        return new Date().toISOString()
      case 'object':
        return this.generateObjectExample(field)
      default:
        return null
    }
  }

  /**
   * Helper method to generate example strings based on field context.
   */
  private generateStringExample(field: FieldMetadata): string {
    // Use field name to generate contextual examples
    if (field.name.includes('email')) {
      return 'user@example.com'
    }
    if (field.name.includes('name')) {
      return 'John Doe'
    }
    if (field.name.includes('phone')) {
      return '+1 (555) 123-4567'
    }
    return 'example'
  }

  /**
   * Helper method to generate example numbers based on field context.
   */
  private generateNumberExample(field: FieldMetadata): number {
    // Use validation rules to generate appropriate numbers
    const min = field.validationRules.find((rule) => rule.decorator === 'Min')?.params?.[0] ?? 0
    const max = field.validationRules.find((rule) => rule.decorator === 'Max')?.params?.[0] ?? 100
    return Math.floor((min + max) / 2)
  }

  /**
   * Helper method to generate example objects for complex fields.
   */
  private generateObjectExample(field: FieldMetadata): Record<string, any> {
    // If we have a nested type definition, use it
    if (field.nestedType) {
      return this.generateSingleExample(this.findModelByName(field.nestedType))
    }
    return {}
  }

  /**
   * Generates OpenAPI parameter definitions for query parameters.
   * This method creates documentation for common query parameters like
   * pagination, filtering, and sorting that can be used to customize
   * API responses.
   */
  private generateQueryParameters(model: ModelMetadata): any[] {
    const parameters = [
      // Pagination parameters
      {
        name: 'page',
        in: 'query',
        required: false,
        description: 'Page number for paginated results',
        schema: {
          type: 'integer',
          minimum: 1,
          default: 1,
        },
      },
      {
        name: 'limit',
        in: 'query',
        required: false,
        description: 'Number of items per page',
        schema: {
          type: 'integer',
          minimum: 1,
          maximum: 100,
          default: 10,
        },
      },
    ]

    // Add filter parameters based on filterable fields
    model.fields
      .filter((field) => this.isFilterableField(field))
      .forEach((field) => {
        parameters.push({
          name: `filter[${field.name}]`,
          in: 'query',
          required: false,
          description: `Filter results by ${field.name}`,
          schema: {
            type: this.mapTypeToOpenAPI(field.type),
          },
        })
      })

    return parameters
  }

  /**
   * Generates example responses for relationship endpoints.
   * This method creates realistic example data for related entities,
   * showing how relationship data is structured in API responses.
   */
  private generateRelationshipExample(relationship: RelationshipMetadata): any {
    // Find the related model
    const relatedModel = this.findModelByName(relationship.foreign.model)
    if (!relatedModel) {
      return []
    }

    // For one-to-many or many-to-many relationships, generate an array of examples
    if (
      relationship.relationType === 'one-to-many' ||
      relationship.relationType === 'many-to-many'
    ) {
      return [
        this.generateRelatedEntityExample(relatedModel, relationship),
        this.generateRelatedEntityExample(relatedModel, relationship),
      ]
    }

    // For one-to-one or many-to-one relationships, generate a single example
    return this.generateRelatedEntityExample(relatedModel, relationship)
  }

  /**
   * Helper method to generate an example of a related entity.
   * This creates realistic example data while maintaining referential integrity
   * in the examples.
   */
  private generateRelatedEntityExample(
    model: ModelMetadata,
    relationship: RelationshipMetadata,
  ): any {
    const example = this.generateSingleExample(model)

    // Add relationship-specific fields
    if (relationship.foreign.field) {
      example[relationship.foreign.field] = this.generateExampleId()
    }

    return example
  }

  /**
   * Helper method to determine if a field should be available for filtering.
   * Not all fields make sense as filter parameters, so we need to be selective.
   */
  private isFilterableField(field: FieldMetadata): boolean {
    // Don't allow filtering on computed fields or complex objects
    if (field.isComputed || field.type === 'object') {
      return false
    }

    // Don't allow filtering on sensitive fields
    const sensitiveFields = ['password', 'token', 'secret']
    if (sensitiveFields.includes(field.name)) {
      return false
    }

    // Allow filtering on basic types that make sense to filter by
    const filterableTypes = ['string', 'number', 'boolean', 'Date']
    return filterableTypes.includes(field.type)
  }

  /**
   * Helper method to generate example IDs for relationships.
   * This ensures our examples use consistent ID formats.
   */
  private generateExampleId(): string {
    // Generate a UUID-like string for example IDs
    return '123e4567-e89b-12d3-a456-426614174000'
  }
}

================
File: modules/interfaces.ts
================
// tools/generators/dto/modules/interface.generator.ts
import { TypeMapper } from '../utils/type-mapper'
import { DocumentationParser } from '../utils/documentation-parser'
import { TemplateEngine } from '../templates/template.engine'
import type { ModelMetadata, FieldMetadata, RelationshipMetadata, ValidationRule } from '../types'

/**
 * InterfaceGenerator creates TypeScript interfaces from model metadata
 * using a template-based approach.
 */
export class InterfaceGenerator {
  constructor(
    private readonly typeMapper: TypeMapper,
    private readonly documentationParser: DocumentationParser,
  ) {}

  /**
   * Generates a complete interface file from model metadata
   */
  generateInterface(metadata: ModelMetadata): string {
    if (metadata.isView) {
      return this.generateViewInterface(metadata)
    }
    return this.generateModelInterface(metadata)
  }

  /**
   * Generates an interface for a database model
   */
  private generateModelInterface(metadata: ModelMetadata): string {
    const context = {
      model: metadata,
      imports: this.prepareImports(metadata),
      fields: this.prepareFields(metadata.fields),
      relations: this.prepareRelations(metadata.relations),
      documentation: this.prepareDocumentation(metadata),
    }

    // Change from 'interface/model.interface.hbs' to 'interface/model.interface'
    return TemplateEngine.process('interface/model.interface', context)
  }

  /**
   * Generates an interface for a database view
   */
  private generateViewInterface(metadata: ModelMetadata): string {
    const context = {
      model: metadata,
      imports: this.prepareImports(metadata),
      fields: this.prepareFields(metadata.fields),
      computedColumns: metadata.viewMetadata?.computedColumns || [],
      documentation: this.prepareDocumentation(metadata),
    }

    return TemplateEngine.process('interface/view', context)
  }

  /**
   * Prepares imports for the interface
   */
  private prepareImports(metadata: ModelMetadata): string[] {
    const imports = ['BaseEntity']

    if (metadata.relations?.length) {
      // Add imports for related interfaces
      imports.push(...metadata.relations.map((rel) => `I${rel.type}`))
    }

    // Add any validation-related imports if needed
    if (metadata.fields.some((f) => f.validationRules?.length)) {
      imports.push('ValidationError')
    }

    return imports
  }

  /**
   * Prepares field metadata for the template
   */
  private prepareFields(fields: FieldMetadata[]): any[] {
    return fields.map((field) => ({
      ...field,
      tsType: this.typeMapper.mapFieldType(field),
      documentation: this.documentationParser.parseFieldDocumentation(field),
      validationDescription: this.formatValidationRules(field.validationRules),
    }))
  }

  /**
   * Prepares relation metadata for the template
   */
  private prepareRelations(relations: RelationshipMetadata[]): any[] {
    return relations.map((relation) => ({
      ...relation,
      interfaceType: `I${relation.type}`,
      isArray: relation.relationType.includes('many'),
      documentation: {
        description: `${relation.name} ${relation.relationType} ${relation.foreign.model}`,
      },
    }))
  }

  /**
   * Prepares documentation metadata for the template
   */
  private prepareDocumentation(metadata: ModelMetadata): any {
    const docs = metadata.documentation || {}

    if (metadata.isView) {
      return {
        ...docs,
        description: `Interface for ${metadata.name} database view\n${docs.description || ''}`,
        sourceQuery: metadata.viewMetadata?.sourceQuery,
      }
    }

    return {
      ...docs,
      description: `Interface for ${metadata.name} database model\n${docs.description || ''}`,
    }
  }

  /**
   * Formats validation rules into a readable string for documentation
   */
  private formatValidationRules(rules?: ValidationRule[]): string {
    if (!rules?.length) return ''

    return rules
      .map((rule) => {
        const params = rule.parameters ? `(${rule.parameters.join(', ')})` : ''
        return `@${rule.decorator}${params} - ${rule.message}`
      })
      .join('\n')
  }
}

================
File: modules/openapi-metadata.ts
================
// tools/generators/dto/modules/openapi-metadata.ts

import { TypeMapper } from '../utils/type-mapper'
import type { ModelMetadata, FieldMetadata, ValidationRule } from '../types'

/**
 * OpenAPIMetadataGenerator handles the creation of comprehensive OpenAPI/Swagger
 * decorators and metadata. It ensures our DTOs are properly documented for API
 * consumers with complete type information, examples, and security schemes.
 */
export class OpenAPIMetadataGenerator {
  constructor(private readonly typeMapper: TypeMapper) {}

  /**
   * Generates all OpenAPI decorators for a DTO class. This includes class-level
   * decorators for response types and field-level decorators for properties.
   */
  generateOpenAPIMetadata(model: ModelMetadata): string {
    const imports = this.generateSwaggerImports()
    const classDecorators = this.generateClassDecorators(model)
    const propertyDecorators = this.generatePropertyDecorators(model.fields)

    return `
${imports}

${classDecorators}
export class ${model.name}DTO {
${propertyDecorators}
}
`
  }

  /**
   * Generates necessary imports for OpenAPI decorators. We import everything we
   * need from @nestjs/swagger to support our enhanced documentation.
   */
  private generateSwaggerImports(): string {
    return `
        import {
        ApiProperty,
        ApiPropertyOptional,
        ApiExtraModels,
        ApiResponse,
        ApiResponseType,
        ApiTags,
        getSchemaPath,
        ApiBasicAuth,
        ApiBearerAuth,
        ApiOAuth2,
        ApiCookieAuth
        } from '@nestjs/swagger';
        `
  }

  /**
   * Generates class-level OpenAPI decorators including response types,
   * authentication requirements, and tags for API grouping.
   */
  private generateClassDecorators(model: ModelMetadata): string {
    const { documentation } = model

    // Build array of class decorators
    const decorators = [
      `@ApiTags('${model.name}')`,
      this.generateAuthDecorators(model),
      this.generateResponseDecorators(model),
      this.generateExtraModelsDecorator(model),
    ].filter(Boolean)

    return decorators.join('\n')
  }

  /**
   * Generates @ApiProperty decorators for each field with comprehensive
   * metadata including type information, examples, and validation rules.
   */
  private generatePropertyDecorators(fields: FieldMetadata[]): string {
    return fields
      .map((field) => {
        const propertyDecorator = field.isRequired ? '@ApiProperty' : '@ApiPropertyOptional'
        const options = this.buildPropertyOptions(field)

        return `  ${propertyDecorator}(${options})
  ${field.name}${field.isRequired ? '' : '?'}: ${this.typeMapper.mapPrismaToTypeScript(field)};`
      })
      .join('\n\n')
  }

  /**
   * Builds comprehensive options for @ApiProperty decorators including
   * type information, examples, and nested schema references.
   */
  private buildPropertyOptions(field: FieldMetadata): string {
    const options: Record<string, any> = {
      description: field.documentation.description,
      type: OpenAPIMetadataGenerator.getSwaggerType(field),
      example: this.generateExample(field),
    }

    // Add validation rules metadata
    if (field.validationRules.length > 0) {
      options.minimum = this.extractMinimum(field.validationRules)
      options.maximum = this.extractMaximum(field.validationRules)
      options.minLength = this.extractMinLength(field.validationRules)
      options.maxLength = this.extractMaxLength(field.validationRules)
      options.pattern = this.extractPattern(field.validationRules)
    }

    // Add enum values if applicable
    if (field.type === 'enum') {
      options.enum = this.extractEnumValues(field)
    }

    // Add nested schema references if needed
    if (this.isComplexType(field)) {
      options.schema = this.generateNestedSchema(field)
    }

    return this.serializeOptions(options)
  }

  /**
   * Generates authentication decorators based on security schemes
   * defined in the model's metadata.
   */
  private generateAuthDecorators(model: ModelMetadata): string {
    const authDecorators: string[] = []
    const securitySchemes = this.extractSecuritySchemes(model)

    securitySchemes.forEach((scheme) => {
      switch (scheme.type) {
        case 'bearer':
          authDecorators.push('@ApiBearerAuth()')
          break
        case 'basic':
          authDecorators.push('@ApiBasicAuth()')
          break
        case 'oauth2':
          authDecorators.push(`@ApiOAuth2(${JSON.stringify(scheme.flows)})`)
          break
        case 'cookie':
          authDecorators.push(`@ApiCookieAuth('${scheme.name}')`)
          break
      }
    })

    return authDecorators.join('\n')
  }

  /**
   * Generates response decorators with proper type information and
   * status codes. Handles both success and error responses.
   */
  private generateResponseDecorators(model: ModelMetadata): string {
    const responseDecorators: string[] = []

    // Success response
    responseDecorators.push(`
        @ApiResponse({
        status: 200,
        description: 'Successful operation',
        type: ${model.name}DTO
        })`)

    // Error responses
    responseDecorators.push(`
        @ApiResponse({
        status: 400,
        description: 'Bad request - validation error'
        })
        @ApiResponse({
        status: 401,
        description: 'Unauthorized - authentication required'
    })`)

    return responseDecorators.join('\n')
  }

  /**
   * Generates discriminator mapping for inheritance relationships,
   * allowing proper type discrimination in polymorphic responses.
   */
  private generateExtraModelsDecorator(model: ModelMetadata): string {
    if (!model.relationships.length) return ''

    const relatedModels = model.relationships.map((rel) => rel.type).filter(Boolean)

    if (relatedModels.length === 0) return ''

    return `@ApiExtraModels(${relatedModels.join(', ')})`
  }

  /**
   * Extracts security schemes from model metadata to determine
   * which authentication decorators to generate.
   */
  private extractSecuritySchemes(model: ModelMetadata): any[] {
    const securityMatch = model.documentation.description.match(/@security\s+({[\s\S]+?})/)
    if (!securityMatch) return []

    try {
      return JSON.parse(securityMatch[1])
    } catch {
      console.warn(`Invalid security scheme definition in ${model.name}`)
      return []
    }
  }

  /**
   * Generates example values for OpenAPI documentation. Tries to create
   * realistic examples based on field type and validation rules.
   */
  private generateExample(field: FieldMetadata): any {
    // First check if there's an explicit example in the documentation
    if (field.documentation.example !== undefined) {
      return field.documentation.example
    }

    // Generate example based on type and validation rules
    switch (field.type) {
      case 'string':
        return this.generateStringExample(field)
      case 'number':
        return this.generateNumberExample(field)
      case 'boolean':
        return true
      case 'Date':
        return new Date().toISOString()
      default:
        return undefined
    }
  }

  // Helper methods for example generation...
  private generateStringExample(field: FieldMetadata): string {
    const validationRules = field.validationRules
    if (validationRules.some((rule) => rule.decorator === 'IsEmail')) {
      return 'user@example.com'
    }
    if (validationRules.some((rule) => rule.decorator === 'IsUUID')) {
      return '123e4567-e89b-12d3-a456-426614174000'
    }
    return 'example'
  }

  private generateNumberExample(field: FieldMetadata): number {
    const min = this.extractMinimum(field.validationRules) ?? 0
    const max = this.extractMaximum(field.validationRules) ?? 100
    return Math.floor((min + max) / 2)
  }

  /**
   * Extracts minimum value from validation rules if present.
   */
  private extractMinimum(rules: ValidationRule[]): number | undefined {
    const minRule = rules.find((rule) => rule.decorator === 'IsInt' || rule.decorator === 'Min')
    return minRule?.params?.[0]
  }

  /**
   * Extracts maximum value from validation rules if present.
   */
  private extractMaximum(rules: ValidationRule[]): number | undefined {
    const maxRule = rules.find((rule) => rule.decorator === 'Max')
    return maxRule?.params?.[0]
  }

  /**
   * Extracts minimum length value from validation rules if present.
   */
  private extractMinLength(rules: ValidationRule[]): number | undefined {
    const minLengthRule = rules.find((rule) => rule.decorator === 'MinLength')
    return minLengthRule?.params?.[0]
  }

  /**
   * Extracts maximum length value from validation rules if present.
   */
  private extractMaxLength(rules: ValidationRule[]): number | undefined {
    const maxLengthRule = rules.find((rule) => rule.decorator === 'MaxLength')
    return maxLengthRule?.params?.[0]
  }

  /**
   * Extracts pattern value from validation rules if present.
   */
  private extractPattern(rules: ValidationRule[]): string | undefined {
    const patternRule = rules.find((rule) => rule.decorator === 'Matches')
    return patternRule?.params?.[0]
  }

  /**
   * Extracts enum values from field metadata if applicable.
   */

  private extractEnumValues(field: FieldMetadata): string[] {
    return field.validationRules.find((rule) => rule.decorator === 'IsEnum')?.params || []
  }

  /**
   * Determines if a field is a complex type that requires a nested schema.
   */
  private isComplexType(field: FieldMetadata): boolean {
    return field.type === 'object' || field.type === 'array'
  }

  /**
   * Generates nested schema references for complex types.
   */
  private generateNestedSchema(field: FieldMetadata): string {
    if (field.type === 'object') {
      return `() => ${field.name}DTO`
    }

    if (field.type === 'array') {
      return `() => [${this.typeMapper.mapPrismaToTypeScript(field.itemType)}]`
    }

    return ''
  }

  /**
   * Serializes options object into a string for decorator usage.
   */
  private serializeOptions(options: Record<string, any>): string {
    return JSON.stringify(options, null, 2)
      .replace(/"([^"]+)":/g, '$1:')
      .replace(/"/g, '')
      .replace(/,/g, ', ')
  }

  /**
   * Determines the correct Swagger type for a field based on its metadata.
   */
  public static getSwaggerType(field: FieldMetadata): string {
    switch (field.type) {
      case 'string':
        return 'string'
      case 'number':
        return 'number'
      case 'boolean':
        return 'boolean'
      case 'Date':
        return 'string'
      case 'enum':
        return 'string'
      default:
        return 'object'
    }
  }
}

================
File: modules/schemas.ts
================
// tools/generators/dto/modules/schemas.ts
import { TypeMapper } from '../utils/type-mapper'
import { DocumentationParser } from '../utils/documentation-parser'
import { TemplateEngine } from '../templates/template.engine'
import type { ModelMetadata, FieldMetadata, ValidationRule, TransformationRule } from '../types'

/**
 * SchemaGenerator creates Zod validation schemas using a template-based approach.
 * This class transforms our model metadata into runtime validation schemas while
 * maintaining consistent formatting and comprehensive validation rules.
 */
export class SchemaGenerator {
  constructor(
    private readonly typeMapper: TypeMapper,
    private readonly docParser: DocumentationParser,
  ) {}

  /**
   * Generates a complete schema file for a model, including validation rules,
   * transformations, and utility functions for runtime type checking.
   */
  generateSchema(model: ModelMetadata): string {
    const context = {
      model: {
        ...model,
        schemaName: `${model.name}Schema`,
        typeName: model.name,
      },
      imports: this.prepareImports(model),
      fields: this.prepareFields(model.fields),
      documentation: this.docParser.parseModelDocumentation(model),
    }

    return TemplateEngine.process('schema/base', context)
  }

  /**
   * Prepares import statements, including Zod and any custom type imports.
   */
  private prepareImports(model: ModelMetadata): string[] {
    const imports = ['z']

    // Add imports for related schemas
    model.relationships?.forEach((relation) => {
      imports.push(`${relation.type}Schema`)
    })

    return imports
  }

  /**
   * Prepares field definitions with their respective Zod validators
   */
  private prepareFields(fields: FieldMetadata[]): any[] {
    return fields.map((field) => ({
      ...field,
      zodType: this.getZodType(field),
      transformations: this.prepareTransforms(field.transformationRules),
      validations: this.prepareValidations(field.validationRules),
      documentation: this.docParser.parseFieldDocumentation(field),
    }))
  }

  /**
   * Maps a field to its Zod type
   */
  private getZodType(field: FieldMetadata): string {
    let zodType = this.typeMapper.mapPrismaToZod(field.type)

    if (field.enum?.length) {
      zodType = `enum([${field.enum.map((v) => `'${v}'`).join(', ')}])`
    }

    if (field.isArray) {
      zodType = `array(z.${zodType}())`
    }

    if (!field.isRequired) {
      zodType = `${zodType}.nullable()`
    }

    return zodType
  }

  /**
   * Prepares transformation rules for a field
   */
  private prepareTransforms(rules?: TransformationRule[]): any[] {
    if (!rules?.length) return []

    return rules.map((rule) => {
      switch (rule.type) {
        case 'toDate':
          return {
            transform: '(val) => new Date(val)',
            description: 'Convert to Date',
          }
        case 'toString':
          return {
            transform: 'String',
            description: 'Convert to string',
          }
        case 'toNumber':
          return {
            transform:
              rule.params?.[0] === 'integer'
                ? '(val) => parseInt(String(val), 10)'
                : '(val) => Number(val)',
            description: `Convert to ${rule.params?.[0] || 'number'}`,
          }
        case 'toBoolean':
          return {
            transform: '(val) => Boolean(val)',
            description: 'Convert to boolean',
          }
        case 'custom':
          return {
            transform: rule.params?.[0] || 'identity',
            description: 'Custom transformation',
          }
        default:
          return {
            transform: 'identity',
            description: 'Identity transformation',
          }
      }
    })
  }

  /**
   * Prepares validation rules for a field
   */
  private prepareValidations(rules?: ValidationRule[]): any[] {
    if (!rules?.length) return []

    return rules.map((rule) => {
      switch (rule.decorator) {
        case 'IsEmail':
          return {
            validation: 'email()',
            description: 'Must be a valid email',
          }
        case 'MinLength':
          return {
            validation: `min(${rule.params?.[0]})`,
            description: `Minimum length: ${rule.params?.[0]}`,
          }
        case 'MaxLength':
          return {
            validation: `max(${rule.params?.[0]})`,
            description: `Maximum length: ${rule.params?.[0]}`,
          }
        case 'IsInt':
          return {
            validation: 'int()',
            description: 'Must be an integer',
          }
        case 'IsPositive':
          return {
            validation: 'positive()',
            description: 'Must be positive',
          }
        default:
          const refinement = rule.params?.[0] || 'true'
          return {
            validation: `refine(${refinement})`,
            description: rule.message || 'Custom validation',
          }
      }
    })
  }
}

================
File: modules/transformers.ts
================
// tools/generators/dto/modules/transformers.ts
import { TemplateEngine } from '../templates/template.engine'
import type { ModelMetadata, FieldMetadata, TransformationRule, TransformationType } from '../types'

/**
 * TransformationGenerator handles the generation of transformation decorators
 * and utility methods for converting data between different formats and types.
 */
export class TransformationGenerator {
  /**
   * Generates transformation rules for a model
   */
  generateTransformationRules(model: ModelMetadata): TransformationRule[] {
    const context = {
      model,
      fields: this.prepareFields(model.fields),
    }

    return this.processTransformations(context)
  }

  /**
   * Prepare fields with their transformations
   */
  private prepareFields(fields: FieldMetadata[]): any[] {
    return fields.map((field) => ({
      ...field,
      transformations: [
        ...this.getTypeTransformations(field),
        ...this.getCaseTransformations(field),
        ...this.getCustomTransformations(field),
      ],
    }))
  }

  /**
   * Get type-specific transformations
   */
  private getTypeTransformations(field: FieldMetadata): TransformationRule[] {
    const rules: TransformationRule[] = []

    switch (field.type.toLowerCase()) {
      case 'date':
      case 'datetime':
        rules.push({
          type: 'toDate',
          params: ['ISO'],
          options: {
            format: 'ISO',
          },
        })
        break

      case 'number':
      case 'int':
      case 'float':
      case 'decimal':
        rules.push({
          type: 'toNumber',
          params: [field.documentation?.description?.includes('@integer') ? 'integer' : 'float'],
          options: {
            precision: field.documentation?.description?.includes('@precision')
              ? this.extractPrecision(field.documentation.description)
              : undefined,
          },
        })
        break

      case 'boolean':
        rules.push({
          type: 'toBoolean',
        })
        break

      case 'string':
        rules.push({
          type: 'toString',
          options: {
            nullIfEmpty: true,
          },
        })
        break
    }

    return rules
  }

  /**
   * Get case transformations for string fields
   */
  private getCaseTransformations(field: FieldMetadata): TransformationRule[] {
    const rules: TransformationRule[] = []
    const docs = field.documentation?.description || ''

    if (docs.includes('@lowercase')) {
      rules.push({
        type: 'custom',
        params: ['(value) => value?.toLowerCase()'],
        options: {
          preValidation: true,
        },
      })
    }

    if (docs.includes('@uppercase')) {
      rules.push({
        type: 'custom',
        params: ['(value) => value?.toUpperCase()'],
        options: {
          preValidation: true,
        },
      })
    }

    if (docs.includes('@trim')) {
      rules.push({
        type: 'custom',
        params: ['(value) => typeof value === "string" ? value.trim() : value'],
        options: {
          preValidation: true,
        },
      })
    }

    return rules
  }

  /**
   * Get custom transformations from documentation
   */
  private getCustomTransformations(field: FieldMetadata): TransformationRule[] {
    const rules: TransformationRule[] = []
    const docs = field.documentation?.description || ''

    // Parse @transform directives
    const transformMatches = docs.matchAll(/@transform\s*\((.*?)\)/g)
    for (const match of Array.from(transformMatches)) {
      const [type, ...params] = match[1].split(',').map((param) => param.trim())
      rules.push({
        type: type as TransformationType,
        params: params.length ? params : undefined,
      })
    }

    return rules
  }

  /**
   * Processes transformation rules into a template context
   */
  private processTransformations(context: any): TransformationRule[] {
    const templateResult = TemplateEngine.process('schema/transform', context)
    return this.parseTransformationContent(templateResult)
  }

  /**
   * Parse transformation content from template result
   */
  private parseTransformationContent(content: string): TransformationRule[] {
    // This would need to parse the generated content back into rules
    // For now, return empty array as this needs to be implemented based on
    // the specific template format used
    return []
  }

  /**
   * Extract precision from documentation
   */
  private extractPrecision(docs: string): number | undefined {
    const match = docs.match(/@precision\((\d+)\)/)
    return match ? parseInt(match[1], 10) : undefined
  }

  /**
   * Generates utility methods for transforming entire DTOs
   */
  generateTransformationMethods(model: ModelMetadata): string {
    const context = {
      model,
      hasRelations: model.relationships?.length > 0,
    }

    return TemplateEngine.process('schema/transform.methods', context)
  }
}

================
File: modules/type-guard.ts
================
// tools/generators/dto/modules/type-guards.ts
import { ModelMetadata, FieldMetadata } from '../core/types'
import { TypeMapper } from '../utils/type-mapper'

/**
 * TypeGuardGenerator creates TypeScript type guards that provide
 * runtime type checking with full type inference.
 */
export class TypeGuardGenerator {
  private typeMapper: TypeMapper

  constructor() {
    this.typeMapper = new TypeMapper()
  }

  /**
   * Generates type guard functions for a model that can be used
   * to verify types at runtime.
   */
  generateTypeGuards(model: ModelMetadata): string {
    const guardContent = `
import { I${model.name} } from './interfaces'
import { ${model.name}Schema } from './schemas'

/**
 * Type guard for ${model.name}
 * Ensures that an unknown value matches the expected structure
 */
export function is${model.name}(value: unknown): value is I${model.name} {
  return ${model.name}Schema.safeParse(value).success
}

/**
 * Specialized type guards for checking partial data
 */
${this.generatePartialTypeGuards(model)}

/**
 * Type guard utilities for arrays and relationships
 */
${this.generateCollectionTypeGuards(model)}
`
    return guardContent
  }

  /**
   * Generates type guards for checking partial objects that may
   * only include some fields of the model.
   */
  private generatePartialTypeGuards(model: ModelMetadata): string {
    return `
      export function isPartial${model.name}(value: unknown): value is Partial<I${model.name}> {
        if (typeof value !== 'object' || value === null) return false;

        const knownKeys = ${JSON.stringify(model.fields.map((f) => f.name))};
        return Object.keys(value).every(key => 
          knownKeys.includes(key) && isValidField(key, value[key as keyof typeof value])
        );
      }

      /**
       * Validates individual fields based on their expected types.
       */
      function isValidField(key: string, value: unknown): boolean {
        switch (key) {
      ${this.generateFieldValidations(model.fields)}
        }
        return false;
      }
      `
  }

  /**
   * Generates type guards for handling arrays and related objects.
   */
  private generateCollectionTypeGuards(model: ModelMetadata): string {
    return `
/**
 * Type guard for arrays of ${model.name}
 */
export function is${model.name}Array(value: unknown): value is I${model.name}[] {
  return Array.isArray(value) && value.every(is${model.name})
}

/**
 * Type guard for partial arrays of ${model.name}
 */
export function isPartial${model.name}Array(value: unknown): value is Partial<I${model.name}>[] {
  return Array.isArray(value) && value.every(isPartial${model.name})
}
`
  }

  /**
   * Generates individual field validation logic based on field types.
   */
  private generateFieldValidations(fields: FieldMetadata[]): string {
    return fields
      .map(
        (field) => `    case '${field.name}':
      ${this.generateFieldTypeCheck(field)}`,
      )
      .join('\n')
  }

  /**
   * Generates type-specific validation logic for a field.
   */
  private generateFieldTypeCheck(field: FieldMetadata): string {
    const type = this.typeMapper.mapPrismaToTypeScript(field)

    switch (type) {
      case 'string':
        return 'return typeof value === "string";'
      case 'number':
        return 'return typeof value === "number" && !isNaN(value);'
      case 'boolean':
        return 'return typeof value === "boolean";'
      case 'Date':
        return 'return value instanceof Date || !isNaN(Date.parse(String(value)));'
      default:
        return 'return true; // Complex type requiring deeper validation'
    }
  }
}

================
File: modules/validators.ts
================
// tools/generators/dto/modules/validators.ts
import { TemplateEngine } from '../templates/template.engine'
import type {
  ValidationRule,
  ModelMetadata,
  FieldMetadata,
  ValidationRuleDefinition,
} from '../types'

/**
 * Enhanced ValidationGenerator that infers validation rules from database constraints
 * and generates sophisticated validation decorators for DTOs.
 */
export class ValidationGenerator {
  /**
   * Generates comprehensive validation rules by combining explicit decorators
   * with inferred rules from database constraints
   */
  async generateValidationRules(model: ModelMetadata): Promise<ValidationRule[]> {
    const context = {
      model,
      fields: await this.processFields(model.fields),
      customRules: await this.generateCustomRules(model),
      crossFieldRules: await this.generateCrossFieldRules(model),
      isView: model.isView,
    }

    const content = TemplateEngine.process('schema/validation', context)
    const rules = await this.parseValidationContent(content)

    return [
      ...rules,
      ...(await this.inferDatabaseConstraints(model)),
      ...(await this.generateCheckConstraints(model)),
      ...(await this.generateUniqueConstraints(model)),
      ...(await this.generateForeignKeyValidation(model)),
    ]
  }

  /**
   * Parse validation content into validation rules
   */
  private async parseValidationContent(content: string): Promise<ValidationRule[]> {
    const rules: ValidationRule[] = []
    const lines = content.split('\n')

    for (const line of lines) {
      const match = line.match(/@Validate\((.*?)\)/)
      if (match) {
        const [decorator, ...params] = match[1].split(',').map((p) => p.trim())
        rules.push({
          decorator,
          params,
          message: `${decorator} validation failed`,
        })
      }
    }

    return rules
  }

  /**
   * Process fields to determine their validation requirements
   */
  private async processFields(fields: FieldMetadata[]): Promise<any[]> {
    return fields.map((field) => ({
      ...field,
      validations: this.getFieldValidations(field),
      constraints: this.extractConstraints(field),
      documentation: field.documentation,
    }))
  }

  /**
   * Get validation rules for a field based on its type and metadata
   */
  private getFieldValidations(field: FieldMetadata): ValidationRuleDefinition[] {
    const rules: ValidationRuleDefinition[] = []

    // Required validation
    if (field.isRequired) {
      rules.push({
        name: 'required',
        decorator: 'IsNotEmpty',
        message: `${field.name} is required`,
      })
    }

    // Type-specific validation
    switch (field.type.toLowerCase()) {
      case 'string':
        rules.push({
          name: 'string',
          decorator: 'IsString',
          message: `${field.name} must be a string`,
        })
        break
      case 'number':
      case 'int':
      case 'float':
        rules.push({
          name: 'number',
          decorator: 'IsNumber',
          message: `${field.name} must be a number`,
        })
        break
      case 'boolean':
        rules.push({
          name: 'boolean',
          decorator: 'IsBoolean',
          message: `${field.name} must be a boolean`,
        })
        break
      case 'date':
      case 'datetime':
        rules.push({
          name: 'date',
          decorator: 'IsDate',
          message: `${field.name} must be a valid date`,
        })
        break
    }

    // Add additional validations from documentation
    this.addValidationsFromDocs(field, rules)

    return rules
  }

  /**
   * Extract validations from field documentation
   */
  private addValidationsFromDocs(field: FieldMetadata, rules: ValidationRuleDefinition[]): void {
    const docs = field.documentation?.description || ''

    // Email validation
    if (docs.includes('@email')) {
      rules.push({
        name: 'email',
        decorator: 'IsEmail',
        message: `${field.name} must be a valid email address`,
      })
    }

    // Length validation
    const lengthMatch = docs.match(/@length\((\d+),(\d+)\)/)
    if (lengthMatch) {
      rules.push({
        name: 'length',
        decorator: 'Length',
        parameters: [lengthMatch[1], lengthMatch[2]],
        message: `${field.name} must be between ${lengthMatch[1]} and ${lengthMatch[2]} characters`,
      })
    }

    // Custom validations
    const validateMatches = docs.matchAll(/@validate\((.*?)\)/g)
    for (const match of validateMatches) {
      const [decorator, ...params] = match[1].split(',').map((p) => p.trim())
      rules.push({
        name: decorator.toLowerCase(),
        decorator,
        parameters: params.length ? params : undefined,
        message: `${field.name} failed ${decorator} validation`,
      })
    }
  }

  /**
   * Extract database constraints from field metadata
   */
  private extractConstraints(field: FieldMetadata): any {
    const constraints: any = {}
    const docs = field.documentation?.description || ''

    // Extract length constraints
    const lengthMatch = docs.match(/@length\((\d+)\)/)
    if (lengthMatch) {
      constraints.maxLength = parseInt(lengthMatch[1])
    }

    // Extract numeric precision
    const precisionMatch = docs.match(/@precision\((\d+),(\d+)\)/)
    if (precisionMatch) {
      constraints.numericPrecision = parseInt(precisionMatch[1])
      constraints.numericScale = parseInt(precisionMatch[2])
    }

    return constraints
  }

  /**
   * Generate custom validation rules for the model
   */
  private async generateCustomRules(model: ModelMetadata): Promise<ValidationRuleDefinition[]> {
    const rules: ValidationRuleDefinition[] = []

    if (model.isView) {
      rules.push({
        name: 'view',
        decorator: 'IsViewDTO',
        message: `This DTO represents a view: ${model.name}`,
      })

      // Add computed column validations
      model.viewMetadata?.computedColumns.forEach((column) => {
        rules.push({
          name: 'computed',
          decorator: 'IsComputed',
          parameters: [column.name],
          message: `${column.name} is a computed field`,
        })
      })
    }

    return rules
  }

  /**
   * Generate validation rules for relationships between fields
   */
  private async generateCrossFieldRules(model: ModelMetadata): Promise<ValidationRuleDefinition[]> {
    const rules: ValidationRuleDefinition[] = []

    // Date range validation
    const dateFields = model.fields.filter(
      (field) => field.type.toLowerCase() === 'date' || field.type.toLowerCase() === 'datetime',
    )

    if (dateFields.length >= 2) {
      rules.push({
        name: 'dateRange',
        decorator: 'ValidateDateRange',
        parameters: [dateFields.map((f) => f.name)],
        message: 'End date must be after start date',
      })
    }

    // Dependent field validation
    const dependentFields = this.findDependentFields(model)
    for (const { main, dependent } of dependentFields) {
      rules.push({
        name: 'dependent',
        decorator: 'ValidateDependent',
        parameters: [main, dependent],
        message: `${dependent} is required when ${main} is provided`,
      })
    }

    return rules
  }

  /**
   * Find fields that have dependencies on other fields
   */
  private findDependentFields(model: ModelMetadata): Array<{ main: string; dependent: string }> {
    const dependencies: Array<{ main: string; dependent: string }> = []

    model.fields.forEach((field) => {
      const dependencyMatch = field.documentation?.description.match(/@depends-on\s+(\w+)/)
      if (dependencyMatch) {
        dependencies.push({
          main: dependencyMatch[1],
          dependent: field.name,
        })
      }
    })

    return dependencies
  }

  /**
   * Infers validation rules from PostgreSQL column constraints such as
   * NOT NULL, length constraints, numeric ranges, etc.
   */
  private async inferDatabaseConstraints(model: ModelMetadata): Promise<ValidationRule[]> {
    const rules: ValidationRule[] = []

    for (const field of model.fields) {
      // Get PostgreSQL column metadata from field documentation
      const columnMetadata = this.extractColumnMetadata(field)

      if (columnMetadata.notNull) {
        rules.push({
          decorator: 'IsNotEmpty',
          message: `${field.name} is required`,
        })
      }

      // Handle character varying length constraints
      if (columnMetadata.maxLength) {
        rules.push({
          decorator: 'MaxLength',
          params: [columnMetadata.maxLength],
          message: `${field.name} cannot be longer than ${columnMetadata.maxLength} characters`,
        })
      }

      // Handle numeric precision and scale
      if (columnMetadata.numericPrecision) {
        rules.push({
          decorator: 'IsNumber',
          params: [
            {
              maxDecimalPlaces: columnMetadata.numericScale || 0,
              max: Math.pow(10, columnMetadata.numericPrecision) - 1,
            },
          ],
          message: `${field.name} must be a number with at most ${columnMetadata.numericScale} decimal places`,
        })
      }
    }

    return rules
  }

  /**
   * Generates validation rules from PostgreSQL CHECK constraints.
   * Converts CHECK expressions into class-validator decorators.
   */
  private async generateCheckConstraints(model: ModelMetadata): Promise<ValidationRule[]> {
    const rules: ValidationRule[] = []
    const checkConstraints = this.extractCheckConstraints(model)

    for (const constraint of checkConstraints) {
      const validationRule = this.convertCheckToValidation(constraint)
      if (validationRule) {
        rules.push(validationRule)
      }
    }

    return rules
  }

  /**
   * Converts a PostgreSQL CHECK constraint into a corresponding validation rule.
   * Handles common patterns like range checks, enum values, and regex patterns.
   */
  private convertCheckToValidation(checkConstraint: string): ValidationRule | null {
    // Match common CHECK constraint patterns
    const rangeMatch = checkConstraint.match(/(\w+)\s*(>=|<=|>|<)\s*(\d+)/)
    if (rangeMatch) {
      const [, field, operator, value] = rangeMatch
      return this.createRangeValidation(field, operator, Number(value))
    }

    const enumMatch = checkConstraint.match(/(\w+)\s+IN\s+\((.*?)\)/)
    if (enumMatch) {
      const [, field, values] = enumMatch
      return {
        decorator: 'IsIn',
        params: [values.split(',').map((v) => v.trim().replace(/'/g, ''))],
        message: `${field} must be one of: ${values}`,
      }
    }

    const regexMatch = checkConstraint.match(/(\w+)\s+~\s+'(.*?)'/)
    if (regexMatch) {
      const [, field, pattern] = regexMatch
      return {
        decorator: 'Matches',
        params: [new RegExp(pattern)],
        message: `${field} must match pattern: ${pattern}`,
      }
    }

    return null
  }

  /**
   * Creates range validation rules based on operators found in CHECK constraints.
   */
  private createRangeValidation(field: string, operator: string, value: number): ValidationRule {
    const decoratorMap: Record<string, string> = {
      '>=': 'Min',
      '<=': 'Max',
      '>': 'Min',
      '<': 'Max',
    }

    return {
      decorator: decoratorMap[operator],
      params: [operator.includes('>') ? value : value],
      message: `${field} must be ${operator} ${value}`,
    }
  }

  /**
   * Generates validation rules for composite unique constraints.
   * Creates custom validators that check uniqueness across multiple fields.
   */
  private async generateUniqueConstraints(model: ModelMetadata): Promise<ValidationRule[]> {
    const rules: ValidationRule[] = []
    const uniqueConstraints = this.extractUniqueConstraints(model)

    for (const constraint of uniqueConstraints) {
      if (constraint.fields.length > 1) {
        // Generate composite unique validator
        rules.push({
          decorator: 'ValidateCompositeUnique',
          params: [constraint.fields],
          message: `The combination of (${constraint.fields.join(', ')}) must be unique`,
        })
      }
    }

    return rules
  }

  /**
   * Generates validation rules for foreign key relationships.
   * Ensures referenced entities exist in the database.
   */
  private async generateForeignKeyValidation(model: ModelMetadata): Promise<ValidationRule[]> {
    const rules: ValidationRule[] = []

    for (const relationship of model.relations) {
      rules.push({
        decorator: 'ValidateExists',
        params: [relationship.foreign.model, relationship.foreign.field],
        message: `Referenced ${relationship.foreign.model} must exist`,
      })
    }

    return rules
  }

  /**
   * Extracts column metadata from field documentation and database schema.
   */
  private extractColumnMetadata(field: FieldMetadata) {
    const metadata = {
      notNull: false,
      maxLength: null,
      numericPrecision: null,
      numericScale: null,
    }

    // Parse field documentation for database constraints
    const lengthMatch = field.documentation.description.match(/@length\((\d+)\)/)
    if (lengthMatch) {
      metadata.maxLength = parseInt(lengthMatch[1])
    }

    const precisionMatch = field.documentation.description.match(/@precision\((\d+),(\d+)\)/)
    if (precisionMatch) {
      metadata.numericPrecision = parseInt(precisionMatch[1])
      metadata.numericScale = parseInt(precisionMatch[2])
    }

    return metadata
  }

  /**
   * Extracts CHECK constraints from model documentation.
   */
  private extractCheckConstraints(model: ModelMetadata): string[] {
    const checkMatch = model.documentation.description.match(/@check\s+{([^}]+)}/)
    if (!checkMatch) return []

    return checkMatch[1]
      .split(';')
      .map((constraint) => constraint.trim())
      .filter(Boolean)
  }

  /**
   * Extracts unique constraints from model documentation.
   */
  private extractUniqueConstraints(model: ModelMetadata): Array<{ fields: string[] }> {
    const uniqueMatch = model.documentation.description.match(/@unique\s+{([^}]+)}/)
    if (!uniqueMatch) return []

    return uniqueMatch[1].split('),').map((constraint) => ({
      fields: constraint
        .replace(/[()]/g, '')
        .split(',')
        .map((field) => field.trim()),
    }))
  }
}

================
File: template/dto.template.ts
================
// tools/generators/dto/templates/dto.template.ts
import { ModelMetadata, FieldMetadata, ValidationRule } from '../core/types'

/**
 * DTO Template Generator
 * Responsible for generating the actual DTO class code using a template-based approach.
 * This makes it easier to maintain consistent code generation and modify the output format.
 */
export class DTOTemplate {
  /**
   * Generates a complete DTO class with validation and transformation decorators
   */
  static generate(model: ModelMetadata): string {
    const imports = this.generateImports(model)
    const classDeclaration = this.generateClassDeclaration(model)
    const properties = this.generateProperties(model)
    const methods = this.generateMethods(model)

    return `${imports}

${classDeclaration} {
${properties}

${methods}
}
`
  }

  /**
   * Generates necessary imports based on used features
   */
  private static generateImports(model: ModelMetadata): string {
    const imports = new Set<string>(['import { ApiProperty } from "@nestjs/swagger"'])

    // Add validation imports if needed
    if (model.fields.some((f) => f.validationRules.length > 0)) {
      imports.add('import { IsNotEmpty, IsOptional } from "class-validator"')
    }

    // Add transformation imports if needed
    if (model.fields.some((f) => f.transformationRules.length > 0)) {
      imports.add('import { Transform } from "class-transformer"')
    }

    return Array.from(imports).join('\n')
  }

  /**
   * Generates the class declaration with inheritance if needed
   */
  private static generateClassDeclaration(model: ModelMetadata): string {
    const docs = this.generateClassDocumentation(model.documentation)
    return `${docs}
export class ${model.name}DTO extends BaseDTO`
  }

  /**
   * Generates properties with decorators for validation and documentation
   */
  private static generateProperties(model: ModelMetadata): string {
    return model.fields.map((field) => this.generateField(field)).join('\n\n')
  }

  /**
   * Generates a single field with all necessary decorators
   */
  private static generateField(field: FieldMetadata): string {
    const decorators = [
      this.generateApiPropertyDecorator(field),
      ...this.generateValidationDecorators(field.validationRules),
      ...this.generateTransformationDecorators(field.transformationRules),
    ]

    return `  ${decorators.join('\n  ')}
  ${field.name}${field.isRequired ? '' : '?'}: ${field.type};`
  }

  // ... Additional helper methods for specific template components
}

================
File: template/interface.template.ts
================
// tools/generators/dto/templates/interface.template.ts
/**
 * Template system for generating TypeScript interfaces.
 * Uses a flexible template structure that can be customized through
 * configuration while maintaining consistent formatting and documentation.
 */
export class InterfaceTemplate {
  /**
   * Main template for generating an interface file.
   * Supports imports, documentation, and multiple interface definitions.
   */
  static readonly MAIN_TEMPLATE = `
  // This file is auto-generated. Do not modify manually.
  {{imports}}
  
  {{documentation}}
  export interface {{interfaceName}} {
  {{properties}}
  }
  
  {{relationInterfaces}}
  
  {{typeHelpers}}
  `.trim()

  /**
   * Template for generating import statements.
   * Handles both internal and external imports with proper grouping.
   */
  static readonly IMPORTS_TEMPLATE = `
  {{#each imports}}
  import { {{what}} } from '{{from}}'
  {{/each}}
  `.trim()

  /**
   * Template for generating JSDoc documentation blocks.
   * Supports multiple documentation features like examples and deprecation notices.
   */
  static readonly DOCUMENTATION_TEMPLATE = `
  /**
   * {{description}}
   *{{#if deprecated}}
   * @deprecated {{deprecated}}{{/if}}
   *{{#if example}}
   * @example
   * {{example}}{{/if}}
   *{{#if version}}
   * @version {{version}}{{/if}}
   */
  `.trim()

  /**
   * Template for generating interface properties.
   * Supports different types, optional flags, and property documentation.
   */
  static readonly PROPERTY_TEMPLATE = `
    /**
     * {{description}}
     *{{#if example}}
     * @example {{example}}{{/if}}
     *{{#if validation}}
     * @validation {{validation}}{{/if}}
     */
    {{name}}{{#unless required}}?{{/unless}}: {{type}};
  `.trim()

  /**
   * Template for generating relation interfaces.
   * Creates extended interfaces for handling related entities.
   */
  static readonly RELATION_INTERFACE_TEMPLATE = `
  export interface {{interfaceName}}With{{relationName}} extends {{interfaceName}} {
    {{relationProperty}}: {{relationType}};
  }
  `.trim()

  /**
   * Template for generating type helpers.
   * Creates utility types for working with the interface.
   */
  static readonly TYPE_HELPERS_TEMPLATE = `
  /**
   * Helper types for working with {{interfaceName}}
   */
  export type Partial{{interfaceName}} = Partial<{{interfaceName}}>
  export type Required{{interfaceName}} = Required<{{interfaceName}}>
  export type Pick{{interfaceName}}<K extends keyof {{interfaceName}}> = Pick<{{interfaceName}}, K>
  `.trim()

  /**
   * Template for generating validation metadata.
   * Describes validation rules that should be applied to properties.
   */
  static readonly VALIDATION_METADATA_TEMPLATE = `
  /**
   * Validation metadata for {{interfaceName}}
   */
  export const {{interfaceName}}ValidationRules = {
  {{#each validationRules}}
    {{name}}: {
      {{#each rules}}
      {{name}}: {{value}},
      {{/each}}
    },
  {{/each}}
  } as const;
  `.trim()
}

================
File: template/request.dto.template.ts
================
/**
 * Template for generating request DTOs with appropriate validation
 * and transformation rules for incoming data.
 */
export class RequestDTOTemplate {
    static generate(model: ModelMetadata): string {
      return TemplateSystem.generateDTO(model, {
        useValidation: true,
        useTransformation: true,
        usePipes: true,
        isRequest: true,
        isResponse: false,
        extends: 'BaseRequestDTO'
      })
    }
  }

================
File: template/response.dto.template.ts
================
import { ModelMetadata } from '../types'

/**
 * Template for generating response DTOs that handle outgoing data
 * with proper serialization and documentation.
 */
export class ResponseDTOTemplate {
  static generate(model: ModelMetadata): string {
    return TemplateSystem.generateDTO(model, {
      useValidation: false,
      useTransformation: true,
      usePipes: false,
      isRequest: false,
      isResponse: true,
      extends: 'BaseResponseDTO',
    })
  }
}

================
File: template/schema.template.ts
================
// tools/generators/dto/templates/schema.template.ts
/**
 * Template system for generating Zod schemas.
 * Provides a structured way to create validation schemas with
 * proper typing and documentation.
 */
export class SchemaTemplate {
  /**
   * Main template for generating a schema file.
   * Includes imports, schema definition, and utility functions.
   */
  static readonly MAIN_TEMPLATE = `
  // This file is auto-generated. Do not modify manually.
  {{imports}}
  
  {{documentation}}
  export const {{schemaName}} = z.object({
  {{properties}}
  })
  
  /**
   * Type inference from schema
   */
  export type {{typeName}} = z.infer<typeof {{schemaName}}>
  
  {{validators}}
  
  {{utilities}}
  `.trim()

  /**
   * Template for generating schema imports.
   * Handles Zod and related type imports.
   */
  static readonly IMPORTS_TEMPLATE = `
  import { z } from 'zod'
  {{#each customImports}}
  import { {{what}} } from '{{from}}'
  {{/each}}
  `.trim()

  /**
   * Template for generating schema properties.
   * Supports all Zod validators and transformations.
   */
  static readonly PROPERTY_TEMPLATE = `
    /**
     * {{description}}
     */
    {{name}}: {{zodType}}{{#if transforms}}
      {{#each transforms}}
      .transform({{transform}})
      {{/each}}
    {{/if}}{{#if validations}}
      {{#each validations}}
      .{{validation}}
      {{/each}}
    {{/if}},
  `.trim()

  /**
   * Template for generating schema validation functions.
   * Creates utility functions for validating data against the schema.
   */
  static readonly VALIDATORS_TEMPLATE = `
  /**
   * Validates data against the {{schemaName}}
   * @throws {ZodError} if validation fails
   */
  export function validate{{typeName}}(data: unknown): {{typeName}} {
    return {{schemaName}}.parse(data)
  }
  
  /**
   * Safely validates data against the {{schemaName}}
   * @returns Result object indicating success or failure
   */
  export function safeValidate{{typeName}}(data: unknown): Result<{{typeName}}, z.ZodError> {
    const result = {{schemaName}}.safeParse(data)
    return result.success
      ? { ok: true, value: result.data }
      : { ok: false, error: result.error }
  }
  `.trim()

  /**
   * Template for generating schema utilities.
   * Creates helper functions for common schema operations.
   */
  static readonly UTILITIES_TEMPLATE = `
  /**
   * Utility functions for {{schemaName}}
   */
  export const {{schemaName}}Utils = {
    /**
     * Creates a partial schema that makes all properties optional
     */
    partial: () => {{schemaName}}.partial(),
  
    /**
     * Creates a strict schema that doesn't allow additional properties
     */
    strict: () => {{schemaName}}.strict(),
  
    /**
     * Creates a schema for arrays of {{typeName}}
     */
    array: () => z.array({{schemaName}}),
  
    /**
     * Creates a schema with only the specified keys
     */
    pick: <K extends keyof {{typeName}}>(keys: K[]) => {{schemaName}}.pick(keys),
  } as const;
  `.trim()

  /**
   * Template for generating custom refinement rules.
   * Allows adding complex validation logic to schemas.
   */
  static readonly REFINEMENT_TEMPLATE = `
      .refine(
        (data) => {{refinementLogic}},
        { message: '{{message}}' }
      )
  `.trim()

  /**
   * Template for generating preprocess transformations.
   * Allows data transformation before validation.
   */
  static readonly PREPROCESS_TEMPLATE = `
      .preprocess((val) => {{preprocessLogic}})
  `.trim()
}

================
File: templates/api/metadata.api.hbs
================
{{#if imports}}
  {{{imports}}}
{{/if}}

{{#if model.documentation}}
  /** *
  {{{model.documentation}}}
  */
{{/if}}
@ApiTags('{{name}}')
{{#each securitySchemes}}
  @{{this}}()
{{/each}}
{{#each responses}}
  @ApiResponse({ status:
  {{status}}, description: '{{{description}}}',
  {{#if type}}
    type:
    {{type}},
  {{/if}}
  })
{{/each}}
export class
{{name}}DTO {
{{#each properties}}
  {{#if documentation}}
    /** *
    {{{documentation.description}}}
    */
  {{/if}}
  @ApiProperty({{{serializeOptions this}}})
  {{name}}{{#unless isRequired}}?{{/unless}}:
  {{type}};

{{/each}}
}

================
File: templates/base/base-types.hbs
================
{{!-- templates/utils/base-types.hbs --}}

/**
 * Base types used across DTOs
 */
export interface BaseDTO {
  toEntity(): Record<string, any>
}

export interface ValidationError {
  property: string
  constraints: Record<string, string>
}

export type ValidationResult<T> = {
  isValid: boolean
  data?: T
  errors?: ValidationError[]
}


/**
 * Common type helpers
 */
export type DeepPartial<T> = {
  [P in keyof T]?: DeepPartial<T[P]>
}

export type DeepRequired<T> = {
  [P in keyof T]-?: DeepRequired<T[P]>
}

export type DateString = string
export type UUIDString = string

================
File: templates/base/documentation.hbs
================
/**
 * {{description}}
 {{#if deprecated}}
 * @deprecated {{deprecated}}
 {{/if}}
 {{#if example}}
 * @example {{example}}
 {{/if}}
 {{#if version}}
 * @version {{version}}
 {{/if}}
 */

================
File: templates/base/helpers.hbs
================
{{! templates/base/helpers.hbs }}
/** * Validation helper functions */ export function createValidationError( property: string,
constraint: string, message: string ): ValidationError { return { property, constraints: {
[constraint]: message } } } export function isValidationError(error: unknown): error is
ValidationError { return ( typeof error === 'object' && error !== null && 'property' in error &&
'constraints' in error && typeof (error as any).property === 'string' && typeof (error as
any).constraints === 'object' ) }

================
File: templates/base/imports.hbs
================
import { ApiProperty } from '@nestjs/swagger';
{{#if hasValidation}}
  import { IsNotEmpty, IsOptional } from 'class-validator';
{{/if}}
{{#if hasTransform}}
  import { Transform } from 'class-transformer';
{{/if}}

================
File: templates/base/property.hbs
================
3. `templates/property.hbs`: ```handlebars /** *
{{description}}
{{#if example}}
  * @example
  {{example}}
{{/if}}
{{#if validation}}
  * @validation
  {{validation}}
{{/if}}
*/
{{name}}{{#unless required}}?{{/unless}}:
{{type}}; ```

================
File: templates/base/type-helpers.hbs
================
export type Partial{{interfaceName}} = Partial<I{{interfaceName}}>;
export type Required{{interfaceName}} = Required<I{{interfaceName}}>;

================
File: templates/dto/model.dto.hbs
================
{{> imports}}

/**
 * {{#if documentation.description}}{{documentation.description}}{{else}}DTO for {{name}}{{/if}}
 */
export class {{name}}DTO {
{{#each fields}}
  /**
   * {{#if documentation.description}}{{documentation.description}}{{/if}}
   */
  @ApiProperty()
  {{#each validationRules}}
  @{{this}}()
  {{/each}}
  {{name}}{{#unless isRequired}}?{{/unless}}: {{type}};

{{/each}}
}

================
File: templates/dto/relationships.dto.hbs
================
{{#if documentation}}
  /** *
  {{{documentation.description}}}
  */
{{/if}}
export interface
{{name}}Relation {
{{#each relations}}
  {{name}}: { type: '{{type}}', model: '{{model}}', field: '{{field}}', isRequired:
  {{isRequired}}, isArray:
  {{isArray}}, foreignKey: '{{foreignKey}}', };
{{/each}}
}

================
File: templates/dto/request.dto.hbs
================
import { ApiProperty } from '@nestjs/swagger'; import { Transform } from 'class-transformer'; import
{ IsString, IsNumber, IsBoolean, IsDate, IsOptional, IsNotEmpty,
{{#each additionalValidators}}
  {{this}},
{{/each}}
} from 'class-validator';

{{#if documentation}}
  /** *
  {{{documentation.description}}}
  */
{{/if}}
export class
{{name}}RequestDTO {
{{#each properties}}
  {{#if documentation}}
    /** *
    {{{documentation.description}}}
    */
  {{/if}}
  @ApiProperty({ description: '{{{documentation.description}}}', type: () =>
  {{{swaggerType}}}, required:
  {{isRequired}},
  {{#if isArray}}
    isArray: true,
  {{/if}}
  })
  {{#if isRequired}}
    @IsNotEmpty()
  {{else}}
    @IsOptional()
  {{/if}}
  {{#each validators}}
    @{{decorator}}({{{params}}})
  {{/each}}
  {{#if transformers}}
    {{#each transformers}}
      @Transform({{{this}}})
    {{/each}}
  {{/if}}
  {{name}}{{#unless isRequired}}?{{/unless}}:
  {{type}};

{{/each}}
}

================
File: templates/dto/response.dto.hbs
================
import { ApiProperty } from '@nestjs/swagger'; import { Transform } from 'class-transformer';

{{#if documentation}}
  /** *
  {{{documentation.description}}}
  */
{{/if}}
export class
{{name}}ResponseDTO {
{{#each properties}}
  {{#if documentation}}
    /** *
    {{{documentation.description}}}
    */
  {{/if}}
  @ApiProperty({ description: '{{{documentation.description}}}', type: () =>
  {{{swaggerType}}}, required:
  {{isRequired}},
  {{#if isArray}}
    isArray: true,
  {{/if}}
  })
  {{#if transformers}}
    {{#each transformers}}
      @Transform({{{this}}})
    {{/each}}
  {{/if}}
  {{name}}{{#unless isRequired}}?{{/unless}}:
  {{type}};

{{/each}}

================
File: templates/dto/view.dto.hbs
================
{{! templates/dto/view.dto.hbs }}
import { ApiProperty } from '@nestjs/swagger'; import { Transform } from 'class-transformer'; import
{ IsString, IsNumber, IsBoolean, IsDate, IsOptional, IsNotEmpty, IsUUID, IsInt, IsEnum, IsJSON }
from 'class-validator'; /** *
{{model.documentation.description}}
* Generated from database view:
{{model.viewMetadata.sourceQuery}}
*/ export class
{{model.name}}ViewDTO {
{{#each model.fields}}
  /** *
  {{documentation.description}}
  {{#if documentation.example}}
    * @example
    {{documentation.example}}
  {{/if}}
  */
  {{#if isRequired}}
    @IsNotEmpty()
  {{else}}
    @IsOptional()
  {{/if}}
  @ApiProperty({ description: '{{documentation.description}}', type: () =>
  {{swaggerType}}, required:
  {{isRequired}},
  {{#if isArray}}
    isArray: true,
  {{/if}}
  })
  {{#each validationRules}}
    @{{decorator}}({{#if params}}{{params}}{{/if}})
  {{/each}}
  {{#if isComputed}}
    @IsComputed()
  {{/if}}
  {{#each transformationRules}}
    @Transform({{{this}}})
  {{/each}}
  {{name}}{{#unless isRequired}}?{{/unless}}:
  {{type}};

{{/each}}

{{#if model.viewMetadata.computedColumns.length}}
  // Computed columns
  {{#each model.viewMetadata.computedColumns}}
    /** * Computed column:
    {{expression}}
    * Dependencies:
    {{dependsOn}}
    */ @ApiProperty({ description: 'Computed field', type: () =>
    {{returnType}}, }) @IsComputed()
    {{name}}:
    {{returnType}};

  {{/each}}
{{/if}}
}

================
File: templates/guard/type.guard.hbs
================
import { {{name}}DTO } from './dto/{{lowercase name}}.dto';
import { {{name}}Schema } from './schemas/{{lowercase name}}.schema';

/**
 * Type guard for {{name}}
 */
export function is{{name}}(value: unknown): value is {{name}}DTO {
  return {{name}}Schema.safeParse(value).success;
}

/**
 * Type guard for partial {{name}}
 */
export function isPartial{{name}}(value: unknown): value is Partial<{{name}}DTO> {
  if (typeof value !== 'object' || value === null) return false;
  
  const knownKeys = [{{#each properties}}'{{name}}',{{/each}}];
  return Object.keys(value).every(key => 
    knownKeys.includes(key) && isValidField(key, value[key as keyof typeof value])
  );
}

/**
 * Validates individual fields based on their expected types
 */
function isValidField(key: string, value: unknown): boolean {
  switch (key) {
    {{#each properties}}
    case '{{name}}':
      return {{validationType}};
    {{/each}}
  }
  return false;
}

================
File: templates/interface/model.interface.hbs
================
{{!-- templates/interface/model.interface.hbs --}}
{{> imports}}

{{> documentation}}
export interface I{{model.name}} extends BaseEntity {
  {{#each model.fields}}
  /**
   * {{documentation.description}}
   {{#if documentation.example}}
   * @example {{documentation.example}}
   {{/if}}
   {{#if validationRules.length}}
   * @validation
   {{#each validationRules}}
   * - {{decorator}}{{#if params}}({{params}}){{/if}}: {{message}}
   {{/each}}
   {{/if}}
   */
  {{name}}{{#unless isRequired}}?{{/unless}}: {{tsType}};
  {{/each}}

  {{#if model.relations.length}}
  // Relationships
  {{#each model.relations}}
  /**
   * {{../name}} {{relationType}} {{foreign.model}}
   */
  {{name}}{{#unless isRequired}}?{{/unless}}: {{#if isArray}}I{{foreign.model}}[]{{else}}I{{foreign.model}}{{/if}};
  {{/each}}
  {{/if}}
}

{{#if model.relations.length}}
// Type helpers for relationships
{{#each model.relations}}
export type {{../model.name}}With{{name}} = I{{../model.name}} & {
  {{name}}: {{#if isArray}}I{{foreign.model}}[]{{else}}I{{foreign.model}}{{/if}};
};
{{/each}}
{{/if}}

================
File: templates/interface/relationships.interface.hbs
================
export interface I{{interfaceName}}With{{relationName}}
extends I{{interfaceName}}
{
{{relationProperty}}:
{{relationType}}; }

================
File: templates/interface/view.interface.hbs
================
{{!-- templates/interface/view.interface.hbs --}}
{{> imports}}

/**
 * Interface for {{model.name}} database view
 * {{model.documentation.description}}
 * 
 * View Query:
 * {{model.viewMetadata.sourceQuery}}
 */
export interface I{{model.name}}View {
  {{#each model.fields}}
  /**
   * {{documentation.description}}
   {{#if documentation.example}}
   * @example {{documentation.example}}
   {{/if}}
   */
  {{name}}{{#unless isRequired}}?{{/unless}}: {{tsType}};

  {{/each}}

  {{#if model.viewMetadata.computedColumns.length}}
  // Computed columns
  {{#each model.viewMetadata.computedColumns}}
  /**
   * Computed field based on: {{expression}}
   */
  {{name}}: {{returnType}};

  {{/each}}
  {{/if}}

  {{#if model.viewMetadata.dependencies.length}}
  // View dependencies
  dependencies: {
    {{#each model.viewMetadata.dependencies}}
    {{this}}: boolean;
    {{/each}}
  };
  {{/if}}
}

================
File: templates/schema/model.schema.hbs
================
import { z } from 'zod';
{{#each imports}}
import { {{this}} } from './{{lowercase this}}';
{{/each}}

/**
 * Schema for {{name}}
 */
export const {{name}}Schema = z.object({
  {{#each fields}}
  {{name}}: z.{{lookup ../zodTypes name}},
  {{/each}}
});

/**
 * Type inference from schema
 */
export type {{name}} = z.infer<typeof {{name}}Schema>;

/**
 * Validation helper functions for {{name}}
 */
{{#each fields}}
{{#if validationRules}}
/**
 * Validates {{name}} field
 */
export function validate{{pascalCase name}}(value: unknown): boolean {
  {{#each validationRules}}
  // {{decorator}} validation
  if (!is{{lowercase decorator}}(value)) {
    return false;
  }
  {{/each}}
  return true;
}

{{/if}}
{{/each}}

================
File: templates/schema/schema.utilities.hbs
================
/** * Schema utilities for
{{name}}
*/

{{#each fields}}
  {{#if validationRules}}
    /** * Zod schema for
    {{name}}
    field */ export const
    {{name}}Schema = z.{{zodType}}{{#unless isRequired}}.optional(){{/unless}};

  {{/if}}
{{/each}}

================
File: templates/schema/transform.hbs
================
{{! templates/schema/transform.hbs }}
{{#each fields}}
  {{#if transformations.length}}
    // Transformations for
    {{name}}
    {{#each transformations}}
      {{#if type}}
        {{#if (eq type 'toDate')}}
          @Transform(({ value }) => value ? new Date(value) : null)
        {{/if}}
        {{#if (eq type 'toString')}}
          @Transform(({ value }) => value?.toString())
        {{/if}}
        {{#if (eq type 'toNumber')}}
          @Transform(({ value }) => {
          {{#if params}}
            {{#if (eq params.[0] 'integer')}}
              return value ? parseInt(value.toString(), 10) : null;
            {{else}}
              return value ? parseFloat(value.toString()) : null;
            {{/if}}
          {{else}}
            return value ? Number(value) : null;
          {{/if}}
          })
        {{/if}}
        {{#if (eq type 'toBoolean')}}
          @Transform(({ value }) => { if (typeof value === 'boolean') return value; if (typeof value
          === 'string') return value.toLowerCase() === 'true'; return Boolean(value); })
        {{/if}}
        {{#if (eq type 'custom')}}
          @Transform({{{params.[0]}}})
        {{/if}}
      {{/if}}
    {{/each}}
  {{/if}}
{{/each}}

================
File: templates/schema/transform.methods.hbs
================
{{! templates/schema/transform.methods.hbs }}
/** * Transformation methods for
{{model.name}}
*/ export class
{{model.name}}Transformer { /** * Transform entity to DTO */ static toDTO(entity: any):
{{model.name}}DTO { return plainToClass({{model.name}}DTO, entity, { excludeExtraneousValues: true,
enableImplicitConversion: true }); } /** * Transform DTO to entity */ static fromDTO(dto:
{{model.name}}DTO): any { return classToPlain(dto, { excludeExtraneousValues: true }); }

{{#if hasRelations}}
  /** * Transform entity to DTO including relations */ static toDTOWithRelations(entity: any):
  {{model.name}}DTO { const dto = this.toDTO(entity);
  {{#each model.relationships}}
    if (entity.{{name}}) { dto.{{name}}
    =
    {{#if isArray}}
      entity.{{name}}.map(item =>
      {{type}}Transformer.toDTO(item))
    {{else}}
      {{type}}Transformer.toDTO(entity.{{name}})
    {{/if}}; }
  {{/each}}
  return dto; }
{{/if}}
}

================
File: templates/schema/validation.helpers.hbs
================
/** * Validation helper functions for
{{name}}
*/

{{#each fields}}
  {{#if validationRules}}
    /** * Validates
    {{name}}
    field */ export function validate{{capitalize name}}(value: unknown): boolean {
    {{#each validationRules}}
      //
      {{decorator}}
      validation if (!{{lowercase decorator}}(value)) { return false }
    {{/each}}
    return true }

  {{/if}}
{{/each}}

================
File: templates/schema/validation.schema.hbs
================
import { z } from 'zod';
{{#if imports}}
{{{imports}}}
{{/if}}

{{#if documentation}}
/**
 * {{{documentation.description}}}
 */
{{/if}}
export const {{name}}Schema = z.object({
  {{#each properties}}
  {{name}}: {{#if isRequired}}z.{{zodType}}(){{else}}z.{{zodType}}().optional(){{/if}}
    {{#if transforms}}
    {{#each transforms}}
    .transform({{{transform}}})
    {{/each}}
    {{/if}}
    {{#if validations}}
    {{#each validations}}
    .{{{validation}}}
    {{/each}}
    {{/if}},
  {{/each}}
});

export type {{name}}Schema = z.infer<typeof {{name}}Schema>;

================
File: templates/index.hbs
================
{{#each models}}
  export * from './dto/{{lowercase name}}.dto'; export * from './interfaces/{{lowercase
    name
  }}.interface'; export * from './schemas/{{lowercase name}}.schema'; export * from './guards/{{lowercase
    name
  }}.guard';
{{/each}}

export * from './utils/base-types'; export * from './utils/helpers';

================
File: templates/template.engine.ts
================
// tools/generators/dto/templates/template.engine.ts
import Handlebars from 'handlebars'
import { TypeMapper } from '../utils/type-mapper'
import type { FieldMetadata } from '../types'
import { join } from 'path'
import { readFile } from 'fs/promises'

/**
 * Enhanced template engine for processing Handlebars templates
 */
export class TemplateEngine {
  private static handlebars = Handlebars.create()
  private static templates = new Map<string, HandlebarsTemplateDelegate>()
  private static typeMapper = new TypeMapper()
  private static partialsRegistered = false
  private static templatesLoaded = false

  /**
   * Initialize the template engine
   */
  static async initialize(templatesPath: string): Promise<void> {
    console.log('Initializing template engine with path:', templatesPath)

    if (!this.partialsRegistered) {
      await this.registerBasePartials(templatesPath)
    }
    if (!this.templatesLoaded) {
      await this.loadTemplates(templatesPath)
    }
    this.registerDefaultHelpers()

    // Debug logging
    console.log('Available templates:', Array.from(this.templates.keys()))
    console.log('Available partials:', Object.keys(this.handlebars.partials))
  }

  /**
   * Register core partials used across templates
   */
  private static async registerBasePartials(templatesPath: string): Promise<void> {
    const partials = {
      // Base partials
      'imports': 'base/imports.hbs',
      'documentation': 'base/documentation.hbs',
      'property': 'base/property.hbs',
      'type-helpers': 'base/type-helpers.hbs',

      // Validation & Transformation
      'transform': 'schema/transform.hbs',
      'transform-methods': 'schema/transform.methods.hbs',
      'validation-schema': 'schema/validation.schema.hbs',
      'validation-helpers': 'schema/validation.helpers.hbs',
      'schema-utilities': 'schema/schema.utilities.hbs',

      // API
      'api-metadata': 'api/metadata.api.hbs',

      // DTO related
      'dto-base': 'dto/model.dto.hbs',
      'dto-relation': 'dto/relationships.dto.hbs',

      // Interface related
      'interface-base': 'interface/model.interface.hbs',
      'interface-relation': 'interface/relationships.interface.hbs',
    }

    console.log('Registering base partials...')
    for (const [name, path] of Object.entries(partials)) {
      try {
        const fullPath = join(templatesPath, path)
        console.log(`Loading partial ${name} from ${fullPath}`)
        const content = await readFile(fullPath, 'utf-8')
        this.handlebars.registerPartial(name, content)
      } catch (error) {
        console.error(`Error loading partial ${name}:`, error)
      }
    }

    console.log('Base partials registered')
    this.partialsRegistered = true
  }

  /**
   * Load all template files
   */
  private static async loadTemplates(templatesPath: string): Promise<void> {
    const templateFiles = {
      // API templates
      'api/metadata.api': 'api/metadata.api.hbs',

      // Base templates
      'base/documentation': 'base/documentation.hbs',
      'base/imports': 'base/imports.hbs',
      'base/property': 'base/property.hbs',
      'base/type-helpers': 'base/type-helpers.hbs',
      'base/base-types': 'base/base-types.hbs',
      'base/helpers': 'base/helpers.hbs',

      // DTO templates
      'dto/model.dto': 'dto/model.dto.hbs',
      'dto/relationships.dto': 'dto/relationships.dto.hbs',
      'dto/request.dto': 'dto/request.dto.hbs',
      'dto/response.dto': 'dto/response.dto.hbs',
      'dto/view.dto': 'dto/view.dto.hbs',

      // Guard templates
      'guard/type.guard': 'guard/type.guard.hbs',

      // Interface templates
      'interface/model.interface': 'interface/model.interface.hbs',
      'interface/relationships.interface': 'interface/relationships.interface.hbs',
      'interface/view.interface': 'interface/view.interface.hbs',

      // Schema templates
      'schema/model.schema': 'schema/model.schema.hbs',
      'schema/transform': 'schema/transform.hbs',
      'schema/validation': 'schema/validation.schema.hbs',

      // Index template
      'index': 'index.hbs',
    }

    console.log('Loading templates...')
    for (const [name, path] of Object.entries(templateFiles)) {
      try {
        const fullPath = join(templatesPath, path)
        console.log(`Loading template ${name} from ${fullPath}`)
        const content = await readFile(fullPath, 'utf-8')
        this.templates.set(name, this.handlebars.compile(content))
      } catch (error) {
        console.error(`Error loading template ${name}:`, error)
      }
    }

    console.log('Templates loaded')
    this.templatesLoaded = true
  }

  /**
   * Register all Handlebars helpers
   */
  private static registerDefaultHelpers(): void {
    // Type mapping helpers
    this.registerHelper('mapType', (type: string) => this.typeMapper.mapType(type))
    this.registerHelper('mapFieldType', (field) => this.typeMapper.mapFieldType(field))
    this.registerHelper('getSwaggerType', (field) => this.typeMapper.getSwaggerType(field))

    // Logical operators
    this.registerHelper('eq', (a, b) => a === b)
    this.registerHelper('neq', (a, b) => a !== b)
    this.registerHelper('and', (a, b) => a && b)
    this.registerHelper('or', (a, b) => a || b)
    this.registerHelper('not', (a) => !a)

    // String manipulation
    this.registerHelper('lowercase', (str) => str?.toLowerCase())
    this.registerHelper('uppercase', (str) => str?.toUpperCase())
    this.registerHelper('capitalize', (str) => {
      if (!str) return ''
      return str.charAt(0).toUpperCase() + str.slice(1)
    })
    this.registerHelper('pascalCase', (str: string) => {
      return str
        .split(/[-_\s]+/)
        .map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
        .join('')
    })

    // Array helpers
    this.registerHelper('join', (arr, separator) => arr?.join(separator))
    this.registerHelper('length', (arr) => arr?.length || 0)
    this.registerHelper('first', (arr) => arr?.[0])
    this.registerHelper('last', (arr) => arr?.[arr.length - 1])

    // Object helpers
    this.registerHelper('json', (obj) => JSON.stringify(obj, null, 2))
    this.registerHelper('get', (obj, key) => obj?.[key])
    this.registerHelper('keys', (obj) => Object.keys(obj || {}))
    this.registerHelper('values', (obj) => Object.values(obj || {}))

    // Validation helpers
    this.registerHelper('isRequired', (field) => field.isRequired)
    this.registerHelper('hasValidation', (field) => field.validationRules?.length > 0)
    this.registerHelper('hasTransform', (field) => field.transformationRules?.length > 0)

    // Conditional helper
    this.registerHelper('ifCond', function (v1, operator, v2, options) {
      switch (operator) {
        case '==':
          return v1 == v2 ? options.fn(this) : options.inverse(this)
        case '===':
          return v1 === v2 ? options.fn(this) : options.inverse(this)
        case '!=':
          return v1 != v2 ? options.fn(this) : options.inverse(this)
        case '!==':
          return v1 !== v2 ? options.fn(this) : options.inverse(this)
        case '<':
          return v1 < v2 ? options.fn(this) : options.inverse(this)
        case '<=':
          return v1 <= v2 ? options.fn(this) : options.inverse(this)
        case '>':
          return v1 > v2 ? options.fn(this) : options.inverse(this)
        case '>=':
          return v1 >= v2 ? options.fn(this) : options.inverse(this)
        case '&&':
          return v1 && v2 ? options.fn(this) : options.inverse(this)
        case '||':
          return v1 || v2 ? options.fn(this) : options.inverse(this)
        default:
          return options.inverse(this)
      }
    })

    // Formatting helpers
    this.registerHelper('date', (date) => (date ? new Date(date).toISOString() : ''))
    this.registerHelper('formatDate', (date, format) => {
      if (!date) return ''
      const d = new Date(date)
      switch (format) {
        case 'short':
          return d.toLocaleDateString()
        case 'long':
          return d.toLocaleString()
        case 'iso':
          return d.toISOString()
        default:
          return d.toString()
      }
    })
  }

  /**
   * Process a template with context
   */
  static process(templateName: string, context: any): string {
    // Log the incoming template name and check if it's a full path
    console.log('Processing template:', {
      requestedTemplate: templateName,
      isFullPath: templateName.includes('/'),
    })

    // Debug logging
    console.log('Template Context in Engine:', JSON.stringify(context, null, 2))

    // If it's a full path, extract just the template name part
    const normalizedName = templateName.includes('/templates/')
      ? templateName.split('/templates/')[1].replace(/\.hbs$/, '')
      : templateName.replace(/\.hbs$/, '')

    console.log('Normalized template name:', normalizedName)

    const template = this.templates.get(normalizedName)

    if (!template) {
      console.error('Template lookup failed:', {
        requested: templateName,
        normalized: normalizedName,
        availableTemplates: Array.from(this.templates.keys()),
      })
      throw new Error(`Template ${templateName} not found`)
    }

    // Process imports first
    if (context.hasValidation || context.hasTransform) {
      const imports = []
      imports.push("import { ApiProperty } from '@nestjs/swagger';")
      if (context.hasValidation) {
        imports.push("import { IsNotEmpty, IsOptional } from 'class-validator';")
      }
      if (context.hasTransform) {
        imports.push("import { Transform } from 'class-transformer';")
      }
      context.processedImports = imports.join('\n')
    }

    const result = template(context)
    console.log('Template Result:', result)

    return result
  }

  /**
   * Register a custom helper
   */
  static registerHelper(name: string, helper: Handlebars.HelperDelegate): void {
    this.handlebars.registerHelper(name, helper)
  }

  /**
   * Register a custom partial
   */
  static registerPartial(name: string, partial: string): void {
    this.handlebars.registerPartial(name, partial)
  }
}

================
File: templates/template.helpers.ts
================
// tools/generators/dto/templates/template.helpers.ts
import Handlebars from 'handlebars'
import { TypeMapper } from '../utils/type-mapper'

const typeMapper = new TypeMapper()

export function registerHandlebarsHelpers() {
  // Type mapping helpers
  Handlebars.registerHelper('mapFieldType', (field) => {
    return typeMapper.mapFieldType(field)
  })

  Handlebars.registerHelper('getSwaggerType', (field) => {
    return typeMapper.getSwaggerType(field)
  })

  // Logical operators
  Handlebars.registerHelper('eq', (a, b) => a === b)
  Handlebars.registerHelper('neq', (a, b) => a !== b)
  Handlebars.registerHelper('and', (a, b) => a && b)
  Handlebars.registerHelper('or', (a, b) => a || b)
  Handlebars.registerHelper('not', (a) => !a)

  // String manipulation
  Handlebars.registerHelper('lowercase', (str) => str?.toLowerCase())
  Handlebars.registerHelper('uppercase', (str) => str?.toUpperCase())
  Handlebars.registerHelper('capitalize', (str) => {
    if (!str) return ''
    return str.charAt(0).toUpperCase() + str.slice(1)
  })

  // Array helpers
  Handlebars.registerHelper('join', (arr, separator) => arr?.join(separator))
  Handlebars.registerHelper('length', (arr) => arr?.length || 0)
  Handlebars.registerHelper('first', (arr) => arr?.[0])
  Handlebars.registerHelper('last', (arr) => arr?.[arr.length - 1])

  // Object helpers
  Handlebars.registerHelper('json', (obj) => JSON.stringify(obj, null, 2))
  Handlebars.registerHelper('get', (obj, key) => obj?.[key])
  Handlebars.registerHelper('keys', (obj) => Object.keys(obj || {}))
  Handlebars.registerHelper('values', (obj) => Object.values(obj || {}))

  // Conditional helpers
  Handlebars.registerHelper('ifCond', function (v1, operator, v2, options) {
    switch (operator) {
      case '==':
        return v1 == v2 ? options.fn(this) : options.inverse(this)
      case '===':
        return v1 === v2 ? options.fn(this) : options.inverse(this)
      case '!=':
        return v1 != v2 ? options.fn(this) : options.inverse(this)
      case '!==':
        return v1 !== v2 ? options.fn(this) : options.inverse(this)
      case '<':
        return v1 < v2 ? options.fn(this) : options.inverse(this)
      case '<=':
        return v1 <= v2 ? options.fn(this) : options.inverse(this)
      case '>':
        return v1 > v2 ? options.fn(this) : options.inverse(this)
      case '>=':
        return v1 >= v2 ? options.fn(this) : options.inverse(this)
      case '&&':
        return v1 && v2 ? options.fn(this) : options.inverse(this)
      case '||':
        return v1 || v2 ? options.fn(this) : options.inverse(this)
      default:
        return options.inverse(this)
    }
  })

  // Formatting helpers
  Handlebars.registerHelper('date', (date) => {
    if (!date) return ''
    return new Date(date).toISOString()
  })

  Handlebars.registerHelper('formatDate', (date, format) => {
    if (!date) return ''
    const d = new Date(date)
    switch (format) {
      case 'short':
        return d.toLocaleDateString()
      case 'long':
        return d.toLocaleString()
      case 'iso':
        return d.toISOString()
      default:
        return d.toString()
    }
  })
}

================
File: templates/template.system.ts
================
// tools/generators/dto/templates/template.system.ts

import type { ModelMetadata, FieldMetadata, NestedTypeMetadata } from '../types'
import { TemplateEngine } from './template.engine'

/**
 * Enhanced template system that provides a flexible and extensible way to generate
 * different types of DTOs and related classes. This system supports inheritance,
 * custom decorators, and specialized NestJS features.
 */
export class TemplateSystem {
  /**
   * Maintains a registry of custom decorators that can be applied to
   * DTOs and their properties. This allows for easy extension of the
   * template system with new decorators.
   */
  private static customDecorators: Map<string, DecoratorDefinition> = new Map()

  /**
   * Registers a custom decorator for use in templates. This allows users
   * to extend the system with their own decorators while maintaining
   * type safety and documentation.
   */
  static registerDecorator(name: string, definition: DecoratorDefinition): void {
    this.customDecorators.set(name, definition)
  }

  /**
   * Generates a complete DTO class with all necessary imports, decorators,
   * and class members. This is the main entry point for template generation.
   */
  static generateDTO(model: ModelMetadata, options: DTOGenerationOptions): string {
    // Use template engine directly
    const context = {
      model,
      options,
      imports: this.generateImports(model, options),
      classDecorators: this.generateClassDecorators(model, options),
      methods: this.generateMethods(model, options),
    }

    return TemplateEngine.process(options.isView ? 'dto/view.dto' : 'dto/model.dto', context)
  }

  /**
   * Generates imports based on the features being used in the DTO.
   * This includes framework imports, custom decorators, and base classes.
   */
  private static generateImports(model: ModelMetadata, options: DTOGenerationOptions): string {
    const imports = new Set<string>()

    // Add base NestJS imports
    imports.add(`import { ApiProperty } from '@nestjs/swagger'`)

    // Add validation imports if needed
    if (options.useValidation) {
      imports.add(`import { IsString, IsNumber, IsBoolean, IsOptional } from 'class-validator'`)
    }

    // Add transformation imports if needed
    if (options.useTransformation) {
      imports.add(`import { Transform } from 'class-transformer'`)
    }

    // Add inheritance-related imports
    if (options.extends) {
      imports.add(`import { ${options.extends} } from '../base'`)
    }

    // Add custom decorator imports
    this.customDecorators.forEach((decorator) => {
      if (decorator.importStatement) {
        imports.add(decorator.importStatement)
      }
    })

    return Array.from(imports).join('\n')
  }

  /**
   * Generates class-level decorators including custom decorators,
   * API documentation, and validation rules.
   */
  private static generateClassDecorators(
    model: ModelMetadata,
    options: DTOGenerationOptions,
  ): string {
    const decorators = []

    // Add API documentation decorators
    decorators.push(`@ApiTags('${model.name}')`)

    // Add response type decorators for controllers
    if (options.isResponse) {
      decorators.push(this.generateResponseDecorators(model))
    }

    // Add custom class-level decorators
    model.decorators?.forEach((decorator) => {
      const customDecorator = this.customDecorators.get(decorator.name)
      if (customDecorator) {
        decorators.push(customDecorator.generate(decorator.params))
      }
    })

    return decorators.join('\n')
  }

  /**
   * Generates response type decorators for OpenAPI documentation.
   * This method creates decorators that describe the structure and
   * possible status codes of API responses.
   */
  private static generateResponseDecorators(model: ModelMetadata): string {
    const decorators = [
      `@ApiResponse({
        status: 200,
        description: 'Successful response',
        type: ${model.name}DTO
      })`,
      `@ApiResponse({
        status: 400,
        description: 'Bad request - validation error'
      })`,
      `@ApiResponse({
        status: 401,
        description: 'Unauthorized - authentication required'
      })`,
    ]

    // Add specific error responses if defined in model metadata
    if (model.errorResponses) {
      model.errorResponses.forEach((error) => {
        decorators.push(`@ApiResponse({
          status: ${error.status},
          description: '${error.description}'
        })`)
      })
    }

    return decorators.join('\n')
  }

  /**
   * Generates class methods based on the DTO type and options.
   * This includes transformation methods, validation methods,
   * and any custom business logic methods.
   */
  private static generateMethods(model: ModelMetadata, options: DTOGenerationOptions): string {
    const methods = []

    // Add toEntity transformation method
    if (options.useTransformation) {
      methods.push(`
  /**
   * Transforms this DTO to its corresponding entity
   */
  toEntity(): Record<string, any> {
    return {
      ${model.fields.map((field) => `${field.name}: this.${field.name}`).join(',\n      ')}
    }
  }`)
    }

    // Add validation method if needed
    if (options.useValidation) {
      methods.push(`
  /**
   * Validates this DTO instance
   */
  async validate(): Promise<ValidationError[]> {
    return validate(this)
  }`)
    }

    // Add custom business logic methods from metadata
    if (model.methods) {
      model.methods.forEach((method) => {
        methods.push(
          TemplateEngine.process(method.template, {
            methodName: method.name,
            params: method.parameters,
            returnType: method.returnType,
            body: method.body,
          }),
        )
      })
    }

    return methods.join('\n\n')
  }

  /**
   * Generates property decorators for a field including validation,
   * transformation, and documentation decorators.
   */
  private static generatePropertyDecorators(
    field: FieldMetadata,
    options: DTOGenerationOptions,
  ): string {
    const decorators = []

    // Add API documentation decorator
    decorators.push(this.generateApiPropertyDecorator(field))

    // Add validation decorators if enabled
    if (options.useValidation) {
      decorators.push(...this.generateValidationDecorators(field))
    }

    // Add transformation decorators if enabled
    if (options.useTransformation) {
      decorators.push(...this.generateTransformationDecorators(field))
    }

    // Add custom decorators from field metadata
    field.decorators?.forEach((decorator) => {
      const customDecorator = this.customDecorators.get(decorator.name)
      if (customDecorator) {
        decorators.push(customDecorator.generate(decorator.params))
      }
    })

    return decorators.join('\n  ')
  }

  /**
   * Generates the TypeScript type definition for a field,
   * handling arrays, nested types, and generics.
   */
  private static generateTypeDefinition(field: FieldMetadata): string {
    let type = field.type

    // Handle array types
    if (field.isArray) {
      type = `${type}[]`
    }

    // Handle generic types
    if (field.genericParams) {
      type = `${type}<${field.genericParams.join(', ')}>`
    }

    // Handle nested types
    if (field.nestedType) {
      type = this.generateNestedTypeDefinition(field.nestedType)
    }

    return type
  }

  /**
   * Helper method to generate API property decorator with complete metadata.
   */
  private static generateApiPropertyDecorator(field: FieldMetadata): string {
    const options = {
      description: field.documentation.description,
      required: field.isRequired,
      type: () => field.type,
      isArray: field.isArray,
      example: field.documentation.example,
    }

    return `@ApiProperty(${JSON.stringify(options, null, 2)})`
  }

  /**
   * Helper method to generate validation decorators for a field.
   */
  private static generateValidationDecorators(field: FieldMetadata): string[] {
    const decorators = []

    if (field.isRequired) {
      decorators.push('@IsNotEmpty()')
    } else {
      decorators.push('@IsOptional()')
    }

    // Add type-specific validation
    switch (field.type) {
      case 'string':
        decorators.push('@IsString()')
        break
      case 'number':
        decorators.push('@IsNumber()')
        break
      case 'boolean':
        decorators.push('@IsBoolean()')
        break
      // Add more type validations as needed
    }

    return decorators
  }

  /**
   * Helper method to generate transformation decorators for a field.
   */
  private static generateTransformationDecorators(field: FieldMetadata): string[] {
    const decorators = []

    if (field.transformationRules) {
      field.transformationRules.forEach((rule) => {
        decorators.push(`@Transform(${rule.transformer})`)
      })
    }

    return decorators
  }

  /**
   * Generates type definitions for nested types within our DTOs.
   * This method handles complex object structures, allowing us to properly
   * represent nested data in our TypeScript types.
   */
  private static generateNestedTypeDefinition(nestedType: NestedTypeMetadata): string {
    // If it's a simple nested type, just return its name
    if (typeof nestedType === 'string') {
      return nestedType
    }

    // For object types, generate an inline interface
    if (nestedType.type === 'object') {
      const properties = nestedType.properties.map((prop) => {
        const type = this.generateTypeDefinition(prop)
        return `${prop.name}${prop.isRequired ? '' : '?'}: ${type}`
      })

      return `{
        ${properties.join(';\n        ')}
      }`
    }

    // For enums, generate a union type
    if (nestedType.type === 'enum') {
      return nestedType.values.map((value) => `'${value}'`).join(' | ')
    }

    // For nested arrays, recursively generate the item type
    if (nestedType.type === 'array') {
      const itemType = this.generateTypeDefinition(nestedType.itemType)
      return `${itemType}[]`
    }

    // Default to any if we can't determine the type
    return 'any'
  }

  /**
   * Generates the class definition including inheritance if specified.
   * This supports both single and multiple inheritance through mixins.
   */
  private static generateClassDefinition(
    model: ModelMetadata,
    options: DTOGenerationOptions,
  ): string {
    let definition = `export class ${model.name}DTO`

    // Handle inheritance
    if (options.extends) {
      definition += ` extends ${options.extends}`
    }

    // Handle mixins if any
    if (options.mixins?.length) {
      const mixinChain = options.mixins.join(', ')
      definition += ` implements ${mixinChain}`
    }

    return definition
  }

  /**
   * Generates the complete class body including properties, methods,
   * and any additional features required by the DTO type.
   */
  private static generateClassBody(model: ModelMetadata, options: DTOGenerationOptions): string {
    const properties = this.generateProperties(model.fields, options)
    const methods = this.generateMethods(model, options)
    const pipes = options.usePipes ? this.generatePipes(model) : ''

    return `{
  ${properties}

  ${methods}

  ${pipes}
}`
  }

  /**
   * Generates property declarations with appropriate decorators
   * for validation, transformation, and documentation.
   */
  private static generateProperties(
    fields: FieldMetadata[],
    options: DTOGenerationOptions,
  ): string {
    return fields
      .map((field) => {
        const decorators = this.generatePropertyDecorators(field, options)
        const typeDefinition = this.generateTypeDefinition(field)

        return `${decorators}
  ${field.name}${field.isRequired ? '' : '?'}: ${typeDefinition}`
      })
      .join('\n\n')
  }

  /**
   * Generates NestJS pipes for request validation and transformation.
   * These pipes can be used in controllers to automatically validate
   * and transform incoming requests.
   */
  private static generatePipes(model: ModelMetadata): string {
    return `
  /**
   * Creates a validation pipe for this DTO
   */
  static createValidationPipe(): ValidationPipe {
    return new ValidationPipe({
      transform: true,
      whitelist: true,
      forbidNonWhitelisted: true,
    })
  }

  /**
   * Creates a transformation pipe for this DTO
   */
  static createTransformationPipe(): ParseDTO<${model.name}DTO> {
    return new ParseDTO(${model.name}DTO)
  }`
  }
}

/**
 * Options for customizing DTO generation including feature flags
 * and inheritance configuration.
 */
interface DTOGenerationOptions {
  useValidation: boolean
  useTransformation: boolean
  usePipes: boolean
  isRequest: boolean
  isResponse: boolean
  extends?: string
  mixins?: string[]
}

/**
 * Definition of a custom decorator including its import statement
 * and generation logic.
 */
interface DecoratorDefinition {
  importStatement?: string
  generate: (params?: any[]) => string
}

================
File: types/config.types.ts
================
// tools/generators/dto/core/config.types.ts
import type { ModelMetadata } from './model.types'
import type { TemplateConfig } from './template.types'
import type { ValidationConfig } from './validation.types'

export interface CustomGenerator {
  name: string
  generate: (model: ModelMetadata) => Promise<void>
}

export interface GeneratorOptions {
  outputPath: string
  prettierConfig?: string
  documentation?: {
    enabled: boolean
    outputFormat: 'markdown' | 'html'
    includeExamples: boolean
  }
  validation?: {
    enabled: boolean
    useClassValidator: boolean
    useZod: boolean
  }
  transformation?: {
    enabled: boolean
    useCamelCase: boolean
    dateTransformation: boolean
  }
  typescript?: {
    strict: boolean
    generateInterfaces: boolean
    generateTypeGuards: boolean
  }
  includeGeneratedFields?: boolean
}

export interface GeneratedFile {
  path: string
  content: string
}

export interface GeneratorConfig {
  templatesPath: string
  outputPath: string
  prettierConfig?: string
  types: TypeMappingConfig
  validation: ValidationConfig
  templates: TemplateConfig
  plugins: PluginConfig[]
  output: OutputConfig
  hooks: HooksConfig
}
export interface TypeMappingConfig {
  defaultMappings: Record<string, string>
  customMappings: Record<string, string>
  typeConverters: Record<string, TypeConverter>
  genericTypes: GenericTypeConfig[]
}

export interface TypeConverter {
  toTypeScript: (value: any) => string
  toDatabase: (value: any) => string
  validate: (value: any) => boolean
}

export interface GenericTypeConfig {
  name: string
  typeParameters: number
  template: string
}

export interface PluginConfig {
  name: string
  enabled: boolean
  options?: Record<string, any>
  beforeGenerate?: () => Promise<void>
  afterGenerate?: () => Promise<void>
  generators?: CustomGenerator[]
}

export interface OutputConfig {
  format: 'typescript' | 'javascript'
  moduleSystem: 'esm' | 'commonjs'
  fileNaming: FileNamingConfig
  structure: OutputStructureConfig
}

export interface FileNamingConfig {
  case: 'kebab' | 'camel' | 'pascal'
  prefix?: string
  suffix?: string
}

export interface OutputStructureConfig {
  baseDir: string
  separateDirectories: boolean
  generateIndex: boolean
}

export interface HooksConfig {
  beforeGeneration?: () => Promise<void>
  afterGeneration?: () => Promise<void>
  beforeModelGeneration?: (model: ModelMetadata) => Promise<void>
  afterModelGeneration?: (model: ModelMetadata) => Promise<void>
}

================
File: types/documentation.types.ts
================
export interface DocumentationMetadata {
  description?: string
  deprecated?: boolean
  example?: string
  tags?: string[]
}

export interface DocumentationMetadata {
    description?: string
    example?: string
  }

================
File: types/field.types.ts
================
import type { ValidationRule, TransformationRule } from './rules.types'

export interface FieldMetadata {
  name: string
  type: string
  isRequired: boolean
  isList: boolean
  isUnique: boolean
  isId: boolean
  isReadOnly: boolean
  hasDefaultValue: boolean
  documentation?: string
  isGenerated?: boolean
  kind: 'scalar' | 'enum' | 'object'
  nativeType?: string | null
  validationRules?: ValidationRule[]
  transformationRules?: TransformationRule[]
}

export interface RelationshipMetadata {
  name: string
  type: string
  relationType: 'one-to-one' | 'one-to-many' | 'many-to-one' | 'many-to-many'
  isRequired: boolean
  isArray: boolean
  foreign: {
    model: string
    field: string
  }
}

export interface ComputedColumnMetadata {
  name: string
  expression: string
  dependsOn: string[]
  returnType: string
}

================
File: types/index.ts
================
export * from './field.types'
export * from './view.types'
export * from './postgresql.types'
export * from './config.types'
export * from './documentation.types'
export * from './model.types'
export * from './rules.types'
export * from './template.types'
export * from './rules.types'

================
File: types/model.types.ts
================
import type { DocumentationMetadata } from './documentation.types'
import type { FieldMetadata, RelationshipMetadata } from './field.types'
import type { ViewMetadata } from './view.types'

export interface ModelMetadata {
  name: string
  documentation: DocumentationMetadata
  fields: FieldMetadata[]
  relations: RelationshipMetadata[]
  isView?: boolean
  viewMetadata?: ViewMetadata
}

================
File: types/postgresql.types.ts
================
// tools/generators/dto/types/postgresql.types.ts

/**
 * Type definitions for PostgreSQL-specific types.
 * These interfaces match the structure of PostgreSQL's native types.
 */

// Geometric Types
export interface Point {
  x: number
  y: number
}

export interface Line {
  a: number // Line equation: ax + by + c = 0
  b: number
  c: number
}

export interface LineSegment {
  start: Point
  end: Point
}

export interface Box {
  high: Point // Upper right corner
  low: Point // Lower left corner
}

export interface Path {
  points: Point[]
  closed: boolean
}

export interface Polygon {
  points: Point[]
}

export interface Circle {
  center: Point
  radius: number
}

// Network Types
export type InetAddress = string // With runtime validation
export type CidrAddress = string // With runtime validation
export type MacAddress = string // With runtime validation
export type MacAddress8 = string // With runtime validation

// Range Types
export interface Range<T> {
  lower: T | null // null means unbounded
  upper: T | null // null means unbounded
  lowerInclusive: boolean
  upperInclusive: boolean
}

// JSON Types with validation
export interface JsonField<T = unknown> {
  value: T
  isValid(): boolean
  toString(): string
}

export interface RelationMetadata {
    name: string
    type: string
    isRequired: boolean
    isList: boolean
  }

================
File: types/rules.types.ts
================
export type TransformationType =
  | 'toDate'
  | 'toString'
  | 'toNumber'
  | 'toBoolean'
  | 'toArray'
  | 'trim'
  | 'lowercase'
  | 'uppercase'
  | 'custom'

export interface TransformationRule {
  type: TransformationType
  params?: any[]
  options?: {
    nullIfEmpty?: boolean
    preValidation?: boolean
    precision?: number
    format?: string
  }
  preValidate?: (value: any) => boolean
  transform?: (value: any) => any
}

export interface CompositeTransformationRule {
  rules: TransformationRule[]
  order: number[]
}

export interface ValidationMessageTemplates {
  required: string
  string: string
  number: string
  boolean: string
  date: string
  email: string
  minLength: string
  maxLength: string
  [key: string]: string
}

export interface ValidationContext {
  field: string
  value: any
  parameters?: Record<string, any>
  parent?: any
}

export type ValidatorFunction = (value: any) => boolean | Promise<boolean>

export interface ValidationRuleDefinition {
  name: string
  decorator: string
  parameters?: any[]
  message: string
  metadata?: {
    description?: string
    example?: string
    priority?: number
  }
  validate?: (value: any, context?: any) => boolean | Promise<boolean>
}

export interface ValidationRule {
  decorator: string
  parameters?: string[]
  message: string
}

export interface ValidationConfig {
  rules: ValidationRule[]
  messages: Record<string, string>
  customValidators: Record<string, ValidatorFunction>
}

export interface ValidationOptions {
  enabled: boolean
  useClassValidator: boolean
  useZod: boolean
  customRules?: ValidationRule[]
  customMessages?: Record<string, string>
  customValidators?: Record<string, ValidatorFunction>
}

================
File: types/template.types.ts
================
import type { ModelMetadata } from './model.types'
import type { DocumentationMetadata } from './documentation.types'
import type { ValidationRule } from './rules.types'
import type { TransformationRule } from './rules.types'

export type TemplateFunction = (context: any) => string

export interface TemplateContext {
  model: ModelMetadata
  imports?: string[]
  validationRules?: ValidationRule[]
  transformationRules?: TransformationRule[]
  documentation?: DocumentationMetadata
  [key: string]: any
}

export interface TemplateConfig {
  templatePaths?: string[]
  overrides?: Record<string, string>
  variables?: Record<string, any>
  functions?: Record<string, TemplateFunction>
}

================
File: types/view.types.ts
================
import type { ComputedColumnMetadata } from './field.types'

export interface ViewMetadata {
  sourceQuery: string
  materialized: boolean
  updatable: boolean
  dependencies: string[]
  computedColumns: ComputedColumnMetadata[]
}

================
File: utils/documentation-parser.ts
================
// tools/generators/dto/utils/documentation-parser.ts
import { DMMF } from '@prisma/generator-helper'
import type { ValidationRule, TransformationRule, DocumentationMetadata } from '../types'

/**
 * DocumentationParser extracts and processes documentation from Prisma schema
 * comments and converts them into structured metadata that can be used
 * throughout the generator.
 */
export class DocumentationParser {
  /**
   * Parses model-level documentation, extracting metadata and special
   * directives that affect code generation.
   */
  parseModelDocumentation(model: DMMF.Model): DocumentationMetadata {
    const docs = model.documentation || ''

    return {
      description: this.extractDescription(docs),
      example: this.extractExample(docs),
      deprecated: this.isDeprecated(docs),
      version: this.extractVersion(docs),
      since: this.extractSince(docs),
    }
  }

  /**
   * Parses field-level documentation, extracting validation rules,
   * examples, and other metadata.
   */
  parseFieldDocumentation(field: DMMF.Field): DocumentationMetadata {
    const docs = field.documentation || ''

    return {
      description: this.extractDescription(docs),
      example: this.extractExample(docs),
      deprecated: this.isDeprecated(docs),
      version: this.extractVersion(docs),
      validationRules: this.extractValidationRules(docs, field),
      transformationRules: this.extractTransformationRules(docs),
    }
  }

  /**
   * Extracts the main description from a documentation string,
   * removing special directives and annotations.
   */
  private extractDescription(docs: string): string {
    // Remove all special annotations
    return docs
      .replace(/@\w+\([^)]*\)/g, '') // Remove @decorator(...) style annotations
      .replace(/@\w+/g, '') // Remove @tag style annotations
      .trim()
  }

  /**
   * Extracts example values from documentation.
   * Examples can be specified using @example annotation.
   */
  private extractExample(docs: string): any {
    const exampleMatch = docs.match(/@example\s+([^@]+)/)
    if (!exampleMatch) return undefined

    try {
      // Try to parse as JSON first
      return JSON.parse(exampleMatch[1].trim())
    } catch {
      // If not valid JSON, return as string
      return exampleMatch[1].trim()
    }
  }

  /**
   * Checks if an entity is marked as deprecated.
   */
  private isDeprecated(docs: string): boolean {
    return docs.includes('@deprecated')
  }

  /**
   * Extracts version information from documentation.
   */
  private extractVersion(docs: string): string | undefined {
    const versionMatch = docs.match(/@version\s+([^\s@]+)/)
    return versionMatch ? versionMatch[1] : undefined
  }

  /**
   * Extracts the version when a feature was introduced.
   */
  private extractSince(docs: string): string | undefined {
    const sinceMatch = docs.match(/@since\s+([^\s@]+)/)
    return sinceMatch ? sinceMatch[1] : undefined
  }

  /**
   * Extracts validation rules from documentation comments.
   * These can be specified using @validate annotation.
   */
  private extractValidationRules(docs: string, field: DMMF.Field): ValidationRule[] {
    const rules: ValidationRule[] = []
    const validationMatches = docs.matchAll(/@validate\s*\(([^)]+)\)/g)

    for (const match of validationMatches) {
      const [decorator, ...params] = match[1].split(',').map((param) => param.trim())

      rules.push({
        decorator,
        params: params.length ? params : undefined,
      })
    }

    return rules
  }

  /**
   * Extracts transformation rules from documentation comments.
   * These can be specified using @transform annotation.
   */
  private extractTransformationRules(docs: string): TransformationRule[] {
    const rules: TransformationRule[] = []
    const transformMatches = docs.matchAll(/@transform\s*\(([^)]+)\)/g)

    for (const match of transformMatches) {
      const [type, ...params] = match[1].split(',').map((param) => param.trim())

      rules.push({
        type: type as any,
        params: params.length ? params : undefined,
      })
    }

    return rules
  }
}

================
File: utils/field-parser.ts
================
// tools/generators/dto/utils/field-parser.ts

import { DMMF } from '@prisma/generator-helper'
import type { DocumentationMetadata, FieldMetadata, ValidationRule } from '../types'

interface ConstraintInfo {
  type: string
  definition: string
  table: string
  columns: string[]
}

/**
 * Enhanced FieldParser that handles detailed PostgreSQL metadata,
 * infers validation rules from database constraints, and manages
 * computed fields.
 */
export class FieldParser {
  constructor() {}

  /**
   * Creates the base metadata for a field from DMMF
   */
  async parseField(field: DMMF.Field): Promise<FieldMetadata> {
    // Create basic field metadata
    return {
      name: field.name,
      type: this.mapPrismaType(field.type),
      isRequired: field.isRequired,
      isArray: field.isList,
      documentation: this.parseDocumentation(field),
      validationRules: this.getBasicValidationRules(field),
      transformationRules: [],
      isComputed: false,
    }
  }

  /**
   * Maps Prisma types to TypeScript types
   */
  private mapPrismaType(type: string): string {
    const typeMap: Record<string, string> = {
      String: 'string',
      Boolean: 'boolean',
      Int: 'number',
      BigInt: 'bigint',
      Float: 'number',
      Decimal: 'number',
      DateTime: 'Date',
      Json: 'Record<string, any>',
      Bytes: 'Buffer',
    }

    return typeMap[type] || 'any'
  }

  /**
   * Extracts documentation from field
   */
  private parseDocumentation(field: DMMF.Field): DocumentationMetadata {
    const docs = field.documentation || ''

    return {
      description: this.extractDescription(docs),
      example: undefined,
      deprecated: false,
      version: undefined,
    }
  }

  /**
   * Extracts description from documentation string
   */
  private extractDescription(docs: string): string {
    return docs
      .replace(/@\w+(\([^)]*\))?/g, '') // Remove all @directives
      .trim()
  }

  /**
   * Gets basic validation rules based on field properties
   */
  private getBasicValidationRules(field: DMMF.Field): ValidationRule[] {
    const rules: ValidationRule[] = []

    // Add required validation if field is not optional
    if (field.isRequired) {
      rules.push({
        decorator: 'IsNotEmpty',
        message: `${field.name} is required`,
      })
    }

    // Add type-specific validation
    switch (field.type) {
      case 'String':
        rules.push({
          decorator: 'IsString',
          message: `${field.name} must be a string`,
        })
        break
      case 'Int':
      case 'Float':
      case 'Decimal':
        rules.push({
          decorator: 'IsNumber',
          params: [{ allowNaN: false, allowInfinity: false }],
          message: `${field.name} must be a number`,
        })
        break
      case 'Boolean':
        rules.push({
          decorator: 'IsBoolean',
          message: `${field.name} must be a boolean`,
        })
        break
      case 'DateTime':
        rules.push({
          decorator: 'IsDate',
          message: `${field.name} must be a valid date`,
        })
        break
    }

    return rules
  }
}

================
File: utils/file-manager.ts
================
// tools/generators/dto/utils/file-manager.ts
import { mkdir, writeFile } from 'fs/promises'
import { join, dirname } from 'path'
import * as prettier from 'prettier'

/**
 * FileManager handles all file system operations for the generator.
 * It provides a consistent interface for file operations and ensures
 * proper formatting of generated code.
 */
export class FileManager {
  constructor(private readonly basePath: string) {}

  /**
   * Initializes the directory structure needed for generation.
   * Creates directories for different types of generated files.
   */
  async initializeDirectory(): Promise<void> {
    try {
      console.log(`Initializing directory: ${this.basePath}`)
      await mkdir(this.basePath, { recursive: true })
      console.log('Directory initialized successfully')
    } catch (error) {
      console.error('Failed to initialize directory:', error)
      throw error
    }
  }

  /**
   * Writes a file with proper formatting applied.
   * Handles different file types (TypeScript, Markdown, etc.) appropriately.
   */
  async writeFile(relativePath: string, content: string): Promise<void> {
    try {
      const fullPath = join(this.basePath, relativePath)
      console.log(`Writing file to: ${fullPath}`)
      await mkdir(dirname(fullPath), { recursive: true })
      await writeFile(fullPath, content, 'utf-8')
      console.log(`Successfully wrote file: ${relativePath}`)
    } catch (error) {
      console.error(`Failed to write file ${relativePath}:`, error)
      throw error
    }
  }
}

================
File: utils/type-mapper.ts
================
// tools/generators/dto/utils/type-mapper.ts
import type { FieldMetadata } from '../types'

/**
 * Maps Prisma types to TypeScript types
 */
export class TypeMapper {
  private readonly typeMap: Record<string, string> = {
    // Prisma scalar types
    'String': 'string',
    'string': 'string',
    'Boolean': 'boolean',
    'boolean': 'boolean',
    'Int': 'number',
    'Float': 'number',
    'number': 'number',
    'BigInt': 'bigint',
    'bigint': 'bigint',
    'Decimal': 'number',
    'decimal': 'number',
    'DateTime': 'Date',
    'Date': 'Date',
    'date': 'Date',
    'Json': 'Record<string, any>',
    'json': 'Record<string, any>',
    'Bytes': 'Buffer',
    'bytes': 'Buffer',

    // Special types
    'Record<string, any>': 'Record<string, any>',
    'unknown': 'unknown',
    'any': 'any',
  }

  /**
   * Maps a field to its TypeScript type, handling arrays and optional types
   */
  mapFieldType(field: FieldMetadata): string {
    let baseType = this.mapType(field.type)

    if (field.enum?.length) {
      baseType = field.enum.map((v) => `'${v}'`).join(' | ')
    }

    if (field.isArray) {
      baseType = `${baseType}[]`
    }

    return baseType
  }

  /**
   * Maps a Prisma type to a TypeScript type
   */
  mapType(type: string): string {
    // Try exact match first
    const mappedType = this.typeMap[type]
    if (mappedType) {
      return mappedType
    }

    // Try case-insensitive match
    const lowerType = type.toLowerCase()
    for (const [key, value] of Object.entries(this.typeMap)) {
      if (key.toLowerCase() === lowerType) {
        return value
      }
    }

    // Handle unknown types
    console.warn(`Unknown type: ${type}, defaulting to 'unknown'`)
    return 'unknown'
  }

  // ZOD TYPES

  private readonly zodTypeMap: Record<string, string> = {
    String: 'string',
    string: 'string',
    Boolean: 'boolean',
    boolean: 'boolean',
    Int: 'number',
    Float: 'number',
    number: 'number',
    BigInt: 'bigint',
    bigint: 'bigint',
    Decimal: 'number',
    decimal: 'number',
    DateTime: 'date',
    Date: 'date',
    date: 'date',
    Json: 'record(z.unknown())',
    json: 'record(z.unknown())',
    Bytes: 'instanceof(Buffer)',
    bytes: 'instanceof(Buffer)',
  }

  /**
   * Maps a field to its Zod type, handling arrays and optional types
   */
  mapToZodType(field: FieldMetadata): string {
    let baseType = this.getZodType(field.type)

    // Handle enums
    if (field.enum?.length) {
      baseType = `enum([${field.enum.map((v) => `'${v}'`).join(', ')}])`
    }

    // Handle arrays
    if (field.isArray) {
      baseType = `array(z.${baseType}())`
    }

    // Handle nullable/optional
    if (!field.isRequired) {
      baseType = `${baseType}.nullable()`
    }

    return baseType
  }

  /**
   * Maps a Prisma type to a Zod type
   */
  private getZodType(type: string): string {
    // Try exact match first
    const zodType = this.zodTypeMap[type]
    if (zodType) {
      return zodType
    }

    // Try case-insensitive match
    const lowerType = type.toLowerCase()
    for (const [key, value] of Object.entries(this.zodTypeMap)) {
      if (key.toLowerCase() === lowerType) {
        return value
      }
    }

    // Handle unknown types
    console.warn(`Unknown type for Zod mapping: ${type}, defaulting to 'any'`)
    return 'any()'
  }

  mapPrismaToZod(type: string): string {
    switch (type.toLowerCase()) {
      case 'string':
        return 'string'
      case 'boolean':
        return 'boolean'
      case 'int':
      case 'float':
      case 'decimal':
        return 'number'
      case 'datetime':
      case 'date':
        return 'date'
      case 'json':
        return 'record(z.unknown())'
      case 'bytes':
        return 'instanceof(Buffer)'
      case 'bigint':
        return 'bigint'
      default:
        console.warn(`Unknown type for Zod mapping: ${type}, defaulting to 'any'`)
        return 'any()'
    }
  }

  /**
   * Gets the Swagger type for a field
   */
  getSwaggerType(field: FieldMetadata): string {
    const type = this.mapType(field.type)
    switch (type) {
      case 'string':
        return 'String'
      case 'number':
        return 'Number'
      case 'boolean':
        return 'Boolean'
      case 'Date':
        return 'Date'
      case 'Record<string, any>':
        return 'Object'
      case 'Buffer':
        return 'String'
      default:
        return 'String'
    }
  }
}

================
File: config.ts
================
// tools/generators/dto/config.ts
import { cosmiconfig } from 'cosmiconfig'
import type { GeneratorOptions } from './types'

/**
 * Configuration management for the DTO generator.
 * Handles loading and merging of configuration from multiple sources:
 * - Default configuration
 * - Configuration file (.dtogenrc, package.json, etc.)
 * - Command line arguments
 */
export class ConfigurationManager {
  private static readonly DEFAULT_CONFIG: GeneratorOptions = {
    outputPath: 'src/generated',
    documentation: {
      enabled: true,
      outputFormat: 'markdown',
      includeExamples: true,
    },
    validation: {
      enabled: true,
      useClassValidator: true,
      useZod: false,
    },
    transformation: {
      enabled: true,
      useCamelCase: true,
      dateTransformation: true,
    },
    typescript: {
      strict: true,
      generateInterfaces: true,
      generateTypeGuards: true,
    },
  }

  /**
   * Loads and merges configuration from all sources.
   */
  static async loadConfiguration(
    cliOptions: Partial<GeneratorOptions> = {},
  ): Promise<GeneratorOptions> {
    // Load configuration file using cosmiconfig
    const explorer = cosmiconfig('dtogen')
    const result = await explorer.search()

    // Merge configurations with priority: CLI > File > Default
    return {
      ...this.DEFAULT_CONFIG,
      ...(result?.config || {}),
      ...cliOptions,
    }
  }

  /**
   * Validates the configuration to ensure all required options are present
   * and have valid values.
   */
  static validateConfiguration(config: GeneratorOptions): void {
    // Validate output path
    if (!config.outputPath) {
      throw new Error('Output path is required')
    }

    // Validate documentation configuration
    if (config.documentation.enabled) {
      if (!['markdown', 'html'].includes(config.documentation.outputFormat)) {
        throw new Error('Invalid documentation format')
      }
    }

    // Add additional validation as needed
  }
}

================
File: index.ts
================
// tools/generators/dto/index.ts
import { join } from 'path'
import { Command } from 'commander'
import { PrismaClient, Prisma } from '@prisma/client'
import { getDMMF } from '@prisma/internals'
import { DMMF } from '@prisma/generator-helper'
import { Chalk } from 'chalk'
import { ConfigurationManager } from './config'
import { BaseGenerator } from './core/base.generator'
import { FileManager } from './utils/file-manager'
import { DocumentationGenerator } from './modules/documentation'
import { ValidationGenerator } from './modules/validators'
import { TransformationGenerator } from './modules/transformers'
import { InterfaceGenerator } from './modules/interfaces'
import { SchemaGenerator } from './modules/schemas'
import { TypeGuardGenerator } from './modules/type-guard'
import { TypeMapper } from './utils/type-mapper'
import { OpenAPIMetadataGenerator } from './modules/openapi-metadata'
import type { GeneratorOptions, ModelMetadata, GeneratedFile, FieldMetadata } from './types'
import { readFile } from 'fs/promises'
import { TemplateEngine } from './templates/template.engine'

const chalk = new Chalk()

/**
 * Main entry point for the DTO generator.
 * Handles CLI interface, configuration loading, and orchestrates
 * the generation process.
 */

function withInitialization<T extends (...args: any[]) => any>(
  method: T,
): (...args: Parameters<T>) => Promise<ReturnType<T>> {
  return async function (
    this: { isReady: boolean; initialize: () => Promise<void> },
    ...args: any[]
  ) {
    if (!this.isReady) {
      console.log('Initialization required. Running initialize()...')
      await this.initialize()
    }
    return method.apply(this, args)
  }
}

export async function main() {
  const program = new Command()

  program
    .name('dtogen')
    .description('Generate DTOs from Prisma schema')
    .version('1.0.0')
    .option('-o, --output <path>', 'Output directory for generated files')
    .option('--no-validation', 'Disable validation decorators')
    .option('--no-documentation', 'Disable documentation generation')
    .parse(process.argv)

  const options = program.opts()
  const __dirname = new URL('.', import.meta.url).pathname

  try {
    // Load and validate configuration
    const config: GeneratorOptions = {
      outputPath: join(__dirname, 'src', 'generated'),
      typescript: {
        strict: true,
        generateInterfaces: true,
        generateTypeGuards: true,
      },
      validation: {
        enabled: true,
        useClassValidator: true,
        useZod: true,
      },
      documentation: {
        enabled: true,
        outputFormat: 'markdown' as const,
        includeExamples: true,
      },
    }
    ConfigurationManager.validateConfiguration(config)

    // Get DMMF directly from schema file
    const prisma = new PrismaClient()

    // Initialize generators
    const schemaPath = join(__dirname, '..', '..', '..', '..', 'prisma', 'schema.prisma')
    const fileManager = new FileManager(config.outputPath)
    const dmmf: DMMF.Document = await getDMMF({
      datamodelPath: schemaPath,
    })

    const generator = new DTOGenerator(dmmf, config, prisma, fileManager)

    // Generate all artifacts
    console.log(chalk.blue('Starting DTO generation...'))
    await generator.generate()
    console.log(chalk.green('DTO generation completed successfully!'))
  } catch (error) {
    console.error(chalk.red('Error during generation:'), error)
    process.exit(1)
  }
}

class DTOGenerator extends BaseGenerator {
  private documentationGenerator: DocumentationGenerator
  private validationGenerator: ValidationGenerator
  private transformationGenerator: TransformationGenerator

  constructor(
    dmmf: DMMF.Document,
    options: GeneratorOptions,
    prisma: PrismaClient,
    fileManager: FileManager,
  ) {
    super(dmmf, options)

    // Initialize type mapper as other generators depend on it
    this.typeMapper = new TypeMapper()

    // Initialize generators with template manager
    this.validationGenerator = new ValidationGenerator()
    this.transformationGenerator = new TransformationGenerator()
    this.documentationGenerator = new DocumentationGenerator([], options, this.fileManager)
  }

  override async initialize(): Promise<void> {
    await super.initialize() // Initialize the template engine
    await this.initializeDocumentationGenerator() // Any subclass-specific initialization
  }

  private async initializeDocumentationGenerator(): Promise<void> {
    const processedModels = await Promise.all(
      this.dmmf.datamodel.models.map((model) => this.processModel(model)),
    )

    this.documentationGenerator = new DocumentationGenerator(
      processedModels,
      this.options,
      this.fileManager,
    )
  }

  protected async generateInterface(metadata: ModelMetadata): Promise<GeneratedFile> {
    await this.ensureInitialized()

    const templateName = metadata.isView ? 'interface/view.interface' : 'interface/model.interface'
    const templatePath = join(__dirname, 'templates', `${templateName}.hbs`)
    console.log(`${templatePath} with dirname ${__dirname}`)

    const content = TemplateEngine.process(templatePath, {
      model: metadata,
      imports: this.getInterfaceImports(metadata),
      typeMapper: this.typeMapper,
    })

    return {
      path: `interfaces/${metadata.name.toLowerCase()}.interface.ts`,
      content,
    }
  }

  protected async generateValidatedDTO(metadata: ModelMetadata): Promise<GeneratedFile> {
    await this.ensureInitialized()

    const templateName = metadata.isView ? 'dto/view.dto' : 'dto/model.dto'
    const templatePath = join(__dirname, 'templates', `${templateName}.hbs`)
    console.log(`${templatePath} with dirname ${__dirname}`)

    const hasValidation = metadata.fields.some((f) => f.validationRules?.length)
    const hasTransform = metadata.fields.some((f) => f.transformationRules?.length)

    // Process validation and transformation rules
    const fields = metadata.fields.map((field) => ({
      ...field,
      validationRules: field.validationRules?.map((rule) => rule.decorator),
      transformationRules: field.transformationRules?.map((rule) => `Transform${rule.type}`),
    }))

    const templateContext = {
      name: metadata.name,
      documentation: metadata.documentation,
      fields,
      hasValidation,
      hasTransform,
    }

    // Debug logging
    console.log('Template Context:', JSON.stringify(templateContext, null, 2))

    const content = TemplateEngine.process(templatePath, templateContext)

    console.log(`Generated DTO content length: ${content.length}`)
    console.log('Generated DTO content:', content)

    return {
      path: `dto/${metadata.name.toLowerCase()}.dto.ts`,
      content,
    }
  }

  protected async generateTypeGuard(metadata: ModelMetadata): Promise<GeneratedFile> {
    await this.ensureInitialized()

    const content = TemplateEngine.process('guard/type.guard.hbs', {
      ...metadata,
      imports: this.getTypeGuardImports(metadata),
    })

    return {
      path: `guards/${metadata.name.toLowerCase()}.guard.ts`,
      content,
    }
  }

  protected async generateZodSchema(metadata: ModelMetadata): Promise<GeneratedFile> {
    await this.ensureInitialized()

    const content = TemplateEngine.process('schema/model.schema.hbs', {
      ...metadata,
      imports: this.getSchemaImports(metadata),
      zodTypes: this.getZodTypes(metadata),
    })

    return {
      path: `schemas/${metadata.name.toLowerCase()}.schema.ts`,
      content,
    }
  }

  protected async generateDocumentation(): Promise<void> {
    if (!this.documentationGenerator) {
      await this.initializeDocumentationGenerator()
    }
    await this.documentationGenerator.generate()
  }

  protected async generateIndexFile(): Promise<void> {
    await this.ensureInitialized()

    const content = TemplateEngine.process('index.hbs', {
      models: this.dmmf.datamodel.models.map((model) => ({
        name: model.name.toLowerCase(),
        hasInterface: this.options.typescript?.generateInterfaces,
        hasTypeGuard: this.options.typescript?.generateTypeGuards,
        hasSchema: this.options.validation?.useZod,
      })),
    })

    await this.fileManager.writeFile('index.ts', content)
  }

  protected async generateUtilityFiles(): Promise<void> {
    await this.ensureInitialized()
    // Generate base types
    const baseTypesTemplate = TemplateEngine.process('base/type-helpers.hbs', {})
    await this.fileManager.writeFile('base/base-types.ts', baseTypesTemplate)

    // Generate helpers
    const helpersTemplate = TemplateEngine.process('base/helpers.hbs', {})
    await this.fileManager.writeFile('base/helpers.ts', helpersTemplate)
  }

  // Helper methods for template context
  private getInterfaceImports(metadata: ModelMetadata): string[] {
    const imports = ['BaseEntity']
    if (metadata.relations?.length) {
      imports.push(...metadata.relations.map((rel) => `I${rel.type}`))
    }
    return imports
  }

  private getDTOImports(metadata: ModelMetadata): string[] {
    const imports = ['ApiProperty']
    if (metadata.fields.some((f) => f.validationRules?.length)) {
      imports.push('IsNotEmpty', 'IsOptional')
    }
    if (metadata.fields.some((f) => f.transformationRules?.length)) {
      imports.push('Transform')
    }
    return imports
  }

  private getTypeGuardImports(metadata: ModelMetadata): string[] {
    return [`I${metadata.name}`, `${metadata.name}Schema`]
  }

  private getSchemaImports(metadata: ModelMetadata): string[] {
    const imports = ['z']
    if (metadata.relations?.length) {
      imports.push(...metadata.relations.map((rel) => `${rel.type}Schema`))
    }
    return imports
  }

  private getSwaggerTypes(metadata: ModelMetadata): Record<string, string> {
    return Object.fromEntries(
      metadata.fields.map((field) => [field.name, this.getSwaggerType(field)]),
    )
  }

  private getZodTypes(metadata: ModelMetadata): Record<string, string> {
    return Object.fromEntries(
      metadata.fields.map((field) => [field.name, this.typeMapper.mapToZodType(field)]),
    )
  }

  private getSwaggerType(field: FieldMetadata): string {
    switch (field.type) {
      case 'String':
        return 'String'
      case 'Int':
      case 'Float':
      case 'Decimal':
        return 'Number'
      case 'Boolean':
        return 'Boolean'
      case 'DateTime':
        return 'Date'
      case 'Json':
        return 'Object'
      default:
        if (field.kind === 'enum') {
          return field.type
        }
        return 'String'
    }
  }
}

// Run the generator if called directly
if (require.main === module) {
  main()
}
