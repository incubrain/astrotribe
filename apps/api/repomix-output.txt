This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-16T09:06:20.265Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
scripts/
  barrel.generator.ts
  build-logger.ts
src/
  content/
    __tests__/
      utils/
        sample-data.utils.ts
        test.utils.ts
      categories.test.ts
      content-categories.test.ts
      content-source-visits.test.ts
      content-sources.test.ts
      content-statuses.test.ts
      content-tags.test.ts
      contents.test.ts
      embedding-reviews.test.ts
      feed-categories.test.ts
      feed-sources.test.ts
      feeds.test.ts
      news-summaries.test.ts
      news-tags.test.ts
      news.test.ts
      newsletters.test.ts
      research-embeddings.test.ts
      research.test.ts
      tags.test.ts
    controllers/
      categories.controller.ts
      content-categories.controller.ts
      content-source-visits.controller.ts
      content-sources.controller.ts
      content-statuses.controller.ts
      content-tags.controller.ts
      content.controller.ts
      embedding-reviews.controller.ts
      feed-categories.controller.ts
      feed-sources.controller.ts
      feeds.controller.ts
      news-summaries.controller.ts
      news-tags.controller.ts
      news.controller.ts
      newsletters.controller.ts
      research-embeddings.controller.ts
      research.controller.ts
      tags.controller.ts
    models/
      categories.model.ts
      content-categories.model.ts
      content-source-visits.model.ts
      content-sources.model.ts
      content-statuses.model.ts
      content-tags.model.ts
      contents.model.ts
      embedding-reviews.model.ts
      feed-categories.model.ts
      feed-sources.model.ts
      feeds.model.ts
      news-summaries.model.ts
      news-tags.model.ts
      news.model.ts
      newsletters.model.ts
      research-embeddings.model.ts
      research.model.ts
      tags.model.ts
    services/
      categories.service.ts
      content-categories.service.ts
      content-source-visits.service.ts
      content-sources.service.ts
      content-statuses.service.ts
      content-tags.service.ts
      content.service.ts
      embedding-reviews.service.ts
      feed-categories.service.ts
      feed-sources.service.ts
      feeds.service.ts
      news-summaries.service.ts
      news-tags.service.ts
      news.service.ts
      newsletters.service.ts
      research-embeddings.service.ts
      research.service.ts
      tags.service.ts
    content.module.ts
    index.ts
  core/
    __tests__/
      permission.guard.test.ts
      permission.service.test.ts
    base/
      base.controller.ts
      base.dto.ts
      base.gateway.ts
      base.model.ts
      base.service.ts
    cache/
      cache.mock.ts
      cache.module.ts
    config/
      configuration.ts
      domain-config.ts
    decorators/
      api.decorator.ts
      current-user.decorator.ts
      permission.decorator.ts
      plan.decorator.ts
      public.decorator.ts
      roles.decorator.ts
      service.decorator.ts
      validate.decorator.ts
    dto/
      pagination.dto.ts
    filters/
      http-exception.filter.ts
    guards/
      api-key.guard.ts
      permission.guard.ts
      plan.guard.ts
      throttler.guard.ts
    interceptors/
      bigint.interceptor.ts
      logging.interceptor.ts
      pagination.interceptor.ts
    logger/
      custom.logger.ts
      logger.colors.ts
    modules/
      logger.module.ts
      permission.module.ts
      prisma.module.ts
    pipes/
      transformation.pipe.ts
      trim.pipe.ts
      type-conversion.pipe.ts
      validation.pipe.ts
    services/
      debug.service.ts
      pagination.service.ts
      permission.service.ts
      prisma.service.ts
    storage/
      throttler.storage.ts
    utils/
      auth.utils.ts
      permission.utils.ts
    webhook/
      razorpay.service.ts
      webhook.module.ts
    core.module.ts
    index.ts
  jobs/
    controllers/
      job-config.controller.ts
      job-metric.controller.ts
    services/
      job-config.service.ts
      job-metric.service.ts
    index.ts
    job.module.ts
  monitoring/
    controllers/
      error-metrics.controller.ts
      health.controller.ts
      log.controller.ts
    gateways/
      log.gateway.ts
    services/
      error-metrics.service.ts
      log.service.ts
      monitoring.service.ts
    index.ts
    monitoring.module.ts
  payments/
    controllers/
      payment.controller.ts
      plan.controller.ts
      provider.controller.ts
      refund.controller.ts
      subscription.controller.ts
      webhook.controller.ts
    models/
      payment.model.ts
      plan.model.ts
      provider.model.ts
      refund.model.ts
      subscription.model.ts
    services/
      payment.service.ts
      plan.service.ts
      provider.service.ts
      refund.service.ts
      subscription.service.ts
    index.ts
    payment.module.ts
  types/
    domain.types.ts
    index.ts
    pagination.types.ts
    permission.types.ts
    plan.types.ts
    subscription.types.ts
  app.module.ts
  main.ts
  metadata.ts
  tree.txt
.dockerignore
code-style.md
docker-compose.yml
Dockerfile
eslint.config.js
nest-cli.json
package.json
project.json
README.md
tsconfig.json
vite.config.ts
vitest.config.ts
vitest.setup.ts

================================================================
Repository Files
================================================================

================
File: scripts/barrel.generator.ts
================
import { fileURLToPath } from 'url'
import * as fs from 'fs'
import * as path from 'path'
import { CustomLogger } from '../src/core/logger/custom.logger'

interface BarrelConfig {
  rootDir: string
  directories: string[]
  extensions?: string[]
  ignorePatterns?: string[]
  generateNestedBarrels?: boolean
  excludeDirs?: string[]
}

export class BarrelGenerator {
  private readonly logger: CustomLogger
  private readonly defaultExtensions = ['.ts', '.tsx'] as const
  private readonly defaultIgnorePatterns = [
    '.module',
    '.module.ts',
    '.spec.ts',
    '.test.ts',
    '.e2e-spec.ts',
    '.d.ts',
    'index.ts',
  ] as const
  private readonly defaultExcludeDirs = ['__tests__', 'dist', 'node_modules'] as const

  constructor(logger: CustomLogger) {
    this.logger = logger
    this.logger.setContext('BarrelGenerator')
  }

  private isDirectoryExcluded(dirPath: string, excludeDirs: string[]): boolean {
    return excludeDirs.some(
      (excludeDir) => dirPath.includes(`/${excludeDir}/`) || dirPath.endsWith(`/${excludeDir}`),
    )
  }

  async generateBarrels(config: BarrelConfig): Promise<void> {
    try {
      const {
        rootDir,
        directories,
        extensions = [...this.defaultExtensions],
        ignorePatterns = [...this.defaultIgnorePatterns],
        generateNestedBarrels = true,
        excludeDirs = [...this.defaultExcludeDirs],
      } = config

      this.logger.log(`Starting barrel file generation for directories: ${directories.join(', ')}`)

      for (const dir of directories) {
        const fullPath = path.join(rootDir, dir)

        if (!fs.existsSync(fullPath)) {
          this.logger.warn(`Directory not found: ${fullPath}`)
          continue
        }

        await this.processDirectory(fullPath, {
          extensions,
          ignorePatterns,
          generateNestedBarrels,
          excludeDirs,
        })
      }

      this.logger.log('Barrel file generation completed successfully')
    } catch (error) {
      this.logger.error(
        'Failed to generate barrel files',
        error instanceof Error ? error.stack : String(error),
      )
      throw error
    }
  }

  private async processDirectory(
    dirPath: string,
    options: Required<
      Pick<BarrelConfig, 'extensions' | 'ignorePatterns' | 'generateNestedBarrels' | 'excludeDirs'>
    >,
    isRootDir = true,
  ): Promise<string[]> {
    try {
      const files = await fs.promises.readdir(dirPath, { withFileTypes: true })
      const exports: string[] = []
      const rootDir = isRootDir ? dirPath : path.dirname(dirPath)

      if (!isRootDir && this.isDirectoryExcluded(dirPath, options.excludeDirs)) {
        return exports
      }

      const validFiles = files
        .filter((file) => file.isFile())
        .map((file) => file.name)
        .filter((filename) => {
          const isValidExtension = options.extensions.some((ext) => filename.endsWith(ext))
          const shouldInclude = !options.ignorePatterns.some((pattern) =>
            filename.includes(pattern),
          )
          return isValidExtension && shouldInclude
        })

      validFiles.forEach((filename) => {
        const relativePath = path.relative(rootDir, path.join(dirPath, filename))
        exports.push(this.generateExportStatement(relativePath))
      })

      const subdirs = files.filter((file) => file.isDirectory())
      for (const subdir of subdirs) {
        const subdirPath = path.join(dirPath, subdir.name)
        if (!this.isDirectoryExcluded(subdirPath, options.excludeDirs)) {
          const nestedExports = await this.processDirectory(subdirPath, options, false)
          exports.push(...nestedExports)
        }
      }

      if (isRootDir) {
        await this.writeBarrelFile(dirPath, exports)
      }

      return exports
    } catch (error) {
      this.logger.error(
        `Error processing directory ${dirPath}:`,
        error instanceof Error ? error.stack : String(error),
      )
      throw error
    }
  }

  private generateExportStatement(filename: string): string {
    const withoutExt = filename.replace(/\.tsx?$/, '')
    return `export * from './${withoutExt}'`
  }

  private generateBarrelContent(exports: string[]): string {
    const uniqueExports = [...new Set(exports)]
    return [
      '/**',
      ' * @file Auto-generated barrel file',
      ' * @generated',
      ' */',
      '',
      uniqueExports.join('\n'),
      '', // Trailing newline
    ].join('\n')
  }

  private async writeBarrelFile(dirPath: string, exports: string[]): Promise<void> {
    const barrelPath = path.join(dirPath, 'index.ts')
    const content = this.generateBarrelContent(exports)

    try {
      await fs.promises.writeFile(barrelPath, content)
      this.logger.debug(`Generated barrel file: ${barrelPath}`)
    } catch (error) {
      this.logger.error(
        `Error writing barrel file ${barrelPath}:`,
        error instanceof Error ? error.stack : String(error),
      )
      throw error
    }
  }
}

const __dirname = path.dirname(fileURLToPath(import.meta.url))

export async function generateProjectBarrels(): Promise<void> {
  const logger = new CustomLogger('BarrelGenerator')
  const generator = new BarrelGenerator(logger)

  await generator.generateBarrels({
    rootDir: path.resolve(__dirname, '../src'),
    directories: ['core', 'content', 'types', 'monitoring', 'jobs'],
    ignorePatterns: [
      // NestJS Critical Files
      '.controller.ts',
      '.service.ts',
      '.module.ts',
      '.guard.ts',
      '.middleware.ts',
      '.filter.ts',
      '.interceptor.ts',
      '.decorator.ts',
      '.provider.ts',
      '.resolver.ts',

      // Test Files
      '.spec.ts',
      '.test.ts',
      '.e2e-spec.ts',

      // Other Common Ignores
      '.d.ts',
      'index.ts',
      '.mock.ts',
    ],
    generateNestedBarrels: false,
  })
}

// Execute if running directly
if (import.meta.url.endsWith(process.argv[1])) {
  generateProjectBarrels().catch((error: unknown) => {
    console.error(
      'Error generating barrel files:',
      error instanceof Error ? error.stack : String(error),
    )
    process.exit(1)
  })
}

================
File: scripts/build-logger.ts
================
import { spawn } from 'child_process'
import { createWriteStream } from 'fs'
import { join, dirname } from 'path'
import { mkdir } from 'fs/promises'

// Get the API project root directory
const API_ROOT = join(process.cwd())
const LOG_FILE = join(API_ROOT, 'logs', 'build-debug.log')

async function createLogDir() {
  const logDir = dirname(LOG_FILE)
  try {
    await mkdir(logDir, { recursive: true })
    console.log(`Created log directory: ${logDir}`)
  } catch (err) {
    console.warn(`Warning: Could not create log directory: ${err}`)
  }
}

async function runBuildWithLogs() {
  await createLogDir()

  const logStream = createWriteStream(LOG_FILE, { flags: 'w' })
  const timestamp = new Date().toISOString()

  logStream.write(`Build started at ${timestamp}\n`)
  logStream.write('Environment:\n')
  logStream.write(`CWD: ${process.cwd()}\n`)
  logStream.write(`NODE_ENV: ${process.env.NODE_ENV}\n`)
  logStream.write('----------------------------------------\n\n')

  const buildProcess = spawn('nx', ['build', '@astronera/api', '--verbose'], {
    env: {
      ...process.env,
      NODE_DEBUG: 'module',
      FORCE_COLOR: 'true',
    },
    stdio: ['inherit', 'pipe', 'pipe'],
  })

  // Pipe process output to both console and log file
  buildProcess.stdout?.on('data', (data) => {
    process.stdout.write(data)
    logStream.write(data)
  })

  buildProcess.stderr?.on('data', (data) => {
    process.stderr.write(data)
    logStream.write(data)
  })

  return new Promise<void>((resolve, reject) => {
    buildProcess.on('exit', (code) => {
      const endTimestamp = new Date().toISOString()
      logStream.write(`\n----------------------------------------\n`)
      logStream.write(`Build finished at ${endTimestamp}\n`)
      logStream.write(`Exit code: ${code}\n`)
      logStream.end()

      if (code === 0) {
        console.log(`\nBuild succeeded. Logs saved to ${LOG_FILE}`)
        resolve()
      } else {
        const error = new Error(`Build process exited with code ${code}`)
        console.error(`\nBuild failed. Logs saved to ${LOG_FILE}`)
        reject(error)
      }
    })

    buildProcess.on('error', (error) => {
      logStream.write(`\nBuild process error: ${error.message}\n`)
      logStream.end()
      reject(error)
    })
  })
}

// Run the build logger
runBuildWithLogs().catch((error) => {
  console.error('Build failed:', error.message)
  process.exit(1)
})

================
File: src/content/__tests__/utils/sample-data.utils.ts
================
import type { Prisma } from '@astronera/db'
import { ContentType, ContentStatus, Priority } from '@astronera/db'
import { faker } from '@faker-js/faker'

export const createSampleCategory = (): Prisma.CategoriesCreateInput => ({
  id: faker.number.int(),
  name: faker.commerce.department(),
})

export const createSampleContentCategory = (): Prisma.ContentCategoriesCreateInput => ({
  is_primary: faker.datatype.boolean(),
  contents: { connect: { id: faker.string.uuid() } },
  categories: { connect: { id: faker.number.int() } },
})

export const createSampleContentSource = (): Prisma.ContentSourcesCreateInput => ({
  url: faker.internet.url(),
  content_type: faker.helpers.arrayElement([...Object.values(ContentType)]),
  scrape_frequency: faker.helpers.arrayElement(['daily', 'weekly', 'monthly']),
  refreshed_at: faker.date.recent(),
  has_failed: faker.datatype.boolean(),
  failed_count: faker.number.int({ min: 0, max: 10 }),
  priority: faker.helpers.arrayElement([...Object.values(Priority)]),
  hash: faker.number.int(),
  scraped_at: faker.date.recent(),
  expected_count: faker.number.int({ min: 1, max: 100 }),
  rss_urls: [faker.internet.url(), faker.internet.url()],
})

export const createSampleContentSourceVisit = (): Prisma.ContentSourceVisitsCreateInput => ({
  contents: { connect: { id: faker.string.uuid() } },
  user_profiles: { connect: { id: faker.string.uuid() } },
})

export const createSampleContentStatus = (): Prisma.ContentStatusesCreateInput => ({
  contents: { connect: { id: faker.string.uuid() } },
  notes: faker.helpers.arrayElement([faker.lorem.words(3), null]),
  content_status: faker.helpers.arrayElement([...Object.values(ContentStatus)]),
})

export const createSampleContentTag = (): Prisma.ContentTagsCreateInput => ({
  contents: { connect: { id: faker.string.uuid() } },
  tags: { connect: { id: faker.number.int() } },
})

export const createSampleContent = (): Prisma.ContentsCreateInput => ({
  content_type: faker.helpers.arrayElement([...Object.values(ContentType)]),
  title: faker.helpers.arrayElement([faker.lorem.words(3), null]),
  url: faker.internet.url(),
  rss_url: faker.helpers.arrayElement([faker.internet.url(), null]),
  hot_score: faker.helpers.arrayElement([faker.number.int({ min: 0, max: 100 }), null]),
})

================
File: src/content/__tests__/utils/test.utils.ts
================
import { Test } from '@nestjs/testing'
import { PrismaService } from '@core/services/prisma.service'
import { ConfigService } from '@nestjs/config'
import { PaginationService } from '@core/services/pagination.service'
import { CustomLogger } from '@core/logger/custom.logger'
import { Reflector } from '@nestjs/core'

import { vi, expect, describe, it, beforeEach, type Mock, type MockedFunction } from 'vitest'

// Mock Prisma content_type enum
export const content_type = {
  ARTICLE: 'ARTICLE',
  NEWS: 'NEWS',
  BLOG: 'BLOG',
  VIDEO: 'VIDEO',
  PODCAST: 'PODCAST',
} as const

// Mock Prisma client
vi.mock('@astronera/db', () => {
  class PrismaClientKnownRequestError extends Error {
    code: string
    constructor(message: string, { code }: { code: string }) {
      super(message)
      this.name = 'PrismaClientKnownRequestError'
      this.code = code
    }
  }

  class PrismaClientValidationError extends Error {
    constructor(message: string) {
      super(message)
      this.name = 'PrismaClientValidationError'
    }
  }

  const Prisma = {
    ModelName: {
      contents: 'contents',
      content_tags: 'content_tags',
      content_statuses: 'content_statuses',
      content_source_visits: 'content_source_visits',
      feed_sources: 'feed_sources',
      feed_categories: 'feed_categories',
      feeds: 'feeds',
      news_summaries: 'news_summaries',
      news_tags: 'news_tags',
    },
    content_type,
    PrismaClientKnownRequestError,
    PrismaClientValidationError,
  }

  return {
    PrismaClient: vi.fn(),
    Prisma,
  }
})

export type MockType<T> = {
  [P in keyof T]: T[P] extends (...args: any[]) => any ? Mock : T[P]
}

// Generic helper to create mocked service
export const createMockService = <T extends object>(): MockType<T> => {
  const mock: MockType<T> = {} as MockType<T>

  // Get all methods from the service prototype
  const prototype = Object.getPrototypeOf({} as T)
  const propertyNames = Object.getOwnPropertyNames(prototype)

  // Create mock functions for all methods
  propertyNames.forEach((key) => {
    if (key !== 'constructor') {
      ;(mock as any)[key] = vi.fn()
    }
  })

  return mock
}

export const createBaseMockService = () => ({
  findAll: vi.fn(),
  findOne: vi.fn(),
  create: vi.fn(),
  update: vi.fn(),
  remove: vi.fn(),
  executeQuery: vi.fn(),
  executePrismaQuery: vi.fn(),
  handleError: vi.fn(),
})

export const createSuccessResponse = (data: any) => ({
  success: true,
  data,
  timestamp: expect.any(String),
})

export const createErrorResponse = (error: string) => ({
  success: false,
  error,
  timestamp: expect.any(String),
  code: 'UNKNOWN_ERROR',
})

export const createPaginatedResponse = (data: any[], total: number) => ({
  success: true,
  items: data,
  meta: {
    total,
    page: 1,
    limit: 10,
    totalPages: Math.ceil(total / 10),
    hasNextPage: total > 10,
    hasPreviousPage: false,
  },
  timestamp: expect.any(String),
})

export const mockControllerProperties = (
  controller: any,
  mockPrismaModel: any,
  logger: CustomLogger,
  service: any,
  paginationService: PaginationService,
  serviceName: string,
) => {
  Object.defineProperty(controller, 'model', {
    get: () => mockPrismaModel,
  })
  Object.defineProperty(controller, 'logger', {
    get: () => logger,
  })
  Object.defineProperty(controller, serviceName, {
    get: () => service,
  })
  Object.defineProperty(controller, 'paginationService', {
    get: () => paginationService,
  })
}

interface CreateTestModuleOptions {
  controller: any
  serviceClass: any
  mockService: any
  prismaModelName: string
  providers?: any[]
}

export const createTestModule = async ({
  controller,
  serviceClass,
  mockService,
  prismaModelName,
  providers = [],
}: CreateTestModuleOptions) => {
  const mockPrismaService = {
    [prismaModelName]: {
      findMany: vi.fn(),
      findUnique: vi.fn(),
      create: vi.fn(),
      update: vi.fn(),
      delete: vi.fn(),
      count: vi.fn(),
    },
  }

  const mockConfigService = {
    get: vi.fn((key: string) => {
      switch (key) {
        case 'SUPABASE_URL':
          return 'https://example.supabase.co'
        case 'SUPABASE_ANON_KEY':
          return 'test-key'
        case 'JWT_SECRET':
          return 'test-secret'
        default:
          return undefined
      }
    }),
  }

  const mockPaginationService = {
    paginate: vi.fn(),
    getPaginationMeta: vi.fn((total: number, query: any) => ({
      total,
      page: Number(query.page) || 1,
      limit: Number(query.limit) || 10,
      totalPages: Math.ceil(total / (Number(query.limit) || 10)),
      hasNextPage: total > (Number(query.limit) || 10),
      hasPreviousPage: (Number(query.page) || 1) > 1,
    })),
  }

  const mockLogger = {
    setContext: vi.fn(),
    log: vi.fn(),
    error: vi.fn(),
    warn: vi.fn(),
    debug: vi.fn(),
  }

  const mockReflector = {
    get: vi.fn(),
    getAllAndOverride: vi.fn(),
    getAllAndMerge: vi.fn(),
  }

  const module = await Test.createTestingModule({
    controllers: [controller],
    providers: [
      {
        provide: serviceClass,
        useValue: mockService,
      },
      {
        provide: PrismaService,
        useValue: mockPrismaService,
      },
      {
        provide: ConfigService,
        useValue: mockConfigService,
      },
      {
        provide: PaginationService,
        useValue: mockPaginationService,
      },
      {
        provide: CustomLogger,
        useValue: mockLogger,
      },
      {
        provide: Reflector,
        useValue: mockReflector,
      },
      ...providers,
    ],
  }).compile()

  return module
}

================
File: src/content/__tests__/categories.test.ts
================
import { describe, it, expect, beforeEach } from 'vitest'
import { faker } from '@faker-js/faker'
import { CategoryController } from '../controllers/categories.controller'
import { CategoriesService } from '../services/categories.service'
import { PrismaService } from '../../core/services/prisma.service'
import { PaginationService } from '../../core/services/pagination.service'
import { CustomLogger } from '../../core/logger/custom.logger'
import type { MockType } from './utils/test.utils'
import {
  createTestModule,
  createBaseMockService,
  createSuccessResponse,
  createErrorResponse,
  createPaginatedResponse,
  mockControllerProperties,
} from './utils/test.utils'
import { createSampleCategory } from './utils/sample-data.utils'

describe('CategoryController', () => {
  let controller: CategoryController
  let categoriesService: MockType<CategoriesService>
  let prismaService: PrismaService
  let logger: CustomLogger
  let paginationService: PaginationService
  let mockPrismaModel: any

  beforeEach(async () => {
    const mockService = createBaseMockService()
    const module = await createTestModule({
      controller: CategoryController,
      serviceClass: CategoriesService,
      mockService,
      prismaModelName: 'categories',
    })

    controller = module.get<CategoryController>(CategoryController)
    categoriesService = module.get(CategoriesService)
    prismaService = module.get<PrismaService>(PrismaService)
    logger = module.get<CustomLogger>(CustomLogger)
    paginationService = module.get<PaginationService>(PaginationService)
    mockPrismaModel = prismaService['categories']

    mockControllerProperties(
      controller,
      mockPrismaModel,
      logger,
      categoriesService,
      paginationService,
      'categoriesService',
    )
  })

  describe('findAllCategories', () => {
    it('should return paginated categories', async () => {
      const categories = [createSampleCategory(), createSampleCategory()]
      const query = { page: 1, limit: 10 }

      mockPrismaModel.findMany.mockResolvedValue(categories)
      mockPrismaModel.count.mockResolvedValue(2)
      categoriesService.findAllCategories.mockResolvedValue(createPaginatedResponse(categories, 2))

      const result = await controller.findAllCategories(query)

      expect(result).toEqual(createPaginatedResponse(categories, 2))
      expect(logger.log).toHaveBeenCalledWith('Fetching all categories')
      expect(logger.debug).toHaveBeenCalledWith('Found 2 categories')
    })

    it('should handle errors', async () => {
      const error = new Error('Database error')
      categoriesService.findAllCategories.mockRejectedValue(error)

      const result = await controller.findAllCategories({ page: 1, limit: 10 })
      expect(result).toEqual(createErrorResponse('Database error'))
      expect(logger.error).toHaveBeenCalledWith('Failed to fetch categories', error.stack)
    })
  })

  describe('findOneCategories', () => {
    it('should return a single category', async () => {
      const category = createSampleCategory()
      const id = faker.string.uuid()

      mockPrismaModel.findUnique.mockResolvedValue(category)

      const result = await controller.findOneCategories(id)

      expect(result).toEqual(createSuccessResponse(category))
    })

    it('should handle errors', async () => {
      const id = faker.string.uuid()
      const error = new Error('Not found')
      mockPrismaModel.findUnique.mockRejectedValue(error)

      const result = await controller.findOneCategories(id)
      expect(result).toEqual(createErrorResponse('Not found'))
    })
  })

  describe('createCategories', () => {
    it('should create a category', async () => {
      const createData = createSampleCategory()
      const createdCategory = { id: faker.string.uuid(), ...createData }

      mockPrismaModel.create.mockResolvedValue(createdCategory)

      const result = await controller.createCategories(createData)

      expect(result).toEqual(createSuccessResponse(createdCategory))
    })

    it('should handle errors', async () => {
      const createData = createSampleCategory()
      const error = new Error('Creation failed')
      mockPrismaModel.create.mockRejectedValue(error)

      const result = await controller.createCategories(createData)
      expect(result).toEqual(createErrorResponse('Creation failed'))
    })
  })

  describe('updateCategories', () => {
    it('should update a category', async () => {
      const id = faker.string.uuid()
      const updateData = {
        name: faker.commerce.department(),
        updated_at: new Date(),
      }
      const updatedCategory = { id, ...updateData }

      mockPrismaModel.update.mockResolvedValue(updatedCategory)

      const result = await controller.updateCategories(id, updateData)

      expect(result).toEqual(createSuccessResponse(updatedCategory))
    })

    it('should handle errors', async () => {
      const id = faker.string.uuid()
      const updateData = {
        name: faker.commerce.department(),
      }
      const error = new Error('Update failed')
      mockPrismaModel.update.mockRejectedValue(error)

      const result = await controller.updateCategories(id, updateData)
      expect(result).toEqual(createErrorResponse('Update failed'))
    })
  })

  describe('removeCategories', () => {
    it('should remove a category', async () => {
      const id = faker.string.uuid()
      const deletedCategory = { id }

      mockPrismaModel.delete.mockResolvedValue(deletedCategory)

      const result = await controller.removeCategories(id)

      expect(result).toEqual(createSuccessResponse(deletedCategory))
    })

    it('should handle errors', async () => {
      const id = faker.string.uuid()
      const error = new Error('Delete failed')
      mockPrismaModel.delete.mockRejectedValue(error)

      const result = await controller.removeCategories(id)
      expect(result).toEqual(createErrorResponse('Delete failed'))
    })
  })
})

================
File: src/content/__tests__/content-categories.test.ts
================
import { describe, it, expect, beforeEach, vi } from 'vitest'
import { Test } from '@nestjs/testing'
import { ConfigService } from '@nestjs/config'
import type { Prisma } from '@astronera/db'
import { faker } from '@faker-js/faker'
import { ContentCategoryController } from '../controllers/content-categories.controller'
import { ContentCategoriesService } from '../services/content-categories.service'
import { PrismaService } from '../../core/services/prisma.service'
import { PaginationService } from '../../core/services/pagination.service'
import { CustomLogger } from '../../core/logger/custom.logger'

const createSampleContentCategory = (): Prisma.ContentCategoriesCreateInput => ({
  is_primary: faker.datatype.boolean(),
  contents: { connect: { id: faker.string.uuid() } },
  categories: { connect: { id: faker.number.int() } },
})

describe('ContentCategoryController', () => {
  let controller: ContentCategoryController
  let contentCategoriesService: ContentCategoriesService
  let prismaService: PrismaService
  let logger: CustomLogger
  let paginationService: PaginationService

  const mockPrismaService = {
    content_categories: {
      findMany: vi.fn(),
      findUnique: vi.fn(),
      create: vi.fn(),
      update: vi.fn(),
      delete: vi.fn(),
      count: vi.fn(),
    },
  }

  const mockContentCategoriesService = {
    findAll: vi.fn(),
    findOne: vi.fn(),
    create: vi.fn(),
    update: vi.fn(),
    remove: vi.fn(),
  }

  const mockConfigService = {
    get: vi.fn(),
  }

  const mockPaginationService = {
    paginate: vi.fn(),
    getPaginationMeta: vi.fn((total: number, query: any) => ({
      total,
      page: query.page || 1,
      limit: query.limit || 10,
      totalPages: Math.ceil(total / (query.limit || 10)),
    })),
  }

  const mockLogger = {
    log: vi.fn(),
    error: vi.fn(),
    warn: vi.fn(),
    debug: vi.fn(),
    verbose: vi.fn(),
  }

  beforeEach(async () => {
    vi.clearAllMocks()

    const module = await Test.createTestingModule({
      controllers: [ContentCategoryController],
      providers: [
        {
          provide: ContentCategoriesService,
          useValue: mockContentCategoriesService,
        },
        {
          provide: PrismaService,
          useValue: mockPrismaService,
        },
        {
          provide: ConfigService,
          useValue: mockConfigService,
        },
        {
          provide: PaginationService,
          useValue: mockPaginationService,
        },
        {
          provide: CustomLogger,
          useValue: mockLogger,
        },
      ],
    }).compile()

    controller = module.get<ContentCategoryController>(ContentCategoryController)
    contentCategoriesService = module.get<ContentCategoriesService>(ContentCategoriesService)
    prismaService = module.get<PrismaService>(PrismaService)
    logger = module.get<CustomLogger>(CustomLogger)
    paginationService = module.get<PaginationService>(PaginationService)

    // Mock the base controller's model property
    Object.defineProperty(controller, 'model', {
      get: () => mockPrismaService.content_categories,
    })

    // Mock the logger property
    Object.defineProperty(controller, 'logger', {
      get: () => mockLogger,
    })

    // Mock the contentCategoriesService property
    Object.defineProperty(controller, 'contentCategoriesService', {
      get: () => mockContentCategoriesService,
    })

    // Mock the paginationService property
    Object.defineProperty(controller, 'paginationService', {
      get: () => mockPaginationService,
    })
  })

  describe('findAllContentCategories', () => {
    it('should return paginated content categories', async () => {
      const contentCategories = [createSampleContentCategory(), createSampleContentCategory()]
      const query = { page: 1, limit: 10 }
      const paginatedResponse = {
        data: contentCategories,
        meta: {
          total: 2,
          page: 1,
          limit: 10,
          totalPages: 1,
        },
        success: true,
        timestamp: expect.any(String),
      }

      mockPrismaService.content_categories.findMany.mockResolvedValue(contentCategories)
      mockPrismaService.content_categories.count.mockResolvedValue(2)

      const result = await controller.findAllContentCategories(query)

      expect(result).toEqual(paginatedResponse)
    })

    it('should handle errors', async () => {
      const error = new Error('Database error')
      mockPrismaService.content_categories.findMany.mockRejectedValue(error)

      const result = await controller.findAllContentCategories({ page: 1, limit: 10 })
      expect(result).toEqual({
        success: false,
        error: 'Database error',
        timestamp: expect.any(String),
        code: 'UNKNOWN_ERROR',
      })
    })
  })

  describe('findOneContentCategories', () => {
    it('should return a single content category', async () => {
      const contentCategory = createSampleContentCategory()
      const id = faker.string.uuid()

      mockPrismaService.content_categories.findUnique.mockResolvedValue(contentCategory)

      const result = await controller.findOneContentCategories(id)

      expect(result).toEqual({
        success: true,
        data: contentCategory,
        timestamp: expect.any(String),
      })
    })

    it('should handle errors', async () => {
      const id = faker.string.uuid()
      const error = new Error('Not found')
      mockPrismaService.content_categories.findUnique.mockRejectedValue(error)

      const result = await controller.findOneContentCategories(id)
      expect(result).toEqual({
        success: false,
        error: 'Not found',
        timestamp: expect.any(String),
        code: 'UNKNOWN_ERROR',
      })
    })
  })

  describe('createContentCategories', () => {
    it('should create a content category', async () => {
      const createData: Prisma.content_categoriesCreateInput = createSampleContentCategory()
      const createdContentCategory = { id: faker.string.uuid(), ...createData }

      mockPrismaService.content_categories.create.mockResolvedValue(createdContentCategory)

      const result = await controller.createContentCategories(createData)

      expect(result).toEqual({
        success: true,
        data: createdContentCategory,
        timestamp: expect.any(String),
      })
    })

    it('should handle errors', async () => {
      const createData: Prisma.content_categoriesCreateInput = createSampleContentCategory()
      const error = new Error('Creation failed')
      mockPrismaService.content_categories.create.mockRejectedValue(error)

      const result = await controller.createContentCategories(createData)
      expect(result).toEqual({
        success: false,
        error: 'Creation failed',
        timestamp: expect.any(String),
        code: 'UNKNOWN_ERROR',
      })
    })
  })

  describe('updateContentCategories', () => {
    it('should update a content category', async () => {
      const id = faker.string.uuid()
      const updateData: Prisma.content_categoriesUpdateInput = {
        is_primary: faker.datatype.boolean(),
      }
      const updatedContentCategory = { id, ...updateData }

      mockPrismaService.content_categories.update.mockResolvedValue(updatedContentCategory)

      const result = await controller.updateContentCategories(id, updateData)

      expect(result).toEqual({
        success: true,
        data: updatedContentCategory,
        timestamp: expect.any(String),
      })
    })

    it('should handle errors', async () => {
      const id = faker.string.uuid()
      const updateData: Prisma.content_categoriesUpdateInput = {
        is_primary: faker.datatype.boolean(),
      }
      const error = new Error('Update failed')
      mockPrismaService.content_categories.update.mockRejectedValue(error)

      const result = await controller.updateContentCategories(id, updateData)
      expect(result).toEqual({
        success: false,
        error: 'Update failed',
        timestamp: expect.any(String),
        code: 'UNKNOWN_ERROR',
      })
    })
  })

  describe('removeContentCategories', () => {
    it('should remove a content category', async () => {
      const id = faker.string.uuid()
      const deletedContentCategory = { id }

      mockPrismaService.content_categories.delete.mockResolvedValue(deletedContentCategory)

      const result = await controller.removeContentCategories(id)

      expect(result).toEqual({
        success: true,
        data: deletedContentCategory,
        timestamp: expect.any(String),
      })
    })

    it('should handle errors', async () => {
      const id = faker.string.uuid()
      const error = new Error('Delete failed')
      mockPrismaService.content_categories.delete.mockRejectedValue(error)

      const result = await controller.removeContentCategories(id)
      expect(result).toEqual({
        success: false,
        error: 'Delete failed',
        timestamp: expect.any(String),
        code: 'UNKNOWN_ERROR',
      })
    })
  })
})

================
File: src/content/__tests__/content-source-visits.test.ts
================
import { describe, it, expect, beforeEach } from 'vitest'
import { PrismaService } from '@core/services/prisma.service'
import { PaginationService } from '@core/services/pagination.service'
import { CustomLogger } from '@core/logger/custom.logger'
import { faker } from '@faker-js/faker'
import type { Prisma } from '@astronera/db'
import { NotFoundException, InternalServerErrorException } from '@nestjs/common'
import { ContentSourceVisitService } from '../services/content-source-visits.service'
import { ContentSourceVisitController } from '../controllers/content-source-visits.controller'
import type { MockType } from './utils/test.utils'
import {
  createTestModule,
  createBaseMockService,
  createSuccessResponse,
  createErrorResponse,
  createPaginatedResponse,
  mockControllerProperties,
} from './utils/test.utils'

const createSampleContentSourceVisit = (): Prisma.content_source_visitsCreateInput => ({
  contents: { connect: { id: faker.string.uuid() } },
  user_profiles: { connect: { id: faker.string.uuid() } },
})

describe('ContentSourceVisitController', () => {
  let controller: ContentSourceVisitController
  let contentSourceVisitService: MockType<ContentSourceVisitService>
  let prismaService: PrismaService
  let logger: CustomLogger
  let paginationService: PaginationService
  let mockPrismaModel: any

  beforeEach(async () => {
    const mockService = createBaseMockService()
    const module = await createTestModule({
      controller: ContentSourceVisitController,
      serviceClass: ContentSourceVisitService,
      mockService,
      prismaModelName: 'content_source_visits',
    })

    controller = module.get<ContentSourceVisitController>(ContentSourceVisitController)
    contentSourceVisitService = module.get(ContentSourceVisitService)
    prismaService = module.get<PrismaService>(PrismaService)
    logger = module.get<CustomLogger>(CustomLogger)
    paginationService = module.get<PaginationService>(PaginationService)
    mockPrismaModel = prismaService['content_source_visits']

    mockControllerProperties(
      controller,
      mockPrismaModel,
      logger,
      contentSourceVisitService,
      paginationService,
      'contentSourceVisitService',
    )
  })

  describe('findAllContentSourceVisits', () => {
    it('should return paginated content source visits', async () => {
      const visits = [createSampleContentSourceVisit(), createSampleContentSourceVisit()]
      const query = { page: 1, limit: 10 }

      mockPrismaModel.findMany.mockResolvedValue(visits)
      mockPrismaModel.count.mockResolvedValue(2)

      const result = await controller.findAllContentSourceVisits(query)

      expect(result).toEqual(createPaginatedResponse(visits, 2))
    })

    it('should handle errors', async () => {
      mockPrismaModel.findMany.mockRejectedValue(new Error('Database error'))

      await expect(controller.findAllContentSourceVisits({ page: 1, limit: 10 })).rejects.toThrow(
        InternalServerErrorException,
      )
    })
  })

  describe('findOneContentSourceVisits', () => {
    it('should return a single content source visit', async () => {
      const visit = createSampleContentSourceVisit()
      const id = faker.string.uuid()

      mockPrismaModel.findUnique.mockResolvedValue(visit)

      const result = await controller.findOneContentSourceVisits(id)

      expect(result).toEqual(createSuccessResponse(visit))
    })

    it('should handle errors', async () => {
      const id = faker.string.uuid()
      mockPrismaModel.findUnique.mockResolvedValue(null)

      await expect(controller.findOneContentSourceVisits(id)).rejects.toThrow(NotFoundException)
    })
  })

  describe('createContentSourceVisits', () => {
    it('should create a content source visit', async () => {
      const createData = createSampleContentSourceVisit()
      const createdVisit = { id: faker.string.uuid(), ...createData }

      mockPrismaModel.create.mockResolvedValue(createdVisit)

      const result = await controller.createContentSourceVisits(createData)

      expect(result).toEqual(createSuccessResponse(createdVisit))
    })

    it('should handle errors', async () => {
      const createData = createSampleContentSourceVisit()
      mockPrismaModel.create.mockRejectedValue(new Error('Creation failed'))

      await expect(controller.createContentSourceVisits(createData)).rejects.toThrow(
        InternalServerErrorException,
      )
    })
  })

  describe('updateContentSourceVisits', () => {
    it('should update a content source visit', async () => {
      const id = faker.string.uuid()
      const updateData = createSampleContentSourceVisit()
      const updatedVisit = { id, ...updateData }

      mockPrismaModel.update.mockResolvedValue(updatedVisit)

      const result = await controller.updateContentSourceVisits(id, updateData)

      expect(result).toEqual(createSuccessResponse(updatedVisit))
    })

    it('should handle errors', async () => {
      const id = faker.string.uuid()
      const updateData = createSampleContentSourceVisit()
      mockPrismaModel.update.mockRejectedValue(new Error('Update failed'))

      await expect(controller.updateContentSourceVisits(id, updateData)).rejects.toThrow(
        InternalServerErrorException,
      )
    })
  })

  describe('removeContentSourceVisits', () => {
    it('should remove a content source visit', async () => {
      const id = faker.string.uuid()
      const deletedVisit = { id }

      mockPrismaModel.findUnique.mockResolvedValue(deletedVisit)
      mockPrismaModel.delete.mockResolvedValue(deletedVisit)

      const result = await controller.removeContentSourceVisits(id)

      expect(result).toEqual(createSuccessResponse(deletedVisit))
    })

    it('should handle errors', async () => {
      const id = faker.string.uuid()
      mockPrismaModel.findUnique.mockResolvedValue(null)

      await expect(controller.removeContentSourceVisits(id)).rejects.toThrow(NotFoundException)
    })
  })
})

================
File: src/content/__tests__/content-sources.test.ts
================
import { describe, it, expect, beforeEach } from 'vitest'
import { faker } from '@faker-js/faker'
import type { Prisma } from '@astronera/db'
import { content_type } from '@astronera/db'
import { ContentSourceController } from '../controllers/content-sources.controller'
import { ContentSourcesService } from '../services/content-sources.service'
import { PrismaService } from '../../core/services/prisma.service'
import { PaginationService } from '../../core/services/pagination.service'
import { CustomLogger } from '../../core/logger/custom.logger'
import type { MockType } from './utils/test.utils'
import {
  createTestModule,
  createBaseMockService,
  createSuccessResponse,
  createErrorResponse,
  createPaginatedResponse,
  mockControllerProperties,
} from './utils/test.utils'
import { createSampleContentSource } from './utils/sample-data.utils'

describe('ContentSourceController', () => {
  let controller: ContentSourceController
  let contentSourcesService: MockType<ContentSourcesService>
  let prismaService: PrismaService
  let logger: CustomLogger
  let paginationService: PaginationService
  let mockPrismaModel: any

  beforeEach(async () => {
    const mockService = createBaseMockService()
    const module = await createTestModule({
      controller: ContentSourceController,
      serviceClass: ContentSourcesService,
      mockService,
      prismaModelName: 'content_sources',
    })

    controller = module.get<ContentSourceController>(ContentSourceController)
    contentSourcesService = module.get(ContentSourcesService)
    prismaService = module.get<PrismaService>(PrismaService)
    logger = module.get<CustomLogger>(CustomLogger)
    paginationService = module.get<PaginationService>(PaginationService)
    mockPrismaModel = prismaService['content_sources']

    mockControllerProperties(
      controller,
      mockPrismaModel,
      logger,
      contentSourcesService,
      paginationService,
      'contentSourcesService',
    )
  })

  describe('findAllContentSources', () => {
    it('should return paginated content sources', async () => {
      const contentSources = [createSampleContentSource(), createSampleContentSource()]
      const query = { page: 1, limit: 10 }

      mockPrismaModel.findMany.mockResolvedValue(contentSources)
      mockPrismaModel.count.mockResolvedValue(2)

      const result = await controller.findAllContentSources(query)

      expect(result).toEqual(createPaginatedResponse(contentSources, 2))
    })

    it('should handle errors', async () => {
      const error = new Error('Database error')
      mockPrismaModel.findMany.mockRejectedValue(error)

      const result = await controller.findAllContentSources({
        page: 1,
        limit: 10,
      })
      expect(result).toEqual(createErrorResponse('Database error'))
    })
  })

  describe('findOneContentSources', () => {
    it('should return a single content source', async () => {
      const contentSource = createSampleContentSource()
      const id = faker.string.uuid()

      mockPrismaModel.findUnique.mockResolvedValue(contentSource)

      const result = await controller.findOneContentSources(id)

      expect(result).toEqual(createSuccessResponse(contentSource))
    })

    it('should handle errors', async () => {
      const id = faker.string.uuid()
      const error = new Error('Not found')
      mockPrismaModel.findUnique.mockRejectedValue(error)

      const result = await controller.findOneContentSources(id)
      expect(result).toEqual(createErrorResponse('Not found'))
    })
  })

  describe('createContentSources', () => {
    it('should create a content source', async () => {
      const createData = createSampleContentSource()
      const createdContentSource = { id: faker.string.uuid(), ...createData }

      mockPrismaModel.create.mockResolvedValue(createdContentSource)

      const result = await controller.createContentSources(createData)

      expect(result).toEqual(createSuccessResponse(createdContentSource))
    })

    it('should handle errors', async () => {
      const createData = createSampleContentSource()
      const error = new Error('Creation failed')
      mockPrismaModel.create.mockRejectedValue(error)

      const result = await controller.createContentSources(createData)
      expect(result).toEqual(createErrorResponse('Creation failed'))
    })
  })

  describe('updateContentSources', () => {
    it('should update a content source', async () => {
      const id = faker.string.uuid()
      const updateData: Prisma.content_sourcesUpdateInput = {
        url: faker.internet.url(),
        content_type: faker.helpers.arrayElement([...Object.values(content_type)]),
        updated_at: new Date(),
        companies: { connect: { id: faker.string.uuid() } },
      }
      const updatedContentSource = {
        id,
        ...updateData,
        company_id: updateData.companies?.connect?.id,
        created_at: new Date(),
      }

      mockPrismaModel.update.mockResolvedValue(updatedContentSource)

      const result = await controller.updateContentSources(id, updateData)

      expect(result).toEqual(createSuccessResponse(updatedContentSource))
    })

    it('should handle errors', async () => {
      const id = faker.string.uuid()
      const updateData: Prisma.content_sourcesUpdateInput = {
        url: faker.internet.url(),
        companies: { connect: { id: faker.string.uuid() } },
      }
      const error = new Error('Update failed')
      mockPrismaModel.update.mockRejectedValue(error)

      const result = await controller.updateContentSources(id, updateData)
      expect(result).toEqual(createErrorResponse('Update failed'))
    })
  })

  describe('removeContentSources', () => {
    it('should remove a content source', async () => {
      const id = faker.string.uuid()
      const deletedContentSource = { id }

      mockPrismaModel.delete.mockResolvedValue(deletedContentSource)

      const result = await controller.removeContentSources(id)

      expect(result).toEqual(createSuccessResponse(deletedContentSource))
    })

    it('should handle errors', async () => {
      const id = faker.string.uuid()
      const error = new Error('Delete failed')
      mockPrismaModel.delete.mockRejectedValue(error)

      const result = await controller.removeContentSources(id)
      expect(result).toEqual(createErrorResponse('Delete failed'))
    })
  })
})

================
File: src/content/__tests__/content-statuses.test.ts
================
import { describe, it, expect, beforeEach } from 'vitest'
import { PrismaService } from '@core/services/prisma.service'
import { PaginationService } from '@core/services/pagination.service'
import { CustomLogger } from '@core/logger/custom.logger'
import { faker } from '@faker-js/faker'
import type { Prisma } from '@astronera/db'
import { content_status } from '@astronera/db'
import { NotFoundException, InternalServerErrorException } from '@nestjs/common'
import { ContentStatusesService } from '../services/content-statuses.service'
import { ContentStatusController } from '../controllers/content-statuses.controller'
import type { MockType } from './utils/test.utils'
import {
  createTestModule,
  createBaseMockService,
  createSuccessResponse,
  createErrorResponse,
  createPaginatedResponse,
  mockControllerProperties,
} from './utils/test.utils'

const createSampleContentStatus = (): Prisma.content_statusesCreateInput => ({
  contents: { connect: { id: faker.string.uuid() } },
  content_status: faker.helpers.arrayElement([...Object.values(content_status)]),
  created_at: faker.date.recent(),
  notes: faker.lorem.sentence(),
})

describe('ContentStatusController', () => {
  let controller: ContentStatusController
  let contentStatusesService: MockType<ContentStatusesService>
  let prismaService: PrismaService
  let logger: CustomLogger
  let paginationService: PaginationService
  let mockPrismaModel: any

  beforeEach(async () => {
    const mockService = createBaseMockService()
    const module = await createTestModule({
      controller: ContentStatusController,
      serviceClass: ContentStatusesService,
      mockService,
      prismaModelName: 'content_statuses',
    })

    controller = module.get<ContentStatusController>(ContentStatusController)
    contentStatusesService = module.get(ContentStatusesService)
    prismaService = module.get<PrismaService>(PrismaService)
    logger = module.get<CustomLogger>(CustomLogger)
    paginationService = module.get<PaginationService>(PaginationService)
    mockPrismaModel = prismaService['content_statuses']

    mockControllerProperties(
      controller,
      mockPrismaModel,
      logger,
      contentStatusesService,
      paginationService,
      'contentStatusesService',
    )
  })

  describe('findAllContentStatuses', () => {
    it('should return paginated content statuses', async () => {
      const contentStatuses = [createSampleContentStatus(), createSampleContentStatus()]
      const query = { page: 1, limit: 10 }

      mockPrismaModel.findMany.mockResolvedValue(contentStatuses)
      mockPrismaModel.count.mockResolvedValue(2)

      const result = await controller.findAllContentStatuses(query)

      expect(result).toEqual(createPaginatedResponse(contentStatuses, 2))
    })

    it('should handle errors', async () => {
      mockPrismaModel.findMany.mockRejectedValue(new Error('Database error'))

      await expect(controller.findAllContentStatuses({ page: 1, limit: 10 })).rejects.toThrow(
        InternalServerErrorException,
      )
    })
  })

  describe('findOneContentStatuses', () => {
    it('should return a single content status', async () => {
      const contentStatus = createSampleContentStatus()
      const id = faker.string.uuid()

      mockPrismaModel.findUnique.mockResolvedValue(contentStatus)

      const result = await controller.findOneContentStatuses(id)

      expect(result).toEqual(createSuccessResponse(contentStatus))
    })

    it('should handle errors', async () => {
      const id = faker.string.uuid()
      mockPrismaModel.findUnique.mockResolvedValue(null)

      await expect(controller.findOneContentStatuses(id)).rejects.toThrow(NotFoundException)
    })
  })

  describe('createContentStatuses', () => {
    it('should create a content status', async () => {
      const createData = createSampleContentStatus()
      const createdContentStatus = { id: faker.string.uuid(), ...createData }

      mockPrismaModel.create.mockResolvedValue(createdContentStatus)

      const result = await controller.createContentStatuses(createData)

      expect(result).toEqual(createSuccessResponse(createdContentStatus))
    })

    it('should handle errors', async () => {
      const createData = createSampleContentStatus()
      mockPrismaModel.create.mockRejectedValue(new Error('Creation failed'))

      await expect(controller.createContentStatuses(createData)).rejects.toThrow(
        InternalServerErrorException,
      )
    })
  })

  describe('updateContentStatuses', () => {
    it('should update a content status', async () => {
      const id = faker.string.uuid()
      const updateData = createSampleContentStatus()
      const updatedContentStatus = { id, ...updateData }

      mockPrismaModel.update.mockResolvedValue(updatedContentStatus)

      const result = await controller.updateContentStatuses(id, updateData)

      expect(result).toEqual(createSuccessResponse(updatedContentStatus))
    })

    it('should handle errors', async () => {
      const id = faker.string.uuid()
      const updateData = createSampleContentStatus()
      mockPrismaModel.update.mockRejectedValue(new Error('Update failed'))

      await expect(controller.updateContentStatuses(id, updateData)).rejects.toThrow(
        InternalServerErrorException,
      )
    })
  })

  describe('removeContentStatuses', () => {
    it('should remove a content status', async () => {
      const id = faker.string.uuid()
      const deletedContentStatus = { id }

      mockPrismaModel.findUnique.mockResolvedValue(deletedContentStatus)
      mockPrismaModel.delete.mockResolvedValue(deletedContentStatus)

      const result = await controller.removeContentStatuses(id)

      expect(result).toEqual(createSuccessResponse(deletedContentStatus))
    })

    it('should handle errors', async () => {
      const id = faker.string.uuid()
      mockPrismaModel.findUnique.mockResolvedValue(null)

      await expect(controller.removeContentStatuses(id)).rejects.toThrow(NotFoundException)
    })
  })
})

================
File: src/content/__tests__/content-tags.test.ts
================
import { describe, it, expect, beforeEach } from 'vitest'
import { PrismaService } from '@core/services/prisma.service'
import { PaginationService } from '@core/services/pagination.service'
import { CustomLogger } from '@core/logger/custom.logger'
import { faker } from '@faker-js/faker'
import type { Prisma } from '@astronera/db'
import { NotFoundException, InternalServerErrorException } from '@nestjs/common'
import { ContentTagsService } from '../services/content-tags.service'
import { ContentTagController } from '../controllers/content-tags.controller'
import type { MockType } from './utils/test.utils'
import {
  createTestModule,
  createBaseMockService,
  createSuccessResponse,
  createErrorResponse,
  createPaginatedResponse,
  mockControllerProperties,
} from './utils/test.utils'

const createSampleContentTag = (): Prisma.content_tagsCreateInput => ({
  contents: { connect: { id: faker.string.uuid() } },
  tags: { connect: { id: faker.number.int() } },
})

describe('ContentTagController', () => {
  let controller: ContentTagController
  let contentTagsService: MockType<ContentTagsService>
  let prismaService: PrismaService
  let logger: CustomLogger
  let paginationService: PaginationService
  let mockPrismaModel: any

  beforeEach(async () => {
    const mockService = createBaseMockService()
    const module = await createTestModule({
      controller: ContentTagController,
      serviceClass: ContentTagsService,
      mockService,
      prismaModelName: 'content_tags',
    })

    controller = module.get<ContentTagController>(ContentTagController)
    contentTagsService = module.get(ContentTagsService)
    prismaService = module.get<PrismaService>(PrismaService)
    logger = module.get<CustomLogger>(CustomLogger)
    paginationService = module.get<PaginationService>(PaginationService)
    mockPrismaModel = prismaService['content_tags']

    mockControllerProperties(
      controller,
      mockPrismaModel,
      logger,
      contentTagsService,
      paginationService,
      'contentTagsService',
    )
  })

  describe('findAllContentTags', () => {
    it('should return paginated content tags', async () => {
      const contentTags = [createSampleContentTag(), createSampleContentTag()]
      const query = { page: 1, limit: 10 }

      mockPrismaModel.findMany.mockResolvedValue(contentTags)
      mockPrismaModel.count.mockResolvedValue(2)

      const result = await controller.findAllContentTags(query)

      expect(result).toEqual(createPaginatedResponse(contentTags, 2))
    })

    it('should handle errors', async () => {
      mockPrismaModel.findMany.mockRejectedValue(new InternalServerErrorException('Database error'))

      await expect(controller.findAllContentTags({ page: 1, limit: 10 })).rejects.toThrow(
        InternalServerErrorException,
      )
    })
  })

  describe('findOneContentTags', () => {
    it('should return a single content tag', async () => {
      const contentTag = createSampleContentTag()
      const id = faker.string.uuid()

      mockPrismaModel.findUnique.mockResolvedValue(contentTag)

      const result = await controller.findOneContentTags(id)

      expect(result).toEqual(createSuccessResponse(contentTag))
    })

    it('should handle errors', async () => {
      const id = faker.string.uuid()
      mockPrismaModel.findUnique.mockResolvedValue(null)

      await expect(controller.findOneContentTags(id)).rejects.toThrow(NotFoundException)
    })
  })

  describe('createContentTags', () => {
    it('should create a content tag', async () => {
      const createData = createSampleContentTag()
      const createdContentTag = { id: faker.string.uuid(), ...createData }

      mockPrismaModel.create.mockResolvedValue(createdContentTag)

      const result = await controller.createContentTags(createData)

      expect(result).toEqual(createSuccessResponse(createdContentTag))
    })

    it('should handle errors', async () => {
      const createData = createSampleContentTag()
      mockPrismaModel.create.mockRejectedValue(new InternalServerErrorException('Creation failed'))

      await expect(controller.createContentTags(createData)).rejects.toThrow(
        InternalServerErrorException,
      )
    })
  })

  describe('updateContentTags', () => {
    it('should update a content tag', async () => {
      const id = faker.string.uuid()
      const updateData = createSampleContentTag()
      const updatedContentTag = { id, ...updateData }

      mockPrismaModel.update.mockResolvedValue(updatedContentTag)

      const result = await controller.updateContentTags(id, updateData)

      expect(result).toEqual(createSuccessResponse(updatedContentTag))
    })

    it('should handle errors', async () => {
      const id = faker.string.uuid()
      const updateData = createSampleContentTag()
      mockPrismaModel.update.mockRejectedValue(new InternalServerErrorException('Update failed'))

      await expect(controller.updateContentTags(id, updateData)).rejects.toThrow(
        InternalServerErrorException,
      )
    })
  })

  describe('removeContentTags', () => {
    it('should remove a content tag', async () => {
      const id = faker.string.uuid()
      const deletedContentTag = { id }

      mockPrismaModel.findUnique.mockResolvedValue(deletedContentTag)
      mockPrismaModel.delete.mockResolvedValue(deletedContentTag)

      const result = await controller.removeContentTags(id)

      expect(result).toEqual(createSuccessResponse(deletedContentTag))
    })

    it('should handle errors', async () => {
      const id = faker.string.uuid()
      mockPrismaModel.findUnique.mockResolvedValue(null)

      await expect(controller.removeContentTags(id)).rejects.toThrow(NotFoundException)
    })
  })
})

================
File: src/content/__tests__/contents.test.ts
================
import { describe, it, expect, beforeEach, vi } from 'vitest'
import { faker } from '@faker-js/faker'
import type { Prisma } from '@astronera/db'
import { ContentType } from '@astronera/db'
import { ContentController } from '../controllers/contents.controller'
import { ContentService } from '../services/contents.service'
import { PrismaService } from '../../core/services/prisma.service'
import { PaginationService } from '../../core/services/pagination.service'
import { CustomLogger } from '../../core/logger/custom.logger'
import { PermissionGuard } from '../../core/guards/permission.guard'
import type { MockType } from './utils/test.utils'
import {
  createTestModule,
  createBaseMockService,
  createSuccessResponse,
  createErrorResponse,
  createPaginatedResponse,
  mockControllerProperties,
} from './utils/test.utils'

const mockPermissionGuard = {
  canActivate: () => true,
  logger: {
    setContext: vi.fn(),
    log: vi.fn(),
    error: vi.fn(),
    warn: vi.fn(),
    debug: vi.fn(),
  },
}

const createSampleContent = (): Prisma.contentsCreateInput => ({
  content_type: faker.helpers.arrayElement([...Object.values(ContentType)]),
  title: faker.helpers.arrayElement([faker.lorem.words(3), null]),
  url: faker.internet.url(),
  rss_url: faker.helpers.arrayElement([faker.internet.url(), null]),
  hot_score: faker.helpers.arrayElement([faker.number.int({ min: 0, max: 100 }), null]),
})

describe('ContentController', () => {
  let controller: ContentController
  let contentService: MockType<ContentService>
  let prismaService: PrismaService
  let logger: CustomLogger
  let paginationService: PaginationService
  let mockPrismaModel: any

  beforeEach(async () => {
    const mockService = createBaseMockService()
    const module = await createTestModule({
      controller: ContentController,
      serviceClass: ContentService,
      mockService,
      prismaModelName: 'contents',
      providers: [
        {
          provide: PermissionGuard,
          useValue: mockPermissionGuard,
        },
      ],
    })

    controller = module.get<ContentController>(ContentController)
    contentService = module.get(ContentService)
    prismaService = module.get<PrismaService>(PrismaService)
    logger = module.get<CustomLogger>(CustomLogger)
    paginationService = module.get<PaginationService>(PaginationService)
    mockPrismaModel = prismaService['contents']

    mockControllerProperties(
      controller,
      mockPrismaModel,
      logger,
      contentService,
      paginationService,
      'contentService',
    )
  })

  describe('findAllContents', () => {
    it('should return paginated contents', async () => {
      const contents = [createSampleContent(), createSampleContent()]
      const query = { page: 1, limit: 10 }

      mockPrismaModel.findMany.mockResolvedValue(contents)
      mockPrismaModel.count.mockResolvedValue(2)

      const result = await controller.findAllContents(query)

      expect(result).toEqual(createPaginatedResponse(contents, 2))
    })

    it('should handle errors', async () => {
      const error = new Error('Database error')
      mockPrismaModel.findMany.mockRejectedValue(error)

      const result = await controller.findAllContents({ page: 1, limit: 10 })
      expect(result).toEqual(createErrorResponse('Database error'))
    })
  })

  describe('findOneContents', () => {
    it('should return a single content', async () => {
      const content = createSampleContent()
      const id = faker.string.uuid()

      mockPrismaModel.findUnique.mockResolvedValue(content)

      const result = await controller.findOneContents(id)

      expect(result).toEqual(createSuccessResponse(content))
    })

    it('should handle errors', async () => {
      const id = faker.string.uuid()
      const error = new Error('Not found')
      mockPrismaModel.findUnique.mockRejectedValue(error)

      const result = await controller.findOneContents(id)
      expect(result).toEqual(createErrorResponse('Not found'))
    })
  })

  describe('createContents', () => {
    it('should create a content', async () => {
      const createData = createSampleContent()
      const createdContent = {
        id: faker.string.uuid(),
        content_type: createData.content_type,
        title: createData.title,
        url: createData.url,
        rss_url: createData.rss_url,
        hot_score: createData.hot_score,
        created_at: new Date(),
        updated_at: new Date(),
      }

      mockPrismaModel.create.mockResolvedValue(createdContent)

      const result = await controller.createContents(createData)

      expect(result).toEqual(createSuccessResponse(createdContent))
    })

    it('should handle errors', async () => {
      const createData = createSampleContent()
      const error = new Error('Creation failed')
      mockPrismaModel.create.mockRejectedValue(error)

      const result = await controller.createContents(createData)
      expect(result).toEqual(createErrorResponse('Creation failed'))
    })
  })

  describe('updateContents', () => {
    it('should update a content', async () => {
      const id = faker.string.uuid()
      const updateData: Prisma.contentsUpdateInput = {
        content_type: faker.helpers.arrayElement([...Object.values(ContentType)]),
        title: faker.lorem.words(3),
        url: faker.internet.url(),
        rss_url: faker.internet.url(),
        hot_score: faker.number.int({ min: 0, max: 100 }),
        updated_at: new Date(),
      }
      const updatedContent = {
        id,
        content_type: updateData.content_type as string,
        title: updateData.title as string,
        url: updateData.url as string,
        rss_url: updateData.rss_url as string,
        hot_score: updateData.hot_score as number,
        created_at: new Date(),
        updated_at: updateData.updated_at as Date,
      }

      mockPrismaModel.update.mockResolvedValue(updatedContent)

      const result = await controller.updateContents(id, updateData)

      expect(result).toEqual(createSuccessResponse(updatedContent))
    })

    it('should handle errors', async () => {
      const id = faker.string.uuid()
      const updateData: Prisma.contentsUpdateInput = {
        content_type: faker.helpers.arrayElement([...Object.values(ContentType)]),
      }
      const error = new Error('Update failed')
      mockPrismaModel.update.mockRejectedValue(error)

      const result = await controller.updateContents(id, updateData)
      expect(result).toEqual(createErrorResponse('Update failed'))
    })
  })

  describe('removeContents', () => {
    it('should remove a content', async () => {
      const id = faker.string.uuid()
      const deletedContent = { id }

      mockPrismaModel.delete.mockResolvedValue(deletedContent)

      const result = await controller.removeContents(id)

      expect(result).toEqual(createSuccessResponse(deletedContent))
    })

    it('should handle errors', async () => {
      const id = faker.string.uuid()
      const error = new Error('Delete failed')
      mockPrismaModel.delete.mockRejectedValue(error)

      const result = await controller.removeContents(id)
      expect(result).toEqual(createErrorResponse('Delete failed'))
    })
  })
})

================
File: src/content/__tests__/embedding-reviews.test.ts
================
import { describe, it, expect, beforeEach } from 'vitest'
import { PrismaService } from '@core/services/prisma.service'
import { PaginationService } from '@core/services/pagination.service'
import { CustomLogger } from '@core/logger/custom.logger'
import { faker } from '@faker-js/faker'
import type { Prisma } from '@astronera/db'
import { EmbeddingReviewsService } from '../services/embedding-reviews.service'
import { EmbeddingReviewController } from '../controllers/embedding-reviews.controller'
import {
  createTestModule,
  createBaseMockService,
  createSuccessResponse,
  createErrorResponse,
  createPaginatedResponse,
  mockControllerProperties,
} from './utils/test.utils'

const createSampleEmbeddingReview = (): Prisma.embedding_reviewsCreateInput => ({
  agent_review: faker.helpers.arrayElement([true, false, null]),
  human_review: faker.helpers.arrayElement([true, false, null]),
  notes: faker.helpers.arrayElement([faker.lorem.words(3), null]),
})

describe('EmbeddingReview Module', () => {
  let controller: EmbeddingReviewController
  let embeddingReviewsService: ReturnType<typeof createBaseMockService>
  let prismaService: PrismaService
  let logger: CustomLogger
  let paginationService: PaginationService
  let mockPrismaModel: any

  beforeEach(async () => {
    const mockService = createBaseMockService()
    const module = await createTestModule({
      controller: EmbeddingReviewController,
      serviceClass: EmbeddingReviewsService,
      mockService,
      prismaModelName: 'embedding_reviews',
    })

    controller = module.get<EmbeddingReviewController>(EmbeddingReviewController)
    embeddingReviewsService = module.get(EmbeddingReviewsService)
    prismaService = module.get<PrismaService>(PrismaService)
    logger = module.get<CustomLogger>(CustomLogger)
    paginationService = module.get<PaginationService>(PaginationService)
    mockPrismaModel = prismaService['embedding_reviews']

    mockControllerProperties(
      controller,
      mockPrismaModel,
      logger,
      embeddingReviewsService,
      paginationService,
      'embeddingReviewsService',
    )
  })

  describe('findAllEmbeddingReviews', () => {
    it('should return paginated embedding reviews', async () => {
      const embeddingReviews = [
        { id: '1', ...createSampleEmbeddingReview() },
        { id: '2', ...createSampleEmbeddingReview() },
      ]
      const query = { page: 1, limit: 10 }

      mockPrismaModel.findMany.mockResolvedValue(embeddingReviews)
      mockPrismaModel.count.mockResolvedValue(2)

      const result = await controller.findAllEmbeddingReviews(query)

      expect(result).toEqual(createPaginatedResponse(embeddingReviews, 2))
      expect(mockPrismaModel.findMany).toHaveBeenCalled()
      expect(mockPrismaModel.count).toHaveBeenCalled()
    })

    it('should handle errors when fetching embedding reviews', async () => {
      const error = new Error('Database error')
      mockPrismaModel.findMany.mockRejectedValue(error)

      const result = await controller.findAllEmbeddingReviews({
        page: 1,
        limit: 10,
      })
      expect(result).toEqual(createErrorResponse('Database error'))
    })
  })

  describe('findOneEmbeddingReviews', () => {
    it('should return a single embedding review', async () => {
      const embeddingReview = { id: '1', ...createSampleEmbeddingReview() }
      mockPrismaModel.findUnique.mockResolvedValue(embeddingReview)

      const result = await controller.findOneEmbeddingReviews('1')

      expect(result).toEqual(createSuccessResponse(embeddingReview))
      expect(mockPrismaModel.findUnique).toHaveBeenCalledWith({
        where: { id: '1' },
      })
    })

    it('should handle not found error', async () => {
      mockPrismaModel.findUnique.mockResolvedValue(null)

      const result = await controller.findOneEmbeddingReviews('1')
      expect(result).toEqual(createErrorResponse('embedding_reviews not found'))
    })
  })

  describe('createEmbeddingReviews', () => {
    it('should create an embedding review', async () => {
      const createData = createSampleEmbeddingReview()
      const createdReview = {
        id: '1',
        ...createData,
        created_at: new Date(),
        updated_at: new Date(),
      }

      mockPrismaModel.create.mockResolvedValue(createdReview)

      const result = await controller.createEmbeddingReviews(createData)

      expect(result).toEqual(createSuccessResponse(createdReview))
      expect(mockPrismaModel.create).toHaveBeenCalledWith({
        data: createData,
      })
    })

    it('should handle creation errors', async () => {
      const createData = createSampleEmbeddingReview()
      const error = new Error('Creation failed')
      mockPrismaModel.create.mockRejectedValue(error)

      const result = await controller.createEmbeddingReviews(createData)
      expect(result).toEqual(createErrorResponse('Creation failed'))
    })
  })

  describe('updateEmbeddingReviews', () => {
    it('should update an embedding review', async () => {
      const id = '1'
      const updateData: Prisma.embedding_reviewsUpdateInput = {
        agent_review: true,
        notes: 'Updated notes',
      }
      const updatedReview = {
        id,
        ...updateData,
        created_at: new Date(),
        updated_at: new Date(),
      }

      mockPrismaModel.update.mockResolvedValue(updatedReview)

      const result = await controller.updateEmbeddingReviews(id, updateData)

      expect(result).toEqual(createSuccessResponse(updatedReview))
      expect(mockPrismaModel.update).toHaveBeenCalledWith({
        where: { id },
        data: updateData,
      })
    })

    it('should handle update errors', async () => {
      const id = '1'
      const updateData: Prisma.embedding_reviewsUpdateInput = {
        agent_review: true,
      }
      const error = new Error('Update failed')
      mockPrismaModel.update.mockRejectedValue(error)

      const result = await controller.updateEmbeddingReviews(id, updateData)
      expect(result).toEqual(createErrorResponse('Update failed'))
    })
  })

  describe('removeEmbeddingReviews', () => {
    it('should remove an embedding review', async () => {
      const id = '1'
      const deletedReview = { id, ...createSampleEmbeddingReview() }

      mockPrismaModel.findUnique.mockResolvedValue(deletedReview)
      mockPrismaModel.delete.mockResolvedValue(deletedReview)

      const result = await controller.removeEmbeddingReviews(id)

      expect(result).toEqual(createSuccessResponse(deletedReview))
      expect(mockPrismaModel.delete).toHaveBeenCalledWith({
        where: { id },
      })
    })

    it('should handle removal errors', async () => {
      const id = '1'
      mockPrismaModel.findUnique.mockResolvedValue(null)

      const result = await controller.removeEmbeddingReviews(id)
      expect(result).toEqual(createErrorResponse('embedding_reviews not found'))
    })
  })
})

================
File: src/content/__tests__/feed-categories.test.ts
================
import { describe, it, expect, beforeEach } from 'vitest'
import { PrismaService } from '@core/services/prisma.service'
import { PaginationService } from '@core/services/pagination.service'
import { CustomLogger } from '@core/logger/custom.logger'
import { faker } from '@faker-js/faker'
import type { Prisma } from '@astronera/db'
import { FeedCategoriesService } from '../services/feed-categories.service'
import { FeedCategoryController } from '../controllers/feed-categories.controller'
import {
  createTestModule,
  createBaseMockService,
  createSuccessResponse,
  createErrorResponse,
  createPaginatedResponse,
  mockControllerProperties,
} from './utils/test.utils'

const createSampleFeedCategory = (): Prisma.feed_categoriesCreateInput => ({
  feeds: { connect: { id: faker.string.uuid() } },
  categories: { connect: { id: faker.number.int() } },
})

describe('FeedCategory Module', () => {
  let controller: FeedCategoryController
  let feedCategoriesService: ReturnType<typeof createBaseMockService>
  let prismaService: PrismaService
  let logger: CustomLogger
  let paginationService: PaginationService
  let mockPrismaModel: any

  beforeEach(async () => {
    const mockService = createBaseMockService()
    const module = await createTestModule({
      controller: FeedCategoryController,
      serviceClass: FeedCategoriesService,
      mockService,
      prismaModelName: 'feed_categories',
    })

    controller = module.get<FeedCategoryController>(FeedCategoryController)
    feedCategoriesService = module.get(FeedCategoriesService)
    prismaService = module.get<PrismaService>(PrismaService)
    logger = module.get<CustomLogger>(CustomLogger)
    paginationService = module.get<PaginationService>(PaginationService)
    mockPrismaModel = prismaService['feed_categories']

    mockControllerProperties(
      controller,
      mockPrismaModel,
      logger,
      feedCategoriesService,
      paginationService,
      'feedCategoriesService',
    )
  })

  describe('findAllFeedCategories', () => {
    it('should return paginated feed categories', async () => {
      const feedCategories = [
        { id: '1', ...createSampleFeedCategory() },
        { id: '2', ...createSampleFeedCategory() },
      ]
      const query = { page: 1, limit: 10 }

      mockPrismaModel.findMany.mockResolvedValue(feedCategories)
      mockPrismaModel.count.mockResolvedValue(2)

      const result = await controller.findAllFeedCategories(query)

      expect(result).toEqual(createPaginatedResponse(feedCategories, 2))
      expect(mockPrismaModel.findMany).toHaveBeenCalled()
      expect(mockPrismaModel.count).toHaveBeenCalled()
    })

    it('should handle errors when fetching feed categories', async () => {
      const error = new Error('Database error')
      mockPrismaModel.findMany.mockRejectedValue(error)

      const result = await controller.findAllFeedCategories({
        page: 1,
        limit: 10,
      })
      expect(result).toEqual(createErrorResponse('Database error'))
    })
  })

  describe('findOneFeedCategories', () => {
    it('should return a single feed category', async () => {
      const feedCategory = { id: '1', ...createSampleFeedCategory() }
      mockPrismaModel.findUnique.mockResolvedValue(feedCategory)

      const result = await controller.findOneFeedCategories('1')

      expect(result).toEqual(createSuccessResponse(feedCategory))
      expect(mockPrismaModel.findUnique).toHaveBeenCalledWith({
        where: { id: '1' },
      })
    })

    it('should handle not found error', async () => {
      mockPrismaModel.findUnique.mockResolvedValue(null)

      const result = await controller.findOneFeedCategories('1')
      expect(result).toEqual(createErrorResponse('feed_categories not found'))
    })
  })

  describe('createFeedCategories', () => {
    it('should create a feed category', async () => {
      const createData = createSampleFeedCategory()
      const createdCategory = {
        id: '1',
        feed_id: createData.feeds.connect!.id,
        category_id: createData.categories.connect!.id,
        created_at: new Date(),
        updated_at: new Date(),
      }

      mockPrismaModel.create.mockResolvedValue(createdCategory)

      const result = await controller.createFeedCategories(createData)

      expect(result).toEqual(createSuccessResponse(createdCategory))
      expect(mockPrismaModel.create).toHaveBeenCalledWith({
        data: createData,
      })
    })

    it('should handle creation errors', async () => {
      const createData = createSampleFeedCategory()
      const error = new Error('Creation failed')
      mockPrismaModel.create.mockRejectedValue(error)

      const result = await controller.createFeedCategories(createData)
      expect(result).toEqual(createErrorResponse('Creation failed'))
    })
  })

  describe('updateFeedCategories', () => {
    it('should update a feed category', async () => {
      const id = '1'
      const updateData: Prisma.feed_categoriesUpdateInput = {
        feeds: { connect: { id: faker.string.uuid() } },
      }
      const updatedCategory = {
        id,
        feed_id: updateData.feeds?.connect?.id,
        category_id: faker.string.uuid(),
        created_at: new Date(),
        updated_at: new Date(),
      }

      mockPrismaModel.update.mockResolvedValue(updatedCategory)

      const result = await controller.updateFeedCategories(id, updateData)

      expect(result).toEqual(createSuccessResponse(updatedCategory))
      expect(mockPrismaModel.update).toHaveBeenCalledWith({
        where: { id },
        data: updateData,
      })
    })

    it('should handle update errors', async () => {
      const id = '1'
      const updateData: Prisma.feed_categoriesUpdateInput = {
        feeds: { connect: { id: faker.string.uuid() } },
      }
      const error = new Error('Update failed')
      mockPrismaModel.update.mockRejectedValue(error)

      const result = await controller.updateFeedCategories(id, updateData)
      expect(result).toEqual(createErrorResponse('Update failed'))
    })
  })

  describe('removeFeedCategories', () => {
    it('should remove a feed category', async () => {
      const id = '1'
      const deletedCategory = {
        id,
        feed_id: faker.string.uuid(),
        category_id: faker.string.uuid(),
        created_at: new Date(),
        updated_at: new Date(),
      }

      mockPrismaModel.findUnique.mockResolvedValue(deletedCategory)
      mockPrismaModel.delete.mockResolvedValue(deletedCategory)

      const result = await controller.removeFeedCategories(id)

      expect(result).toEqual(createSuccessResponse(deletedCategory))
      expect(mockPrismaModel.delete).toHaveBeenCalledWith({
        where: { id },
      })
    })

    it('should handle removal errors', async () => {
      const id = '1'
      mockPrismaModel.findUnique.mockResolvedValue(null)

      const result = await controller.removeFeedCategories(id)
      expect(result).toEqual(createErrorResponse('feed_categories not found'))
    })
  })
})

================
File: src/content/__tests__/feed-sources.test.ts
================
import { describe, it, expect, beforeEach } from 'vitest'
import { PrismaService } from '@core/services/prisma.service'
import { PaginationService } from '@core/services/pagination.service'
import { CustomLogger } from '@core/logger/custom.logger'
import { faker } from '@faker-js/faker'
import type { Prisma } from '@astronera/db'
import { NotFoundException, InternalServerErrorException } from '@nestjs/common'
import { FeedSourceService } from '../services/feed-sources.service'
import { FeedSourceController } from '../controllers/feed-sources.controller'
import type { MockType } from './utils/test.utils'
import {
  createTestModule,
  createBaseMockService,
  createSuccessResponse,
  createErrorResponse,
  createPaginatedResponse,
  mockControllerProperties,
} from './utils/test.utils'

const createSampleFeedSource = (): Prisma.feed_sourcesCreateInput => ({
  feeds: { connect: { id: faker.string.uuid() } },
  content_sources: { connect: { id: faker.number.int() } },
})

describe('FeedSourceController', () => {
  let controller: FeedSourceController
  let feedSourceService: MockType<FeedSourceService>
  let prismaService: PrismaService
  let logger: CustomLogger
  let paginationService: PaginationService
  let mockPrismaModel: any

  beforeEach(async () => {
    const mockService = createBaseMockService()
    const module = await createTestModule({
      controller: FeedSourceController,
      serviceClass: FeedSourceService,
      mockService,
      prismaModelName: 'feed_sources',
    })

    controller = module.get<FeedSourceController>(FeedSourceController)
    feedSourceService = module.get(FeedSourceService)
    prismaService = module.get<PrismaService>(PrismaService)
    logger = module.get<CustomLogger>(CustomLogger)
    paginationService = module.get<PaginationService>(PaginationService)
    mockPrismaModel = prismaService['feed_sources']

    mockControllerProperties(
      controller,
      mockPrismaModel,
      logger,
      feedSourceService,
      paginationService,
      'feedSourceService',
    )
  })

  describe('findAllFeedSources', () => {
    it('should return paginated feed sources', async () => {
      const feedSources = [createSampleFeedSource(), createSampleFeedSource()]
      const query = { page: 1, limit: 10 }

      mockPrismaModel.findMany.mockResolvedValue(feedSources)
      mockPrismaModel.count.mockResolvedValue(2)

      const result = await controller.findAllFeedSources(query)

      expect(result).toEqual(createPaginatedResponse(feedSources, 2))
    })

    it('should handle errors', async () => {
      mockPrismaModel.findMany.mockRejectedValue(new Error('Database error'))

      await expect(controller.findAllFeedSources({ page: 1, limit: 10 })).rejects.toThrow(
        InternalServerErrorException,
      )
    })
  })

  describe('findOneFeedSources', () => {
    it('should return a single feed source', async () => {
      const feedSource = createSampleFeedSource()
      const id = faker.string.uuid()

      mockPrismaModel.findUnique.mockResolvedValue(feedSource)

      const result = await controller.findOneFeedSources(id)

      expect(result).toEqual(createSuccessResponse(feedSource))
    })

    it('should handle errors', async () => {
      const id = faker.string.uuid()
      mockPrismaModel.findUnique.mockResolvedValue(null)

      await expect(controller.findOneFeedSources(id)).rejects.toThrow(NotFoundException)
    })
  })

  describe('createFeedSources', () => {
    it('should create a feed source', async () => {
      const createData = createSampleFeedSource()
      const createdFeedSource = { id: faker.string.uuid(), ...createData }

      mockPrismaModel.create.mockResolvedValue(createdFeedSource)

      const result = await controller.createFeedSources(createData)

      expect(result).toEqual(createSuccessResponse(createdFeedSource))
    })

    it('should handle errors', async () => {
      const createData = createSampleFeedSource()
      mockPrismaModel.create.mockRejectedValue(new Error('Creation failed'))

      await expect(controller.createFeedSources(createData)).rejects.toThrow(
        InternalServerErrorException,
      )
    })
  })

  describe('updateFeedSources', () => {
    it('should update a feed source', async () => {
      const id = faker.string.uuid()
      const updateData = createSampleFeedSource()
      const updatedFeedSource = { id, ...updateData }

      mockPrismaModel.update.mockResolvedValue(updatedFeedSource)

      const result = await controller.updateFeedSources(id, updateData)

      expect(result).toEqual(createSuccessResponse(updatedFeedSource))
    })

    it('should handle errors', async () => {
      const id = faker.string.uuid()
      const updateData = createSampleFeedSource()
      mockPrismaModel.update.mockRejectedValue(new Error('Update failed'))

      await expect(controller.updateFeedSources(id, updateData)).rejects.toThrow(
        InternalServerErrorException,
      )
    })
  })

  describe('removeFeedSources', () => {
    it('should remove a feed source', async () => {
      const id = faker.string.uuid()
      const deletedFeedSource = { id }

      mockPrismaModel.findUnique.mockResolvedValue(deletedFeedSource)
      mockPrismaModel.delete.mockResolvedValue(deletedFeedSource)

      const result = await controller.removeFeedSources(id)

      expect(result).toEqual(createSuccessResponse(deletedFeedSource))
    })

    it('should handle errors', async () => {
      const id = faker.string.uuid()
      mockPrismaModel.findUnique.mockResolvedValue(null)

      await expect(controller.removeFeedSources(id)).rejects.toThrow(NotFoundException)
    })
  })
})

================
File: src/content/__tests__/feeds.test.ts
================
import { describe, it, expect, beforeEach } from 'vitest'
import { PrismaService } from '@core/services/prisma.service'
import { PaginationService } from '@core/services/pagination.service'
import { CustomLogger } from '@core/logger/custom.logger'
import { faker } from '@faker-js/faker'
import type { Prisma } from '@astronera/db'
import { FeedsService } from '../services/feeds.service'
import { FeedController } from '../controllers/feeds.controller'
import {
  createTestModule,
  createBaseMockService,
  createSuccessResponse,
  createErrorResponse,
  createPaginatedResponse,
  mockControllerProperties,
} from './utils/test.utils'

const createSampleFeed = (): Prisma.feedsCreateInput => ({
  name: faker.helpers.arrayElement([faker.lorem.words(3), null]),
  user_profiles: { connect: { id: faker.string.uuid() } },
})

describe('Feed Module', () => {
  let controller: FeedController
  let feedsService: ReturnType<typeof createBaseMockService>
  let prismaService: PrismaService
  let logger: CustomLogger
  let paginationService: PaginationService
  let mockPrismaModel: any

  beforeEach(async () => {
    const mockService = createBaseMockService()
    const module = await createTestModule({
      controller: FeedController,
      serviceClass: FeedsService,
      mockService,
      prismaModelName: 'feeds',
    })

    controller = module.get<FeedController>(FeedController)
    feedsService = module.get(FeedsService)
    prismaService = module.get<PrismaService>(PrismaService)
    logger = module.get<CustomLogger>(CustomLogger)
    paginationService = module.get<PaginationService>(PaginationService)
    mockPrismaModel = prismaService['feeds']

    mockControllerProperties(
      controller,
      mockPrismaModel,
      logger,
      feedsService,
      paginationService,
      'feedsService',
    )
  })

  describe('findAllFeeds', () => {
    it('should return paginated feeds', async () => {
      const feeds = [
        { id: '1', ...createSampleFeed() },
        { id: '2', ...createSampleFeed() },
      ]
      const query = { page: 1, limit: 10 }

      mockPrismaModel.findMany.mockResolvedValue(feeds)
      mockPrismaModel.count.mockResolvedValue(2)

      const result = await controller.findAllFeeds(query)

      expect(result).toEqual(createPaginatedResponse(feeds, 2))
      expect(mockPrismaModel.findMany).toHaveBeenCalled()
      expect(mockPrismaModel.count).toHaveBeenCalled()
    })

    it('should handle errors when fetching feeds', async () => {
      const error = new Error('Database error')
      mockPrismaModel.findMany.mockRejectedValue(error)

      const result = await controller.findAllFeeds({ page: 1, limit: 10 })
      expect(result).toEqual(createErrorResponse('Database error'))
    })

    it('should handle filters and sorting', async () => {
      const feeds = [
        { id: '1', ...createSampleFeed() },
        { id: '2', ...createSampleFeed() },
      ]
      const query = {
        page: 1,
        limit: 10,
        sortBy: 'created_at',
        sortOrder: 'desc' as const,
        name: 'test',
      }

      mockPrismaModel.findMany.mockResolvedValue(feeds)
      mockPrismaModel.count.mockResolvedValue(2)

      const result = await controller.findAllFeeds(query)

      expect(result).toEqual(createPaginatedResponse(feeds, 2))
      expect(mockPrismaModel.findMany).toHaveBeenCalled()
      expect(mockPrismaModel.count).toHaveBeenCalled()
    })
  })

  describe('findOneFeeds', () => {
    it('should return a single feed', async () => {
      const feed = { id: '1', ...createSampleFeed() }
      mockPrismaModel.findUnique.mockResolvedValue(feed)

      const result = await controller.findOneFeeds('1')

      expect(result).toEqual(createSuccessResponse(feed))
      expect(mockPrismaModel.findUnique).toHaveBeenCalledWith({
        where: { id: '1' },
      })
    })

    it('should handle not found error', async () => {
      mockPrismaModel.findUnique.mockResolvedValue(null)

      const result = await controller.findOneFeeds('1')
      expect(result).toEqual(createErrorResponse('feeds not found'))
    })
  })

  describe('createFeeds', () => {
    it('should create a feed', async () => {
      const createData = createSampleFeed()
      const createdFeed = {
        id: '1',
        name: createData.name,
        user_id: createData.user_profiles.connect!.id,
        created_at: new Date(),
        updated_at: new Date(),
      }

      mockPrismaModel.create.mockResolvedValue(createdFeed)

      const result = await controller.createFeeds(createData)

      expect(result).toEqual(createSuccessResponse(createdFeed))
      expect(mockPrismaModel.create).toHaveBeenCalledWith({
        data: createData,
      })
    })

    it('should handle creation errors', async () => {
      const createData = createSampleFeed()
      const error = new Error('Creation failed')
      mockPrismaModel.create.mockRejectedValue(error)

      const result = await controller.createFeeds(createData)
      expect(result).toEqual(createErrorResponse('Creation failed'))
    })
  })

  describe('updateFeeds', () => {
    it('should update a feed', async () => {
      const id = '1'
      const updateData: Prisma.feedsUpdateInput = {
        name: faker.lorem.words(3),
      }
      const updatedFeed = {
        id,
        ...updateData,
        user_id: faker.string.uuid(),
        created_at: new Date(),
        updated_at: new Date(),
      }

      mockPrismaModel.update.mockResolvedValue(updatedFeed)

      const result = await controller.updateFeeds(id, updateData)

      expect(result).toEqual(createSuccessResponse(updatedFeed))
      expect(mockPrismaModel.update).toHaveBeenCalledWith({
        where: { id },
        data: updateData,
      })
    })

    it('should handle update errors', async () => {
      const id = '1'
      const updateData: Prisma.feedsUpdateInput = {
        name: faker.lorem.words(3),
      }
      const error = new Error('Update failed')
      mockPrismaModel.update.mockRejectedValue(error)

      const result = await controller.updateFeeds(id, updateData)
      expect(result).toEqual(createErrorResponse('Update failed'))
    })
  })

  describe('removeFeeds', () => {
    it('should remove a feed', async () => {
      const id = '1'
      const deletedFeed = {
        id,
        name: faker.lorem.words(3),
        user_id: faker.string.uuid(),
        created_at: new Date(),
        updated_at: new Date(),
      }

      mockPrismaModel.findUnique.mockResolvedValue(deletedFeed)
      mockPrismaModel.delete.mockResolvedValue(deletedFeed)

      const result = await controller.removeFeeds(id)

      expect(result).toEqual(createSuccessResponse(deletedFeed))
      expect(mockPrismaModel.delete).toHaveBeenCalledWith({
        where: { id },
      })
    })

    it('should handle removal errors', async () => {
      const id = '1'
      mockPrismaModel.findUnique.mockResolvedValue(null)

      const result = await controller.removeFeeds(id)
      expect(result).toEqual(createErrorResponse('feeds not found'))
    })
  })
})

================
File: src/content/__tests__/news-summaries.test.ts
================
import { describe, it, expect, beforeEach } from 'vitest'
import { PrismaService } from '@core/services/prisma.service'
import { PaginationService } from '@core/services/pagination.service'
import { CustomLogger } from '@core/logger/custom.logger'
import { faker } from '@faker-js/faker'
import type { Prisma } from '@astronera/db'
import { NewsSummariesService } from '../services/news-summaries.service'
import { NewsSummaryController } from '../controllers/news-summaries.controller'
import {
  createTestModule,
  createBaseMockService,
  createSuccessResponse,
  createErrorResponse,
  createPaginatedResponse,
  mockControllerProperties,
} from './utils/test.utils'

const createSampleNewsSummary = (): Prisma.news_summariesCreateInput => ({
  news: { connect: { id: faker.string.uuid() } },
  summary: faker.helpers.arrayElement([faker.lorem.words(3), null]),
  complexity_level: faker.helpers.arrayElement([faker.lorem.words(3), null]),
  version: faker.number.int(),
  is_current: faker.helpers.arrayElement([true, false, null]),
})

describe('NewsSummary Module', () => {
  let controller: NewsSummaryController
  let newsSummariesService: ReturnType<typeof createBaseMockService>
  let prismaService: PrismaService
  let logger: CustomLogger
  let paginationService: PaginationService
  let mockPrismaModel: any

  beforeEach(async () => {
    const mockService = createBaseMockService()
    const module = await createTestModule({
      controller: NewsSummaryController,
      serviceClass: NewsSummariesService,
      mockService,
      prismaModelName: 'news_summaries',
    })

    controller = module.get<NewsSummaryController>(NewsSummaryController)
    newsSummariesService = module.get(NewsSummariesService)
    prismaService = module.get<PrismaService>(PrismaService)
    logger = module.get<CustomLogger>(CustomLogger)
    paginationService = module.get<PaginationService>(PaginationService)
    mockPrismaModel = prismaService['news_summaries']

    mockControllerProperties(
      controller,
      mockPrismaModel,
      logger,
      newsSummariesService,
      paginationService,
      'newsSummariesService',
    )
  })

  describe('findAllNewsSummaries', () => {
    it('should return paginated news summaries', async () => {
      const newsSummaries = [
        { id: '1', ...createSampleNewsSummary() },
        { id: '2', ...createSampleNewsSummary() },
      ]
      const query = { page: 1, limit: 10 }

      mockPrismaModel.findMany.mockResolvedValue(newsSummaries)
      mockPrismaModel.count.mockResolvedValue(2)

      const result = await controller.findAllNewsSummaries(query)

      expect(result).toEqual(createPaginatedResponse(newsSummaries, 2))
      expect(mockPrismaModel.findMany).toHaveBeenCalled()
      expect(mockPrismaModel.count).toHaveBeenCalled()
    })

    it('should handle errors when fetching news summaries', async () => {
      const error = new Error('Database error')
      mockPrismaModel.findMany.mockRejectedValue(error)

      const result = await controller.findAllNewsSummaries({
        page: 1,
        limit: 10,
      })
      expect(result).toEqual(createErrorResponse('Database error'))
    })

    it('should handle filters and sorting', async () => {
      const newsSummaries = [
        { id: '1', ...createSampleNewsSummary() },
        { id: '2', ...createSampleNewsSummary() },
      ]
      const query = {
        page: 1,
        limit: 10,
        sortBy: 'created_at',
        sortOrder: 'desc' as const,
        complexity_level: 'high',
      }

      mockPrismaModel.findMany.mockResolvedValue(newsSummaries)
      mockPrismaModel.count.mockResolvedValue(2)

      const result = await controller.findAllNewsSummaries(query)

      expect(result).toEqual(createPaginatedResponse(newsSummaries, 2))
      expect(mockPrismaModel.findMany).toHaveBeenCalled()
      expect(mockPrismaModel.count).toHaveBeenCalled()
    })
  })

  describe('findOneNewsSummaries', () => {
    it('should return a single news summary', async () => {
      const newsSummary = { id: '1', ...createSampleNewsSummary() }
      mockPrismaModel.findUnique.mockResolvedValue(newsSummary)

      const result = await controller.findOneNewsSummaries('1')

      expect(result).toEqual(createSuccessResponse(newsSummary))
      expect(mockPrismaModel.findUnique).toHaveBeenCalledWith({
        where: { id: '1' },
      })
    })

    it('should handle not found error', async () => {
      mockPrismaModel.findUnique.mockResolvedValue(null)

      const result = await controller.findOneNewsSummaries('1')
      expect(result).toEqual(createErrorResponse('news_summaries not found'))
    })
  })

  describe('createNewsSummaries', () => {
    it('should create a news summary', async () => {
      const createData = createSampleNewsSummary()
      const createdSummary = {
        id: '1',
        news_id: createData.news.connect!.id,
        summary: createData.summary,
        // embedding: createData.embedding,
        complexity_level: createData.complexity_level,
        version: createData.version,
        is_current: createData.is_current,
        created_at: new Date(),
        updated_at: new Date(),
      }

      mockPrismaModel.create.mockResolvedValue(createdSummary)

      const result = await controller.createNewsSummaries(createData)

      expect(result).toEqual(createSuccessResponse(createdSummary))
      expect(mockPrismaModel.create).toHaveBeenCalledWith({
        data: createData,
      })
    })

    it('should handle creation errors', async () => {
      const createData = createSampleNewsSummary()
      const error = new Error('Creation failed')
      mockPrismaModel.create.mockRejectedValue(error)

      const result = await controller.createNewsSummaries(createData)
      expect(result).toEqual(createErrorResponse('Creation failed'))
    })
  })

  describe('updateNewsSummaries', () => {
    it('should update a news summary', async () => {
      const id = '1'
      const updateData: Prisma.news_summariesUpdateInput = {
        summary: faker.lorem.words(3),
        complexity_level: 'high',
        version: faker.number.int(),
        is_current: true,
      }
      const updatedSummary = {
        id,
        ...updateData,
        news_id: faker.string.uuid(),
        created_at: new Date(),
        updated_at: new Date(),
      }

      mockPrismaModel.update.mockResolvedValue(updatedSummary)

      const result = await controller.updateNewsSummaries(id, updateData)

      expect(result).toEqual(createSuccessResponse(updatedSummary))
      expect(mockPrismaModel.update).toHaveBeenCalledWith({
        where: { id },
        data: updateData,
      })
    })

    it('should handle update errors', async () => {
      const id = '1'
      const updateData: Prisma.news_summariesUpdateInput = {
        summary: faker.lorem.words(3),
      }
      const error = new Error('Update failed')
      mockPrismaModel.update.mockRejectedValue(error)

      const result = await controller.updateNewsSummaries(id, updateData)
      expect(result).toEqual(createErrorResponse('Update failed'))
    })
  })

  describe('removeNewsSummaries', () => {
    it('should remove a news summary', async () => {
      const id = '1'
      const deletedSummary = {
        id,
        news_id: faker.string.uuid(),
        summary: faker.lorem.words(3),
        complexity_level: 'high',
        version: faker.number.int(),
        is_current: true,
        created_at: new Date(),
        updated_at: new Date(),
      }

      mockPrismaModel.findUnique.mockResolvedValue(deletedSummary)
      mockPrismaModel.delete.mockResolvedValue(deletedSummary)

      const result = await controller.removeNewsSummaries(id)

      expect(result).toEqual(createSuccessResponse(deletedSummary))
      expect(mockPrismaModel.delete).toHaveBeenCalledWith({
        where: { id },
      })
    })

    it('should handle removal errors', async () => {
      const id = '1'
      mockPrismaModel.findUnique.mockResolvedValue(null)

      const result = await controller.removeNewsSummaries(id)
      expect(result).toEqual(createErrorResponse('news_summaries not found'))
    })
  })
})

================
File: src/content/__tests__/news-tags.test.ts
================
import { describe, it, expect, beforeEach } from 'vitest'
import { PrismaService } from '@core/services/prisma.service'
import { PaginationService } from '@core/services/pagination.service'
import { CustomLogger } from '@core/logger/custom.logger'
import { faker } from '@faker-js/faker'
import type { Prisma } from '@astronera/db'
import { NewsTagsService } from '../services/news-tags.service'
import { NewsTagController } from '../controllers/news-tags.controller'
import {
  createTestModule,
  createBaseMockService,
  createSuccessResponse,
  createErrorResponse,
  createPaginatedResponse,
  mockControllerProperties,
} from './utils/test.utils'

const createSampleNewsTag = (): Prisma.news_tagsCreateInput => ({
  id: faker.number.int(),
  tags: { connect: { id: faker.number.int() } },
  news_id: faker.string.uuid(),
})

describe('NewsTag Module', () => {
  let controller: NewsTagController
  let newsTagsService: ReturnType<typeof createBaseMockService>
  let prismaService: PrismaService
  let logger: CustomLogger
  let paginationService: PaginationService
  let mockPrismaModel: any

  beforeEach(async () => {
    const mockService = createBaseMockService()
    const module = await createTestModule({
      controller: NewsTagController,
      serviceClass: NewsTagsService,
      mockService,
      prismaModelName: 'news_tags',
    })

    controller = module.get<NewsTagController>(NewsTagController)
    newsTagsService = module.get(NewsTagsService)
    prismaService = module.get<PrismaService>(PrismaService)
    logger = module.get<CustomLogger>(CustomLogger)
    paginationService = module.get<PaginationService>(PaginationService)
    mockPrismaModel = prismaService['news_tags']

    mockControllerProperties(
      controller,
      mockPrismaModel,
      logger,
      newsTagsService,
      paginationService,
      'newsTagsService',
    )
  })

  describe('findAllNewsTags', () => {
    it('should return paginated news tags', async () => {
      const newsTags = [
        { id: '1', ...createSampleNewsTag() },
        { id: '2', ...createSampleNewsTag() },
      ]
      const query = { page: 1, limit: 10 }

      mockPrismaModel.findMany.mockResolvedValue(newsTags)
      mockPrismaModel.count.mockResolvedValue(2)

      const result = await controller.findAllNewsTags(query)

      expect(result).toEqual(createPaginatedResponse(newsTags, 2))
      expect(mockPrismaModel.findMany).toHaveBeenCalled()
      expect(mockPrismaModel.count).toHaveBeenCalled()
    })

    it('should handle errors when fetching news tags', async () => {
      const error = new Error('Database error')
      mockPrismaModel.findMany.mockRejectedValue(error)

      const result = await controller.findAllNewsTags({ page: 1, limit: 10 })
      expect(result).toEqual(createErrorResponse('Database error'))
    })

    it('should handle filters and sorting', async () => {
      const newsTags = [
        { id: '1', ...createSampleNewsTag() },
        { id: '2', ...createSampleNewsTag() },
      ]
      const query = {
        page: 1,
        limit: 10,
        sortBy: 'created_at',
        sortOrder: 'desc' as const,
      }

      mockPrismaModel.findMany.mockResolvedValue(newsTags)
      mockPrismaModel.count.mockResolvedValue(2)

      const result = await controller.findAllNewsTags(query)

      expect(result).toEqual(createPaginatedResponse(newsTags, 2))
      expect(mockPrismaModel.findMany).toHaveBeenCalled()
      expect(mockPrismaModel.count).toHaveBeenCalled()
    })
  })

  describe('findOneNewsTags', () => {
    it('should return a single news tag', async () => {
      const newsTag = { id: '1', ...createSampleNewsTag() }
      mockPrismaModel.findUnique.mockResolvedValue(newsTag)

      const result = await controller.findOneNewsTags('1')

      expect(result).toEqual(createSuccessResponse(newsTag))
      expect(mockPrismaModel.findUnique).toHaveBeenCalledWith({
        where: { id: '1' },
      })
    })

    it('should handle not found error', async () => {
      mockPrismaModel.findUnique.mockResolvedValue(null)

      const result = await controller.findOneNewsTags('1')
      expect(result).toEqual(createErrorResponse('news_tags not found'))
    })
  })

  describe('createNewsTags', () => {
    it('should create a news tag', async () => {
      const createData = createSampleNewsTag()
      const createdTag = {
        id: '1',
        tag_id: createData.tags.connect!.id,
        news_id: createData.news_id,
        created_at: new Date(),
        updated_at: new Date(),
      }

      mockPrismaModel.create.mockResolvedValue(createdTag)

      const result = await controller.createNewsTags(createData)

      expect(result).toEqual(createSuccessResponse(createdTag))
      expect(mockPrismaModel.create).toHaveBeenCalledWith({
        data: createData,
      })
    })

    it('should handle creation errors', async () => {
      const createData = createSampleNewsTag()
      const error = new Error('Creation failed')
      mockPrismaModel.create.mockRejectedValue(error)

      const result = await controller.createNewsTags(createData)
      expect(result).toEqual(createErrorResponse('Creation failed'))
    })
  })

  describe('updateNewsTags', () => {
    it('should update a news tag', async () => {
      const id = '1'
      const updateData: Prisma.news_tagsUpdateInput = {
        tags: { connect: { id: faker.number.int() } },
      }
      const updatedTag = {
        id,
        tag_id: updateData.tags?.connect?.id,
        news_id: faker.string.uuid(),
        created_at: new Date(),
        updated_at: new Date(),
      }

      mockPrismaModel.update.mockResolvedValue(updatedTag)

      const result = await controller.updateNewsTags(id, updateData)

      expect(result).toEqual(createSuccessResponse(updatedTag))
      expect(mockPrismaModel.update).toHaveBeenCalledWith({
        where: { id },
        data: updateData,
      })
    })

    it('should handle update errors', async () => {
      const id = '1'
      const updateData: Prisma.news_tagsUpdateInput = {
        tags: { connect: { id: faker.number.int() } },
      }
      const error = new Error('Update failed')
      mockPrismaModel.update.mockRejectedValue(error)

      const result = await controller.updateNewsTags(id, updateData)
      expect(result).toEqual(createErrorResponse('Update failed'))
    })
  })

  describe('removeNewsTags', () => {
    it('should remove a news tag', async () => {
      const id = '1'
      const deletedTag = {
        id,
        tag_id: faker.string.uuid(),
        news_id: faker.string.uuid(),
        created_at: new Date(),
        updated_at: new Date(),
      }

      mockPrismaModel.findUnique.mockResolvedValue(deletedTag)
      mockPrismaModel.delete.mockResolvedValue(deletedTag)

      const result = await controller.removeNewsTags(id)

      expect(result).toEqual(createSuccessResponse(deletedTag))
      expect(mockPrismaModel.delete).toHaveBeenCalledWith({
        where: { id },
      })
    })

    it('should handle removal errors', async () => {
      const id = '1'
      mockPrismaModel.findUnique.mockResolvedValue(null)

      const result = await controller.removeNewsTags(id)
      expect(result).toEqual(createErrorResponse('news_tags not found'))
    })
  })
})

================
File: src/content/__tests__/news.test.ts
================
import { describe, it, expect, beforeEach } from 'vitest'
import { PrismaService } from '@core/services/prisma.service'
import { PaginationService } from '@core/services/pagination.service'
import { CustomLogger } from '@core/logger/custom.logger'
import { faker } from '@faker-js/faker'
import type { Prisma } from '@astronera/db'
import { NewsService } from '../services/news.service'
import { NewsController } from '../controllers/news.controller'
import {
  createTestModule,
  createBaseMockService,
  createSuccessResponse,
  createErrorResponse,
  createPaginatedResponse,
  mockControllerProperties,
} from './utils/test.utils'

const createSampleNews = (): Prisma.newsCreateInput => ({
  title: faker.helpers.arrayElement([faker.lorem.words(3), null]),
  body: faker.helpers.arrayElement([faker.lorem.words(3), null]),
  author: faker.helpers.arrayElement([faker.lorem.words(3), null]),
  description: faker.helpers.arrayElement([faker.lorem.words(3), null]),
  featured_image: faker.helpers.arrayElement([faker.lorem.words(3), null]),
  has_summary: faker.datatype.boolean(),
  published_at: faker.helpers.arrayElement([faker.date.recent(), null]),
  url: faker.internet.url(),
  hash: faker.number.bigInt(),
  failed_count: faker.helpers.arrayElement([faker.number.int({ min: 0, max: 10 }), null]),
  scrape_frequency: faker.helpers.arrayElement(['daily', 'weekly', 'monthly', null]),
  scraped_at: faker.helpers.arrayElement([faker.date.recent(), null]),
  content_status: faker.helpers.arrayElement(['draft', 'published', 'archived', null]),
  keywords: faker.helpers.arrayElement([faker.lorem.words(5).split(' '), null]),
  companies: { connect: { id: faker.string.uuid() } },
  contents: { connect: { id: faker.string.uuid() } },
})

describe('News Module', () => {
  let controller: NewsController
  let newsService: ReturnType<typeof createBaseMockService>
  let prismaService: PrismaService
  let logger: CustomLogger
  let paginationService: PaginationService
  let mockPrismaModel: any

  beforeEach(async () => {
    const mockService = createBaseMockService()
    const module = await createTestModule({
      controller: NewsController,
      serviceClass: NewsService,
      mockService,
      prismaModelName: 'news',
    })

    controller = module.get<NewsController>(NewsController)
    newsService = module.get(NewsService)
    prismaService = module.get<PrismaService>(PrismaService)
    logger = module.get<CustomLogger>(CustomLogger)
    paginationService = module.get<PaginationService>(PaginationService)
    mockPrismaModel = prismaService['news']

    mockControllerProperties(
      controller,
      mockPrismaModel,
      logger,
      newsService,
      paginationService,
      'newsService',
    )
  })

  describe('findAllNews', () => {
    it('should return paginated news', async () => {
      const news = [
        { id: '1', ...createSampleNews() },
        { id: '2', ...createSampleNews() },
      ]
      const query = { page: 1, limit: 10 }

      mockPrismaModel.findMany.mockResolvedValue(news)
      mockPrismaModel.count.mockResolvedValue(2)

      const result = await controller.findAllNews(query)

      expect(result).toEqual(createPaginatedResponse(news, 2))
      expect(mockPrismaModel.findMany).toHaveBeenCalled()
      expect(mockPrismaModel.count).toHaveBeenCalled()
    })

    it('should handle errors when fetching news', async () => {
      const error = new Error('Database error')
      mockPrismaModel.findMany.mockRejectedValue(error)

      const result = await controller.findAllNews({ page: 1, limit: 10 })
      expect(result).toEqual(createErrorResponse('Database error'))
    })

    it('should handle filters and sorting', async () => {
      const news = [
        { id: '1', ...createSampleNews() },
        { id: '2', ...createSampleNews() },
      ]
      const query = {
        page: 1,
        limit: 10,
        sortBy: 'created_at',
        sortOrder: 'desc' as const,
        content_status: 'published',
      }

      mockPrismaModel.findMany.mockResolvedValue(news)
      mockPrismaModel.count.mockResolvedValue(2)

      const result = await controller.findAllNews(query)

      expect(result).toEqual(createPaginatedResponse(news, 2))
      expect(mockPrismaModel.findMany).toHaveBeenCalled()
      expect(mockPrismaModel.count).toHaveBeenCalled()
    })
  })

  describe('findOneNews', () => {
    it('should return a single news item', async () => {
      const news = { id: '1', ...createSampleNews() }
      mockPrismaModel.findUnique.mockResolvedValue(news)

      const result = await controller.findOneNews('1')

      expect(result).toEqual(createSuccessResponse(news))
      expect(mockPrismaModel.findUnique).toHaveBeenCalledWith({
        where: { id: '1' },
      })
    })

    it('should handle not found error', async () => {
      mockPrismaModel.findUnique.mockResolvedValue(null)

      const result = await controller.findOneNews('1')
      expect(result).toEqual(createErrorResponse('news not found'))
    })
  })

  describe('createNews', () => {
    it('should create a news item', async () => {
      const createData = createSampleNews()
      const createdNews = {
        id: '1',
        ...createData,
        company_id: createData.companies.connect!.id,
        created_at: new Date(),
        updated_at: new Date(),
      }

      mockPrismaModel.create.mockResolvedValue(createdNews)

      const result = await controller.createNews(createData)

      expect(result).toEqual(createSuccessResponse(createdNews))
      expect(mockPrismaModel.create).toHaveBeenCalledWith({
        data: createData,
      })
    })

    it('should handle creation errors', async () => {
      const createData = createSampleNews()
      const error = new Error('Creation failed')
      mockPrismaModel.create.mockRejectedValue(error)

      const result = await controller.createNews(createData)
      expect(result).toEqual(createErrorResponse('Creation failed'))
    })
  })

  describe('updateNews', () => {
    it('should update a news item', async () => {
      const id = '1'
      const updateData: Prisma.newsUpdateInput = {
        title: faker.lorem.words(3),
        content_status: 'published',
        companies: { connect: { id: faker.string.uuid() } },
      }
      const updatedNews = {
        id,
        ...updateData,
        company_id: updateData.companies?.connect?.id,
        created_at: new Date(),
        updated_at: new Date(),
      }

      mockPrismaModel.update.mockResolvedValue(updatedNews)

      const result = await controller.updateNews(id, updateData)

      expect(result).toEqual(createSuccessResponse(updatedNews))
      expect(mockPrismaModel.update).toHaveBeenCalledWith({
        where: { id },
        data: updateData,
      })
    })

    it('should handle update errors', async () => {
      const id = '1'
      const updateData: Prisma.newsUpdateInput = {
        title: faker.lorem.words(3),
      }
      const error = new Error('Update failed')
      mockPrismaModel.update.mockRejectedValue(error)

      const result = await controller.updateNews(id, updateData)
      expect(result).toEqual(createErrorResponse('Update failed'))
    })
  })

  describe('removeNews', () => {
    it('should remove a news item', async () => {
      const id = '1'
      const deletedNews = {
        id,
        title: faker.lorem.words(3),
        company_id: faker.string.uuid(),
        created_at: new Date(),
        updated_at: new Date(),
      }

      mockPrismaModel.findUnique.mockResolvedValue(deletedNews)
      mockPrismaModel.delete.mockResolvedValue(deletedNews)

      const result = await controller.removeNews(id)

      expect(result).toEqual(createSuccessResponse(deletedNews))
      expect(mockPrismaModel.delete).toHaveBeenCalledWith({
        where: { id },
      })
    })

    it('should handle removal errors', async () => {
      const id = '1'
      mockPrismaModel.findUnique.mockResolvedValue(null)

      const result = await controller.removeNews(id)
      expect(result).toEqual(createErrorResponse('news not found'))
    })
  })
})

================
File: src/content/__tests__/newsletters.test.ts
================
import { describe, it, expect, beforeEach } from 'vitest'
import { PrismaService } from '@core/services/prisma.service'
import { PaginationService } from '@core/services/pagination.service'
import { CustomLogger } from '@core/logger/custom.logger'
import { faker } from '@faker-js/faker'
import type { Prisma } from '@astronera/db'
import { NewslettersService } from '../services/newsletters.service'
import { NewsletterController } from '../controllers/newsletters.controller'
import {
  createTestModule,
  createBaseMockService,
  createSuccessResponse,
  createErrorResponse,
  createPaginatedResponse,
  mockControllerProperties,
} from './utils/test.utils'

const createSampleNewsletter = (): Prisma.newslettersCreateInput => ({
  created_at: faker.date.recent(),
  title: faker.helpers.arrayElement([faker.lorem.words(3), null]),
  frequency: faker.helpers.arrayElement(['daily', 'weekly', 'monthly', null]),
  start_date: faker.date.recent(),
  end_date: faker.date.recent(),
  generated_content: faker.helpers.arrayElement([faker.lorem.words(3), null]),
  content_status: faker.helpers.arrayElement(['draft', 'published', 'archived', null]),
  contents: { connect: { id: faker.string.uuid() } },
})

describe('Newsletter Module', () => {
  let controller: NewsletterController
  let newslettersService: ReturnType<typeof createBaseMockService>
  let prismaService: PrismaService
  let logger: CustomLogger
  let paginationService: PaginationService
  let mockPrismaModel: any

  beforeEach(async () => {
    const mockService = createBaseMockService()
    const module = await createTestModule({
      controller: NewsletterController,
      serviceClass: NewslettersService,
      mockService,
      prismaModelName: 'newsletters',
    })

    controller = module.get<NewsletterController>(NewsletterController)
    newslettersService = module.get(NewslettersService)
    prismaService = module.get<PrismaService>(PrismaService)
    logger = module.get<CustomLogger>(CustomLogger)
    paginationService = module.get<PaginationService>(PaginationService)
    mockPrismaModel = prismaService['newsletters']

    mockControllerProperties(
      controller,
      mockPrismaModel,
      logger,
      newslettersService,
      paginationService,
      'newslettersService',
    )
  })

  describe('findAllNewsletters', () => {
    it('should return paginated newsletters', async () => {
      const newsletters = [
        { id: '1', ...createSampleNewsletter() },
        { id: '2', ...createSampleNewsletter() },
      ]
      const query = { page: 1, limit: 10 }

      mockPrismaModel.findMany.mockResolvedValue(newsletters)
      mockPrismaModel.count.mockResolvedValue(2)

      const result = await controller.findAllNewsletters(query)

      expect(result).toEqual(createPaginatedResponse(newsletters, 2))
      expect(mockPrismaModel.findMany).toHaveBeenCalled()
      expect(mockPrismaModel.count).toHaveBeenCalled()
    })

    it('should handle errors when fetching newsletters', async () => {
      const error = new Error('Database error')
      mockPrismaModel.findMany.mockRejectedValue(error)

      const result = await controller.findAllNewsletters({
        page: 1,
        limit: 10,
      })
      expect(result).toEqual(createErrorResponse('Database error'))
    })

    it('should handle filters and sorting', async () => {
      const newsletters = [
        { id: '1', ...createSampleNewsletter() },
        { id: '2', ...createSampleNewsletter() },
      ]
      const query = {
        page: 1,
        limit: 10,
        sortBy: 'created_at',
        sortOrder: 'desc' as const,
        content_status: 'published',
      }

      mockPrismaModel.findMany.mockResolvedValue(newsletters)
      mockPrismaModel.count.mockResolvedValue(2)

      const result = await controller.findAllNewsletters(query)

      expect(result).toEqual(createPaginatedResponse(newsletters, 2))
      expect(mockPrismaModel.findMany).toHaveBeenCalled()
      expect(mockPrismaModel.count).toHaveBeenCalled()
    })
  })

  describe('findOneNewsletters', () => {
    it('should return a single newsletter', async () => {
      const newsletter = { id: '1', ...createSampleNewsletter() }
      mockPrismaModel.findUnique.mockResolvedValue(newsletter)

      const result = await controller.findOneNewsletters('1')

      expect(result).toEqual(createSuccessResponse(newsletter))
      expect(mockPrismaModel.findUnique).toHaveBeenCalledWith({
        where: { id: '1' },
      })
    })

    it('should handle not found error', async () => {
      mockPrismaModel.findUnique.mockResolvedValue(null)

      const result = await controller.findOneNewsletters('1')
      expect(result).toEqual(createErrorResponse('newsletters not found'))
    })
  })

  describe('createNewsletters', () => {
    it('should create a newsletter', async () => {
      const createData = createSampleNewsletter()
      const createdNewsletter = {
        id: '1',
        ...createData,
        created_at: new Date(),
        updated_at: new Date(),
      }

      mockPrismaModel.create.mockResolvedValue(createdNewsletter)

      const result = await controller.createNewsletters(createData)

      expect(result).toEqual(createSuccessResponse(createdNewsletter))
      expect(mockPrismaModel.create).toHaveBeenCalledWith({
        data: createData,
      })
    })

    it('should handle creation errors', async () => {
      const createData = createSampleNewsletter()
      const error = new Error('Creation failed')
      mockPrismaModel.create.mockRejectedValue(error)

      const result = await controller.createNewsletters(createData)
      expect(result).toEqual(createErrorResponse('Creation failed'))
    })
  })

  describe('updateNewsletters', () => {
    it('should update a newsletter', async () => {
      const id = '1'
      const updateData: Prisma.newslettersUpdateInput = {
        title: faker.lorem.words(3),
        content_status: 'published',
        frequency: 'weekly',
      }
      const updatedNewsletter = {
        id,
        ...updateData,
        created_at: new Date(),
        updated_at: new Date(),
      }

      mockPrismaModel.update.mockResolvedValue(updatedNewsletter)

      const result = await controller.updateNewsletters(id, updateData)

      expect(result).toEqual(createSuccessResponse(updatedNewsletter))
      expect(mockPrismaModel.update).toHaveBeenCalledWith({
        where: { id },
        data: updateData,
      })
    })

    it('should handle update errors', async () => {
      const id = '1'
      const updateData: Prisma.newslettersUpdateInput = {
        title: faker.lorem.words(3),
      }
      const error = new Error('Update failed')
      mockPrismaModel.update.mockRejectedValue(error)

      const result = await controller.updateNewsletters(id, updateData)
      expect(result).toEqual(createErrorResponse('Update failed'))
    })
  })

  describe('removeNewsletters', () => {
    it('should remove a newsletter', async () => {
      const id = '1'
      const deletedNewsletter = {
        id,
        title: faker.lorem.words(3),
        user_id: faker.string.uuid(),
        created_at: new Date(),
        updated_at: new Date(),
      }

      mockPrismaModel.findUnique.mockResolvedValue(deletedNewsletter)
      mockPrismaModel.delete.mockResolvedValue(deletedNewsletter)

      const result = await controller.removeNewsletters(id)

      expect(result).toEqual(createSuccessResponse(deletedNewsletter))
      expect(mockPrismaModel.delete).toHaveBeenCalledWith({
        where: { id },
      })
    })

    it('should handle removal errors', async () => {
      const id = '1'
      mockPrismaModel.findUnique.mockResolvedValue(null)

      const result = await controller.removeNewsletters(id)
      expect(result).toEqual(createErrorResponse('newsletters not found'))
    })
  })
})

================
File: src/content/__tests__/research-embeddings.test.ts
================
import { describe, it, expect, beforeEach } from 'vitest'
import { PrismaService } from '@core/services/prisma.service'
import { PaginationService } from '@core/services/pagination.service'
import { CustomLogger } from '@core/logger/custom.logger'
import { faker } from '@faker-js/faker'
import type { Prisma } from '@astronera/db'
import { ResearchEmbeddingsService } from '../services/research-embeddings.service'
import { ResearchEmbeddingController } from '../controllers/research-embeddings.controller'
import {
  createTestModule,
  createBaseMockService,
  createSuccessResponse,
  createErrorResponse,
  createPaginatedResponse,
  mockControllerProperties,
} from './utils/test.utils'

const createSampleResearchEmbedding = (): Prisma.research_embeddingsCreateInput => ({
  research: { connect: { id: faker.string.uuid() } },
  chunk: faker.lorem.words(3),
  url: faker.helpers.arrayElement([faker.internet.url(), null]),
  // embedding: faker.helpers.arrayElement([faker.lorem.words(10).split(' '), null]),
  is_flagged: faker.helpers.arrayElement([faker.datatype.boolean(), null]),
  // embedding_reviews: faker.helpers.arrayElement([
  //   { connect: { id: faker.string.uuid() } },
  //   undefined
  // ])
})

describe('ResearchEmbedding Module', () => {
  let controller: ResearchEmbeddingController
  let researchEmbeddingsService: ReturnType<typeof createBaseMockService>
  let prismaService: PrismaService
  let logger: CustomLogger
  let paginationService: PaginationService
  let mockPrismaModel: any

  beforeEach(async () => {
    const mockService = createBaseMockService()
    const module = await createTestModule({
      controller: ResearchEmbeddingController,
      serviceClass: ResearchEmbeddingsService,
      mockService,
      prismaModelName: 'research_embeddings',
    })

    controller = module.get<ResearchEmbeddingController>(ResearchEmbeddingController)
    researchEmbeddingsService = module.get(ResearchEmbeddingsService)
    prismaService = module.get<PrismaService>(PrismaService)
    logger = module.get<CustomLogger>(CustomLogger)
    paginationService = module.get<PaginationService>(PaginationService)
    mockPrismaModel = prismaService['research_embeddings']

    mockControllerProperties(
      controller,
      mockPrismaModel,
      logger,
      researchEmbeddingsService,
      paginationService,
      'researchEmbeddingsService',
    )
  })

  describe('findAllResearchEmbeddings', () => {
    it('should return paginated research embeddings', async () => {
      const researchEmbeddings = [
        { id: '1', ...createSampleResearchEmbedding() },
        { id: '2', ...createSampleResearchEmbedding() },
      ]
      const query = { page: 1, limit: 10 }

      mockPrismaModel.findMany.mockResolvedValue(researchEmbeddings)
      mockPrismaModel.count.mockResolvedValue(2)

      const result = await controller.findAllResearchEmbeddings(query)

      expect(result).toEqual(createPaginatedResponse(researchEmbeddings, 2))
      expect(mockPrismaModel.findMany).toHaveBeenCalled()
      expect(mockPrismaModel.count).toHaveBeenCalled()
    })

    it('should handle errors when fetching research embeddings', async () => {
      const error = new Error('Database error')
      mockPrismaModel.findMany.mockRejectedValue(error)

      const result = await controller.findAllResearchEmbeddings({
        page: 1,
        limit: 10,
      })
      expect(result).toEqual(createErrorResponse('Database error'))
    })

    it('should handle filters and sorting', async () => {
      const researchEmbeddings = [
        { id: '1', ...createSampleResearchEmbedding() },
        { id: '2', ...createSampleResearchEmbedding() },
      ]
      const query = {
        page: 1,
        limit: 10,
        sortBy: 'created_at',
        sortOrder: 'desc' as const,
        is_flagged: true,
      }

      mockPrismaModel.findMany.mockResolvedValue(researchEmbeddings)
      mockPrismaModel.count.mockResolvedValue(2)

      const result = await controller.findAllResearchEmbeddings(query)

      expect(result).toEqual(createPaginatedResponse(researchEmbeddings, 2))
      expect(mockPrismaModel.findMany).toHaveBeenCalled()
      expect(mockPrismaModel.count).toHaveBeenCalled()
    })
  })

  describe('findOneResearchEmbeddings', () => {
    it('should return a single research embedding', async () => {
      const researchEmbedding = { id: '1', ...createSampleResearchEmbedding() }
      mockPrismaModel.findUnique.mockResolvedValue(researchEmbedding)

      const result = await controller.findOneResearchEmbeddings('1')

      expect(result).toEqual(createSuccessResponse(researchEmbedding))
      expect(mockPrismaModel.findUnique).toHaveBeenCalledWith({
        where: { id: '1' },
      })
    })

    it('should handle not found error', async () => {
      mockPrismaModel.findUnique.mockResolvedValue(null)

      const result = await controller.findOneResearchEmbeddings('1')
      expect(result).toEqual(createErrorResponse('research_embeddings not found'))
    })
  })

  describe('createResearchEmbeddings', () => {
    it('should create a research embedding', async () => {
      const createData = createSampleResearchEmbedding()
      const createdEmbedding = {
        id: '1',
        ...createData,
        research_id: createData.research.connect!.id,
        // embedding_review_id: createData.embedding_review?.connect?.id,
        created_at: new Date(),
        updated_at: new Date(),
      }

      mockPrismaModel.create.mockResolvedValue(createdEmbedding)

      const result = await controller.createResearchEmbeddings(createData)

      expect(result).toEqual(createSuccessResponse(createdEmbedding))
      expect(mockPrismaModel.create).toHaveBeenCalledWith({
        data: createData,
      })
    })

    it('should handle creation errors', async () => {
      const createData = createSampleResearchEmbedding()
      const error = new Error('Creation failed')
      mockPrismaModel.create.mockRejectedValue(error)

      const result = await controller.createResearchEmbeddings(createData)
      expect(result).toEqual(createErrorResponse('Creation failed'))
    })
  })

  describe('updateResearchEmbeddings', () => {
    it('should update a research embedding', async () => {
      const id = '1'
      const updateData: Prisma.research_embeddingsUpdateInput = {
        chunk: faker.lorem.words(3),
        is_flagged: true,
        // embedding_review: { connect: { id: faker.string.uuid() } }
      }
      const updatedEmbedding = {
        id,
        ...updateData,
        research_id: faker.string.uuid(),
        // embedding_review_id: updateData.embedding_review?.connect?.id,
        created_at: new Date(),
        updated_at: new Date(),
      }

      mockPrismaModel.update.mockResolvedValue(updatedEmbedding)

      const result = await controller.updateResearchEmbeddings(id, updateData)

      expect(result).toEqual(createSuccessResponse(updatedEmbedding))
      expect(mockPrismaModel.update).toHaveBeenCalledWith({
        where: { id },
        data: updateData,
      })
    })

    it('should handle update errors', async () => {
      const id = '1'
      const updateData: Prisma.research_embeddingsUpdateInput = {
        chunk: faker.lorem.words(3),
      }
      const error = new Error('Update failed')
      mockPrismaModel.update.mockRejectedValue(error)

      const result = await controller.updateResearchEmbeddings(id, updateData)
      expect(result).toEqual(createErrorResponse('Update failed'))
    })
  })

  describe('removeResearchEmbeddings', () => {
    it('should remove a research embedding', async () => {
      const id = '1'
      const deletedEmbedding = {
        id,
        chunk: faker.lorem.words(3),
        research_id: faker.string.uuid(),
        created_at: new Date(),
        updated_at: new Date(),
      }

      mockPrismaModel.findUnique.mockResolvedValue(deletedEmbedding)
      mockPrismaModel.delete.mockResolvedValue(deletedEmbedding)

      const result = await controller.removeResearchEmbeddings(id)

      expect(result).toEqual(createSuccessResponse(deletedEmbedding))
      expect(mockPrismaModel.delete).toHaveBeenCalledWith({
        where: { id },
      })
    })

    it('should handle removal errors', async () => {
      const id = '1'
      mockPrismaModel.findUnique.mockResolvedValue(null)

      const result = await controller.removeResearchEmbeddings(id)
      expect(result).toEqual(createErrorResponse('research_embeddings not found'))
    })
  })
})

================
File: src/content/__tests__/research.test.ts
================
import { describe, it, expect, beforeEach } from 'vitest'
import { PrismaService } from '@core/services/prisma.service'
import { PaginationService } from '@core/services/pagination.service'
import { CustomLogger } from '@core/logger/custom.logger'
import { faker } from '@faker-js/faker'
import type { Prisma } from '@astronera/db'
import { ResearchService } from '../services/research.service'
import { ResearchController } from '../controllers/research.controller'
import {
  createTestModule,
  createBaseMockService,
  createSuccessResponse,
  createErrorResponse,
  createPaginatedResponse,
  mockControllerProperties,
} from './utils/test.utils'

const createSampleResearch = (): Prisma.researchCreateInput => ({
  published_at: faker.helpers.arrayElement([faker.date.recent(), null]),
  title: faker.helpers.arrayElement([faker.lorem.words(3), null]),
  version: faker.helpers.arrayElement([1, null]),
  abstract: faker.helpers.arrayElement([faker.lorem.words(3), null]),
  keywords: faker.lorem.words(5),
  month: faker.helpers.arrayElement([faker.date.month(), null]),
  year: faker.date.past().getFullYear().toString(),
  abstract_url: faker.internet.url(),
  category: faker.helpers.arrayElement([faker.lorem.words(3), null]),
  doi_url: faker.helpers.arrayElement([faker.internet.url(), null]),
  figure_count: faker.helpers.arrayElement([faker.number.int({ min: 0, max: 10 }), null]),
  has_embedding: faker.helpers.arrayElement([faker.datatype.boolean(), null]),
  page_count: faker.helpers.arrayElement([faker.number.int({ min: 1, max: 100 }), null]),
  pdf_url: faker.helpers.arrayElement([faker.internet.url(), null]),
  published_in: faker.helpers.arrayElement([faker.lorem.words(3), null]),
  table_count: faker.helpers.arrayElement([faker.number.int({ min: 0, max: 10 }), null]),
  comments: faker.helpers.arrayElement([faker.lorem.words(3), null]),
  is_flagged: faker.datatype.boolean(),
  authors: faker.helpers.arrayElement([faker.lorem.words(5).split(' '), null]),
  summary: faker.helpers.arrayElement([faker.lorem.words(3), null]),
  content_status: faker.helpers.arrayElement(['draft', 'published', 'archived', null]),
  affiliations: faker.helpers.arrayElement([faker.lorem.words(5).split(' '), null]),
})

describe('Research Module', () => {
  let controller: ResearchController
  let researchService: ReturnType<typeof createBaseMockService>
  let prismaService: PrismaService
  let logger: CustomLogger
  let paginationService: PaginationService
  let mockPrismaModel: any

  beforeEach(async () => {
    const mockService = createBaseMockService()
    const module = await createTestModule({
      controller: ResearchController,
      serviceClass: ResearchService,
      mockService,
      prismaModelName: 'research',
    })

    controller = module.get<ResearchController>(ResearchController)
    researchService = module.get(ResearchService)
    prismaService = module.get<PrismaService>(PrismaService)
    logger = module.get<CustomLogger>(CustomLogger)
    paginationService = module.get<PaginationService>(PaginationService)
    mockPrismaModel = prismaService['research']

    mockControllerProperties(
      controller,
      mockPrismaModel,
      logger,
      researchService,
      paginationService,
      'researchService',
    )
  })

  describe('findAllResearch', () => {
    it('should return paginated research', async () => {
      const research = [
        { id: '1', ...createSampleResearch() },
        { id: '2', ...createSampleResearch() },
      ]
      const query = { page: 1, limit: 10 }

      mockPrismaModel.findMany.mockResolvedValue(research)
      mockPrismaModel.count.mockResolvedValue(2)

      const result = await controller.findAllResearch(query)

      expect(result).toEqual(createPaginatedResponse(research, 2))
      expect(mockPrismaModel.findMany).toHaveBeenCalled()
      expect(mockPrismaModel.count).toHaveBeenCalled()
    })

    it('should handle errors when fetching research', async () => {
      const error = new Error('Database error')
      mockPrismaModel.findMany.mockRejectedValue(error)

      const result = await controller.findAllResearch({ page: 1, limit: 10 })
      expect(result).toEqual(createErrorResponse('Database error'))
    })

    it('should handle filters and sorting', async () => {
      const research = [
        { id: '1', ...createSampleResearch() },
        { id: '2', ...createSampleResearch() },
      ]
      const query = {
        page: 1,
        limit: 10,
        sortBy: 'created_at',
        sortOrder: 'desc' as const,
        content_status: 'published',
        has_embedding: true,
      }

      mockPrismaModel.findMany.mockResolvedValue(research)
      mockPrismaModel.count.mockResolvedValue(2)

      const result = await controller.findAllResearch(query)

      expect(result).toEqual(createPaginatedResponse(research, 2))
      expect(mockPrismaModel.findMany).toHaveBeenCalled()
      expect(mockPrismaModel.count).toHaveBeenCalled()
    })
  })

  describe('findOneResearch', () => {
    it('should return a single research', async () => {
      const research = { id: '1', ...createSampleResearch() }
      mockPrismaModel.findUnique.mockResolvedValue(research)

      const result = await controller.findOneResearch('1')

      expect(result).toEqual(createSuccessResponse(research))
      expect(mockPrismaModel.findUnique).toHaveBeenCalledWith({
        where: { id: '1' },
      })
    })

    it('should handle not found error', async () => {
      mockPrismaModel.findUnique.mockResolvedValue(null)

      const result = await controller.findOneResearch('1')
      expect(result).toEqual(createErrorResponse('research not found'))
    })
  })

  describe('createResearch', () => {
    it('should create a research', async () => {
      const createData = createSampleResearch()
      const createdResearch = {
        id: '1',
        ...createData,
        created_at: new Date(),
        updated_at: new Date(),
      }

      mockPrismaModel.create.mockResolvedValue(createdResearch)

      const result = await controller.createResearch(createData)

      expect(result).toEqual(createSuccessResponse(createdResearch))
      expect(mockPrismaModel.create).toHaveBeenCalledWith({
        data: createData,
      })
    })

    it('should handle creation errors', async () => {
      const createData = createSampleResearch()
      const error = new Error('Creation failed')
      mockPrismaModel.create.mockRejectedValue(error)

      const result = await controller.createResearch(createData)
      expect(result).toEqual(createErrorResponse('Creation failed'))
    })
  })

  describe('updateResearch', () => {
    it('should update a research', async () => {
      const id = '1'
      const updateData: Prisma.researchUpdateInput = {
        title: faker.lorem.words(3),
        content_status: 'published',
        has_embedding: true,
        summary: faker.lorem.words(3),
      }
      const updatedResearch = {
        id,
        ...updateData,
        user_id: faker.string.uuid(),
        created_at: new Date(),
        updated_at: new Date(),
      }

      mockPrismaModel.update.mockResolvedValue(updatedResearch)

      const result = await controller.updateResearch(id, updateData)

      expect(result).toEqual(createSuccessResponse(updatedResearch))
      expect(mockPrismaModel.update).toHaveBeenCalledWith({
        where: { id },
        data: updateData,
      })
    })

    it('should handle update errors', async () => {
      const id = '1'
      const updateData: Prisma.researchUpdateInput = {
        title: faker.lorem.words(3),
      }
      const error = new Error('Update failed')
      mockPrismaModel.update.mockRejectedValue(error)

      const result = await controller.updateResearch(id, updateData)
      expect(result).toEqual(createErrorResponse('Update failed'))
    })
  })

  describe('removeResearch', () => {
    it('should remove a research', async () => {
      const id = '1'
      const deletedResearch = {
        id,
        title: faker.lorem.words(3),
        user_id: faker.string.uuid(),
        created_at: new Date(),
        updated_at: new Date(),
      }

      mockPrismaModel.findUnique.mockResolvedValue(deletedResearch)
      mockPrismaModel.delete.mockResolvedValue(deletedResearch)

      const result = await controller.removeResearch(id)

      expect(result).toEqual(createSuccessResponse(deletedResearch))
      expect(mockPrismaModel.delete).toHaveBeenCalledWith({
        where: { id },
      })
    })

    it('should handle removal errors', async () => {
      const id = '1'
      mockPrismaModel.findUnique.mockResolvedValue(null)

      const result = await controller.removeResearch(id)
      expect(result).toEqual(createErrorResponse('research not found'))
    })
  })
})

================
File: src/content/__tests__/tags.test.ts
================
import { describe, it, expect, beforeEach } from 'vitest'
import { PrismaService } from '@core/services/prisma.service'
import { PaginationService } from '@core/services/pagination.service'
import { CustomLogger } from '@core/logger/custom.logger'
import { faker } from '@faker-js/faker'
import type { Prisma } from '@astronera/db'
import { TagsService } from '../services/tags.service'
import { TagController } from '../controllers/tags.controller'
import {
  createTestModule,
  createBaseMockService,
  createSuccessResponse,
  createErrorResponse,
  createPaginatedResponse,
  mockControllerProperties,
} from './utils/test.utils'

const createSampleTag = (): Prisma.tagsCreateInput => ({
  id: faker.number.int(),
  body: faker.helpers.arrayElement([faker.lorem.words(3), null]),
  name: faker.lorem.words(3),
  document_id: faker.helpers.arrayElement([faker.string.uuid(), null]),
  locale: faker.helpers.arrayElement(['en', 'es', 'fr', null]),
  published_at: faker.helpers.arrayElement([faker.date.recent().toString(), null]),
})

describe('Tag Module', () => {
  let controller: TagController
  let tagsService: ReturnType<typeof createBaseMockService>
  let prismaService: PrismaService
  let logger: CustomLogger
  let paginationService: PaginationService
  let mockPrismaModel: any

  beforeEach(async () => {
    const mockService = createBaseMockService()
    const module = await createTestModule({
      controller: TagController,
      serviceClass: TagsService,
      mockService,
      prismaModelName: 'tags',
    })

    controller = module.get<TagController>(TagController)
    tagsService = module.get(TagsService)
    prismaService = module.get<PrismaService>(PrismaService)
    logger = module.get<CustomLogger>(CustomLogger)
    paginationService = module.get<PaginationService>(PaginationService)
    mockPrismaModel = prismaService['tags']

    mockControllerProperties(
      controller,
      mockPrismaModel,
      logger,
      tagsService,
      paginationService,
      'tagsService',
    )
  })

  describe('findAllTags', () => {
    it('should return paginated tags', async () => {
      const tags = [
        { id: '1', ...createSampleTag() },
        { id: '2', ...createSampleTag() },
      ]
      const query = { page: 1, limit: 10 }

      mockPrismaModel.findMany.mockResolvedValue(tags)
      mockPrismaModel.count.mockResolvedValue(2)

      const result = await controller.findAllTags(query)

      expect(result).toEqual(createPaginatedResponse(tags, 2))
      expect(mockPrismaModel.findMany).toHaveBeenCalled()
      expect(mockPrismaModel.count).toHaveBeenCalled()
    })

    it('should handle errors when fetching tags', async () => {
      const error = new Error('Database error')
      mockPrismaModel.findMany.mockRejectedValue(error)

      const result = await controller.findAllTags({ page: 1, limit: 10 })
      expect(result).toEqual(createErrorResponse('Database error'))
    })

    it('should handle filters and sorting', async () => {
      const tags = [
        { id: '1', ...createSampleTag() },
        { id: '2', ...createSampleTag() },
      ]
      const query = {
        page: 1,
        limit: 10,
        sortBy: 'created_at',
        sortOrder: 'desc' as const,
        locale: 'en',
      }

      mockPrismaModel.findMany.mockResolvedValue(tags)
      mockPrismaModel.count.mockResolvedValue(2)

      const result = await controller.findAllTags(query)

      expect(result).toEqual(createPaginatedResponse(tags, 2))
      expect(mockPrismaModel.findMany).toHaveBeenCalled()
      expect(mockPrismaModel.count).toHaveBeenCalled()
    })
  })

  describe('findOneTags', () => {
    it('should return a single tag', async () => {
      const tag = { id: '1', ...createSampleTag() }
      mockPrismaModel.findUnique.mockResolvedValue(tag)

      const result = await controller.findOneTags('1')

      expect(result).toEqual(createSuccessResponse(tag))
      expect(mockPrismaModel.findUnique).toHaveBeenCalledWith({
        where: { id: '1' },
      })
    })

    it('should handle not found error', async () => {
      mockPrismaModel.findUnique.mockResolvedValue(null)

      const result = await controller.findOneTags('1')
      expect(result).toEqual(createErrorResponse('tags not found'))
    })
  })

  describe('createTags', () => {
    it('should create a tag', async () => {
      const createData = createSampleTag()
      const createdTag = {
        id: '1',
        ...createData,
        created_at: new Date(),
        updated_at: new Date(),
      }

      mockPrismaModel.create.mockResolvedValue(createdTag)

      const result = await controller.createTags(createData)

      expect(result).toEqual(createSuccessResponse(createdTag))
      expect(mockPrismaModel.create).toHaveBeenCalledWith({
        data: createData,
      })
    })

    it('should handle creation errors', async () => {
      const createData = createSampleTag()
      const error = new Error('Creation failed')
      mockPrismaModel.create.mockRejectedValue(error)

      const result = await controller.createTags(createData)
      expect(result).toEqual(createErrorResponse('Creation failed'))
    })
  })

  describe('updateTags', () => {
    it('should update a tag', async () => {
      const id = '1'
      const updateData: Prisma.tagsUpdateInput = {
        name: faker.lorem.words(3),
        body: faker.lorem.words(3),
        locale: 'en',
        published_at: faker.date.recent().toString(),
      }
      const updatedTag = {
        id,
        ...updateData,
        user_id: faker.string.uuid(),
        created_at: new Date(),
        updated_at: new Date(),
      }

      mockPrismaModel.update.mockResolvedValue(updatedTag)

      const result = await controller.updateTags(id, updateData)

      expect(result).toEqual(createSuccessResponse(updatedTag))
      expect(mockPrismaModel.update).toHaveBeenCalledWith({
        where: { id },
        data: updateData,
      })
    })

    it('should handle update errors', async () => {
      const id = '1'
      const updateData: Prisma.tagsUpdateInput = {
        name: faker.lorem.words(3),
      }
      const error = new Error('Update failed')
      mockPrismaModel.update.mockRejectedValue(error)

      const result = await controller.updateTags(id, updateData)
      expect(result).toEqual(createErrorResponse('Update failed'))
    })
  })

  describe('removeTags', () => {
    it('should remove a tag', async () => {
      const id = '1'
      const deletedTag = {
        id,
        name: faker.lorem.words(3),
        user_id: faker.string.uuid(),
        created_at: new Date(),
        updated_at: new Date(),
      }

      mockPrismaModel.findUnique.mockResolvedValue(deletedTag)
      mockPrismaModel.delete.mockResolvedValue(deletedTag)

      const result = await controller.removeTags(id)

      expect(result).toEqual(createSuccessResponse(deletedTag))
      expect(mockPrismaModel.delete).toHaveBeenCalledWith({
        where: { id },
      })
    })

    it('should handle removal errors', async () => {
      const id = '1'
      mockPrismaModel.findUnique.mockResolvedValue(null)

      const result = await controller.removeTags(id)
      expect(result).toEqual(createErrorResponse('tags not found'))
    })
  })
})

================
File: src/content/controllers/categories.controller.ts
================
// controller.ejs template
import {
  Controller,
  Get,
  Post,
  Put,
  Delete,
  Body,
  Param,
  Query,
  ParseUUIDPipe,
  Inject,
} from '@nestjs/common'
import { ApiTags, ApiOperation } from '@nestjs/swagger'
import { CategoriesService } from '../services/categories.service'
import { ConfigService } from '@nestjs/config'
import { PrismaService } from '@core/services/prisma.service'
import { PaginationService } from '@core/services/pagination.service'
import { CustomLogger } from '@core/logger/custom.logger'
import { BaseController } from '@core/base/base.controller'

import type { Prisma } from '@astronera/db'
import type { PaginatedResponse, PaginatedQuery } from '@types'

@Controller('categories')
@ApiTags('Categories')
export class CategoryController extends BaseController {
  constructor(
    protected readonly categoriesService: CategoriesService,
    protected readonly prisma: PrismaService,
    protected readonly config: ConfigService,
    protected readonly paginationService: PaginationService,
    protected readonly logger: CustomLogger,
  ) {
    super('Categories')
  }

  @Get()
  @ApiOperation({ summary: 'Get all Categories' })
  async findAllCategories(
    @Query() query: PaginatedQuery,
  ): Promise<
    PaginatedResponse<unknown> | { success: boolean; error: any; timestamp: string; code: any }
  > {
    try {
      this.logger.log('Fetching all categories')
      return super.findAll(query)
    } catch (error: any) {
      this.logger.error('Failed to fetch categories', error.stack)
      throw error
    }
  }

  @Get(':id')
  @ApiOperation({ summary: 'Get Categories by id' })
  async findOneCategories(
    @Param('id', ParseUUIDPipe) id: string,
    @Query('include') include?: string[],
  ) {
    try {
      return await super.findOne(id, include)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Post()
  @ApiOperation({ summary: 'Create Categories' })
  async createCategories(@Body() data: Prisma.CategoriesCreateInput) {
    try {
      return await super.create(data)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Put(':id')
  @ApiOperation({ summary: 'Update Categories' })
  async updateCategories(
    @Param('id', ParseUUIDPipe) id: string,
    @Body() data: Prisma.CategoriesUpdateInput,
  ) {
    try {
      return await super.update(id, data)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Delete(':id')
  @ApiOperation({ summary: 'Delete Categories' })
  async removeCategories(@Param('id', ParseUUIDPipe) id: string) {
    try {
      return await super.remove(id)
    } catch (error: any) {
      return this.handleError(error)
    }
  }
}

================
File: src/content/controllers/content-categories.controller.ts
================
// controller.ejs template
import {
  Controller,
  Get,
  Post,
  Put,
  Delete,
  Body,
  Param,
  Query,
  ParseUUIDPipe,
} from '@nestjs/common'
import { ApiTags, ApiOperation } from '@nestjs/swagger'
import { ContentCategoriesService } from '../services/content-categories.service'
import { PrismaService } from '@core/services/prisma.service'
import { PaginationService } from '@core/services/pagination.service'
import { CustomLogger } from '@core/logger/custom.logger'
import { BaseController } from '@core/base/base.controller'
import { ConfigService } from '@nestjs/config'

import type { Prisma } from '@astronera/db'
import type { PaginatedResponse, PaginatedQuery } from '@types'

@Controller('content-categories')
@ApiTags('ContentCategories')
export class ContentCategoryController extends BaseController {
  constructor(
    protected readonly contentCategoriesService: ContentCategoriesService,
    protected readonly prisma: PrismaService,
    protected readonly config: ConfigService,
    protected readonly paginationService: PaginationService,
    protected readonly logger: CustomLogger,
  ) {
    super('ContentCategories')
  }

  @Get()
  @ApiOperation({ summary: 'Get all ContentCategories' })
  async findAllContentCategories(
    @Query() query: PaginatedQuery,
  ): Promise<
    PaginatedResponse<unknown> | { success: boolean; error: any; timestamp: string; code: any }
  > {
    try {
      return await super.findAll(query)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Get(':id')
  @ApiOperation({ summary: 'Get ContentCategories by id' })
  async findOneContentCategories(
    @Param('id', ParseUUIDPipe) id: string,
    @Query('include') include?: string[],
  ) {
    try {
      return await super.findOne(id, include)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Post()
  @ApiOperation({ summary: 'Create ContentCategories' })
  async createContentCategories(@Body() data: Prisma.ContentCategoriesCreateInput) {
    try {
      return await super.create(data)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Put(':id')
  @ApiOperation({ summary: 'Update ContentCategories' })
  async updateContentCategories(
    @Param('id', ParseUUIDPipe) id: string,
    @Body() data: Prisma.ContentCategoriesUpdateInput,
  ) {
    try {
      return await super.update(id, data)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Delete(':id')
  @ApiOperation({ summary: 'Delete ContentCategories' })
  async removeContentCategories(@Param('id', ParseUUIDPipe) id: string) {
    try {
      return await super.remove(id)
    } catch (error: any) {
      return this.handleError(error)
    }
  }
}

================
File: src/content/controllers/content-source-visits.controller.ts
================
// controller.ejs template
import {
  Controller,
  Get,
  Post,
  Put,
  Delete,
  Body,
  Param,
  Query,
  ParseUUIDPipe,
} from '@nestjs/common'
import { ApiTags, ApiOperation } from '@nestjs/swagger'
import { PrismaService } from '@core/services/prisma.service'
import { PaginationService } from '@core/services/pagination.service'
import { CustomLogger } from '@core/logger/custom.logger'
import { BaseController } from '@core/base/base.controller'
import { ConfigService } from '@nestjs/config'
import { ContentSourceVisitService } from '../services/content-source-visits.service'

import type { Prisma } from '@astronera/db'
import type { PaginatedResponse, PaginatedQuery } from '@types'

@Controller('content-source-visits')
@ApiTags('ContentSourceVisits')
export class ContentSourceVisitController extends BaseController {
  constructor(
    protected readonly contentSourceVisitService: ContentSourceVisitService,
    protected readonly prisma: PrismaService,
    protected readonly config: ConfigService,
    protected readonly paginationService: PaginationService,
    protected readonly logger: CustomLogger,
  ) {
    super('ContentSourceVisits')
  }

  @Get()
  @ApiOperation({ summary: 'Get all ContentSourceVisits' })
  async findAllContentSourceVisits(
    @Query() query: PaginatedQuery,
  ): Promise<
    PaginatedResponse<unknown> | { success: boolean; error: any; timestamp: string; code: any }
  > {
    try {
      return await super.findAll(query)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Get(':id')
  @ApiOperation({ summary: 'Get ContentSourceVisits by id' })
  async findOneContentSourceVisits(
    @Param('id', ParseUUIDPipe) id: string,
    @Query('include') include?: string[],
  ) {
    try {
      return await super.findOne(id, include)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Post()
  @ApiOperation({ summary: 'Create ContentSourceVisits' })
  async createContentSourceVisits(@Body() data: Prisma.ContentSourceVisitsCreateInput) {
    try {
      return await super.create(data)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Put(':id')
  @ApiOperation({ summary: 'Update ContentSourceVisits' })
  async updateContentSourceVisits(
    @Param('id', ParseUUIDPipe) id: string,
    @Body() data: Prisma.ContentSourceVisitsUpdateInput,
  ) {
    try {
      return await super.update(id, data)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Delete(':id')
  @ApiOperation({ summary: 'Delete ContentSourceVisits' })
  async removeContentSourceVisits(@Param('id', ParseUUIDPipe) id: string) {
    try {
      return await super.remove(id)
    } catch (error: any) {
      return this.handleError(error)
    }
  }
}

================
File: src/content/controllers/content-sources.controller.ts
================
// controller.ejs template
import {
  Controller,
  Get,
  Post,
  Put,
  Delete,
  Body,
  Param,
  Query,
  ParseUUIDPipe,
} from '@nestjs/common'
import { ApiTags, ApiOperation } from '@nestjs/swagger'
import { PrismaService } from '@core/services/prisma.service'
import { PaginationService } from '@core/services/pagination.service'
import { CustomLogger } from '@core/logger/custom.logger'
import { BaseController } from '@core/base/base.controller'
import { ConfigService } from '@nestjs/config'
import { ContentSourcesService } from '../services/content-sources.service'

import { Prisma } from '@astronera/db'
import type { PaginatedResponse, PaginatedQuery } from '@types'

@Controller('content-sources')
@ApiTags('ContentSources')
export class ContentSourceController extends BaseController {
  constructor(
    protected readonly contentSourcesService: ContentSourcesService,
    protected readonly prisma: PrismaService,
    protected readonly config: ConfigService,
    protected readonly paginationService: PaginationService,
    protected readonly logger: CustomLogger,
  ) {
    super('ContentSources')
  }

  @Get()
  @ApiOperation({ summary: 'Get all ContentSources' })
  async findAllContentSources(
    @Query() query: PaginatedQuery,
  ): Promise<
    PaginatedResponse<unknown> | { success: boolean; error: any; timestamp: string; code: any }
  > {
    try {
      return await super.findAll(query)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Get(':id')
  @ApiOperation({ summary: 'Get ContentSources by id' })
  async findOneContentSources(
    @Param('id', ParseUUIDPipe) id: string,
    @Query('include') include?: string[],
  ) {
    try {
      return await super.findOne(id, include)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Post()
  @ApiOperation({ summary: 'Create ContentSources' })
  async createContentSources(@Body() data: Prisma.ContentSourcesCreateInput) {
    try {
      return await super.create(data)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Put(':id')
  @ApiOperation({ summary: 'Update ContentSources' })
  async updateContentSources(
    @Param('id', ParseUUIDPipe) id: string,
    @Body() data: Prisma.ContentSourcesUpdateInput,
  ) {
    try {
      return await super.update(id, data)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Delete(':id')
  @ApiOperation({ summary: 'Delete ContentSources' })
  async removeContentSources(@Param('id', ParseUUIDPipe) id: string) {
    try {
      return await super.remove(id)
    } catch (error: any) {
      return this.handleError(error)
    }
  }
}

================
File: src/content/controllers/content-statuses.controller.ts
================
// controller.ejs template
import {
  Controller,
  Get,
  Post,
  Put,
  Delete,
  Body,
  Param,
  Query,
  ParseUUIDPipe,
} from '@nestjs/common'
import { ApiTags, ApiOperation } from '@nestjs/swagger'
import { PrismaService } from '@core/services/prisma.service'
import { PaginationService } from '@core/services/pagination.service'
import { CustomLogger } from '@core/logger/custom.logger'
import { BaseController } from '@core/base/base.controller'
import { ConfigService } from '@nestjs/config'
import { ContentStatusesService } from '../services/content-statuses.service'

import type { Prisma } from '@astronera/db'
import type { PaginatedResponse, PaginatedQuery } from '@types'

@Controller('content-statuses')
@ApiTags('ContentStatuses')
export class ContentStatusController extends BaseController {
  constructor(
    protected readonly contentStatusesService: ContentStatusesService,
    protected readonly prisma: PrismaService,
    protected readonly config: ConfigService,
    protected readonly paginationService: PaginationService,
    protected readonly logger: CustomLogger,
  ) {
    super('ContentStatuses')
  }

  @Get()
  @ApiOperation({ summary: 'Get all ContentStatuses' })
  async findAllContentStatuses(
    @Query() query: PaginatedQuery,
  ): Promise<
    PaginatedResponse<unknown> | { success: boolean; error: any; timestamp: string; code: any }
  > {
    try {
      return await super.findAll(query)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Get(':id')
  @ApiOperation({ summary: 'Get ContentStatuses by id' })
  async findOneContentStatuses(
    @Param('id', ParseUUIDPipe) id: string,
    @Query('include') include?: string[],
  ) {
    try {
      return await super.findOne(id, include)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Post()
  @ApiOperation({ summary: 'Create ContentStatuses' })
  async createContentStatuses(@Body() data: Prisma.ContentStatusesCreateInput) {
    try {
      return await super.create(data)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Put(':id')
  @ApiOperation({ summary: 'Update ContentStatuses' })
  async updateContentStatuses(
    @Param('id', ParseUUIDPipe) id: string,
    @Body() data: Prisma.ContentStatusesUpdateInput,
  ) {
    try {
      return await super.update(id, data)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Delete(':id')
  @ApiOperation({ summary: 'Delete ContentStatuses' })
  async removeContentStatuses(@Param('id', ParseUUIDPipe) id: string) {
    try {
      return await super.remove(id)
    } catch (error: any) {
      return this.handleError(error)
    }
  }
}

================
File: src/content/controllers/content-tags.controller.ts
================
// controller.ejs template
import {
  Controller,
  Get,
  Post,
  Put,
  Delete,
  Body,
  Param,
  Query,
  ParseUUIDPipe,
} from '@nestjs/common'
import { ApiTags, ApiOperation } from '@nestjs/swagger'
import { PrismaService } from '@core/services/prisma.service'
import { PaginationService } from '@core/services/pagination.service'
import { CustomLogger } from '@core/logger/custom.logger'
import { BaseController } from '@core/base/base.controller'
import { ConfigService } from '@nestjs/config'
import { ContentTagsService } from '../services/content-tags.service'

import type { Prisma } from '@astronera/db'
import type { PaginatedResponse, PaginatedQuery } from '@types'

@Controller('content-tags')
@ApiTags('ContentTags')
export class ContentTagController extends BaseController {
  constructor(
    protected readonly contentTagsService: ContentTagsService,
    protected readonly prisma: PrismaService,
    protected readonly config: ConfigService,
    protected readonly paginationService: PaginationService,
    protected readonly logger: CustomLogger,
  ) {
    super('ContentTags')
  }

  @Get()
  @ApiOperation({ summary: 'Get all ContentTags' })
  async findAllContentTags(
    @Query() query: PaginatedQuery,
  ): Promise<
    PaginatedResponse<unknown> | { success: boolean; error: any; timestamp: string; code: any }
  > {
    try {
      return await super.findAll(query)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Get(':id')
  @ApiOperation({ summary: 'Get ContentTags by id' })
  async findOneContentTags(
    @Param('id', ParseUUIDPipe) id: string,
    @Query('include') include?: string[],
  ) {
    try {
      return await super.findOne(id, include)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Post()
  @ApiOperation({ summary: 'Create ContentTags' })
  async createContentTags(@Body() data: Prisma.ContentTagsCreateInput) {
    try {
      return await super.create(data)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Put(':id')
  @ApiOperation({ summary: 'Update ContentTags' })
  async updateContentTags(
    @Param('id', ParseUUIDPipe) id: string,
    @Body() data: Prisma.ContentTagsUpdateInput,
  ) {
    try {
      return await super.update(id, data)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Delete(':id')
  @ApiOperation({ summary: 'Delete ContentTags' })
  async removeContentTags(@Param('id', ParseUUIDPipe) id: string) {
    try {
      return await super.remove(id)
    } catch (error: any) {
      return this.handleError(error)
    }
  }
}

================
File: src/content/controllers/content.controller.ts
================
// controller.ejs template
import {
  Controller,
  Get,
  Post,
  Put,
  Delete,
  Body,
  Param,
  Query,
  ParseUUIDPipe,
  UseGuards,
  HttpException,
  HttpStatus,
} from '@nestjs/common'
import { ApiTags, ApiOperation } from '@nestjs/swagger'
import { ConfigService } from '@nestjs/config'
import { PrismaService } from '@core/services/prisma.service'
import { PaginationService } from '@core/services/pagination.service'
import { CustomLogger } from '@core/logger/custom.logger'
import { BaseController } from '@core/base/base.controller'
import { PermissionGuard } from '@core/guards/permission.guard'
import { ContentService } from '../services/content.service'
import { ApiBaseController } from '@core/base/base.controller'
import { ApiPaginatedResponse, ApiGetByIdResponse } from '@core/decorators/api.decorator'

import type { Prisma } from '@astronera/db'
import type { PaginatedQuery, PaginatedResponse } from '@types'

const ContentDto = {}

@ApiBaseController('contents')
@UseGuards(PermissionGuard)
export class ContentController extends BaseController {
  constructor(
    protected readonly contentService: ContentService,
    protected readonly prisma: PrismaService,
    protected readonly config: ConfigService,
    protected readonly paginationService: PaginationService,
    protected readonly logger: CustomLogger,
  ) {
    super('Contents')
  }

  @Get()
  @ApiPaginatedResponse(ContentDto)
  @ApiOperation({ summary: 'Get all content with company logos' })
  async getAllContent(@Query() query: PaginatedQuery) {
    try {
      return await this.contentService.getAllContent(query)
    } catch (error: any) {
      throw new HttpException(
        error.message || 'An error occurred',
        error.status || HttpStatus.INTERNAL_SERVER_ERROR,
      )
    }
  }

  @Get(':id')
  @ApiGetByIdResponse(ContentDto)
  @ApiOperation({ summary: 'Get Contents by id' })
  async findOneContents(
    @Param('id', ParseUUIDPipe) id: string,
    @Query('include') include?: string[],
  ) {
    try {
      return await super.findOne(id, include)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Post()
  @ApiOperation({ summary: 'Create Contents' })
  async createContents(@Body() data: Prisma.ContentsCreateInput) {
    try {
      return await super.create(data)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Put(':id')
  @ApiOperation({ summary: 'Update Contents' })
  async updateContents(
    @Param('id', ParseUUIDPipe) id: string,
    @Body() data: Prisma.ContentsUpdateInput,
  ) {
    try {
      return await super.update(id, data)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Delete(':id')
  @ApiOperation({ summary: 'Delete Contents' })
  async removeContents(@Param('id', ParseUUIDPipe) id: string) {
    try {
      return await super.remove(id)
    } catch (error: any) {
      return this.handleError(error)
    }
  }
}

================
File: src/content/controllers/embedding-reviews.controller.ts
================
// controller.ejs template
import {
  Controller,
  Get,
  Post,
  Put,
  Delete,
  Body,
  Param,
  Query,
  ParseUUIDPipe,
} from '@nestjs/common'
import { ApiTags, ApiOperation } from '@nestjs/swagger'
import { ConfigService } from '@nestjs/config'
import { PrismaService } from '@core/services/prisma.service'
import { PaginationService } from '@core/services/pagination.service'
import { CustomLogger } from '@core/logger/custom.logger'
import { BaseController } from '@core/base/base.controller'
import { EmbeddingReviewsService } from '../services/embedding-reviews.service'

import type { PaginatedResponse, PaginatedQuery } from '@types'
import type { Prisma } from '@astronera/db'

@Controller('embedding-reviews')
@ApiTags('EmbeddingReviews')
export class EmbeddingReviewController extends BaseController {
  constructor(
    protected readonly embeddingReviewsService: EmbeddingReviewsService,
    protected readonly prisma: PrismaService,
    protected readonly config: ConfigService,
    protected readonly paginationService: PaginationService,
    protected readonly logger: CustomLogger,
  ) {
    super('EmbeddingReviews')
  }

  @Get()
  @ApiOperation({ summary: 'Get all EmbeddingReviews' })
  async findAllEmbeddingReviews(
    @Query() query: PaginatedQuery,
  ): Promise<
    PaginatedResponse<unknown> | { success: boolean; error: any; timestamp: string; code: any }
  > {
    try {
      return await super.findAll(query)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Get(':id')
  @ApiOperation({ summary: 'Get EmbeddingReviews by id' })
  async findOneEmbeddingReviews(
    @Param('id', ParseUUIDPipe) id: string,
    @Query('include') include?: string[],
  ) {
    try {
      return await super.findOne(id, include)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Post()
  @ApiOperation({ summary: 'Create EmbeddingReviews' })
  async createEmbeddingReviews(@Body() data: Prisma.EmbeddingReviewsCreateInput) {
    try {
      return await super.create(data)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Put(':id')
  @ApiOperation({ summary: 'Update EmbeddingReviews' })
  async updateEmbeddingReviews(
    @Param('id', ParseUUIDPipe) id: string,
    @Body() data: Prisma.EmbeddingReviewsUpdateInput,
  ) {
    try {
      return await super.update(id, data)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Delete(':id')
  @ApiOperation({ summary: 'Delete EmbeddingReviews' })
  async removeEmbeddingReviews(@Param('id', ParseUUIDPipe) id: string) {
    try {
      return await super.remove(id)
    } catch (error: any) {
      return this.handleError(error)
    }
  }
}

================
File: src/content/controllers/feed-categories.controller.ts
================
// controller.ejs template
import {
  Controller,
  Get,
  Post,
  Put,
  Delete,
  Body,
  Param,
  Query,
  ParseUUIDPipe,
} from '@nestjs/common'
import { ApiTags, ApiOperation } from '@nestjs/swagger'
import { ConfigService } from '@nestjs/config'
import { FeedCategoriesService } from '../services/feed-categories.service'
import { PrismaService } from '@core/services/prisma.service'
import { PaginationService } from '@core/services/pagination.service'
import { CustomLogger } from '@core/logger/custom.logger'
import { BaseController } from '@core/base/base.controller'

import type { Prisma } from '@astronera/db'
import type { PaginatedResponse, PaginatedQuery } from '@types'

@Controller('feed-categories')
@ApiTags('FeedCategories')
export class FeedCategoryController extends BaseController {
  constructor(
    protected readonly feedCategoriesService: FeedCategoriesService,
    protected readonly prisma: PrismaService,
    protected readonly config: ConfigService,
    protected readonly paginationService: PaginationService,
    protected readonly logger: CustomLogger,
  ) {
    super('FeedCategories')
  }

  @Get()
  @ApiOperation({ summary: 'Get all FeedCategories' })
  async findAllFeedCategories(
    @Query() query: PaginatedQuery,
  ): Promise<
    PaginatedResponse<unknown> | { success: boolean; error: any; timestamp: string; code: any }
  > {
    try {
      return await super.findAll(query)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Get(':id')
  @ApiOperation({ summary: 'Get FeedCategories by id' })
  async findOneFeedCategories(
    @Param('id', ParseUUIDPipe) id: string,
    @Query('include') include?: string[],
  ) {
    try {
      return await super.findOne(id, include)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Post()
  @ApiOperation({ summary: 'Create FeedCategories' })
  async createFeedCategories(@Body() data: Prisma.FeedCategoriesCreateInput) {
    try {
      return await super.create(data)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Put(':id')
  @ApiOperation({ summary: 'Update FeedCategories' })
  async updateFeedCategories(
    @Param('id', ParseUUIDPipe) id: string,
    @Body() data: Prisma.FeedCategoriesUpdateInput,
  ) {
    try {
      return await super.update(id, data)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Delete(':id')
  @ApiOperation({ summary: 'Delete FeedCategories' })
  async removeFeedCategories(@Param('id', ParseUUIDPipe) id: string) {
    try {
      return await super.remove(id)
    } catch (error: any) {
      return this.handleError(error)
    }
  }
}

================
File: src/content/controllers/feed-sources.controller.ts
================
// controller.ejs template
import {
  Controller,
  Get,
  Post,
  Put,
  Delete,
  Body,
  Param,
  Query,
  ParseUUIDPipe,
} from '@nestjs/common'
import { ApiTags, ApiOperation } from '@nestjs/swagger'
import { ConfigService } from '@nestjs/config'
import { FeedSourceService } from '../services/feed-sources.service'
import { PrismaService } from '@core/services/prisma.service'
import { PaginationService } from '@core/services/pagination.service'
import { CustomLogger } from '@core/logger/custom.logger'
import { BaseController } from '@core/base/base.controller'

import type { Prisma } from '@astronera/db'
import type { PaginatedResponse, PaginatedQuery } from '@types'

@Controller('feed-sources')
@ApiTags('FeedSources')
export class FeedSourceController extends BaseController {
  constructor(
    protected readonly feedSourceService: FeedSourceService,
    protected readonly prisma: PrismaService,
    protected readonly config: ConfigService,
    protected readonly paginationService: PaginationService,
    protected readonly logger: CustomLogger,
  ) {
    super('FeedSources')
  }

  @Get()
  @ApiOperation({ summary: 'Get all FeedSources' })
  async findAllFeedSources(
    @Query() query: PaginatedQuery,
  ): Promise<
    PaginatedResponse<unknown> | { success: boolean; error: any; timestamp: string; code: any }
  > {
    try {
      return await super.findAll(query)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Get(':id')
  @ApiOperation({ summary: 'Get FeedSources by id' })
  async findOneFeedSources(
    @Param('id', ParseUUIDPipe) id: string,
    @Query('include') include?: string[],
  ) {
    try {
      return await super.findOne(id, include)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Post()
  @ApiOperation({ summary: 'Create FeedSources' })
  async createFeedSources(@Body() data: Prisma.FeedSourcesCreateInput) {
    try {
      return await super.create(data)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Put(':id')
  @ApiOperation({ summary: 'Update FeedSources' })
  async updateFeedSources(
    @Param('id', ParseUUIDPipe) id: string,
    @Body() data: Prisma.FeedSourcesUpdateInput,
  ) {
    try {
      return await super.update(id, data)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Delete(':id')
  @ApiOperation({ summary: 'Delete FeedSources' })
  async removeFeedSources(@Param('id', ParseUUIDPipe) id: string) {
    try {
      return await super.remove(id)
    } catch (error: any) {
      return this.handleError(error)
    }
  }
}

================
File: src/content/controllers/feeds.controller.ts
================
// controller.ejs template
import {
  Controller,
  Get,
  Post,
  Put,
  Delete,
  Body,
  Param,
  Query,
  ParseUUIDPipe,
} from '@nestjs/common'
import { ApiTags, ApiOperation } from '@nestjs/swagger'
import { ConfigService } from '@nestjs/config'
import { PrismaService } from '@core/services/prisma.service'
import { PaginationService } from '@core/services/pagination.service'
import { CustomLogger } from '@core/logger/custom.logger'
import { BaseController } from '@core/base/base.controller'
import { FeedsService } from '../services/feeds.service'

import type { Prisma } from '@astronera/db'
import type { PaginatedResponse, PaginatedQuery } from '@types'

@Controller('feeds')
@ApiTags('Feeds')
export class FeedController extends BaseController {
  constructor(
    protected readonly feedsService: FeedsService,
    protected readonly prisma: PrismaService,
    protected readonly config: ConfigService,
    protected readonly paginationService: PaginationService,
    protected readonly logger: CustomLogger,
  ) {
    super('Feeds')
  }

  @Get()
  @ApiOperation({ summary: 'Get all Feeds' })
  async findAllFeeds(
    @Query() query: PaginatedQuery,
  ): Promise<
    PaginatedResponse<unknown> | { success: boolean; error: any; timestamp: string; code: any }
  > {
    try {
      return await super.findAll(query)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Get(':id')
  @ApiOperation({ summary: 'Get Feeds by id' })
  async findOneFeeds(@Param('id', ParseUUIDPipe) id: string, @Query('include') include?: string[]) {
    try {
      return await super.findOne(id, include)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Post()
  @ApiOperation({ summary: 'Create Feeds' })
  async createFeeds(@Body() data: Prisma.FeedsCreateInput) {
    try {
      return await super.create(data)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Put(':id')
  @ApiOperation({ summary: 'Update Feeds' })
  async updateFeeds(@Param('id', ParseUUIDPipe) id: string, @Body() data: Prisma.FeedsUpdateInput) {
    try {
      return await super.update(id, data)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Delete(':id')
  @ApiOperation({ summary: 'Delete Feeds' })
  async removeFeeds(@Param('id', ParseUUIDPipe) id: string) {
    try {
      return await super.remove(id)
    } catch (error: any) {
      return this.handleError(error)
    }
  }
}

================
File: src/content/controllers/news-summaries.controller.ts
================
// controller.ejs template
import {
  Controller,
  Get,
  Post,
  Put,
  Delete,
  Body,
  Param,
  Query,
  ParseUUIDPipe,
} from '@nestjs/common'
import { ApiTags, ApiOperation } from '@nestjs/swagger'
import { NewsSummariesService } from '../services/news-summaries.service'
import { ConfigService } from '@nestjs/config'
import { PrismaService } from '@core/services/prisma.service'
import { PaginationService } from '@core/services/pagination.service'
import { CustomLogger } from '@core/logger/custom.logger'
import { BaseController } from '@core/base/base.controller'

import type { Prisma } from '@astronera/db'
import type { PaginatedResponse, PaginatedQuery } from '@types'

@Controller('news-summaries')
@ApiTags('NewsSummaries')
export class NewsSummaryController extends BaseController {
  constructor(
    protected readonly newsSummariesService: NewsSummariesService,
    protected readonly prisma: PrismaService,
    protected readonly config: ConfigService,
    protected readonly paginationService: PaginationService,
    protected readonly logger: CustomLogger,
  ) {
    super('NewsSummaries')
  }

  @Get()
  @ApiOperation({ summary: 'Get all NewsSummaries' })
  async findAllNewsSummaries(
    @Query() query: PaginatedQuery,
  ): Promise<
    PaginatedResponse<unknown> | { success: boolean; error: any; timestamp: string; code: any }
  > {
    try {
      return await super.findAll(query)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Get(':id')
  @ApiOperation({ summary: 'Get NewsSummaries by id' })
  async findOneNewsSummaries(
    @Param('id', ParseUUIDPipe) id: string,
    @Query('include') include?: string[],
  ) {
    try {
      return await super.findOne(id, include)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Post()
  @ApiOperation({ summary: 'Create NewsSummaries' })
  async createNewsSummaries(@Body() data: Prisma.NewsSummariesCreateInput) {
    try {
      return await super.create(data)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Put(':id')
  @ApiOperation({ summary: 'Update NewsSummaries' })
  async updateNewsSummaries(
    @Param('id', ParseUUIDPipe) id: string,
    @Body() data: Prisma.NewsSummariesUpdateInput,
  ) {
    try {
      return await super.update(id, data)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Delete(':id')
  @ApiOperation({ summary: 'Delete NewsSummaries' })
  async removeNewsSummaries(@Param('id', ParseUUIDPipe) id: string) {
    try {
      return await super.remove(id)
    } catch (error: any) {
      return this.handleError(error)
    }
  }
}

================
File: src/content/controllers/news-tags.controller.ts
================
// controller.ejs template
import {
  Controller,
  Get,
  Post,
  Put,
  Delete,
  Body,
  Param,
  Query,
  ParseUUIDPipe,
} from '@nestjs/common'
import { ApiTags, ApiOperation } from '@nestjs/swagger'
import { NewsTagsService } from '../services/news-tags.service'
import { ConfigService } from '@nestjs/config'
import { PrismaService } from '@core/services/prisma.service'
import { PaginationService } from '@core/services/pagination.service'
import { CustomLogger } from '@core/logger/custom.logger'
import { BaseController } from '@core/base/base.controller'

import type { Prisma } from '@astronera/db'
import type { PaginatedResponse, PaginatedQuery } from '@types'

@Controller('news-tags')
@ApiTags('NewsTags')
export class NewsTagController extends BaseController {
  constructor(
    protected readonly newsTagsService: NewsTagsService,
    protected readonly prisma: PrismaService,
    protected readonly config: ConfigService,
    protected readonly paginationService: PaginationService,
    protected readonly logger: CustomLogger,
  ) {
    super('NewsTags')
  }

  @Get()
  @ApiOperation({ summary: 'Get all NewsTags' })
  async findAllNewsTags(
    @Query() query: PaginatedQuery,
  ): Promise<
    PaginatedResponse<unknown> | { success: boolean; error: any; timestamp: string; code: any }
  > {
    try {
      return await super.findAll(query)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Get(':id')
  @ApiOperation({ summary: 'Get NewsTags by id' })
  async findOneNewsTags(
    @Param('id', ParseUUIDPipe) id: string,
    @Query('include') include?: string[],
  ) {
    try {
      return await super.findOne(id, include)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Post()
  @ApiOperation({ summary: 'Create NewsTags' })
  async createNewsTags(@Body() data: Prisma.NewsTagsCreateInput) {
    try {
      return await super.create(data)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Put(':id')
  @ApiOperation({ summary: 'Update NewsTags' })
  async updateNewsTags(
    @Param('id', ParseUUIDPipe) id: string,
    @Body() data: Prisma.NewsTagsUpdateInput,
  ) {
    try {
      return await super.update(id, data)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Delete(':id')
  @ApiOperation({ summary: 'Delete NewsTags' })
  async removeNewsTags(@Param('id', ParseUUIDPipe) id: string) {
    try {
      return await super.remove(id)
    } catch (error: any) {
      return this.handleError(error)
    }
  }
}

================
File: src/content/controllers/news.controller.ts
================
// controller.ejs template
import {
  Controller,
  Get,
  Post,
  Put,
  Delete,
  Body,
  Param,
  Query,
  ParseUUIDPipe,
} from '@nestjs/common'
import { ApiTags, ApiOperation } from '@nestjs/swagger'
import { NewsService } from '../services/news.service'
import { ConfigService } from '@nestjs/config'
import { PrismaService } from '@core/services/prisma.service'
import { PaginationService } from '@core/services/pagination.service'
import { CustomLogger } from '@core/logger/custom.logger'
import { BaseController } from '@core/base/base.controller'

import type { Prisma } from '@astronera/db'
import type { PaginatedResponse, PaginatedQuery } from '@types'

@Controller('news')
@ApiTags('News')
export class NewsController extends BaseController {
  constructor(
    protected readonly newsService: NewsService,
    protected readonly prisma: PrismaService,
    protected readonly config: ConfigService,
    protected readonly paginationService: PaginationService,
    protected readonly logger: CustomLogger,
  ) {
    super('News')
  }

  @Get()
  @ApiOperation({ summary: 'Get all News' })
  async findAllNews(
    @Query() query: PaginatedQuery,
  ): Promise<
    PaginatedResponse<unknown> | { success: boolean; error: any; timestamp: string; code: any }
  > {
    try {
      return await super.findAll(query)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Get(':id')
  @ApiOperation({ summary: 'Get News by id' })
  async findOneNews(@Param('id', ParseUUIDPipe) id: string, @Query('include') include?: string[]) {
    try {
      return await super.findOne(id, include)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Post()
  @ApiOperation({ summary: 'Create News' })
  async createNews(@Body() data: Prisma.NewsCreateInput) {
    try {
      return await super.create(data)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Put(':id')
  @ApiOperation({ summary: 'Update News' })
  async updateNews(@Param('id', ParseUUIDPipe) id: string, @Body() data: Prisma.NewsUpdateInput) {
    try {
      return await super.update(id, data)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Delete(':id')
  @ApiOperation({ summary: 'Delete News' })
  async removeNews(@Param('id', ParseUUIDPipe) id: string) {
    try {
      return await super.remove(id)
    } catch (error: any) {
      return this.handleError(error)
    }
  }
}

================
File: src/content/controllers/newsletters.controller.ts
================
// controller.ejs template
import {
  Controller,
  Get,
  Post,
  Put,
  Delete,
  Body,
  Param,
  Query,
  ParseUUIDPipe,
} from '@nestjs/common'
import { ApiTags, ApiOperation } from '@nestjs/swagger'
import { ConfigService } from '@nestjs/config'
import { NewslettersService } from '../services/newsletters.service'
import { PrismaService } from '@core/services/prisma.service'
import { PaginationService } from '@core/services/pagination.service'
import { CustomLogger } from '@core/logger/custom.logger'
import { BaseController } from '@core/base/base.controller'

import type { PaginatedResponse, PaginatedQuery } from '@types'
import type { Prisma } from '@astronera/db'

@Controller('newsletters')
@ApiTags('Newsletters')
export class NewsletterController extends BaseController {
  constructor(
    protected readonly newslettersService: NewslettersService,
    protected readonly prisma: PrismaService,
    protected readonly config: ConfigService,
    protected readonly paginationService: PaginationService,
    protected readonly logger: CustomLogger,
  ) {
    super('Newsletters')
  }

  @Get()
  @ApiOperation({ summary: 'Get all Newsletters' })
  async findAllNewsletters(
    @Query() query: PaginatedQuery,
  ): Promise<
    PaginatedResponse<unknown> | { success: boolean; error: any; timestamp: string; code: any }
  > {
    try {
      return await super.findAll(query)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Get(':id')
  @ApiOperation({ summary: 'Get Newsletters by id' })
  async findOneNewsletters(
    @Param('id', ParseUUIDPipe) id: string,
    @Query('include') include?: string[],
  ) {
    try {
      return await super.findOne(id, include)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Post()
  @ApiOperation({ summary: 'Create Newsletters' })
  async createNewsletters(@Body() data: Prisma.NewslettersCreateInput) {
    try {
      return await super.create(data)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Put(':id')
  @ApiOperation({ summary: 'Update Newsletters' })
  async updateNewsletters(
    @Param('id', ParseUUIDPipe) id: string,
    @Body() data: Prisma.NewslettersUpdateInput,
  ) {
    try {
      return await super.update(id, data)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Delete(':id')
  @ApiOperation({ summary: 'Delete Newsletters' })
  async removeNewsletters(@Param('id', ParseUUIDPipe) id: string) {
    try {
      return await super.remove(id)
    } catch (error: any) {
      return this.handleError(error)
    }
  }
}

================
File: src/content/controllers/research-embeddings.controller.ts
================
// controller.ejs template
import {
  Controller,
  Get,
  Post,
  Put,
  Delete,
  Body,
  Param,
  Query,
  ParseUUIDPipe,
} from '@nestjs/common'
import { ApiTags, ApiOperation } from '@nestjs/swagger'
import { ResearchEmbeddingsService } from '../services/research-embeddings.service'
import { ConfigService } from '@nestjs/config'
import { PrismaService } from '@core/services/prisma.service'
import { PaginationService } from '@core/services/pagination.service'
import { CustomLogger } from '@core/logger/custom.logger'
import { BaseController } from '@core/base/base.controller'

import type { Prisma } from '@astronera/db'
import type { PaginatedResponse, PaginatedQuery } from '@types'

@Controller('research-embeddings')
@ApiTags('ResearchEmbeddings')
export class ResearchEmbeddingController extends BaseController {
  constructor(
    protected readonly researchEmbeddingsService: ResearchEmbeddingsService,
    protected readonly prisma: PrismaService,
    protected readonly config: ConfigService,
    protected readonly paginationService: PaginationService,
    protected readonly logger: CustomLogger,
  ) {
    super('ResearchEmbeddings')
  }

  @Get()
  @ApiOperation({ summary: 'Get all ResearchEmbeddings' })
  async findAllResearchEmbeddings(
    @Query() query: PaginatedQuery,
  ): Promise<
    PaginatedResponse<unknown> | { success: boolean; error: any; timestamp: string; code: any }
  > {
    try {
      return await super.findAll(query)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Get(':id')
  @ApiOperation({ summary: 'Get ResearchEmbeddings by id' })
  async findOneResearchEmbeddings(
    @Param('id', ParseUUIDPipe) id: string,
    @Query('include') include?: string[],
  ) {
    try {
      return await super.findOne(id, include)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Post()
  @ApiOperation({ summary: 'Create ResearchEmbeddings' })
  async createResearchEmbeddings(@Body() data: Prisma.ResearchEmbeddingsCreateInput) {
    try {
      return await super.create(data)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Put(':id')
  @ApiOperation({ summary: 'Update ResearchEmbeddings' })
  async updateResearchEmbeddings(
    @Param('id', ParseUUIDPipe) id: string,
    @Body() data: Prisma.ResearchEmbeddingsUpdateInput,
  ) {
    try {
      return await super.update(id, data)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Delete(':id')
  @ApiOperation({ summary: 'Delete ResearchEmbeddings' })
  async removeResearchEmbeddings(@Param('id', ParseUUIDPipe) id: string) {
    try {
      return await super.remove(id)
    } catch (error: any) {
      return this.handleError(error)
    }
  }
}

================
File: src/content/controllers/research.controller.ts
================
// controller.ejs template
import {
  Controller,
  Get,
  Post,
  Put,
  Delete,
  Body,
  Param,
  Query,
  ParseUUIDPipe,
} from '@nestjs/common'
import { ApiTags, ApiOperation } from '@nestjs/swagger'
import { ConfigService } from '@nestjs/config'
import { PrismaService } from '@core/services/prisma.service'
import { PaginationService } from '@core/services/pagination.service'
import { CustomLogger } from '@core/logger/custom.logger'
import { BaseController } from '@core/base/base.controller'
import { ResearchService } from '../services/research.service'

import type { PaginatedResponse, PaginatedQuery } from '@types'
import type { Prisma } from '@astronera/db'

@Controller('research')
@ApiTags('Research')
export class ResearchController extends BaseController {
  constructor(
    protected readonly researchService: ResearchService,
    protected readonly prisma: PrismaService,
    protected readonly config: ConfigService,
    protected readonly paginationService: PaginationService,
    protected readonly logger: CustomLogger,
  ) {
    super('Research')
  }

  @Get()
  @ApiOperation({ summary: 'Get all Research' })
  async findAllResearch(
    @Query() query: PaginatedQuery,
  ): Promise<
    PaginatedResponse<unknown> | { success: boolean; error: any; timestamp: string; code: any }
  > {
    try {
      return await super.findAll(query)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Get(':id')
  @ApiOperation({ summary: 'Get Research by id' })
  async findOneResearch(
    @Param('id', ParseUUIDPipe) id: string,
    @Query('include') include?: string[],
  ) {
    try {
      return await super.findOne(id, include)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Post()
  @ApiOperation({ summary: 'Create Research' })
  async createResearch(@Body() data: Prisma.ResearchCreateInput) {
    try {
      return await super.create(data)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Put(':id')
  @ApiOperation({ summary: 'Update Research' })
  async updateResearch(
    @Param('id', ParseUUIDPipe) id: string,
    @Body() data: Prisma.ResearchUpdateInput,
  ) {
    try {
      return await super.update(id, data)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Delete(':id')
  @ApiOperation({ summary: 'Delete Research' })
  async removeResearch(@Param('id', ParseUUIDPipe) id: string) {
    try {
      return await super.remove(id)
    } catch (error: any) {
      return this.handleError(error)
    }
  }
}

================
File: src/content/controllers/tags.controller.ts
================
// controller.ejs template
import {
  Controller,
  Get,
  Post,
  Put,
  Delete,
  Body,
  Param,
  Query,
  ParseUUIDPipe,
} from '@nestjs/common'
import { ApiTags, ApiOperation } from '@nestjs/swagger'
import { ConfigService } from '@nestjs/config'
import { TagsService } from '../services/tags.service'
import { PrismaService } from '@core/services/prisma.service'
import { PaginationService } from '@core/services/pagination.service'
import { CustomLogger } from '@core/logger/custom.logger'
import { BaseController } from '@core/base/base.controller'

import type { Prisma } from '@astronera/db'
import type { PaginatedResponse, PaginatedQuery } from '@types'

@Controller('tags')
@ApiTags('Tags')
export class TagController extends BaseController {
  constructor(
    protected readonly tagsService: TagsService,
    protected readonly prisma: PrismaService,
    protected readonly config: ConfigService,
    protected readonly paginationService: PaginationService,
    protected readonly logger: CustomLogger,
  ) {
    super('Tags')
  }

  @Get()
  @ApiOperation({ summary: 'Get all Tags' })
  async findAllTags(
    @Query() query: PaginatedQuery,
  ): Promise<
    PaginatedResponse<unknown> | { success: boolean; error: any; timestamp: string; code: any }
  > {
    try {
      return await super.findAll(query)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Get(':id')
  @ApiOperation({ summary: 'Get Tags by id' })
  async findOneTags(@Param('id', ParseUUIDPipe) id: string, @Query('include') include?: string[]) {
    try {
      return await super.findOne(id, include)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Post()
  @ApiOperation({ summary: 'Create Tags' })
  async createTags(@Body() data: Prisma.TagsCreateInput) {
    try {
      return await super.create(data)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Put(':id')
  @ApiOperation({ summary: 'Update Tags' })
  async updateTags(@Param('id', ParseUUIDPipe) id: string, @Body() data: Prisma.TagsUpdateInput) {
    try {
      return await super.update(id, data)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Delete(':id')
  @ApiOperation({ summary: 'Delete Tags' })
  async removeTags(@Param('id', ParseUUIDPipe) id: string) {
    try {
      return await super.remove(id)
    } catch (error: any) {
      return this.handleError(error)
    }
  }
}

================
File: src/content/models/categories.model.ts
================
// templates/entity/model.ejs
import { BaseModel } from '@core'

// Model interface
export interface CategoryModel extends BaseModel {
  id: string
  created_at: Date
  updated_at?: Date
  body?: string
  name: string
  document_id?: string
  locale?: string
  published_at?: string
}

================
File: src/content/models/content-categories.model.ts
================
// templates/entity/model.ejs
import { BaseModel } from '@core'
import { ContentModel, CategoryModel } from '@content'

// Model interface
export interface ContentCategoryModel extends BaseModel {
  content_id: string

  is_primary: boolean
  categories: CategoryModel
  contents: ContentModel
}

================
File: src/content/models/content-source-visits.model.ts
================
// templates/entity/model.ejs
import { BaseModel } from '@core'
import { ContentModel, CategoryModel } from '@content'

// Model interface
export interface ContentSourceVisitsModel extends BaseModel {
  id: string
  content_id: string
  user_id?: string
  created_at?: Date
  contents: ContentModel

  // userProfiles?: UserProfilesModel;
}

================
File: src/content/models/content-sources.model.ts
================
// templates/entity/model.ejs
import type { ContentType, ScrapeFrequency, Priority } from '@astronera/db'
import { BaseModel } from '@core'
import type { CategoryModel } from '@content'

// Model interface
export interface ContentSourceModel extends BaseModel {
  id: string

  url: string

  content_type: ContentType

  scrape_frequency: ScrapeFrequency

  created_at?: Date

  updated_at?: Date

  refreshed_at?: Date

  has_failed?: boolean

  failed_count?: number

  priority: Priority

  hash?: string

  scraped_at?: Date

  expected_count?: number

  company_id?: string

  rss_urls?: string[]

  // companies?: CompaniesModel;

  contentSources?: ContentSourceModel[]

  // socialMedia?: SocialMediaModel[];

  categories?: CategoryModel[]
}

================
File: src/content/models/content-statuses.model.ts
================
// templates/entity/model.ejs
import { BaseModel } from '@core'
import type { ContentStatus } from '@astronera/db'
import { ContentModel, CategoryModel } from '@content'

// Model interface
export interface ContentStatusesModel extends BaseModel {
  id: string
  content_id: string
  notes?: string
  created_at?: Date
  content_status: ContentStatus
  contents: ContentModel
}

================
File: src/content/models/content-tags.model.ts
================
// templates/entity/model.ejs
import { BaseModel } from '@core'
import { ContentModel, CategoryModel, TagModel } from '@content'

// Model interface
export interface ContentTagModel extends BaseModel {
  content_id: string
  tag_id: number
  contents: ContentModel
  tags: TagModel
}

================
File: src/content/models/contents.model.ts
================
// templates/entity/model.ejs
import { BaseModel } from '@core'
import type { ContentType } from '@astronera/db'

// Model interface
export interface ContentModel extends BaseModel {
  id: string
  content_type: ContentType
  title?: string
  created_at?: Date
  updated_at?: Date
  url: string
  rss_url?: string
  hot_score?: number
  contents: ContentModel[]
}

================
File: src/content/models/embedding-reviews.model.ts
================
// templates/entity/model.ejs
import { BaseModel } from '@core'

// Model interface
export interface EmbeddingReviewModel extends BaseModel {
  id: string

  created_at: Date

  updated_at?: Date

  agent_review?: boolean

  human_review?: boolean

  notes?: string

  embeddingReviews?: EmbeddingReviewModel[]
}

================
File: src/content/models/feed-categories.model.ts
================
// templates/entity/model.ejs
import { BaseModel } from '@core'
import { FeedModel, CategoryModel } from '@content'

// import { UserProfilesModel } from "@auth/models/user-profiles.model";

// Model interface
export interface FeedCategoryModel extends BaseModel {
  id: string

  created_at: Date

  feed_id?: string

  category_id?: string
  categories?: CategoryModel
  feeds?: FeedModel

  // user_profiles?: UserProfilesModel[];
}

================
File: src/content/models/feed-sources.model.ts
================
// templates/entity/model.ejs
import { BaseModel } from '@core'

import type { FeedModel } from '@content/models/feeds.model'

import type { ContentSourceModel } from '@content/models/content-sources.model'

// Model interface
export interface FeedSourceModel extends BaseModel {
  id: string

  feed_id?: string

  created_at: Date

  content_source_id?: string

  feeds?: FeedModel

  // companies?: CompaniesModel[];
  // user_profiles?: UserProfilesModel[];

  content_sources?: ContentSourceModel
}

================
File: src/content/models/feeds.model.ts
================
// templates/entity/model.ejs
import { BaseModel } from '@core'
import { Prisma } from '@astronera/db'

// import { UserProfilesModel } from '@auth/models/user-profiles.model';

// Model interface
export interface FeedModel extends BaseModel {
  id: string
  created_at: Date
  name?: string
  user_id?: string
  feeds?: FeedModel[]
}

================
File: src/content/models/news-summaries.model.ts
================
// templates/entity/model.ejs
import { BaseModel } from '@core'
import { ContentModel, CategoryModel, NewsModel, ContentSourceModel } from '@content'

// import { CompaniesModel } from "@org/models/companies.model";

// Model interface
export interface NewsSummaryModel extends BaseModel {
  id: string
  news_id: string

  summary?: string

  embedding?: string

  complexity_level?: string

  version: number

  is_current?: boolean

  created_at?: Date

  updated_at?: Date

  content_sources: ContentSourceModel[]

  news: NewsModel

  categories: CategoryModel[]

  // companies: CompaniesModel[];

  contents: ContentModel[]
}

================
File: src/content/models/news-tags.model.ts
================
// templates/entity/model.ejs
import { BaseModel } from '@core'
import { TagModel } from '@content'

// Model interface
export interface NewsTagModel extends BaseModel {
  id: number
  tag_id: number
  news_id?: string
  tags: TagModel
}

================
File: src/content/models/news.model.ts
================
// templates/entity/model.ejs
import { BaseModel } from '@core'
import type { ScrapeFrequency, ContentStatus } from '@astronera/db'
import type { ContentSourceModel, ContentModel, CategoryModel } from '@content'

// Model interface
export interface NewsModel extends BaseModel {
  created_at: Date

  updated_at: Date
  title?: string
  body?: string
  category_id?: string
  author?: string
  description?: string
  featured_image?: string
  has_summary: boolean
  published_at?: Date
  url: string
  hash?: string
  id: string
  company_id?: string
  failed_count?: number
  scrape_frequency: ScrapeFrequency
  scraped_at?: Date
  content_status: ContentStatus
  keywords?: Record<string, any>
  score?: number
  content_source_id?: string
  content_sources?: ContentSourceModel
  news: NewsModel[]
  categories?: CategoryModel[]
  contents: ContentModel
  // companies?: CompaniesModel[];
  // social_media?: SocialMediaModel[];
}

================
File: src/content/models/newsletters.model.ts
================
// templates/entity/model.ejs
import { BaseModel } from '@core'
import type { ContentStatus } from '@astronera/db'
import { ContentModel, CategoryModel } from '@content'

// Model interface
export interface NewsletterModel extends BaseModel {
  id: string
  title: string
  frequency: string
  start_date: Date
  end_date: Date
  generated_content?: string
  created_at?: Date
  updated_at?: Date
  content_status: ContentStatus
  contents: ContentModel
}

================
File: src/content/models/research-embeddings.model.ts
================
// templates/entity/model.ejs
import { BaseModel } from '@core'
import type { EmbeddingReviewModel } from '@content/models/embedding-reviews.model'
import { ContentModel, CategoryModel } from '@content'
import type { ResearchModel } from '@content/models/research.model'

// Model interface
export interface ResearchEmbeddingModel extends BaseModel {
  id: number

  research_id: string

  chunk: string

  url?: string

  embedding?: string

  created_at?: Date

  is_flagged?: boolean

  updated_at: Date

  embedding_review_id?: string

  embeddingReviews?: EmbeddingReviewModel

  contents: ContentModel[]

  research: ResearchModel
}

================
File: src/content/models/research.model.ts
================
// templates/entity/model.ejs
import { BaseModel } from '@core'
import type { ContentStatus } from '@astronera/db'
import { ContentModel, CategoryModel } from '@content'

// Model interface
export interface ResearchModel extends BaseModel {
  created_at: Date
  updated_at?: Date
  published_at?: Date
  title?: string
  version?: number
  id: string
  abstract?: string
  keywords?: string
  month?: string
  year?: string
  abstract_url: string
  category?: string
  doi_url?: string
  figure_count?: number
  has_embedding?: boolean
  page_count?: number
  pdf_url?: string
  published_in?: string
  table_count?: number
  comments?: string
  is_flagged: boolean
  authors?: Record<string, any>
  summary?: string
  content_status: ContentStatus
  affiliations?: Record<string, any>
  contents: ContentModel
  research: ResearchModel[]
}

================
File: src/content/models/tags.model.ts
================
// templates/entity/model.ejs
import { BaseModel } from '@core'

// Model interface
export interface TagModel extends BaseModel {
  id: number
  body?: string
  name: string
  document_id?: string
  locale?: string
  published_at?: string
  created_at?: Date
  updated_at?: Date
  tags: TagModel[]
}

================
File: src/content/services/categories.service.ts
================
// templates/service/service.ejs
import { Injectable } from '@nestjs/common'
import type { Prisma } from '@astronera/db'
import { BaseService } from '@core/base/base.service'
import { PaginationService } from '@core/services/pagination.service'
import { PrismaService } from '@core/services/prisma.service'
import type { CategoryModel } from '../models/categories.model'

@Injectable()
export class CategoriesService extends BaseService<'Categories'> {
  constructor(
    protected readonly prisma: PrismaService,
    protected readonly paginationService: PaginationService,
  ) {
    super('Categories')
  }

  async findWithRelations(id: number): Promise<CategoryModel | null> {
    const result = await this.prisma.categories.findUnique({
      where: { id },
      include: {
        companies: true,
        content_categories: true,
        feed_categories: true,
        news: true,
      },
    })
    return result ? this.mapToModel(result) : null
  }

  async findMany(params: Prisma.CategoriesDefaultArgs): Promise<CategoryModel[]> {
    const items = await this.prisma.categories.findMany(params)
    return items.map((item) => this.mapToModel(item))
  }

  async findAllCategories(
    query: Prisma.CategoriesFindManyArgs,
  ): Promise<{ items: CategoryModel[]; total: number }> {
    const [items, total] = await Promise.all([
      this.prisma.categories.findMany({
        skip: query.skip,
        take: query.take,
        where: query.where,
        orderBy: query.orderBy,
      }),
      this.prisma.categories.count({ where: query.where }),
    ])

    return {
      items: items.map((item) => this.mapToModel(item)),
      total,
    }
  }

  private mapToModel(data: any): CategoryModel {
    return {
      ...data,
    }
  }
}

================
File: src/content/services/content-categories.service.ts
================
// templates/service/service.ejs
import { Injectable } from '@nestjs/common'
import type { Prisma } from '@astronera/db'
import { PaginationService } from '@core/services/pagination.service'
import { PrismaService } from '@core/services/prisma.service'
import { BaseService } from '@core/base/base.service'
import type { ContentCategoryModel } from '../models/content-categories.model'

@Injectable()
export class ContentCategoriesService extends BaseService<'ContentCategories'> {
  constructor(
    protected readonly prisma: PrismaService,
    protected readonly paginationService: PaginationService,
  ) {
    super('ContentCategories')
  }

  async findWithRelations(id: string, categoryId: number): Promise<ContentCategoryModel | null> {
    const result = await this.prisma.contentCategories.findUnique({
      where: {
        content_id_category_id: {
          content_id: id,
          category_id: categoryId,
        },
      },
      include: {
        categories: true,
        contents: true,
      },
    })
    return result ? this.mapToModel(result) : null
  }

  async findMany(params: Prisma.ContentCategoriesDefaultArgs): Promise<ContentCategoryModel[]> {
    const items = await this.prisma.contentCategories.findMany(params)
    return items.map((item) => this.mapToModel(item))
  }

  async findAllContentCategories(
    query: Prisma.ContentCategoriesFindManyArgs,
  ): Promise<{ items: ContentCategoryModel[]; total: number }> {
    const [items, total] = await Promise.all([
      this.prisma.contentCategories.findMany({
        skip: query.skip,
        take: query.take,
        where: query.where,
        orderBy: query.orderBy,

        include: {
          categories: true,

          contents: true,
        },
      }),
      this.prisma.contentCategories.count({ where: query.where }),
    ])

    return {
      items: items.map((item) => this.mapToModel(item)),
      total,
    }
  }

  private mapToModel(data: any): ContentCategoryModel {
    return {
      ...data,
    }
  }
}

================
File: src/content/services/content-source-visits.service.ts
================
// templates/service/service.ejs
import { Injectable } from '@nestjs/common'
import type { Prisma } from '@astronera/db'
import { BaseService } from '@core/base/base.service'
import { PaginationService } from '@core/services/pagination.service'
import { PrismaService } from '@core/services/prisma.service'
import { ContentSourceVisitsModel } from '../models/content-source-visits.model'

@Injectable()
export class ContentSourceVisitService extends BaseService<'ContentSourceVisits'> {
  constructor(
    protected readonly prisma: PrismaService,
    protected readonly paginationService: PaginationService,
  ) {
    super('ContentSourceVisits')
  }

  async findWithRelations(id: string): Promise<ContentSourceVisitsModel | null> {
    const result = await this.prisma.contentSourceVisits.findUnique({
      where: { id },
      include: {
        contents: true,
        user_profiles: true,
      },
    })
    return result ? this.mapToModel(result) : null
  }

  async findMany(
    params: Prisma.ContentSourceVisitsDefaultArgs,
  ): Promise<ContentSourceVisitsModel[]> {
    const items = await this.prisma.contentSourceVisits.findMany(params)
    return items.map((item) => this.mapToModel(item))
  }

  async findAllContentSourceVisits(
    query: Prisma.ContentSourceVisitsFindManyArgs,
  ): Promise<{ items: ContentSourceVisitsModel[]; total: number }> {
    const [items, total] = await Promise.all([
      this.prisma.contentSourceVisits.findMany({
        skip: query.skip,
        take: query.take,
        where: query.where,
        orderBy: query.orderBy,
      }),
      this.prisma.contentSourceVisits.count({ where: query.where }),
    ])

    return {
      items: items.map((item) => this.mapToModel(item)),
      total,
    }
  }

  private mapToModel(data: any): ContentSourceVisitsModel {
    return {
      ...data,
    }
  }
}

================
File: src/content/services/content-sources.service.ts
================
// templates/service/service.ejs
import { Injectable } from '@nestjs/common'
import { BaseService } from '@core/base/base.service'
import { PaginationService } from '@core/services/pagination.service'
import { PrismaService } from '@core/services/prisma.service'
import { ContentSourceModel } from '../models/content-sources.model'
import { Prisma } from '@astronera/db'

@Injectable()
export class ContentSourcesService extends BaseService<'ContentSources'> {
  constructor(
    protected readonly prisma: PrismaService,
    protected readonly paginationService: PaginationService,
  ) {
    super('ContentSources')
  }

  async findWithRelations(id: number): Promise<ContentSourceModel | null> {
    const result = await this.prisma.contentSources.findUnique({
      where: { id },
      include: {
        companies: true,
        feed_sources: true,
        news: true,
      },
    })
    return result ? this.mapToModel(result) : null
  }

  async findMany(params: Prisma.ContentSourcesDefaultArgs): Promise<ContentSourceModel[]> {
    const items = await this.prisma.contentSources.findMany(params)
    return items.map((item) => this.mapToModel(item))
  }

  async findAllContentSources(
    query: Prisma.ContentSourcesFindManyArgs,
  ): Promise<{ items: ContentSourceModel[]; total: number }> {
    const [items, total] = await Promise.all([
      this.prisma.contentSources.findMany({
        skip: query.skip,
        take: query.take,
        where: query.where,
        orderBy: query.orderBy,
      }),
      this.prisma.contentSources.count({ where: query.where }),
    ])

    return {
      items: items.map((item) => this.mapToModel(item)),
      total,
    }
  }

  private mapToModel(data: any): ContentSourceModel {
    return {
      ...data,
    }
  }
}

================
File: src/content/services/content-statuses.service.ts
================
// templates/service/service.ejs
import { Injectable } from '@nestjs/common'
import { BaseService } from '@core/base/base.service'
import { PaginationService } from '@core/services/pagination.service'
import { PrismaService } from '@core/services/prisma.service'
import { ContentStatusesModel } from '../models/content-statuses.model'
import type { Prisma } from '@astronera/db'

@Injectable()
export class ContentStatusesService extends BaseService<'ContentStatuses'> {
  constructor(
    protected readonly prisma: PrismaService,
    protected readonly paginationService: PaginationService,
  ) {
    super('ContentStatuses')
  }

  async findWithRelations(id: string): Promise<ContentStatusesModel | null> {
    const result = await this.prisma.contentStatuses.findUnique({
      where: { id },
      include: {
        contents: true,
      },
    })
    return result ? this.mapToModel(result) : null
  }

  async findMany(params: Prisma.ContentStatusesDefaultArgs): Promise<ContentStatusesModel[]> {
    const items = await this.prisma.contentStatuses.findMany(params)
    return items.map((item) => this.mapToModel(item))
  }

  async findAllContentStatuses(
    query: Prisma.ContentStatusesFindManyArgs,
  ): Promise<{ items: ContentStatusesModel[]; total: number }> {
    const [items, total] = await Promise.all([
      this.prisma.contentStatuses.findMany({
        skip: query.skip,
        take: query.take,
        where: query.where,
        orderBy: query.orderBy,
      }),
      this.prisma.contentStatuses.count({ where: query.where }),
    ])

    return {
      items: items.map((item) => this.mapToModel(item)),
      total,
    }
  }

  private mapToModel(data: any): ContentStatusesModel {
    return {
      ...data,
    }
  }
}

================
File: src/content/services/content-tags.service.ts
================
// templates/service/service.ejs
import { Injectable } from '@nestjs/common'
import { BaseService } from '@core/base/base.service'
import { PaginationService } from '@core/services/pagination.service'
import { PrismaService } from '@core/services/prisma.service'
import { ContentTagModel } from '../models/content-tags.model'
import type { Prisma } from '@astronera/db'

@Injectable()
export class ContentTagsService extends BaseService<'ContentTags'> {
  constructor(
    protected readonly prisma: PrismaService,
    protected readonly paginationService: PaginationService,
  ) {
    super('ContentTags')
  }

  async findWithRelations(id: string, tagId: number): Promise<ContentTagModel | null> {
    const result = await this.prisma.contentTags.findUnique({
      where: { content_id_tag_id: { content_id: id, tag_id: tagId } },
      include: {
        contents: true,
        tags: true,
      },
    })
    return result ? this.mapToModel(result) : null
  }

  async findMany(params: Prisma.ContentTagsDefaultArgs): Promise<ContentTagModel[]> {
    const items = await this.prisma.contentTags.findMany(params)
    return items.map((item) => this.mapToModel(item))
  }

  async findAllContentTags(
    query: Prisma.ContentTagsFindManyArgs,
  ): Promise<{ items: ContentTagModel[]; total: number }> {
    const [items, total] = await Promise.all([
      this.prisma.contentTags.findMany({
        skip: query.skip,
        take: query.take,
        where: query.where,
        orderBy: query.orderBy,
      }),
      this.prisma.contentTags.count({ where: query.where }),
    ])

    return {
      items: items.map((item) => this.mapToModel(item)),
      total,
    }
  }

  private mapToModel(data: any): ContentTagModel {
    return {
      ...data,
    }
  }
}

================
File: src/content/services/content.service.ts
================
// templates/service/service.ejs
import { Injectable } from '@nestjs/common'
import { BaseService } from '@core/base/base.service'
import { PaginationService } from '@core/services/pagination.service'
import { PrismaService } from '@core/services/prisma.service'
import { ContentModel } from '../models/contents.model'
import type { Prisma } from '@astronera/db'
import type { PaginatedQuery } from '@types'

@Injectable()
export class ContentService extends BaseService<'Contents'> {
  constructor(
    protected readonly prisma: PrismaService,
    protected readonly paginationService: PaginationService,
  ) {
    super('Contents')
  }

  async findWithRelations(id: string): Promise<ContentModel | null> {
    const result = await this.prisma.contents.findUnique({
      where: { id },
      include: {
        bookmarks: true,
        content_statuses: true,
        content_tags: true,
        content_categories: true,
        content_source_visits: true,
        news: true,
        newsletters: true,
        research: true,
      },
    })
    return result ? this.mapToModel(result) : null
  }

  async findMany(params: Prisma.ContentsDefaultArgs): Promise<ContentModel[]> {
    const items = await this.prisma.contents.findMany(params)
    return items.map((item) => this.mapToModel(item))
  }

  async getAllContent(query: PaginatedQuery) {
    const { skip, take } = this.paginationService.getSkipTake(query)

    const [items, total] = await Promise.all([
      this.prisma.contents.findMany({
        where: {
          content_type: 'news',
        },
        skip,
        take,
        select: {
          id: true,
          title: true,
          url: true,
          content_type: true,
          hot_score: true,
          created_at: true,
          updated_at: true,
          // Include related news data
          news: {
            select: {
              description: true,
              featured_image: true,
              author: true,
              published_at: true,
              news_summaries: {
                where: {
                  is_current: true, // Only get current summaries
                },
                select: {
                  summary: true,
                  complexity_level: true,
                  version: true,
                },
              },
              companies: {
                select: {
                  logo_url: true,
                  name: true,
                },
              },
            },
          },
          content_categories: {
            select: {
              is_primary: true,
              categories: {
                select: {
                  name: true,
                },
              },
            },
          },
          content_tags: {
            select: {
              tags: {
                select: {
                  name: true,
                },
              },
            },
          },
        },
        orderBy: {
          created_at: 'desc',
        },
      }),
      this.prisma.contents.count({
        where: {
          content_type: 'news',
        },
      }),
    ])

    const transformedItems = items.map((content) => ({
      id: content.id,
      title: content.title,
      url: content.url,
      type: content.content_type,
      hotScore: content.hot_score,
      createdAt: content.created_at.toISOString(), // Format the date
      updatedAt: content.updated_at.toISOString(), // Format the date
      description: content.news?.description,
      featuredImage: content.news?.featured_image,
      author: content.news?.author,
      publishedAt: content.news?.published_at?.toISOString(), // Format optional date
      summary: content.news?.news_summaries?.[0]?.summary, // Get the current summary
      summaryComplexity: content.news?.news_summaries?.[0]?.complexity_level,
      summaryVersion: content.news?.news_summaries?.[0]?.version,
      companyLogo: content.news?.companies?.logo_url,
      companyName: content.news?.companies?.name,
      categories: content.content_categories.map((cc) => ({
        name: cc.categories.name,
        isPrimary: cc.is_primary,
      })),
      tags: content.content_tags.map((ct) => ct.tags.name),
    }))

    return {
      data: transformedItems,
      meta: this.paginationService.getPaginationMeta(total, query),
      timestamp: new Date().toISOString(),
    }
  }

  private mapToModel(data: any): ContentModel {
    return {
      ...data,
    }
  }
}

================
File: src/content/services/embedding-reviews.service.ts
================
// templates/service/service.ejs
import { Injectable } from '@nestjs/common'
import type { Prisma } from '@astronera/db'
import { BaseService } from '@core/base/base.service'
import { PaginationService } from '@core/services/pagination.service'
import { PrismaService } from '@core/services/prisma.service'
import { EmbeddingReviewModel } from '../models/embedding-reviews.model'

@Injectable()
export class EmbeddingReviewsService extends BaseService<'EmbeddingReviews'> {
  constructor(
    protected readonly prisma: PrismaService,
    protected readonly paginationService: PaginationService,
  ) {
    super('EmbeddingReviews')
  }

  async findWithRelations(id: number): Promise<EmbeddingReviewModel | null> {
    const result = await this.prisma.embeddingReviews.findUnique({
      where: { id },
      include: {
        research_embeddings: true,
      },
    })
    return result ? this.mapToModel(result) : null
  }

  async findMany(params: Prisma.EmbeddingReviewsDefaultArgs): Promise<EmbeddingReviewModel[]> {
    const items = await this.prisma.embeddingReviews.findMany(params)
    return items.map((item) => this.mapToModel(item))
  }

  async findAllEmbeddingReviews(
    query: Prisma.EmbeddingReviewsFindManyArgs,
  ): Promise<{ items: EmbeddingReviewModel[]; total: number }> {
    const [items, total] = await Promise.all([
      this.prisma.embeddingReviews.findMany({
        skip: query.skip,
        take: query.take,
        where: query.where,
        orderBy: query.orderBy,
      }),
      this.prisma.embeddingReviews.count({ where: query.where }),
    ])

    return {
      items: items.map((item) => this.mapToModel(item)),
      total,
    }
  }

  private mapToModel(data: any): EmbeddingReviewModel {
    return {
      ...data,
    }
  }
}

================
File: src/content/services/feed-categories.service.ts
================
import { Injectable } from '@nestjs/common'
import type { Prisma } from '@astronera/db'
import { BaseService } from '@core/base/base.service'
import { PaginationService } from '@core/services/pagination.service'
import { PrismaService } from '@core/services/prisma.service'
import type { FeedCategoryModel } from '../models/feed-categories.model'

@Injectable()
export class FeedCategoriesService extends BaseService<'FeedCategories'> {
  constructor(
    protected readonly prisma: PrismaService,
    protected readonly paginationService: PaginationService,
  ) {
    super('FeedCategories')
  }

  async findWithRelations(id: number): Promise<FeedCategoryModel | null> {
    const result = await this.prisma.feedCategories.findUnique({
      where: { id },
      include: {
        categories: true,
        feeds: true,
      },
    })
    return result ? this.mapToModel(result) : null
  }

  async findMany(params: Prisma.FeedCategoriesDefaultArgs): Promise<FeedCategoryModel[]> {
    const items = await this.prisma.feedCategories.findMany(params)
    return items.map((item) => this.mapToModel(item))
  }

  async findAllFeedCategories(
    query: Prisma.FeedCategoriesFindManyArgs,
  ): Promise<{ items: FeedCategoryModel[]; total: number }> {
    const [items, total] = await Promise.all([
      this.prisma.feedCategories.findMany({
        skip: query.skip,
        take: query.take,
        where: query.where,
        orderBy: query.orderBy,
      }),
      this.prisma.feedCategories.count({ where: query.where }),
    ])

    return {
      items: items.map((item) => this.mapToModel(item)),
      total,
    }
  }

  private mapToModel(data: any): FeedCategoryModel {
    return {
      ...data,
    }
  }
}

================
File: src/content/services/feed-sources.service.ts
================
// templates/service/service.ejs
import { Injectable } from '@nestjs/common'
import type { Prisma } from '@astronera/db'
import { BaseService } from '@core/base/base.service'
import { PaginationService } from '@core/services/pagination.service'
import { PrismaService } from '@core/services/prisma.service'
import type { FeedSourceModel } from '../models/feed-sources.model'

@Injectable()
export class FeedSourceService extends BaseService<'FeedSources'> {
  constructor(
    protected readonly prisma: PrismaService,
    protected readonly paginationService: PaginationService,
  ) {
    super('FeedSources')
  }

  async findWithRelations(id: number): Promise<FeedSourceModel | null> {
    const result = await this.prisma.feedSources.findUnique({
      where: { id },
      include: {
        content_sources: true,
        feeds: true,
      },
    })
    return result ? this.mapToModel(result) : null
  }

  async findMany(params: Prisma.FeedSourcesDefaultArgs): Promise<FeedSourceModel[]> {
    const items = await this.prisma.feedSources.findMany(params)
    return items.map((item) => this.mapToModel(item))
  }

  async findAllFeedSources(
    query: Prisma.FeedSourcesFindManyArgs,
  ): Promise<{ items: FeedSourceModel[]; total: number }> {
    const [items, total] = await Promise.all([
      this.prisma.feedSources.findMany({
        skip: query.skip,
        take: query.take,
        where: query.where,
        orderBy: query.orderBy,
      }),
      this.prisma.feedSources.count({ where: query.where }),
    ])

    return {
      items: items.map((item) => this.mapToModel(item)),
      total,
    }
  }

  private mapToModel(data: any): FeedSourceModel {
    return {
      ...data,
    }
  }
}

================
File: src/content/services/feeds.service.ts
================
// templates/service/service.ejs
import { Injectable } from '@nestjs/common'
import type { Prisma } from '@astronera/db'
import { BaseService } from '@core/base/base.service'
import { PaginationService } from '@core/services/pagination.service'
import { PrismaService } from '@core/services/prisma.service'
import type { FeedModel } from '../models/feeds.model'

@Injectable()
export class FeedsService extends BaseService<'Feeds'> {
  constructor(
    protected readonly prisma: PrismaService,
    protected readonly paginationService: PaginationService,
  ) {
    super('Feeds')
  }

  async findWithRelations(id: string): Promise<FeedModel | null> {
    const result = await this.prisma.feeds.findUnique({
      where: { id },
      include: {
        feed_categories: true,
        feed_sources: true,
        user_profiles: true,
      },
    })
    return result ? this.mapToModel(result) : null
  }

  async findMany(params: Prisma.FeedsDefaultArgs): Promise<FeedModel[]> {
    const items = await this.prisma.feeds.findMany(params)
    return items.map((item) => this.mapToModel(item))
  }

  async findAllFeeds(
    query: Prisma.FeedsFindManyArgs,
  ): Promise<{ items: FeedModel[]; total: number }> {
    const [items, total] = await Promise.all([
      this.prisma.feeds.findMany({
        skip: query.skip,
        take: query.take,
        where: query.where,
        orderBy: query.orderBy,
      }),
      this.prisma.feeds.count({ where: query.where }),
    ])

    return {
      items: items.map((item) => this.mapToModel(item)),
      total,
    }
  }

  private mapToModel(data: any): FeedModel {
    return {
      ...data,
    }
  }
}

================
File: src/content/services/news-summaries.service.ts
================
// templates/service/service.ejs
import { Injectable } from '@nestjs/common'
import type { Prisma } from '@astronera/db'
import { BaseService } from '@core/base/base.service'
import { PaginationService } from '@core/services/pagination.service'
import { PrismaService } from '@core/services/prisma.service'
import { NewsSummaryModel } from '../models/news-summaries.model'

@Injectable()
export class NewsSummariesService extends BaseService<'NewsSummaries'> {
  constructor(
    protected readonly prisma: PrismaService,
    protected readonly paginationService: PaginationService,
  ) {
    super('NewsSummaries')
  }

  async findWithRelations(id: string): Promise<NewsSummaryModel | null> {
    const result = await this.prisma.newsSummaries.findUnique({
      where: { id },
      include: {
        news: true,
      },
    })
    return result ? this.mapToModel(result) : null
  }

  async findMany(params: Prisma.NewsSummariesDefaultArgs): Promise<NewsSummaryModel[]> {
    const items = await this.prisma.newsSummaries.findMany(params)
    return items.map((item) => this.mapToModel(item))
  }

  async findAllNewsSummaries(
    query: Prisma.NewsSummariesFindManyArgs,
  ): Promise<{ items: NewsSummaryModel[]; total: number }> {
    const [items, total] = await Promise.all([
      this.prisma.newsSummaries.findMany({
        skip: query.skip,
        take: query.take,
        where: query.where,
        orderBy: query.orderBy,
      }),
      this.prisma.newsSummaries.count({ where: query.where }),
    ])

    return {
      items: items.map((item) => this.mapToModel(item)),
      total,
    }
  }

  private mapToModel(data: any): NewsSummaryModel {
    return {
      ...data,
    }
  }
}

================
File: src/content/services/news-tags.service.ts
================
// templates/service/service.ejs
import { Injectable } from '@nestjs/common'
import type { Prisma } from '@astronera/db'
import { BaseService } from '@core/base/base.service'
import { PaginationService } from '@core/services/pagination.service'
import { PrismaService } from '@core/services/prisma.service'
import { NewsTagModel } from '../models/news-tags.model'

@Injectable()
export class NewsTagsService extends BaseService<'NewsTags'> {
  constructor(
    protected readonly prisma: PrismaService,
    protected readonly paginationService: PaginationService,
  ) {
    super('NewsTags')
  }

  async findWithRelations(id: number): Promise<NewsTagModel | null> {
    const result = await this.prisma.newsTags.findUnique({
      where: { id },
      include: {
        tags: true,
      },
    })
    return result ? this.mapToModel(result) : null
  }

  async findMany(params: Prisma.NewsTagsDefaultArgs): Promise<NewsTagModel[]> {
    const items = await this.prisma.newsTags.findMany(params)
    return items.map((item) => this.mapToModel(item))
  }

  async findAllNewsTags(
    query: Prisma.NewsTagsFindManyArgs,
  ): Promise<{ items: NewsTagModel[]; total: number }> {
    const [items, total] = await Promise.all([
      this.prisma.newsTags.findMany({
        skip: query.skip,
        take: query.take,
        where: query.where,
        orderBy: query.orderBy,
      }),
      this.prisma.newsTags.count({ where: query.where }),
    ])

    return {
      items: items.map((item) => this.mapToModel(item)),
      total,
    }
  }

  private mapToModel(data: any): NewsTagModel {
    return {
      ...data,
    }
  }
}

================
File: src/content/services/news.service.ts
================
// templates/service/service.ejs
import { Injectable } from '@nestjs/common'
import type { Prisma } from '@astronera/db'
import { BaseService } from '@core/base/base.service'
import { PaginationService } from '@core/services/pagination.service'
import { PrismaService } from '@core/services/prisma.service'
import { NewsModel } from '../models/news.model'

@Injectable()
export class NewsService extends BaseService<'News'> {
  constructor(
    protected readonly prisma: PrismaService,
    protected readonly paginationService: PaginationService,
  ) {
    super('News')
  }

  async findWithRelations(id: string): Promise<NewsModel | null> {
    const result = await this.prisma.news.findUnique({
      where: { id },
      include: {
        companies: true,
        categories: true,
        content_sources: true,
        contents: true,
        news_summaries: true,
      },
    })
    return result ? this.mapToModel(result) : null
  }

  async findMany(params: Prisma.NewsDefaultArgs): Promise<NewsModel[]> {
    const items = await this.prisma.news.findMany(params)
    return items.map((item) => this.mapToModel(item))
  }

  async findAllNews(
    query: Prisma.NewsFindManyArgs,
  ): Promise<{ items: NewsModel[]; total: number }> {
    const [items, total] = await Promise.all([
      this.prisma.news.findMany({
        skip: query.skip,
        take: query.take,
        where: query.where,
        orderBy: query.orderBy,
      }),
      this.prisma.news.count({ where: query.where }),
    ])

    return {
      items: items.map((item) => this.mapToModel(item)),
      total,
    }
  }

  private mapToModel(data: any): NewsModel {
    return {
      ...data,
    }
  }
}

================
File: src/content/services/newsletters.service.ts
================
// templates/service/service.ejs
import { Injectable } from '@nestjs/common'
import type { Prisma } from '@astronera/db'
import { BaseService } from '@core/base/base.service'
import { PaginationService } from '@core/services/pagination.service'
import { PrismaService } from '@core/services/prisma.service'
import { NewsletterModel } from '../models/newsletters.model'

@Injectable()
export class NewslettersService extends BaseService<'Newsletters'> {
  constructor(
    protected readonly prisma: PrismaService,
    protected readonly paginationService: PaginationService,
  ) {
    super('Newsletters')
  }

  async findWithRelations(id: string): Promise<NewsletterModel | null> {
    const result = await this.prisma.newsletters.findUnique({
      where: { id },
      include: {
        contents: true,
      },
    })
    return result ? this.mapToModel(result) : null
  }

  async findMany(params: Prisma.NewslettersDefaultArgs): Promise<NewsletterModel[]> {
    const items = await this.prisma.newsletters.findMany(params)
    return items.map((item) => this.mapToModel(item))
  }

  async findAllNewsletters(
    query: Prisma.NewslettersFindManyArgs,
  ): Promise<{ items: NewsletterModel[]; total: number }> {
    const [items, total] = await Promise.all([
      this.prisma.newsletters.findMany({
        skip: query.skip,
        take: query.take,
        where: query.where,
        orderBy: query.orderBy,
      }),
      this.prisma.newsletters.count({ where: query.where }),
    ])

    return {
      items: items.map((item) => this.mapToModel(item)),
      total,
    }
  }

  private mapToModel(data: any): NewsletterModel {
    return {
      ...data,
    }
  }
}

================
File: src/content/services/research-embeddings.service.ts
================
// templates/service/service.ejs
import { Injectable } from '@nestjs/common'
import type { Prisma } from '@astronera/db'
import { BaseService } from '@core/base/base.service'
import { PaginationService } from '@core/services/pagination.service'
import { PrismaService } from '@core/services/prisma.service'
import { ResearchEmbeddingModel } from '../models/research-embeddings.model'

@Injectable()
export class ResearchEmbeddingsService extends BaseService<'ResearchEmbeddings'> {
  constructor(
    protected readonly prisma: PrismaService,
    protected readonly paginationService: PaginationService,
  ) {
    super('ResearchEmbeddings')
  }

  async findWithRelations(id: number): Promise<ResearchEmbeddingModel | null> {
    const result = await this.prisma.researchEmbeddings.findUnique({
      where: { id },
      include: {
        embedding_reviews: true,
        research: true,
      },
    })
    return result ? this.mapToModel(result) : null
  }

  async findMany(params: Prisma.ResearchEmbeddingsFindManyArgs): Promise<ResearchEmbeddingModel[]> {
    const items = await this.prisma.researchEmbeddings.findMany(params)
    return items.map((item) => this.mapToModel(item))
  }

  async findAllResearchEmbeddings(
    query: Prisma.ResearchEmbeddingsFindManyArgs,
  ): Promise<{ items: ResearchEmbeddingModel[]; total: number }> {
    const [items, total] = await Promise.all([
      this.prisma.researchEmbeddings.findMany({
        skip: query.skip,
        take: query.take,
        where: query.where,
        orderBy: query.orderBy,
      }),
      this.prisma.researchEmbeddings.count({ where: query.where }),
    ])

    return {
      items: items.map((item) => this.mapToModel(item)),
      total,
    }
  }

  private mapToModel(data: any): ResearchEmbeddingModel {
    return {
      ...data,
    }
  }
}

================
File: src/content/services/research.service.ts
================
// templates/service/service.ejs
import { Injectable } from '@nestjs/common'
import type { Prisma } from '@astronera/db'
import { BaseService } from '@core/base/base.service'
import { PaginationService } from '@core/services/pagination.service'
import { PrismaService } from '@core/services/prisma.service'
import { ResearchModel } from '../models/research.model'

@Injectable()
export class ResearchService extends BaseService<'Research'> {
  constructor(
    protected readonly prisma: PrismaService,
    protected readonly paginationService: PaginationService,
  ) {
    super('Research')
  }

  async findWithRelations(id: string): Promise<ResearchModel | null> {
    const result = await this.prisma.research.findUnique({
      where: { id },
      include: {
        contents: true,
        research_embeddings: true,
      },
    })
    return result ? this.mapToModel(result) : null
  }

  async findMany(params: Prisma.ResearchDefaultArgs): Promise<ResearchModel[]> {
    const items = await this.prisma.research.findMany(params)
    return items.map((item) => this.mapToModel(item))
  }

  async findAllResearch(
    query: Prisma.ResearchFindManyArgs,
  ): Promise<{ items: ResearchModel[]; total: number }> {
    const [items, total] = await Promise.all([
      this.prisma.research.findMany({
        skip: query.skip,
        take: query.take,
        where: query.where,
        orderBy: query.orderBy,
      }),
      this.prisma.research.count({ where: query.where }),
    ])

    return {
      items: items.map((item) => this.mapToModel(item)),
      total,
    }
  }

  private mapToModel(data: any): ResearchModel {
    return {
      ...data,
    }
  }
}

================
File: src/content/services/tags.service.ts
================
// templates/service/service.ejs
import { Injectable } from '@nestjs/common'
import type { Prisma } from '@astronera/db'
import { BaseService } from '@core/base/base.service'
import { PaginationService } from '@core/services/pagination.service'
import { PrismaService } from '@core/services/prisma.service'
import { TagModel } from '../models/tags.model'

@Injectable()
export class TagsService extends BaseService<'Tags'> {
  constructor(
    protected readonly prisma: PrismaService,
    protected readonly paginationService: PaginationService,
  ) {
    super('Tags')
  }

  async findWithRelations(id: number): Promise<TagModel | null> {
    const result = await this.prisma.tags.findUnique({
      where: { id },
      include: {
        content_tags: true,
        news_tags: true,
      },
    })
    return result ? this.mapToModel(result) : null
  }

  async findMany(params: Prisma.TagsDefaultArgs): Promise<TagModel[]> {
    const items = await this.prisma.tags.findMany(params)
    return items.map((item) => this.mapToModel(item))
  }

  async findAllTags(query: Prisma.TagsFindManyArgs): Promise<{ items: TagModel[]; total: number }> {
    const [items, total] = await Promise.all([
      this.prisma.tags.findMany({
        skip: query.skip,
        take: query.take,
        where: query.where,
        orderBy: query.orderBy,
      }),
      this.prisma.tags.count({ where: query.where }),
    ])

    return {
      items: items.map((item) => this.mapToModel(item)),
      total,
    }
  }

  private mapToModel(data: any): TagModel {
    return {
      ...data,
    }
  }
}

================
File: src/content/content.module.ts
================
// templates/module/content.module.ejs
import { Module } from '@nestjs/common'
import { CoreModule } from '@core/core.module'
import { PrismaModule } from '@core/modules/prisma.module'
import { PermissionModule } from '@core/modules/permission.module'
import { createDomainModule } from '@core/config/domain-config'
// Controllers
import { ResearchEmbeddingController } from '@content/controllers/research-embeddings.controller'
import { EmbeddingReviewController } from '@content/controllers/embedding-reviews.controller'
import { ContentCategoryController } from '@content/controllers/content-categories.controller'
import { ContentTagController } from '@content/controllers/content-tags.controller'
import { ContentStatusController } from '@content/controllers/content-statuses.controller'
import { NewsletterController } from '@content/controllers/newsletters.controller'
import { ResearchController } from '@content/controllers/research.controller'
import { CategoryController } from '@content/controllers/categories.controller'
import { FeedCategoryController } from '@content/controllers/feed-categories.controller'
import { FeedController } from '@content/controllers/feeds.controller'
import { ContentSourceController } from '@content/controllers/content-sources.controller'
import { TagController } from '@content/controllers/tags.controller'
import { NewsController } from '@content/controllers/news.controller'
import { NewsTagController } from '@content/controllers/news-tags.controller'
import { ContentSourceVisitController } from '@content/controllers/content-source-visits.controller'
import { FeedSourceController } from '@content/controllers/feed-sources.controller'
import { ContentController } from '@content/controllers/content.controller'
import { NewsSummaryController } from '@content/controllers/news-summaries.controller'

// Services
import { ResearchEmbeddingsService } from '@content/services/research-embeddings.service'
import { EmbeddingReviewsService } from '@content/services/embedding-reviews.service'
import { ContentCategoriesService } from '@content/services/content-categories.service'
import { ContentTagsService } from '@content/services/content-tags.service'
import { ContentStatusesService } from '@content/services/content-statuses.service'
import { NewslettersService } from '@content/services/newsletters.service'
import { ResearchService } from '@content/services/research.service'
import { CategoriesService } from '@content/services/categories.service'
import { FeedCategoriesService } from '@content/services/feed-categories.service'
import { FeedsService } from '@content/services/feeds.service'
import { ContentSourcesService } from '@content/services/content-sources.service'
import { TagsService } from '@content/services/tags.service'
import { NewsService } from '@content/services/news.service'
import { NewsTagsService } from '@content/services/news-tags.service'
import { ContentSourceVisitService } from '@content/services/content-source-visits.service'
import { FeedSourceService } from '@content/services/feed-sources.service'
import { ContentService } from '@content/services/content.service'
import { NewsSummariesService } from '@content/services/news-summaries.service'

@Module({
  imports: [
    PrismaModule,
    PermissionModule,
    CoreModule,
    createDomainModule('content', {
      requiresAuth: true,
      requiresCompany: false,
    }),
  ],
  controllers: [
    ResearchEmbeddingController,
    EmbeddingReviewController,
    ContentCategoryController,
    ContentTagController,
    ContentStatusController,
    NewsletterController,
    ResearchController,
    CategoryController,
    FeedCategoryController,
    FeedController,
    ContentSourceController,
    TagController,
    NewsController,
    NewsTagController,
    ContentSourceVisitController,
    FeedSourceController,
    ContentController,
    NewsSummaryController,
  ],
  providers: [
    EmbeddingReviewsService,
    ResearchEmbeddingsService,
    ContentCategoriesService,
    ContentTagsService,
    ContentStatusesService,
    NewslettersService,
    ResearchService,
    CategoriesService,
    FeedCategoriesService,
    FeedsService,
    ContentSourcesService,
    TagsService,
    NewsService,
    NewsTagsService,
    ContentSourceVisitService,
    FeedSourceService,
    ContentService,
    NewsSummariesService,
  ],
  exports: [
    ResearchEmbeddingsService,
    EmbeddingReviewsService,
    ContentCategoriesService,
    ContentTagsService,
    ContentStatusesService,
    NewslettersService,
    ResearchService,
    CategoriesService,
    FeedCategoriesService,
    FeedsService,
    ContentSourcesService,
    TagsService,
    NewsService,
    NewsTagsService,
    ContentSourceVisitService,
    FeedSourceService,
    ContentService,
    NewsSummariesService,
  ],
})
export class ContentModule {}

================
File: src/content/index.ts
================
/**
 * @file Auto-generated barrel file
 * @generated
 */

export * from './models/categories.model'
export * from './models/content-categories.model'
export * from './models/content-source-visits.model'
export * from './models/content-sources.model'
export * from './models/content-statuses.model'
export * from './models/content-tags.model'
export * from './models/contents.model'
export * from './models/embedding-reviews.model'
export * from './models/feed-categories.model'
export * from './models/feed-sources.model'
export * from './models/feeds.model'
export * from './models/news-summaries.model'
export * from './models/news-tags.model'
export * from './models/news.model'
export * from './models/newsletters.model'
export * from './models/research-embeddings.model'
export * from './models/research.model'
export * from './models/tags.model'

================
File: src/core/__tests__/permission.guard.test.ts
================
// test/permission.guard.spec.ts
import { Test } from '@nestjs/testing'
import type { ExecutionContext } from '@nestjs/common'
import { ConfigService } from '@nestjs/config'
import { Reflector } from '@nestjs/core'
import { vi, describe, it, expect, beforeEach } from 'vitest'
import { PermissionGuard } from '../guards/permission.guard'
import { PermissionService } from '../services/permission.service'
import { CustomLogger } from '../logger/custom.logger'

describe('PermissionGuard', () => {
  let guard: PermissionGuard
  let permissionService: PermissionService
  let configService: ConfigService
  let logger: CustomLogger
  let reflector: Reflector

  beforeEach(async () => {
    const mockPermissionService = {
      validateToken: vi.fn(),
      validatePermission: vi.fn(),
    }

    const mockConfigService = {
      get: vi.fn((key: string) => {
        switch (key) {
          case 'SUPABASE_URL':
            return 'https://example.supabase.co'
          case 'SUPABASE_ANON_KEY':
            return 'test-key'
          case 'JWT_SECRET':
            return 'test-secret'
          default:
            return undefined
        }
      }),
    }

    const mockLogger = {
      setContext: vi.fn(),
      log: vi.fn(),
      error: vi.fn(),
      warn: vi.fn(),
      debug: vi.fn(),
    }

    const mockReflector = {
      get: vi.fn(),
      getAllAndOverride: vi.fn(),
      getAllAndMerge: vi.fn(),
    }

    const module = await Test.createTestingModule({
      providers: [
        PermissionGuard,
        {
          provide: PermissionService,
          useValue: mockPermissionService,
        },
        {
          provide: ConfigService,
          useValue: mockConfigService,
        },
        {
          provide: CustomLogger,
          useValue: mockLogger,
        },
        {
          provide: Reflector,
          useValue: mockReflector,
        },
      ],
    }).compile()

    guard = module.get<PermissionGuard>(PermissionGuard)
    permissionService = module.get<PermissionService>(PermissionService)
    configService = module.get<ConfigService>(ConfigService)
    logger = module.get<CustomLogger>(CustomLogger)
    reflector = module.get<Reflector>(Reflector)
  })

  describe('Route Access Control', () => {
    it('should allow access when no permissions are required', async () => {
      const context = createMockExecutionContext()
      reflector.get.mockReturnValue(null)

      const result = await guard.canActivate(context)
      expect(result).toBe(true)
    })

    it('should allow access for valid token and permissions', async () => {
      const context = createMockExecutionContext({
        headers: { authorization: 'Bearer valid-token' },
      })

      reflector.get.mockImplementation((key: string) => {
        switch (key) {
          case 'table':
            return 'contents'
          case 'action':
            return 'select'
          default:
            return null
        }
      })

      vi.spyOn(permissionService, 'validateToken').mockResolvedValue({
        user: { id: 'user-123' },
        role: 'user',
      })

      vi.spyOn(permissionService, 'validatePermission').mockResolvedValue(true)

      const result = await guard.canActivate(context)
      expect(result).toBe(true)
    })

    it('should deny access when permission is not granted', async () => {
      const context = createMockExecutionContext({
        headers: { authorization: 'Bearer valid-token' },
      })

      reflector.get.mockImplementation((key: string) => {
        switch (key) {
          case 'table':
            return 'contents'
          case 'action':
            return 'write'
          default:
            return null
        }
      })

      vi.spyOn(permissionService, 'validateToken').mockResolvedValue({
        user: { id: 'user-123' },
        role: 'user',
      })

      vi.spyOn(permissionService, 'validatePermission').mockResolvedValue(false)

      const result = await guard.canActivate(context)
      expect(result).toBe(false)
    })

    it('should handle missing authorization header', async () => {
      const context = createMockExecutionContext()

      reflector.get.mockImplementation((key: string) => {
        switch (key) {
          case 'table':
            return 'contents'
          case 'action':
            return 'select'
          default:
            return null
        }
      })

      const result = await guard.canActivate(context)
      expect(result).toBe(false)
    })

    it('should handle invalid authorization format', async () => {
      const context = createMockExecutionContext({
        headers: { authorization: 'InvalidFormat' },
      })

      reflector.get.mockImplementation((key: string) => {
        switch (key) {
          case 'table':
            return 'contents'
          case 'action':
            return 'select'
          default:
            return null
        }
      })

      const result = await guard.canActivate(context)
      expect(result).toBe(false)
    })

    it('should handle token validation errors', async () => {
      const context = createMockExecutionContext({
        headers: { authorization: 'Bearer invalid-token' },
      })

      reflector.get.mockImplementation((key: string) => {
        switch (key) {
          case 'table':
            return 'contents'
          case 'action':
            return 'select'
          default:
            return null
        }
      })

      vi.spyOn(permissionService, 'validateToken').mockRejectedValue(new Error('Invalid token'))

      const result = await guard.canActivate(context)
      expect(result).toBe(false)
    })
  })
})

function createMockExecutionContext(
  options: {
    headers?: Record<string, string>
  } = {},
) {
  const context: ExecutionContext = {
    switchToHttp: () => ({
      getRequest: () => ({
        headers: options.headers || {},
      }),
    }),
    getHandler: () => ({}),
    getClass: () => ({}),
    getType: () => 'http',
    getArgs: () => [],
    getArgByIndex: () => ({}),
  }

  return context
}

================
File: src/core/__tests__/permission.service.test.ts
================
// test/permission.service.spec.ts
import { Test } from '@nestjs/testing'
import { ConfigService } from '@nestjs/config'
import { vi, describe, it, expect, beforeEach } from 'vitest'
import { PermissionService } from '../services/permission.service'
import { CustomLogger } from '../logger/custom.logger'

// Mock Supabase client
vi.mock('@supabase/supabase-js', () => ({
  createClient: vi.fn(() => ({
    auth: {
      getUser: vi.fn(),
    },
    from: vi.fn(() => ({
      select: vi.fn(),
    })),
  })),
}))

describe('PermissionService', () => {
  let service: PermissionService
  let configService: ConfigService
  let logger: CustomLogger

  beforeEach(async () => {
    const mockConfigService = {
      get: vi.fn((key: string) => {
        switch (key) {
          case 'SUPABASE_URL':
            return 'https://example.supabase.co'
          case 'SUPABASE_ANON_KEY':
            return 'test-key'
          case 'JWT_SECRET':
            return 'test-secret'
          default:
            return undefined
        }
      }),
    }

    const mockLogger = {
      setContext: vi.fn(),
      log: vi.fn(),
      error: vi.fn(),
      warn: vi.fn(),
      debug: vi.fn(),
    }

    const module = await Test.createTestingModule({
      providers: [
        PermissionService,
        {
          provide: ConfigService,
          useValue: mockConfigService,
        },
        {
          provide: CustomLogger,
          useValue: mockLogger,
        },
      ],
    }).compile()

    service = module.get<PermissionService>(PermissionService)
    configService = module.get<ConfigService>(ConfigService)
    logger = module.get<CustomLogger>(CustomLogger)
  })

  describe('Module Initialization', () => {
    it('should successfully load role hierarchy on initialization', async () => {
      const mockRoleHierarchy = {
        admin: ['user'],
        user: [],
      }

      vi.spyOn(service['supabase'].from('role_hierarchy'), 'select').mockResolvedValue({
        data: mockRoleHierarchy,
        error: null,
      })

      await service.onModuleInit()

      expect(service['roleHierarchy']).toEqual(mockRoleHierarchy)
    })

    it('should handle empty role hierarchy gracefully', async () => {
      vi.spyOn(service['supabase'].from('role_hierarchy'), 'select').mockResolvedValue({
        data: null,
        error: null,
        count: 0,
        status: 200,
        statusText: 'OK',
      })

      await service.onModuleInit()

      expect(service['roleHierarchy']).toEqual({})
    })
  })

  describe('Token Validation', () => {
    it('should successfully validate and return token payload for valid token', async () => {
      const mockPayload = {
        user: { id: 'user-123' },
        role: 'user',
      }

      vi.spyOn(service['supabase'].auth, 'getUser').mockResolvedValue({
        data: { user: mockPayload.user },
        error: null,
      })

      const result = await service.validateToken('valid-token')

      expect(result).toEqual(mockPayload)
    })

    it('should throw error for invalid token', async () => {
      vi.spyOn(service['supabase'].auth, 'getUser').mockResolvedValue({
        data: { user: null },
        error: {
          status: 400,
          code: 'invalid_token',
          message: 'Invalid token',
          name: 'Invalid',
          __isAuthError: true,
        },
      })

      await expect(service.validateToken('invalid-token')).rejects.toThrow('Invalid token')
    })

    it('should handle missing user data in valid token', async () => {
      vi.spyOn(service['supabase'].auth, 'getUser').mockResolvedValue({
        data: { user: null },
        error: null,
      })

      await expect(service.validateToken('valid-token')).rejects.toThrow('User data not found')
    })
  })

  describe('Permission Validation', () => {
    it('should validate permission successfully for allowed action', async () => {
      const mockPermissions = {
        data: [
          {
            table: 'contents',
            action: 'read',
            conditions: null,
          },
        ],
        error: null,
      }

      vi.spyOn(service['supabase'].from('role_permissions'), 'select').mockResolvedValue(
        mockPermissions,
      )

      const result = await service.validatePermission('user', 'contents', 'select', 'user-123')

      expect(result).toBe(true)
    })

    it('should deny access for unauthorized action', async () => {
      vi.spyOn(service['supabase'].from('role_permissions'), 'select').mockResolvedValue({
        data: [],
        error: null,
        count: 0,
        status: 200,
        statusText: 'OK',
      })

      const result = await service.validatePermission('user', 'contents', 'insert', 'user-123')

      expect(result).toBe(false)
    })

    it('should evaluate conditions successfully when userId matches', async () => {
      const mockPermissions = {
        data: [
          {
            table: 'contents',
            action: 'write',
            conditions: { user_id: 'user-123' },
          },
        ],
        error: null,
      }

      vi.spyOn(service['supabase'].from('role_permissions'), 'select').mockResolvedValue(
        mockPermissions,
      )

      const result = await service.validatePermission('user', 'contents', 'insert', 'user-123')

      expect(result).toBe(true)
    })

    it('should handle missing permissions data gracefully', async () => {
      vi.spyOn(service['supabase'].from('role_permissions'), 'select').mockResolvedValue({
        count: undefined,
        data: null,
        status: 200,
        statusText: 'OK',
        error: null,
      })

      const result = await service.validatePermission('user', 'contents', 'insert', 'user-123')

      expect(result).toBe(false)
    })

    it('should handle invalid table or action gracefully', async () => {
      vi.spyOn(service['supabase'].from('role_permissions'), 'select').mockResolvedValue({
        data: null,
        error: {
          code: '400',
          stack: '...',
          message: 'Invalid table or action',
          details: 'Table not found',
          hint: '',
          name: '',
        },
        count: undefined,
        status: 400,
        statusText: 'Bad Request',
      })

      const result = await service.validatePermission('user', 'invalid_table', 'select', 'user-123')

      expect(result).toBe(false)
    })
  })
})

================
File: src/core/base/base.controller.ts
================
// base.controller.ts

import {
  Injectable,
  UnauthorizedException,
  NotFoundException,
  HttpException,
  InternalServerErrorException,
  BadRequestException,
  ConflictException,
  Inject,
  Scope,
  applyDecorators,
} from '@nestjs/common'
import { REQUEST } from '@nestjs/core'
import { Request, Response } from 'express'
import { verify } from 'jsonwebtoken'
import { ConfigService } from '@nestjs/config'
import { Prisma } from '@astronera/db'
import { PrismaService } from '../services/prisma.service'
import { PaginationService } from '../services/pagination.service'
import { CustomLogger } from '../logger/custom.logger'
import type { PaginatedResponse, PaginatedQuery } from '@types'
import { ApiTags, ApiSecurity } from '@nestjs/swagger'
import { Controller } from '@nestjs/common'

export function ApiBaseController(name: string) {
  return applyDecorators(Controller(name), ApiTags(name), ApiSecurity('bearer'))
}

@ApiBaseController('base')
@Injectable({ scope: Scope.REQUEST })
export abstract class BaseController {
  @Inject(REQUEST)
  private readonly request: any

  constructor(protected readonly modelName: keyof Prisma.TypeMap['model']) {}

  protected abstract get prisma(): PrismaService
  protected abstract get config(): ConfigService
  protected abstract get paginationService(): PaginationService
  protected abstract get logger(): CustomLogger

  protected get model(): any {
    return this.prisma[this.modelName]
  }

  async findAll(query: PaginatedQuery) {
    try {
      const { page = 1, limit = 10, include, ...filters } = query
      const includes = include?.reduce((acc, rel) => ({ ...acc, [rel]: true }), {})

      const [items, total] = await Promise.all([
        this.model.findMany({
          where: filters,
          include: includes,
          skip: (Number(page) - 1) * Number(limit),
          take: Number(limit),
        }),
        this.model.count({ where: filters }),
      ])

      return this.handlePaginatedSuccess(
        items,
        this.paginationService.getPaginationMeta(total, query),
      )
    } catch (error: any) {
      throw this.handleError(error)
    }
  }

  async findOne(id: string, include?: string[]) {
    try {
      const includes = include?.reduce((acc, rel) => ({ ...acc, [rel]: true }), {})
      const data = await this.model.findUnique({
        where: { id },
        include: includes,
      })
      if (!data) {
        throw new NotFoundException(`${String(this.modelName)} not found`)
      }
      return this.handleSuccess(data)
    } catch (error: any) {
      throw this.handleError(error)
    }
  }

  async create(data: unknown) {
    try {
      const result = await this.model.create({ data })
      return this.handleSuccess(result)
    } catch (error: any) {
      throw this.handleError(error)
    }
  }

  async update(id: string, data: unknown) {
    try {
      const result = await this.model.update({
        where: { id },
        data,
      })
      return this.handleSuccess(result)
    } catch (error: any) {
      throw this.handleError(error)
    }
  }

  async remove(id: string) {
    try {
      const existing = await this.model.findUnique({ where: { id } })
      if (!existing) {
        throw new NotFoundException(`${String(this.modelName)} not found`)
      }
      await this.model.delete({ where: { id } })
      return this.handleSuccess(existing)
    } catch (error: any) {
      throw this.handleError(error)
    }
  }

  protected handleSuccess<T>(data: T): Partial<Response<T>> {
    const debug = this.config.get('app.debug')
    const response: any = { data }

    if (debug && this.request?.permissions) {
      response.debug = {
        permissions: this.request.permissions,
        timestamp: new Date().toISOString(),
      }
    }

    return response
  }

  protected handlePaginatedSuccess<T>(data: T[], meta: any): PaginatedResponse<T> {
    const debug = this.config.get('app.debug')

    const response: PaginatedResponse<T> = {
      data,
      meta,
      timestamp: new Date().toISOString(),
      success: true,
    }

    if (debug && this.request?.permissions) {
      response.debug = {
        permissions: this.request.permissions,
        timestamp: new Date().toISOString(),
      }
    }

    return response
  }

  protected handleError(error: any): never {
    this.logger.error('Error:', error)

    if (error instanceof HttpException) {
      throw error
    }

    if (error instanceof Prisma.PrismaClientKnownRequestError) {
      switch (error.code) {
        case 'P2002':
          throw new ConflictException(`Duplicate entry on ${String(this.modelName)}`)
        case 'P2003':
          throw new BadRequestException(`Referenced record not found on ${String(this.modelName)}`)
        case 'P2021':
          throw new NotFoundException(`Table not found for ${String(this.modelName)}`)
        case 'P2025':
          throw new NotFoundException(`${String(this.modelName)} not found`)
        case 'P2010':
          throw new BadRequestException(`Invalid query on ${String(this.modelName)}`)
        default:
          throw new InternalServerErrorException(`Database error on ${String(this.modelName)}`)
      }
    }

    if (error instanceof Prisma.PrismaClientValidationError) {
      throw new BadRequestException(`Validation error on ${String(this.modelName)}`)
    }

    throw new InternalServerErrorException(error.message || 'An unexpected error occurred')
  }
}

================
File: src/core/base/base.dto.ts
================
// core/base/base.dto.ts
import { ApiProperty } from '@nestjs/swagger'

export class BaseEntityDto {
  @ApiProperty({ format: 'uuid' })
  id: string

  @ApiProperty()
  createdAt: Date

  @ApiProperty()
  updatedAt: Date
}

================
File: src/core/base/base.gateway.ts
================
// core/base/base.gateway.ts
import {
  OnGatewayConnection,
  OnGatewayDisconnect,
  SubscribeMessage,
  WebSocketServer,
  WebSocketGateway,
} from '@nestjs/websockets'
import { Injectable } from '@nestjs/common'
import { Server, Socket } from 'socket.io'
import { CustomLogger } from '@core/logger/custom.logger'

@Injectable()
@WebSocketGateway()
export abstract class BaseGateway implements OnGatewayConnection, OnGatewayDisconnect {
  @WebSocketServer() server: Server
  protected readonly logger = new CustomLogger(BaseGateway.name)
  protected readonly connectedClients = new Map<string, Socket>()

  afterInit(server: Server) {
    this.logger.log('Base Gateway initialized')
  }

  handleConnection(client: Socket) {
    console.log(`Client connected: ${client.id}`)
    this.connectedClients.set(client.id, client)
    this.logger.log(`Client connected: ${client.id}`)
  }

  handleDisconnect(client: Socket) {
    this.connectedClients.delete(client.id)
    this.logger.log(`Client disconnected: ${client.id}`)
  }

  // Optionally define common message handlers if needed
  @SubscribeMessage('ping')
  handlePing(client: Socket): string {
    return 'pong'
  }
}

================
File: src/core/base/base.model.ts
================
// templates/entity/base.model.ejs
export interface BaseModel {
  id: string | number
  created_at?: Date
  updated_at?: Date

  deleted_at?: Date
}

================
File: src/core/base/base.service.ts
================
// core/services/base.service.ts
import { Injectable } from '@nestjs/common'
import { Prisma } from '@astronera/db'
import type { PaginationService } from '../services/pagination.service'

@Injectable()
export abstract class BaseService<ModelName extends Prisma.ModelName> {
  constructor(protected readonly modelName: ModelName) {}

  protected handleError(error: any): never {
    console.error('Database operation failed:', error)

    if (error instanceof Prisma.PrismaClientKnownRequestError) {
      switch (error.code) {
        case 'P2002':
          throw new Error(`Duplicate entry on ${this.modelName}: ${error.message}`)
        case 'P2003':
          throw new Error(`Referenced record not found on ${this.modelName}: ${error.message}`)
        case 'P2021':
          throw new Error(`Table not found for ${this.modelName}: ${error.message}`)
        case 'P2025':
          throw new Error(`Record not found on ${this.modelName}: ${error.message}`)
        case 'P2010':
          throw new Error(`Invalid query on ${this.modelName}: ${error.message}`)
        default:
          throw new Error(`Database error on ${this.modelName}: ${error.message}`)
      }
    }

    if (error instanceof Prisma.PrismaClientValidationError) {
      throw new Error(`Validation error on ${this.modelName}: ${error.message}`)
    }

    if (error.code) {
      switch (error.code) {
        case '23505':
          throw new Error(`Duplicate entry on ${this.modelName}: ${error.message}`)
        case '23503':
          throw new Error(`Referenced record not found on ${this.modelName}: ${error.message}`)
        case '42P01':
          throw new Error(`Table not found for ${this.modelName}: ${error.message}`)
        case '42703':
          throw new Error(`Column not found on ${this.modelName}: ${error.message}`)
      }
    }

    throw new Error(`An unexpected error occurred on ${this.modelName}: ${error.message}`)
  }

  protected async executeQuery<R>(
    operation: () => Promise<R | { data: R | null; error: any }>,
  ): Promise<R> {
    try {
      const result = await operation()
      return result as R
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  protected async executePrismaQuery<R>(operation: () => Promise<R>): Promise<R> {
    try {
      return await operation()
    } catch (error: any) {
      return this.handleError(error)
    }
  }
}

================
File: src/core/cache/cache.mock.ts
================
// cache.mock.ts
export class MockCacheService {
  private store = new Map<string, { value: string; expiry?: number }>()

  async get<T>(key: string): Promise<T | null> {
    const item = this.store.get(key)
    if (!item) return null

    if (item.expiry && item.expiry < Date.now()) {
      this.store.delete(key)
      return null
    }

    return JSON.parse(item.value) as T
  }

  async set<T>(key: string, value: T, ttlSeconds?: number): Promise<void> {
    const expiry = ttlSeconds ? Date.now() + ttlSeconds * 1000 : undefined
    this.store.set(key, {
      value: JSON.stringify(value),
      expiry,
    })
  }

  async del(key: string): Promise<void> {
    this.store.delete(key)
  }

  async flushPrefix(prefix: string): Promise<void> {
    for (const key of this.store.keys()) {
      if (key.startsWith(prefix)) {
        this.store.delete(key)
      }
    }
  }

  async getAllKeys(prefix: string): Promise<Array<{ key: string; value: any }>> {
    const result = []
    for (const [key, item] of this.store.entries()) {
      if (key.startsWith(prefix)) {
        result.push({
          key,
          value: JSON.parse(item.value),
        })
      }
    }
    return result
  }
}

================
File: src/core/cache/cache.module.ts
================
// redis.module.ts
import { Module, Global, OnApplicationShutdown, Inject } from '@nestjs/common'
import { ConfigService, ConfigModule } from '@nestjs/config'
import { Redis } from 'ioredis'
import IORedis from 'ioredis'
import { MockCacheService } from './cache.mock'

@Global()
@Module({
  imports: [ConfigModule],
  providers: [
    // 2) Redis client for cache/metrics
    {
      provide: 'REDIS_CACHE',
      useFactory: (config: ConfigService) => {
        // if (process.env.NODE_ENV === 'development') {
        //   return new MockCacheService()
        // }

        return new IORedis({
          host: config.get<string>('app.redis.host') || 'redis.railway.internal',
          port: config.get<number>('app.redis.port') || 6379,
          password: config.get<string>('app.redis.password'),
          username: config.get<string>('app.redis.username'),
          family: 0,
        })
      },
      inject: [ConfigService],
    },
  ],
  exports: ['REDIS_CACHE'],
})

export class RedisModule implements OnApplicationShutdown {
  constructor(@Inject('REDIS_CACHE') private cacheClient: Redis) {}

  async onApplicationShutdown() {
    // Alternative place to close connections if desired
    await Promise.all([this.cacheClient.quit()])
  }
}

================
File: src/core/config/configuration.ts
================
// config/configuration.ts
import { registerAs } from '@nestjs/config'

export default registerAs('app', () => ({
  debug: process.env.APP_DEBUG === 'true',
  supabase: {
    anon_key: process.env.SUPABASE_ANON_KEY,
    url: process.env.SUPABASE_URL,
    jwt_secret: process.env.SUPABASE_JWT_SECRET,
  },
  redis: {
    host: process.env.REDIS_HOST || 'localhost',
    port: parseInt(process.env.REDIS_PORT, 10) || 6379,
    password: process.env.REDIS_PASSWORD,
    username: process.env.REDIS_USER,
  },
  environment: process.env.NODE_ENV || 'development',
  api_cors_origins: process.env.API_CORS_ORIGINS || '*',
  api_port: parseInt(process.env.API_PORT, 10) || 3030,
  database: {
    url: process.env.DATABASE_URL,
    host: process.env.DATABASE_HOST,
    port: parseInt(process.env.DATABASE_PORT, 10) || 5432,
    username: process.env.DATABASE_USER,
    password: process.env.DATABASE_PASSWORD,
    database: process.env.DATABASE_NAME,
  },
  razorpay: {
    key_id: process.env.RAZORPAY_TEST_KEY,
    key_secret: process.env.RAZORPAY_TEST_SECRET,
  },
  jwt: {
    secret: process.env.JWT_SECRET,
    expiresIn: process.env.JWT_EXPIRES_IN || '1d',
  },
}))

================
File: src/core/config/domain-config.ts
================
// core/config/domain-config.ts
import { createCentralizedLogger, Service, DomainsForService } from '@ib/logger'
import { DynamicModule, MiddlewareConsumer, Module, NestModule } from '@nestjs/common'
import { CustomLogger } from '@core/logger/custom.logger'

// Define the options interface
export interface DomainModuleOptions {
  requiresAuth?: boolean
  requiresCompany?: boolean
  // Add other options as needed
}

export function createDomainModule(
  domainName: DomainsForService<Service.API>,
  options: DomainModuleOptions,
): DynamicModule {
  @Module({})
  class DomainModule {}

  return {
    module: DomainModule,
    providers: [
      {
        provide: CustomLogger,
        useFactory: () => {
          const logger = new CustomLogger()
          logger.setDomain(domainName)
          return logger
        },
      },
    ],
    exports: [CustomLogger],
    global: false,
  }
}

================
File: src/core/decorators/api.decorator.ts
================
// core/decorators/api.decorators.ts
import { applyDecorators } from '@nestjs/common'
import { ApiOperation, ApiResponse, ApiQuery } from '@nestjs/swagger'

export function ApiPaginatedResponse(type: any) {
  return applyDecorators(
    ApiOperation({ summary: 'Get paginated list' }),
    ApiQuery({ name: 'page', required: false, type: Number }),
    ApiQuery({ name: 'limit', required: false, type: Number }),
    ApiResponse({
      status: 200,
      description: 'Successful operation',
      type: type,
      isArray: true,
    }),
  )
}

export function ApiGetByIdResponse(type: any) {
  return applyDecorators(
    ApiOperation({ summary: 'Get by ID' }),
    ApiResponse({
      status: 200,
      description: 'Found',
      type: type,
    }),
    ApiResponse({ status: 404, description: 'Not found' }),
  )
}

================
File: src/core/decorators/current-user.decorator.ts
================
// decorators/current-user.decorator.ejs
import { ExecutionContext } from '@nestjs/common'
import { createParamDecorator } from '@nestjs/common'

export const CurrentUser = createParamDecorator((data: unknown, ctx: ExecutionContext) => {
  const request = ctx.switchToHttp().getRequest()
  return request.user
})

================
File: src/core/decorators/permission.decorator.ts
================
// decorators/permission.decorator.ts
import { SetMetadata } from '@nestjs/common'
import type { DatabaseAction } from '@types'

export const Table = (table: string) => SetMetadata('table', table)
export const Action = (action: DatabaseAction) => SetMetadata('action', action)

================
File: src/core/decorators/plan.decorator.ts
================
// decorators/plan.decorator.ejs
import { SetMetadata } from '@nestjs/common'

export const PLAN_KEY = 'plan'
export const RequirePlan = (...plans: string[]) => SetMetadata(PLAN_KEY, plans)

================
File: src/core/decorators/public.decorator.ts
================
// src/core/decorators/public.decorator.ts
import { SetMetadata } from '@nestjs/common'

export const IS_PUBLIC_KEY = 'isPublic'
export const Public = () => SetMetadata(IS_PUBLIC_KEY, true)

================
File: src/core/decorators/roles.decorator.ts
================
// decorators/roles.decorator.ejs
import { SetMetadata } from '@nestjs/common'

export const ROLES_KEY = 'roles'
export const Roles = (...roles: string[]) => SetMetadata(ROLES_KEY, roles)

================
File: src/core/decorators/service.decorator.ts
================
// src/core/decorators/service.decorator.ts
import { SetMetadata, applyDecorators, UseGuards } from '@nestjs/common'
import { ApiKeyGuard } from '@core/guards/api-key.guard'

export const IS_SERVICE_KEY = 'isService'
export const Service = () =>
  applyDecorators(SetMetadata(IS_SERVICE_KEY, true), UseGuards(ApiKeyGuard))

================
File: src/core/decorators/validate.decorator.ts
================
// decorators/validate.decorator.ejs
import { ValidationOptions, ValidationArguments } from 'class-validator'
import { registerDecorator } from 'class-validator'

export function IsCustomValue(property: string, validationOptions?: ValidationOptions) {
  return function (object: object, propertyName: string) {
    registerDecorator({
      name: 'isCustomValue',
      target: object.constructor,
      propertyName: propertyName,
      constraints: [property],
      options: validationOptions,
      validator: {
        validate(value: any, args: ValidationArguments) {
          const [relatedPropertyName] = args.constraints
          const relatedValue = (args.object as any)[relatedPropertyName]
          return typeof value === 'string' && typeof relatedValue === 'string'
        },
      },
    })
  }
}

================
File: src/core/dto/pagination.dto.ts
================
import { IsOptional, IsNumber, IsString } from 'class-validator'
import { Type } from 'class-transformer'

export class PaginationParams {
  @IsOptional()
  @IsNumber()
  @Type(() => Number)
  page?: number = 1

  @IsOptional()
  @IsNumber()
  @Type(() => Number)
  limit?: number = 10

  @IsOptional()
  @IsString()
  sort?: string

  @IsOptional()
  @IsString()
  search?: string

  @IsOptional()
  @IsString()
  order?: string

  @IsOptional()
  @IsString()
  include?: Record<string, boolean>
}

================
File: src/core/filters/http-exception.filter.ts
================
// filters/http-exception.filter.ts
import { ExceptionFilter, ArgumentsHost } from '@nestjs/common'
import { Catch, HttpException } from '@nestjs/common'
import { Response } from 'express'
import { CustomLogger } from '@core/logger/custom.logger'

@Catch(HttpException)
export class HttpExceptionFilter implements ExceptionFilter {
  constructor(private logger: CustomLogger) {
    this.logger.setDomain('filter')
  }

  catch(exception: HttpException, host: ArgumentsHost) {
    const ctx = host.switchToHttp()
    const response = ctx.getResponse<Response>()
    const status = exception.getStatus()
    const exceptionResponse = exception.getResponse()

    this.logger.error(`HTTP Exception: ${exception.message}`, exception.stack)

    response.status(status).json({
      success: false,
      timestamp: new Date().toISOString(),
      error: exceptionResponse,
      statusCode: status,
    })
  }
}

================
File: src/core/guards/api-key.guard.ts
================
import { Injectable, CanActivate, ExecutionContext, ForbiddenException } from '@nestjs/common'

@Injectable()
export class ApiKeyGuard implements CanActivate {
  canActivate(context: ExecutionContext): boolean {
    const request = context.switchToHttp().getRequest()
    const apiKey = request.headers['authorization']?.split(' ')[1] // Extract Bearer token

    console.log('Request:', request.headers)
    console.log('headers array:', request.headers['authorization']?.split)
    console.log('API Key:', apiKey, 'Expected:', process.env.API_SECRET_KEY)

    if (apiKey !== process.env.API_SECRET_KEY) {
      throw new ForbiddenException('Invalid API Key')
    }
    return true
  }
}

================
File: src/core/guards/permission.guard.ts
================
// guards/permission.guard.ts
import { CanActivate, ExecutionContext } from '@nestjs/common'
import { Injectable, UnauthorizedException } from '@nestjs/common'
import { Reflector } from '@nestjs/core'
import { CustomLogger } from '@core/logger/custom.logger'
import { IS_PUBLIC_KEY } from '@core/decorators/public.decorator'
import { IS_SERVICE_KEY } from '@core/decorators/service.decorator'
import { PermissionService } from '../services/permission.service'
import { DebugService } from '../services/debug.service'

@Injectable()
export class PermissionGuard implements CanActivate {
  constructor(
    private readonly permissionService: PermissionService,
    private readonly logger: CustomLogger,
    private readonly reflector: Reflector,
    private readonly debugService: DebugService,
  ) {
    this.logger.setDomain('permissions')
  }

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const request = context.switchToHttp().getRequest()

    const isPublic = this.reflector.getAllAndOverride<boolean>(IS_PUBLIC_KEY, [
      context.getHandler(),
      context.getClass(),
    ])

    const isService = this.reflector.getAllAndOverride<boolean>(IS_SERVICE_KEY, [
      context.getHandler(),
      context.getClass(),
    ])

    this.attachDebugInfo(request, context, isPublic, isService)

    if (isPublic) {
      return true
    }

    if (isService) {
      return true
    }

    const token = this.extractToken(request)
    if (!token) {
      this.logger.warn('No token found in request')
      throw new UnauthorizedException('No authorization token found')
    }

    try {
      const userData = await this.permissionService.validateToken(token)
      request.user = userData

      this.attachUserDebugInfo(request, userData)
      return true
    } catch (error: any) {
      this.logger.error('Permission check failed', error.stack)
      throw new UnauthorizedException('Invalid token')
    }
  }

  private attachDebugInfo(
    request: any,
    context: ExecutionContext,
    isPublic: boolean,
    isService: boolean,
  ) {
    this.debugService.attachPermissionDebugInfo(request, {
      isPublic,
      isService,
      endpoint: `${request.method} ${request.path}`,
      handler: context.getHandler().name,
      controller: context.getClass().name,
    })
  }

  private async attachUserDebugInfo(request: any, userData: any) {
    this.debugService.attachPermissionDebugInfo(request, {
      user: {
        role: userData.role,
        email: userData.email,
      },
      roleHierarchy: await this.permissionService.getRoleHierarchy(userData.role),
    })
  }

  private extractToken(request: any): string | null {
    const authHeader = request.headers.authorization
    return authHeader ? authHeader.replace('Bearer ', '') : null
  }
}

================
File: src/core/guards/plan.guard.ts
================
// guards/plan.guard.ejs
import { CanActivate, ExecutionContext } from '@nestjs/common'
import { CustomLogger } from '@core/logger/custom.logger'
import { Injectable } from '@nestjs/common'
import { Reflector } from '@nestjs/core'
import { PLAN_KEY } from '../decorators/plan.decorator'
import { PrismaService } from '../services/prisma.service'

@Injectable()
export class PlanGuard implements CanActivate {
  logger = new CustomLogger('plan-guard')
  constructor(
    private reflector: Reflector,
    private prisma: PrismaService,
  ) {}

  // guards/plan.guard.ts
  async canActivate(context: ExecutionContext): Promise<boolean> {
    const requiredPlans = this.reflector.getAllAndOverride<string[]>(PLAN_KEY, [
      context.getHandler(),
      context.getClass(),
    ])

    if (!requiredPlans) {
      this.logger.debug('No plan requirements for this route')
      return true
    }

    const { user } = context.switchToHttp().getRequest()
    if (!user) {
      this.logger.warn('No user found in request')
      return false
    }

    this.logger.debug('Checking user subscription', {
      userId: user.id,
      requiredPlans,
    })

    const userSubscription = await this.prisma.customerSubscriptions.findFirst({
      where: {
        user_id: user.id,
        status: 'ACTIVE',
      },
      include: {
        customer_subscription_plans: {
          select: {
            name: true,
          },
        },
      },
    })

    this.logger.debug('Found subscription status', {
      hasActiveSubscription: !!userSubscription,
      planName: userSubscription?.customer_subscription_plans?.name,
    })

    const hasRequiredPlan = requiredPlans.includes(
      userSubscription?.customer_subscription_plans?.name,
    )

    return hasRequiredPlan
  }
}

================
File: src/core/guards/throttler.guard.ts
================
// core/guards/throttler.guard.ts
import { ExecutionContext } from '@nestjs/common'
import { Injectable, SetMetadata } from '@nestjs/common'
import { Reflector } from '@nestjs/core'
import { type ThrottlerModuleOptions, ThrottlerRequest, ThrottlerStorage } from '@nestjs/throttler'
import { ThrottlerGuard } from '@nestjs/throttler'
import { CustomLogger } from '@core/logger/custom.logger'

// Decorator to skip throttling for specific routes
export const SkipThrottle = () => SetMetadata('skipThrottle', true)

// Decorator to set custom limits for specific routes
export const Throttle = (limit: number, ttl: number) => SetMetadata('throttle', { limit, ttl })

@Injectable()
export class CustomThrottlerGuard extends ThrottlerGuard {
  private readonly logger: CustomLogger

  constructor(
    options: ThrottlerModuleOptions,
    storageService: ThrottlerStorage,
    reflector: Reflector,
  ) {
    super(options, storageService, reflector)
    this.logger = new CustomLogger('ThrottlerGuard')
  }

  protected async getTracker(req: Record<string, any>): Promise<string> {
    // You can customize the tracking key based on your needs
    // Default is IP address
    const ip = req.ip
    const userAgent = req.headers['user-agent'] || 'unknown'

    return `${ip}-${userAgent}`
  }

  protected getKeyForRoute(context: ExecutionContext): string {
    const req = context.switchToHttp().getRequest()
    return `${req.method}-${req.url}`
  }

  protected async handleRequest(input: ThrottlerRequest): Promise<boolean> {
    // Check if route should skip throttling
    const skipThrottle = this.reflector.get<boolean>('skipThrottle', input.context.getHandler())
    if (skipThrottle) {
      return true
    }

    // Get custom limits if set
    const customLimits = this.reflector.get<{ limit: number; ttl: number }>(
      'throttle',
      input.context.getHandler(),
    )

    if (customLimits) {
      input.limit = customLimits.limit
      input.ttl = customLimits.ttl
    }

    const tracker = await this.getTracker(input.context.switchToHttp().getRequest())
    const key = this.getKeyForRoute(input.context)
    const record = await this.storageService.increment(
      `${key}-${tracker}`,
      input.ttl,
      input.limit,
      input.blockDuration,
      input.throttler.name ?? 'throttler',
    )

    this.logger.debug(`Request ${key} from ${tracker}: ${record.totalHits}/${input.limit}`)

    if (record.totalHits > input.limit) {
      this.logger.warn(
        `Request ${key} from ${tracker} exceeded limit: ${record.totalHits}/${input.limit}`,
      )
      return false
    }

    return true
  }
}

================
File: src/core/interceptors/bigint.interceptor.ts
================
// interceptors/bigint-serialization.interceptor.ts
import { NestInterceptor, ExecutionContext, CallHandler } from '@nestjs/common'
import { Injectable } from '@nestjs/common'
import { Observable } from 'rxjs'
import { map } from 'rxjs/operators'

@Injectable()
export class BigIntSerializationInterceptor implements NestInterceptor {
  private transformValue(value: any): any {
    if (typeof value === 'bigint') {
      return value.toString()
    }

    if (Array.isArray(value)) {
      return value.map((item) => this.transformValue(item))
    }

    if (typeof value === 'object' && value !== null) {
      return Object.fromEntries(
        Object.entries(value).map(([key, val]) => [key, this.transformValue(val)]),
      )
    }

    return value
  }

  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    return next.handle().pipe(map((data) => this.transformValue(data)))
  }
}

================
File: src/core/interceptors/logging.interceptor.ts
================
// interceptors/logging.interceptor.ts
import type { NestInterceptor, ExecutionContext, CallHandler } from '@nestjs/common'
import { Injectable } from '@nestjs/common'
import { Observable } from 'rxjs'
import { tap } from 'rxjs/operators'
import { CustomLogger } from '@core/logger/custom.logger'

@Injectable()
export class LoggingInterceptor implements NestInterceptor {
  constructor(private logger: CustomLogger) {
    this.logger.setDomain('logging')
  }

  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    const request = context.switchToHttp().getRequest()
    const method = request.method
    const url = request.url
    const now = Date.now()

    return next.handle().pipe(
      tap(() => {
        this.logger.log(`${method} ${url} took ${Date.now() - now}ms`)
      }),
    )
  }
}

================
File: src/core/interceptors/pagination.interceptor.ts
================
// templates/core/interceptors/pagination.interceptor.ejs
import { NestInterceptor, ExecutionContext, CallHandler } from '@nestjs/common'
import { Injectable } from '@nestjs/common'
import { Observable } from 'rxjs'
import { map } from 'rxjs/operators'
import type { PaginatedResponse } from '@types'

@Injectable()
export class PaginationInterceptor<T> implements NestInterceptor<T, PaginatedResponse<T>> {
  intercept(context: ExecutionContext, next: CallHandler): Observable<PaginatedResponse<T>> {
    return next.handle().pipe(
      map((data) => {
        // If data is already paginated, return as is
        if (this.isPaginated(data)) {
          return data
        }

        // Get pagination params from request query
        const request = context.switchToHttp().getRequest()
        const { page = 1, limit = 10 } = request.query

        // If data is an array, paginate it
        if (Array.isArray(data)) {
          const total = data.length
          const totalPages = Math.ceil(total / limit)
          const start = (page - 1) * limit
          const end = start + limit

          return {
            data: data.slice(start, end),
            meta: {
              total,
              page: Number(page),
              limit: Number(limit),
              totalPages,
              hasNextPage: end < total,
              hasPreviousPage: start > 0,
            },
            success: true,
            timestamp: new Date().toISOString(),
          }
        }

        // If not an array, wrap in paginated response
        return {
          data: [data],
          meta: {
            total: 1,
            page: 1,
            limit: 1,
            totalPages: 1,
            hasNextPage: false,
            hasPreviousPage: false,
          },
          success: true,
          timestamp: new Date().toISOString(),
        }
      }),
    )
  }

  private isPaginated(data: any): data is PaginatedResponse<T> {
    return (
      data &&
      'data' in data &&
      'meta' in data &&
      'total' in data.meta &&
      'page' in data.meta &&
      'limit' in data.meta &&
      'totalPages' in data.meta
    )
  }
}

================
File: src/core/logger/custom.logger.ts
================
// custom.logger.ts
import { ConsoleLogger, LoggerService } from '@nestjs/common'
import { createCentralizedLogger, Service, DomainsForService } from '@ib/logger'

export class CustomLogger extends ConsoleLogger implements LoggerService {
  private centralLogger = createCentralizedLogger<Service>()

  constructor(context?: string) {
    super(context)
    // Optionally set the service & domain here or in your Modules
    this.centralLogger.setServiceName(Service.API)
    this.centralLogger.setDomain('logging')
  }

  // Override log calls
  log(message: string, context?: any) {
    super.log(message, context)
    void this.centralLogger.info(message, context)
  }

  error(message: string, context?: any) {
    super.error(message, context)
    void this.centralLogger.error(message, context)
  }

  warn(message: string, context?: any) {
    super.warn(message, context)
    void this.centralLogger.warn(message, context)
  }

  debug(message: string, context?: any) {
    super.debug(message, context)
    void this.centralLogger.debug(message, context)
  }

  verbose(message: string, context?: any) {
    super.verbose(message, context)
    void this.centralLogger.verbose(message, context)
  }

  setDomain(domain: DomainsForService<Service.API>) {
    this.centralLogger.setDomain(domain)
  }
}

================
File: src/core/logger/logger.colors.ts
================
export const LoggerColors = {
  auth: '\x1b[35m', // Magenta
  content: '\x1b[36m', // Cyan
  location: '\x1b[32m', // Green
  security: '\x1b[31m', // Red
  search: '\x1b[33m', // Yellow
  payments: '\x1b[34m', // Blue
  advertising: '\x1b[95m', // Bright Magenta
  core: '\x1b[90m', // Gray
  default: '\x1b[37m', // White
  reset: '\x1b[0m', // Reset
} as const

================
File: src/core/modules/logger.module.ts
================
import { Global, Module } from '@nestjs/common'
import { CustomLogger } from '../logger/custom.logger'

@Global()
@Module({
  providers: [
    {
      provide: CustomLogger,
      useValue: new CustomLogger(),
    },
  ],
  exports: [CustomLogger],
})
export class LoggerModule {}

================
File: src/core/modules/permission.module.ts
================
// permission.module.ts
import { Global, Module } from '@nestjs/common'
import { ConfigModule } from '@nestjs/config'
import { APP_GUARD, Reflector } from '@nestjs/core'
import { CustomLogger } from '@core/logger/custom.logger'
import { PermissionService } from '../services/permission.service'
import { PermissionGuard } from '../guards/permission.guard'
import { PrismaModule } from '../modules/prisma.module'
import { DebugService } from '../services/debug.service'

@Global()
@Module({
  imports: [ConfigModule, PrismaModule],
  providers: [
    PermissionService,
    Reflector,
    {
      provide: CustomLogger,
      useFactory: () => new CustomLogger('Permission'),
    },
    {
      provide: APP_GUARD,
      useFactory: (
        permissionService: PermissionService,
        logger: CustomLogger,
        reflector: Reflector,
        debugService: DebugService,
      ) => {
        return new PermissionGuard(permissionService, logger, reflector, debugService)
      },
      inject: [PermissionService, CustomLogger, Reflector, DebugService],
    },
  ],
  exports: [PermissionService],
})
export class PermissionModule {}

================
File: src/core/modules/prisma.module.ts
================
// prisma.module.ts
import { Global, Module } from '@nestjs/common'
import { ConfigModule, ConfigService } from '@nestjs/config'
import { PrismaService } from '../services/prisma.service'

@Global()
@Module({
  imports: [ConfigModule],
  providers: [
    {
      provide: PrismaService,
      useFactory: (configService: ConfigService) => {
        return new PrismaService(configService)
      },
      inject: [ConfigService],
    },
  ],
  exports: [PrismaService],
})
export class PrismaModule {}

================
File: src/core/pipes/transformation.pipe.ts
================
// pipes/transformation.pipe.ejs
import { PipeTransform, ArgumentMetadata } from '@nestjs/common'
import { Injectable } from '@nestjs/common'

@Injectable()
export class TransformationPipe implements PipeTransform {
  constructor(private readonly transformFn: (value: any) => any) {}

  transform(value: any, metadata: ArgumentMetadata) {
    return this.transformFn(value)
  }
}

================
File: src/core/pipes/trim.pipe.ts
================
// pipes/trim.pipe.ejs
import { PipeTransform, ArgumentMetadata } from '@nestjs/common'
import { Injectable } from '@nestjs/common'

@Injectable()
export class TrimPipe implements PipeTransform {
  transform(value: any, metadata: ArgumentMetadata) {
    if (!value) return value

    if (typeof value === 'string') {
      return value.trim()
    }

    if (Array.isArray(value)) {
      return value.map((item) => (typeof item === 'string' ? item.trim() : item))
    }

    if (typeof value === 'object') {
      return Object.keys(value).reduce(
        (acc, key) => ({
          ...acc,
          [key]: typeof value[key] === 'string' ? value[key].trim() : value[key],
        }),
        {},
      )
    }

    return value
  }
}

================
File: src/core/pipes/type-conversion.pipe.ts
================
// pipes/type-conversion.pipe.ejs
import { PipeTransform, ArgumentMetadata } from '@nestjs/common'
import { Injectable, BadRequestException } from '@nestjs/common'

@Injectable()
export class TypeConversionPipe implements PipeTransform {
  constructor(private readonly targetType: 'number' | 'boolean' | 'string') {}

  transform(value: any, metadata: ArgumentMetadata) {
    if (value === undefined) return value

    try {
      switch (this.targetType) {
        case 'number':
          return Number(value)
        case 'boolean':
          return value === 'true' || value === '1' || value === true
        case 'string':
          return String(value)
        default:
          return value
      }
    } catch (error: any) {
      throw new BadRequestException(`Type conversion failed: ${error.message}`)
    }
  }
}

================
File: src/core/pipes/validation.pipe.ts
================
// pipes/validation.pipe.ts
import { PipeTransform, ArgumentMetadata } from '@nestjs/common'
import { Injectable, BadRequestException } from '@nestjs/common'
import { validate } from 'class-validator'
import { plainToInstance } from 'class-transformer'
import { CustomLogger } from '@core/logger/custom.logger'

@Injectable()
export class ValidationPipe implements PipeTransform<any> {
  constructor(private logger: CustomLogger) {
    this.logger.setDomain('validation')
  }

  async transform(value: any, { metatype }: ArgumentMetadata) {
    if (!metatype || !this.toValidate(metatype)) {
      return value
    }

    const object = plainToInstance(metatype, value)
    const errors = await validate(object)

    if (errors.length > 0) {
      this.logger.warn(`Validation failed: ${JSON.stringify(errors)}`)
      throw new BadRequestException('Validation failed')
    }

    return value
  }

  private toValidate(metatype: Function): boolean {
    const types: Function[] = [String, Boolean, Number, Array, Object]
    return !types.includes(metatype)
  }
}

================
File: src/core/services/debug.service.ts
================
import { Injectable, ExecutionContext } from '@nestjs/common'
import { Reflector } from '@nestjs/core'
import { ConfigService } from '@nestjs/config'

@Injectable()
export class DebugService {
  constructor(private readonly config: ConfigService) {}

  isDebugMode(): boolean {
    return this.config.get('app.debug') ?? false
  }

  attachPermissionDebugInfo(request: any, data: any) {
    if (!this.isDebugMode()) return
    request.permissions = {
      ...request.permissions,
      ...data,
    }
  }
}

================
File: src/core/services/pagination.service.ts
================
import { Injectable } from '@nestjs/common'
import type { PaginatedQuery, PaginatedResponse, PaginationMeta } from '@types'

@Injectable()
export class PaginationService {
  getPaginationMeta(total: number, query: PaginatedQuery): PaginationMeta {
    const page = Number(query.page) || 1
    const limit = Number(query.limit) || 10
    const totalPages = Math.ceil(total / limit)

    return {
      total,
      totalPages,
      page,
      limit,
      hasNextPage: page < totalPages,
      hasPreviousPage: page > 1,
    }
  }

  getPaginatedResponse<T>(data: T[], total: number, query: PaginatedQuery): PaginatedResponse<T> {
    return {
      data,
      meta: this.getPaginationMeta(total, query),
      success: true,
      timestamp: new Date().toISOString(),
    }
  }

  getSkipTake(query: PaginatedQuery): { skip: number; take: number } {
    const page = Number(query.page) || 1
    const limit = Number(query.limit) || 10

    return {
      skip: (page - 1) * limit,
      take: limit,
    }
  }
}

================
File: src/core/services/permission.service.ts
================
// services/permission.service.ts
import { OnModuleInit } from '@nestjs/common'
import { Injectable, UnauthorizedException } from '@nestjs/common'
import { ConfigService } from '@nestjs/config'
import { SupabaseClient } from '@supabase/supabase-js'
import { createClient } from '@supabase/supabase-js'
import { CustomLogger } from '@core/logger/custom.logger'
import * as jwt from 'jsonwebtoken'
import { PrismaService } from './prisma.service'
import type { DatabaseAction, TokenPayload, PermissionCondition } from '@types'

interface SupabaseJwtPayload {
  aud: string
  exp: number
  sub: string
  email: string
  role: string
  // ... other fields from your JWT
}

@Injectable()
export class PermissionService implements OnModuleInit {
  private jwtSecret: string
  private roleHierarchyCache: Map<string, string[]>

  constructor(
    private readonly config: ConfigService,
    private readonly prisma: PrismaService,
    private readonly logger: CustomLogger,
  ) {
    // Get this from your Supabase dashboard > Project Settings > API
    this.jwtSecret = this.config.get('app.supabase.jwt_secret')
    this.roleHierarchyCache = new Map()
  }

  async onModuleInit() {
    this.logger.setDomain('permissions')
    try {
      this.logger.log('Permission service initializing...')
      await this.loadRoleHierarchy()
      this.logger.log('Permission service initialized with role hierarchy')
    } catch (error) {
      this.logger.error('Failed to initialize permission service', error)
      throw error // rethrow so Nest knows to fail startup
    }
  }

  private async loadRoleHierarchy() {
    try {
      const hierarchyData = await this.prisma.roleHierarchy.findMany()

      this.logger.log(`fetching role hierarchy for ${this.roleHierarchyCache.size} roles`)
      hierarchyData.forEach(({ parent_role, child_role }) => {
        const parentRoles = this.roleHierarchyCache.get(child_role) || []
        parentRoles.push(parent_role)
        this.roleHierarchyCache.set(child_role, parentRoles)
      })

      this.logger.log(`Loaded role hierarchy for ${this.roleHierarchyCache.size} roles`)
    } catch (error: any) {
      this.logger.error('Failed to load role hierarchy', error.stack)
      throw error
    }
  }

  async getRoleHierarchy(role: string): Promise<string[]> {
    try {
      // First, get direct hierarchy from cache
      const directHierarchy = this.roleHierarchyCache.get(role) || []

      // Then get inherited permissions by recursively checking parent roles
      const allRoles = new Set<string>([role, ...directHierarchy])

      for (const parentRole of directHierarchy) {
        const parentHierarchy = await this.getRoleHierarchy(parentRole)
        parentHierarchy.forEach((r) => allRoles.add(r))
      }

      return Array.from(allRoles)
    } catch (error) {
      this.logger.error(`Failed to get role hierarchy for ${role}`, error)
      return [role] // Return just the current role if hierarchy lookup fails
    }
  }

  async validateToken(token: string): Promise<SupabaseJwtPayload> {
    try {
      this.logger.debug('Attempting to validate Supabase token', {
        tokenLength: token.length,
        tokenPrefix: token.substring(0, 10) + '...', // Safe logging
      })

      const decoded = jwt.verify(token, this.jwtSecret) as SupabaseJwtPayload

      this.logger.debug('Token decoded successfully', {
        sub: decoded.sub,
        role: decoded.role,
        exp: new Date(decoded.exp * 1000).toISOString(),
        aud: decoded.aud,
      })

      // Verify the token is a Supabase token
      if (decoded.aud !== 'authenticated') {
        this.logger.warn('Invalid audience in token', { aud: decoded.aud })
        throw new UnauthorizedException('Invalid token audience')
      }

      return decoded
    } catch (error: any) {
      this.logger.error('Token validation failed', {
        error: error.message,
        stack: error.stack,
      })
      throw new UnauthorizedException('Invalid token')
    }
  }
}

================
File: src/core/services/prisma.service.ts
================
// core/services/prisma.service.ejs
import { OnModuleInit, OnModuleDestroy } from '@nestjs/common'
import { Injectable } from '@nestjs/common'
import { ConfigService } from '@nestjs/config'
import { PrismaClient } from '@astronera/db'

@Injectable()
export class PrismaService extends PrismaClient implements OnModuleInit, OnModuleDestroy {
  constructor(private readonly configService: ConfigService) {
    super({
      log: ['query', 'info', 'warn', 'error'],
      datasources: {
        db: {
          url: configService.get<string>('app.database.url'),
        },
      },
    })
  }

  async onModuleInit() {
    try {
      console.log('Prisma connecting...')
      await this.$connect()
      console.log('Prisma connected')
    } catch (error) {
      console.error('Prisma connection failed', error)
      throw error
    }
  }

  async onModuleDestroy() {
    await this.$disconnect()
    console.log('Prisma disconnected')
  }
}

================
File: src/core/storage/throttler.storage.ts
================
// core/storage/throttler.storage.ts
import { Injectable } from '@nestjs/common'
import type { ThrottlerStorage } from '@nestjs/throttler'
import { CustomLogger } from '@core/logger/custom.logger'

interface ThrottleRecord {
  totalHits: number
  timeToExpire: number
}

@Injectable()
export class CustomThrottlerStorage implements ThrottlerStorage {
  private storage: Map<string, ThrottleRecord> = new Map()
  private readonly logger: CustomLogger

  constructor() {
    this.logger = new CustomLogger('ThrottlerStorage')
  }

  async increment(
    key: string,
    ttl: number,
    limit: number,
    blockDuration: number,
    throttlerName: string,
  ): Promise<ThrottlerStorage['increment']['arguments']> {
    const record = this.storage.get(key) ?? {
      totalHits: 0,
      timeToExpire: Date.now() + ttl,
    }
    record.totalHits++
    this.storage.set(key, record)

    this.logger.debug(`Increment key: ${key}, hits: ${record.totalHits}`)
    return record
  }

  async get(key: string): Promise<ThrottleRecord | undefined> {
    this.clearExpired()
    return this.storage.get(key)
  }

  async reset(key: string): Promise<void> {
    this.storage.delete(key)
    this.logger.debug(`Reset key: ${key}`)
  }

  private clearExpired(): void {
    const now = Date.now()
    for (const [key, record] of this.storage.entries()) {
      if (record.timeToExpire <= now) {
        this.storage.delete(key)
        this.logger.debug(`Cleared expired key: ${key}`)
      }
    }
  }
}

================
File: src/core/utils/auth.utils.ts
================
// utils/auth.utils.ejs
import { UnauthorizedException } from '@nestjs/common'
import { verify } from 'jsonwebtoken'

export class AuthUtils {
  static verifyToken(token: string, secret: string): any {
    try {
      return verify(token, secret)
    } catch (error: any) {
      throw new UnauthorizedException('Invalid token')
    }
  }

  static extractTokenFromHeader(authHeader: string): string {
    if (!authHeader) {
      throw new UnauthorizedException('No authorization header')
    }
    const [type, token] = authHeader.split(' ')
    if (type !== 'Bearer') {
      throw new UnauthorizedException('Invalid authorization type')
    }
    return token
  }
}

================
File: src/core/utils/permission.utils.ts
================
// utils/permission.utils.ejs
export class PermissionUtils {
  static canAccess(userPermissions: string[], requiredPermissions: string[]): boolean {
    return requiredPermissions.every((required) =>
      userPermissions.some((userPerm) => this.matchPermission(userPerm, required)),
    )
  }

  private static matchPermission(userPerm: string, required: string): boolean {
    const userParts = userPerm.split(':')
    const requiredParts = required.split(':')

    if (userParts[0] === '*') return true
    if (userParts.length !== requiredParts.length) return false

    return userParts.every((part, i) => part === '*' || part === requiredParts[i])
  }
}

================
File: src/core/webhook/razorpay.service.ts
================
import { Injectable } from '@nestjs/common';

@Injectable()
export class RazorpayWebhookService {
  handleEvent(payload: any): void {
    switch (payload.event) {
      case 'subscription.activated':
        this.handleSubscriptionActivated(payload);
        break;
      case 'subscription.charged':
        this.handleSubscriptionCharged(payload);
        break;
      case 'payment.captured':
        this.handlePaymentCaptured(payload);
        break;
      default:
        console.warn(`Unhandled event type: ${payload.event}`);
    }
  }

  private handleSubscriptionCharged(payload: any): void {
    // Logic for subscription charged
  }

  private handlePaymentCaptured(payload: any): void {
    // Logic for payment captured
  }

  private handleSubscriptionActivated(payload: any): void {

  }
}

================
File: src/core/webhook/webhook.module.ts
================
import { Module } from '@nestjs/common';
import { RazorpayWebhookService } from './razorpay.service';

@Module({
  providers: [RazorpayWebhookService],
  exports: [RazorpayWebhookService],
})
export class WebhookModule {}

================
File: src/core/core.module.ts
================
// core.module.ts
import { Module, Global } from '@nestjs/common'
import { ConfigModule } from '@nestjs/config'
import { Reflector } from '@nestjs/core'
import { LoggerModule } from './modules/logger.module'
import { PaginationService } from './services/pagination.service'
import { PermissionModule } from './modules/permission.module'
import { PrismaModule } from './modules/prisma.module'
import { DebugService } from './services/debug.service'

@Global()
@Module({
  imports: [ConfigModule, PrismaModule, LoggerModule, PermissionModule],
  providers: [PaginationService, DebugService, Reflector],
  exports: [PaginationService, LoggerModule, PermissionModule, DebugService, Reflector],
})
export class CoreModule {}

================
File: src/core/index.ts
================
/**
 * @file Auto-generated barrel file
 * @generated
 */

export * from './base/base.dto'
export * from './base/base.gateway'
export * from './base/base.model'
export * from './config/configuration'
export * from './config/domain-config'
export * from './dto/pagination.dto'
export * from './logger/custom.logger'
export * from './logger/logger.colors'
export * from './pipes/transformation.pipe'
export * from './pipes/trim.pipe'
export * from './pipes/type-conversion.pipe'
export * from './pipes/validation.pipe'
export * from './storage/throttler.storage'
export * from './utils/auth.utils'
export * from './utils/permission.utils'

================
File: src/jobs/controllers/job-config.controller.ts
================
import {
  Controller,
  Get,
  Post,
  Put,
  Delete,
  Body,
  Param,
  Query,
  ParseUUIDPipe,
  UseGuards,
  HttpException,
  HttpStatus,
} from '@nestjs/common'
import { ApiOperation } from '@nestjs/swagger'
import { PermissionGuard } from '@core/guards/permission.guard'
import { Prisma } from '@astronera/db'
import { ConfigService } from '@nestjs/config'
import { PrismaService } from '@core/services/prisma.service'
import { PaginationService } from '@core/services/pagination.service'
import { CustomLogger } from '@core/logger/custom.logger'
import { BaseController, ApiBaseController } from '@core/base/base.controller'
import { PaginatedQuery } from '@types'
import { JobConfigService } from '../services/job-config.service'

@ApiBaseController('job-configs')
@UseGuards(PermissionGuard)
@Controller()
export class JobConfigController extends BaseController {
  constructor(
    protected readonly jobConfigService: JobConfigService,
    protected readonly prisma: PrismaService,
    protected readonly config: ConfigService,
    protected readonly paginationService: PaginationService,
    protected readonly logger: CustomLogger,
  ) {
    // Match the Prisma model name you intend to use
    super('JobConfigs')
  }

  @Get()
  @ApiOperation({ summary: 'Get all job configs (cron-jobs)' })
  async getAll(@Query() query: PaginatedQuery) {
    try {
      // If you want fully customized retrieval, call a custom service method:
      // return this.jobConfigsService.getAllJobConfigs(query)
      // Or, use the base controller’s `findAll` for quick paging/filters:
      return await this.findAll(query)
    } catch (error: any) {
      throw new HttpException(
        error.message || 'An error occurred',
        error.status || HttpStatus.INTERNAL_SERVER_ERROR,
      )
    }
  }

  @Get(':id')
  @ApiOperation({ summary: 'Get a single job config by ID' })
  async findOneJobConfig(
    @Param('id', ParseUUIDPipe) id: string,
    @Query('include') include?: string[],
  ) {
    try {
      return await this.findOne(id, include)
    } catch (error: any) {
      throw this.handleError(error)
    }
  }

  @Post()
  @ApiOperation({ summary: 'Create a new job config (cron-job)' })
  async createJobConfig(@Body() data: Prisma.JobConfigsCreateInput) {
    try {
      return await this.create(data)
    } catch (error: any) {
      throw this.handleError(error)
    }
  }

  @Put(':id')
  @ApiOperation({ summary: 'Update an existing job config' })
  async updateJobConfig(
    @Param('id', ParseUUIDPipe) id: string,
    @Body() data: Prisma.JobConfigsUpdateInput,
  ) {
    try {
      return await this.update(id, data)
    } catch (error: any) {
      throw this.handleError(error)
    }
  }

  @Delete(':id')
  @ApiOperation({ summary: 'Delete a job config' })
  async removeJobConfig(@Param('id', ParseUUIDPipe) id: string) {
    try {
      return await this.remove(id)
    } catch (error: any) {
      throw this.handleError(error)
    }
  }
}

================
File: src/jobs/controllers/job-metric.controller.ts
================
import {
  Controller,
  Get,
  Post,
  Put,
  Delete,
  Body,
  Param,
  Query,
  ParseUUIDPipe,
  UseGuards,
  HttpException,
  HttpStatus,
} from '@nestjs/common'
import { ApiOperation } from '@nestjs/swagger'
import { ConfigService } from '@nestjs/config'
import { PrismaService } from '@core/services/prisma.service'
import { PaginationService } from '@core/services/pagination.service'
import { CustomLogger } from '@core/logger/custom.logger'
import { PermissionGuard } from '@core/guards/permission.guard'
import { BaseController, ApiBaseController } from '@core/base/base.controller'
import { JobMetricService } from '../services/job-metric.service'
import { Prisma } from '@astronera/db'
import { PaginatedQuery } from '@types'

@ApiBaseController('job-metrics')
@UseGuards(PermissionGuard)
@Controller()
export class JobMetricController extends BaseController {
  constructor(
    protected readonly jobMetricService: JobMetricService,
    protected readonly prisma: PrismaService,
    protected readonly config: ConfigService,
    protected readonly paginationService: PaginationService,
    protected readonly logger: CustomLogger,
  ) {
    super('JobMetrics')
  }

  @Get()
  @ApiOperation({ summary: 'Retrieve all job metrics' })
  async getAll(@Query() query: PaginatedQuery) {
    try {
      // If you need a simple paginated list:
      return await this.findAll(query)
      // Or for custom logic, call service methods, e.g.:
      // return await this.jobMetricService.findMetricsByJobName('my-job')
    } catch (error: any) {
      throw new HttpException(
        error.message || 'An error occurred',
        error.status || HttpStatus.INTERNAL_SERVER_ERROR,
      )
    }
  }

  @Get(':id')
  @ApiOperation({ summary: 'Retrieve a single job metric by ID' })
  async findOneJobMetric(
    @Param('id', ParseUUIDPipe) id: string,
    @Query('include') include?: string[],
  ) {
    try {
      return await this.findOne(id, include)
    } catch (error: any) {
      throw this.handleError(error)
    }
  }

  @Post()
  @ApiOperation({ summary: 'Create a new job metric record' })
  async createJobMetric(@Body() data: Prisma.JobMetricsCreateInput) {
    try {
      return await this.create(data)
    } catch (error: any) {
      throw this.handleError(error)
    }
  }

  @Put(':id')
  @ApiOperation({ summary: 'Update a job metric record' })
  async updateJobMetric(
    @Param('id', ParseUUIDPipe) id: string,
    @Body() data: Prisma.JobMetricsUpdateInput,
  ) {
    try {
      return await this.update(id, data)
    } catch (error: any) {
      throw this.handleError(error)
    }
  }

  @Delete(':id')
  @ApiOperation({ summary: 'Delete a job metric record' })
  async removeJobMetric(@Param('id', ParseUUIDPipe) id: string) {
    try {
      return await this.remove(id)
    } catch (error: any) {
      throw this.handleError(error)
    }
  }
}

================
File: src/jobs/services/job-config.service.ts
================
import { Injectable } from '@nestjs/common'
import { BaseService } from '@core/base/base.service'
import { PrismaService } from '@core/services/prisma.service'
import { PaginationService } from '@core/services/pagination.service'

@Injectable()
export class JobConfigService extends BaseService<'JobConfigs'> {
  constructor(
    protected readonly prisma: PrismaService,
    protected readonly paginationService: PaginationService,
  ) {
    super('JobConfigs')
  }

  // Example custom method
  async getAllJobConfigs(query: any) {
    // Your custom logic or direct calls to executePrismaQuery, e.g.:
    return this.executePrismaQuery(() =>
      // This could be further refined to include pagination, filtering, etc.
      this.prisma.jobConfigs.findMany({
        where: {},
        orderBy: { created_at: 'desc' },
      }),
    )
  }
}

================
File: src/jobs/services/job-metric.service.ts
================
import { Injectable } from '@nestjs/common'
import { Prisma } from '@astronera/db'
import { BaseService } from '@core/base/base.service'
import { PrismaService } from '@core/services/prisma.service'
import { PaginationService } from '@core/services/pagination.service'

@Injectable()
export class JobMetricService extends BaseService<'JobMetrics'> {
  constructor(
    protected readonly prisma: PrismaService,
    protected readonly paginationService: PaginationService,
  ) {
    // Pass in the Prisma model name to the super constructor
    super('JobMetrics')
  }

  // Example custom method (e.g., filter by job_name or date range)
  async findMetricsByJobName(jobName: string) {
    return this.executePrismaQuery(() =>
      this.prisma.jobMetrics.findMany({
        where: { job_name: jobName },
        orderBy: { created_at: 'desc' },
      }),
    )
  }
}

================
File: src/jobs/index.ts
================
/**
 * @file Auto-generated barrel file
 * @generated
 */

================
File: src/jobs/job.module.ts
================
import { Module } from '@nestjs/common'
import { JobConfigController } from './controllers/job-config.controller'
import { JobConfigService } from './services/job-config.service'
import { JobMetricController } from './controllers/job-metric.controller'
import { JobMetricService } from './services/job-metric.service'

@Module({
  controllers: [JobConfigController, JobMetricController],
  providers: [JobConfigService, JobMetricService],
  exports: [JobConfigService, JobMetricService],
})
export class JobModule {}

================
File: src/monitoring/controllers/error-metrics.controller.ts
================
// src/monitoring/controllers/error-metrics.controller.ts
import { Controller, Get, Query, UseGuards, HttpException, HttpStatus } from '@nestjs/common'
import { ApiTags, ApiOperation } from '@nestjs/swagger'
import { PermissionGuard } from '@core/guards/permission.guard'
import { ErrorMetricService } from '../services/error-metrics.service'
import { ApiBaseController } from '@core/base/base.controller'
import type { ErrorSeverity, ErrorType } from '@astronera/db'

@ApiBaseController('error-metrics')
@UseGuards(PermissionGuard)
export class ErrorMetricController {
  constructor(private readonly metricsService: ErrorMetricService) {}

  @Get('frequency')
  @ApiOperation({ summary: 'Get error frequency data' })
  async getErrorFrequency(
    @Query('startDate') startDate?: string,
    @Query('endDate') endDate?: string,
    @Query('service') serviceName?: string,
    @Query('type') errorType?: ErrorType,
    @Query('severity') severity?: ErrorSeverity,
  ) {
    try {
      return await this.metricsService.getErrorFrequency({
        startDate,
        endDate,
        serviceName,
        errorType,
        severity,
      })
    } catch (error: any) {
      throw new HttpException(
        error.message || 'Failed to retrieve error frequency',
        error.status || HttpStatus.INTERNAL_SERVER_ERROR,
      )
    }
  }

  @Get('metrics')
  @ApiOperation({ summary: 'Get error metrics' })
  async getErrorMetrics(
    @Query('startDate') startDate?: string,
    @Query('endDate') endDate?: string,
    @Query('service') serviceName?: string,
    @Query('type') errorType?: ErrorType,
  ) {
    try {
      return await this.metricsService.getErrorMetrics({
        startDate,
        endDate,
        serviceName,
        errorType,
      })
    } catch (error: any) {
      throw new HttpException(
        error.message || 'Failed to retrieve error metrics',
        error.status || HttpStatus.INTERNAL_SERVER_ERROR,
      )
    }
  }

  @Get('stats')
  @ApiOperation({ summary: 'Get error stats data' })
  async getErrorStats(
    @Query('minExecTime') minExecTime?: number,
    @Query('topLevel') topLevel?: boolean,
  ) {
    try {
      return await this.metricsService.getErrorStats({
        minExecTime,
        topLevel,
      })
    } catch (error: any) {
      throw new HttpException(
        error.message || 'Failed to retrieve error stats',
        error.status || HttpStatus.INTERNAL_SERVER_ERROR,
      )
    }
  }

  @Get('trends')
  @ApiOperation({ summary: 'Get error trends over time' })
  async getErrorTrends(
    @Query('timeframe') timeframe: '1h' | '24h' | '7d' | '30d' = '24h',
    @Query('service') serviceName?: string,
  ) {
    try {
      return await this.metricsService.getErrorTrends(timeframe, serviceName)
    } catch (error: any) {
      throw new HttpException(
        error.message || 'Failed to retrieve error trends',
        error.status || HttpStatus.INTERNAL_SERVER_ERROR,
      )
    }
  }
}

================
File: src/monitoring/controllers/health.controller.ts
================
// src/monitoring/controllers/health.controller.ts
import { Controller, Get, OnModuleInit, OnModuleDestroy, Req } from '@nestjs/common'
import { Request } from 'express'
import { Public } from '@core/decorators/public.decorator'
import { CustomLogger } from '@core/logger/custom.logger'
import {
  HealthCheckService,
  HttpHealthIndicator,
  DiskHealthIndicator,
  MemoryHealthIndicator,
} from '@nestjs/terminus'
import { HealthCheck } from '@nestjs/terminus'

@Controller('monitoring')
export class HealthController implements OnModuleInit, OnModuleDestroy {
  private readonly logger = new CustomLogger('Health')
  private healthCheckInterval: NodeJS.Timeout | null = null

  constructor(
    private health: HealthCheckService,
    private http: HttpHealthIndicator,
    private disk: DiskHealthIndicator,
    private memory: MemoryHealthIndicator,
  ) {}

  onModuleInit() {
    this.healthCheckInterval = setInterval(
      () => {
        this.performHealthCheck()
      },
      60 * 1000 * 30,
    )
  }

  private async performHealthCheck() {
    return this.health.check([
      () => this.http.pingCheck('nestjs-docs', 'https://docs.nestjs.com'),
      () => this.disk.checkStorage('storage', { path: '/', thresholdPercent: 0.9 }),
      () => this.memory.checkHeap('memory_heap', 150 * 1024 * 1024),
    ])
  }

  onModuleDestroy() {
    if (this.healthCheckInterval) {
      clearInterval(this.healthCheckInterval)
    }
  }

  @Get('health')
  @Public()
  @HealthCheck()
  async check(@Req() req: Request) {
    this.logger.log('Health check endpoint called', {
      timestamp: new Date().toISOString(),
      headers: req.headers,
      ip: req.ip,
      method: req.method,
      path: req.path,
    })
    return this.performHealthCheck()
  }
}

================
File: src/monitoring/controllers/log.controller.ts
================
// src/monitoring/controllers/logs.controller.ts
import {
  Controller,
  Get,
  Post,
  Body,
  Query,
  UseGuards,
  HttpException,
  HttpStatus,
  Inject,
} from '@nestjs/common'
import { MessagePattern } from '@nestjs/microservices'
import { ApiTags, ApiOperation } from '@nestjs/swagger'
import { ConfigService } from '@nestjs/config'
import { PrismaService } from '@core/services/prisma.service'
import { PaginationService } from '@core/services/pagination.service'
import { CustomLogger } from '@core/logger/custom.logger'
import { ErrorLogs } from '@astronera/db'
import { BaseController } from '@core/base/base.controller'
import { PermissionGuard } from '@core/guards/permission.guard'
import { ApiKeyGuard } from '@core/guards/api-key.guard'
import { LogService } from '../services/log.service'
import { ApiBaseController } from '@core/base/base.controller'
import { ApiPaginatedResponse } from '@core/decorators/api.decorator'
import { Service } from '@core/decorators/service.decorator'
import type { LogEntry } from '@ib/cache'
import type { ErrorLogEntry } from '@ib/logger'


@ApiBaseController('logs')
@UseGuards(PermissionGuard)
export class LogController extends BaseController {
  constructor(
    protected readonly logService: LogService,
    protected readonly prisma: PrismaService,
    protected readonly config: ConfigService,
    protected readonly paginationService: PaginationService,
    protected readonly logger: CustomLogger,
  ) {
    super('ErrorLogs')
    this.logger.setDomain('monitoring')
  }

  @Get('patterns')
  @ApiOperation({ summary: 'Get error patterns' })
  async getErrorPatterns() {
    try {
      return await this.logService.getErrorPatterns()
    } catch (error: any) {
      throw new HttpException(
        error.message || 'Failed to retrieve error patterns',
        error.status || HttpStatus.INTERNAL_SERVER_ERROR,
      )
    }
  }

  @ApiPaginatedResponse({})
  @Get()
  async getLogs(
    @Query('from') from?: string,
    @Query('to') to?: string,
    @Query('service') service?: string,
    @Query('severity') severity?: string,
    @Query('page') page: number = 1,
    @Query('pageSize') pageSize: number = 50,
  ) {
    // For historical logs, get from Postgres
    if (from && to) {
      return this.logService.getHistoricalLogs({
        from: new Date(from),
        to: new Date(to),
        service,
        severity,
        page,
        pageSize,
      })
    }

    // For recent logs (last 24h), get from Redis
    return this.logService.getRecentLogs({
      service,
      severity,
      page,
      pageSize,
    })
  }

  @Post('process')
  @Service()
  @ApiOperation({ summary: 'Process new log entry' })
  async processLog(@Body() log: LogEntry) {
    try {
      const errorLog: ErrorLogEntry = {
        ...log,
        id: '', // provide appropriate value
        service_name: '', // provide appropriate value
        severity: '', // provide appropriate value
        environment: '', // provide appropriate value
        created_at: new Date().toISOString(), // provide appropriate value
      }
      return await this.logService.processLog(errorLog)
    } catch (error: any) {
      throw new HttpException(
        error.message || 'Failed to process log',
        error.status || HttpStatus.INTERNAL_SERVER_ERROR,
      )
    }
  }

  @Get('stats')
  @ApiOperation({ summary: 'Get log statistics' })
  async getLogStats(@Query('hours') hours?: number) {
    try {
      return await this.logService.getLogStats(hours)
    } catch (error: any) {
      throw new HttpException(
        error.message || 'Failed to retrieve log statistics',
        error.status || HttpStatus.INTERNAL_SERVER_ERROR,
      )
    }
  }
}

================
File: src/monitoring/gateways/log.gateway.ts
================
// src/monitoring/gateways/log.gateway.ts

import {
  WebSocketGateway,
  SubscribeMessage,
  OnGatewayConnection,
  OnGatewayDisconnect,
  ConnectedSocket,
  MessageBody,
} from '@nestjs/websockets'
import { UseGuards, Injectable } from '@nestjs/common'
import { Socket } from 'socket.io'
import { PermissionGuard } from '@core/guards/permission.guard'
import { CustomLogger } from '@core/logger/custom.logger'
import { BaseGateway } from '@core/base/base.gateway'
import * as crypto from 'crypto'

// Same interface as before
interface LogFilters {
  service?: string
  severity?: string
  startTime?: string
  endTime?: string
}

// @UseGuards(PermissionGuard)
@WebSocketGateway({
  path: '/log-stream',
  transports: ['websocket', 'polling'],
})
export class LogGateway extends BaseGateway implements OnGatewayConnection, OnGatewayDisconnect {
  // We override `connectedClients` in order to store additional data
  private readonly clientMetadata = new Map<
    string,
    {
      filters?: LogFilters
      rooms: Set<string>
    }
  >()

  constructor(logger: CustomLogger) {
    super()
    // (Optional) give this gateway a domain or change the context
    this.logger.setContext('log-gateway')
    this.logger.setDomain('monitoring')

    this.server?.on('connect_error', (err) => {
      this.logger.error('Socket connection error', { error: err })
    })

    this.server?.on('connection_failed', (err) => {
      this.logger.error('Socket connection failed', { error: err })
    })
  }

  /**
   * Override handleConnection to store extended info
   */
  override async handleConnection(client: Socket) {
    // Call BaseGateway's handleConnection if you want to track
    // each raw Socket in `baseConnectedClients`
    super.handleConnection(client)

    try {
      // Add client to our tracking
      this.clientMetadata.set(client.id, {
        rooms: new Set(),
      })

      this.logger.log('Client connected to log stream', {
        clientId: client.id,
        handshake: {
          query: client.handshake.query,
          headers: client.handshake.headers,
        },
      })

      // Send initial connection success
      client.emit('connection_status', {
        status: 'connected',
        clientId: client.id,
        timestamp: new Date().toISOString(),
      })
    } catch (error) {
      this.logger.error('Error handling client connection', {
        error,
        clientId: client.id,
      })
      client.disconnect(true)
    }
  }

  /**
   * Override handleDisconnect to clean up your extended map
   */
  override async handleDisconnect(client: Socket) {
    // Also call the base method if you want the base gateway to track this
    super.handleDisconnect(client)

    try {
      // Clean up client tracking
      const clientInfo = this.clientMetadata.get(client.id)
      if (clientInfo) {
        // Leave all rooms
        clientInfo.rooms.forEach((room) => client.leave(room))
        this.clientMetadata.delete(client.id)
      }

      this.logger.log('Client disconnected from log stream', {
        clientId: client.id,
      })
    } catch (error) {
      this.logger.error('Error handling client disconnect', {
        error,
        clientId: client.id,
      })
    }
  }

  /**
   * Subscribe message example
   */
  @SubscribeMessage('subscribe')
  async handleSubscribe(@ConnectedSocket() client: Socket, @MessageBody() filters: LogFilters) {
    try {
      // Retrieve or initialize client info
      const clientInfo = this.clientMetadata.get(client.id) || {
        filters: undefined,
        rooms: new Set<string>(),
      }

      // Leave previous rooms
      clientInfo.rooms.forEach((room) => client.leave(room))
      clientInfo.rooms.clear()

      // Compute room name from filters
      const room = this.getFilterRoom(filters)
      await client.join(room)
      clientInfo.rooms.add(room)

      // Update client info
      clientInfo.filters = filters
      this.clientMetadata.set(client.id, clientInfo)

      this.logger.log('Client subscribed to log stream', {
        clientId: client.id,
        filters,
        room,
      })

      return {
        event: 'subscribed',
        data: {
          room,
          filters,
          timestamp: new Date().toISOString(),
        },
      }
    } catch (error) {
      this.logger.error('Error handling subscription', {
        error,
        clientId: client.id,
        filters,
      })
      throw error
    }
  }

  /**
   * Helper to map filters to a room name
   */
  private getFilterRoom(filters: LogFilters): string {
    const service = filters?.service || '*'
    const severity = filters?.severity || '*'
    return `logs:${service}:${severity}`
  }

  /**
   * Broadcast logs to relevant rooms
   */
  async broadcastLog(log: any) {
    try {
      console.log('broadcastLog', log)
      const roomPatterns = [
        `logs:${log.service}:${log.severity}`,
        `logs:${log.service}:*`,
        `logs:*:${log.severity}`,
        `logs:*:*`,
      ]

      // Emit to each matching room
      // Emit to each matching room
      roomPatterns.forEach((room) => {
        this.server.to(room).emit('newLog', {
          ...log,
          created_at: new Date().toISOString(),
        })
      })

      this.logger.debug('Broadcast log to rooms', {
        logId: log.id,
        service: log.service,
        severity: log.severity,
        rooms: roomPatterns,
      })
    } catch (error) {
      this.logger.error('Error broadcasting log', {
        error,
        log,
      })
      throw error
    }
  }

  /**
   * Helper methods for monitoring/debugging
   */
  getConnectedClients() {
    return Array.from(this.clientMetadata.entries()).map(([id, info]) => ({
      clientId: id,
      filters: info.filters,
      rooms: Array.from(info.rooms),
      connectedAt: info.filters.startTime,
    }))
  }

  getRoomSubscriptions() {
    const rooms = new Map<string, string[]>()
    this.connectedClients.forEach((info, clientId) => {
      info.rooms.forEach((room) => {
        const clients = rooms.get(room) || []
        clients.push(clientId)
        rooms.set(room, clients)
      })
    })
    return Object.fromEntries(rooms)
  }
}

================
File: src/monitoring/services/error-metrics.service.ts
================
// src/monitoring/services/error-metrics.service.ts
import { Injectable } from '@nestjs/common'
import { PrismaService } from '@core/services/prisma.service'
import { CustomLogger } from '@core/logger/custom.logger'
import type { ErrorSeverity, ErrorType } from '@astronera/db'

interface TimeRange {
  startDate?: string
  endDate?: string
}

interface ErrorQueryParams extends TimeRange {
  serviceName?: string
  errorType?: ErrorType
  severity?: ErrorSeverity
}

@Injectable()
export class ErrorMetricService {
  constructor(
    private readonly prisma: PrismaService,
    private readonly logger: CustomLogger,
  ) {
    this.logger.setDomain('monitoring')
  }

  async getErrorFrequency(params: ErrorQueryParams) {
    try {
      const { startDate, endDate, serviceName, errorType, severity } = params

      const where = {
        ...(serviceName && { service_name: serviceName }),
        ...(errorType && { error_type: errorType }),
        ...(severity && { severity }),
        ...(startDate &&
          endDate && {
            time_bucket: {
              gte: new Date(startDate),
              lte: new Date(endDate),
            },
          }),
      }

      const frequency = await this.prisma.error_frequency.findMany({
        where,
        orderBy: { time_bucket: 'desc' },
      })

      return {
        data: frequency,
        timestamp: new Date().toISOString(),
      }
    } catch (error) {
      this.logger.error('Failed to get error frequency', { error })
      throw error
    }
  }

  async getErrorMetrics(params: ErrorQueryParams) {
    try {
      const { startDate, endDate, serviceName, errorType } = params

      const where = {
        ...(serviceName && { service_name: serviceName }),
        ...(errorType && { error_type: errorType }),
        ...(startDate &&
          endDate && {
            time_bucket: {
              gte: new Date(startDate),
              lte: new Date(endDate),
            },
          }),
      }

      const [metrics, totalErrors] = await Promise.all([
        this.prisma.error_metrics.findMany({
          where,
          orderBy: { time_bucket: 'desc' },
        }),
        this.prisma.error_metrics.aggregate({
          where,
          _sum: { error_count: true },
        }),
      ])

      return {
        data: metrics,
        total: totalErrors._sum.error_count || 0,
        timestamp: new Date().toISOString(),
      }
    } catch (error) {
      this.logger.error('Failed to get error metrics', { error })
      throw error
    }
  }

  async getErrorStats({ minExecTime, topLevel }: { minExecTime?: number; topLevel?: boolean }) {
    try {
      const where = {
        ...(minExecTime && { mean_exec_time: { gte: minExecTime } }),
        ...(topLevel !== undefined && { toplevel: topLevel }),
      }

      const stats = await this.prisma.error_stats.findMany({
        where,
        orderBy: { mean_exec_time: 'desc' },
      })

      return {
        data: stats,
        timestamp: new Date().toISOString(),
      }
    } catch (error) {
      this.logger.error('Failed to get error stats', { error })
      throw error
    }
  }

  async getErrorTrends(timeframe: '1h' | '24h' | '7d' | '30d', serviceName?: string) {
    try {
      const intervals = {
        '1h': { hours: 1, interval: 'minute' },
        '24h': { hours: 24, interval: 'hour' },
        '7d': { days: 7, interval: 'day' },
        '30d': { days: 30, interval: 'day' },
      }

      const { hours, days } = intervals[timeframe] as { hours?: number; days?: number; interval: string }
      const startDate = new Date()
      if (hours) startDate.setHours(startDate.getHours() - hours)
      if (days) startDate.setDate(startDate.getDate() - days)

      const trends = await this.prisma.error_metrics.groupBy({
        by: ['severity', 'time_bucket'],
        where: {
          time_bucket: { gte: startDate },
          ...(serviceName && { service_name: serviceName }),
        },
        _sum: { error_count: true },
        orderBy: { time_bucket: 'asc' },
      })

      // Group by severity and create time series
      const grouped = trends.reduce((acc, curr) => {
        const severity = curr.severity
        if (!acc[severity]) acc[severity] = []

        acc[severity].push({
          timestamp: curr.time_bucket,
          count: curr._sum.error_count || 0,
        })

        return acc
      }, {})

      return {
        data: grouped,
        timeframe,
        startDate: startDate.toISOString(),
        endDate: new Date().toISOString(),
      }
    } catch (error) {
      this.logger.error('Failed to get error trends', { error })
      throw error
    }
  }
}

================
File: src/monitoring/services/log.service.ts
================
// src/monitoring/services/log.service.ts
import { Injectable, Inject, OnModuleInit } from '@nestjs/common'
import { Redis } from 'ioredis'
import { PrismaService } from '@core/services/prisma.service'
import { PaginationService } from '@core/services/pagination.service'
import { CustomLogger } from '@core/logger/custom.logger'
import { Cron } from '@nestjs/schedule'
import { LogGateway } from '../gateways/log.gateway'
import type { ErrorLogEntry } from '@ib/logger'
import type { PaginatedQuery } from '@types'

@Injectable()
export class LogService implements OnModuleInit {
  private readonly LOG_KEY_PREFIX = 'logs:'
  private readonly RETENTION_HOURS = 24
  @Inject(LogGateway)
  private readonly logGateway: LogGateway

  constructor(
    @Inject('REDIS_CACHE') private readonly redis: Redis,
    private readonly prisma: PrismaService,
    private readonly paginationService: PaginationService,
    private readonly logger: CustomLogger,
  ) {
    this.logger.setDomain('monitoring')
  }

  async onModuleInit() {
    await this.cleanupOldLogs()
  }

  async getRecentLogs(
    query: PaginatedQuery & {
      hours?: number
      level?: 'error' | 'warn' | 'info'
      service?: string
    },
  ): Promise<any> {
    try {
      const { skip, take } = this.paginationService.getSkipTake(query)
      const hours = query.hours || this.RETENTION_HOURS

      // Get keys from Redis
      const keys = await this.redis.keys(`${this.LOG_KEY_PREFIX}*`)
      if (!keys.length)
        return {
          data: [],
          meta: this.paginationService.getPaginationMeta(0, query),
          created_at: new Date().toISOString(),
        }

      // Get all logs
      const pipeline = this.redis.pipeline()
      keys.forEach((key) => pipeline.hgetall(key))
      const results: any = await pipeline.exec()
      if (!results) return []

      // Filter and transform logs
      let logs = results
        .map(([err, data]) => {
          if (err || !data) return null
          return {
            ...Object.values(data),
            metadata: data.metadata ? JSON.parse(data.metadata) : {},
            created_at: parseInt(data.created_at),
          }
        })
        .filter(Boolean)
        .filter((log) => {
          const cutoff = Date.now() - hours * 3600000
          return (
            log.created_at >= cutoff &&
            (!query.level || log.level === query.level) &&
            (!query.service || log.service === query.service)
          )
        })
        .sort((a, b) => b.created_at - a.created_at)

      const total = logs.length
      logs = logs.slice(skip, skip + take)

      return {
        data: logs,
        meta: this.paginationService.getPaginationMeta(total, query),
        created_at: new Date().toISOString(),
      }
    } catch (error) {
      this.logger.error('Failed to get recent logs', { error })
      throw error
    }
  }

  async processLog(log: ErrorLogEntry): Promise<void> {
    try {
      const logKey = `${this.LOG_KEY_PREFIX}${log.created_at}`

      console.log('Processing log', logKey, log)

      await this.redis
        .multi()
        .hset(logKey, {
          ...log,
          metadata: JSON.stringify(log.metadata),
        })
        .expire(logKey, this.RETENTION_HOURS * 3600)
        .exec()

      await this.logGateway.broadcastLog(log)
    } catch (error) {
      this.logger.error('Failed to process log', { error })
      throw error
    }
  }

  async getLogStats(hours: number = 24) {
    try {
      const keys = await this.redis.keys(`${this.LOG_KEY_PREFIX}*`)
      const pipeline = this.redis.pipeline()
      keys.forEach((key) => pipeline.hgetall(key))
      const results = await pipeline.exec()

      const cutoff = Date.now() - hours * 3600000
      const stats = {
        total: 0,
        byLevel: {} as Record<string, number>,
        byService: {} as Record<string, number>,
        timeRange: {
          start: new Date(cutoff).toISOString(),
          end: new Date().toISOString(),
        },
      }

      results?.forEach(([err, data]: [err: any, data: any]) => {
        if (err || !data) return
        const created_at = parseInt(data.created_at)
        if (created_at < cutoff) return

        stats.total++
        stats.byLevel[data.level] = (stats.byLevel[data.level] || 0) + 1
        stats.byService[data.service] = (stats.byService[data.service] || 0) + 1
      })

      return stats
    } catch (error) {
      this.logger.error('Failed to get log stats', { error })
      throw error
    }
  }

  @Cron('0 * * * *')
  async batchProcessLogs(): Promise<void> {
    try {
      const hourAgo = Date.now() - 3600000
      const keys = await this.redis.keys(`${this.LOG_KEY_PREFIX}*`)

      const logsToProcess: any = await Promise.all(
        keys.map(async (key) => {
          const log = await this.redis.hgetall(key)
          return { key, ...log }
        }),
      )

      // Group logs by service and level
      const groupedLogs = logsToProcess.reduce((acc, log) => {
        const key = `${log.service}_${log.level}`
        if (!acc[key]) acc[key] = []
        acc[key].push(log)
        return acc
      }, {})

      // Store in PostgreSQL
      await Promise.all(
        (Object.values(groupedLogs) as any[][]).map(async (logs: any[]) => {
          await this.prisma.errorLogs.createMany({
            data: logs.map((log) => ({
              service_name: log.service,
              severity: this.mapLogLevelToSeverity(log.level),
              message: log.message,
              metadata: log.metadata ? JSON.parse(log.metadata) : {},
              created_at: new Date(parseInt(log.created_at)),
              environment: process.env.NODE_ENV || 'development',
              error_type: log.error_type || 'unknown', // Add this line
            })),
          })
        }),
      )

      // Cleanup processed logs
      await Promise.all(logsToProcess.map((log) => this.redis.del(log.key)))
    } catch (error) {
      this.logger.error('Failed to batch process logs', { error })
      throw error
    }
  }

  private async cleanupOldLogs(): Promise<void> {
    try {
      const retentionTime = Date.now() - this.RETENTION_HOURS * 3600000
      const keys = await this.redis.keys(`${this.LOG_KEY_PREFIX}*`)

      for (const key of keys) {
        const keyType = await this.redis.type(key)
        if (keyType !== 'hash') {
          this.logger.warn(`Deleting key ${key} with unexpected type: ${keyType}`)
          await this.redis.del(key)
          continue
        }
        const log = await this.redis.hgetall(key)
        if (parseInt(log.created_at) < retentionTime) {
          await this.redis.del(key)
        }
      }
    } catch (error) {
      this.logger.error('Failed to cleanup old logs', { error })
    }
  }

  private mapLogLevelToSeverity(level: string): 'low' | 'medium' | 'high' | 'critical' {
    switch (level) {
      case 'error':
        return 'critical'
      case 'warn':
        return 'high'
      case 'info':
        return 'medium'
      default:
        return 'low'
    }
  }

  async getHistoricalLogs({
    from,
    to,
    service,
    severity,
    page,
    pageSize,
  }: {
    from: Date
    to: Date
    service?: string
    severity?: string
    page: number
    pageSize: number
  }) {
    const { skip, take } = this.paginationService.getSkipTake({ page, pageSize })

    const [logs, total] = await Promise.all([
      this.prisma.errorLogs.findMany({
        where: {
          created_at: {
            gte: from,
            lte: to,
          },
          ...(service && { service_name: service }),
          ...(severity && { severity: severity as any }),
        },
        orderBy: { created_at: 'desc' },
        skip,
        take,
      }),
      this.prisma.errorLogs.count({
        where: {
          created_at: {
            gte: from,
            lte: to,
          },
          ...(service && { service_name: service }),
          ...(severity && { severity: severity as any }),
        },
      }),
    ])

    return {
      data: logs,
      meta: this.paginationService.getPaginationMeta(total, { page, pageSize }),
      created_at: new Date().toISOString(),
    }
  }

  async getErrorPatterns() {
    try {
      const patterns = await this.prisma.errorLogs.groupBy({
        by: ['error_hash', 'error_pattern'],
        where: {
          is_new_pattern: true,
          created_at: {
            gte: new Date(Date.now() - this.RETENTION_HOURS * 3600000),
          },
        },
        _count: {
          error_hash: true,
        },
        orderBy: {
          _count: {
            error_hash: 'desc',
          },
        },
      })

      return {
        patterns: await Promise.all(
          patterns.map(async (pattern) => {
            const example = await this.prisma.errorLogs.findFirst({
              where: { error_hash: pattern.error_hash },
              select: {
                message: true,
                stack_trace: true,
                service_name: true,
                domain: true,
                created_at: true,
              },
            })

            return {
              ...pattern,
              count: pattern._count.error_hash,
              example,
            }
          }),
        ),
        created_at: new Date().toISOString(),
      }
    } catch (error) {
      this.logger.error('Failed to get error patterns', { error })
      throw error
    }
  }
}

================
File: src/monitoring/services/monitoring.service.ts
================
// src/monitoring/services/monitoring.service.ts
import { Injectable } from '@nestjs/common'

@Injectable()
export class MonitoringService {
  async getSystemMetrics() {
    return {
      timestamp: new Date(),
      // Add more system metrics here
    }
  }
}

================
File: src/monitoring/index.ts
================
/**
 * @file Auto-generated barrel file
 * @generated
 */

export * from './gateways/log.gateway'

================
File: src/monitoring/monitoring.module.ts
================
// src/monitoring/monitoring.module.ts
import { Module } from '@nestjs/common'
import { TerminusModule } from '@nestjs/terminus'
import { HttpModule } from '@nestjs/axios'
import { CoreModule } from '@core/core.module'
import { PrismaModule } from '@core/modules/prisma.module'
import { createDomainModule } from '@core/config/domain-config'
import { HealthController } from './controllers/health.controller'
import { MonitoringService } from './services/monitoring.service'
import { ErrorMetricService } from './services/error-metrics.service'
import { LogService } from './services/log.service'
import { LogController } from './controllers/log.controller'
import { ErrorMetricController } from './controllers/error-metrics.controller'
import { LogGateway } from './gateways/log.gateway'

@Module({
  imports: [
    PrismaModule,
    CoreModule,
    TerminusModule,
    HttpModule,
    createDomainModule('monitoring', {
      requiresAuth: false,
      requiresCompany: false,
    }),
  ],
  controllers: [HealthController, LogController, ErrorMetricController],
  providers: [MonitoringService, LogService, ErrorMetricService, LogGateway],
  exports: [MonitoringService, LogService, ErrorMetricService],
})
export class MonitoringModule {}

================
File: src/payments/controllers/payment.controller.ts
================
// payments.ejs template
import { Controller, Get, Query } from '@nestjs/common'
import { ApiTags, ApiOperation } from '@nestjs/swagger'
import { ConfigService } from '@nestjs/config'
import { PrismaService } from '@core/services/prisma.service'
import { PaginationService } from '@core/services/pagination.service'
import { CustomLogger } from '@core/logger/custom.logger'
import { BaseController } from '@core/base/base.controller'

import type { Prisma } from '@astronera/db'
import type { PaginatedResponse, PaginatedQuery } from '@types'
import { PaymentService } from '../services/payment.service'

@Controller('payments')
@ApiTags('Payment')
export class PaymentController extends BaseController {
  constructor(
    protected readonly paymentService: PaymentService,
    protected readonly prisma: PrismaService,
    protected readonly config: ConfigService,
    protected readonly paginationService: PaginationService,
    protected readonly logger: CustomLogger,
  ) {
    super('CustomerPayments')
  }

  @Get()
  @ApiOperation({ summary: 'Get all payments' })
  async findAllPaymentPayments(
    @Query() query: PaginatedQuery,
  ): Promise<
    PaginatedResponse<unknown> | { success: boolean; error: any; timestamp: string; code: any }
  > {
    try {
      this.logger.log('Fetching all payments')
      return super.findAll(query)
    } catch (error: any) {
      this.logger.error('Failed to fetch payments', error.stack)
      throw error
    }
  }
}

================
File: src/payments/controllers/plan.controller.ts
================
// plan.ejs template
import { Controller, Get, Param, Query } from '@nestjs/common'
import { ApiTags, ApiOperation } from '@nestjs/swagger'
import { PlanService } from '../services/plan.service'
import { ConfigService } from '@nestjs/config'
import { PrismaService } from '@core/services/prisma.service'
import { PaginationService } from '@core/services/pagination.service'
import { CustomLogger } from '@core/logger/custom.logger'
import { BaseController } from '@core/base/base.controller'

import type { Prisma } from '@astronera/db'
import type { PaginatedResponse, PaginatedQuery } from '@types'

@Controller('payments/plans')
@ApiTags('Plan')
export class PlanController extends BaseController {
  constructor(
    protected readonly planService: PlanService,
    protected readonly prisma: PrismaService,
    protected readonly config: ConfigService,
    protected readonly paginationService: PaginationService,
    protected readonly logger: CustomLogger,
  ) {
    super('CustomerSubscriptionPlans')
  }

  @Get()
  @ApiOperation({ summary: 'Get all plans' })
  async findAllPlans(
    @Query() query: PaginatedQuery,
  ): Promise<
    PaginatedResponse<unknown> | { success: boolean; error: any; timestamp: string; code: any }
  > {
    try {
      this.logger.log('Fetching all plans')
      return super.findAll(query)
    } catch (error: any) {
      this.logger.error('Failed to fetch plans', error.stack)
      throw error
    }
  }

  @Get(':id')
  @ApiOperation({ summary: 'Get plan by id' })
  async findOnePlan(@Param('id') id: number, @Query('include') include?: string[]) {
    try {
      return await super.findOne(`${id}`, include)
    } catch (error: any) {
      return this.handleError(error)
    }
  }
}

================
File: src/payments/controllers/provider.controller.ts
================
// provider.ejs template
import { Controller, Get, Param, Query } from '@nestjs/common'
import { ApiTags, ApiOperation } from '@nestjs/swagger'
import { ProviderService } from '../services/provider.service'
import { ConfigService } from '@nestjs/config'
import { PrismaService } from '@core/services/prisma.service'
import { PaginationService } from '@core/services/pagination.service'
import { CustomLogger } from '@core/logger/custom.logger'
import { BaseController } from '@core/base/base.controller'

import type { Prisma } from '@astronera/db'
import type { PaginatedResponse, PaginatedQuery } from '@types'

@Controller('payments/providers')
@ApiTags('Provider')
export class ProviderController extends BaseController {
  constructor(
    protected readonly providerService: ProviderService,
    protected readonly prisma: PrismaService,
    protected readonly config: ConfigService,
    protected readonly paginationService: PaginationService,
    protected readonly logger: CustomLogger,
  ) {
    super('PaymentProviders')
  }

  @Get()
  @ApiOperation({ summary: 'Get all payment providers' })
  async findAllPaymentProviders(
    @Query() query: PaginatedQuery,
  ): Promise<
    PaginatedResponse<unknown> | { success: boolean; error: any; timestamp: string; code: any }
  > {
    try {
      this.logger.log('Fetching all payment providers')
      return super.findAll(query)
    } catch (error: any) {
      this.logger.error('Failed to fetch payment providers', error.stack)
      throw error
    }
  }

  @Get(':id')
  @ApiOperation({ summary: 'Get payment provider by id' })
  async findOneProvider(@Param('id') id: number, @Query('include') include?: string[]) {
    try {
      return await super.findOne(`${id}`, include)
    } catch (error: any) {
      return this.handleError(error)
    }
  }
}

================
File: src/payments/controllers/refund.controller.ts
================
// provider.ejs template
import { Body, Controller, Get, Param, ParseIntPipe, Post, Put, Query } from '@nestjs/common'
import { ApiTags, ApiOperation } from '@nestjs/swagger'
import { ConfigService } from '@nestjs/config'
import { PrismaService } from '@core/services/prisma.service'
import { PaginationService } from '@core/services/pagination.service'
import { CustomLogger } from '@core/logger/custom.logger'
import { BaseController } from '@core/base/base.controller'

import type { Prisma } from '@astronera/db'
import type { PaginatedResponse, PaginatedQuery } from '@types'
import { RefundService } from '../services/refund.service'

@Controller('payments/refunds')
@ApiTags('Refund')
export class RefundController extends BaseController {
  constructor(
    protected readonly refundService: RefundService,
    protected readonly prisma: PrismaService,
    protected readonly config: ConfigService,
    protected readonly paginationService: PaginationService,
    protected readonly logger: CustomLogger,
  ) {
    super('CustomerRefunds')
  }

  @Get()
  @ApiOperation({ summary: 'Get all refunds' })
  async findAllRefunds(
    @Query() query: PaginatedQuery,
  ): Promise<
    PaginatedResponse<unknown> | { success: boolean; error: any; timestamp: string; code: any }
  > {
    try {
      this.logger.log('Fetching all plans')
      return super.findAll(query)
    } catch (error: any) {
      this.logger.error('Failed to fetch plans', error.stack)
      throw error
    }
  }

  @Get(':id')
  @ApiOperation({ summary: 'Get Refunds by id' })
  async findOneRefund(@Param('id', ParseIntPipe) id: string, @Query('include') include?: string[]) {
    try {
      return await super.findOne(id, include)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Post()
  @ApiOperation({ summary: 'Create Refund' })
  async createRefund(@Body() data: Prisma.CustomerRefundsCreateInput) {
    try {
      return await super.create(data)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Put(':id')
  @ApiOperation({ summary: 'Update Refund' })
  async updateRefund(@Param('id') id: string, @Body() data: Prisma.CustomerRefundsUpdateInput) {
    try {
      return await super.update(id, data)
    } catch (error: any) {
      return this.handleError(error)
    }
  }
}

================
File: src/payments/controllers/subscription.controller.ts
================
// provider.ejs template
import { Body, Controller, Get, Param, ParseIntPipe, Post, Put, Query } from '@nestjs/common'
import { ApiTags, ApiOperation } from '@nestjs/swagger'
import { ConfigService } from '@nestjs/config'
import { PrismaService } from '@core/services/prisma.service'
import { PaginationService } from '@core/services/pagination.service'
import { CustomLogger } from '@core/logger/custom.logger'
import { BaseController } from '@core/base/base.controller'

import type { Prisma } from '@astronera/db'
import type { PaginatedResponse, PaginatedQuery } from '@types'
import { SubscriptionService } from '../services/subscription.service'

@Controller('payments/subscriptions')
@ApiTags('Subscription')
export class SubscriptionController extends BaseController {
  constructor(
    protected readonly subscriptionService: SubscriptionService,
    protected readonly prisma: PrismaService,
    protected readonly config: ConfigService,
    protected readonly paginationService: PaginationService,
    protected readonly logger: CustomLogger,
  ) {
    super('CustomerSubscriptions')
  }

  @Get()
  @ApiOperation({ summary: 'Get all subscriptions' })
  async findAllSubscriptions(
    @Query() query: PaginatedQuery,
  ): Promise<
    PaginatedResponse<unknown> | { success: boolean; error: any; timestamp: string; code: any }
  > {
    try {
      this.logger.log('Fetching all plans')
      return super.findAll(query)
    } catch (error: any) {
      this.logger.error('Failed to fetch plans', error.stack)
      throw error
    }
  }

  @Get(':id')
  @ApiOperation({ summary: 'Get Subscriptions by id' })
  async findOneSubscription(
    @Param('id', ParseIntPipe) id: string,
    @Query('include') include?: string[],
  ) {
    try {
      return await super.findOne(id, include)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Post()
  @ApiOperation({ summary: 'Create Subscription' })
  async createSubscription(@Body() data: Prisma.CustomerSubscriptionsCreateInput) {
    try {
      return await super.create(data)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Put(':id')
  @ApiOperation({ summary: 'Update Subscription' })
  async updateSubscription(
    @Param('id', ParseIntPipe) id: string,
    @Body() data: Prisma.CustomerSubscriptionsUpdateInput,
  ) {
    try {
      return await super.update(id, data)
    } catch (error: any) {
      return this.handleError(error)
    }
  }
}

================
File: src/payments/controllers/webhook.controller.ts
================
import { Controller, Headers, Post, Body, UnauthorizedException } from '@nestjs/common'
import { CustomLogger } from '@core/logger/custom.logger'
import { Public } from '@core/decorators/public.decorator'
import { PaymentService } from '@payments/services/payment.service'
import { SubscriptionService } from '@payments/services/subscription.service'
import crypto from 'crypto'

@Controller('webhook')
@Public()
export class WebhookController {
  constructor(
    private readonly subscriptionService: SubscriptionService,
    private readonly paymentService: PaymentService,
    private readonly logger: CustomLogger,
  ) {
    this.logger.setDomain('webhook')
  }

  @Post('razorpay')
  handleWebhook(
    @Body() body: any,
    @Headers('x-razorpay-signature') razorpaySignature: string,
  ): void {
    try {
      const secret = process.env.RAZORPAY_WEBHOOK_SECRET!

      const shasum = crypto.createHmac('sha256', secret)
      shasum.update(JSON.stringify(body))
      const digest = shasum.digest('hex')

      if (digest !== razorpaySignature) {
        return
      }

      const { payload, event } = body

      switch (event) {
        case 'subscription.authenticated':
        case 'subscription.paused':
        case 'subscription.resumed':
        case 'subscription.activated':
        case 'subscription.pending':
        case 'subscription.halted':
        case 'subscription.charged':
        case 'subscription.cancelled':
        case 'subscription.completed':
        case 'subscription.updated':
          this.handleSubscriptionUpdate(payload)
          break
        default:
          console.warn(`Unhandled event type: ${event}`)
      }
    } catch (error: any) {
      this.logger.error('Unauthorized Webhook', error.stack)
      throw new UnauthorizedException('Invalid token')
    }
  }

  private handlePaymentUpdate(payment: any): void {
    const data = {
      external_payment_id: payment.id,
      user_id: payment.user_id,
      subscription_id: payment.subscription_id,
      payment_provider_id: payment.payment_provider_id,
      external_order_id: payment.order_id,
      amount: payment.amount / 100, // Razorpay gets the value in paise
      currency: payment.currency,
      status: payment.status,
      method: payment.method,
      description: payment.description,
      fee: payment.fee,
      tax: payment.tax,
      error_code: payment.error_code,
      error_description: payment.error_description,
      acquirer_data: payment.acquirer_data,
      notes: payment.notes,
      created_at: new Date(payment.created_at * 1000),
      order_id: payment.order_id,
      invoice_id: payment.invoice_id,
      international: payment.international,
      amount_refunded: payment.amount_refunded,
      amount_transferred: payment.amount_transferred,
      refund_status: payment.refund_status,
      captured: !!payment.captured,
      bank: payment.bank,
      wallet: payment.wallet,
      vpa: payment.vpa,
      error_source: payment.error_source,
      error_step: payment.error_step,
      error_reason: payment.error_reason,
    }

    this.paymentService.updatePayment(data)
  }

  private async handleSubscriptionUpdate(payload: any): Promise<void> {
    const { entity: subscriptionPayload } = payload.subscription
    console.log(payload, 'PAYLOAD')
    console.log(subscriptionPayload, 'SUBSCRIPTION PAYLOAD')

    const data = {
      external_subscription_id: subscriptionPayload.id,
      status: subscriptionPayload.status,
      quantity: subscriptionPayload.quantity,
      charge_at: new Date(subscriptionPayload.charge_at * 1000),
      start_at: new Date(subscriptionPayload.start_at * 1000),
      end_at: new Date(subscriptionPayload.end_at * 1000),
      total_count: subscriptionPayload.total_count,
      paid_count: subscriptionPayload.paid_count,
      remaining_count: subscriptionPayload.remaining_count,
      customer_notify: subscriptionPayload.customer_notify,
      created_at: new Date(subscriptionPayload.created_at * 1000),
      expire_by: subscriptionPayload.expire_by
        ? new Date(subscriptionPayload.expire_by * 1000)
        : null,
      short_url: subscriptionPayload.short_url,
      has_scheduled_changes: subscriptionPayload.has_scheduled_changes,
      change_scheduled_at: subscriptionPayload.change_scheduled_at
        ? new Date(subscriptionPayload.change_scheduled_at * 1000)
        : null,
      source: subscriptionPayload.source,
      offer_id: subscriptionPayload.offer_id,
    }

    this.subscriptionService.updateSubscription(data)

    if (payload.payment) {
      const { entity: payment } = payload.payment

      const subscription = await this.subscriptionService.findOne({
        where: {
          id: subscriptionPayload.id,
          user_id: subscriptionPayload.user_id,
        },
      })

      payment.user_id = subscription.user_id
      payment.payment_provider_id = subscription.payment_provider_id
      payment.subscription_id = subscription.id

      this.handlePaymentUpdate(payment)
    }
  }
}

================
File: src/payments/models/payment.model.ts
================
// templates/entity/model.ejs
import { BaseModel } from '@core'

// Model interface
export interface PaymentModel extends BaseModel {
  id: number,
  user_id: string,
  subscription_id: number,
  payment_provider_id: number,
  external_payment_id: string,
  external_order_id: string,
  amount: number,
  currency: string,
  status: string,
  method: string,
  description: string,
  fee: number,
  tax: number,
  error_code: string,
  error_description: string,
  acquirer_data: Record<string, any>,
  notes: Record<string, any>,
  created_at: Date,
  order_id: string,
  invoice_id: string,
  international: boolean,
  amount_refunded: number,
  amount_transferred: number,
  refund_status: string,
  captured: boolean,
  bank: string,
  wallet: string,
  vpa: string,
  error_source: string,
  error_step: string,
  error_reason: string,
}

================
File: src/payments/models/plan.model.ts
================
// templates/entity/model.ejs
import { BaseModel } from '@core'

// Model interface
export interface PlanModel extends BaseModel {
  id: string
  external_plan_id: string
  name: string
  description: string
  interval: number
  interval_type: string
  monthly_amount: number
  annual_amount: number
  current: string
  features: string[]
  is_active: boolean
  created_at: Date
  updated_at?: Date
}

================
File: src/payments/models/provider.model.ts
================
// templates/entity/model.ejs
import { BaseModel } from '@core'

// Model interface
export interface ProviderModel extends BaseModel {
  id: string
  name: string
  is_active: boolean
  created_at: Date
  updated_at?: Date
}

================
File: src/payments/models/refund.model.ts
================
// templates/entity/model.ejs
import { BaseModel } from '@core'

// Model interface
export interface RefundModel extends BaseModel {
  acquirer_data: Record<string, any>
  amount: number
  batch_id: string
  created_at: Date
  currency: string
  external_refund_id: string
  id: number
  notes: Record<string, any>
  payment_id: number
  receipt: string
  speed_processed: string
  speed_requested: string
  status: string
}

================
File: src/payments/models/subscription.model.ts
================
// templates/entity/model.ejs
import { BaseModel } from '@core'
import { SubscriptionStatus } from 'src/types/subscription.types'
import { PlanModel } from './plan.model'
import { ProviderModel } from './provider.model'

// Model interface
export interface SubscriptionModel extends BaseModel {
  id: string
  external_subscription_id: string
  name: string
  status: SubscriptionStatus
  quantity: number

  cancel_at_period_end: boolean
  total_count: number
  paid_count: number
  remaining_count: number
  auth_attempts: number
  type: number
  customer_notify: boolean
  short_url: string
  has_scheduled_changes: boolean
  source: string
  offer_id: string
  pause_initiated_by: string
  cancel_initiated_by: string
  notes?: Record<string, any>
  
  
  created_at: Date
  updated_at?: Date
  start_at: Date
  end_at: Date
  change_scheduled_at: Date
  charge_at: Date
  ended_at: Date
  current_start?: Date
  current_end?: Date
  expire_by: Date

  user_id: string
  plan_id: number
  payment_provider_id: number

  plan: PlanModel
  provider: ProviderModel
}

================
File: src/payments/services/payment.service.ts
================
// templates/service/service.ejs
import { Injectable } from '@nestjs/common'
import type { Prisma } from '@astronera/db'
import { BaseService } from '@core/base/base.service'
import { PaginationService } from '@core/services/pagination.service'
import { PrismaService } from '@core/services/prisma.service'
import type { PaymentModel } from '../models/payment.model'

@Injectable()
export class PaymentService extends BaseService<'CustomerPayments'> {
  constructor(
    protected readonly prisma: PrismaService,
    protected readonly paginationService: PaginationService,
  ) {
    super('CustomerPayments')
  }

  async updatePayment(data) {
    const result = await this.prisma.customerPayments.upsert({
      where: {
        id: data.id,
        external_payment_id: data.external_payment_id,
      },
      update: data,
      create: data,
    })

    return result
  }

  async findWithRelations(id: number): Promise<PaymentModel | null> {
    const result = await this.prisma.customerPayments.findUnique({
      where: { id },
    })
    return result ? this.mapToModel(result) : null
  }

  async findMany(params: Prisma.CustomerPaymentsFindManyArgs): Promise<PaymentModel[]> {
    const items = await this.prisma.customerPayments.findMany(params)
    return items.map((item) => this.mapToModel(item))
  }

  async findAllPayments(
    query: Prisma.CustomerPaymentsFindManyArgs,
  ): Promise<{ items: PaymentModel[]; total: number }> {
    const [items, total] = await Promise.all([
      this.prisma.customerPayments.findMany({
        skip: query.skip,
        take: query.take,
        where: query.where,
        orderBy: query.orderBy,
      }),
      this.prisma.customerPayments.count({ where: query.where }),
    ])

    return {
      items: items.map((item) => this.mapToModel(item)),
      total,
    }
  }

  private mapToModel(data: any): PaymentModel {
    return {
      ...data,
    }
  }
}

================
File: src/payments/services/plan.service.ts
================
// templates/service/service.ejs
import { Injectable } from '@nestjs/common'
import type { Prisma } from '@astronera/db'
import { BaseService } from '@core/base/base.service'
import { PaginationService } from '@core/services/pagination.service'
import { PrismaService } from '@core/services/prisma.service'
import type { PlanModel } from '../models/plan.model'

@Injectable()
export class PlanService extends BaseService<'CustomerSubscriptionPlans'> {
  constructor(
    protected readonly prisma: PrismaService,
    protected readonly paginationService: PaginationService,
  ) {
    super('CustomerSubscriptionPlans')
  }

  async findWithRelations(id: number): Promise<PlanModel | null> {
    const result = await this.prisma.customerSubscriptionPlans.findUnique({
      where: { id },
    })
    return result ? this.mapToModel(result) : null
  }

  async findMany(params: Prisma.CustomerSubscriptionPlansFindManyArgs): Promise<PlanModel[]> {
    const items = await this.prisma.customerSubscriptionPlans.findMany(params)
    return items.map((item) => this.mapToModel(item))
  }

  async findAllPlans(
    query: Prisma.CustomerSubscriptionPlansFindManyArgs,
  ): Promise<{ items: PlanModel[]; total: number }> {
    const [items, total] = await Promise.all([
      this.prisma.customerSubscriptionPlans.findMany({
        skip: query.skip,
        take: query.take,
        where: query.where,
        orderBy: query.orderBy,
      }),
      this.prisma.customerSubscriptionPlans.count({ where: query.where }),
    ])

    return {
      items: items.map((item) => this.mapToModel(item)),
      total,
    }
  }

  private mapToModel(data: any): PlanModel {
    return {
      ...data,
    }
  }
}

================
File: src/payments/services/provider.service.ts
================
// templates/service/service.ejs
import { Injectable } from '@nestjs/common'
import type { Prisma } from '@astronera/db'
import { BaseService } from '@core/base/base.service'
import { PaginationService } from '@core/services/pagination.service'
import { PrismaService } from '@core/services/prisma.service'
import type { ProviderModel } from '../models/provider.model'

@Injectable()
export class ProviderService extends BaseService<'PaymentProviders'> {
  constructor(
    protected readonly prisma: PrismaService,
    protected readonly paginationService: PaginationService,
  ) {
    super('PaymentProviders')
  }

  async findWithRelations(id: number): Promise<ProviderModel | null> {
    const result = await this.prisma.paymentProviders.findUnique({
      where: { id },
    })
    return result ? this.mapToModel(result) : null
  }

  async findMany(params: Prisma.PaymentProvidersFindManyArgs): Promise<ProviderModel[]> {
    const items = await this.prisma.paymentProviders.findMany(params)
    return items.map((item) => this.mapToModel(item))
  }

  async findAllProviders(
    query: Prisma.PaymentProvidersFindManyArgs,
  ): Promise<{ items: ProviderModel[]; total: number }> {
    const [items, total] = await Promise.all([
      this.prisma.paymentProviders.findMany({
        skip: query.skip,
        take: query.take,
        where: query.where,
        orderBy: query.orderBy,
      }),
      this.prisma.paymentProviders.count({ where: query.where }),
    ])

    return {
      items: items.map((item) => this.mapToModel(item)),
      total,
    }
  }

  private mapToModel(data: any): ProviderModel {
    return {
      ...data,
    }
  }
}

================
File: src/payments/services/refund.service.ts
================
// templates/service/service.ejs
import { Injectable } from '@nestjs/common'
import type { Prisma } from '@astronera/db'
import { BaseService } from '@core/base/base.service'
import { PaginationService } from '@core/services/pagination.service'
import { PrismaService } from '@core/services/prisma.service'
import type { RefundModel } from '../models/refund.model'

@Injectable()
export class RefundService extends BaseService<'CustomerRefunds'> {
  constructor(
    protected readonly prisma: PrismaService,
    protected readonly paginationService: PaginationService,
  ) {
    super('CustomerRefunds')
  }

  async findWithRelations(id: number): Promise<RefundModel | null> {
    const result = await this.prisma.customerRefunds.findUnique({
      where: { id },
      include: {
        customer_payments: true,
      },
    })

    return result ? this.mapToModel(result) : null
  }

  async findMany(params: Prisma.CustomerRefundsFindManyArgs): Promise<RefundModel[]> {
    const items = await this.prisma.customerRefunds.findMany(params)
    return items.map((item) => this.mapToModel(item))
  }

  async findAllRefunds(
    query: Prisma.CustomerRefundsFindManyArgs,
  ): Promise<{ items: RefundModel[]; total: number }> {
    const [items, total] = await Promise.all([
      this.prisma.customerRefunds.findMany({
        skip: query.skip,
        take: query.take,
        where: query.where,
        orderBy: query.orderBy,
      }),
      this.prisma.customerRefunds.count({ where: query.where }),
    ])

    return {
      items: items.map((item) => this.mapToModel(item)),
      total,
    }
  }

  private mapToModel(data: any): RefundModel {
    return {
      ...data,
    }
  }
}

================
File: src/payments/services/subscription.service.ts
================
// templates/service/service.ejs
import { Injectable } from '@nestjs/common'
import type { Prisma } from '@astronera/db'
import { BaseService } from '@core/base/base.service'
import { PaginationService } from '@core/services/pagination.service'
import { PrismaService } from '@core/services/prisma.service'
import type { SubscriptionModel } from '../models/subscription.model'

@Injectable()
export class SubscriptionService extends BaseService<'CustomerSubscriptions'> {
  constructor(
    protected readonly prisma: PrismaService,
    protected readonly paginationService: PaginationService,
  ) {
    super('CustomerSubscriptions')
  }

  async updateSubscription(data) {
    const result = await this.prisma.customerSubscriptions.update({
      where: { id: data.id, user_id: data.user_id, external_subscription_id: data.external_subscription_id },
      data,
    })

    return result
  }

  async findWithRelations(id: number): Promise<SubscriptionModel | null> {
    const result = await this.prisma.customerSubscriptions.findUnique({
      where: { id },
      include: {
        customer_subscription_plans: true,
        payment_providers: true,
      },
    })

    return result ? this.mapToModel(result) : null
  }

  async findOne(params: Prisma.CustomerSubscriptionsFindUniqueArgs): Promise<SubscriptionModel> {
    const result = await this.prisma.customerSubscriptions.findUnique({
      ...params,
      include: {
        payment_providers: true,
      },
    })

    return result ? this.mapToModel(result) : null
  }

  async findMany(
    params: Prisma.CustomerSubscriptionsFindManyArgs,
  ): Promise<SubscriptionModel[]> {
    const items = await this.prisma.customerSubscriptions.findMany(params)
    return items.map((item) => this.mapToModel(item))
  }

  async findAllSubscriptions(
    query: Prisma.CustomerSubscriptionsFindManyArgs,
  ): Promise<{ items: SubscriptionModel[]; total: number }> {
    const [items, total] = await Promise.all([
      this.prisma.customerSubscriptions.findMany({
        skip: query.skip,
        take: query.take,
        where: query.where,
        orderBy: query.orderBy,
      }),
      this.prisma.customerSubscriptions.count({ where: query.where }),
    ])

    return {
      items: items.map((item) => this.mapToModel(item)),
      total,
    }
  }

  private mapToModel(data: any): SubscriptionModel {
    return {
      ...data,
    }
  }
}

================
File: src/payments/index.ts
================
export * from './models/payment.model';
export * from './models/plan.model';
export * from './models/provider.model';
export * from './models/refund.model';
export * from './models/subscription.model';

================
File: src/payments/payment.module.ts
================
// templates/module/content.module.ejs
import { Module } from '@nestjs/common'
import { CoreModule } from '@core/core.module'
import { PrismaModule } from '@core/modules/prisma.module'
import { PermissionModule } from '@core/modules/permission.module'
import { createDomainModule } from '@core/config/domain-config'
// Controllers
import { PaymentController } from '@payments/controllers/payment.controller'
import { PlanController } from '@payments/controllers/plan.controller'
import { ProviderController } from '@payments/controllers/provider.controller'
import { RefundController } from '@payments/controllers/refund.controller'
import { SubscriptionController } from '@payments/controllers/subscription.controller'

// Services
import { PaymentService } from '@payments/services/payment.service'
import { PlanService } from '@payments/services/plan.service'
import { ProviderService } from '@payments/services/provider.service'
import { RefundService } from '@payments/services/refund.service'
import { SubscriptionService } from '@payments/services/subscription.service'
import { WebhookModule } from '@core/webhook/webhook.module'
import { WebhookController } from './controllers/webhook.controller'

@Module({
  imports: [
    PrismaModule,
    PermissionModule,
    CoreModule,
    WebhookModule,
    createDomainModule('content', {
      requiresAuth: true,
      requiresCompany: false,
    }),
  ],
  controllers: [
    PaymentController,
    PlanController,
    ProviderController,
    RefundController,
    SubscriptionController,
    WebhookController
  ],
  providers: [
    PaymentService,
    PlanService,
    ProviderService,
    RefundService,
    SubscriptionService,
  ],
  exports: [
    PaymentService,
    PlanService,
    ProviderService,
    RefundService,
    SubscriptionService
  ],
})
export class PaymentsModule {}

================
File: src/types/domain.types.ts
================
// Original interfaces remain the same
export interface DomainConfig {
  requiresAuth: boolean
  defaultPermissions: string[]
  supportsSoftDelete?: boolean
  supportsVersioning?: boolean
  requiresCompany?: boolean
  requiresUser?: boolean
  requiresEncryption?: boolean
  supportsCaching?: boolean
  requiresAdmin?: boolean
  sensitiveFields?: string[]
  exclude?: boolean
}

export interface CrossDomainConfig {
  allowedRelations: string[]
  implicitRelations?: {
    user?: boolean
    company?: boolean
  }
}

export interface LoggerConfig {
  domainName: string
  subContexts?: string[]
}

================
File: src/types/index.ts
================
/**
 * @file Auto-generated barrel file
 * @generated
 */

export * from './domain.types'
export * from './pagination.types'
export * from './permission.types'
export * from './plan.types'
export * from './subscription.types'

================
File: src/types/pagination.types.ts
================
export interface PaginatedResponse<T> {
  data: T[]
  meta: PaginationMeta
  success: boolean
  timestamp: string
  debug?: {
    permissions: {
      isPublic: boolean
      endpoint: string
      handler: string
      controller: string
      user?: {
        role: string
        email: string
      }
      roleHierarchy?: string[]
    }
    timestamp: string
  }
}

export interface PaginationMeta {
  total: number
  totalPages: number
  page: number
  limit: number
  hasNextPage: boolean
  hasPreviousPage: boolean
}

export interface PaginatedQuery {
  page?: number | string
  limit?: number | string
  sortBy?: string
  sortOrder?: 'asc' | 'desc'
  search?: string
  [key: string]: any
}

================
File: src/types/permission.types.ts
================
// types/permission.types.ejs
export enum PermissionAction {
  CREATE = 'CREATE',
  READ = 'READ',
  UPDATE = 'UPDATE',
  DELETE = 'DELETE',
  MANAGE = 'MANAGE',
}

export enum ResourceType {
  USER = 'USER',
  CONTENT = 'CONTENT',
  SETTINGS = 'SETTINGS',
  BILLING = 'BILLING',
}

export interface Permission {
  action: PermissionAction
  resource: ResourceType
  conditions?: Record<string, any>
}

export type DatabaseAction = 'select' | 'insert' | 'update' | 'delete'

export interface PermissionCondition {
  sql: string
}

export interface TokenPayload {
  role: string
  user_id: string
  email: string
  aud: string
  exp: number
}

export interface AuthError extends Error {
  status: number
  code: string
}

================
File: src/types/plan.types.ts
================
// types/plan.types.ejs
export enum PlanType {
  FREE = 'FREE',
  BASIC = 'BASIC',
  PREMIUM = 'PREMIUM',
  ENTERPRISE = 'ENTERPRISE',
}

export interface PlanFeature {
  name: string
  limit?: number
  enabled: boolean
}

export interface Plan {
  id: string
  name: string
  type: PlanType
  features: PlanFeature[]
  price: number
}

================
File: src/types/subscription.types.ts
================
// types/plan.types.ejs
export enum SubscriptionStatus {
  CREATED = 'CREATED',
  AUTHENTICATED = 'AUTHENTICATED',
  CHARGED = 'CHARGED',
  COMPLETED = 'COMPLETED',
  EXPIRED='EXPIRED',
  CANCELED='CANCELED',
}

================
File: src/app.module.ts
================
// app.module.ts
import * as path from 'path'
import { Module } from '@nestjs/common'
import { APP_GUARD } from '@nestjs/core'
import { ConfigModule } from '@nestjs/config'
import { ThrottlerModule } from '@nestjs/throttler'

import configuration from '@core/config/configuration'
import { CustomLogger } from '@core/logger/custom.logger'
// GUARDS
import { PermissionGuard } from '@core/guards/permission.guard'
// CORE modules
import { LoggerModule } from '@core/modules/logger.module'
import { PrismaModule } from '@core/modules/prisma.module'
import { CoreModule } from '@core/core.module'
// Feature modules
import { ContentModule } from '@content/content.module'
import { MonitoringModule } from '@monitoring/monitoring.module'
// New modules (for caching & jobs)
import { RedisModule } from '@core/cache/cache.module'
import { PaymentsModule } from '@payments/payment.module'
import { JobModule } from '@jobs/job.module'

@Module({
  imports: [
    // 1) Global config
    ConfigModule.forRoot({
      isGlobal: true,
      load: [configuration],
      envFilePath: path.resolve(__dirname, '../../../.env'),
      cache: true,
    }),

    // 2) Core modules & services
    PrismaModule,
    CoreModule,
    LoggerModule,

    // 3) Feature modules
    ContentModule,
    MonitoringModule,
    JobModule,
    PaymentsModule,

    // 4) Rate limiting
    ThrottlerModule.forRoot([
      {
        ttl: 60,
        limit: 10,
      },
    ]),

    // 5) Our new caching & jobs modules
    RedisModule,
  ],
  providers: [
    {
      provide: APP_GUARD,
      useClass: PermissionGuard,
    },
    {
      provide: CustomLogger,
      useValue: new CustomLogger(''),
    },
  ],
})
export class AppModule {}

================
File: src/main.ts
================
// main.ts
import { NestFactory } from '@nestjs/core'
import { ValidationPipe } from '@nestjs/common'
import tcpPortUsed from 'tcp-port-used'
import { SwaggerModule, DocumentBuilder } from '@nestjs/swagger'
import { ConfigService } from '@nestjs/config'
import compression from 'compression'

import { HttpExceptionFilter } from '@core/filters/http-exception.filter'
import { LoggingInterceptor } from '@core/interceptors/logging.interceptor'
import { CustomLogger } from '@core/logger/custom.logger'
import { PaginationInterceptor } from '@core/interceptors/pagination.interceptor'
import { TrimPipe } from '@core/pipes/trim.pipe'
import helmet from 'helmet'
import { IoAdapter } from '@nestjs/platform-socket.io'

// INTERCEPTORS
import { BigIntSerializationInterceptor } from '@core/interceptors/bigint.interceptor'
import { AppModule } from './app.module'
import { Logger } from '@nestjs/common'

Logger.overrideLogger(['log', 'error', 'warn', 'debug', 'verbose'])

async function bootstrap() {
  // Create the app with custom logger
  const logger = new CustomLogger('Bootstrap')
  const app = await NestFactory.create(AppModule, {
    logger,
  })

  app.useWebSocketAdapter(new IoAdapter(app))

  // Debug middleware
  // CORS Configuration - Let's use enableCors() instead of manual middleware
  app.enableCors({
    origin: [
      'https://admin.astronera.org',
      'https://app.astronera.org',
      'http://localhost:3000',
      'http://localhost:3009',
      'http://localhost:3001',
      'http://localhost:3002',
      'http://localhost:3003',
      'http://localhost:4200',
    ],
    methods: ['GET', 'HEAD', 'PUT', 'PATCH', 'POST', 'DELETE', 'OPTIONS'],
    allowedHeaders: [
      'Content-Type',
      'Accept',
      'Authorization',
      'x-api-key',
      'Origin',
      'baggage',
      'sentry-trace',
      'X-Requested-With',
      'Access-Control-Request-Method',
      'Access-Control-Request-Headers',
      'Upgrade',
      'Connection',
    ],
    exposedHeaders: ['Content-Range', 'X-Content-Range'],
    credentials: true,
    preflightContinue: false,
    optionsSuccessStatus: 204,
  })

  app.use((req, res, next) => {
    const logger = new CustomLogger('HTTP')
    logger.debug(`${req.method} ${req.path}`, {
      origin: req.headers.origin,
      method: req.method,
      path: req.path,
    })
    next()
  })

  const configService = app.get(ConfigService)

  // Security
  app.use(
    helmet({
      crossOriginEmbedderPolicy: false,
      crossOriginOpenerPolicy: false,
      crossOriginResourcePolicy: false,
      contentSecurityPolicy: {
        directives: {
          defaultSrc: ["'self'"],
          scriptSrc: ["'self'", "'unsafe-inline'", "'unsafe-eval'"],
          styleSrc: ["'self'", "'unsafe-inline'"],
          imgSrc: ["'self'", 'data:', 'https:'],
          connectSrc: ["'self'", 'wss:', 'ws:', '*.astronera.org'],
        },
      },
    }),
  )
  app.use(compression())

  // Global filters
  app.useGlobalFilters(new HttpExceptionFilter(new CustomLogger()))

  // Global interceptors
  app.useGlobalInterceptors(
    new BigIntSerializationInterceptor(),
    new LoggingInterceptor(new CustomLogger()),
    new PaginationInterceptor(),
  )

  // Global pipes
  app.useGlobalPipes(
    new ValidationPipe({
      transform: true,
      whitelist: true,
      forbidNonWhitelisted: true,
      transformOptions: {
        enableImplicitConversion: true,
      },
    }),
    new TrimPipe(),
  )

  // ToDo - add favicon to public folder
  app.use('/favicon.ico', (req, res) => {
    res.status(204).end()
  })
  // API Prefix
  app.setGlobalPrefix('api/v1')

  // Swagger Setup
  const config = new DocumentBuilder()
    .setTitle('API Documentation')
    .setDescription('The API description')
    .setVersion('1.0')
    .addTag('api')
    .addBearerAuth()
    .addApiKey({ type: 'apiKey', name: 'x-api-key', in: 'header' }, 'api-key')
    .build()

  const document = SwaggerModule.createDocument(app, config)
  SwaggerModule.setup('docs', app, document)

  // Startup
  const port = process.env.PORT || 8080
  const host = process.env.HOST ?? 'localhost' // Important for Railway
  console.log('Starting application on:', host, port)

  try {
    const inUse = await tcpPortUsed.check(Number(port), host)
    console.log('Port status:', { port, inUse })
    if (inUse) {
      console.error(`Port ${port} is already in use!`)
      process.exit(1)
    }
  } catch (error) {
    console.error('Error checking port:', error)
  }

  const listenPromise = app.listen(Number(port), host)
  const timeoutPromise = new Promise((_, reject) => {
    setTimeout(() => reject(new Error('Listen timeout after 10 seconds')), 10000)
  })
  try {
    await Promise.race([listenPromise, timeoutPromise])
    console.log('Listen successful!')
  } catch (error) {
    console.error('Listen failed or timed out:', error)
    throw error
  }

  console.log('12. Bootstrap process complete!')
}

bootstrap().catch((error: any) => {
  console.error('Bootstrap failed with error:', {
    message: error.message,
    stack: error.stack,
    code: error.code,
    errno: error.errno,
  })
  process.exit(1)
})

================
File: src/metadata.ts
================
/* eslint-disable */
export default async () => {
    const t = {};
    return { "@nestjs/swagger": { "models": [[import("./core/dto/pagination.dto"), { "PaginationParams": { page: { required: false, type: () => Number, default: 1 }, limit: { required: false, type: () => Number, default: 10 }, sort: { required: false, type: () => String }, search: { required: false, type: () => String }, order: { required: false, type: () => String }, include: { required: false, type: () => Object } } }]], "controllers": [[import("./core/base/base.controller"), { "BaseController": {} }], [import("./content/controllers/research-embeddings.controller"), { "ResearchEmbeddingController": { "findAllResearchEmbeddings": { type: Object }, "findOneResearchEmbeddings": { type: Object }, "createResearchEmbeddings": { type: Object }, "updateResearchEmbeddings": { type: Object }, "removeResearchEmbeddings": { type: Object } } }], [import("./content/controllers/embedding-reviews.controller"), { "EmbeddingReviewController": { "findAllEmbeddingReviews": { type: Object }, "findOneEmbeddingReviews": { type: Object }, "createEmbeddingReviews": { type: Object }, "updateEmbeddingReviews": { type: Object }, "removeEmbeddingReviews": { type: Object } } }], [import("./content/controllers/content-categories.controller"), { "ContentCategoryController": { "findAllContentCategories": { type: Object }, "findOneContentCategories": { type: Object }, "createContentCategories": { type: Object }, "updateContentCategories": { type: Object }, "removeContentCategories": { type: Object } } }], [import("./content/controllers/content-tags.controller"), { "ContentTagController": { "findAllContentTags": { type: Object }, "findOneContentTags": { type: Object }, "createContentTags": { type: Object }, "updateContentTags": { type: Object }, "removeContentTags": { type: Object } } }], [import("./content/controllers/content-statuses.controller"), { "ContentStatusController": { "findAllContentStatuses": { type: Object }, "findOneContentStatuses": { type: Object }, "createContentStatuses": { type: Object }, "updateContentStatuses": { type: Object }, "removeContentStatuses": { type: Object } } }], [import("./content/controllers/newsletters.controller"), { "NewsletterController": { "findAllNewsletters": { type: Object }, "findOneNewsletters": { type: Object }, "createNewsletters": { type: Object }, "updateNewsletters": { type: Object }, "removeNewsletters": { type: Object } } }], [import("./content/controllers/research.controller"), { "ResearchController": { "findAllResearch": { type: Object }, "findOneResearch": { type: Object }, "createResearch": { type: Object }, "updateResearch": { type: Object }, "removeResearch": { type: Object } } }], [import("./content/controllers/categories.controller"), { "CategoryController": { "findAllCategories": { type: Object }, "findOneCategories": { type: Object }, "createCategories": { type: Object }, "updateCategories": { type: Object }, "removeCategories": { type: Object } } }], [import("./content/controllers/feed-categories.controller"), { "FeedCategoryController": { "findAllFeedCategories": { type: Object }, "findOneFeedCategories": { type: Object }, "createFeedCategories": { type: Object }, "updateFeedCategories": { type: Object }, "removeFeedCategories": { type: Object } } }], [import("./content/controllers/feeds.controller"), { "FeedController": { "findAllFeeds": { type: Object }, "findOneFeeds": { type: Object }, "createFeeds": { type: Object }, "updateFeeds": { type: Object }, "removeFeeds": { type: Object } } }], [import("./content/controllers/content-sources.controller"), { "ContentSourceController": { "findAllContentSources": { type: Object }, "findOneContentSources": { type: Object }, "createContentSources": { type: Object }, "updateContentSources": { type: Object }, "removeContentSources": { type: Object } } }], [import("./content/controllers/tags.controller"), { "TagController": { "findAllTags": { type: Object }, "findOneTags": { type: Object }, "createTags": { type: Object }, "updateTags": { type: Object }, "removeTags": { type: Object } } }], [import("./content/controllers/news.controller"), { "NewsController": { "findAllNews": { type: Object }, "findOneNews": { type: Object }, "createNews": { type: Object }, "updateNews": { type: Object }, "removeNews": { type: Object } } }], [import("./content/controllers/news-tags.controller"), { "NewsTagController": { "findAllNewsTags": { type: Object }, "findOneNewsTags": { type: Object }, "createNewsTags": { type: Object }, "updateNewsTags": { type: Object }, "removeNewsTags": { type: Object } } }], [import("./content/controllers/content-source-visits.controller"), { "ContentSourceVisitController": { "findAllContentSourceVisits": { type: Object }, "findOneContentSourceVisits": { type: Object }, "createContentSourceVisits": { type: Object }, "updateContentSourceVisits": { type: Object }, "removeContentSourceVisits": { type: Object } } }], [import("./content/controllers/feed-sources.controller"), { "FeedSourceController": { "findAllFeedSources": { type: Object }, "findOneFeedSources": { type: Object }, "createFeedSources": { type: Object }, "updateFeedSources": { type: Object }, "removeFeedSources": { type: Object } } }], [import("./content/controllers/content.controller"), { "ContentController": { "getAllContent": {}, "findOneContents": { type: Object }, "createContents": { type: Object }, "updateContents": { type: Object }, "removeContents": { type: Object } } }], [import("./content/controllers/news-summaries.controller"), { "NewsSummaryController": { "findAllNewsSummaries": { type: Object }, "findOneNewsSummaries": { type: Object }, "createNewsSummaries": { type: Object }, "updateNewsSummaries": { type: Object }, "removeNewsSummaries": { type: Object } } }], [import("./monitoring/controllers/health.controller"), { "HealthController": { "check": { type: Object }, "options": { type: String } } }]] } };
};

================
File: src/tree.txt
================
.
├── app.module.ts
├── audit.log
├── content
│   ├── __tests__
│   │   ├── categories.test.ts
│   │   ├── content-categories.test.ts
│   │   ├── content-source-visits.test.ts
│   │   ├── content-sources.test.ts
│   │   ├── content-statuses.test.ts
│   │   ├── content-tags.test.ts
│   │   ├── contents.test.ts
│   │   ├── embedding-reviews.test.ts
│   │   ├── feed-categories.test.ts
│   │   ├── feed-sources.test.ts
│   │   ├── feeds.test.ts
│   │   ├── news-summaries.test.ts
│   │   ├── news-tags.test.ts
│   │   ├── news.test.ts
│   │   ├── newsletters.test.ts
│   │   ├── research-embeddings.test.ts
│   │   ├── research.test.ts
│   │   ├── tags.test.ts
│   │   └── utils
│   │       ├── sample-data.utils.ts
│   │       └── test.utils.ts
│   ├── content.module.ts
│   ├── controllers
│   │   ├── categories.controller.ts
│   │   ├── content-categories.controller.ts
│   │   ├── content-source-visits.controller.ts
│   │   ├── content-sources.controller.ts
│   │   ├── content-statuses.controller.ts
│   │   ├── content-tags.controller.ts
│   │   ├── contents.controller.ts
│   │   ├── embedding-reviews.controller.ts
│   │   ├── feed-categories.controller.ts
│   │   ├── feed-sources.controller.ts
│   │   ├── feeds.controller.ts
│   │   ├── news-summaries.controller.ts
│   │   ├── news-tags.controller.ts
│   │   ├── news.controller.ts
│   │   ├── newsletters.controller.ts
│   │   ├── research-embeddings.controller.ts
│   │   ├── research.controller.ts
│   │   └── tags.controller.ts
│   ├── dto
│   ├── index.ts
│   ├── models
│   │   ├── categories.model.ts
│   │   ├── content-categories.model.ts
│   │   ├── content-source-visits.model.ts
│   │   ├── content-sources.model.ts
│   │   ├── content-statuses.model.ts
│   │   ├── content-tags.model.ts
│   │   ├── contents.model.ts
│   │   ├── embedding-reviews.model.ts
│   │   ├── feed-categories.model.ts
│   │   ├── feed-sources.model.ts
│   │   ├── feeds.model.ts
│   │   ├── news-summaries.model.ts
│   │   ├── news-tags.model.ts
│   │   ├── news.model.ts
│   │   ├── newsletters.model.ts
│   │   ├── research-embeddings.model.ts
│   │   ├── research.model.ts
│   │   └── tags.model.ts
│   └── services
│       ├── categories.service.ts
│       ├── content-categories.service.ts
│       ├── content-source-visits.service.ts
│       ├── content-sources.service.ts
│       ├── content-statuses.service.ts
│       ├── content-tags.service.ts
│       ├── contents.service.ts
│       ├── embedding-reviews.service.ts
│       ├── feed-categories.service.ts
│       ├── feed-sources.service.ts
│       ├── feeds.service.ts
│       ├── news-summaries.service.ts
│       ├── news-tags.service.ts
│       ├── news.service.ts
│       ├── newsletters.service.ts
│       ├── research-embeddings.service.ts
│       ├── research.service.ts
│       └── tags.service.ts
├── core
│   ├── __tests__
│   │   ├── permission.guard.test.ts
│   │   └── permission.service.test.ts
│   ├── base
│   │   ├── base.controller.ts
│   │   ├── base.model.ts
│   │   └── base.service.ts
│   ├── config
│   │   ├── configuration.ts
│   │   └── domain-config.ts
│   ├── core.module.ts
│   ├── decorators
│   │   ├── current-user.decorator.ts
│   │   ├── permissions.decorator.ts
│   │   ├── plan.decorator.ts
│   │   ├── roles.decorator.ts
│   │   └── validate.decorator.ts
│   ├── dto
│   │   └── pagination.dto.ts
│   ├── filters
│   │   └── http-exception.filter.ts
│   ├── guards
│   │   ├── permission.guard.ts
│   │   ├── plan.guard.ts
│   │   └── throttler.guard.ts
│   ├── index.ts
│   ├── interceptors
│   │   ├── logging.interceptor.ts
│   │   └── pagination.interceptor.ts
│   ├── logger
│   │   ├── custom.logger.ts
│   │   ├── logger.colors.ts
│   │   └── logger.module.ts
│   ├── middleware
│   ├── permission.module.ts
│   ├── pipes
│   │   ├── transformation.pipe.ts
│   │   ├── trim.pipe.ts
│   │   ├── type-conversion.pipe.ts
│   │   └── validation.pipe.ts
│   ├── prisma.module.ts
│   ├── services
│   │   ├── base.service.ts
│   │   ├── cache.service.ts
│   │   ├── config.service.ts
│   │   ├── pagination.service.ts
│   │   ├── permission.service.ts
│   │   └── prisma.service.ts
│   ├── types
│   │   ├── index.ts
│   │   ├── pagination.types.ts
│   │   ├── permission.types.ts
│   │   └── plan.types.ts
│   └── utils
│       ├── auth.utils.ts
│       └── permission.utils.ts
├── health
│   └── health.controller.ts
├── main.ts
├── metadata.ts
├── tree.txt
└── types
    ├── index.ts
    └── permissions.types.ts

25 directories, 127 files

================
File: .dockerignore
================
node_modules
dist
test
**/*.test.ts
**/*.spec.ts
**/__tests__/**
.nuxt
.env
.DS_Store # macOS
npm-debug.log
yarn-debug.log
.idea # JetBrains IDEs
.vscode # VS Code

================
File: code-style.md
================
You are a senior TypeScript programmer with experience in the NestJS framework and a preference for
clean programming and design patterns.

Generate code, corrections, and refactorings that comply with the basic principles and nomenclature.

## TypeScript General Guidelines

### Basic Principles

- Use English for all code and documentation.
- Always declare the type of each variable and function (parameters and return value).
  - Avoid using any.
  - Create necessary types.
- Use JSDoc to document public classes and methods.
- Don't leave blank lines within a function.
- One export per file.

### Nomenclature

- Use PascalCase for classes.
- Use camelCase for variables, functions, and methods.
- Use kebab-case for file and directory names.
- Use UPPERCASE for environment variables.
  - Avoid magic numbers and define constants.
- Start each function with a verb.
- Use verbs for boolean variables. Example: isLoading, hasError, canDelete, etc.
- Use complete words instead of abbreviations and correct spelling.
  - Except for standard abbreviations like API, URL, etc.
  - Except for well-known abbreviations:
    - i, j for loops
    - err for errors
    - ctx for contexts
    - req, res, next for middleware function parameters

### Functions

- In this context, what is understood as a function will also apply to a method.
- Write short functions with a single purpose. Less than 20 instructions.
- Name functions with a verb and something else.
  - If it returns a boolean, use isX or hasX, canX, etc.
  - If it doesn't return anything, use executeX or saveX, etc.
- Avoid nesting blocks by:
  - Early checks and returns.
  - Extraction to utility functions.
- Use higher-order functions (map, filter, reduce, etc.) to avoid function nesting.
  - Use arrow functions for simple functions (less than 3 instructions).
  - Use named functions for non-simple functions.
- Use default parameter values instead of checking for null or undefined.
- Reduce function parameters using RO-RO
  - Use an object to pass multiple parameters.
  - Use an object to return results.
  - Declare necessary types for input arguments and output.
- Use a single level of abstraction.

### Data

- Don't abuse primitive types and encapsulate data in composite types.
- Avoid data validations in functions and use classes with internal validation.
- Prefer immutability for data.
  - Use readonly for data that doesn't change.
  - Use as const for literals that don't change.

### Classes

- Follow SOLID principles.
- Prefer composition over inheritance.
- Declare interfaces to define contracts.
- Write small classes with a single purpose.
  - Less than 200 instructions.
  - Less than 10 public methods.
  - Less than 10 properties.

### Exceptions

- Use exceptions to handle errors you don't expect.
- If you catch an exception, it should be to:
  - Fix an expected problem.
  - Add context.
  - Otherwise, use a global handler.

### Testing

- Follow the Arrange-Act-Assert convention for tests.
- Name test variables clearly.
  - Follow the convention: inputX, mockX, actualX, expectedX, etc.
- Write unit tests for each public function.
  - Use test doubles to simulate dependencies.
    - Except for third-party dependencies that are not expensive to execute.
- Write acceptance tests for each module.
  - Follow the Given-When-Then convention.

## Specific to NestJS

### Basic Principles

- Use modular architecture
- Encapsulate the API in modules.
  - One module per main domain/route.
  - One controller for its route.
    - And other controllers for secondary routes.
  - A models folder with data types.
    - DTOs validated with class-validator for inputs.
    - Declare simple types for outputs.
  - A services module with business logic and persistence.
    - Entities with MikroORM for data persistence.
    - One service per entity.
- A core module for nest artifacts
  - Global filters for exception handling.
  - Global middlewares for request management.
  - Guards for permission management.
  - Interceptors for request management.
- A shared module for services shared between modules.
  - Utilities
  - Shared business logic

### Testing

- Use the standard Vitests framework for testing.
- Write tests for each controller and service.
- Write end to end tests for each api module.
- Add a admin/test method to each controller as a smoke test.

================
File: docker-compose.yml
================
services:
  api:
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - '3000:3000'
    environment:
      - NODE_ENV=production
      - DB_HOST=postgres
      - DB_PORT=5432
      - DB_NAME=postgres
      - DB_USER=postgres
      - DB_PASSWORD=postgres
      - DB_SCHEMA=public
      - DATABASE_URL=postgresql://postgres:postgres@postgres:5432/postgres
      - DIRECT_URL=postgresql://postgres:postgres@postgres:5432/postgres
      - SUPABASE_URL=http://supabase:54321
      - API_PREFIX=/api
      - SWAGGER_PATH=/api
      - CORS_ORIGINS=http://localhost:3000,http://localhost:3001
    volumes:
      - .:/usr/src/app
      - /usr/src/app/node_modules

================
File: Dockerfile
================
FROM node:22.12.0-bookworm

WORKDIR /app

ARG NX_CLOUD_ACCESS_TOKEN

ENV NX_CLOUD_ACCESS_TOKEN=${NX_CLOUD_ACCESS_TOKEN} \
    PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD=1 \
    NX_DAEMON=false \
    NX_SKIP_NX_CLOUD=true

# Install required build dependencies
RUN apt-get update && \
    apt-get install -y python3 make g++ git && \
    rm -rf /var/lib/apt/lists/*

# Install pnpm
RUN npm install -g pnpm

# Copy only the necessary files first
COPY package.json pnpm-lock.yaml pnpm-workspace.yaml ./
COPY apps/api/package.json ./apps/api/

# Copy the source files for the required workspaces
COPY apps/api ./apps/api
COPY libs ./libs
COPY prisma ./prisma
COPY tsconfig.* ./
COPY nx.json ./
COPY pnpm-workspace.yaml ./

# Install dependencies for specific workspaces
RUN pnpm install --filter @astronera/api

# Generate Prisma client for logger
RUN pnpx prisma generate

# Install nx and build
RUN pnpx nx reset
RUN pnpx nx build @astronera/api --skip-nx-cache

RUN pnpm prune --production

# Set the working directory to the output
WORKDIR /app/apps/api/dist

# Expose port and start command
EXPOSE 8080
CMD ["node", "main.js"]

================
File: eslint.config.js
================
import baseConfig from '../../eslint.config'

export default {
  ...baseConfig,
  rules: {
    ...baseConfig.rules,
    '@typescript-eslint/consistent-type-imports': 'off',
  },
}

================
File: nest-cli.json
================
{
  "$schema": "https://json.schemastore.org/nest-cli",
  "collection": "@nestjs/schematics",
  "sourceRoot": "src",
  "compilerOptions": {
    "tsConfigPath": "tsconfig.json",
    "builder": "swc",
    "deleteOutDir": true,
    "assets": ["**/*.json"],
    "webpack": false
  },
  "projects": {}
}

================
File: package.json
================
{
  "name": "@astronera/api",
  "version": "0.0.3",
  "private": true,
  "type": "commonjs",
  "scripts": {
    "build:logger": "tsx scripts/build-logger.ts",
    "lint": "pnpm nx lint @astronera/api",
    "test": "pnpm nx test @astronera/api",
    "dev": "nx serve @astronera/api",
    "build": "nx build @astronera/api",
    "start": "node dist/main.js --port=8080"
  },
  "dependencies": {
    "@astronera/db": "workspace:*",
    "@ib/cache": "workspace:*",
    "@ib/logger": "workspace:*",
    "@nestjs/axios": "^3.1.3",
    "@nestjs/cache-manager": "^2.3.0",
    "@nestjs/common": "^10.0.0",
    "@nestjs/config": "^3.3.0",
    "@nestjs/core": "^10.0.0",
    "@nestjs/microservices": "^10.4.15",
    "@nestjs/platform-socket.io": "^10.4.15",
    "@nestjs/schedule": "^4.1.2",
    "@nestjs/swagger": "^7.1.17",
    "@nestjs/terminus": "^10.2.3",
    "@nestjs/throttler": "^6.3.0",
    "@nestjs/websockets": "^10.4.15",
    "@supabase/supabase-js": "^2.47.8",
    "cache-manager": "^5.7.6",
    "class-transformer": "^0.5.1",
    "class-validator": "^0.14.0",
    "compression": "^1.7.5",
    "cosmiconfig": "^9.0.0",
    "express": "^4.18.2",
    "helmet": "^8.0.0",
    "ioredis": "^5.4.2",
    "jsonwebtoken": "^9.0.2",
    "playwright": "^1.41.1",
    "rxjs": "^7.8.1",
    "socket.io": "^4.8.1",
    "tcp-port-used": "^1.0.2"
  },
  "devDependencies": {
    "@nestjs/cli": "^10.0.0",
    "@types/socket.io": "^4.0.0",
    "@nestjs/schematics": "^10.0.0",
    "@nestjs/testing": "^10.0.0",
    "@nx/node": "20.3.0",
    "@types/compression": "^1.7.5",
    "@types/express": "^4.17.17",
    "@types/node": "^18.16.9",
    "@types/tcp-port-used": "^1.0.4",
    "ts-loader": "^9.5.1"
  }
}

================
File: project.json
================
{
  "name": "@astronera/api",
  "sourceRoot": "apps/api/src",
  "projectType": "application",
  "implicitDependencies": ["@ib/logger", "@ib/cache", "@astronera/db"],
  "targets": {
    "build": {
      "executor": "@nx/vite:build",
      "outputs": ["{options.outputPath}"],
      "defaultConfiguration": "production",
      "options": {
        "outputPath": "apps/api/dist",
        "main": "apps/api/src/main.ts",
        "tsConfig": "apps/api/tsconfig.json",
        "format": ["esm", "cjs"],
        "generatePackageJson": true,
        "generateLockfile": false
      },
      "dependsOn": [
        {
          "target": "build",
          "projects": ["@astronera/db", "@ib/logger", "@ib/cache"],
          "params": "forward"
        }
      ],
      "configurations": {
        "development": {
          "mode": "development",
          "watch": true
        },
        "production": {
          "mode": "production",
          "optimization": true,
          "extractLicenses": true,
          "inspect": false
        }
      }
    },
    "serve": {
      "executor": "@nx/vite:dev-server",
      "defaultConfiguration": "development",
      "options": {
        "buildTarget": "@astronera/api:build",
        "port": 3000
      },
      "configurations": {
        "development": {
          "buildTarget": "@astronera/api:build:development",
          "hmr": true
        },
        "production": {
          "buildTarget": "@astronera/api:build:production"
        }
      }
    },
    "lint": {
      "executor": "@nx/eslint:lint",
      "outputs": ["{options.outputFile}"]
    },
    "test": {
      "executor": "@nx/jest:jest",
      "outputs": ["{workspaceRoot}/coverage/{projectRoot}"],
      "options": {
        "jestConfig": "apps/api/jest.config.ts"
      }
    }
  }
}

================
File: README.md
================
# Astronera API

A NestJS-based API service with role-based permissions, authentication, and content management
capabilities.

## Quick Links

- API Base URL: http://localhost:3000/api
- Swagger Documentation: http://localhost:3000/docs
- Database Admin: http://localhost:54321 (Supabase)

## Prerequisites

- Node.js (v20.x recommended)
- PostgreSQL (via Supabase)
- pnpm or yarn
- Docker and Docker Compose (for containerized deployment)

## Environment Setup

The application uses various environment variables for configuration. Key configurations include:

```env
# Database Configuration
DB_HOST=localhost
DB_PORT=5432
DB_NAME=postgres
DB_USER=your_user
DB_PASSWORD=your_password

# API Configuration
PORT=3000
API_PREFIX=/api
SWAGGER_PATH=/api

# Supabase Configuration
SUPABASE_URL="http://localhost:54321"
SUPABASE_SERVICE_KEY="your_service_key"
SUPABASE_ANON_KEY="your_anon_key"

# CORS Configuration
CORS_ORIGINS=http://localhost:3000,http://localhost:3001
```

## Project Structure

```
src/
├── core/                   # Core functionality and shared modules
│   ├── config/            # Application configuration
│   ├── decorators/        # Custom decorators
│   ├── guards/            # Authentication and permission guards
│   ├── middleware/        # HTTP middleware
│   ├── modules/           # Core feature modules
│   ├── services/          # Shared services
│   └── types/             # TypeScript type definitions
├── content/               # Content management module
└── main.ts               # Application entry point
```

## Core Modules

### Permission Module

- Handles role-based access control (RBAC)
- Manages user permissions and authorization
- Files:
  - `permission.module.ts`: Module configuration
  - `permission.service.ts`: Permission logic
  - `permission.guard.ts`: Route protection
  - `permission.decorator.ts`: Custom decorators for routes

### Domain Module

- Manages domain-specific configuration
- Handles middleware and guard setup
- Provides logging capabilities
- Files:
  - `domain-config.ts`: Domain configuration

### Content Module

- Manages various content types (news, articles, research)
- Handles content categorization and tagging
- Provides content search and filtering

## Key Features

- Role-based access control
- JWT Authentication via Supabase
- Content management system
- API documentation with Swagger
- Database integration with Prisma
- Custom logging system
- CORS configuration
- Environment-based configuration
- Docker containerization

## File Types

- `.ts`: TypeScript source files
- `.env`: Environment configuration
- `.json`: Configuration files (package.json, tsconfig.json)
- `.md`: Documentation files
- `.prisma`: Database schema definition
- `Dockerfile`: Container configuration
- `docker-compose.yml`: Multi-container Docker configuration

## Getting Started

### Local Development

1. Clone the repository
2. Install dependencies:
   ```bash
   pnpm install
   ```
3. Set up environment variables:
   ```bash
   cp .env.example .env
   ```
4. Start the development server:
   ```bash
   pnpm run dev
   ```

### Docker Deployment

1. Build and start the containers:

   ```bash
   docker-compose up -d --build
   ```

2. Stop the containers:

   ```bash
   docker-compose down
   ```

3. View logs:

   ```bash
   docker-compose logs -f api
   ```

4. Access the services:
   - API: http://localhost:3000
   - Swagger: http://localhost:3000/docs
   - Supabase: http://localhost:54321
   - PostgreSQL: localhost:5432

### Docker Commands

```bash
# Build the API image
docker build -t astronera-api .

# Manually update prisma from api dir
dotenv -e ../../.env -- npx prisma db pull
dotenv -e ../../.env -- npx prisma generate

# View container logs
docker-compose logs -f [service_name]

# Restart a service
docker-compose restart [service_name]

# Remove all containers and volumes
docker-compose down -v
```

## API Documentation

The API documentation is available through Swagger UI at http://localhost:3000/docs. This provides:

- Detailed endpoint documentation
- Request/response schemas
- Testing interface
- Authentication information

## Development Tools

- **NestJS**: Main framework
- **Prisma**: Database ORM
- **Supabase**: Authentication and database
- **Swagger**: API documentation
- **TypeScript**: Programming language
- **ESLint/Prettier**: Code formatting and linting
- **Docker**: Containerization
- **Docker Compose**: Container orchestration

## Testing

```bash
# Unit tests
npm run test

# E2E tests
npm run test:e2e

# Test coverage
npm run test:cov
```

## Contributing

1. Create a feature branch
2. Make your changes
3. Write/update tests
4. Submit a pull request

## License

[MIT License](LICENSE)

================
File: tsconfig.json
================
{
  "extends": ["../../tsconfig.nest.json"],
  "compilerOptions": {
    "baseUrl": ".",
    "outDir": "./dist",
    "rootDir": "./src",
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,
    "paths": {
      "@types": ["src/types/index.ts"],
      "@core": ["src/core/index.ts"],
      "@jobs": ["src/jobs/index.ts"],
      "@jobs/*": ["src/jobs/*"],
      "@content": ["src/content/index.ts"],
      "@monitoring": ["src/monitoring/index.ts"],
      "@auth/*": ["src/auth/*"],
      "@common/*": ["src/common/*"],
      "@content/*": ["src/content/*"],
      "@core/*": ["src/core/*"],
      "@engagement/*": ["src/engagement/*"],
      "@location/*": ["src/location/*"],
      "@monitoring/*": ["src/monitoring/*"],
      "@org/*": ["src/org/*"],
      "@payments": ["src/payments/index.ts"],
      "@payments/*": ["src/payments/*"],
      "@search/*": ["src/search/*"],
      "@security/*": ["src/security/*"],
      "@advertising/*": ["src/advertising/*"]
    }
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "test", "**/*.test.ts", "**/*.spec.ts", "dist"]
}

================
File: vite.config.ts
================
/// <reference types="vitest" />
import { defineConfig } from 'vite'
import { nxViteTsPaths } from '@nx/vite/plugins/nx-tsconfig-paths.plugin'
import { visualizer } from 'rollup-plugin-visualizer'
import path from 'path'
import { fileURLToPath } from 'url'

console.log('fileURLToPath', fileURLToPath(import.meta.url))

const __dirname = path.dirname(fileURLToPath(import.meta.url))

export default defineConfig({
  build: {
    sourcemap: process.env.NODE_ENV === 'development',
    minify: process.env.NODE_ENV === 'production',
    outDir: path.resolve(__dirname, './dist'),
    reportCompressedSize: true,
    commonjsOptions: {
      transformMixedEsModules: true,
      include: [/node_modules/, /libs\/logger/],
    },
    chunkSizeWarningLimit: 600,
    rollupOptions: {
      treeshake: true,
      external: [
        // Add Node.js built-ins
        'http',
        'https',
        'url',
        'path',
        'fs',
        'events',
        'util',
        'stream',
        'zlib',
        // Add problematic dependencies
        'socket.io',
        'engine.io',
        'socket.io-adapter',
        'socket.io-parser',
        // Add pattern matching for Node modules
        /^node:*/,
        // Add pattern for Node.js internal modules
        /^[@]nestjs\/.*/,
        /^socket\.io.*/,
        /^rxjs\/.*/,

        'class-transformer',
        'class-transformer/storage',
        'class-validator',
      ],
      output: {
        format: 'esm',
        manualChunks: {
          'socket-io': ['socket.io', 'socket.io-parser', 'socket.io-adapter'],
          'engine-io': ['engine.io', 'engine.io-parser'],
          'node-utils': ['debug', 'events', 'util'],
        },
      },
      input: {
        main: path.resolve(__dirname, 'src/main.ts'),
      },
    },
  },
  cacheDir: path.resolve(__dirname, '../../node_modules/.vite/apps/api'),
  server: {
    port: 3000,
    host: 'localhost',
  },
  plugins: [
    nxViteTsPaths({
      debug: true,
    }),
    visualizer({
      filename: 'stats.html', // Output file
      open: true, // Automatically open in default browser
      gzipSize: true, // Show gzip sizes
      brotliSize: true, // Show brotli sizes
      template: 'treemap', // Use treemap visualization
    }),
  ],
  resolve: {
    preserveSymlinks: true,
    alias: {
      '@types': path.resolve(__dirname, './src/types'),
      '@core': path.resolve(__dirname, './src/core'),
      '@jobs': path.resolve(__dirname, './src/jobs/'),
      '@content': path.resolve(__dirname, './src/content'),
      '@monitoring': path.resolve(__dirname, './src/monitoring'),
      '@payments': path.resolve(__dirname, './src/payments'),
      '@auth': path.resolve(__dirname, './src/auth'),
      '@common': path.resolve(__dirname, './src/common'),
      '@engagement': path.resolve(__dirname, './src/engagement'),
      '@location': path.resolve(__dirname, './src/location'),
      '@org': path.resolve(__dirname, './src/org'),
      '@search': path.resolve(__dirname, './src/search'),
      '@security': path.resolve(__dirname, './src/security'),
      '@advertising': path.resolve(__dirname, './src/advertising'),
      '#layers': path.resolve(__dirname, '../../layers'),
      //
      '@astronera/db': path.resolve(__dirname, '../../node_modules/@astronera/db'),
      '@ib/logger': path.resolve(__dirname, '../../node_modules/@ib/logger'),
      '@ib/cache': path.resolve(__dirname, '../../node_modules/@ib/cache'),

      'class-transformer/storage': require.resolve('class-transformer'),
    },
  },
  test: {
    globals: true,
    cache: {
      dir: path.resolve(__dirname, '../../node_modules/.vitest/apps/api'),
    },
    environment: 'node',
    include: ['src/**/*.{test,spec}.{js,mjs,cjs,ts,mts,cts}'],
    reporters: ['default'],
    coverage: {
      reportsDirectory: path.resolve(__dirname, '../../coverage/apps/api'),
      provider: 'v8',
    },
  },
  optimizeDeps: {
    exclude: ['socket.io', 'engine.io', '@nestjs/core', '@nestjs/common'],
    include: ['@astronera/db', '@ib/logger', '@ib/cache'],
    esbuildOptions: {
      platform: 'node',
      target: 'node18',
      format: 'esm',
      mainFields: ['module', 'main'],
    },
  },
})

================
File: vitest.config.ts
================
import { defineConfig } from 'vitest/config.js'

export default defineConfig({
  test: {
    globals: true,
    setupFiles: ['./vitest.setup.ts'],
    environment: 'node',
    coverage: {
      provider: 'v8',
      reporter: ['text', 'json', 'html'],
    },
    alias: {
      '@core': '/src/core',
      '@content': '/src/content',
      '@auth': '/src/auth',
    },
  },
})

================
File: vitest.setup.ts
================
import { vi } from 'vitest'
import { mockDeep, mockReset } from 'vitest-mock-extended'
import type { PrismaClient } from '@astronera/db'

vi.mock('@astronera/db', () => ({
  PrismaClient: vi.fn(() => mockDeep<PrismaClient>()),
}))

beforeEach(() => {
  mockReset(prismaMock)
})

export const prismaMock = mockDeep<PrismaClient>()
