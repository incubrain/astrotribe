
================================================================
Repository Structure
================================================================
src/
  content/
    controllers/
      categories.controller.ts
      content-categories.controller.ts
      content-source-visits.controller.ts
      content-sources.controller.ts
      content-statuses.controller.ts
      content-tags.controller.ts
      content.controller.ts
      embedding-reviews.controller.ts
      feed-categories.controller.ts
      feed-sources.controller.ts
      feeds.controller.ts
      news-summaries.controller.ts
      news-tags.controller.ts
      news.controller.ts
      newsletters.controller.ts
      research-embeddings.controller.ts
      research.controller.ts
      tags.controller.ts
    models/
      categories.model.ts
      content-categories.model.ts
      content-source-visits.model.ts
      content-sources.model.ts
      content-statuses.model.ts
      content-tags.model.ts
      contents.model.ts
      embedding-reviews.model.ts
      feed-categories.model.ts
      feed-sources.model.ts
      feeds.model.ts
      news-summaries.model.ts
      news-tags.model.ts
      news.model.ts
      newsletters.model.ts
      research-embeddings.model.ts
      research.model.ts
      tags.model.ts
    services/
      categories.service.ts
      content-categories.service.ts
      content-source-visits.service.ts
      content-sources.service.ts
      content-statuses.service.ts
      content-tags.service.ts
      content.service.ts
      embedding-reviews.service.ts
      feed-categories.service.ts
      feed-sources.service.ts
      feeds.service.ts
      news-summaries.service.ts
      news-tags.service.ts
      news.service.ts
      newsletters.service.ts
      research-embeddings.service.ts
      research.service.ts
      tags.service.ts
    content.module.ts
    index.ts
  core/
    base/
      base.controller.ts
      base.dto.ts
      base.gateway.ts
      base.model.ts
      base.service.ts
    cache/
      cache.mock.ts
      cache.module.ts
    config/
      configuration.ts
      domain-config.ts
    decorators/
      api.decorator.ts
      current-user.decorator.ts
      permission.decorator.ts
      plan.decorator.ts
      public.decorator.ts
      roles.decorator.ts
      service.decorator.ts
      validate.decorator.ts
    dto/
      pagination.dto.ts
    filters/
      http-exception.filter.ts
    guards/
      api-key.guard.ts
      permission.guard.ts
      plan.guard.ts
      throttler.guard.ts
    interceptors/
      bigint.interceptor.ts
      logging.interceptor.ts
      pagination.interceptor.ts
    logger/
      custom.logger.ts
      logger.colors.ts
    modules/
      logger.module.ts
      permission.module.ts
      prisma.module.ts
    pipes/
      transformation.pipe.ts
      trim.pipe.ts
      type-conversion.pipe.ts
      validation.pipe.ts
    services/
      debug.service.ts
      pagination.service.ts
      permission.service.ts
      prisma.service.ts
    storage/
      throttler.storage.ts
    utils/
      auth.utils.ts
      permission.utils.ts
    webhook/
      razorpay.service.ts
      webhook.module.ts
    core.module.ts
    index.ts
  jobs/
    controllers/
      job-config.controller.ts
      job-metric.controller.ts
    services/
      job-config.service.ts
      job-metric.service.ts
    index.ts
    job.module.ts
  monitoring/
    controllers/
      error-metrics.controller.ts
      health.controller.ts
      log.controller.ts
    gateways/
      log.gateway.ts
    services/
      error-metrics.service.ts
      log.service.ts
      monitoring.service.ts
    index.ts
    monitoring.module.ts
  observables/
    events.gateway.ts
    events.module.ts
    payments.observable.ts
  payments/
    controllers/
      payment.controller.ts
      plan.controller.ts
      provider.controller.ts
      refund.controller.ts
      subscription.controller.ts
      webhook.controller.ts
    models/
      payment.model.ts
      plan.model.ts
      provider.model.ts
      refund.model.ts
      subscription.model.ts
    services/
      payment.service.ts
      plan.service.ts
      provider.service.ts
      refund.service.ts
      subscription.service.ts
    index.ts
    payment.module.ts
  types/
    domain.types.ts
    index.ts
    pagination.types.ts
    permission.types.ts
    plan.types.ts
    subscription.types.ts
  app.module.ts
  main.ts
  metadata.ts
  tree.txt
.dockerignore
code-style.md
docker-compose.yml
Dockerfile
eslint.config.js
package.json
project.json
README.md
tsconfig.json
vitest.config.ts
vitest.setup.ts

================================================================
Repository Files
================================================================

================
File: src/content/controllers/categories.controller.ts
================
// controller.ejs template
import {
  Controller,
  Get,
  Post,
  Put,
  Delete,
  Body,
  Param,
  Query,
  ParseUUIDPipe,
  Inject,
} from '@nestjs/common'
import { ApiTags, ApiOperation } from '@nestjs/swagger'
import { CategoriesService } from '../services/categories.service'
import { ConfigService } from '@nestjs/config'
import { PrismaService } from '@core/services/prisma.service'
import { PaginationService } from '@core/services/pagination.service'
import { CustomLogger } from '@core/logger/custom.logger'
import { BaseController } from '@core/base/base.controller'

import type { Prisma } from '@astronera/db'
import type { PaginatedResponse, PaginatedQuery } from '@types'

@Controller('categories')
@ApiTags('Categories')
export class CategoryController extends BaseController {
  constructor(
    protected readonly categoriesService: CategoriesService,
    protected readonly prisma: PrismaService,
    protected readonly config: ConfigService,
    protected readonly paginationService: PaginationService,
    protected readonly logger: CustomLogger,
  ) {
    super('Categories')
  }

  @Get()
  @ApiOperation({ summary: 'Get all Categories' })
  async findAllCategories(
    @Query() query: PaginatedQuery,
  ): Promise<
    PaginatedResponse<unknown> | { success: boolean; error: any; timestamp: string; code: any }
  > {
    try {
      this.logger.log('Fetching all Categories')
      return super.findAll(query)
    } catch (error: any) {
      this.logger.error('Failed to fetch Categories', error.stack)
      throw error
    }
  }

  @Get(':id')
  @ApiOperation({ summary: 'Get Categories by id' })
  async findOneCategories(
    @Param('id', ParseUUIDPipe) id: string,
    @Query('include') include?: string[],
  ) {
    try {
      return await super.findOne(id, include)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Post()
  @ApiOperation({ summary: 'Create Categories' })
  async createCategories(@Body() data: Prisma.CategoriesCreateInput) {
    try {
      return await super.create(data)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Put(':id')
  @ApiOperation({ summary: 'Update Categories' })
  async updateCategories(
    @Param('id', ParseUUIDPipe) id: string,
    @Body() data: Prisma.CategoriesUpdateInput,
  ) {
    try {
      return await super.update(id, data)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Delete(':id')
  @ApiOperation({ summary: 'Delete Categories' })
  async removeCategories(@Param('id', ParseUUIDPipe) id: string) {
    try {
      return await super.remove(id)
    } catch (error: any) {
      return this.handleError(error)
    }
  }
}

================
File: src/content/controllers/content-categories.controller.ts
================
// controller.ejs template
import {
  Controller,
  Get,
  Post,
  Put,
  Delete,
  Body,
  Param,
  Query,
  ParseUUIDPipe,
} from '@nestjs/common'
import { ApiTags, ApiOperation } from '@nestjs/swagger'
import { ContentCategoriesService } from '../services/content-categories.service'
import { PrismaService } from '@core/services/prisma.service'
import { PaginationService } from '@core/services/pagination.service'
import { CustomLogger } from '@core/logger/custom.logger'
import { BaseController } from '@core/base/base.controller'
import { ConfigService } from '@nestjs/config'

import type { Prisma } from '@astronera/db'
import type { PaginatedResponse, PaginatedQuery } from '@types'

@Controller('content-categories')
@ApiTags('ContentCategories')
export class ContentCategoryController extends BaseController {
  constructor(
    protected readonly contentCategoriesService: ContentCategoriesService,
    protected readonly prisma: PrismaService,
    protected readonly config: ConfigService,
    protected readonly paginationService: PaginationService,
    protected readonly logger: CustomLogger,
  ) {
    super('ContentCategories')
  }

  @Get()
  @ApiOperation({ summary: 'Get all ContentCategories' })
  async findAllContentCategories(
    @Query() query: PaginatedQuery,
  ): Promise<
    PaginatedResponse<unknown> | { success: boolean; error: any; timestamp: string; code: any }
  > {
    try {
      return await super.findAll(query)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Get(':id')
  @ApiOperation({ summary: 'Get ContentCategories by id' })
  async findOneContentCategories(
    @Param('id', ParseUUIDPipe) id: string,
    @Query('include') include?: string[],
  ) {
    try {
      return await super.findOne(id, include)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Post()
  @ApiOperation({ summary: 'Create ContentCategories' })
  async createContentCategories(@Body() data: Prisma.ContentCategoriesCreateInput) {
    try {
      return await super.create(data)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Put(':id')
  @ApiOperation({ summary: 'Update ContentCategories' })
  async updateContentCategories(
    @Param('id', ParseUUIDPipe) id: string,
    @Body() data: Prisma.ContentCategoriesUpdateInput,
  ) {
    try {
      return await super.update(id, data)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Delete(':id')
  @ApiOperation({ summary: 'Delete ContentCategories' })
  async removeContentCategories(@Param('id', ParseUUIDPipe) id: string) {
    try {
      return await super.remove(id)
    } catch (error: any) {
      return this.handleError(error)
    }
  }
}

================
File: src/content/controllers/content-source-visits.controller.ts
================
// controller.ejs template
import {
  Controller,
  Get,
  Post,
  Put,
  Delete,
  Body,
  Param,
  Query,
  ParseUUIDPipe,
} from '@nestjs/common'
import { ApiTags, ApiOperation } from '@nestjs/swagger'
import { PrismaService } from '@core/services/prisma.service'
import { PaginationService } from '@core/services/pagination.service'
import { CustomLogger } from '@core/logger/custom.logger'
import { BaseController } from '@core/base/base.controller'
import { ConfigService } from '@nestjs/config'
import { ContentSourceVisitService } from '../services/content-source-visits.service'

import type { Prisma } from '@astronera/db'
import type { PaginatedResponse, PaginatedQuery } from '@types'

@Controller('content-source-visits')
@ApiTags('ContentSourceVisits')
export class ContentSourceVisitController extends BaseController {
  constructor(
    protected readonly contentSourceVisitService: ContentSourceVisitService,
    protected readonly prisma: PrismaService,
    protected readonly config: ConfigService,
    protected readonly paginationService: PaginationService,
    protected readonly logger: CustomLogger,
  ) {
    super('ContentSourceVisits')
  }

  @Get()
  @ApiOperation({ summary: 'Get all ContentSourceVisits' })
  async findAllContentSourceVisits(
    @Query() query: PaginatedQuery,
  ): Promise<
    PaginatedResponse<unknown> | { success: boolean; error: any; timestamp: string; code: any }
  > {
    try {
      return await super.findAll(query)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Get(':id')
  @ApiOperation({ summary: 'Get ContentSourceVisits by id' })
  async findOneContentSourceVisits(
    @Param('id', ParseUUIDPipe) id: string,
    @Query('include') include?: string[],
  ) {
    try {
      return await super.findOne(id, include)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Post()
  @ApiOperation({ summary: 'Create ContentSourceVisits' })
  async createContentSourceVisits(@Body() data: Prisma.ContentSourceVisitsCreateInput) {
    try {
      return await super.create(data)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Put(':id')
  @ApiOperation({ summary: 'Update ContentSourceVisits' })
  async updateContentSourceVisits(
    @Param('id', ParseUUIDPipe) id: string,
    @Body() data: Prisma.ContentSourceVisitsUpdateInput,
  ) {
    try {
      return await super.update(id, data)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Delete(':id')
  @ApiOperation({ summary: 'Delete ContentSourceVisits' })
  async removeContentSourceVisits(@Param('id', ParseUUIDPipe) id: string) {
    try {
      return await super.remove(id)
    } catch (error: any) {
      return this.handleError(error)
    }
  }
}

================
File: src/content/controllers/content-sources.controller.ts
================
// controller.ejs template
import {
  Controller,
  Get,
  Post,
  Put,
  Delete,
  Body,
  Param,
  Query,
  ParseUUIDPipe,
} from '@nestjs/common'
import { ApiTags, ApiOperation } from '@nestjs/swagger'
import { PrismaService } from '@core/services/prisma.service'
import { PaginationService } from '@core/services/pagination.service'
import { CustomLogger } from '@core/logger/custom.logger'
import { BaseController } from '@core/base/base.controller'
import { ConfigService } from '@nestjs/config'
import { ContentSourcesService } from '../services/content-sources.service'

import { Prisma } from '@astronera/db'
import type { PaginatedResponse, PaginatedQuery } from '@types'

@Controller('content-sources')
@ApiTags('ContentSources')
export class ContentSourceController extends BaseController {
  constructor(
    protected readonly contentSourcesService: ContentSourcesService,
    protected readonly prisma: PrismaService,
    protected readonly config: ConfigService,
    protected readonly paginationService: PaginationService,
    protected readonly logger: CustomLogger,
  ) {
    super('ContentSources')
  }

  @Get()
  @ApiOperation({ summary: 'Get all ContentSources' })
  async findAllContentSources(
    @Query() query: PaginatedQuery,
  ): Promise<
    PaginatedResponse<unknown> | { success: boolean; error: any; timestamp: string; code: any }
  > {
    try {
      return await super.findAll(query)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Get(':id')
  @ApiOperation({ summary: 'Get ContentSources by id' })
  async findOneContentSources(
    @Param('id', ParseUUIDPipe) id: string,
    @Query('include') include?: string[],
  ) {
    try {
      return await super.findOne(id, include)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Post()
  @ApiOperation({ summary: 'Create ContentSources' })
  async createContentSources(@Body() data: Prisma.ContentSourcesCreateInput) {
    try {
      return await super.create(data)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Put(':id')
  @ApiOperation({ summary: 'Update ContentSources' })
  async updateContentSources(
    @Param('id', ParseUUIDPipe) id: string,
    @Body() data: Prisma.ContentSourcesUpdateInput,
  ) {
    try {
      return await super.update(id, data)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Delete(':id')
  @ApiOperation({ summary: 'Delete ContentSources' })
  async removeContentSources(@Param('id', ParseUUIDPipe) id: string) {
    try {
      return await super.remove(id)
    } catch (error: any) {
      return this.handleError(error)
    }
  }
}

================
File: src/content/controllers/content-statuses.controller.ts
================
// controller.ejs template
import {
  Controller,
  Get,
  Post,
  Put,
  Delete,
  Body,
  Param,
  Query,
  ParseUUIDPipe,
} from '@nestjs/common'
import { ApiTags, ApiOperation } from '@nestjs/swagger'
import { PrismaService } from '@core/services/prisma.service'
import { PaginationService } from '@core/services/pagination.service'
import { CustomLogger } from '@core/logger/custom.logger'
import { BaseController } from '@core/base/base.controller'
import { ConfigService } from '@nestjs/config'
import { ContentStatusesService } from '../services/content-statuses.service'

import type { Prisma } from '@astronera/db'
import type { PaginatedResponse, PaginatedQuery } from '@types'

@Controller('content-statuses')
@ApiTags('ContentStatuses')
export class ContentStatusController extends BaseController {
  constructor(
    protected readonly contentStatusesService: ContentStatusesService,
    protected readonly prisma: PrismaService,
    protected readonly config: ConfigService,
    protected readonly paginationService: PaginationService,
    protected readonly logger: CustomLogger,
  ) {
    super('ContentStatuses')
  }

  @Get()
  @ApiOperation({ summary: 'Get all ContentStatuses' })
  async findAllContentStatuses(
    @Query() query: PaginatedQuery,
  ): Promise<
    PaginatedResponse<unknown> | { success: boolean; error: any; timestamp: string; code: any }
  > {
    try {
      return await super.findAll(query)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Get(':id')
  @ApiOperation({ summary: 'Get ContentStatuses by id' })
  async findOneContentStatuses(
    @Param('id', ParseUUIDPipe) id: string,
    @Query('include') include?: string[],
  ) {
    try {
      return await super.findOne(id, include)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Post()
  @ApiOperation({ summary: 'Create ContentStatuses' })
  async createContentStatuses(@Body() data: Prisma.ContentStatusesCreateInput) {
    try {
      return await super.create(data)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Put(':id')
  @ApiOperation({ summary: 'Update ContentStatuses' })
  async updateContentStatuses(
    @Param('id', ParseUUIDPipe) id: string,
    @Body() data: Prisma.ContentStatusesUpdateInput,
  ) {
    try {
      return await super.update(id, data)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Delete(':id')
  @ApiOperation({ summary: 'Delete ContentStatuses' })
  async removeContentStatuses(@Param('id', ParseUUIDPipe) id: string) {
    try {
      return await super.remove(id)
    } catch (error: any) {
      return this.handleError(error)
    }
  }
}

================
File: src/content/controllers/content-tags.controller.ts
================
// controller.ejs template
import {
  Controller,
  Get,
  Post,
  Put,
  Delete,
  Body,
  Param,
  Query,
  ParseUUIDPipe,
} from '@nestjs/common'
import { ApiTags, ApiOperation } from '@nestjs/swagger'
import { PrismaService } from '@core/services/prisma.service'
import { PaginationService } from '@core/services/pagination.service'
import { CustomLogger } from '@core/logger/custom.logger'
import { BaseController } from '@core/base/base.controller'
import { ConfigService } from '@nestjs/config'
import { ContentTagsService } from '../services/content-tags.service'

import type { Prisma } from '@astronera/db'
import type { PaginatedResponse, PaginatedQuery } from '@types'

@Controller('content-tags')
@ApiTags('ContentTags')
export class ContentTagController extends BaseController {
  constructor(
    protected readonly contentTagsService: ContentTagsService,
    protected readonly prisma: PrismaService,
    protected readonly config: ConfigService,
    protected readonly paginationService: PaginationService,
    protected readonly logger: CustomLogger,
  ) {
    super('ContentTags')
  }

  @Get()
  @ApiOperation({ summary: 'Get all ContentTags' })
  async findAllContentTags(
    @Query() query: PaginatedQuery,
  ): Promise<
    PaginatedResponse<unknown> | { success: boolean; error: any; timestamp: string; code: any }
  > {
    try {
      return await super.findAll(query)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Get(':id')
  @ApiOperation({ summary: 'Get ContentTags by id' })
  async findOneContentTags(
    @Param('id', ParseUUIDPipe) id: string,
    @Query('include') include?: string[],
  ) {
    try {
      return await super.findOne(id, include)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Post()
  @ApiOperation({ summary: 'Create ContentTags' })
  async createContentTags(@Body() data: Prisma.ContentTagsCreateInput) {
    try {
      return await super.create(data)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Put(':id')
  @ApiOperation({ summary: 'Update ContentTags' })
  async updateContentTags(
    @Param('id', ParseUUIDPipe) id: string,
    @Body() data: Prisma.ContentTagsUpdateInput,
  ) {
    try {
      return await super.update(id, data)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Delete(':id')
  @ApiOperation({ summary: 'Delete ContentTags' })
  async removeContentTags(@Param('id', ParseUUIDPipe) id: string) {
    try {
      return await super.remove(id)
    } catch (error: any) {
      return this.handleError(error)
    }
  }
}

================
File: src/content/controllers/content.controller.ts
================
// controller.ejs template
import {
  Controller,
  Get,
  Post,
  Put,
  Delete,
  Body,
  Param,
  Query,
  ParseUUIDPipe,
  UseGuards,
  HttpException,
  HttpStatus,
} from '@nestjs/common'
import { ApiTags, ApiOperation } from '@nestjs/swagger'
import { ConfigService } from '@nestjs/config'
import { PrismaService } from '@core/services/prisma.service'
import { PaginationService } from '@core/services/pagination.service'
import { CustomLogger } from '@core/logger/custom.logger'
import { BaseController } from '@core/base/base.controller'
import { PermissionGuard } from '@core/guards/permission.guard'
import { ContentService } from '../services/content.service'
import { ApiBaseController } from '@core/base/base.controller'
import { ApiPaginatedResponse, ApiGetByIdResponse } from '@core/decorators/api.decorator'

import type { Prisma } from '@astronera/db'
import type { PaginatedQuery, PaginatedResponse } from '@types'

const ContentDto = {}

@ApiBaseController('contents')
@UseGuards(PermissionGuard)
export class ContentController extends BaseController {
  constructor(
    protected readonly contentService: ContentService,
    protected readonly prisma: PrismaService,
    protected readonly config: ConfigService,
    protected readonly paginationService: PaginationService,
    protected readonly logger: CustomLogger,
  ) {
    super('Contents')
  }

  @Get()
  @ApiPaginatedResponse(ContentDto)
  @ApiOperation({ summary: 'Get all content with company logos' })
  async getAllContent(@Query() query: PaginatedQuery) {
    try {
      return await this.contentService.getAllContent(query)
    } catch (error: any) {
      throw new HttpException(
        error.message || 'An error occurred',
        error.status || HttpStatus.INTERNAL_SERVER_ERROR,
      )
    }
  }

  @Get(':id')
  @ApiGetByIdResponse(ContentDto)
  @ApiOperation({ summary: 'Get Contents by id' })
  async findOneContents(
    @Param('id', ParseUUIDPipe) id: string,
    @Query('include') include?: string[],
  ) {
    try {
      return await super.findOne(id, include)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Post()
  @ApiOperation({ summary: 'Create Contents' })
  async createContents(@Body() data: Prisma.ContentsCreateInput) {
    try {
      return await super.create(data)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Put(':id')
  @ApiOperation({ summary: 'Update Contents' })
  async updateContents(
    @Param('id', ParseUUIDPipe) id: string,
    @Body() data: Prisma.ContentsUpdateInput,
  ) {
    try {
      return await super.update(id, data)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Delete(':id')
  @ApiOperation({ summary: 'Delete Contents' })
  async removeContents(@Param('id', ParseUUIDPipe) id: string) {
    try {
      return await super.remove(id)
    } catch (error: any) {
      return this.handleError(error)
    }
  }
}

================
File: src/content/controllers/embedding-reviews.controller.ts
================
// controller.ejs template
import {
  Controller,
  Get,
  Post,
  Put,
  Delete,
  Body,
  Param,
  Query,
  ParseUUIDPipe,
} from '@nestjs/common'
import { ApiTags, ApiOperation } from '@nestjs/swagger'
import { ConfigService } from '@nestjs/config'
import { PrismaService } from '@core/services/prisma.service'
import { PaginationService } from '@core/services/pagination.service'
import { CustomLogger } from '@core/logger/custom.logger'
import { BaseController } from '@core/base/base.controller'
import { EmbeddingReviewsService } from '../services/embedding-reviews.service'

import type { PaginatedResponse, PaginatedQuery } from '@types'
import type { Prisma } from '@astronera/db'

@Controller('embedding-reviews')
@ApiTags('EmbeddingReviews')
export class EmbeddingReviewController extends BaseController {
  constructor(
    protected readonly embeddingReviewsService: EmbeddingReviewsService,
    protected readonly prisma: PrismaService,
    protected readonly config: ConfigService,
    protected readonly paginationService: PaginationService,
    protected readonly logger: CustomLogger,
  ) {
    super('EmbeddingReviews')
  }

  @Get()
  @ApiOperation({ summary: 'Get all EmbeddingReviews' })
  async findAllEmbeddingReviews(
    @Query() query: PaginatedQuery,
  ): Promise<
    PaginatedResponse<unknown> | { success: boolean; error: any; timestamp: string; code: any }
  > {
    try {
      return await super.findAll(query)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Get(':id')
  @ApiOperation({ summary: 'Get EmbeddingReviews by id' })
  async findOneEmbeddingReviews(
    @Param('id', ParseUUIDPipe) id: string,
    @Query('include') include?: string[],
  ) {
    try {
      return await super.findOne(id, include)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Post()
  @ApiOperation({ summary: 'Create EmbeddingReviews' })
  async createEmbeddingReviews(@Body() data: Prisma.EmbeddingReviewsCreateInput) {
    try {
      return await super.create(data)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Put(':id')
  @ApiOperation({ summary: 'Update EmbeddingReviews' })
  async updateEmbeddingReviews(
    @Param('id', ParseUUIDPipe) id: string,
    @Body() data: Prisma.EmbeddingReviewsUpdateInput,
  ) {
    try {
      return await super.update(id, data)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Delete(':id')
  @ApiOperation({ summary: 'Delete EmbeddingReviews' })
  async removeEmbeddingReviews(@Param('id', ParseUUIDPipe) id: string) {
    try {
      return await super.remove(id)
    } catch (error: any) {
      return this.handleError(error)
    }
  }
}

================
File: src/content/controllers/feed-categories.controller.ts
================
// controller.ejs template
import {
  Controller,
  Get,
  Post,
  Put,
  Delete,
  Body,
  Param,
  Query,
  ParseUUIDPipe,
} from '@nestjs/common'
import { ApiTags, ApiOperation } from '@nestjs/swagger'
import { ConfigService } from '@nestjs/config'
import { FeedCategoriesService } from '../services/feed-categories.service'
import { PrismaService } from '@core/services/prisma.service'
import { PaginationService } from '@core/services/pagination.service'
import { CustomLogger } from '@core/logger/custom.logger'
import { BaseController } from '@core/base/base.controller'

import type { Prisma } from '@astronera/db'
import type { PaginatedResponse, PaginatedQuery } from '@types'

@Controller('feed-categories')
@ApiTags('FeedCategories')
export class FeedCategoryController extends BaseController {
  constructor(
    protected readonly feedCategoriesService: FeedCategoriesService,
    protected readonly prisma: PrismaService,
    protected readonly config: ConfigService,
    protected readonly paginationService: PaginationService,
    protected readonly logger: CustomLogger,
  ) {
    super('FeedCategories')
  }

  @Get()
  @ApiOperation({ summary: 'Get all FeedCategories' })
  async findAllFeedCategories(
    @Query() query: PaginatedQuery,
  ): Promise<
    PaginatedResponse<unknown> | { success: boolean; error: any; timestamp: string; code: any }
  > {
    try {
      return await super.findAll(query)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Get(':id')
  @ApiOperation({ summary: 'Get FeedCategories by id' })
  async findOneFeedCategories(
    @Param('id', ParseUUIDPipe) id: string,
    @Query('include') include?: string[],
  ) {
    try {
      return await super.findOne(id, include)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Post()
  @ApiOperation({ summary: 'Create FeedCategories' })
  async createFeedCategories(@Body() data: Prisma.FeedCategoriesCreateInput) {
    try {
      return await super.create(data)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Put(':id')
  @ApiOperation({ summary: 'Update FeedCategories' })
  async updateFeedCategories(
    @Param('id', ParseUUIDPipe) id: string,
    @Body() data: Prisma.FeedCategoriesUpdateInput,
  ) {
    try {
      return await super.update(id, data)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Delete(':id')
  @ApiOperation({ summary: 'Delete FeedCategories' })
  async removeFeedCategories(@Param('id', ParseUUIDPipe) id: string) {
    try {
      return await super.remove(id)
    } catch (error: any) {
      return this.handleError(error)
    }
  }
}

================
File: src/content/controllers/feed-sources.controller.ts
================
// controller.ejs template
import {
  Controller,
  Get,
  Post,
  Put,
  Delete,
  Body,
  Param,
  Query,
  ParseUUIDPipe,
} from '@nestjs/common'
import { ApiTags, ApiOperation } from '@nestjs/swagger'
import { ConfigService } from '@nestjs/config'
import { FeedSourceService } from '../services/feed-sources.service'
import { PrismaService } from '@core/services/prisma.service'
import { PaginationService } from '@core/services/pagination.service'
import { CustomLogger } from '@core/logger/custom.logger'
import { BaseController } from '@core/base/base.controller'

import type { Prisma } from '@astronera/db'
import type { PaginatedResponse, PaginatedQuery } from '@types'

@Controller('feed-sources')
@ApiTags('FeedSources')
export class FeedSourceController extends BaseController {
  constructor(
    protected readonly feedSourceService: FeedSourceService,
    protected readonly prisma: PrismaService,
    protected readonly config: ConfigService,
    protected readonly paginationService: PaginationService,
    protected readonly logger: CustomLogger,
  ) {
    super('FeedSources')
  }

  @Get()
  @ApiOperation({ summary: 'Get all FeedSources' })
  async findAllFeedSources(
    @Query() query: PaginatedQuery,
  ): Promise<
    PaginatedResponse<unknown> | { success: boolean; error: any; timestamp: string; code: any }
  > {
    try {
      return await super.findAll(query)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Get(':id')
  @ApiOperation({ summary: 'Get FeedSources by id' })
  async findOneFeedSources(
    @Param('id', ParseUUIDPipe) id: string,
    @Query('include') include?: string[],
  ) {
    try {
      return await super.findOne(id, include)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Post()
  @ApiOperation({ summary: 'Create FeedSources' })
  async createFeedSources(@Body() data: Prisma.FeedSourcesCreateInput) {
    try {
      return await super.create(data)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Put(':id')
  @ApiOperation({ summary: 'Update FeedSources' })
  async updateFeedSources(
    @Param('id', ParseUUIDPipe) id: string,
    @Body() data: Prisma.FeedSourcesUpdateInput,
  ) {
    try {
      return await super.update(id, data)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Delete(':id')
  @ApiOperation({ summary: 'Delete FeedSources' })
  async removeFeedSources(@Param('id', ParseUUIDPipe) id: string) {
    try {
      return await super.remove(id)
    } catch (error: any) {
      return this.handleError(error)
    }
  }
}

================
File: src/content/controllers/feeds.controller.ts
================
// controller.ejs template
import {
  Controller,
  Get,
  Post,
  Put,
  Delete,
  Body,
  Param,
  Query,
  ParseUUIDPipe,
} from '@nestjs/common'
import { ApiTags, ApiOperation } from '@nestjs/swagger'
import { ConfigService } from '@nestjs/config'
import { PrismaService } from '@core/services/prisma.service'
import { PaginationService } from '@core/services/pagination.service'
import { CustomLogger } from '@core/logger/custom.logger'
import { BaseController } from '@core/base/base.controller'
import { FeedsService } from '../services/feeds.service'

import type { Prisma } from '@astronera/db'
import type { PaginatedResponse, PaginatedQuery } from '@types'

@Controller('feeds')
@ApiTags('Feeds')
export class FeedController extends BaseController {
  constructor(
    protected readonly feedsService: FeedsService,
    protected readonly prisma: PrismaService,
    protected readonly config: ConfigService,
    protected readonly paginationService: PaginationService,
    protected readonly logger: CustomLogger,
  ) {
    super('Feeds')
  }

  @Get()
  @ApiOperation({ summary: 'Get all Feeds' })
  async findAllFeeds(
    @Query() query: PaginatedQuery,
  ): Promise<
    PaginatedResponse<unknown> | { success: boolean; error: any; timestamp: string; code: any }
  > {
    try {
      return await super.findAll(query)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Get(':id')
  @ApiOperation({ summary: 'Get Feeds by id' })
  async findOneFeeds(@Param('id', ParseUUIDPipe) id: string, @Query('include') include?: string[]) {
    try {
      return await super.findOne(id, include)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Post()
  @ApiOperation({ summary: 'Create Feeds' })
  async createFeeds(@Body() data: Prisma.FeedsCreateInput) {
    try {
      return await super.create(data)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Put(':id')
  @ApiOperation({ summary: 'Update Feeds' })
  async updateFeeds(@Param('id', ParseUUIDPipe) id: string, @Body() data: Prisma.FeedsUpdateInput) {
    try {
      return await super.update(id, data)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Delete(':id')
  @ApiOperation({ summary: 'Delete Feeds' })
  async removeFeeds(@Param('id', ParseUUIDPipe) id: string) {
    try {
      return await super.remove(id)
    } catch (error: any) {
      return this.handleError(error)
    }
  }
}

================
File: src/content/controllers/news-summaries.controller.ts
================
// controller.ejs template
import {
  Controller,
  Get,
  Post,
  Put,
  Delete,
  Body,
  Param,
  Query,
  ParseUUIDPipe,
} from '@nestjs/common'
import { ApiTags, ApiOperation } from '@nestjs/swagger'
import { NewsSummariesService } from '../services/news-summaries.service'
import { ConfigService } from '@nestjs/config'
import { PrismaService } from '@core/services/prisma.service'
import { PaginationService } from '@core/services/pagination.service'
import { CustomLogger } from '@core/logger/custom.logger'
import { BaseController } from '@core/base/base.controller'

import type { Prisma } from '@astronera/db'
import type { PaginatedResponse, PaginatedQuery } from '@types'

@Controller('news-summaries')
@ApiTags('NewsSummaries')
export class NewsSummaryController extends BaseController {
  constructor(
    protected readonly newsSummariesService: NewsSummariesService,
    protected readonly prisma: PrismaService,
    protected readonly config: ConfigService,
    protected readonly paginationService: PaginationService,
    protected readonly logger: CustomLogger,
  ) {
    super('NewsSummaries')
  }

  @Get()
  @ApiOperation({ summary: 'Get all NewsSummaries' })
  async findAllNewsSummaries(
    @Query() query: PaginatedQuery,
  ): Promise<
    PaginatedResponse<unknown> | { success: boolean; error: any; timestamp: string; code: any }
  > {
    try {
      return await super.findAll(query)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Get(':id')
  @ApiOperation({ summary: 'Get NewsSummaries by id' })
  async findOneNewsSummaries(
    @Param('id', ParseUUIDPipe) id: string,
    @Query('include') include?: string[],
  ) {
    try {
      return await super.findOne(id, include)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Post()
  @ApiOperation({ summary: 'Create NewsSummaries' })
  async createNewsSummaries(@Body() data: Prisma.NewsSummariesCreateInput) {
    try {
      return await super.create(data)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Put(':id')
  @ApiOperation({ summary: 'Update NewsSummaries' })
  async updateNewsSummaries(
    @Param('id', ParseUUIDPipe) id: string,
    @Body() data: Prisma.NewsSummariesUpdateInput,
  ) {
    try {
      return await super.update(id, data)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Delete(':id')
  @ApiOperation({ summary: 'Delete NewsSummaries' })
  async removeNewsSummaries(@Param('id', ParseUUIDPipe) id: string) {
    try {
      return await super.remove(id)
    } catch (error: any) {
      return this.handleError(error)
    }
  }
}

================
File: src/content/controllers/news-tags.controller.ts
================
// controller.ejs template
import {
  Controller,
  Get,
  Post,
  Put,
  Delete,
  Body,
  Param,
  Query,
  ParseUUIDPipe,
} from '@nestjs/common'
import { ApiTags, ApiOperation } from '@nestjs/swagger'
import { NewsTagsService } from '../services/news-tags.service'
import { ConfigService } from '@nestjs/config'
import { PrismaService } from '@core/services/prisma.service'
import { PaginationService } from '@core/services/pagination.service'
import { CustomLogger } from '@core/logger/custom.logger'
import { BaseController } from '@core/base/base.controller'

import type { Prisma } from '@astronera/db'
import type { PaginatedResponse, PaginatedQuery } from '@types'

@Controller('news-tags')
@ApiTags('NewsTags')
export class NewsTagController extends BaseController {
  constructor(
    protected readonly newsTagsService: NewsTagsService,
    protected readonly prisma: PrismaService,
    protected readonly config: ConfigService,
    protected readonly paginationService: PaginationService,
    protected readonly logger: CustomLogger,
  ) {
    super('NewsTags')
  }

  @Get()
  @ApiOperation({ summary: 'Get all NewsTags' })
  async findAllNewsTags(
    @Query() query: PaginatedQuery,
  ): Promise<
    PaginatedResponse<unknown> | { success: boolean; error: any; timestamp: string; code: any }
  > {
    try {
      return await super.findAll(query)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Get(':id')
  @ApiOperation({ summary: 'Get NewsTags by id' })
  async findOneNewsTags(
    @Param('id', ParseUUIDPipe) id: string,
    @Query('include') include?: string[],
  ) {
    try {
      return await super.findOne(id, include)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Post()
  @ApiOperation({ summary: 'Create NewsTags' })
  async createNewsTags(@Body() data: Prisma.NewsTagsCreateInput) {
    try {
      return await super.create(data)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Put(':id')
  @ApiOperation({ summary: 'Update NewsTags' })
  async updateNewsTags(
    @Param('id', ParseUUIDPipe) id: string,
    @Body() data: Prisma.NewsTagsUpdateInput,
  ) {
    try {
      return await super.update(id, data)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Delete(':id')
  @ApiOperation({ summary: 'Delete NewsTags' })
  async removeNewsTags(@Param('id', ParseUUIDPipe) id: string) {
    try {
      return await super.remove(id)
    } catch (error: any) {
      return this.handleError(error)
    }
  }
}

================
File: src/content/controllers/news.controller.ts
================
// controller.ejs template
import {
  Controller,
  Get,
  Post,
  Put,
  Delete,
  Body,
  Param,
  Query,
  ParseUUIDPipe,
} from '@nestjs/common'
import { ApiTags, ApiOperation } from '@nestjs/swagger'
import { NewsService } from '../services/news.service'
import { ConfigService } from '@nestjs/config'
import { PrismaService } from '@core/services/prisma.service'
import { PaginationService } from '@core/services/pagination.service'
import { CustomLogger } from '@core/logger/custom.logger'
import { BaseController } from '@core/base/base.controller'

import type { Prisma } from '@astronera/db'
import type { PaginatedResponse, PaginatedQuery } from '@types'

@Controller('news')
@ApiTags('News')
export class NewsController extends BaseController {
  constructor(
    protected readonly newsService: NewsService,
    protected readonly prisma: PrismaService,
    protected readonly config: ConfigService,
    protected readonly paginationService: PaginationService,
    protected readonly logger: CustomLogger,
  ) {
    super('News')
  }

  @Get()
  @ApiOperation({ summary: 'Get all News' })
  async findAllNews(
    @Query() query: PaginatedQuery,
  ): Promise<
    PaginatedResponse<unknown> | { success: boolean; error: any; timestamp: string; code: any }
  > {
    try {
      return await super.findAll(query)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Get(':id')
  @ApiOperation({ summary: 'Get News by id' })
  async findOneNews(@Param('id', ParseUUIDPipe) id: string, @Query('include') include?: string[]) {
    try {
      return await super.findOne(id, include)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Post()
  @ApiOperation({ summary: 'Create News' })
  async createNews(@Body() data: Prisma.NewsCreateInput) {
    try {
      return await super.create(data)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Put(':id')
  @ApiOperation({ summary: 'Update News' })
  async updateNews(@Param('id', ParseUUIDPipe) id: string, @Body() data: Prisma.NewsUpdateInput) {
    try {
      return await super.update(id, data)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Delete(':id')
  @ApiOperation({ summary: 'Delete News' })
  async removeNews(@Param('id', ParseUUIDPipe) id: string) {
    try {
      return await super.remove(id)
    } catch (error: any) {
      return this.handleError(error)
    }
  }
}

================
File: src/content/controllers/newsletters.controller.ts
================
// controller.ejs template
import {
  Controller,
  Get,
  Post,
  Put,
  Delete,
  Body,
  Param,
  Query,
  ParseUUIDPipe,
} from '@nestjs/common'
import { ApiTags, ApiOperation } from '@nestjs/swagger'
import { ConfigService } from '@nestjs/config'
import { NewslettersService } from '../services/newsletters.service'
import { PrismaService } from '@core/services/prisma.service'
import { PaginationService } from '@core/services/pagination.service'
import { CustomLogger } from '@core/logger/custom.logger'
import { BaseController } from '@core/base/base.controller'

import type { PaginatedResponse, PaginatedQuery } from '@types'
import type { Prisma } from '@astronera/db'

@Controller('newsletters')
@ApiTags('Newsletters')
export class NewsletterController extends BaseController {
  constructor(
    protected readonly newslettersService: NewslettersService,
    protected readonly prisma: PrismaService,
    protected readonly config: ConfigService,
    protected readonly paginationService: PaginationService,
    protected readonly logger: CustomLogger,
  ) {
    super('Newsletters')
  }

  @Get()
  @ApiOperation({ summary: 'Get all Newsletters' })
  async findAllNewsletters(
    @Query() query: PaginatedQuery,
  ): Promise<
    PaginatedResponse<unknown> | { success: boolean; error: any; timestamp: string; code: any }
  > {
    try {
      return await super.findAll(query)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Get(':id')
  @ApiOperation({ summary: 'Get Newsletters by id' })
  async findOneNewsletters(
    @Param('id', ParseUUIDPipe) id: string,
    @Query('include') include?: string[],
  ) {
    try {
      return await super.findOne(id, include)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Post()
  @ApiOperation({ summary: 'Create Newsletters' })
  async createNewsletters(@Body() data: Prisma.NewslettersCreateInput) {
    try {
      return await super.create(data)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Put(':id')
  @ApiOperation({ summary: 'Update Newsletters' })
  async updateNewsletters(
    @Param('id', ParseUUIDPipe) id: string,
    @Body() data: Prisma.NewslettersUpdateInput,
  ) {
    try {
      return await super.update(id, data)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Delete(':id')
  @ApiOperation({ summary: 'Delete Newsletters' })
  async removeNewsletters(@Param('id', ParseUUIDPipe) id: string) {
    try {
      return await super.remove(id)
    } catch (error: any) {
      return this.handleError(error)
    }
  }
}

================
File: src/content/controllers/research-embeddings.controller.ts
================
// controller.ejs template
import {
  Controller,
  Get,
  Post,
  Put,
  Delete,
  Body,
  Param,
  Query,
  ParseUUIDPipe,
} from '@nestjs/common'
import { ApiTags, ApiOperation } from '@nestjs/swagger'
import { ResearchEmbeddingsService } from '../services/research-embeddings.service'
import { ConfigService } from '@nestjs/config'
import { PrismaService } from '@core/services/prisma.service'
import { PaginationService } from '@core/services/pagination.service'
import { CustomLogger } from '@core/logger/custom.logger'
import { BaseController } from '@core/base/base.controller'

import type { Prisma } from '@astronera/db'
import type { PaginatedResponse, PaginatedQuery } from '@types'

@Controller('research-embeddings')
@ApiTags('ResearchEmbeddings')
export class ResearchEmbeddingController extends BaseController {
  constructor(
    protected readonly researchEmbeddingsService: ResearchEmbeddingsService,
    protected readonly prisma: PrismaService,
    protected readonly config: ConfigService,
    protected readonly paginationService: PaginationService,
    protected readonly logger: CustomLogger,
  ) {
    super('ResearchEmbeddings')
  }

  @Get()
  @ApiOperation({ summary: 'Get all ResearchEmbeddings' })
  async findAllResearchEmbeddings(
    @Query() query: PaginatedQuery,
  ): Promise<
    PaginatedResponse<unknown> | { success: boolean; error: any; timestamp: string; code: any }
  > {
    try {
      return await super.findAll(query)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Get(':id')
  @ApiOperation({ summary: 'Get ResearchEmbeddings by id' })
  async findOneResearchEmbeddings(
    @Param('id', ParseUUIDPipe) id: string,
    @Query('include') include?: string[],
  ) {
    try {
      return await super.findOne(id, include)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Post()
  @ApiOperation({ summary: 'Create ResearchEmbeddings' })
  async createResearchEmbeddings(@Body() data: Prisma.ResearchEmbeddingsCreateInput) {
    try {
      return await super.create(data)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Put(':id')
  @ApiOperation({ summary: 'Update ResearchEmbeddings' })
  async updateResearchEmbeddings(
    @Param('id', ParseUUIDPipe) id: string,
    @Body() data: Prisma.ResearchEmbeddingsUpdateInput,
  ) {
    try {
      return await super.update(id, data)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Delete(':id')
  @ApiOperation({ summary: 'Delete ResearchEmbeddings' })
  async removeResearchEmbeddings(@Param('id', ParseUUIDPipe) id: string) {
    try {
      return await super.remove(id)
    } catch (error: any) {
      return this.handleError(error)
    }
  }
}

================
File: src/content/controllers/research.controller.ts
================
// controller.ejs template
import {
  Controller,
  Get,
  Post,
  Put,
  Delete,
  Body,
  Param,
  Query,
  ParseUUIDPipe,
} from '@nestjs/common'
import { ApiTags, ApiOperation } from '@nestjs/swagger'
import { ConfigService } from '@nestjs/config'
import { PrismaService } from '@core/services/prisma.service'
import { PaginationService } from '@core/services/pagination.service'
import { CustomLogger } from '@core/logger/custom.logger'
import { BaseController } from '@core/base/base.controller'
import { ResearchService } from '../services/research.service'

import type { PaginatedResponse, PaginatedQuery } from '@types'
import type { Prisma } from '@astronera/db'

@Controller('research')
@ApiTags('Research')
export class ResearchController extends BaseController {
  constructor(
    protected readonly researchService: ResearchService,
    protected readonly prisma: PrismaService,
    protected readonly config: ConfigService,
    protected readonly paginationService: PaginationService,
    protected readonly logger: CustomLogger,
  ) {
    super('Research')
  }

  @Get()
  @ApiOperation({ summary: 'Get all Research' })
  async findAllResearch(
    @Query() query: PaginatedQuery,
  ): Promise<
    PaginatedResponse<unknown> | { success: boolean; error: any; timestamp: string; code: any }
  > {
    try {
      return await super.findAll(query)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Get(':id')
  @ApiOperation({ summary: 'Get Research by id' })
  async findOneResearch(
    @Param('id', ParseUUIDPipe) id: string,
    @Query('include') include?: string[],
  ) {
    try {
      return await super.findOne(id, include)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Post()
  @ApiOperation({ summary: 'Create Research' })
  async createResearch(@Body() data: Prisma.ResearchCreateInput) {
    try {
      return await super.create(data)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Put(':id')
  @ApiOperation({ summary: 'Update Research' })
  async updateResearch(
    @Param('id', ParseUUIDPipe) id: string,
    @Body() data: Prisma.ResearchUpdateInput,
  ) {
    try {
      return await super.update(id, data)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Delete(':id')
  @ApiOperation({ summary: 'Delete Research' })
  async removeResearch(@Param('id', ParseUUIDPipe) id: string) {
    try {
      return await super.remove(id)
    } catch (error: any) {
      return this.handleError(error)
    }
  }
}

================
File: src/content/controllers/tags.controller.ts
================
// controller.ejs template
import {
  Controller,
  Get,
  Post,
  Put,
  Delete,
  Body,
  Param,
  Query,
  ParseUUIDPipe,
} from '@nestjs/common'
import { ApiTags, ApiOperation } from '@nestjs/swagger'
import { ConfigService } from '@nestjs/config'
import { TagsService } from '../services/tags.service'
import { PrismaService } from '@core/services/prisma.service'
import { PaginationService } from '@core/services/pagination.service'
import { CustomLogger } from '@core/logger/custom.logger'
import { BaseController } from '@core/base/base.controller'

import type { Prisma } from '@astronera/db'
import type { PaginatedResponse, PaginatedQuery } from '@types'

@Controller('tags')
@ApiTags('Tags')
export class TagController extends BaseController {
  constructor(
    protected readonly tagsService: TagsService,
    protected readonly prisma: PrismaService,
    protected readonly config: ConfigService,
    protected readonly paginationService: PaginationService,
    protected readonly logger: CustomLogger,
  ) {
    super('Tags')
  }

  @Get()
  @ApiOperation({ summary: 'Get all Tags' })
  async findAllTags(
    @Query() query: PaginatedQuery,
  ): Promise<
    PaginatedResponse<unknown> | { success: boolean; error: any; timestamp: string; code: any }
  > {
    try {
      return await super.findAll(query)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Get(':id')
  @ApiOperation({ summary: 'Get Tags by id' })
  async findOneTags(@Param('id', ParseUUIDPipe) id: string, @Query('include') include?: string[]) {
    try {
      return await super.findOne(id, include)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Post()
  @ApiOperation({ summary: 'Create Tags' })
  async createTags(@Body() data: Prisma.TagsCreateInput) {
    try {
      return await super.create(data)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Put(':id')
  @ApiOperation({ summary: 'Update Tags' })
  async updateTags(@Param('id', ParseUUIDPipe) id: string, @Body() data: Prisma.TagsUpdateInput) {
    try {
      return await super.update(id, data)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Delete(':id')
  @ApiOperation({ summary: 'Delete Tags' })
  async removeTags(@Param('id', ParseUUIDPipe) id: string) {
    try {
      return await super.remove(id)
    } catch (error: any) {
      return this.handleError(error)
    }
  }
}

================
File: src/content/models/categories.model.ts
================
// templates/entity/model.ejs
import { BaseModel } from '@core'

// Model interface
export interface CategoryModel extends BaseModel {
  id: string
  created_at: Date
  updated_at?: Date
  body?: string
  name: string
  document_id?: string
  locale?: string
  published_at?: string
}

================
File: src/content/models/content-categories.model.ts
================
// templates/entity/model.ejs
import { BaseModel } from '@core'
import { ContentModel, CategoryModel } from '@content'

// Model interface
export interface ContentCategoryModel extends BaseModel {
  content_id: string

  is_primary: boolean
  categories: CategoryModel
  contents: ContentModel
}

================
File: src/content/models/content-source-visits.model.ts
================
// templates/entity/model.ejs
import { BaseModel } from '@core'
import { ContentModel, CategoryModel } from '@content'

// Model interface
export interface ContentSourceVisitsModel extends BaseModel {
  id: string
  content_id: string
  user_id?: string
  created_at?: Date
  contents: ContentModel

  // userProfiles?: UserProfilesModel;
}

================
File: src/content/models/content-sources.model.ts
================
// templates/entity/model.ejs
import type { ContentType, ScrapeFrequency, Priority } from '@astronera/db'
import { BaseModel } from '@core'
import type { CategoryModel } from '@content'

// Model interface
export interface ContentSourceModel extends BaseModel {
  id: string

  url: string

  content_type: ContentType

  scrape_frequency: ScrapeFrequency

  created_at?: Date

  updated_at?: Date

  refreshed_at?: Date

  has_failed?: boolean

  failed_count?: number

  priority: Priority

  hash?: string

  scraped_at?: Date

  expected_count?: number

  company_id?: string

  rss_urls?: string[]

  // companies?: CompaniesModel;

  contentSources?: ContentSourceModel[]

  // socialMedia?: SocialMediaModel[];

  categories?: CategoryModel[]
}

================
File: src/content/models/content-statuses.model.ts
================
// templates/entity/model.ejs
import { BaseModel } from '@core'
import type { ContentStatus } from '@astronera/db'
import { ContentModel, CategoryModel } from '@content'

// Model interface
export interface ContentStatusesModel extends BaseModel {
  id: string
  content_id: string
  notes?: string
  created_at?: Date
  content_status: ContentStatus
  contents: ContentModel
}

================
File: src/content/models/content-tags.model.ts
================
// templates/entity/model.ejs
import { BaseModel } from '@core'
import { ContentModel, CategoryModel, TagModel } from '@content'

// Model interface
export interface ContentTagModel extends BaseModel {
  content_id: string
  tag_id: number
  contents: ContentModel
  tags: TagModel
}

================
File: src/content/models/contents.model.ts
================
// templates/entity/model.ejs
import { BaseModel } from '@core'
import type { ContentType } from '@astronera/db'

// Model interface
export interface ContentModel extends BaseModel {
  id: string
  content_type: ContentType
  title?: string
  created_at?: Date
  updated_at?: Date
  url: string
  rss_url?: string
  hot_score?: number
  contents: ContentModel[]
}

================
File: src/content/models/embedding-reviews.model.ts
================
// templates/entity/model.ejs
import { BaseModel } from '@core'

// Model interface
export interface EmbeddingReviewModel extends BaseModel {
  id: string

  created_at: Date

  updated_at?: Date

  agent_review?: boolean

  human_review?: boolean

  notes?: string

  embeddingReviews?: EmbeddingReviewModel[]
}

================
File: src/content/models/feed-categories.model.ts
================
// templates/entity/model.ejs
import { BaseModel } from '@core'
import { FeedModel, CategoryModel } from '@content'

// import { UserProfilesModel } from "@auth/models/user-profiles.model";

// Model interface
export interface FeedCategoryModel extends BaseModel {
  id: string

  created_at: Date

  feed_id?: string

  category_id?: string
  categories?: CategoryModel
  feeds?: FeedModel

  // user_profiles?: UserProfilesModel[];
}

================
File: src/content/models/feed-sources.model.ts
================
// templates/entity/model.ejs
import { BaseModel } from '@core'

import type { FeedModel } from '@content/models/feeds.model'

import type { ContentSourceModel } from '@content/models/content-sources.model'

// Model interface
export interface FeedSourceModel extends BaseModel {
  id: string

  feed_id?: string

  created_at: Date

  content_source_id?: string

  feeds?: FeedModel

  // companies?: CompaniesModel[];
  // user_profiles?: UserProfilesModel[];

  content_sources?: ContentSourceModel
}

================
File: src/content/models/feeds.model.ts
================
// templates/entity/model.ejs
import { BaseModel } from '@core'
import { Prisma } from '@astronera/db'

// import { UserProfilesModel } from '@auth/models/user-profiles.model';

// Model interface
export interface FeedModel extends BaseModel {
  id: string
  created_at: Date
  name?: string
  user_id?: string
  feeds?: FeedModel[]
}

================
File: src/content/models/news-summaries.model.ts
================
// templates/entity/model.ejs
import { BaseModel } from '@core'
import { ContentModel, CategoryModel, NewsModel, ContentSourceModel } from '@content'

// import { CompaniesModel } from "@org/models/companies.model";

// Model interface
export interface NewsSummaryModel extends BaseModel {
  id: string
  news_id: string

  summary?: string

  embedding?: string

  complexity_level?: string

  version: number

  is_current?: boolean

  created_at?: Date

  updated_at?: Date

  content_sources: ContentSourceModel[]

  news: NewsModel

  categories: CategoryModel[]

  // companies: CompaniesModel[];

  contents: ContentModel[]
}

================
File: src/content/models/news-tags.model.ts
================
// templates/entity/model.ejs
import { BaseModel } from '@core'
import { TagModel } from '@content'

// Model interface
export interface NewsTagModel extends BaseModel {
  id: number
  tag_id: number
  news_id?: string
  tags: TagModel
}

================
File: src/content/models/news.model.ts
================
// templates/entity/model.ejs
import { BaseModel } from '@core'
import type { ScrapeFrequency, ContentStatus } from '@astronera/db'
import type { ContentSourceModel, ContentModel, CategoryModel } from '@content'

// Model interface
export interface NewsModel extends BaseModel {
  created_at: Date

  updated_at: Date
  title?: string
  body?: string
  category_id?: string
  author?: string
  description?: string
  featured_image?: string
  has_summary: boolean
  published_at?: Date
  url: string
  hash?: string
  id: string
  company_id?: string
  failed_count?: number
  scrape_frequency: ScrapeFrequency
  scraped_at?: Date
  content_status: ContentStatus
  keywords?: Record<string, any>
  score?: number
  content_source_id?: string
  content_sources?: ContentSourceModel
  news: NewsModel[]
  categories?: CategoryModel[]
  contents: ContentModel
  // companies?: CompaniesModel[];
  // social_media?: SocialMediaModel[];
}

================
File: src/content/models/newsletters.model.ts
================
// templates/entity/model.ejs
import { BaseModel } from '@core'
import type { ContentStatus } from '@astronera/db'
import { ContentModel, CategoryModel } from '@content'

// Model interface
export interface NewsletterModel extends BaseModel {
  id: string
  title: string
  frequency: string
  start_date: Date
  end_date: Date
  generated_content?: string
  created_at?: Date
  updated_at?: Date
  content_status: ContentStatus
  contents: ContentModel
}

================
File: src/content/models/research-embeddings.model.ts
================
// templates/entity/model.ejs
import { BaseModel } from '@core'
import type { EmbeddingReviewModel } from '@content/models/embedding-reviews.model'
import { ContentModel, CategoryModel } from '@content'
import type { ResearchModel } from '@content/models/research.model'

// Model interface
export interface ResearchEmbeddingModel extends BaseModel {
  id: number

  research_id: string

  chunk: string

  url?: string

  embedding?: string

  created_at?: Date

  is_flagged?: boolean

  updated_at: Date

  embedding_review_id?: string

  embeddingReviews?: EmbeddingReviewModel

  contents: ContentModel[]

  research: ResearchModel
}

================
File: src/content/models/research.model.ts
================
// templates/entity/model.ejs
import { BaseModel } from '@core'
import type { ContentStatus } from '@astronera/db'
import { ContentModel, CategoryModel } from '@content'

// Model interface
export interface ResearchModel extends BaseModel {
  created_at: Date
  updated_at?: Date
  published_at?: Date
  title?: string
  version?: number
  id: string
  abstract?: string
  keywords?: string
  month?: string
  year?: string
  abstract_url: string
  category?: string
  doi_url?: string
  figure_count?: number
  has_embedding?: boolean
  page_count?: number
  pdf_url?: string
  published_in?: string
  table_count?: number
  comments?: string
  is_flagged: boolean
  authors?: Record<string, any>
  summary?: string
  content_status: ContentStatus
  affiliations?: Record<string, any>
  contents: ContentModel
  research: ResearchModel[]
}

================
File: src/content/models/tags.model.ts
================
// templates/entity/model.ejs
import { BaseModel } from '@core'

// Model interface
export interface TagModel extends BaseModel {
  id: number
  body?: string
  name: string
  document_id?: string
  locale?: string
  published_at?: string
  created_at?: Date
  updated_at?: Date
  tags: TagModel[]
}

================
File: src/content/services/categories.service.ts
================
// templates/service/service.ejs
import { Injectable } from '@nestjs/common'
import type { Prisma } from '@astronera/db'
import { BaseService } from '@core/base/base.service'
import { PaginationService } from '@core/services/pagination.service'
import { PrismaService } from '@core/services/prisma.service'
import type { CategoryModel } from '../models/categories.model'

@Injectable()
export class CategoriesService extends BaseService<'Categories'> {
  constructor(
    protected readonly prisma: PrismaService,
    protected readonly paginationService: PaginationService,
  ) {
    super('Categories')
  }

  async findWithRelations(id: number): Promise<CategoryModel | null> {
    const result = await this.prisma.categories.findUnique({
      where: { id },
      include: {
        companies: true,
        content_categories: true,
        feed_categories: true,
        news: true,
      },
    })
    return result ? this.mapToModel(result) : null
  }

  async findMany(params: Prisma.CategoriesDefaultArgs): Promise<CategoryModel[]> {
    const items = await this.prisma.categories.findMany(params)
    return items.map((item) => this.mapToModel(item))
  }

  async findAllCategories(
    query: Prisma.CategoriesFindManyArgs,
  ): Promise<{ items: CategoryModel[]; total: number }> {
    const [items, total] = await Promise.all([
      this.prisma.categories.findMany({
        skip: query.skip,
        take: query.take,
        where: query.where,
        orderBy: query.orderBy,
      }),
      this.prisma.categories.count({ where: query.where }),
    ])

    return {
      items: items.map((item) => this.mapToModel(item)),
      total,
    }
  }

  private mapToModel(data: any): CategoryModel {
    return {
      ...data,
    }
  }
}

================
File: src/content/services/content-categories.service.ts
================
// templates/service/service.ejs
import { Injectable } from '@nestjs/common'
import type { Prisma } from '@astronera/db'
import { PaginationService } from '@core/services/pagination.service'
import { PrismaService } from '@core/services/prisma.service'
import { BaseService } from '@core/base/base.service'
import type { ContentCategoryModel } from '../models/content-categories.model'

@Injectable()
export class ContentCategoriesService extends BaseService<'ContentCategories'> {
  constructor(
    protected readonly prisma: PrismaService,
    protected readonly paginationService: PaginationService,
  ) {
    super('ContentCategories')
  }

  async findWithRelations(id: string, categoryId: number): Promise<ContentCategoryModel | null> {
    const result = await this.prisma.contentCategories.findUnique({
      where: {
        content_id_category_id: {
          content_id: id,
          category_id: categoryId,
        },
      },
      include: {
        categories: true,
        contents: true,
      },
    })
    return result ? this.mapToModel(result) : null
  }

  async findMany(params: Prisma.ContentCategoriesDefaultArgs): Promise<ContentCategoryModel[]> {
    const items = await this.prisma.contentCategories.findMany(params)
    return items.map((item) => this.mapToModel(item))
  }

  async findAllContentCategories(
    query: Prisma.ContentCategoriesFindManyArgs,
  ): Promise<{ items: ContentCategoryModel[]; total: number }> {
    const [items, total] = await Promise.all([
      this.prisma.contentCategories.findMany({
        skip: query.skip,
        take: query.take,
        where: query.where,
        orderBy: query.orderBy,

        include: {
          categories: true,

          contents: true,
        },
      }),
      this.prisma.contentCategories.count({ where: query.where }),
    ])

    return {
      items: items.map((item) => this.mapToModel(item)),
      total,
    }
  }

  private mapToModel(data: any): ContentCategoryModel {
    return {
      ...data,
    }
  }
}

================
File: src/content/services/content-source-visits.service.ts
================
// templates/service/service.ejs
import { Injectable } from '@nestjs/common'
import type { Prisma } from '@astronera/db'
import { BaseService } from '@core/base/base.service'
import { PaginationService } from '@core/services/pagination.service'
import { PrismaService } from '@core/services/prisma.service'
import { ContentSourceVisitsModel } from '../models/content-source-visits.model'

@Injectable()
export class ContentSourceVisitService extends BaseService<'ContentSourceVisits'> {
  constructor(
    protected readonly prisma: PrismaService,
    protected readonly paginationService: PaginationService,
  ) {
    super('ContentSourceVisits')
  }

  async findWithRelations(id: string): Promise<ContentSourceVisitsModel | null> {
    const result = await this.prisma.contentSourceVisits.findUnique({
      where: { id },
      include: {
        contents: true,
        user_profiles: true,
      },
    })
    return result ? this.mapToModel(result) : null
  }

  async findMany(
    params: Prisma.ContentSourceVisitsDefaultArgs,
  ): Promise<ContentSourceVisitsModel[]> {
    const items = await this.prisma.contentSourceVisits.findMany(params)
    return items.map((item) => this.mapToModel(item))
  }

  async findAllContentSourceVisits(
    query: Prisma.ContentSourceVisitsFindManyArgs,
  ): Promise<{ items: ContentSourceVisitsModel[]; total: number }> {
    const [items, total] = await Promise.all([
      this.prisma.contentSourceVisits.findMany({
        skip: query.skip,
        take: query.take,
        where: query.where,
        orderBy: query.orderBy,
      }),
      this.prisma.contentSourceVisits.count({ where: query.where }),
    ])

    return {
      items: items.map((item) => this.mapToModel(item)),
      total,
    }
  }

  private mapToModel(data: any): ContentSourceVisitsModel {
    return {
      ...data,
    }
  }
}

================
File: src/content/services/content-sources.service.ts
================
// templates/service/service.ejs
import { Injectable } from '@nestjs/common'
import { BaseService } from '@core/base/base.service'
import { PaginationService } from '@core/services/pagination.service'
import { PrismaService } from '@core/services/prisma.service'
import { ContentSourceModel } from '../models/content-sources.model'
import { Prisma } from '@astronera/db'

@Injectable()
export class ContentSourcesService extends BaseService<'ContentSources'> {
  constructor(
    protected readonly prisma: PrismaService,
    protected readonly paginationService: PaginationService,
  ) {
    super('ContentSources')
  }

  async findWithRelations(id: number): Promise<ContentSourceModel | null> {
    const result = await this.prisma.contentSources.findUnique({
      where: { id },
      include: {
        companies: true,
        feed_sources: true,
        news: true,
      },
    })
    return result ? this.mapToModel(result) : null
  }

  async findMany(params: Prisma.ContentSourcesDefaultArgs): Promise<ContentSourceModel[]> {
    const items = await this.prisma.contentSources.findMany(params)
    return items.map((item) => this.mapToModel(item))
  }

  async findAllContentSources(
    query: Prisma.ContentSourcesFindManyArgs,
  ): Promise<{ items: ContentSourceModel[]; total: number }> {
    const [items, total] = await Promise.all([
      this.prisma.contentSources.findMany({
        skip: query.skip,
        take: query.take,
        where: query.where,
        orderBy: query.orderBy,
      }),
      this.prisma.contentSources.count({ where: query.where }),
    ])

    return {
      items: items.map((item) => this.mapToModel(item)),
      total,
    }
  }

  private mapToModel(data: any): ContentSourceModel {
    return {
      ...data,
    }
  }
}

================
File: src/content/services/content-statuses.service.ts
================
// templates/service/service.ejs
import { Injectable } from '@nestjs/common'
import { BaseService } from '@core/base/base.service'
import { PaginationService } from '@core/services/pagination.service'
import { PrismaService } from '@core/services/prisma.service'
import { ContentStatusesModel } from '../models/content-statuses.model'
import type { Prisma } from '@astronera/db'

@Injectable()
export class ContentStatusesService extends BaseService<'ContentStatuses'> {
  constructor(
    protected readonly prisma: PrismaService,
    protected readonly paginationService: PaginationService,
  ) {
    super('ContentStatuses')
  }

  async findWithRelations(id: string): Promise<ContentStatusesModel | null> {
    const result = await this.prisma.contentStatuses.findUnique({
      where: { id },
      include: {
        contents: true,
      },
    })
    return result ? this.mapToModel(result) : null
  }

  async findMany(params: Prisma.ContentStatusesDefaultArgs): Promise<ContentStatusesModel[]> {
    const items = await this.prisma.contentStatuses.findMany(params)
    return items.map((item) => this.mapToModel(item))
  }

  async findAllContentStatuses(
    query: Prisma.ContentStatusesFindManyArgs,
  ): Promise<{ items: ContentStatusesModel[]; total: number }> {
    const [items, total] = await Promise.all([
      this.prisma.contentStatuses.findMany({
        skip: query.skip,
        take: query.take,
        where: query.where,
        orderBy: query.orderBy,
      }),
      this.prisma.contentStatuses.count({ where: query.where }),
    ])

    return {
      items: items.map((item) => this.mapToModel(item)),
      total,
    }
  }

  private mapToModel(data: any): ContentStatusesModel {
    return {
      ...data,
    }
  }
}

================
File: src/content/services/content-tags.service.ts
================
// templates/service/service.ejs
import { Injectable } from '@nestjs/common'
import { BaseService } from '@core/base/base.service'
import { PaginationService } from '@core/services/pagination.service'
import { PrismaService } from '@core/services/prisma.service'
import { ContentTagModel } from '../models/content-tags.model'
import type { Prisma } from '@astronera/db'

@Injectable()
export class ContentTagsService extends BaseService<'ContentTags'> {
  constructor(
    protected readonly prisma: PrismaService,
    protected readonly paginationService: PaginationService,
  ) {
    super('ContentTags')
  }

  async findWithRelations(id: string, tagId: number): Promise<ContentTagModel | null> {
    const result = await this.prisma.contentTags.findUnique({
      where: { content_id_tag_id: { content_id: id, tag_id: tagId } },
      include: {
        contents: true,
        tags: true,
      },
    })
    return result ? this.mapToModel(result) : null
  }

  async findMany(params: Prisma.ContentTagsDefaultArgs): Promise<ContentTagModel[]> {
    const items = await this.prisma.contentTags.findMany(params)
    return items.map((item) => this.mapToModel(item))
  }

  async findAllContentTags(
    query: Prisma.ContentTagsFindManyArgs,
  ): Promise<{ items: ContentTagModel[]; total: number }> {
    const [items, total] = await Promise.all([
      this.prisma.contentTags.findMany({
        skip: query.skip,
        take: query.take,
        where: query.where,
        orderBy: query.orderBy,
      }),
      this.prisma.contentTags.count({ where: query.where }),
    ])

    return {
      items: items.map((item) => this.mapToModel(item)),
      total,
    }
  }

  private mapToModel(data: any): ContentTagModel {
    return {
      ...data,
    }
  }
}

================
File: src/content/services/content.service.ts
================
// templates/service/service.ejs
import { Injectable } from '@nestjs/common'
import { BaseService } from '@core/base/base.service'
import { PaginationService } from '@core/services/pagination.service'
import { PrismaService } from '@core/services/prisma.service'
import { ContentModel } from '../models/contents.model'
import type { Prisma } from '@astronera/db'
import type { PaginatedQuery } from '@types'

@Injectable()
export class ContentService extends BaseService<'Contents'> {
  constructor(
    protected readonly prisma: PrismaService,
    protected readonly paginationService: PaginationService,
  ) {
    super('Contents')
  }

  async findWithRelations(id: string): Promise<ContentModel | null> {
    const result = await this.prisma.contents.findUnique({
      where: { id },
      include: {
        bookmarks: true,
        content_statuses: true,
        content_tags: true,
        content_categories: true,
        content_source_visits: true,
        news: true,
        newsletters: true,
        research: true,
      },
    })
    return result ? this.mapToModel(result) : null
  }

  async findMany(params: Prisma.ContentsDefaultArgs): Promise<ContentModel[]> {
    const items = await this.prisma.contents.findMany(params)
    return items.map((item) => this.mapToModel(item))
  }

  async getAllContent(query: PaginatedQuery) {
    const { skip, take } = this.paginationService.getSkipTake(query)

    const [items, total] = await Promise.all([
      this.prisma.contents.findMany({
        where: {
          content_type: 'news',
        },
        skip,
        take,
        select: {
          id: true,
          title: true,
          url: true,
          content_type: true,
          hot_score: true,
          created_at: true,
          updated_at: true,
          // Include related news data
          news: {
            select: {
              description: true,
              featured_image: true,
              author: true,
              published_at: true,
              news_summaries: {
                where: {
                  is_current: true, // Only get current summaries
                },
                select: {
                  summary: true,
                  complexity_level: true,
                  version: true,
                },
              },
              companies: {
                select: {
                  logo_url: true,
                  name: true,
                },
              },
            },
          },
          content_categories: {
            select: {
              is_primary: true,
              categories: {
                select: {
                  name: true,
                },
              },
            },
          },
          content_tags: {
            select: {
              tags: {
                select: {
                  name: true,
                },
              },
            },
          },
        },
        orderBy: {
          created_at: 'desc',
        },
      }),
      this.prisma.contents.count({
        where: {
          content_type: 'news',
        },
      }),
    ])

    const transformedItems = items.map((content) => ({
      id: content.id,
      title: content.title,
      url: content.url,
      type: content.content_type,
      hotScore: content.hot_score,
      createdAt: content.created_at.toISOString(), // Format the date
      updatedAt: content.updated_at.toISOString(), // Format the date
      description: content.news?.description,
      featuredImage: content.news?.featured_image,
      author: content.news?.author,
      publishedAt: content.news?.published_at?.toISOString(), // Format optional date
      summary: content.news?.news_summaries?.[0]?.summary, // Get the current summary
      summaryComplexity: content.news?.news_summaries?.[0]?.complexity_level,
      summaryVersion: content.news?.news_summaries?.[0]?.version,
      companyLogo: content.news?.companies?.logo_url,
      companyName: content.news?.companies?.name,
      categories: content.content_categories.map((cc) => ({
        name: cc.categories.name,
        isPrimary: cc.is_primary,
      })),
      tags: content.content_tags.map((ct) => ct.tags.name),
    }))

    return {
      data: transformedItems,
      meta: this.paginationService.getPaginationMeta(total, query),
      timestamp: new Date().toISOString(),
    }
  }

  private mapToModel(data: any): ContentModel {
    return {
      ...data,
    }
  }
}

================
File: src/content/services/embedding-reviews.service.ts
================
// templates/service/service.ejs
import { Injectable } from '@nestjs/common'
import type { Prisma } from '@astronera/db'
import { BaseService } from '@core/base/base.service'
import { PaginationService } from '@core/services/pagination.service'
import { PrismaService } from '@core/services/prisma.service'
import { EmbeddingReviewModel } from '../models/embedding-reviews.model'

@Injectable()
export class EmbeddingReviewsService extends BaseService<'EmbeddingReviews'> {
  constructor(
    protected readonly prisma: PrismaService,
    protected readonly paginationService: PaginationService,
  ) {
    super('EmbeddingReviews')
  }

  async findWithRelations(id: number): Promise<EmbeddingReviewModel | null> {
    const result = await this.prisma.embeddingReviews.findUnique({
      where: { id },
      include: {
        research_embeddings: true,
      },
    })
    return result ? this.mapToModel(result) : null
  }

  async findMany(params: Prisma.EmbeddingReviewsDefaultArgs): Promise<EmbeddingReviewModel[]> {
    const items = await this.prisma.embeddingReviews.findMany(params)
    return items.map((item) => this.mapToModel(item))
  }

  async findAllEmbeddingReviews(
    query: Prisma.EmbeddingReviewsFindManyArgs,
  ): Promise<{ items: EmbeddingReviewModel[]; total: number }> {
    const [items, total] = await Promise.all([
      this.prisma.embeddingReviews.findMany({
        skip: query.skip,
        take: query.take,
        where: query.where,
        orderBy: query.orderBy,
      }),
      this.prisma.embeddingReviews.count({ where: query.where }),
    ])

    return {
      items: items.map((item) => this.mapToModel(item)),
      total,
    }
  }

  private mapToModel(data: any): EmbeddingReviewModel {
    return {
      ...data,
    }
  }
}

================
File: src/content/services/feed-categories.service.ts
================
import { Injectable } from '@nestjs/common'
import type { Prisma } from '@astronera/db'
import { BaseService } from '@core/base/base.service'
import { PaginationService } from '@core/services/pagination.service'
import { PrismaService } from '@core/services/prisma.service'
import type { FeedCategoryModel } from '../models/feed-categories.model'

@Injectable()
export class FeedCategoriesService extends BaseService<'FeedCategories'> {
  constructor(
    protected readonly prisma: PrismaService,
    protected readonly paginationService: PaginationService,
  ) {
    super('FeedCategories')
  }

  async findWithRelations(id: number): Promise<FeedCategoryModel | null> {
    const result = await this.prisma.feedCategories.findUnique({
      where: { id },
      include: {
        categories: true,
        feeds: true,
      },
    })
    return result ? this.mapToModel(result) : null
  }

  async findMany(params: Prisma.FeedCategoriesDefaultArgs): Promise<FeedCategoryModel[]> {
    const items = await this.prisma.feedCategories.findMany(params)
    return items.map((item) => this.mapToModel(item))
  }

  async findAllFeedCategories(
    query: Prisma.FeedCategoriesFindManyArgs,
  ): Promise<{ items: FeedCategoryModel[]; total: number }> {
    const [items, total] = await Promise.all([
      this.prisma.feedCategories.findMany({
        skip: query.skip,
        take: query.take,
        where: query.where,
        orderBy: query.orderBy,
      }),
      this.prisma.feedCategories.count({ where: query.where }),
    ])

    return {
      items: items.map((item) => this.mapToModel(item)),
      total,
    }
  }

  private mapToModel(data: any): FeedCategoryModel {
    return {
      ...data,
    }
  }
}

================
File: src/content/services/feed-sources.service.ts
================
// templates/service/service.ejs
import { Injectable } from '@nestjs/common'
import type { Prisma } from '@astronera/db'
import { BaseService } from '@core/base/base.service'
import { PaginationService } from '@core/services/pagination.service'
import { PrismaService } from '@core/services/prisma.service'
import type { FeedSourceModel } from '../models/feed-sources.model'

@Injectable()
export class FeedSourceService extends BaseService<'FeedSources'> {
  constructor(
    protected readonly prisma: PrismaService,
    protected readonly paginationService: PaginationService,
  ) {
    super('FeedSources')
  }

  async findWithRelations(id: number): Promise<FeedSourceModel | null> {
    const result = await this.prisma.feedSources.findUnique({
      where: { id },
      include: {
        content_sources: true,
        feeds: true,
      },
    })
    return result ? this.mapToModel(result) : null
  }

  async findMany(params: Prisma.FeedSourcesDefaultArgs): Promise<FeedSourceModel[]> {
    const items = await this.prisma.feedSources.findMany(params)
    return items.map((item) => this.mapToModel(item))
  }

  async findAllFeedSources(
    query: Prisma.FeedSourcesFindManyArgs,
  ): Promise<{ items: FeedSourceModel[]; total: number }> {
    const [items, total] = await Promise.all([
      this.prisma.feedSources.findMany({
        skip: query.skip,
        take: query.take,
        where: query.where,
        orderBy: query.orderBy,
      }),
      this.prisma.feedSources.count({ where: query.where }),
    ])

    return {
      items: items.map((item) => this.mapToModel(item)),
      total,
    }
  }

  private mapToModel(data: any): FeedSourceModel {
    return {
      ...data,
    }
  }
}

================
File: src/content/services/feeds.service.ts
================
// templates/service/service.ejs
import { Injectable } from '@nestjs/common'
import type { Prisma } from '@astronera/db'
import { BaseService } from '@core/base/base.service'
import { PaginationService } from '@core/services/pagination.service'
import { PrismaService } from '@core/services/prisma.service'
import type { FeedModel } from '../models/feeds.model'

@Injectable()
export class FeedsService extends BaseService<'Feeds'> {
  constructor(
    protected readonly prisma: PrismaService,
    protected readonly paginationService: PaginationService,
  ) {
    super('Feeds')
  }

  async findWithRelations(id: string): Promise<FeedModel | null> {
    const result = await this.prisma.feeds.findUnique({
      where: { id },
      include: {
        feed_categories: true,
        feed_sources: true,
        user_profiles: true,
      },
    })
    return result ? this.mapToModel(result) : null
  }

  async findMany(params: Prisma.FeedsDefaultArgs): Promise<FeedModel[]> {
    const items = await this.prisma.feeds.findMany(params)
    return items.map((item) => this.mapToModel(item))
  }

  async findAllFeeds(
    query: Prisma.FeedsFindManyArgs,
  ): Promise<{ items: FeedModel[]; total: number }> {
    const [items, total] = await Promise.all([
      this.prisma.feeds.findMany({
        skip: query.skip,
        take: query.take,
        where: query.where,
        orderBy: query.orderBy,
      }),
      this.prisma.feeds.count({ where: query.where }),
    ])

    return {
      items: items.map((item) => this.mapToModel(item)),
      total,
    }
  }

  private mapToModel(data: any): FeedModel {
    return {
      ...data,
    }
  }
}

================
File: src/content/services/news-summaries.service.ts
================
// templates/service/service.ejs
import { Injectable } from '@nestjs/common'
import type { Prisma } from '@astronera/db'
import { BaseService } from '@core/base/base.service'
import { PaginationService } from '@core/services/pagination.service'
import { PrismaService } from '@core/services/prisma.service'
import { NewsSummaryModel } from '../models/news-summaries.model'

@Injectable()
export class NewsSummariesService extends BaseService<'NewsSummaries'> {
  constructor(
    protected readonly prisma: PrismaService,
    protected readonly paginationService: PaginationService,
  ) {
    super('NewsSummaries')
  }

  async findWithRelations(id: string): Promise<NewsSummaryModel | null> {
    const result = await this.prisma.newsSummaries.findUnique({
      where: { id },
      include: {
        news: true,
      },
    })
    return result ? this.mapToModel(result) : null
  }

  async findMany(params: Prisma.NewsSummariesDefaultArgs): Promise<NewsSummaryModel[]> {
    const items = await this.prisma.newsSummaries.findMany(params)
    return items.map((item) => this.mapToModel(item))
  }

  async findAllNewsSummaries(
    query: Prisma.NewsSummariesFindManyArgs,
  ): Promise<{ items: NewsSummaryModel[]; total: number }> {
    const [items, total] = await Promise.all([
      this.prisma.newsSummaries.findMany({
        skip: query.skip,
        take: query.take,
        where: query.where,
        orderBy: query.orderBy,
      }),
      this.prisma.newsSummaries.count({ where: query.where }),
    ])

    return {
      items: items.map((item) => this.mapToModel(item)),
      total,
    }
  }

  private mapToModel(data: any): NewsSummaryModel {
    return {
      ...data,
    }
  }
}

================
File: src/content/services/news-tags.service.ts
================
// templates/service/service.ejs
import { Injectable } from '@nestjs/common'
import type { Prisma } from '@astronera/db'
import { BaseService } from '@core/base/base.service'
import { PaginationService } from '@core/services/pagination.service'
import { PrismaService } from '@core/services/prisma.service'
import { NewsTagModel } from '../models/news-tags.model'

@Injectable()
export class NewsTagsService extends BaseService<'NewsTags'> {
  constructor(
    protected readonly prisma: PrismaService,
    protected readonly paginationService: PaginationService,
  ) {
    super('NewsTags')
  }

  async findWithRelations(id: number): Promise<NewsTagModel | null> {
    const result = await this.prisma.newsTags.findUnique({
      where: { id },
      include: {
        tags: true,
      },
    })
    return result ? this.mapToModel(result) : null
  }

  async findMany(params: Prisma.NewsTagsDefaultArgs): Promise<NewsTagModel[]> {
    const items = await this.prisma.newsTags.findMany(params)
    return items.map((item) => this.mapToModel(item))
  }

  async findAllNewsTags(
    query: Prisma.NewsTagsFindManyArgs,
  ): Promise<{ items: NewsTagModel[]; total: number }> {
    const [items, total] = await Promise.all([
      this.prisma.newsTags.findMany({
        skip: query.skip,
        take: query.take,
        where: query.where,
        orderBy: query.orderBy,
      }),
      this.prisma.newsTags.count({ where: query.where }),
    ])

    return {
      items: items.map((item) => this.mapToModel(item)),
      total,
    }
  }

  private mapToModel(data: any): NewsTagModel {
    return {
      ...data,
    }
  }
}

================
File: src/content/services/news.service.ts
================
// templates/service/service.ejs
import { Injectable } from '@nestjs/common'
import type { Prisma } from '@astronera/db'
import { BaseService } from '@core/base/base.service'
import { PaginationService } from '@core/services/pagination.service'
import { PrismaService } from '@core/services/prisma.service'
import { NewsModel } from '../models/news.model'

@Injectable()
export class NewsService extends BaseService<'News'> {
  constructor(
    protected readonly prisma: PrismaService,
    protected readonly paginationService: PaginationService,
  ) {
    super('News')
  }

  async findWithRelations(id: string): Promise<NewsModel | null> {
    const result = await this.prisma.news.findUnique({
      where: { id },
      include: {
        companies: true,
        categories: true,
        content_sources: true,
        contents: true,
        news_summaries: true,
      },
    })
    return result ? this.mapToModel(result) : null
  }

  async findMany(params: Prisma.NewsDefaultArgs): Promise<NewsModel[]> {
    const items = await this.prisma.news.findMany(params)
    return items.map((item) => this.mapToModel(item))
  }

  async findAllNews(
    query: Prisma.NewsFindManyArgs,
  ): Promise<{ items: NewsModel[]; total: number }> {
    const [items, total] = await Promise.all([
      this.prisma.news.findMany({
        skip: query.skip,
        take: query.take,
        where: query.where,
        orderBy: query.orderBy,
      }),
      this.prisma.news.count({ where: query.where }),
    ])

    return {
      items: items.map((item) => this.mapToModel(item)),
      total,
    }
  }

  private mapToModel(data: any): NewsModel {
    return {
      ...data,
    }
  }
}

================
File: src/content/services/newsletters.service.ts
================
// templates/service/service.ejs
import { Injectable } from '@nestjs/common'
import type { Prisma } from '@astronera/db'
import { BaseService } from '@core/base/base.service'
import { PaginationService } from '@core/services/pagination.service'
import { PrismaService } from '@core/services/prisma.service'
import { NewsletterModel } from '../models/newsletters.model'

@Injectable()
export class NewslettersService extends BaseService<'Newsletters'> {
  constructor(
    protected readonly prisma: PrismaService,
    protected readonly paginationService: PaginationService,
  ) {
    super('Newsletters')
  }

  async findWithRelations(id: string): Promise<NewsletterModel | null> {
    const result = await this.prisma.newsletters.findUnique({
      where: { id },
      include: {
        contents: true,
      },
    })
    return result ? this.mapToModel(result) : null
  }

  async findMany(params: Prisma.NewslettersDefaultArgs): Promise<NewsletterModel[]> {
    const items = await this.prisma.newsletters.findMany(params)
    return items.map((item) => this.mapToModel(item))
  }

  async findAllNewsletters(
    query: Prisma.NewslettersFindManyArgs,
  ): Promise<{ items: NewsletterModel[]; total: number }> {
    const [items, total] = await Promise.all([
      this.prisma.newsletters.findMany({
        skip: query.skip,
        take: query.take,
        where: query.where,
        orderBy: query.orderBy,
      }),
      this.prisma.newsletters.count({ where: query.where }),
    ])

    return {
      items: items.map((item) => this.mapToModel(item)),
      total,
    }
  }

  private mapToModel(data: any): NewsletterModel {
    return {
      ...data,
    }
  }
}

================
File: src/content/services/research-embeddings.service.ts
================
// templates/service/service.ejs
import { Injectable } from '@nestjs/common'
import type { Prisma } from '@astronera/db'
import { BaseService } from '@core/base/base.service'
import { PaginationService } from '@core/services/pagination.service'
import { PrismaService } from '@core/services/prisma.service'
import { ResearchEmbeddingModel } from '../models/research-embeddings.model'

@Injectable()
export class ResearchEmbeddingsService extends BaseService<'ResearchEmbeddings'> {
  constructor(
    protected readonly prisma: PrismaService,
    protected readonly paginationService: PaginationService,
  ) {
    super('ResearchEmbeddings')
  }

  async findWithRelations(id: number): Promise<ResearchEmbeddingModel | null> {
    const result = await this.prisma.researchEmbeddings.findUnique({
      where: { id },
      include: {
        embedding_reviews: true,
        research: true,
      },
    })
    return result ? this.mapToModel(result) : null
  }

  async findMany(params: Prisma.ResearchEmbeddingsDefaultArgs): Promise<ResearchEmbeddingModel[]> {
    const items = await this.prisma.researchEmbeddings.findMany(params)
    return items.map((item) => this.mapToModel(item))
  }

  async findAllResearchEmbeddings(
    query: Prisma.ResearchEmbeddingsFindManyArgs,
  ): Promise<{ items: ResearchEmbeddingModel[]; total: number }> {
    const [items, total] = await Promise.all([
      this.prisma.researchEmbeddings.findMany({
        skip: query.skip,
        take: query.take,
        where: query.where,
        orderBy: query.orderBy,
      }),
      this.prisma.researchEmbeddings.count({ where: query.where }),
    ])

    return {
      items: items.map((item) => this.mapToModel(item)),
      total,
    }
  }

  private mapToModel(data: any): ResearchEmbeddingModel {
    return {
      ...data,
    }
  }
}

================
File: src/content/services/research.service.ts
================
// templates/service/service.ejs
import { Injectable } from '@nestjs/common'
import type { Prisma } from '@astronera/db'
import { BaseService } from '@core/base/base.service'
import { PaginationService } from '@core/services/pagination.service'
import { PrismaService } from '@core/services/prisma.service'
import { ResearchModel } from '../models/research.model'

@Injectable()
export class ResearchService extends BaseService<'Research'> {
  constructor(
    protected readonly prisma: PrismaService,
    protected readonly paginationService: PaginationService,
  ) {
    super('Research')
  }

  async findWithRelations(id: string): Promise<ResearchModel | null> {
    const result = await this.prisma.research.findUnique({
      where: { id },
      include: {
        contents: true,
        research_embeddings: true,
      },
    })
    return result ? this.mapToModel(result) : null
  }

  async findMany(params: Prisma.ResearchDefaultArgs): Promise<ResearchModel[]> {
    const items = await this.prisma.research.findMany(params)
    return items.map((item) => this.mapToModel(item))
  }

  async findAllResearch(
    query: Prisma.ResearchFindManyArgs,
  ): Promise<{ items: ResearchModel[]; total: number }> {
    const [items, total] = await Promise.all([
      this.prisma.research.findMany({
        skip: query.skip,
        take: query.take,
        where: query.where,
        orderBy: query.orderBy,
      }),
      this.prisma.research.count({ where: query.where }),
    ])

    return {
      items: items.map((item) => this.mapToModel(item)),
      total,
    }
  }

  private mapToModel(data: any): ResearchModel {
    return {
      ...data,
    }
  }
}

================
File: src/content/services/tags.service.ts
================
// templates/service/service.ejs
import { Injectable } from '@nestjs/common'
import type { Prisma } from '@astronera/db'
import { BaseService } from '@core/base/base.service'
import { PaginationService } from '@core/services/pagination.service'
import { PrismaService } from '@core/services/prisma.service'
import { TagModel } from '../models/tags.model'

@Injectable()
export class TagsService extends BaseService<'Tags'> {
  constructor(
    protected readonly prisma: PrismaService,
    protected readonly paginationService: PaginationService,
  ) {
    super('Tags')
  }

  async findWithRelations(id: number): Promise<TagModel | null> {
    const result = await this.prisma.tags.findUnique({
      where: { id },
      include: {
        content_tags: true,
        news_tags: true,
      },
    })
    return result ? this.mapToModel(result) : null
  }

  async findMany(params: Prisma.TagsDefaultArgs): Promise<TagModel[]> {
    const items = await this.prisma.tags.findMany(params)
    return items.map((item) => this.mapToModel(item))
  }

  async findAllTags(query: Prisma.TagsFindManyArgs): Promise<{ items: TagModel[]; total: number }> {
    const [items, total] = await Promise.all([
      this.prisma.tags.findMany({
        skip: query.skip,
        take: query.take,
        where: query.where,
        orderBy: query.orderBy,
      }),
      this.prisma.tags.count({ where: query.where }),
    ])

    return {
      items: items.map((item) => this.mapToModel(item)),
      total,
    }
  }

  private mapToModel(data: any): TagModel {
    return {
      ...data,
    }
  }
}

================
File: src/content/content.module.ts
================
// templates/module/content.module.ejs
import { Module } from '@nestjs/common'
import { CoreModule } from '@core/core.module'
import { PrismaModule } from '@core/modules/prisma.module'
import { PermissionModule } from '@core/modules/permission.module'
import { createDomainModule } from '@core/config/domain-config'
// Controllers
import { ResearchEmbeddingController } from '@content/controllers/research-embeddings.controller'
import { EmbeddingReviewController } from '@content/controllers/embedding-reviews.controller'
import { ContentCategoryController } from '@content/controllers/content-categories.controller'
import { ContentTagController } from '@content/controllers/content-tags.controller'
import { ContentStatusController } from '@content/controllers/content-statuses.controller'
import { NewsletterController } from '@content/controllers/newsletters.controller'
import { ResearchController } from '@content/controllers/research.controller'
import { CategoryController } from '@content/controllers/categories.controller'
import { FeedCategoryController } from '@content/controllers/feed-categories.controller'
import { FeedController } from '@content/controllers/feeds.controller'
import { ContentSourceController } from '@content/controllers/content-sources.controller'
import { TagController } from '@content/controllers/tags.controller'
import { NewsController } from '@content/controllers/news.controller'
import { NewsTagController } from '@content/controllers/news-tags.controller'
import { ContentSourceVisitController } from '@content/controllers/content-source-visits.controller'
import { FeedSourceController } from '@content/controllers/feed-sources.controller'
import { ContentController } from '@content/controllers/content.controller'
import { NewsSummaryController } from '@content/controllers/news-summaries.controller'

// Services
import { ResearchEmbeddingsService } from '@content/services/research-embeddings.service'
import { EmbeddingReviewsService } from '@content/services/embedding-reviews.service'
import { ContentCategoriesService } from '@content/services/content-categories.service'
import { ContentTagsService } from '@content/services/content-tags.service'
import { ContentStatusesService } from '@content/services/content-statuses.service'
import { NewslettersService } from '@content/services/newsletters.service'
import { ResearchService } from '@content/services/research.service'
import { CategoriesService } from '@content/services/categories.service'
import { FeedCategoriesService } from '@content/services/feed-categories.service'
import { FeedsService } from '@content/services/feeds.service'
import { ContentSourcesService } from '@content/services/content-sources.service'
import { TagsService } from '@content/services/tags.service'
import { NewsService } from '@content/services/news.service'
import { NewsTagsService } from '@content/services/news-tags.service'
import { ContentSourceVisitService } from '@content/services/content-source-visits.service'
import { FeedSourceService } from '@content/services/feed-sources.service'
import { ContentService } from '@content/services/content.service'
import { NewsSummariesService } from '@content/services/news-summaries.service'

@Module({
  imports: [
    PrismaModule,
    PermissionModule,
    CoreModule,
    createDomainModule('content', {
      requiresAuth: true,
      requiresCompany: false,
    }),
  ],
  controllers: [
    ResearchEmbeddingController,
    EmbeddingReviewController,
    ContentCategoryController,
    ContentTagController,
    ContentStatusController,
    NewsletterController,
    ResearchController,
    CategoryController,
    FeedCategoryController,
    FeedController,
    ContentSourceController,
    TagController,
    NewsController,
    NewsTagController,
    ContentSourceVisitController,
    FeedSourceController,
    ContentController,
    NewsSummaryController,
  ],
  providers: [
    EmbeddingReviewsService,
    ResearchEmbeddingsService,
    ContentCategoriesService,
    ContentTagsService,
    ContentStatusesService,
    NewslettersService,
    ResearchService,
    CategoriesService,
    FeedCategoriesService,
    FeedsService,
    ContentSourcesService,
    TagsService,
    NewsService,
    NewsTagsService,
    ContentSourceVisitService,
    FeedSourceService,
    ContentService,
    NewsSummariesService,
  ],
  exports: [
    ResearchEmbeddingsService,
    EmbeddingReviewsService,
    ContentCategoriesService,
    ContentTagsService,
    ContentStatusesService,
    NewslettersService,
    ResearchService,
    CategoriesService,
    FeedCategoriesService,
    FeedsService,
    ContentSourcesService,
    TagsService,
    NewsService,
    NewsTagsService,
    ContentSourceVisitService,
    FeedSourceService,
    ContentService,
    NewsSummariesService,
  ],
})
export class ContentModule {}

================
File: src/content/index.ts
================
/**
 * @file Auto-generated barrel file
 * @generated
 */

export * from './models/categories.model'
export * from './models/content-categories.model'
export * from './models/content-source-visits.model'
export * from './models/content-sources.model'
export * from './models/content-statuses.model'
export * from './models/content-tags.model'
export * from './models/contents.model'
export * from './models/embedding-reviews.model'
export * from './models/feed-categories.model'
export * from './models/feed-sources.model'
export * from './models/feeds.model'
export * from './models/news-summaries.model'
export * from './models/news-tags.model'
export * from './models/news.model'
export * from './models/newsletters.model'
export * from './models/research-embeddings.model'
export * from './models/research.model'
export * from './models/tags.model'

================
File: src/core/base/base.controller.ts
================
// base.controller.ts

import {
  Injectable,
  UnauthorizedException,
  NotFoundException,
  HttpException,
  InternalServerErrorException,
  BadRequestException,
  ConflictException,
  Inject,
  Scope,
  applyDecorators,
} from '@nestjs/common'
import { REQUEST } from '@nestjs/core'
import { Request, Response } from 'express'
import { verify } from 'jsonwebtoken'
import { ConfigService } from '@nestjs/config'
import { Prisma } from '@astronera/db'
import { PrismaService } from '../services/prisma.service'
import { PaginationService } from '../services/pagination.service'
import { CustomLogger } from '../logger/custom.logger'
import type { PaginatedResponse, PaginatedQuery } from '@types'
import { ApiTags, ApiSecurity } from '@nestjs/swagger'
import { Controller } from '@nestjs/common'

export function ApiBaseController(name: string) {
  return applyDecorators(Controller(name), ApiTags(name), ApiSecurity('bearer'))
}

@ApiBaseController('base')
@Injectable({ scope: Scope.REQUEST })
export abstract class BaseController {
  @Inject(REQUEST)
  private readonly request: any

  constructor(protected readonly modelName: keyof Prisma.TypeMap['model']) {}

  protected abstract get prisma(): PrismaService
  protected abstract get config(): ConfigService
  protected abstract get paginationService(): PaginationService
  protected abstract get logger(): CustomLogger

  protected get model(): any {
    return this.prisma[this.modelName]
  }

  async findAll(query: PaginatedQuery) {
    try {
      const { page = 1, limit = 10, include, ...filters } = query
      const includes = include?.reduce((acc, rel) => ({ ...acc, [rel]: true }), {})

      const [items, total] = await Promise.all([
        this.model.findMany({
          where: filters,
          include: includes,
          skip: (Number(page) - 1) * Number(limit),
          take: Number(limit),
        }),
        this.model.count({ where: filters }),
      ])

      return this.handlePaginatedSuccess(
        items,
        this.paginationService.getPaginationMeta(total, query),
      )
    } catch (error: any) {
      throw this.handleError(error)
    }
  }

  async findOne(id: string, include?: string[]) {
    try {
      const includes = include?.reduce((acc, rel) => ({ ...acc, [rel]: true }), {})
      const data = await this.model.findUnique({
        where: { id },
        include: includes,
      })
      if (!data) {
        throw new NotFoundException(`${String(this.modelName)} not found`)
      }
      return this.handleSuccess(data)
    } catch (error: any) {
      throw this.handleError(error)
    }
  }

  async create(data: unknown) {
    try {
      const result = await this.model.create({ data })
      return this.handleSuccess(result)
    } catch (error: any) {
      throw this.handleError(error)
    }
  }

  async update(id: string, data: unknown) {
    try {
      const result = await this.model.update({
        where: { id },
        data,
      })
      return this.handleSuccess(result)
    } catch (error: any) {
      throw this.handleError(error)
    }
  }

  async upsert(query: PaginatedQuery, data: unknown) {
    const { ...filters } = query

    try {
      const result = await this.model.upsert({
        where: {
          ...filters,
        },
        update: data,
        create: data,
      })

      return this.handleSuccess(result)
    } catch (error: any) {
      throw this.handleError(error)
    }
  }

  async remove(id: string) {
    try {
      const existing = await this.model.findUnique({ where: { id } })
      if (!existing) {
        throw new NotFoundException(`${String(this.modelName)} not found`)
      }
      await this.model.delete({ where: { id } })
      return this.handleSuccess(existing)
    } catch (error: any) {
      throw this.handleError(error)
    }
  }

  protected handleSuccess<T>(data: T): Partial<Response<T>> {
    const debug = this.config.get('app.debug')
    const response: any = { data }

    if (debug && this.request?.permissions) {
      response.debug = {
        permissions: this.request.permissions,
        timestamp: new Date().toISOString(),
      }
    }

    return response
  }

  protected handlePaginatedSuccess<T>(data: T[], meta: any): PaginatedResponse<T> {
    const debug = this.config.get('app.debug')

    const response: PaginatedResponse<T> = {
      data,
      meta,
      timestamp: new Date().toISOString(),
      success: true,
    }

    if (debug && this.request?.permissions) {
      response.debug = {
        permissions: this.request.permissions,
        timestamp: new Date().toISOString(),
      }
    }

    return response
  }

  protected handleError(error: any): never {
    this.logger.error('Error:', error)

    if (error instanceof HttpException) {
      throw error
    }

    if (error instanceof Prisma.PrismaClientKnownRequestError) {
      switch (error.code) {
        case 'P2002':
          throw new ConflictException(`Duplicate entry on ${String(this.modelName)}`)
        case 'P2003':
          throw new BadRequestException(`Referenced record not found on ${String(this.modelName)}`)
        case 'P2021':
          throw new NotFoundException(`Table not found for ${String(this.modelName)}`)
        case 'P2025':
          throw new NotFoundException(`${String(this.modelName)} not found`)
        case 'P2010':
          throw new BadRequestException(`Invalid query on ${String(this.modelName)}`)
        default:
          throw new InternalServerErrorException(`Database error on ${String(this.modelName)}`)
      }
    }

    if (error instanceof Prisma.PrismaClientValidationError) {
      throw new BadRequestException(`Validation error on ${String(this.modelName)}`)
    }

    throw new InternalServerErrorException(error.message || 'An unexpected error occurred')
  }
}

================
File: src/core/base/base.dto.ts
================
// core/base/base.dto.ts
import { ApiProperty } from '@nestjs/swagger'

export class BaseEntityDto {
  @ApiProperty({ format: 'uuid' })
  id: string

  @ApiProperty()
  createdAt: Date

  @ApiProperty()
  updatedAt: Date
}

================
File: src/core/base/base.gateway.ts
================
// core/base/base.gateway.ts
import {
  OnGatewayConnection,
  OnGatewayDisconnect,
  SubscribeMessage,
  WebSocketServer,
  WebSocketGateway,
} from '@nestjs/websockets'
import { Injectable } from '@nestjs/common'
import { Server, Socket } from 'socket.io'
import { CustomLogger } from '@core/logger/custom.logger'

@Injectable()
@WebSocketGateway()
export abstract class BaseGateway implements OnGatewayConnection, OnGatewayDisconnect {
  @WebSocketServer() server: Server
  protected readonly logger = new CustomLogger(BaseGateway.name)
  protected readonly connectedClients = new Map<string, Socket>()

  afterInit(server: Server) {
    this.logger.log('Base Gateway initialized')
  }

  handleConnection(client: Socket) {
    console.log(`Client connected: ${client.id}`)
    this.connectedClients.set(client.id, client)
    this.logger.log(`Client connected: ${client.id}`)
  }

  handleDisconnect(client: Socket) {
    this.connectedClients.delete(client.id)
    this.logger.log(`Client disconnected: ${client.id}`)
  }

  // Optionally define common message handlers if needed
  @SubscribeMessage('ping')
  handlePing(client: Socket): string {
    return 'pong'
  }
}

================
File: src/core/base/base.model.ts
================
// templates/entity/base.model.ejs
export interface BaseModel {
  id: string | number
  created_at?: Date
  updated_at?: Date

  deleted_at?: Date
}

================
File: src/core/base/base.service.ts
================
// core/services/base.service.ts
import { Injectable } from '@nestjs/common'
import { Prisma } from '@astronera/db'
import type { PaginationService } from '../services/pagination.service'

@Injectable()
export abstract class BaseService<ModelName extends Prisma.ModelName> {
  constructor(protected readonly modelName: ModelName) {}

  protected handleError(error: any): never {
    console.error('Database operation failed:', error)

    if (error instanceof Prisma.PrismaClientKnownRequestError) {
      switch (error.code) {
        case 'P2002':
          throw new Error(`Duplicate entry on ${this.modelName}: ${error.message}`)
        case 'P2003':
          throw new Error(`Referenced record not found on ${this.modelName}: ${error.message}`)
        case 'P2021':
          throw new Error(`Table not found for ${this.modelName}: ${error.message}`)
        case 'P2025':
          throw new Error(`Record not found on ${this.modelName}: ${error.message}`)
        case 'P2010':
          throw new Error(`Invalid query on ${this.modelName}: ${error.message}`)
        default:
          throw new Error(`Database error on ${this.modelName}: ${error.message}`)
      }
    }

    if (error instanceof Prisma.PrismaClientValidationError) {
      throw new Error(`Validation error on ${this.modelName}: ${error.message}`)
    }

    if (error.code) {
      switch (error.code) {
        case '23505':
          throw new Error(`Duplicate entry on ${this.modelName}: ${error.message}`)
        case '23503':
          throw new Error(`Referenced record not found on ${this.modelName}: ${error.message}`)
        case '42P01':
          throw new Error(`Table not found for ${this.modelName}: ${error.message}`)
        case '42703':
          throw new Error(`Column not found on ${this.modelName}: ${error.message}`)
      }
    }

    throw new Error(`An unexpected error occurred on ${this.modelName}: ${error.message}`)
  }

  protected async executeQuery<R>(
    operation: () => Promise<R | { data: R | null; error: any }>,
  ): Promise<R> {
    try {
      const result = await operation()
      return result as R
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  protected async executePrismaQuery<R>(operation: () => Promise<R>): Promise<R> {
    try {
      return await operation()
    } catch (error: any) {
      return this.handleError(error)
    }
  }
}

================
File: src/core/cache/cache.mock.ts
================
// cache.mock.ts
export class MockCacheService {
  private store = new Map<string, { value: string; expiry?: number }>()

  async get<T>(key: string): Promise<T | null> {
    const item = this.store.get(key)
    if (!item) return null

    if (item.expiry && item.expiry < Date.now()) {
      this.store.delete(key)
      return null
    }

    return JSON.parse(item.value) as T
  }

  async set<T>(key: string, value: T, ttlSeconds?: number): Promise<void> {
    const expiry = ttlSeconds ? Date.now() + ttlSeconds * 1000 : undefined
    this.store.set(key, {
      value: JSON.stringify(value),
      expiry,
    })
  }

  async del(key: string): Promise<void> {
    this.store.delete(key)
  }

  async flushPrefix(prefix: string): Promise<void> {
    for (const key of this.store.keys()) {
      if (key.startsWith(prefix)) {
        this.store.delete(key)
      }
    }
  }

  async getAllKeys(prefix: string): Promise<Array<{ key: string; value: any }>> {
    const result = []
    for (const [key, item] of this.store.entries()) {
      if (key.startsWith(prefix)) {
        result.push({
          key,
          value: JSON.parse(item.value),
        })
      }
    }
    return result
  }
}

================
File: src/core/cache/cache.module.ts
================
// redis.module.ts
import { Module, Global, OnApplicationShutdown, Inject } from '@nestjs/common'
import { ConfigService, ConfigModule } from '@nestjs/config'
import { Redis } from 'ioredis'
import IORedis from 'ioredis'
import { MockCacheService } from './cache.mock'

@Global()
@Module({
  imports: [ConfigModule],
  providers: [
    // 2) Redis client for cache/metrics
    {
      provide: 'REDIS_CACHE',
      useFactory: (config: ConfigService) => {
        // if (process.env.NODE_ENV === 'development') {
        //   return new MockCacheService()
        // }

        return new IORedis({
          host: config.get<string>('app.redis.host') || 'redis.railway.internal',
          port: config.get<number>('app.redis.port') || 6379,
          password: config.get<string>('app.redis.password'),
          username: config.get<string>('app.redis.username'),
          family: 0,
        })
      },
      inject: [ConfigService],
    },
  ],
  exports: ['REDIS_CACHE'],
})

export class RedisModule implements OnApplicationShutdown {
  constructor(@Inject('REDIS_CACHE') private cacheClient: Redis) {}

  async onApplicationShutdown() {
    // Alternative place to close connections if desired
    await Promise.all([this.cacheClient.quit()])
  }
}

================
File: src/core/config/configuration.ts
================
// config/configuration.ts
import { registerAs } from '@nestjs/config'

export default registerAs('app', () => ({
  debug: process.env.APP_DEBUG === 'true',
  supabase: {
    anon_key: process.env.SUPABASE_ANON_KEY,
    url: process.env.SUPABASE_URL,
    jwt_secret: process.env.SUPABASE_JWT_SECRET,
  },
  redis: {
    host: process.env.REDIS_HOST || 'localhost',
    port: parseInt(process.env.REDIS_PORT, 10) || 6379,
    password: process.env.REDIS_PASSWORD,
    username: process.env.REDIS_USER,
  },
  environment: process.env.NODE_ENV || 'development',
  api_cors_origins: process.env.API_CORS_ORIGINS || '*',
  api_port: parseInt(process.env.API_PORT, 10) || 3030,
  database: {
    url: process.env.DATABASE_URL,
    host: process.env.DATABASE_HOST,
    port: parseInt(process.env.DATABASE_PORT, 10) || 5432,
    username: process.env.DATABASE_USER,
    password: process.env.DATABASE_PASSWORD,
    database: process.env.DATABASE_NAME,
  },
  razorpay: {
    key_id: process.env.RAZORPAY_TEST_KEY,
    key_secret: process.env.RAZORPAY_TEST_SECRET,
  },
  jwt: {
    secret: process.env.JWT_SECRET,
    expiresIn: process.env.JWT_EXPIRES_IN || '1d',
  },
}))

================
File: src/core/config/domain-config.ts
================
// core/config/domain-config.ts
import { createCentralizedLogger, Service, DomainsForService } from '@ib/logger'
import { DynamicModule, MiddlewareConsumer, Module, NestModule } from '@nestjs/common'
import { CustomLogger } from '@core/logger/custom.logger'

// Define the options interface
export interface DomainModuleOptions {
  requiresAuth?: boolean
  requiresCompany?: boolean
  // Add other options as needed
}

export function createDomainModule(
  domainName: DomainsForService<Service.API>,
  options: DomainModuleOptions,
): DynamicModule {
  @Module({})
  class DomainModule {}

  return {
    module: DomainModule,
    providers: [
      {
        provide: CustomLogger,
        useFactory: () => {
          const logger = new CustomLogger()
          logger.setDomain(domainName)
          return logger
        },
      },
    ],
    exports: [CustomLogger],
    global: false,
  }
}

================
File: src/core/decorators/api.decorator.ts
================
// core/decorators/api.decorators.ts
import { applyDecorators } from '@nestjs/common'
import { ApiOperation, ApiResponse, ApiQuery } from '@nestjs/swagger'

export function ApiPaginatedResponse(type: any) {
  return applyDecorators(
    ApiOperation({ summary: 'Get paginated list' }),
    ApiQuery({ name: 'page', required: false, type: Number }),
    ApiQuery({ name: 'limit', required: false, type: Number }),
    ApiResponse({
      status: 200,
      description: 'Successful operation',
      type: type,
      isArray: true,
    }),
  )
}

export function ApiGetByIdResponse(type: any) {
  return applyDecorators(
    ApiOperation({ summary: 'Get by ID' }),
    ApiResponse({
      status: 200,
      description: 'Found',
      type: type,
    }),
    ApiResponse({ status: 404, description: 'Not found' }),
  )
}

================
File: src/core/decorators/current-user.decorator.ts
================
// decorators/current-user.decorator.ejs
import { ExecutionContext } from '@nestjs/common'
import { createParamDecorator } from '@nestjs/common'

export const CurrentUser = createParamDecorator((data: unknown, ctx: ExecutionContext) => {
  const request = ctx.switchToHttp().getRequest()
  return request.user
})

================
File: src/core/decorators/permission.decorator.ts
================
// decorators/permission.decorator.ts
import { SetMetadata } from '@nestjs/common'
import type { DatabaseAction } from '@types'

export const Table = (table: string) => SetMetadata('table', table)
export const Action = (action: DatabaseAction) => SetMetadata('action', action)

================
File: src/core/decorators/plan.decorator.ts
================
// decorators/plan.decorator.ejs
import { SetMetadata } from '@nestjs/common'

export const PLAN_KEY = 'plan'
export const RequirePlan = (...plans: string[]) => SetMetadata(PLAN_KEY, plans)

================
File: src/core/decorators/public.decorator.ts
================
// src/core/decorators/public.decorator.ts
import { SetMetadata } from '@nestjs/common'

export const IS_PUBLIC_KEY = 'isPublic'
export const Public = () => SetMetadata(IS_PUBLIC_KEY, true)

================
File: src/core/decorators/roles.decorator.ts
================
// decorators/roles.decorator.ejs
import { SetMetadata } from '@nestjs/common'

export const ROLES_KEY = 'roles'
export const Roles = (...roles: string[]) => SetMetadata(ROLES_KEY, roles)

================
File: src/core/decorators/service.decorator.ts
================
// src/core/decorators/service.decorator.ts
import { SetMetadata, applyDecorators, UseGuards } from '@nestjs/common'
import { ApiKeyGuard } from '@core/guards/api-key.guard'

export const IS_SERVICE_KEY = 'isService'
export const Service = () =>
  applyDecorators(SetMetadata(IS_SERVICE_KEY, true), UseGuards(ApiKeyGuard))

================
File: src/core/decorators/validate.decorator.ts
================
// decorators/validate.decorator.ejs
import { ValidationOptions, ValidationArguments } from 'class-validator'
import { registerDecorator } from 'class-validator'

export function IsCustomValue(property: string, validationOptions?: ValidationOptions) {
  return function (object: object, propertyName: string) {
    registerDecorator({
      name: 'isCustomValue',
      target: object.constructor,
      propertyName: propertyName,
      constraints: [property],
      options: validationOptions,
      validator: {
        validate(value: any, args: ValidationArguments) {
          const [relatedPropertyName] = args.constraints
          const relatedValue = (args.object as any)[relatedPropertyName]
          return typeof value === 'string' && typeof relatedValue === 'string'
        },
      },
    })
  }
}

================
File: src/core/dto/pagination.dto.ts
================
import { IsOptional, IsNumber, IsString } from 'class-validator'
import { Type } from 'class-transformer'

export class PaginationParams {
  @IsOptional()
  @IsNumber()
  @Type(() => Number)
  page?: number = 1

  @IsOptional()
  @IsNumber()
  @Type(() => Number)
  limit?: number = 10

  @IsOptional()
  @IsString()
  sort?: string

  @IsOptional()
  @IsString()
  search?: string

  @IsOptional()
  @IsString()
  order?: string

  @IsOptional()
  @IsString()
  include?: Record<string, boolean>
}

================
File: src/core/filters/http-exception.filter.ts
================
// filters/http-exception.filter.ts
import { ExceptionFilter, ArgumentsHost } from '@nestjs/common'
import { Catch, HttpException } from '@nestjs/common'
import { Response } from 'express'
import { CustomLogger } from '@core/logger/custom.logger'

@Catch(HttpException)
export class HttpExceptionFilter implements ExceptionFilter {
  constructor(private logger: CustomLogger) {
    this.logger.setDomain('filter')
  }

  catch(exception: HttpException, host: ArgumentsHost) {
    const ctx = host.switchToHttp()
    const response = ctx.getResponse<Response>()
    const status = exception.getStatus()
    const exceptionResponse = exception.getResponse()

    this.logger.error(`HTTP Exception: ${exception.message}`, exception.stack)

    response.status(status).json({
      success: false,
      timestamp: new Date().toISOString(),
      error: exceptionResponse,
      statusCode: status,
    })
  }
}

================
File: src/core/guards/api-key.guard.ts
================
import { Injectable, CanActivate, ExecutionContext, ForbiddenException } from '@nestjs/common'

@Injectable()
export class ApiKeyGuard implements CanActivate {
  canActivate(context: ExecutionContext): boolean {
    const request = context.switchToHttp().getRequest()
    const apiKey = request.headers['authorization']?.split(' ')[1] // Extract Bearer token

    console.log('Request:', request.headers)
    console.log('headers array:', request.headers['authorization']?.split)
    console.log('API Key:', apiKey, 'Expected:', process.env.API_SECRET_KEY)

    if (apiKey !== process.env.API_SECRET_KEY) {
      throw new ForbiddenException('Invalid API Key')
    }
    return true
  }
}

================
File: src/core/guards/permission.guard.ts
================
// guards/permission.guard.ts
import { CanActivate, ExecutionContext } from '@nestjs/common'
import { Injectable, UnauthorizedException } from '@nestjs/common'
import { Reflector } from '@nestjs/core'
import { CustomLogger } from '@core/logger/custom.logger'
import { IS_PUBLIC_KEY } from '@core/decorators/public.decorator'
import { IS_SERVICE_KEY } from '@core/decorators/service.decorator'
import { PermissionService } from '../services/permission.service'
import { DebugService } from '../services/debug.service'

@Injectable()
export class PermissionGuard implements CanActivate {
  constructor(
    private readonly permissionService: PermissionService,
    private readonly logger: CustomLogger,
    private readonly reflector: Reflector,
    private readonly debugService: DebugService,
  ) {
    this.logger.setDomain('permissions')
  }

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const request = context.switchToHttp().getRequest()

    const isPublic = this.reflector.getAllAndOverride<boolean>(IS_PUBLIC_KEY, [
      context.getHandler(),
      context.getClass(),
    ])

    const isService = this.reflector.getAllAndOverride<boolean>(IS_SERVICE_KEY, [
      context.getHandler(),
      context.getClass(),
    ])

    this.attachDebugInfo(request, context, isPublic, isService)

    if (isPublic) {
      return true
    }

    if (isService) {
      return true
    }

    const token = this.extractToken(request)
    if (!token) {
      this.logger.warn('No token found in request')
      throw new UnauthorizedException('No authorization token found')
    }

    try {
      const userData = await this.permissionService.validateToken(token)
      request.user = userData

      this.attachUserDebugInfo(request, userData)
      return true
    } catch (error: any) {
      this.logger.error('Permission check failed', error.stack)
      throw new UnauthorizedException('Invalid token')
    }
  }

  private attachDebugInfo(
    request: any,
    context: ExecutionContext,
    isPublic: boolean,
    isService: boolean,
  ) {
    this.debugService.attachPermissionDebugInfo(request, {
      isPublic,
      isService,
      endpoint: `${request.method} ${request.path}`,
      handler: context.getHandler().name,
      controller: context.getClass().name,
    })
  }

  private async attachUserDebugInfo(request: any, userData: any) {
    this.debugService.attachPermissionDebugInfo(request, {
      user: {
        role: userData.role,
        email: userData.email,
      },
      roleHierarchy: await this.permissionService.getRoleHierarchy(userData.role),
    })
  }

  private extractToken(request: any): string | null {
    const authHeader = request.headers.authorization
    return authHeader ? authHeader.replace('Bearer ', '') : null
  }
}

================
File: src/core/guards/plan.guard.ts
================
// guards/plan.guard.ejs
import { CanActivate, ExecutionContext } from '@nestjs/common'
import { CustomLogger } from '@core/logger/custom.logger'
import { Injectable } from '@nestjs/common'
import { Reflector } from '@nestjs/core'
import { PLAN_KEY } from '../decorators/plan.decorator'
import { PrismaService } from '../services/prisma.service'

@Injectable()
export class PlanGuard implements CanActivate {
  logger = new CustomLogger('plan-guard')
  constructor(
    private reflector: Reflector,
    private prisma: PrismaService,
  ) {}

  // guards/plan.guard.ts
  async canActivate(context: ExecutionContext): Promise<boolean> {
    const requiredPlans = this.reflector.getAllAndOverride<string[]>(PLAN_KEY, [
      context.getHandler(),
      context.getClass(),
    ])

    if (!requiredPlans) {
      this.logger.debug('No plan requirements for this route')
      return true
    }

    const { user } = context.switchToHttp().getRequest()
    if (!user) {
      this.logger.warn('No user found in request')
      return false
    }

    this.logger.debug('Checking user subscription', {
      userId: user.id,
      requiredPlans,
    })

    const userSubscription = await this.prisma.customerSubscriptions.findFirst({
      where: {
        user_id: user.id,
        status: 'ACTIVE',
      },
      include: {
        customer_subscription_plans: {
          select: {
            name: true,
          },
        },
      },
    })

    this.logger.debug('Found subscription status', {
      hasActiveSubscription: !!userSubscription,
      planName: userSubscription?.customer_subscription_plans?.name,
    })

    const hasRequiredPlan = requiredPlans.includes(
      userSubscription?.customer_subscription_plans?.name,
    )

    return hasRequiredPlan
  }
}

================
File: src/core/guards/throttler.guard.ts
================
// core/guards/throttler.guard.ts
import { ExecutionContext } from '@nestjs/common'
import { Injectable, SetMetadata } from '@nestjs/common'
import { Reflector } from '@nestjs/core'
import { type ThrottlerModuleOptions, ThrottlerRequest, ThrottlerStorage } from '@nestjs/throttler'
import { ThrottlerGuard } from '@nestjs/throttler'
import { CustomLogger } from '@core/logger/custom.logger'

// Decorator to skip throttling for specific routes
export const SkipThrottle = () => SetMetadata('skipThrottle', true)

// Decorator to set custom limits for specific routes
export const Throttle = (limit: number, ttl: number) => SetMetadata('throttle', { limit, ttl })

@Injectable()
export class CustomThrottlerGuard extends ThrottlerGuard {
  private readonly logger: CustomLogger

  constructor(
    options: ThrottlerModuleOptions,
    storageService: ThrottlerStorage,
    reflector: Reflector,
  ) {
    super(options, storageService, reflector)
    this.logger = new CustomLogger('ThrottlerGuard')
  }

  protected async getTracker(req: Record<string, any>): Promise<string> {
    // You can customize the tracking key based on your needs
    // Default is IP address
    const ip = req.ip
    const userAgent = req.headers['user-agent'] || 'unknown'

    return `${ip}-${userAgent}`
  }

  protected getKeyForRoute(context: ExecutionContext): string {
    const req = context.switchToHttp().getRequest()
    return `${req.method}-${req.url}`
  }

  protected async handleRequest(input: ThrottlerRequest): Promise<boolean> {
    // Check if route should skip throttling
    const skipThrottle = this.reflector.get<boolean>('skipThrottle', input.context.getHandler())
    if (skipThrottle) {
      return true
    }

    // Get custom limits if set
    const customLimits = this.reflector.get<{ limit: number; ttl: number }>(
      'throttle',
      input.context.getHandler(),
    )

    if (customLimits) {
      input.limit = customLimits.limit
      input.ttl = customLimits.ttl
    }

    const tracker = await this.getTracker(input.context.switchToHttp().getRequest())
    const key = this.getKeyForRoute(input.context)
    const record = await this.storageService.increment(
      `${key}-${tracker}`,
      input.ttl,
      input.limit,
      input.blockDuration,
      input.throttler.name ?? 'throttler',
    )

    this.logger.debug(`Request ${key} from ${tracker}: ${record.totalHits}/${input.limit}`)

    if (record.totalHits > input.limit) {
      this.logger.warn(
        `Request ${key} from ${tracker} exceeded limit: ${record.totalHits}/${input.limit}`,
      )
      return false
    }

    return true
  }
}

================
File: src/core/interceptors/bigint.interceptor.ts
================
// interceptors/bigint.interceptor.ts
import { NestInterceptor, ExecutionContext, CallHandler } from '@nestjs/common'
import { Injectable } from '@nestjs/common'
import { Observable } from 'rxjs'
import { map } from 'rxjs/operators'

@Injectable()
export class BigIntSerializationInterceptor implements NestInterceptor {
  private transformValue(value: any): any {
    if (typeof value === 'bigint') {
      return value.toString()
    }

    if (Array.isArray(value)) {
      return value.map((item) => this.transformValue(item))
    }

    if (typeof value === 'object' && value !== null) {
      return Object.fromEntries(
        Object.entries(value).map(([key, val]) => [key, this.transformValue(val)]),
      )
    }

    return value
  }

  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    return next.handle().pipe(map((data) => this.transformValue(data)))
  }
}

================
File: src/core/interceptors/logging.interceptor.ts
================
// interceptors/logging.interceptor.ts
import type { NestInterceptor, ExecutionContext, CallHandler } from '@nestjs/common'
import { Injectable } from '@nestjs/common'
import { Observable } from 'rxjs'
import { tap } from 'rxjs/operators'
import { CustomLogger } from '@core/logger/custom.logger'

@Injectable()
export class LoggingInterceptor implements NestInterceptor {
  constructor(private logger: CustomLogger) {
    this.logger.setDomain('logging')
  }

  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    const request = context.switchToHttp().getRequest()
    const method = request.method
    const url = request.url
    const now = Date.now()

    return next.handle().pipe(
      tap(() => {
        this.logger.log(`${method} ${url} took ${Date.now() - now}ms`)
      }),
    )
  }
}

================
File: src/core/interceptors/pagination.interceptor.ts
================
// templates/core/interceptors/pagination.interceptor.ejs
import { NestInterceptor, ExecutionContext, CallHandler } from '@nestjs/common'
import { Injectable } from '@nestjs/common'
import { Observable } from 'rxjs'
import { map } from 'rxjs/operators'
import type { PaginatedResponse } from '@types'

@Injectable()
export class PaginationInterceptor<T> implements NestInterceptor<T, PaginatedResponse<T>> {
  intercept(context: ExecutionContext, next: CallHandler): Observable<PaginatedResponse<T>> {
    return next.handle().pipe(
      map((data) => {
        // If data is already paginated, return as is
        if (this.isPaginated(data)) {
          return data
        }

        // Get pagination params from request query
        const request = context.switchToHttp().getRequest()
        const { page = 1, limit = 10 } = request.query

        // If data is an array, paginate it
        if (Array.isArray(data)) {
          const total = data.length
          const totalPages = Math.ceil(total / limit)
          const start = (page - 1) * limit
          const end = start + limit

          return {
            data: data.slice(start, end),
            meta: {
              total,
              page: Number(page),
              limit: Number(limit),
              totalPages,
              hasNextPage: end < total,
              hasPreviousPage: start > 0,
            },
            success: true,
            timestamp: new Date().toISOString(),
          }
        }

        // If not an array, wrap in paginated response
        return {
          data: [data],
          meta: {
            total: 1,
            page: 1,
            limit: 1,
            totalPages: 1,
            hasNextPage: false,
            hasPreviousPage: false,
          },
          success: true,
          timestamp: new Date().toISOString(),
        }
      }),
    )
  }

  private isPaginated(data: any): data is PaginatedResponse<T> {
    return (
      data &&
      'data' in data &&
      'meta' in data &&
      'total' in data.meta &&
      'page' in data.meta &&
      'limit' in data.meta &&
      'totalPages' in data.meta
    )
  }
}

================
File: src/core/logger/custom.logger.ts
================
// custom.logger.ts
import { ConsoleLogger, LoggerService } from '@nestjs/common'
import { createCentralizedLogger, Service, DomainsForService } from '@ib/logger'

export class CustomLogger extends ConsoleLogger implements LoggerService {
  private centralLogger = createCentralizedLogger<Service>()

  constructor(context?: string) {
    super(context)
    // Optionally set the service & domain here or in your Modules
    this.centralLogger.setServiceName(Service.API)
    this.centralLogger.setDomain('logging')
  }

  // Override log calls
  log(message: string, context?: any) {
    super.log(message, context)
    void this.centralLogger.info(message, context)
  }

  error(message: string, context?: any) {
    super.error(message, context)
    void this.centralLogger.error(message, context)
  }

  warn(message: string, context?: any) {
    super.warn(message, context)
    void this.centralLogger.warn(message, context)
  }

  debug(message: string, context?: any) {
    super.debug(message, context)
    void this.centralLogger.debug(message, context)
  }

  verbose(message: string, context?: any) {
    super.verbose(message, context)
    void this.centralLogger.verbose(message, context)
  }

  setDomain(domain: DomainsForService<Service.API>) {
    this.centralLogger.setDomain(domain)
  }
}

================
File: src/core/logger/logger.colors.ts
================
export const LoggerColors = {
  auth: '\x1b[35m', // Magenta
  content: '\x1b[36m', // Cyan
  location: '\x1b[32m', // Green
  security: '\x1b[31m', // Red
  search: '\x1b[33m', // Yellow
  payments: '\x1b[34m', // Blue
  advertising: '\x1b[95m', // Bright Magenta
  core: '\x1b[90m', // Gray
  default: '\x1b[37m', // White
  reset: '\x1b[0m', // Reset
} as const

================
File: src/core/modules/logger.module.ts
================
import { Global, Module } from '@nestjs/common'
import { CustomLogger } from '../logger/custom.logger'

@Global()
@Module({
  providers: [
    {
      provide: CustomLogger,
      useValue: new CustomLogger(),
    },
  ],
  exports: [CustomLogger],
})
export class LoggerModule {}

================
File: src/core/modules/permission.module.ts
================
// permission.module.ts
import { Global, Module } from '@nestjs/common'
import { ConfigModule } from '@nestjs/config'
import { APP_GUARD, Reflector } from '@nestjs/core'
import { CustomLogger } from '@core/logger/custom.logger'
import { PermissionService } from '../services/permission.service'
import { PermissionGuard } from '../guards/permission.guard'
import { PrismaModule } from '../modules/prisma.module'
import { DebugService } from '../services/debug.service'

@Global()
@Module({
  imports: [ConfigModule, PrismaModule],
  providers: [
    PermissionService,
    Reflector,
    {
      provide: CustomLogger,
      useFactory: () => new CustomLogger('Permission'),
    },
    {
      provide: APP_GUARD,
      useFactory: (
        permissionService: PermissionService,
        logger: CustomLogger,
        reflector: Reflector,
        debugService: DebugService,
      ) => {
        return new PermissionGuard(permissionService, logger, reflector, debugService)
      },
      inject: [PermissionService, CustomLogger, Reflector, DebugService],
    },
  ],
  exports: [PermissionService],
})
export class PermissionModule {}

================
File: src/core/modules/prisma.module.ts
================
// prisma.module.ts
import { Global, Module } from '@nestjs/common'
import { ConfigModule, ConfigService } from '@nestjs/config'
import { PrismaService } from '../services/prisma.service'

@Global()
@Module({
  imports: [ConfigModule],
  providers: [
    {
      provide: PrismaService,
      useFactory: (configService: ConfigService) => {
        return new PrismaService(configService)
      },
      inject: [ConfigService],
    },
  ],
  exports: [PrismaService],
})
export class PrismaModule {}

================
File: src/core/pipes/transformation.pipe.ts
================
// pipes/transformation.pipe.ejs
import { PipeTransform, ArgumentMetadata } from '@nestjs/common'
import { Injectable } from '@nestjs/common'

@Injectable()
export class TransformationPipe implements PipeTransform {
  constructor(private readonly transformFn: (value: any) => any) {}

  transform(value: any, metadata: ArgumentMetadata) {
    return this.transformFn(value)
  }
}

================
File: src/core/pipes/trim.pipe.ts
================
// pipes/trim.pipe.ejs
import { PipeTransform, ArgumentMetadata } from '@nestjs/common'
import { Injectable } from '@nestjs/common'

@Injectable()
export class TrimPipe implements PipeTransform {
  transform(value: any, metadata: ArgumentMetadata) {
    if (!value) return value

    if (typeof value === 'string') {
      return value.trim()
    }

    if (Array.isArray(value)) {
      return value.map((item) => (typeof item === 'string' ? item.trim() : item))
    }

    if (typeof value === 'object') {
      return Object.keys(value).reduce(
        (acc, key) => ({
          ...acc,
          [key]: typeof value[key] === 'string' ? value[key].trim() : value[key],
        }),
        {},
      )
    }

    return value
  }
}

================
File: src/core/pipes/type-conversion.pipe.ts
================
// pipes/type-conversion.pipe.ejs
import { PipeTransform, ArgumentMetadata } from '@nestjs/common'
import { Injectable, BadRequestException } from '@nestjs/common'

@Injectable()
export class TypeConversionPipe implements PipeTransform {
  constructor(private readonly targetType: 'number' | 'boolean' | 'string') {}

  transform(value: any, metadata: ArgumentMetadata) {
    if (value === undefined) return value

    try {
      switch (this.targetType) {
        case 'number':
          return Number(value)
        case 'boolean':
          return value === 'true' || value === '1' || value === true
        case 'string':
          return String(value)
        default:
          return value
      }
    } catch (error: any) {
      throw new BadRequestException(`Type conversion failed: ${error.message}`)
    }
  }
}

================
File: src/core/pipes/validation.pipe.ts
================
// pipes/validation.pipe.ts
import { PipeTransform, ArgumentMetadata } from '@nestjs/common'
import { Injectable, BadRequestException } from '@nestjs/common'
import { validate } from 'class-validator'
import { plainToInstance } from 'class-transformer'
import { CustomLogger } from '@core/logger/custom.logger'

@Injectable()
export class ValidationPipe implements PipeTransform<any> {
  constructor(private logger: CustomLogger) {
    this.logger.setDomain('validation')
  }

  async transform(value: any, { metatype }: ArgumentMetadata) {
    if (!metatype || !this.toValidate(metatype)) {
      return value
    }

    const object = plainToInstance(metatype, value)
    const errors = await validate(object)

    if (errors.length > 0) {
      this.logger.warn(`Validation failed: ${JSON.stringify(errors)}`)
      throw new BadRequestException('Validation failed')
    }

    return value
  }

  private toValidate(metatype: Function): boolean {
    const types: Function[] = [String, Boolean, Number, Array, Object]
    return !types.includes(metatype)
  }
}

================
File: src/core/services/debug.service.ts
================
import { Injectable, ExecutionContext } from '@nestjs/common'
import { Reflector } from '@nestjs/core'
import { ConfigService } from '@nestjs/config'

@Injectable()
export class DebugService {
  constructor(private readonly config: ConfigService) {}

  isDebugMode(): boolean {
    return this.config.get('app.debug') ?? false
  }

  attachPermissionDebugInfo(request: any, data: any) {
    if (!this.isDebugMode()) return
    request.permissions = {
      ...request.permissions,
      ...data,
    }
  }
}

================
File: src/core/services/pagination.service.ts
================
import { Injectable } from '@nestjs/common'
import type { PaginatedQuery, PaginatedResponse, PaginationMeta } from '@types'

@Injectable()
export class PaginationService {
  getPaginationMeta(total: number, query: PaginatedQuery): PaginationMeta {
    const page = Number(query.page) || 1
    const limit = Number(query.limit) || 10
    const totalPages = Math.ceil(total / limit)

    return {
      total,
      totalPages,
      page,
      limit,
      hasNextPage: page < totalPages,
      hasPreviousPage: page > 1,
    }
  }

  getPaginatedResponse<T>(data: T[], total: number, query: PaginatedQuery): PaginatedResponse<T> {
    return {
      data,
      meta: this.getPaginationMeta(total, query),
      success: true,
      timestamp: new Date().toISOString(),
    }
  }

  getSkipTake(query: PaginatedQuery): { skip: number; take: number } {
    const page = Number(query.page) || 1
    const limit = Number(query.limit) || 10

    return {
      skip: (page - 1) * limit,
      take: limit,
    }
  }
}

================
File: src/core/services/permission.service.ts
================
// services/permission.service.ts
import { OnModuleInit } from '@nestjs/common'
import { Injectable, UnauthorizedException } from '@nestjs/common'
import { ConfigService } from '@nestjs/config'
import { SupabaseClient } from '@supabase/supabase-js'
import { createClient } from '@supabase/supabase-js'
import { CustomLogger } from '@core/logger/custom.logger'
import * as jwt from 'jsonwebtoken'
import { PrismaService } from './prisma.service'
import type { DatabaseAction, TokenPayload, PermissionCondition } from '@types'

interface SupabaseJwtPayload {
  aud: string
  exp: number
  sub: string
  email: string
  role: string
  // ... other fields from your JWT
}

@Injectable()
export class PermissionService implements OnModuleInit {
  private jwtSecret: string
  private roleHierarchyCache: Map<string, string[]>

  constructor(
    private readonly config: ConfigService,
    private readonly prisma: PrismaService,
    private readonly logger: CustomLogger,
  ) {
    // Get this from your Supabase dashboard > Project Settings > API
    this.jwtSecret = this.config.get('app.supabase.jwt_secret')
    this.roleHierarchyCache = new Map()
  }

  async onModuleInit() {
    this.logger.setDomain('permissions')
    try {
      this.logger.log('Permission service initializing...')
      await this.loadRoleHierarchy()
      this.logger.log('Permission service initialized with role hierarchy')
    } catch (error) {
      this.logger.error('Failed to initialize permission service', error)
      throw error // rethrow so Nest knows to fail startup
    }
  }

  private async loadRoleHierarchy() {
    try {
      const hierarchyData = await this.prisma.roleHierarchy.findMany()

      this.logger.log(`fetching role hierarchy for ${this.roleHierarchyCache.size} roles`)
      hierarchyData.forEach(({ parent_role, child_role }) => {
        const parentRoles = this.roleHierarchyCache.get(child_role) || []
        parentRoles.push(parent_role)
        this.roleHierarchyCache.set(child_role, parentRoles)
      })

      this.logger.log(`Loaded role hierarchy for ${this.roleHierarchyCache.size} roles`)
    } catch (error: any) {
      this.logger.error('Failed to load role hierarchy', error.stack)
      throw error
    }
  }

  async getRoleHierarchy(role: string): Promise<string[]> {
    try {
      // First, get direct hierarchy from cache
      const directHierarchy = this.roleHierarchyCache.get(role) || []

      // Then get inherited permissions by recursively checking parent roles
      const allRoles = new Set<string>([role, ...directHierarchy])

      for (const parentRole of directHierarchy) {
        const parentHierarchy = await this.getRoleHierarchy(parentRole)
        parentHierarchy.forEach((r) => allRoles.add(r))
      }

      return Array.from(allRoles)
    } catch (error) {
      this.logger.error(`Failed to get role hierarchy for ${role}`, error)
      return [role] // Return just the current role if hierarchy lookup fails
    }
  }

  async validateToken(token: string): Promise<SupabaseJwtPayload> {
    try {
      this.logger.debug('Attempting to validate Supabase token', {
        tokenLength: token.length,
        tokenPrefix: token.substring(0, 10) + '...', // Safe logging
      })

      const decoded = jwt.verify(token, this.jwtSecret) as SupabaseJwtPayload

      this.logger.debug('Token decoded successfully', {
        sub: decoded.sub,
        role: decoded.role,
        exp: new Date(decoded.exp * 1000).toISOString(),
        aud: decoded.aud,
      })

      // Verify the token is a Supabase token
      if (decoded.aud !== 'authenticated') {
        this.logger.warn('Invalid audience in token', { aud: decoded.aud })
        throw new UnauthorizedException('Invalid token audience')
      }

      return decoded
    } catch (error: any) {
      this.logger.error('Token validation failed', {
        error: error.message,
        stack: error.stack,
      })
      throw new UnauthorizedException('Invalid token')
    }
  }
}

================
File: src/core/services/prisma.service.ts
================
// core/services/prisma.service.ejs
import { OnModuleInit, OnModuleDestroy } from '@nestjs/common'
import { Injectable } from '@nestjs/common'
import { ConfigService } from '@nestjs/config'
import { PrismaClient } from '@astronera/db'

@Injectable()
export class PrismaService extends PrismaClient implements OnModuleInit, OnModuleDestroy {
  constructor(private readonly configService: ConfigService) {
    super({
      log: ['query', 'info', 'warn', 'error'],
      datasources: {
        db: {
          url: configService.get<string>('app.database.url'),
        },
      },
    })
  }

  async onModuleInit() {
    try {
      console.log('Prisma connecting...')
      await this.$connect()
      console.log('Prisma connected')
    } catch (error) {
      console.error('Prisma connection failed', error)
      throw error
    }
  }

  async onModuleDestroy() {
    await this.$disconnect()
    console.log('Prisma disconnected')
  }
}

================
File: src/core/storage/throttler.storage.ts
================
// core/storage/throttler.storage.ts
import { Injectable } from '@nestjs/common'
import type { ThrottlerStorage } from '@nestjs/throttler'
import { CustomLogger } from '@core/logger/custom.logger'

interface ThrottleRecord {
  totalHits: number
  timeToExpire: number
}

@Injectable()
export class CustomThrottlerStorage implements ThrottlerStorage {
  private storage: Map<string, ThrottleRecord> = new Map()
  private readonly logger: CustomLogger

  constructor() {
    this.logger = new CustomLogger('ThrottlerStorage')
  }

  async increment(
    key: string,
    ttl: number,
    limit: number,
    blockDuration: number,
    throttlerName: string,
  ): Promise<ThrottlerStorage['increment']['arguments']> {
    const record = this.storage.get(key) ?? {
      totalHits: 0,
      timeToExpire: Date.now() + ttl,
    }
    record.totalHits++
    this.storage.set(key, record)

    this.logger.debug(`Increment key: ${key}, hits: ${record.totalHits}`)
    return record
  }

  async get(key: string): Promise<ThrottleRecord | undefined> {
    this.clearExpired()
    return this.storage.get(key)
  }

  async reset(key: string): Promise<void> {
    this.storage.delete(key)
    this.logger.debug(`Reset key: ${key}`)
  }

  private clearExpired(): void {
    const now = Date.now()
    for (const [key, record] of this.storage.entries()) {
      if (record.timeToExpire <= now) {
        this.storage.delete(key)
        this.logger.debug(`Cleared expired key: ${key}`)
      }
    }
  }
}

================
File: src/core/utils/auth.utils.ts
================
// utils/auth.utils.ejs
import { UnauthorizedException } from '@nestjs/common'
import { verify } from 'jsonwebtoken'

export class AuthUtils {
  static verifyToken(token: string, secret: string): any {
    try {
      return verify(token, secret)
    } catch (error: any) {
      throw new UnauthorizedException('Invalid token')
    }
  }

  static extractTokenFromHeader(authHeader: string): string {
    if (!authHeader) {
      throw new UnauthorizedException('No authorization header')
    }
    const [type, token] = authHeader.split(' ')
    if (type !== 'Bearer') {
      throw new UnauthorizedException('Invalid authorization type')
    }
    return token
  }
}

================
File: src/core/utils/permission.utils.ts
================
// utils/permission.utils.ejs
export class PermissionUtils {
  static canAccess(userPermissions: string[], requiredPermissions: string[]): boolean {
    return requiredPermissions.every((required) =>
      userPermissions.some((userPerm) => this.matchPermission(userPerm, required)),
    )
  }

  private static matchPermission(userPerm: string, required: string): boolean {
    const userParts = userPerm.split(':')
    const requiredParts = required.split(':')

    if (userParts[0] === '*') return true
    if (userParts.length !== requiredParts.length) return false

    return userParts.every((part, i) => part === '*' || part === requiredParts[i])
  }
}

================
File: src/core/webhook/razorpay.service.ts
================
import { Injectable } from '@nestjs/common';

@Injectable()
export class RazorpayWebhookService {
  handleEvent(payload: any): void {
    switch (payload.event) {
      case 'subscription.activated':
        this.handleSubscriptionActivated(payload);
        break;
      case 'subscription.charged':
        this.handleSubscriptionCharged(payload);
        break;
      case 'payment.captured':
        this.handlePaymentCaptured(payload);
        break;
      default:
        console.warn(`Unhandled event type: ${payload.event}`);
    }
  }

  private handleSubscriptionCharged(payload: any): void {
    // Logic for subscription charged
  }

  private handlePaymentCaptured(payload: any): void {
    // Logic for payment captured
  }

  private handleSubscriptionActivated(payload: any): void {

  }
}

================
File: src/core/webhook/webhook.module.ts
================
import { Module } from '@nestjs/common';
import { RazorpayWebhookService } from './razorpay.service';

@Module({
  providers: [RazorpayWebhookService],
  exports: [RazorpayWebhookService],
})
export class WebhookModule {}

================
File: src/core/core.module.ts
================
// core.module.ts
import { Module, Global } from '@nestjs/common'
import { ConfigModule } from '@nestjs/config'
import { Reflector } from '@nestjs/core'
import { LoggerModule } from './modules/logger.module'
import { PaginationService } from './services/pagination.service'
import { PermissionModule } from './modules/permission.module'
import { PrismaModule } from './modules/prisma.module'
import { DebugService } from './services/debug.service'

@Global()
@Module({
  imports: [ConfigModule, PrismaModule, LoggerModule, PermissionModule],
  providers: [PaginationService, DebugService, Reflector],
  exports: [PaginationService, LoggerModule, PermissionModule, DebugService, Reflector],
})
export class CoreModule {}

================
File: src/core/index.ts
================
/**
 * @file Auto-generated barrel file
 * @generated
 */

export * from './base/base.dto'
export * from './base/base.gateway'
export * from './base/base.model'
export * from './config/configuration'
export * from './config/domain-config'
export * from './dto/pagination.dto'
export * from './logger/custom.logger'
export * from './logger/logger.colors'
export * from './pipes/transformation.pipe'
export * from './pipes/trim.pipe'
export * from './pipes/type-conversion.pipe'
export * from './pipes/validation.pipe'
export * from './storage/throttler.storage'
export * from './utils/auth.utils'
export * from './utils/permission.utils'

================
File: src/jobs/controllers/job-config.controller.ts
================
import {
  Controller,
  Get,
  Post,
  Put,
  Delete,
  Body,
  Param,
  Query,
  ParseUUIDPipe,
  UseGuards,
  HttpException,
  HttpStatus,
} from '@nestjs/common'
import { ApiOperation } from '@nestjs/swagger'
import { PermissionGuard } from '@core/guards/permission.guard'
import { Prisma } from '@astronera/db'
import { ConfigService } from '@nestjs/config'
import { PrismaService } from '@core/services/prisma.service'
import { PaginationService } from '@core/services/pagination.service'
import { CustomLogger } from '@core/logger/custom.logger'
import { BaseController, ApiBaseController } from '@core/base/base.controller'
import { PaginatedQuery } from '@types'
import { JobConfigService } from '../services/job-config.service'

@ApiBaseController('job-configs')
@UseGuards(PermissionGuard)
@Controller()
export class JobConfigController extends BaseController {
  constructor(
    protected readonly jobConfigService: JobConfigService,
    protected readonly prisma: PrismaService,
    protected readonly config: ConfigService,
    protected readonly paginationService: PaginationService,
    protected readonly logger: CustomLogger,
  ) {
    // Match the Prisma model name you intend to use
    super('JobConfigs')
  }

  @Get()
  @ApiOperation({ summary: 'Get all job configs (cron-jobs)' })
  async getAll(@Query() query: PaginatedQuery) {
    try {
      // If you want fully customized retrieval, call a custom service method:
      // return this.jobConfigsService.getAllJobConfigs(query)
      // Or, use the base controllers `findAll` for quick paging/filters:
      return await this.findAll(query)
    } catch (error: any) {
      throw new HttpException(
        error.message || 'An error occurred',
        error.status || HttpStatus.INTERNAL_SERVER_ERROR,
      )
    }
  }

  @Get(':id')
  @ApiOperation({ summary: 'Get a single job config by ID' })
  async findOneJobConfig(
    @Param('id', ParseUUIDPipe) id: string,
    @Query('include') include?: string[],
  ) {
    try {
      return await this.findOne(id, include)
    } catch (error: any) {
      throw this.handleError(error)
    }
  }

  @Post()
  @ApiOperation({ summary: 'Create a new job config (cron-job)' })
  async createJobConfig(@Body() data: Prisma.JobConfigsCreateInput) {
    try {
      return await this.create(data)
    } catch (error: any) {
      throw this.handleError(error)
    }
  }

  @Put(':id')
  @ApiOperation({ summary: 'Update an existing job config' })
  async updateJobConfig(
    @Param('id', ParseUUIDPipe) id: string,
    @Body() data: Prisma.JobConfigsUpdateInput,
  ) {
    try {
      return await this.update(id, data)
    } catch (error: any) {
      throw this.handleError(error)
    }
  }

  @Delete(':id')
  @ApiOperation({ summary: 'Delete a job config' })
  async removeJobConfig(@Param('id', ParseUUIDPipe) id: string) {
    try {
      return await this.remove(id)
    } catch (error: any) {
      throw this.handleError(error)
    }
  }
}

================
File: src/jobs/controllers/job-metric.controller.ts
================
import {
  Controller,
  Get,
  Post,
  Put,
  Delete,
  Body,
  Param,
  Query,
  ParseUUIDPipe,
  UseGuards,
  HttpException,
  HttpStatus,
} from '@nestjs/common'
import { ApiOperation } from '@nestjs/swagger'
import { ConfigService } from '@nestjs/config'
import { PrismaService } from '@core/services/prisma.service'
import { PaginationService } from '@core/services/pagination.service'
import { CustomLogger } from '@core/logger/custom.logger'
import { PermissionGuard } from '@core/guards/permission.guard'
import { BaseController, ApiBaseController } from '@core/base/base.controller'
import { JobMetricService } from '../services/job-metric.service'
import { Prisma } from '@astronera/db'
import { PaginatedQuery } from '@types'

@ApiBaseController('job-metrics')
@UseGuards(PermissionGuard)
@Controller()
export class JobMetricController extends BaseController {
  constructor(
    protected readonly jobMetricService: JobMetricService,
    protected readonly prisma: PrismaService,
    protected readonly config: ConfigService,
    protected readonly paginationService: PaginationService,
    protected readonly logger: CustomLogger,
  ) {
    super('JobMetrics')
  }

  @Get()
  @ApiOperation({ summary: 'Retrieve all job metrics' })
  async getAll(@Query() query: PaginatedQuery) {
    try {
      // If you need a simple paginated list:
      return await this.findAll(query)
      // Or for custom logic, call service methods, e.g.:
      // return await this.jobMetricService.findMetricsByJobName('my-job')
    } catch (error: any) {
      throw new HttpException(
        error.message || 'An error occurred',
        error.status || HttpStatus.INTERNAL_SERVER_ERROR,
      )
    }
  }

  @Get(':id')
  @ApiOperation({ summary: 'Retrieve a single job metric by ID' })
  async findOneJobMetric(
    @Param('id', ParseUUIDPipe) id: string,
    @Query('include') include?: string[],
  ) {
    try {
      return await this.findOne(id, include)
    } catch (error: any) {
      throw this.handleError(error)
    }
  }

  @Post()
  @ApiOperation({ summary: 'Create a new job metric record' })
  async createJobMetric(@Body() data: Prisma.JobMetricsCreateInput) {
    try {
      return await this.create(data)
    } catch (error: any) {
      throw this.handleError(error)
    }
  }

  @Put(':id')
  @ApiOperation({ summary: 'Update a job metric record' })
  async updateJobMetric(
    @Param('id', ParseUUIDPipe) id: string,
    @Body() data: Prisma.JobMetricsUpdateInput,
  ) {
    try {
      return await this.update(id, data)
    } catch (error: any) {
      throw this.handleError(error)
    }
  }

  @Delete(':id')
  @ApiOperation({ summary: 'Delete a job metric record' })
  async removeJobMetric(@Param('id', ParseUUIDPipe) id: string) {
    try {
      return await this.remove(id)
    } catch (error: any) {
      throw this.handleError(error)
    }
  }
}

================
File: src/jobs/services/job-config.service.ts
================
import { Injectable } from '@nestjs/common'
import { BaseService } from '@core/base/base.service'
import { PrismaService } from '@core/services/prisma.service'
import { PaginationService } from '@core/services/pagination.service'

@Injectable()
export class JobConfigService extends BaseService<'JobConfigs'> {
  constructor(
    protected readonly prisma: PrismaService,
    protected readonly paginationService: PaginationService,
  ) {
    super('JobConfigs')
  }

  // Example custom method
  async getAllJobConfigs(query: any) {
    // Your custom logic or direct calls to executePrismaQuery, e.g.:
    return this.executePrismaQuery(() =>
      // This could be further refined to include pagination, filtering, etc.
      this.prisma.jobConfigs.findMany({
        where: {},
        orderBy: { created_at: 'desc' },
      }),
    )
  }
}

================
File: src/jobs/services/job-metric.service.ts
================
import { Injectable } from '@nestjs/common'
import { Prisma } from '@astronera/db'
import { BaseService } from '@core/base/base.service'
import { PrismaService } from '@core/services/prisma.service'
import { PaginationService } from '@core/services/pagination.service'

@Injectable()
export class JobMetricService extends BaseService<'JobMetrics'> {
  constructor(
    protected readonly prisma: PrismaService,
    protected readonly paginationService: PaginationService,
  ) {
    // Pass in the Prisma model name to the super constructor
    super('JobMetrics')
  }

  // Example custom method (e.g., filter by job_name or date range)
  async findMetricsByJobName(jobName: string) {
    return this.executePrismaQuery(() =>
      this.prisma.jobMetrics.findMany({
        where: { job_name: jobName },
        orderBy: { created_at: 'desc' },
      }),
    )
  }
}

================
File: src/jobs/index.ts
================
/**
 * @file Auto-generated barrel file
 * @generated
 */

================
File: src/jobs/job.module.ts
================
import { Module } from '@nestjs/common'
import { JobConfigController } from './controllers/job-config.controller'
import { JobConfigService } from './services/job-config.service'
import { JobMetricController } from './controllers/job-metric.controller'
import { JobMetricService } from './services/job-metric.service'

@Module({
  controllers: [JobConfigController, JobMetricController],
  providers: [JobConfigService, JobMetricService],
  exports: [JobConfigService, JobMetricService],
})
export class JobModule {}

================
File: src/monitoring/controllers/error-metrics.controller.ts
================
// src/monitoring/controllers/error-metrics.controller.ts
import { Controller, Get, Query, UseGuards, HttpException, HttpStatus } from '@nestjs/common'
import { ApiTags, ApiOperation } from '@nestjs/swagger'
import { PermissionGuard } from '@core/guards/permission.guard'
import { ErrorMetricService } from '../services/error-metrics.service'
import { ApiBaseController } from '@core/base/base.controller'
import type { ErrorSeverity, ErrorType } from '@astronera/db'

@ApiBaseController('error-metrics')
@UseGuards(PermissionGuard)
export class ErrorMetricController {
  constructor(private readonly metricsService: ErrorMetricService) {}

  @Get('frequency')
  @ApiOperation({ summary: 'Get error frequency data' })
  async getErrorFrequency(
    @Query('startDate') startDate?: string,
    @Query('endDate') endDate?: string,
    @Query('service') serviceName?: string,
    @Query('type') errorType?: ErrorType,
    @Query('severity') severity?: ErrorSeverity,
  ) {
    try {
      return await this.metricsService.getErrorFrequency({
        startDate,
        endDate,
        serviceName,
        errorType,
        severity,
      })
    } catch (error: any) {
      throw new HttpException(
        error.message || 'Failed to retrieve error frequency',
        error.status || HttpStatus.INTERNAL_SERVER_ERROR,
      )
    }
  }

  @Get('metrics')
  @ApiOperation({ summary: 'Get error metrics' })
  async getErrorMetrics(
    @Query('startDate') startDate?: string,
    @Query('endDate') endDate?: string,
    @Query('service') serviceName?: string,
    @Query('type') errorType?: ErrorType,
  ) {
    try {
      return await this.metricsService.getErrorMetrics({
        startDate,
        endDate,
        serviceName,
        errorType,
      })
    } catch (error: any) {
      throw new HttpException(
        error.message || 'Failed to retrieve error metrics',
        error.status || HttpStatus.INTERNAL_SERVER_ERROR,
      )
    }
  }

  @Get('stats')
  @ApiOperation({ summary: 'Get error stats data' })
  async getErrorStats(
    @Query('minExecTime') minExecTime?: number,
    @Query('topLevel') topLevel?: boolean,
  ) {
    try {
      return await this.metricsService.getErrorStats({
        minExecTime,
        topLevel,
      })
    } catch (error: any) {
      throw new HttpException(
        error.message || 'Failed to retrieve error stats',
        error.status || HttpStatus.INTERNAL_SERVER_ERROR,
      )
    }
  }

  @Get('trends')
  @ApiOperation({ summary: 'Get error trends over time' })
  async getErrorTrends(
    @Query('timeframe') timeframe: '1h' | '24h' | '7d' | '30d' = '24h',
    @Query('service') serviceName?: string,
  ) {
    try {
      return await this.metricsService.getErrorTrends(timeframe, serviceName)
    } catch (error: any) {
      throw new HttpException(
        error.message || 'Failed to retrieve error trends',
        error.status || HttpStatus.INTERNAL_SERVER_ERROR,
      )
    }
  }
}

================
File: src/monitoring/controllers/health.controller.ts
================
// src/monitoring/controllers/health.controller.ts
import { Controller, Get, OnModuleInit, OnModuleDestroy, Req } from '@nestjs/common'
import { Request } from 'express'
import { Public } from '@core/decorators/public.decorator'
import { CustomLogger } from '@core/logger/custom.logger'
import {
  HealthCheckService,
  HttpHealthIndicator,
  DiskHealthIndicator,
  MemoryHealthIndicator,
} from '@nestjs/terminus'
import { HealthCheck } from '@nestjs/terminus'

@Controller('monitoring')
export class HealthController implements OnModuleInit, OnModuleDestroy {
  private readonly logger = new CustomLogger('Health')
  private healthCheckInterval: NodeJS.Timeout | null = null

  constructor(
    private health: HealthCheckService,
    private http: HttpHealthIndicator,
    private disk: DiskHealthIndicator,
    private memory: MemoryHealthIndicator,
  ) {}

  onModuleInit() {
    this.healthCheckInterval = setInterval(
      () => {
        this.performHealthCheck()
      },
      60 * 1000 * 30,
    )
  }

  private async performHealthCheck() {
    return this.health.check([
      () => this.http.pingCheck('nestjs-docs', 'https://docs.nestjs.com'),
      () => this.disk.checkStorage('storage', { path: '/', thresholdPercent: 0.9 }),
      () => this.memory.checkHeap('memory_heap', 150 * 1024 * 1024),
    ])
  }

  onModuleDestroy() {
    if (this.healthCheckInterval) {
      clearInterval(this.healthCheckInterval)
    }
  }

  @Get('health')
  @Public()
  @HealthCheck()
  async check(@Req() req: Request) {
    this.logger.log('Health check endpoint called', {
      timestamp: new Date().toISOString(),
      headers: req.headers,
      ip: req.ip,
      method: req.method,
      path: req.path,
    })
    return this.performHealthCheck()
  }
}

================
File: src/monitoring/controllers/log.controller.ts
================
// src/monitoring/controllers/logs.controller.ts
import {
  Controller,
  Get,
  Post,
  Body,
  Query,
  UseGuards,
  HttpException,
  HttpStatus,
  Inject,
} from '@nestjs/common'
import { MessagePattern } from '@nestjs/microservices'
import { ApiTags, ApiOperation } from '@nestjs/swagger'
import { ConfigService } from '@nestjs/config'
import { PrismaService } from '@core/services/prisma.service'
import { PaginationService } from '@core/services/pagination.service'
import { CustomLogger } from '@core/logger/custom.logger'
import { ErrorLogs } from '@astronera/db'
import { BaseController } from '@core/base/base.controller'
import { PermissionGuard } from '@core/guards/permission.guard'
import { ApiKeyGuard } from '@core/guards/api-key.guard'
import { LogService } from '../services/log.service'
import { ApiBaseController } from '@core/base/base.controller'
import { ApiPaginatedResponse } from '@core/decorators/api.decorator'
import { Service } from '@core/decorators/service.decorator'
import type { LogEntry } from '@ib/cache'
import type { ErrorLogEntry } from '@ib/logger'


@ApiBaseController('logs')
@UseGuards(PermissionGuard)
export class LogController extends BaseController {
  constructor(
    protected readonly logService: LogService,
    protected readonly prisma: PrismaService,
    protected readonly config: ConfigService,
    protected readonly paginationService: PaginationService,
    protected readonly logger: CustomLogger,
  ) {
    super('ErrorLogs')
    this.logger.setDomain('monitoring')
  }

  @Get('patterns')
  @ApiOperation({ summary: 'Get error patterns' })
  async getErrorPatterns() {
    try {
      return await this.logService.getErrorPatterns()
    } catch (error: any) {
      throw new HttpException(
        error.message || 'Failed to retrieve error patterns',
        error.status || HttpStatus.INTERNAL_SERVER_ERROR,
      )
    }
  }

  @ApiPaginatedResponse({})
  @Get()
  async getLogs(
    @Query('from') from?: string,
    @Query('to') to?: string,
    @Query('service') service?: string,
    @Query('severity') severity?: string,
    @Query('page') page: number = 1,
    @Query('pageSize') pageSize: number = 50,
  ) {
    // For historical logs, get from Postgres
    if (from && to) {
      return this.logService.getHistoricalLogs({
        from: new Date(from),
        to: new Date(to),
        service,
        severity,
        page,
        pageSize,
      })
    }

    // For recent logs (last 24h), get from Redis
    return this.logService.getRecentLogs({
      service,
      severity,
      page,
      pageSize,
    })
  }

  @Post('process')
  @Service()
  @ApiOperation({ summary: 'Process new log entry' })
  async processLog(@Body() log: LogEntry) {
    try {
      const errorLog: ErrorLogEntry = {
        ...log,
        id: '', // provide appropriate value
        service_name: '', // provide appropriate value
        severity: '', // provide appropriate value
        environment: '', // provide appropriate value
        created_at: new Date().toISOString(), // provide appropriate value
      }
      return await this.logService.processLog(errorLog)
    } catch (error: any) {
      throw new HttpException(
        error.message || 'Failed to process log',
        error.status || HttpStatus.INTERNAL_SERVER_ERROR,
      )
    }
  }

  @Get('stats')
  @ApiOperation({ summary: 'Get log statistics' })
  async getLogStats(@Query('hours') hours?: number) {
    try {
      return await this.logService.getLogStats(hours)
    } catch (error: any) {
      throw new HttpException(
        error.message || 'Failed to retrieve log statistics',
        error.status || HttpStatus.INTERNAL_SERVER_ERROR,
      )
    }
  }
}

================
File: src/monitoring/gateways/log.gateway.ts
================
// src/monitoring/gateways/log.gateway.ts

import {
  WebSocketGateway,
  SubscribeMessage,
  OnGatewayConnection,
  OnGatewayDisconnect,
  ConnectedSocket,
  MessageBody,
} from '@nestjs/websockets'
import { UseGuards, Injectable } from '@nestjs/common'
import { Socket } from 'socket.io'
import { PermissionGuard } from '@core/guards/permission.guard'
import { CustomLogger } from '@core/logger/custom.logger'
import { BaseGateway } from '@core/base/base.gateway'
import * as crypto from 'crypto'

// Same interface as before
interface LogFilters {
  service?: string
  severity?: string
  startTime?: string
  endTime?: string
}

// @UseGuards(PermissionGuard)
@WebSocketGateway({
  path: '/log-stream',
  transports: ['websocket', 'polling'],
})
export class LogGateway extends BaseGateway implements OnGatewayConnection, OnGatewayDisconnect {
  // We override `connectedClients` in order to store additional data
  private readonly clientMetadata = new Map<
    string,
    {
      filters?: LogFilters
      rooms: Set<string>
    }
  >()

  constructor(logger: CustomLogger) {
    super()
    // (Optional) give this gateway a domain or change the context
    this.logger.setContext('log-gateway')
    this.logger.setDomain('monitoring')

    this.server?.on('connect_error', (err) => {
      this.logger.error('Socket connection error', { error: err })
    })

    this.server?.on('connection_failed', (err) => {
      this.logger.error('Socket connection failed', { error: err })
    })
  }

  /**
   * Override handleConnection to store extended info
   */
  override async handleConnection(client: Socket) {
    // Call BaseGateway's handleConnection if you want to track
    // each raw Socket in `baseConnectedClients`
    super.handleConnection(client)

    try {
      // Add client to our tracking
      this.clientMetadata.set(client.id, {
        rooms: new Set(),
      })

      this.logger.log('Client connected to log stream', {
        clientId: client.id,
        handshake: {
          query: client.handshake.query,
          headers: client.handshake.headers,
        },
      })

      // Send initial connection success
      client.emit('connection_status', {
        status: 'connected',
        clientId: client.id,
        timestamp: new Date().toISOString(),
      })
    } catch (error) {
      this.logger.error('Error handling client connection', {
        error,
        clientId: client.id,
      })
      client.disconnect(true)
    }
  }

  /**
   * Override handleDisconnect to clean up your extended map
   */
  override async handleDisconnect(client: Socket) {
    // Also call the base method if you want the base gateway to track this
    super.handleDisconnect(client)

    try {
      // Clean up client tracking
      const clientInfo = this.clientMetadata.get(client.id)
      if (clientInfo) {
        // Leave all rooms
        clientInfo.rooms.forEach((room) => client.leave(room))
        this.clientMetadata.delete(client.id)
      }

      this.logger.log('Client disconnected from log stream', {
        clientId: client.id,
      })
    } catch (error) {
      this.logger.error('Error handling client disconnect', {
        error,
        clientId: client.id,
      })
    }
  }

  /**
   * Subscribe message example
   */
  @SubscribeMessage('subscribe')
  async handleSubscribe(@ConnectedSocket() client: Socket, @MessageBody() filters: LogFilters) {
    try {
      // Retrieve or initialize client info
      const clientInfo = this.clientMetadata.get(client.id) || {
        filters: undefined,
        rooms: new Set<string>(),
      }

      // Leave previous rooms
      clientInfo.rooms.forEach((room) => client.leave(room))
      clientInfo.rooms.clear()

      // Compute room name from filters
      const room = this.getFilterRoom(filters)
      await client.join(room)
      clientInfo.rooms.add(room)

      // Update client info
      clientInfo.filters = filters
      this.clientMetadata.set(client.id, clientInfo)

      this.logger.log('Client subscribed to log stream', {
        clientId: client.id,
        filters,
        room,
      })

      return {
        event: 'subscribed',
        data: {
          room,
          filters,
          timestamp: new Date().toISOString(),
        },
      }
    } catch (error) {
      this.logger.error('Error handling subscription', {
        error,
        clientId: client.id,
        filters,
      })
      throw error
    }
  }

  /**
   * Helper to map filters to a room name
   */
  private getFilterRoom(filters: LogFilters): string {
    const service = filters?.service || '*'
    const severity = filters?.severity || '*'
    return `logs:${service}:${severity}`
  }

  /**
   * Broadcast logs to relevant rooms
   */
  async broadcastLog(log: any) {
    try {
      console.log('broadcastLog', log)
      const roomPatterns = [
        `logs:${log.service}:${log.severity}`,
        `logs:${log.service}:*`,
        `logs:*:${log.severity}`,
        `logs:*:*`,
      ]

      // Emit to each matching room
      // Emit to each matching room
      roomPatterns.forEach((room) => {
        this.server.to(room).emit('newLog', {
          ...log,
          created_at: new Date().toISOString(),
        })
      })

      this.logger.debug('Broadcast log to rooms', {
        logId: log.id,
        service: log.service,
        severity: log.severity,
        rooms: roomPatterns,
      })
    } catch (error) {
      this.logger.error('Error broadcasting log', {
        error,
        log,
      })
      throw error
    }
  }

  /**
   * Helper methods for monitoring/debugging
   */
  getConnectedClients() {
    return Array.from(this.clientMetadata.entries()).map(([id, info]) => ({
      clientId: id,
      filters: info.filters,
      rooms: Array.from(info.rooms),
      connectedAt: info.filters.startTime,
    }))
  }

  getRoomSubscriptions() {
    const rooms = new Map<string, string[]>()
    this.connectedClients.forEach((info, clientId) => {
      info.rooms.forEach((room) => {
        const clients = rooms.get(room) || []
        clients.push(clientId)
        rooms.set(room, clients)
      })
    })
    return Object.fromEntries(rooms)
  }
}

================
File: src/monitoring/services/error-metrics.service.ts
================
// src/monitoring/services/error-metrics.service.ts
import { Injectable } from '@nestjs/common'
import { PrismaService } from '@core/services/prisma.service'
import { CustomLogger } from '@core/logger/custom.logger'
import type { ErrorSeverity, ErrorType } from '@astronera/db'

interface TimeRange {
  startDate?: string
  endDate?: string
}

interface ErrorQueryParams extends TimeRange {
  serviceName?: string
  errorType?: ErrorType
  severity?: ErrorSeverity
}

@Injectable()
export class ErrorMetricService {
  constructor(
    private readonly prisma: PrismaService,
    private readonly logger: CustomLogger,
  ) {
    this.logger.setDomain('monitoring')
  }

  async getErrorFrequency(params: ErrorQueryParams) {
    try {
      const { startDate, endDate, serviceName, errorType, severity } = params

      const where = {
        ...(serviceName && { service_name: serviceName }),
        ...(errorType && { error_type: errorType }),
        ...(severity && { severity }),
        ...(startDate &&
          endDate && {
            time_bucket: {
              gte: new Date(startDate),
              lte: new Date(endDate),
            },
          }),
      }

      const frequency = await this.prisma.error_frequency.findMany({
        where,
        orderBy: { time_bucket: 'desc' },
      })

      return {
        data: frequency,
        timestamp: new Date().toISOString(),
      }
    } catch (error) {
      this.logger.error('Failed to get error frequency', { error })
      throw error
    }
  }

  async getErrorMetrics(params: ErrorQueryParams) {
    try {
      const { startDate, endDate, serviceName, errorType } = params

      const where = {
        ...(serviceName && { service_name: serviceName }),
        ...(errorType && { error_type: errorType }),
        ...(startDate &&
          endDate && {
            time_bucket: {
              gte: new Date(startDate),
              lte: new Date(endDate),
            },
          }),
      }

      const [metrics, totalErrors] = await Promise.all([
        this.prisma.error_metrics.findMany({
          where,
          orderBy: { time_bucket: 'desc' },
        }),
        this.prisma.error_metrics.aggregate({
          where,
          _sum: { error_count: true },
        }),
      ])

      return {
        data: metrics,
        total: totalErrors._sum.error_count || 0,
        timestamp: new Date().toISOString(),
      }
    } catch (error) {
      this.logger.error('Failed to get error metrics', { error })
      throw error
    }
  }

  async getErrorStats({ minExecTime, topLevel }: { minExecTime?: number; topLevel?: boolean }) {
    try {
      const where = {
        ...(minExecTime && { mean_exec_time: { gte: minExecTime } }),
        ...(topLevel !== undefined && { toplevel: topLevel }),
      }

      const stats = await this.prisma.error_stats.findMany({
        where,
        orderBy: { mean_exec_time: 'desc' },
      })

      return {
        data: stats,
        timestamp: new Date().toISOString(),
      }
    } catch (error) {
      this.logger.error('Failed to get error stats', { error })
      throw error
    }
  }

  async getErrorTrends(timeframe: '1h' | '24h' | '7d' | '30d', serviceName?: string) {
    try {
      const intervals = {
        '1h': { hours: 1, interval: 'minute' },
        '24h': { hours: 24, interval: 'hour' },
        '7d': { days: 7, interval: 'day' },
        '30d': { days: 30, interval: 'day' },
      }

      const { hours, days } = intervals[timeframe] as { hours?: number; days?: number; interval: string }
      const startDate = new Date()
      if (hours) startDate.setHours(startDate.getHours() - hours)
      if (days) startDate.setDate(startDate.getDate() - days)

      const trends = await this.prisma.error_metrics.groupBy({
        by: ['severity', 'time_bucket'],
        where: {
          time_bucket: { gte: startDate },
          ...(serviceName && { service_name: serviceName }),
        },
        _sum: { error_count: true },
        orderBy: { time_bucket: 'asc' },
      })

      // Group by severity and create time series
      const grouped = trends.reduce((acc, curr) => {
        const severity = curr.severity
        if (!acc[severity]) acc[severity] = []

        acc[severity].push({
          timestamp: curr.time_bucket,
          count: curr._sum.error_count || 0,
        })

        return acc
      }, {})

      return {
        data: grouped,
        timeframe,
        startDate: startDate.toISOString(),
        endDate: new Date().toISOString(),
      }
    } catch (error) {
      this.logger.error('Failed to get error trends', { error })
      throw error
    }
  }
}

================
File: src/monitoring/services/log.service.ts
================
// src/monitoring/services/log.service.ts
import { Injectable, Inject, OnModuleInit } from '@nestjs/common'
import { Redis } from 'ioredis'
import { PrismaService } from '@core/services/prisma.service'
import { PaginationService } from '@core/services/pagination.service'
import { CustomLogger } from '@core/logger/custom.logger'
import { Cron } from '@nestjs/schedule'
import { LogGateway } from '../gateways/log.gateway'
import type { ErrorLogEntry } from '@ib/logger'
import type { PaginatedQuery } from '@types'

@Injectable()
export class LogService implements OnModuleInit {
  private readonly LOG_KEY_PREFIX = 'logs:'
  private readonly RETENTION_HOURS = 24
  @Inject(LogGateway)
  private readonly logGateway: LogGateway

  constructor(
    @Inject('REDIS_CACHE') private readonly redis: Redis,
    private readonly prisma: PrismaService,
    private readonly paginationService: PaginationService,
    private readonly logger: CustomLogger,
  ) {
    this.logger.setDomain('monitoring')
  }

  async onModuleInit() {
    await this.cleanupOldLogs()
  }

  async getRecentLogs(
    query: PaginatedQuery & {
      hours?: number
      level?: 'error' | 'warn' | 'info'
      service?: string
    },
  ): Promise<any> {
    try {
      const { skip, take } = this.paginationService.getSkipTake(query)
      const hours = query.hours || this.RETENTION_HOURS

      // Get keys from Redis
      const keys = await this.redis.keys(`${this.LOG_KEY_PREFIX}*`)
      if (!keys.length)
        return {
          data: [],
          meta: this.paginationService.getPaginationMeta(0, query),
          created_at: new Date().toISOString(),
        }

      // Get all logs
      const pipeline = this.redis.pipeline()
      keys.forEach((key) => pipeline.hgetall(key))
      const results: any = await pipeline.exec()
      if (!results) return []

      // Filter and transform logs
      let logs = results
        .map(([err, data]) => {
          if (err || !data) return null
          return {
            ...Object.values(data),
            metadata: data.metadata ? JSON.parse(data.metadata) : {},
            created_at: parseInt(data.created_at),
          }
        })
        .filter(Boolean)
        .filter((log) => {
          const cutoff = Date.now() - hours * 3600000
          return (
            log.created_at >= cutoff &&
            (!query.level || log.level === query.level) &&
            (!query.service || log.service === query.service)
          )
        })
        .sort((a, b) => b.created_at - a.created_at)

      const total = logs.length
      logs = logs.slice(skip, skip + take)

      return {
        data: logs,
        meta: this.paginationService.getPaginationMeta(total, query),
        created_at: new Date().toISOString(),
      }
    } catch (error) {
      this.logger.error('Failed to get recent logs', { error })
      throw error
    }
  }

  async processLog(log: ErrorLogEntry): Promise<void> {
    try {
      const logKey = `${this.LOG_KEY_PREFIX}${log.created_at}`

      console.log('Processing log', logKey, log)

      await this.redis
        .multi()
        .hset(logKey, {
          ...log,
          metadata: JSON.stringify(log.metadata),
        })
        .expire(logKey, this.RETENTION_HOURS * 3600)
        .exec()

      await this.logGateway.broadcastLog(log)
    } catch (error) {
      this.logger.error('Failed to process log', { error })
      throw error
    }
  }

  async getLogStats(hours: number = 24) {
    try {
      const keys = await this.redis.keys(`${this.LOG_KEY_PREFIX}*`)
      const pipeline = this.redis.pipeline()
      keys.forEach((key) => pipeline.hgetall(key))
      const results = await pipeline.exec()

      const cutoff = Date.now() - hours * 3600000
      const stats = {
        total: 0,
        byLevel: {} as Record<string, number>,
        byService: {} as Record<string, number>,
        timeRange: {
          start: new Date(cutoff).toISOString(),
          end: new Date().toISOString(),
        },
      }

      results?.forEach(([err, data]: [err: any, data: any]) => {
        if (err || !data) return
        const created_at = parseInt(data.created_at)
        if (created_at < cutoff) return

        stats.total++
        stats.byLevel[data.level] = (stats.byLevel[data.level] || 0) + 1
        stats.byService[data.service] = (stats.byService[data.service] || 0) + 1
      })

      return stats
    } catch (error) {
      this.logger.error('Failed to get log stats', { error })
      throw error
    }
  }

  @Cron('0 * * * *')
  async batchProcessLogs(): Promise<void> {
    try {
      const hourAgo = Date.now() - 3600000
      const keys = await this.redis.keys(`${this.LOG_KEY_PREFIX}*`)

      const logsToProcess: any = await Promise.all(
        keys.map(async (key) => {
          const log = await this.redis.hgetall(key)
          return { key, ...log }
        }),
      )

      // Group logs by service and level
      const groupedLogs = logsToProcess.reduce((acc, log) => {
        const key = `${log.service}_${log.level}`
        if (!acc[key]) acc[key] = []
        acc[key].push(log)
        return acc
      }, {})

      // Store in PostgreSQL
      await Promise.all(
        (Object.values(groupedLogs) as any[][]).map(async (logs: any[]) => {
          await this.prisma.errorLogs.createMany({
            data: logs.map((log) => ({
              service_name: log.service,
              severity: this.mapLogLevelToSeverity(log.level),
              message: log.message,
              metadata: log.metadata ? JSON.parse(log.metadata) : {},
              created_at: new Date(parseInt(log.created_at)),
              environment: process.env.NODE_ENV || 'development',
              error_type: log.error_type || 'unknown', // Add this line
            })),
          })
        }),
      )

      // Cleanup processed logs
      await Promise.all(logsToProcess.map((log) => this.redis.del(log.key)))
    } catch (error) {
      this.logger.error('Failed to batch process logs', { error })
      throw error
    }
  }

  private async cleanupOldLogs(): Promise<void> {
    try {
      const retentionTime = Date.now() - this.RETENTION_HOURS * 3600000
      const keys = await this.redis.keys(`${this.LOG_KEY_PREFIX}*`)

      for (const key of keys) {
        const keyType = await this.redis.type(key)
        if (keyType !== 'hash') {
          this.logger.warn(`Deleting key ${key} with unexpected type: ${keyType}`)
          await this.redis.del(key)
          continue
        }
        const log = await this.redis.hgetall(key)
        if (parseInt(log.created_at) < retentionTime) {
          await this.redis.del(key)
        }
      }
    } catch (error) {
      this.logger.error('Failed to cleanup old logs', { error })
    }
  }

  private mapLogLevelToSeverity(level: string): 'low' | 'medium' | 'high' | 'critical' {
    switch (level) {
      case 'error':
        return 'critical'
      case 'warn':
        return 'high'
      case 'info':
        return 'medium'
      default:
        return 'low'
    }
  }

  async getHistoricalLogs({
    from,
    to,
    service,
    severity,
    page,
    pageSize,
  }: {
    from: Date
    to: Date
    service?: string
    severity?: string
    page: number
    pageSize: number
  }) {
    const { skip, take } = this.paginationService.getSkipTake({ page, pageSize })

    const [logs, total] = await Promise.all([
      this.prisma.errorLogs.findMany({
        where: {
          created_at: {
            gte: from,
            lte: to,
          },
          ...(service && { service_name: service }),
          ...(severity && { severity: severity as any }),
        },
        orderBy: { created_at: 'desc' },
        skip,
        take,
      }),
      this.prisma.errorLogs.count({
        where: {
          created_at: {
            gte: from,
            lte: to,
          },
          ...(service && { service_name: service }),
          ...(severity && { severity: severity as any }),
        },
      }),
    ])

    return {
      data: logs,
      meta: this.paginationService.getPaginationMeta(total, { page, pageSize }),
      created_at: new Date().toISOString(),
    }
  }

  async getErrorPatterns() {
    try {
      const patterns = await this.prisma.errorLogs.groupBy({
        by: ['error_hash', 'error_pattern'],
        where: {
          is_new_pattern: true,
          created_at: {
            gte: new Date(Date.now() - this.RETENTION_HOURS * 3600000),
          },
        },
        _count: {
          error_hash: true,
        },
        orderBy: {
          _count: {
            error_hash: 'desc',
          },
        },
      })

      return {
        patterns: await Promise.all(
          patterns.map(async (pattern) => {
            const example = await this.prisma.errorLogs.findFirst({
              where: { error_hash: pattern.error_hash },
              select: {
                message: true,
                stack_trace: true,
                service_name: true,
                domain: true,
                created_at: true,
              },
            })

            return {
              ...pattern,
              count: pattern._count.error_hash,
              example,
            }
          }),
        ),
        created_at: new Date().toISOString(),
      }
    } catch (error) {
      this.logger.error('Failed to get error patterns', { error })
      throw error
    }
  }
}

================
File: src/monitoring/services/monitoring.service.ts
================
// src/monitoring/services/monitoring.service.ts
import { Injectable } from '@nestjs/common'

@Injectable()
export class MonitoringService {
  async getSystemMetrics() {
    return {
      timestamp: new Date(),
      // Add more system metrics here
    }
  }
}

================
File: src/monitoring/index.ts
================
/**
 * @file Auto-generated barrel file
 * @generated
 */

export * from './gateways/log.gateway'

================
File: src/monitoring/monitoring.module.ts
================
// src/monitoring/monitoring.module.ts
import { Module } from '@nestjs/common'
import { TerminusModule } from '@nestjs/terminus'
import { HttpModule } from '@nestjs/axios'
import { CoreModule } from '@core/core.module'
import { PrismaModule } from '@core/modules/prisma.module'
import { createDomainModule } from '@core/config/domain-config'
import { HealthController } from './controllers/health.controller'
import { MonitoringService } from './services/monitoring.service'
import { ErrorMetricService } from './services/error-metrics.service'
import { LogService } from './services/log.service'
import { LogController } from './controllers/log.controller'
import { ErrorMetricController } from './controllers/error-metrics.controller'
import { LogGateway } from './gateways/log.gateway'

@Module({
  imports: [
    PrismaModule,
    CoreModule,
    TerminusModule,
    HttpModule,
    createDomainModule('monitoring', {
      requiresAuth: false,
      requiresCompany: false,
    }),
  ],
  controllers: [HealthController, LogController, ErrorMetricController],
  providers: [MonitoringService, LogService, ErrorMetricService, LogGateway],
  exports: [MonitoringService, LogService, ErrorMetricService],
})
export class MonitoringModule {}

================
File: src/observables/events.gateway.ts
================
import { WebSocketGateway, WebSocketServer } from '@nestjs/websockets'
import { OnModuleInit } from '@nestjs/common'
import { Server, Socket } from 'socket.io'
import { PaymentEventsService } from './payments.observable'

@WebSocketGateway({
  namespace: '/event',
  transports: ['websocket', 'polling'],
  cors: {
    origin: process.env.NUXT_PUBLIC_APP_URL,
  },
})
export class EventsGateway implements OnModuleInit {
  @WebSocketServer()
  server: Server

  constructor(private paymentEventsService: PaymentEventsService) {}

  handleConnection(client: Socket) {
    console.log('Client connected:', client.data)
  }

  onModuleInit() {
    console.log('EventsGateway initialized')

    this.paymentEventsService.getEvents().subscribe({
      next: (event) => {
        this.server.emit('paymentEvent', event)
      },
      error: (error) => {
        console.error('Payment event error:', error)
      },
    })
  }
}

================
File: src/observables/events.module.ts
================
import { Module } from "@nestjs/common";
import { EventsGateway } from "./events.gateway";
import { PaymentEventsService } from "./payments.observable";

@Module({
  providers: [PaymentEventsService, EventsGateway],
  exports: [PaymentEventsService]
})
export class EventsModule {}

================
File: src/observables/payments.observable.ts
================
import { Injectable } from '@nestjs/common';
import { Subject, Observable } from 'rxjs';

export interface PaymentEvent {
  type: 'created' | 'updated' | 'deleted';
  data: any;
}

@Injectable()
export class PaymentEventsService {
  private eventSubject = new Subject<PaymentEvent>();

  emit(event: PaymentEvent) {
    this.eventSubject.next(event);
  }

  getEvents(): Observable<PaymentEvent> {
    return this.eventSubject.asObservable();
  }
}

================
File: src/payments/controllers/payment.controller.ts
================
// payments.ejs template
import { Controller, Get, Query } from '@nestjs/common'
import { ApiTags, ApiOperation } from '@nestjs/swagger'
import { ConfigService } from '@nestjs/config'
import { PrismaService } from '@core/services/prisma.service'
import { PaginationService } from '@core/services/pagination.service'
import { CustomLogger } from '@core/logger/custom.logger'
import { BaseController } from '@core/base/base.controller'

import type { Prisma } from '@astronera/db'
import type { PaginatedResponse, PaginatedQuery } from '@types'
import { PaymentService } from '../services/payment.service'

@Controller('payments')
@ApiTags('Payment')
export class PaymentController extends BaseController {
  constructor(
    protected readonly paymentService: PaymentService,
    protected readonly prisma: PrismaService,
    protected readonly config: ConfigService,
    protected readonly paginationService: PaginationService,
    protected readonly logger: CustomLogger,
  ) {
    super('CustomerPayments')
  }

  @Get()
  @ApiOperation({ summary: 'Get all payments' })
  async findAllPaymentPayments(
    @Query() query: PaginatedQuery,
  ): Promise<
    PaginatedResponse<unknown> | { success: boolean; error: any; timestamp: string; code: any }
  > {
    try {
      this.logger.log('Fetching all payments')
      return super.findAll(query)
    } catch (error: any) {
      this.logger.error('Failed to fetch payments', error.stack)
      throw error
    }
  }
}

================
File: src/payments/controllers/plan.controller.ts
================
// plan.ejs template
import { Body, Controller, Get, Param, ParseIntPipe, Post, Put, Query } from '@nestjs/common'
import { ApiTags, ApiOperation } from '@nestjs/swagger'
import { PlanService } from '../services/plan.service'
import { Prisma } from '@astronera/db'
import { ConfigService } from '@nestjs/config'
import { PrismaService } from '@core/services/prisma.service'
import { PaginationService } from '@core/services/pagination.service'
import { CustomLogger } from '@core/logger/custom.logger'
import { BaseController } from '@core/base/base.controller'
import type { PaginatedResponse, PaginatedQuery } from '@types'

@Controller('payments/plans')
@ApiTags('Plan')
export class PlanController extends BaseController {
  constructor(
    protected readonly planService: PlanService,
    protected readonly prisma: PrismaService,
    protected readonly config: ConfigService,
    protected readonly paginationService: PaginationService,
    protected readonly logger: CustomLogger,
  ) {
    super('CustomerSubscriptionPlans')
  }

  @Get()
  @ApiOperation({ summary: 'Get all plans' })
  async findAllPlans(
    @Query() query: PaginatedQuery,
  ): Promise<
    PaginatedResponse<unknown> | { success: boolean; error: any; timestamp: string; code: any }
  > {
    try {
      this.logger.log('Fetching all plans')

      const filterQuery = {
        ...query,
        is_active:
          query.is_active && (query.is_active === 'TRUE' || query.is_active === 'true')
            ? true
            : false,
      }

      return super.findAll(query.is_active ? filterQuery : query)
    } catch (error: any) {
      this.logger.error('Failed to fetch plans', error.stack)
      throw error
    }
  }

  @Get(':id')
  @ApiOperation({ summary: 'Get plan by id' })
  async findOnePlan(@Param('id') id: number, @Query('include') include?: string[]) {
    try {
      return await super.findOne(`${id}`, include)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Put(':id')
  @ApiOperation({ summary: 'Update Plan' })
  async updatePlan(
    @Param('id', ParseIntPipe) id: string,
    @Body() data: Prisma.CustomerSubscriptionPlansUpdateInput,
  ) {
    try {
      return await super.update(id, data)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Post()
  @ApiOperation({ summary: 'Upsert Plan' })
  async upsertPlan(
    @Query() query: PaginatedQuery,
    @Body() data: Prisma.CustomerSubscriptionPlansUpdateInput,
  ) {
    try {
      return await super.upsert(query, data)
    } catch (error: any) {
      return this.handleError(error)
    }
  }
}

================
File: src/payments/controllers/provider.controller.ts
================
// provider.ejs template
import { Controller, Get, Param, Query } from '@nestjs/common'
import { ApiTags, ApiOperation } from '@nestjs/swagger'
import { ProviderService } from '../services/provider.service'
import { ConfigService } from '@nestjs/config'
import { PrismaService } from '@core/services/prisma.service'
import { PaginationService } from '@core/services/pagination.service'
import { CustomLogger } from '@core/logger/custom.logger'
import { BaseController } from '@core/base/base.controller'
import type { PaginatedResponse, PaginatedQuery } from '@types'

@Controller('payments/providers')
@ApiTags('Provider')
export class ProviderController extends BaseController {
  constructor(
    protected readonly providerService: ProviderService,
    protected readonly prisma: PrismaService,
    protected readonly config: ConfigService,
    protected readonly paginationService: PaginationService,
    protected readonly logger: CustomLogger,
  ) {
    super('PaymentProviders')
  }

  @Get()
  @ApiOperation({ summary: 'Get all payment providers' })
  async findAllPaymentProviders(
    @Query() query: PaginatedQuery,
  ): Promise<
    PaginatedResponse<unknown> | { success: boolean; error: any; timestamp: string; code: any }
  > {
    try {
      this.logger.log('Fetching all payment providers')
      return super.findAll(query)
    } catch (error: any) {
      this.logger.error('Failed to fetch payment providers', error.stack)
      throw error
    }
  }

  @Get(':id')
  @ApiOperation({ summary: 'Get payment provider by id' })
  async findOneProvider(@Param('id') id: number, @Query('include') include?: string[]) {
    try {
      return await super.findOne(`${id}`, include)
    } catch (error: any) {
      return this.handleError(error)
    }
  }
}

================
File: src/payments/controllers/refund.controller.ts
================
// provider.ejs template
import { Body, Controller, Get, Param, ParseIntPipe, Post, Put, Query } from '@nestjs/common'
import { ApiTags, ApiOperation } from '@nestjs/swagger'
import { ConfigService } from '@nestjs/config'
import { PrismaService } from '@core/services/prisma.service'
import { PaginationService } from '@core/services/pagination.service'
import { CustomLogger } from '@core/logger/custom.logger'
import { BaseController } from '@core/base/base.controller'

import type { Prisma } from '@astronera/db'
import type { PaginatedResponse, PaginatedQuery } from '@types'
import { RefundService } from '../services/refund.service'

@Controller('payments/refunds')
@ApiTags('Refund')
export class RefundController extends BaseController {
  constructor(
    protected readonly refundService: RefundService,
    protected readonly prisma: PrismaService,
    protected readonly config: ConfigService,
    protected readonly paginationService: PaginationService,
    protected readonly logger: CustomLogger,
  ) {
    super('CustomerRefunds')
  }

  @Get()
  @ApiOperation({ summary: 'Get all refunds' })
  async findAllRefunds(
    @Query() query: PaginatedQuery,
  ): Promise<
    PaginatedResponse<unknown> | { success: boolean; error: any; timestamp: string; code: any }
  > {
    try {
      this.logger.log('Fetching all plans')
      return super.findAll(query)
    } catch (error: any) {
      this.logger.error('Failed to fetch plans', error.stack)
      throw error
    }
  }

  @Get(':id')
  @ApiOperation({ summary: 'Get Refunds by id' })
  async findOneRefund(@Param('id', ParseIntPipe) id: string, @Query('include') include?: string[]) {
    try {
      return await super.findOne(id, include)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Post()
  @ApiOperation({ summary: 'Create Refund' })
  async createRefund(@Body() data: Prisma.CustomerRefundsCreateInput) {
    try {
      return await super.create(data)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Put(':id')
  @ApiOperation({ summary: 'Update Refund' })
  async updateRefund(@Param('id') id: string, @Body() data: Prisma.CustomerRefundsUpdateInput) {
    try {
      return await super.update(id, data)
    } catch (error: any) {
      return this.handleError(error)
    }
  }
}

================
File: src/payments/controllers/subscription.controller.ts
================
// provider.ejs template
import { Body, Controller, Get, Param, ParseIntPipe, Post, Put, Query } from '@nestjs/common'
import { ApiTags, ApiOperation } from '@nestjs/swagger'
import { ConfigService } from '@nestjs/config'
import { PrismaService } from '@core/services/prisma.service'
import { PaginationService } from '@core/services/pagination.service'
import { CustomLogger } from '@core/logger/custom.logger'
import { BaseController } from '@core/base/base.controller'

import type { Prisma } from '@astronera/db'
import type { PaginatedResponse, PaginatedQuery } from '@types'
import { SubscriptionService } from '../services/subscription.service'

@Controller('payments/subscriptions')
@ApiTags('Subscription')
export class SubscriptionController extends BaseController {
  constructor(
    protected readonly subscriptionService: SubscriptionService,
    protected readonly prisma: PrismaService,
    protected readonly config: ConfigService,
    protected readonly paginationService: PaginationService,
    protected readonly logger: CustomLogger,
  ) {
    super('CustomerSubscriptions')
  }

  @Get()
  @ApiOperation({ summary: 'Get all subscriptions' })
  async findAllSubscriptions(
    @Query() query: PaginatedQuery,
  ): Promise<
    PaginatedResponse<unknown> | { success: boolean; error: any; timestamp: string; code: any }
  > {
    try {
      this.logger.log('Fetching all subscriptions')
      return super.findAll(query)
    } catch (error: any) {
      this.logger.error('Failed to fetch subscriptions', error.stack)
      throw error
    }
  }

  @Get(':id')
  @ApiOperation({ summary: 'Get Subscriptions by id' })
  async findOneSubscription(
    @Param('id', ParseIntPipe) id: string,
    @Query('include') include?: string[],
  ) {
    try {
      return await super.findOne(id, include)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Post()
  @ApiOperation({ summary: 'Create Subscription' })
  async createSubscription(@Body() data: Prisma.CustomerSubscriptionsCreateInput) {
    try {
      return await super.create(data)
    } catch (error: any) {
      return this.handleError(error)
    }
  }

  @Put(':id')
  @ApiOperation({ summary: 'Update Subscription' })
  async updateSubscription(
    @Param('id', ParseIntPipe) id: string,
    @Body() data: Prisma.CustomerSubscriptionsUpdateInput,
  ) {
    try {
      return await super.update(id, data)
    } catch (error: any) {
      return this.handleError(error)
    }
  }
}

================
File: src/payments/controllers/webhook.controller.ts
================
import { Controller, Headers, Post, Body, UnauthorizedException } from '@nestjs/common'
import { CustomLogger } from '@core/logger/custom.logger'
import { Public } from '@core/decorators/public.decorator'
import { ConfigService } from '@nestjs/config'
import { PaymentService } from '@payments/services/payment.service'
import { SubscriptionService } from '@payments/services/subscription.service'
import crypto from 'crypto'
import Razorpay from 'razorpay'

@Controller('webhook')
@Public()
export class WebhookController {
  constructor(
    private readonly subscriptionService: SubscriptionService,
    private readonly paymentService: PaymentService,
    private readonly logger: CustomLogger,
    private readonly config: ConfigService,
  ) {
    this.logger.setDomain('webhook')
  }

  @Post('razorpay')
  handleWebhook(
    @Body() body: any,
    @Headers('x-razorpay-signature') razorpaySignature: string,
  ): void {
    try {
      const secret = process.env.RAZORPAY_WEBHOOK_SECRET!

      const shasum = crypto.createHmac('sha256', secret)
      shasum.update(JSON.stringify(body))
      const digest = shasum.digest('hex')

      if (digest !== razorpaySignature) {
        console.error('Invalid Razorpay Signature')
        this.logger.error('Invalid Razorpay Signature', { body, razorpaySignature })
        return
      }

      const { payload, event } = body

      switch (event) {
        case 'subscription.activated':
        case 'subscription.completed':
        case 'subscription.resumed':
          this.checkOldSubscription(payload)
          break
        case 'subscription.authenticated':
        case 'subscription.paused':
        case 'subscription.pending':
        case 'subscription.halted':
        case 'subscription.charged':
        case 'subscription.cancelled':
        case 'subscription.updated':
          this.handleSubscriptionUpdate(payload)
          break
        case 'payment.captured':
          this.logger.log('Payment Captured', payload)
          this.handlePaymentUpdate(payload)
          break
        case 'payment.failed':
          this.logger.error('Payment Failed', payload)
          this.handlePaymentUpdate(payload)
          break
        case 'payment.refunded':
          this.logger.warn('Payment Refunded', payload)
          this.handlePaymentUpdate(payload)
          break
        default:
          console.warn(`Unhandled event type: ${event}`)
      }
    } catch (error: any) {
      this.logger.error('Unauthorized Webhook', { error })
      throw new UnauthorizedException('Invalid token')
    }
  }

  private handlePaymentUpdate(payment: any): void {
    const data = {
      external_payment_id: payment.id,
      user_id: payment.user_id,
      subscription_id: payment.subscription_id,
      payment_provider_id: payment.payment_provider_id,
      external_order_id: payment.order_id,
      amount: payment.amount / 100, // Razorpay gets the value in paise
      currency: payment.currency,
      status: payment.status,
      method: payment.method,
      description: payment.description,
      fee: payment.fee,
      tax: payment.tax,
      error_code: payment.error_code,
      error_description: payment.error_description,
      acquirer_data: payment.acquirer_data,
      notes: payment.notes,
      created_at: new Date(payment.created_at * 1000),
      order_id: payment.order_id,
      invoice_id: payment.invoice_id,
      international: payment.international,
      amount_refunded: payment.amount_refunded,
      amount_transferred: payment.amount_transferred,
      refund_status: payment.refund_status,
      captured: !!payment.captured,
      bank: payment.bank,
      wallet: payment.wallet,
      vpa: payment.vpa,
      error_source: payment.error_source,
      error_step: payment.error_step,
      error_reason: payment.error_reason,
    }

    this.paymentService.updatePayment(data)
  }

  private async handleSubscriptionUpdate(payload: any): Promise<void> {
    const { entity: subscriptionPayload } = payload.subscription

    const data = {
      external_subscription_id: subscriptionPayload.id,
      status: subscriptionPayload.status,
      quantity: subscriptionPayload.quantity,
      charge_at: new Date(subscriptionPayload.charge_at * 1000),
      start_at: new Date(subscriptionPayload.start_at * 1000),
      end_at: new Date(subscriptionPayload.end_at * 1000),
      total_count: subscriptionPayload.total_count,
      paid_count: subscriptionPayload.paid_count,
      remaining_count: subscriptionPayload.remaining_count,
      customer_notify: subscriptionPayload.customer_notify,
      created_at: new Date(subscriptionPayload.created_at * 1000),
      expire_by: subscriptionPayload.expire_by
        ? new Date(subscriptionPayload.expire_by * 1000)
        : null,
      short_url: subscriptionPayload.short_url,
      has_scheduled_changes: subscriptionPayload.has_scheduled_changes,
      change_scheduled_at: subscriptionPayload.change_scheduled_at
        ? new Date(subscriptionPayload.change_scheduled_at * 1000)
        : null,
      source: subscriptionPayload.source,
      offer_id: subscriptionPayload.offer_id,
    }

    this.subscriptionService.updateSubscription(data)

    if (payload.payment) {
      const { entity: payment } = payload.payment

      const subscription = await this.subscriptionService.findOne({
        where: {
          external_subscription_id: subscriptionPayload.id,
        },
      })

      payment.user_id = subscription.user_id
      payment.payment_provider_id = subscription.payment_provider_id
      payment.subscription_id = subscription.id

      this.handlePaymentUpdate(payment)
    }
  }

  private async checkOldSubscription(payload: any): Promise<void> {
    const { entity: subscriptionPayload } = payload.subscription

    try {
      const subscriptions = await this.subscriptionService.findMany({
        where: {
          user_id: subscriptionPayload.notes.user_id,
          plan_id: {
            not: subscriptionPayload.plan_id,
          },
        },
      })

      if (subscriptions.length) {
        this.logger.log('Found older subscriptions')
        const razorpay = await new Razorpay({
          key_id: this.config.get<string>('app.razorpay.key_id'),
          key_secret: this.config.get<string>('app.razorpay.key_secret'),
        })

        await Promise.all(
          subscriptions.map(async (subscription) =>
            razorpay.subscriptions.cancel(subscription.external_subscription_id),
          ),
        )
      }

      this.handleSubscriptionUpdate(payload)
    } catch (error: any) {
      this.logger.error('Error while checking old subscription', { error })
    }
  }
}

================
File: src/payments/models/payment.model.ts
================
// templates/entity/model.ejs
import { BaseModel } from '@core'

// Model interface
export interface PaymentModel extends BaseModel {
  id: number,
  user_id: string,
  subscription_id: number,
  payment_provider_id: number,
  external_payment_id: string,
  external_order_id: string,
  amount: number,
  currency: string,
  status: string,
  method: string,
  description: string,
  fee: number,
  tax: number,
  error_code: string,
  error_description: string,
  acquirer_data: Record<string, any>,
  notes: Record<string, any>,
  created_at: Date,
  order_id: string,
  invoice_id: string,
  international: boolean,
  amount_refunded: number,
  amount_transferred: number,
  refund_status: string,
  captured: boolean,
  bank: string,
  wallet: string,
  vpa: string,
  error_source: string,
  error_step: string,
  error_reason: string,
}

================
File: src/payments/models/plan.model.ts
================
// templates/entity/model.ejs
import { BaseModel } from '@core'

// Model interface
export interface PlanModel extends BaseModel {
  id: string
  external_plan_id: string
  name: string
  description: string
  interval: number
  interval_type: string
  monthly_amount: number
  annual_amount: number
  current: string
  features: string[]
  is_active: boolean
  created_at: Date
  updated_at?: Date
}

================
File: src/payments/models/provider.model.ts
================
// templates/entity/model.ejs
import { BaseModel } from '@core'

// Model interface
export interface ProviderModel extends BaseModel {
  id: string
  name: string
  is_active: boolean
  created_at: Date
  updated_at?: Date
}

================
File: src/payments/models/refund.model.ts
================
// templates/entity/model.ejs
import { BaseModel } from '@core'

// Model interface
export interface RefundModel extends BaseModel {
  acquirer_data: Record<string, any>
  amount: number
  batch_id: string
  created_at: Date
  currency: string
  external_refund_id: string
  id: number
  notes: Record<string, any>
  payment_id: number
  receipt: string
  speed_processed: string
  speed_requested: string
  status: string
}

================
File: src/payments/models/subscription.model.ts
================
// templates/entity/model.ejs
import { BaseModel } from '@core'
import { SubscriptionStatus } from 'src/types/subscription.types'
import { PlanModel } from './plan.model'
import { ProviderModel } from './provider.model'

// Model interface
export interface SubscriptionModel extends BaseModel {
  id: string
  external_subscription_id: string
  name: string
  status: SubscriptionStatus
  quantity: number

  cancel_at_period_end: boolean
  total_count: number
  paid_count: number
  remaining_count: number
  auth_attempts: number
  type: number
  customer_notify: boolean
  short_url: string
  has_scheduled_changes: boolean
  source: string
  offer_id: string
  pause_initiated_by: string
  cancel_initiated_by: string
  notes?: Record<string, any>
  
  
  created_at: Date
  updated_at?: Date
  start_at: Date
  end_at: Date
  change_scheduled_at: Date
  charge_at: Date
  ended_at: Date
  current_start?: Date
  current_end?: Date
  expire_by: Date

  user_id: string
  plan_id: number
  payment_provider_id: number

  plan: PlanModel
  provider: ProviderModel
}

================
File: src/payments/services/payment.service.ts
================
// templates/service/service.ejs
import { Injectable } from '@nestjs/common'
import type { Prisma } from '@astronera/db'
import { BaseService } from '@core/base/base.service'
import { PaginationService } from '@core/services/pagination.service'
import { PrismaService } from '@core/services/prisma.service'
import type { PaymentModel } from '../models/payment.model'

@Injectable()
export class PaymentService extends BaseService<'CustomerPayments'> {
  constructor(
    protected readonly prisma: PrismaService,
    protected readonly paginationService: PaginationService,
  ) {
    super('CustomerPayments')
  }

  async updatePayment(data) {
    const result = await this.prisma.customerPayments.upsert({
      where: {
        id: data.id,
        external_payment_id: data.external_payment_id,
      },
      update: data,
      create: data,
    })

    return result
  }

  async findWithRelations(id: number): Promise<PaymentModel | null> {
    const result = await this.prisma.customerPayments.findUnique({
      where: { id },
    })
    return result ? this.mapToModel(result) : null
  }

  async findMany(params: Prisma.CustomerPaymentsFindManyArgs): Promise<PaymentModel[]> {
    const items = await this.prisma.customerPayments.findMany(params)
    return items.map((item) => this.mapToModel(item))
  }

  async findAllPayments(
    query: Prisma.CustomerPaymentsFindManyArgs,
  ): Promise<{ items: PaymentModel[]; total: number }> {
    const [items, total] = await Promise.all([
      this.prisma.customerPayments.findMany({
        skip: query.skip,
        take: query.take,
        where: query.where,
        orderBy: query.orderBy,
      }),
      this.prisma.customerPayments.count({ where: query.where }),
    ])

    return {
      items: items.map((item) => this.mapToModel(item)),
      total,
    }
  }

  private mapToModel(data: any): PaymentModel {
    return {
      ...data,
    }
  }
}

================
File: src/payments/services/plan.service.ts
================
// templates/service/service.ejs
import { Injectable } from '@nestjs/common'
import type { Prisma } from '@astronera/db'
import { BaseService } from '@core/base/base.service'
import { PaginationService } from '@core/services/pagination.service'
import { PrismaService } from '@core/services/prisma.service'
import type { PlanModel } from '../models/plan.model'

@Injectable()
export class PlanService extends BaseService<'CustomerSubscriptionPlans'> {
  constructor(
    protected readonly prisma: PrismaService,
    protected readonly paginationService: PaginationService,
  ) {
    super('CustomerSubscriptionPlans')
  }

  async findWithRelations(id: number): Promise<PlanModel | null> {
    const result = await this.prisma.customerSubscriptionPlans.findUnique({
      where: { id },
    })
    return result ? this.mapToModel(result) : null
  }

  async findMany(params: Prisma.CustomerSubscriptionPlansFindManyArgs): Promise<PlanModel[]> {
    const items = await this.prisma.customerSubscriptionPlans.findMany(params)
    return items.map((item) => this.mapToModel(item))
  }

  async findAllPlans(
    query: Prisma.CustomerSubscriptionPlansFindManyArgs,
  ): Promise<{ items: PlanModel[]; total: number }> {
    const [items, total] = await Promise.all([
      this.prisma.customerSubscriptionPlans.findMany({
        skip: query.skip,
        take: query.take,
        where: query.where,
        orderBy: query.orderBy,
      }),
      this.prisma.customerSubscriptionPlans.count({ where: query.where }),
    ])

    return {
      items: items.map((item) => this.mapToModel(item)),
      total,
    }
  }

  private mapToModel(data: any): PlanModel {
    return {
      ...data,
    }
  }
}

================
File: src/payments/services/provider.service.ts
================
// templates/service/service.ejs
import { Injectable } from '@nestjs/common'
import type { Prisma } from '@astronera/db'
import { BaseService } from '@core/base/base.service'
import { PaginationService } from '@core/services/pagination.service'
import { PrismaService } from '@core/services/prisma.service'
import type { ProviderModel } from '../models/provider.model'

@Injectable()
export class ProviderService extends BaseService<'PaymentProviders'> {
  constructor(
    protected readonly prisma: PrismaService,
    protected readonly paginationService: PaginationService,
  ) {
    super('PaymentProviders')
  }

  async findWithRelations(id: number): Promise<ProviderModel | null> {
    const result = await this.prisma.paymentProviders.findUnique({
      where: { id },
    })
    return result ? this.mapToModel(result) : null
  }

  async findMany(params: Prisma.PaymentProvidersFindManyArgs): Promise<ProviderModel[]> {
    const items = await this.prisma.paymentProviders.findMany(params)
    return items.map((item) => this.mapToModel(item))
  }

  async findAllProviders(
    query: Prisma.PaymentProvidersFindManyArgs,
  ): Promise<{ items: ProviderModel[]; total: number }> {
    const [items, total] = await Promise.all([
      this.prisma.paymentProviders.findMany({
        skip: query.skip,
        take: query.take,
        where: query.where,
        orderBy: query.orderBy,
      }),
      this.prisma.paymentProviders.count({ where: query.where }),
    ])

    return {
      items: items.map((item) => this.mapToModel(item)),
      total,
    }
  }

  private mapToModel(data: any): ProviderModel {
    return {
      ...data,
    }
  }
}

================
File: src/payments/services/refund.service.ts
================
// templates/service/service.ejs
import { Injectable } from '@nestjs/common'
import type { Prisma } from '@astronera/db'
import { BaseService } from '@core/base/base.service'
import { PaginationService } from '@core/services/pagination.service'
import { PrismaService } from '@core/services/prisma.service'
import type { RefundModel } from '../models/refund.model'

@Injectable()
export class RefundService extends BaseService<'CustomerRefunds'> {
  constructor(
    protected readonly prisma: PrismaService,
    protected readonly paginationService: PaginationService,
  ) {
    super('CustomerRefunds')
  }

  async findWithRelations(id: number): Promise<RefundModel | null> {
    const result = await this.prisma.customerRefunds.findUnique({
      where: { id },
      include: {
        customer_payments: true,
      },
    })

    return result ? this.mapToModel(result) : null
  }

  async findMany(params: Prisma.CustomerRefundsFindManyArgs): Promise<RefundModel[]> {
    const items = await this.prisma.customerRefunds.findMany(params)
    return items.map((item) => this.mapToModel(item))
  }

  async findAllRefunds(
    query: Prisma.CustomerRefundsFindManyArgs,
  ): Promise<{ items: RefundModel[]; total: number }> {
    const [items, total] = await Promise.all([
      this.prisma.customerRefunds.findMany({
        skip: query.skip,
        take: query.take,
        where: query.where,
        orderBy: query.orderBy,
      }),
      this.prisma.customerRefunds.count({ where: query.where }),
    ])

    return {
      items: items.map((item) => this.mapToModel(item)),
      total,
    }
  }

  private mapToModel(data: any): RefundModel {
    return {
      ...data,
    }
  }
}

================
File: src/payments/services/subscription.service.ts
================
// templates/service/service.ejs
import { Injectable } from '@nestjs/common'
import type { Prisma } from '@astronera/db'
import { BaseService } from '@core/base/base.service'
import { PaginationService } from '@core/services/pagination.service'
import { PrismaService } from '@core/services/prisma.service'
import type { SubscriptionModel } from '../models/subscription.model'
import { PaymentEventsService } from '../../observables/payments.observable'

@Injectable()
export class SubscriptionService extends BaseService<'CustomerSubscriptions'> {
  constructor(
    protected readonly prisma: PrismaService,
    protected readonly paginationService: PaginationService,
    protected readonly paymentEvents: PaymentEventsService,
  ) {
    super('CustomerSubscriptions')
  }

  async updateSubscription(data) {
    const result = await this.prisma.customerSubscriptions.update({
      where: { external_subscription_id: data.external_subscription_id },
      data,
    })

    this.paymentEvents.emit({
      type: 'updated',
      data: result,
    })

    return result
  }

  async findWithRelations(id: number): Promise<SubscriptionModel | null> {
    const result = await this.prisma.customerSubscriptions.findUnique({
      where: { id },
      include: {
        customer_subscription_plans: true,
        payment_providers: true,
      },
    })

    return result ? this.mapToModel(result) : null
  }

  async findOne(params: Prisma.CustomerSubscriptionsFindUniqueArgs): Promise<SubscriptionModel> {
    const result = await this.prisma.customerSubscriptions.findUnique({
      ...params,
      include: {
        payment_providers: true,
      },
    })

    return result ? this.mapToModel(result) : null
  }

  async findMany(params: Prisma.CustomerSubscriptionsFindManyArgs): Promise<SubscriptionModel[]> {
    const items = await this.prisma.customerSubscriptions.findMany(params)
    return items.map((item) => this.mapToModel(item))
  }

  async findAllSubscriptions(
    query: Prisma.CustomerSubscriptionsFindManyArgs,
  ): Promise<{ items: SubscriptionModel[]; total: number }> {
    const [items, total] = await Promise.all([
      this.prisma.customerSubscriptions.findMany({
        skip: query.skip,
        take: query.take,
        where: query.where,
        orderBy: query.orderBy,
      }),
      this.prisma.customerSubscriptions.count({ where: query.where }),
    ])

    return {
      items: items.map((item) => this.mapToModel(item)),
      total,
    }
  }

  private mapToModel(data: any): SubscriptionModel {
    return {
      ...data,
    }
  }
}

================
File: src/payments/index.ts
================
export * from './models/payment.model';
export * from './models/plan.model';
export * from './models/provider.model';
export * from './models/refund.model';
export * from './models/subscription.model';

================
File: src/payments/payment.module.ts
================
// templates/module/content.module.ejs
import { Module } from '@nestjs/common'
import { CoreModule } from '@core/core.module'
import { PrismaModule } from '@core/modules/prisma.module'
import { PermissionModule } from '@core/modules/permission.module'
import { createDomainModule } from '@core/config/domain-config'
// Controllers
import { PaymentController } from '@payments/controllers/payment.controller'
import { PlanController } from '@payments/controllers/plan.controller'
import { ProviderController } from '@payments/controllers/provider.controller'
import { RefundController } from '@payments/controllers/refund.controller'
import { SubscriptionController } from '@payments/controllers/subscription.controller'

// Services
import { PaymentService } from '@payments/services/payment.service'
import { PlanService } from '@payments/services/plan.service'
import { ProviderService } from '@payments/services/provider.service'
import { RefundService } from '@payments/services/refund.service'
import { SubscriptionService } from '@payments/services/subscription.service'
import { WebhookModule } from '@core/webhook/webhook.module'
import { WebhookController } from './controllers/webhook.controller'
import { EventsModule } from '../observables/events.module'

@Module({
  imports: [
    EventsModule,
    PrismaModule,
    PermissionModule,
    CoreModule,
    WebhookModule,
    createDomainModule('content', {
      requiresAuth: true,
      requiresCompany: false,
    }),
  ],
  controllers: [
    PaymentController,
    PlanController,
    ProviderController,
    RefundController,
    SubscriptionController,
    WebhookController
  ],
  providers: [
    PaymentService,
    PlanService,
    ProviderService,
    RefundService,
    SubscriptionService,
  ],
  exports: [
    PaymentService,
    PlanService,
    ProviderService,
    RefundService,
    SubscriptionService
  ],
})
export class PaymentsModule {}

================
File: src/types/domain.types.ts
================
// Original interfaces remain the same
export interface DomainConfig {
  requiresAuth: boolean
  defaultPermissions: string[]
  supportsSoftDelete?: boolean
  supportsVersioning?: boolean
  requiresCompany?: boolean
  requiresUser?: boolean
  requiresEncryption?: boolean
  supportsCaching?: boolean
  requiresAdmin?: boolean
  sensitiveFields?: string[]
  exclude?: boolean
}

export interface CrossDomainConfig {
  allowedRelations: string[]
  implicitRelations?: {
    user?: boolean
    company?: boolean
  }
}

export interface LoggerConfig {
  domainName: string
  subContexts?: string[]
}

================
File: src/types/index.ts
================
/**
 * @file Auto-generated barrel file
 * @generated
 */

export * from './domain.types'
export * from './pagination.types'
export * from './permission.types'
export * from './plan.types'
export * from './subscription.types'

================
File: src/types/pagination.types.ts
================
export interface PaginatedResponse<T> {
  data: T[]
  meta: PaginationMeta
  success: boolean
  timestamp: string
  debug?: {
    permissions: {
      isPublic: boolean
      endpoint: string
      handler: string
      controller: string
      user?: {
        role: string
        email: string
      }
      roleHierarchy?: string[]
    }
    timestamp: string
  }
}

export interface PaginationMeta {
  total: number
  totalPages: number
  page: number
  limit: number
  hasNextPage: boolean
  hasPreviousPage: boolean
}

export interface PaginatedQuery {
  page?: number | string
  limit?: number | string
  sortBy?: string
  sortOrder?: 'asc' | 'desc'
  search?: string
  [key: string]: any
}

================
File: src/types/permission.types.ts
================
// types/permission.types.ejs
export enum PermissionAction {
  CREATE = 'CREATE',
  READ = 'READ',
  UPDATE = 'UPDATE',
  DELETE = 'DELETE',
  MANAGE = 'MANAGE',
}

export enum ResourceType {
  USER = 'USER',
  CONTENT = 'CONTENT',
  SETTINGS = 'SETTINGS',
  BILLING = 'BILLING',
}

export interface Permission {
  action: PermissionAction
  resource: ResourceType
  conditions?: Record<string, any>
}

export type DatabaseAction = 'select' | 'insert' | 'update' | 'delete'

export interface PermissionCondition {
  sql: string
}

export interface TokenPayload {
  role: string
  user_id: string
  email: string
  aud: string
  exp: number
}

export interface AuthError extends Error {
  status: number
  code: string
}

================
File: src/types/plan.types.ts
================
// types/plan.types.ejs
export enum PlanType {
  FREE = 'FREE',
  BASIC = 'BASIC',
  PREMIUM = 'PREMIUM',
  ENTERPRISE = 'ENTERPRISE',
}

export interface PlanFeature {
  name: string
  limit?: number
  enabled: boolean
}

export interface Plan {
  id: string
  name: string
  type: PlanType
  features: PlanFeature[]
  price: number
}

================
File: src/types/subscription.types.ts
================
// types/plan.types.ejs
export enum SubscriptionStatus {
  CREATED = 'CREATED',
  AUTHENTICATED = 'AUTHENTICATED',
  CHARGED = 'CHARGED',
  COMPLETED = 'COMPLETED',
  EXPIRED='EXPIRED',
  CANCELED='CANCELED',
}

================
File: src/app.module.ts
================
// app.module.ts
import * as path from 'path'
import { Module } from '@nestjs/common'
import { APP_GUARD } from '@nestjs/core'
import { ConfigModule } from '@nestjs/config'
import { ThrottlerModule } from '@nestjs/throttler'

import configuration from '@core/config/configuration'
import { CustomLogger } from '@core/logger/custom.logger'
// GUARDS
import { PermissionGuard } from '@core/guards/permission.guard'
// CORE modules
import { LoggerModule } from '@core/modules/logger.module'
import { PrismaModule } from '@core/modules/prisma.module'
import { CoreModule } from '@core/core.module'
// Feature modules
import { ContentModule } from '@content/content.module'
import { MonitoringModule } from '@monitoring/monitoring.module'
// New modules (for caching & jobs)
import { RedisModule } from '@core/cache/cache.module'
import { PaymentsModule } from '@payments/payment.module'
import { JobModule } from '@jobs/job.module'
import { EventsModule } from './observables/events.module'

@Module({
  imports: [
    // 1) Global config
    ConfigModule.forRoot({
      isGlobal: true,
      load: [configuration],
      envFilePath: path.resolve(__dirname, '../../../.env'),
      cache: true,
    }),

    // 2) Core modules & services
    PrismaModule,
    EventsModule,
    CoreModule,
    LoggerModule,

    // 3) Feature modules
    ContentModule,
    MonitoringModule,
    JobModule,
    PaymentsModule,

    // 4) Rate limiting
    ThrottlerModule.forRoot([
      {
        ttl: 60,
        limit: 10,
      },
    ]),

    // 5) Our new caching & jobs modules
    RedisModule,
  ],
  providers: [
    {
      provide: APP_GUARD,
      useClass: PermissionGuard,
    },
    {
      provide: CustomLogger,
      useValue: new CustomLogger(''),
    },
  ],
})
export class AppModule {}

================
File: src/main.ts
================
// main.ts
import { NestFactory } from '@nestjs/core'
import { ValidationPipe } from '@nestjs/common'
import tcpPortUsed from 'tcp-port-used'
import { SwaggerModule, DocumentBuilder } from '@nestjs/swagger'
import { ConfigService } from '@nestjs/config'
import compression from 'compression'

import { HttpExceptionFilter } from '@core/filters/http-exception.filter'
import { LoggingInterceptor } from '@core/interceptors/logging.interceptor'
import { CustomLogger } from '@core/logger/custom.logger'
import { PaginationInterceptor } from '@core/interceptors/pagination.interceptor'
import { TrimPipe } from '@core/pipes/trim.pipe'
import helmet from 'helmet'
import { IoAdapter } from '@nestjs/platform-socket.io'

// INTERCEPTORS
import { BigIntSerializationInterceptor } from '@core/interceptors/bigint.interceptor'
import { AppModule } from './app.module'
import { Logger } from '@nestjs/common'

Logger.overrideLogger(['log', 'error', 'warn', 'debug', 'verbose'])

async function bootstrap() {
  // Create the app with custom logger
  const logger = new CustomLogger('Bootstrap')
  const app = await NestFactory.create(AppModule, {
    logger,
  })

  app.useWebSocketAdapter(new IoAdapter(app))

  // Debug middleware
  // CORS Configuration - Let's use enableCors() instead of manual middleware
  app.enableCors({
    origin: [
      'https://admin.astronera.org',
      'https://app.astronera.org',
      'http://localhost:3000',
      'http://localhost:3009',
      'http://localhost:3001',
      'http://localhost:3002',
      'http://localhost:3003',
      'http://localhost:4200',
    ],
    methods: ['GET', 'HEAD', 'PUT', 'PATCH', 'POST', 'DELETE', 'OPTIONS'],
    allowedHeaders: [
      'Content-Type',
      'Accept',
      'Authorization',
      'x-api-key',
      'Origin',
      'baggage',
      'sentry-trace',
      'X-Requested-With',
      'Access-Control-Request-Method',
      'Access-Control-Request-Headers',
      'Upgrade',
      'Connection',
    ],
    exposedHeaders: ['Content-Range', 'X-Content-Range'],
    credentials: true,
    preflightContinue: false,
    optionsSuccessStatus: 204,
  })

  app.use((req, res, next) => {
    const logger = new CustomLogger('HTTP')
    logger.debug(`${req.method} ${req.path}`, {
      origin: req.headers.origin,
      method: req.method,
      path: req.path,
    })
    next()
  })

  const configService = app.get(ConfigService)

  // Security
  app.use(
    helmet({
      crossOriginEmbedderPolicy: false,
      crossOriginOpenerPolicy: false,
      crossOriginResourcePolicy: false,
      contentSecurityPolicy: {
        directives: {
          defaultSrc: ["'self'"],
          scriptSrc: ["'self'", "'unsafe-inline'", "'unsafe-eval'"],
          styleSrc: ["'self'", "'unsafe-inline'"],
          imgSrc: ["'self'", 'data:', 'https:'],
          connectSrc: ["'self'", 'wss:', 'ws:', '*.astronera.org'],
        },
      },
    }),
  )
  app.use(compression())

  // Global filters
  app.useGlobalFilters(new HttpExceptionFilter(new CustomLogger()))

  // Global interceptors
  app.useGlobalInterceptors(
    new BigIntSerializationInterceptor(),
    new LoggingInterceptor(new CustomLogger()),
    new PaginationInterceptor(),
  )

  // Global pipes
  app.useGlobalPipes(
    new ValidationPipe({
      transform: true,
      whitelist: true,
      forbidNonWhitelisted: true,
      transformOptions: {
        enableImplicitConversion: true,
      },
    }),
    new TrimPipe(),
  )

  // ToDo - add favicon to public folder
  app.use('/favicon.ico', (req, res) => {
    res.status(204).end()
  })
  // API Prefix
  app.setGlobalPrefix('api/v1')

  // Swagger Setup
  const config = new DocumentBuilder()
    .setTitle('API Documentation')
    .setDescription('The API description')
    .setVersion('1.0')
    .addTag('api')
    .addBearerAuth()
    .addApiKey({ type: 'apiKey', name: 'x-api-key', in: 'header' }, 'api-key')
    .build()

  const document = SwaggerModule.createDocument(app, config)
  SwaggerModule.setup('docs', app, document)

  // Startup
  const port = process.env.PORT || 8080
  const host = process.env.HOST ?? 'localhost' // Important for Railway
  console.log('Starting application on:', host, port)

  try {
    const inUse = await tcpPortUsed.check(Number(port), host)
    console.log('Port status:', { port, inUse })
    if (inUse) {
      console.error(`Port ${port} is already in use!`)
      process.exit(1)
    }
  } catch (error) {
    console.error('Error checking port:', error)
  }

  const listenPromise = app.listen(Number(port), host)
  const timeoutPromise = new Promise((_, reject) => {
    setTimeout(() => reject(new Error('Listen timeout after 10 seconds')), 10000)
  })
  try {
    await Promise.race([listenPromise, timeoutPromise])
    console.log('Listen successful!')
  } catch (error) {
    console.error('Listen failed or timed out:', error)
    throw error
  }

  console.log('12. Bootstrap process complete!')
}

bootstrap().catch((error: any) => {
  console.error('Bootstrap failed with error:', {
    message: error.message,
    stack: error.stack,
    code: error.code,
    errno: error.errno,
  })
  process.exit(1)
})

================
File: src/metadata.ts
================
/* eslint-disable */
export default async () => {
    const t = {};
    return { "@nestjs/swagger": { "models": [[import("./core/dto/pagination.dto"), { "PaginationParams": { page: { required: false, type: () => Number, default: 1 }, limit: { required: false, type: () => Number, default: 10 }, sort: { required: false, type: () => String }, search: { required: false, type: () => String }, order: { required: false, type: () => String }, include: { required: false, type: () => Object } } }]], "controllers": [[import("./core/base/base.controller"), { "BaseController": {} }], [import("./content/controllers/research-embeddings.controller"), { "ResearchEmbeddingController": { "findAllResearchEmbeddings": { type: Object }, "findOneResearchEmbeddings": { type: Object }, "createResearchEmbeddings": { type: Object }, "updateResearchEmbeddings": { type: Object }, "removeResearchEmbeddings": { type: Object } } }], [import("./content/controllers/embedding-reviews.controller"), { "EmbeddingReviewController": { "findAllEmbeddingReviews": { type: Object }, "findOneEmbeddingReviews": { type: Object }, "createEmbeddingReviews": { type: Object }, "updateEmbeddingReviews": { type: Object }, "removeEmbeddingReviews": { type: Object } } }], [import("./content/controllers/content-categories.controller"), { "ContentCategoryController": { "findAllContentCategories": { type: Object }, "findOneContentCategories": { type: Object }, "createContentCategories": { type: Object }, "updateContentCategories": { type: Object }, "removeContentCategories": { type: Object } } }], [import("./content/controllers/content-tags.controller"), { "ContentTagController": { "findAllContentTags": { type: Object }, "findOneContentTags": { type: Object }, "createContentTags": { type: Object }, "updateContentTags": { type: Object }, "removeContentTags": { type: Object } } }], [import("./content/controllers/content-statuses.controller"), { "ContentStatusController": { "findAllContentStatuses": { type: Object }, "findOneContentStatuses": { type: Object }, "createContentStatuses": { type: Object }, "updateContentStatuses": { type: Object }, "removeContentStatuses": { type: Object } } }], [import("./content/controllers/newsletters.controller"), { "NewsletterController": { "findAllNewsletters": { type: Object }, "findOneNewsletters": { type: Object }, "createNewsletters": { type: Object }, "updateNewsletters": { type: Object }, "removeNewsletters": { type: Object } } }], [import("./content/controllers/research.controller"), { "ResearchController": { "findAllResearch": { type: Object }, "findOneResearch": { type: Object }, "createResearch": { type: Object }, "updateResearch": { type: Object }, "removeResearch": { type: Object } } }], [import("./content/controllers/categories.controller"), { "CategoryController": { "findAllCategories": { type: Object }, "findOneCategories": { type: Object }, "createCategories": { type: Object }, "updateCategories": { type: Object }, "removeCategories": { type: Object } } }], [import("./content/controllers/feed-categories.controller"), { "FeedCategoryController": { "findAllFeedCategories": { type: Object }, "findOneFeedCategories": { type: Object }, "createFeedCategories": { type: Object }, "updateFeedCategories": { type: Object }, "removeFeedCategories": { type: Object } } }], [import("./content/controllers/feeds.controller"), { "FeedController": { "findAllFeeds": { type: Object }, "findOneFeeds": { type: Object }, "createFeeds": { type: Object }, "updateFeeds": { type: Object }, "removeFeeds": { type: Object } } }], [import("./content/controllers/content-sources.controller"), { "ContentSourceController": { "findAllContentSources": { type: Object }, "findOneContentSources": { type: Object }, "createContentSources": { type: Object }, "updateContentSources": { type: Object }, "removeContentSources": { type: Object } } }], [import("./content/controllers/tags.controller"), { "TagController": { "findAllTags": { type: Object }, "findOneTags": { type: Object }, "createTags": { type: Object }, "updateTags": { type: Object }, "removeTags": { type: Object } } }], [import("./content/controllers/news.controller"), { "NewsController": { "findAllNews": { type: Object }, "findOneNews": { type: Object }, "createNews": { type: Object }, "updateNews": { type: Object }, "removeNews": { type: Object } } }], [import("./content/controllers/news-tags.controller"), { "NewsTagController": { "findAllNewsTags": { type: Object }, "findOneNewsTags": { type: Object }, "createNewsTags": { type: Object }, "updateNewsTags": { type: Object }, "removeNewsTags": { type: Object } } }], [import("./content/controllers/content-source-visits.controller"), { "ContentSourceVisitController": { "findAllContentSourceVisits": { type: Object }, "findOneContentSourceVisits": { type: Object }, "createContentSourceVisits": { type: Object }, "updateContentSourceVisits": { type: Object }, "removeContentSourceVisits": { type: Object } } }], [import("./content/controllers/feed-sources.controller"), { "FeedSourceController": { "findAllFeedSources": { type: Object }, "findOneFeedSources": { type: Object }, "createFeedSources": { type: Object }, "updateFeedSources": { type: Object }, "removeFeedSources": { type: Object } } }], [import("./content/controllers/content.controller"), { "ContentController": { "getAllContent": {}, "findOneContents": { type: Object }, "createContents": { type: Object }, "updateContents": { type: Object }, "removeContents": { type: Object } } }], [import("./content/controllers/news-summaries.controller"), { "NewsSummaryController": { "findAllNewsSummaries": { type: Object }, "findOneNewsSummaries": { type: Object }, "createNewsSummaries": { type: Object }, "updateNewsSummaries": { type: Object }, "removeNewsSummaries": { type: Object } } }], [import("./monitoring/controllers/health.controller"), { "HealthController": { "check": { type: Object }, "options": { type: String } } }]] } };
};

================
File: src/tree.txt
================
.
 app.module.ts
 audit.log
 content
  __tests__
   categories.test.ts
   content-categories.test.ts
   content-source-visits.test.ts
   content-sources.test.ts
   content-statuses.test.ts
   content-tags.test.ts
   contents.test.ts
   embedding-reviews.test.ts
   feed-categories.test.ts
   feed-sources.test.ts
   feeds.test.ts
   news-summaries.test.ts
   news-tags.test.ts
   news.test.ts
   newsletters.test.ts
   research-embeddings.test.ts
   research.test.ts
   tags.test.ts
   utils
       sample-data.utils.ts
       test.utils.ts
  content.module.ts
  controllers
   categories.controller.ts
   content-categories.controller.ts
   content-source-visits.controller.ts
   content-sources.controller.ts
   content-statuses.controller.ts
   content-tags.controller.ts
   contents.controller.ts
   embedding-reviews.controller.ts
   feed-categories.controller.ts
   feed-sources.controller.ts
   feeds.controller.ts
   news-summaries.controller.ts
   news-tags.controller.ts
   news.controller.ts
   newsletters.controller.ts
   research-embeddings.controller.ts
   research.controller.ts
   tags.controller.ts
  dto
  index.ts
  models
   categories.model.ts
   content-categories.model.ts
   content-source-visits.model.ts
   content-sources.model.ts
   content-statuses.model.ts
   content-tags.model.ts
   contents.model.ts
   embedding-reviews.model.ts
   feed-categories.model.ts
   feed-sources.model.ts
   feeds.model.ts
   news-summaries.model.ts
   news-tags.model.ts
   news.model.ts
   newsletters.model.ts
   research-embeddings.model.ts
   research.model.ts
   tags.model.ts
  services
      categories.service.ts
      content-categories.service.ts
      content-source-visits.service.ts
      content-sources.service.ts
      content-statuses.service.ts
      content-tags.service.ts
      contents.service.ts
      embedding-reviews.service.ts
      feed-categories.service.ts
      feed-sources.service.ts
      feeds.service.ts
      news-summaries.service.ts
      news-tags.service.ts
      news.service.ts
      newsletters.service.ts
      research-embeddings.service.ts
      research.service.ts
      tags.service.ts
 core
  __tests__
   permission.guard.test.ts
   permission.service.test.ts
  base
   base.controller.ts
   base.model.ts
   base.service.ts
  config
   configuration.ts
   domain-config.ts
  core.module.ts
  decorators
   current-user.decorator.ts
   permissions.decorator.ts
   plan.decorator.ts
   roles.decorator.ts
   validate.decorator.ts
  dto
   pagination.dto.ts
  filters
   http-exception.filter.ts
  guards
   permission.guard.ts
   plan.guard.ts
   throttler.guard.ts
  index.ts
  interceptors
   logging.interceptor.ts
   pagination.interceptor.ts
  logger
   custom.logger.ts
   logger.colors.ts
   logger.module.ts
  middleware
  permission.module.ts
  pipes
   transformation.pipe.ts
   trim.pipe.ts
   type-conversion.pipe.ts
   validation.pipe.ts
  prisma.module.ts
  services
   base.service.ts
   cache.service.ts
   config.service.ts
   pagination.service.ts
   permission.service.ts
   prisma.service.ts
  types
   index.ts
   pagination.types.ts
   permission.types.ts
   plan.types.ts
  utils
      auth.utils.ts
      permission.utils.ts
 health
  health.controller.ts
 main.ts
 metadata.ts
 tree.txt
 types
     index.ts
     permissions.types.ts

25 directories, 127 files

================
File: .dockerignore
================
node_modules
dist
test
**/*.test.ts
**/*.spec.ts
**/__tests__/**
.nuxt
.env
.DS_Store # macOS
npm-debug.log
yarn-debug.log
.idea # JetBrains IDEs
.vscode # VS Code

================
File: code-style.md
================
You are a senior TypeScript programmer with experience in the NestJS framework and a preference for
clean programming and design patterns.

Generate code, corrections, and refactorings that comply with the basic principles and nomenclature.

## TypeScript General Guidelines

### Basic Principles

- Use English for all code and documentation.
- Always declare the type of each variable and function (parameters and return value).
  - Avoid using any.
  - Create necessary types.
- Use JSDoc to document public classes and methods.
- Don't leave blank lines within a function.
- One export per file.

### Nomenclature

- Use PascalCase for classes.
- Use camelCase for variables, functions, and methods.
- Use kebab-case for file and directory names.
- Use UPPERCASE for environment variables.
  - Avoid magic numbers and define constants.
- Start each function with a verb.
- Use verbs for boolean variables. Example: isLoading, hasError, canDelete, etc.
- Use complete words instead of abbreviations and correct spelling.
  - Except for standard abbreviations like API, URL, etc.
  - Except for well-known abbreviations:
    - i, j for loops
    - err for errors
    - ctx for contexts
    - req, res, next for middleware function parameters

### Functions

- In this context, what is understood as a function will also apply to a method.
- Write short functions with a single purpose. Less than 20 instructions.
- Name functions with a verb and something else.
  - If it returns a boolean, use isX or hasX, canX, etc.
  - If it doesn't return anything, use executeX or saveX, etc.
- Avoid nesting blocks by:
  - Early checks and returns.
  - Extraction to utility functions.
- Use higher-order functions (map, filter, reduce, etc.) to avoid function nesting.
  - Use arrow functions for simple functions (less than 3 instructions).
  - Use named functions for non-simple functions.
- Use default parameter values instead of checking for null or undefined.
- Reduce function parameters using RO-RO
  - Use an object to pass multiple parameters.
  - Use an object to return results.
  - Declare necessary types for input arguments and output.
- Use a single level of abstraction.

### Data

- Don't abuse primitive types and encapsulate data in composite types.
- Avoid data validations in functions and use classes with internal validation.
- Prefer immutability for data.
  - Use readonly for data that doesn't change.
  - Use as const for literals that don't change.

### Classes

- Follow SOLID principles.
- Prefer composition over inheritance.
- Declare interfaces to define contracts.
- Write small classes with a single purpose.
  - Less than 200 instructions.
  - Less than 10 public methods.
  - Less than 10 properties.

### Exceptions

- Use exceptions to handle errors you don't expect.
- If you catch an exception, it should be to:
  - Fix an expected problem.
  - Add context.
  - Otherwise, use a global handler.

### Testing

- Follow the Arrange-Act-Assert convention for tests.
- Name test variables clearly.
  - Follow the convention: inputX, mockX, actualX, expectedX, etc.
- Write unit tests for each public function.
  - Use test doubles to simulate dependencies.
    - Except for third-party dependencies that are not expensive to execute.
- Write acceptance tests for each module.
  - Follow the Given-When-Then convention.

## Specific to NestJS

### Basic Principles

- Use modular architecture
- Encapsulate the API in modules.
  - One module per main domain/route.
  - One controller for its route.
    - And other controllers for secondary routes.
  - A models folder with data types.
    - DTOs validated with class-validator for inputs.
    - Declare simple types for outputs.
  - A services module with business logic and persistence.
    - Entities with MikroORM for data persistence.
    - One service per entity.
- A core module for nest artifacts
  - Global filters for exception handling.
  - Global middlewares for request management.
  - Guards for permission management.
  - Interceptors for request management.
- A shared module for services shared between modules.
  - Utilities
  - Shared business logic

### Testing

- Use the standard Vitests framework for testing.
- Write tests for each controller and service.
- Write end to end tests for each api module.
- Add a admin/test method to each controller as a smoke test.

================
File: docker-compose.yml
================
services:
  api:
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - '3000:3000'
    environment:
      - NODE_ENV=production
      - DB_HOST=postgres
      - DB_PORT=5432
      - DB_NAME=postgres
      - DB_USER=postgres
      - DB_PASSWORD=postgres
      - DB_SCHEMA=public
      - DATABASE_URL=postgresql://postgres:postgres@postgres:5432/postgres
      - DIRECT_URL=postgresql://postgres:postgres@postgres:5432/postgres
      - SUPABASE_URL=http://supabase:54321
      - API_PREFIX=/api
      - SWAGGER_PATH=/api
      - CORS_ORIGINS=http://localhost:3000,http://localhost:3001
    volumes:
      - .:/usr/src/app
      - /usr/src/app/node_modules

================
File: Dockerfile
================
FROM node:20.19-bookworm
ENV PNPM_HOME="/pnpm"
ENV PATH="$PNPM_HOME:$PATH"
ENV NX_DAEMON=false
ENV NX_VERBOSE_LOGGING=true
ENV NX_SKIP_NX_CLOUD=true
RUN corepack enable

WORKDIR /app

ARG NX_CLOUD_ACCESS_TOKEN

ENV NX_CLOUD_ACCESS_TOKEN=${NX_CLOUD_ACCESS_TOKEN} \
    PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD=1
    

# Install required build dependencies
RUN apt-get update && \
    apt-get install -y python3 make g++ git && \
    rm -rf /var/lib/apt/lists/*

# Copy only the necessary files first
COPY package.json pnpm-lock.yaml pnpm-workspace.yaml .npmrc .nxignore tsconfig.json nx.json nest-cli.json ./
COPY apps/api ./apps/api
COPY libs ./libs
COPY shared ./shared

# Install dependencies for specific workspaces
RUN pnpm install --filter @astronera/api...

# Generate Prisma client for logger
RUN pnpm prisma:gen

# Install nx and build
RUN pnpx nx reset
RUN pnpx nx build @astronera/api --skip-nx-cache

RUN pnpm prune --production

# Set the working directory to the output
WORKDIR /app/dist/apps/api/src

# Expose port and start command
EXPOSE 8080
CMD ["node", "main.js"]

================
File: eslint.config.js
================
import baseConfig from '../../eslint.config'

export default {
  ...baseConfig,
  rules: {
    ...baseConfig.rules,
    '@typescript-eslint/consistent-type-imports': 'off',
  },
}

================
File: package.json
================
{
  "name": "@astronera/api",
  "version": "0.0.3",
  "private": true,
  "type": "commonjs",
  "engines": {
    "node": ">=22.0.0"
  },
  "scripts": {
    "build:logger": "tsx scripts/build-logger.ts"
  },
  "dependencies": {
    "@ib/logger": "workspace:*",
    "@nestjs/axios": "^3.1.3",
    "@nestjs/cache-manager": "^2.3.0",
    "@nestjs/common": "^10.0.0",
    "@nestjs/config": "^3.3.0",
    "@nestjs/core": "^10.0.0",
    "@nestjs/microservices": "^10.4.15",
    "@nestjs/platform-socket.io": "^10.4.15",
    "@nestjs/schedule": "^4.1.2",
    "@nestjs/swagger": "^7.1.17",
    "@nestjs/terminus": "^10.2.3",
    "@nestjs/throttler": "^6.3.0",
    "@nestjs/websockets": "^10.4.15",
    "@supabase/supabase-js": "^2.47.8",
    "cache-manager": "^5.7.6",
    "class-transformer": "^0.5.1",
    "class-validator": "^0.14.0",
    "compression": "^1.7.5",
    "cosmiconfig": "^9.0.0",
    "express": "^4.18.2",
    "helmet": "^8.0.0",
    "ioredis": "^5.4.2",
    "jsonwebtoken": "^9.0.2",
    "playwright": "^1.41.1",
    "rxjs": "^7.8.1",
    "socket.io": "^4.8.1",
    "tcp-port-used": "^1.0.2",
    "vite-plugin-node": "^4.0.0",
    "vite-tsconfig-paths": "^5.1.4"
  },
  "devDependencies": {
    "@nestjs/cli": "^10.0.0",
    "@nestjs/schematics": "^10.0.0",
    "@nestjs/testing": "^10.0.0",
    "@nx/node": "20.3.0",
    "@nx/workspace": "20.3.0",
    "@swc-node/register": "~1.10.9",
    "@swc/cli": "^0.5.2",
    "@swc/core": "1.10.4",
    "@types/compression": "^1.7.5",
    "@types/express": "^4.17.17",
    "@types/node": "^18.16.9",
    "@types/tcp-port-used": "^1.0.4",
    "ts-loader": "^9.5.1"
  }
}

================
File: project.json
================
{
  "name": "@astronera/api",
  "sourceRoot": "apps/api/src",
  "projectType": "application",
  "implicitDependencies": ["@ib/logger", "@ib/cache", "@astronera/db"],
  "targets": {
    "build": {
      "executor": "nx:run-commands",
      "options": {
        "commands": ["nest build api", "cp apps/api/package.json dist/apps/api/"],
        "parallel": false
      },
      "dependsOn": [
        {
          "target": "build",
          "projects": ["@ib/logger"]
        }
      ]
    },
    "serve": {
      "executor": "nx:run-commands",
      "options": {
        "command": "nest start api --watch"
      }
    },
    "serve:prod": {
      "executor": "nx:run-commands",
      "options": {
        "command": "node dist/apps/api/main.js"
      },
      "dependsOn": [
        {
          "target": "build",
          "projects": "self"
        }
      ]
    },
    "lint": {
      "executor": "nx/eslint:lint",
      "output": "{options.outputFile}"
    },
    "test": {
      "executor": "nx/jest:jest",
      "output": "{workspaceRoot}/coverage/{projectRoot}",
      "options": {
        "jestConfig": "apps/api/jest.config.ts"
      }
    }
  }
}

================
File: README.md
================
# Astronera API

A NestJS-based API service with role-based permissions, authentication, and content management
capabilities.

## Quick Links

- API Base URL: http://localhost:3000/api
- Swagger Documentation: http://localhost:3000/docs
- Database Admin: http://localhost:54321 (Supabase)

## Prerequisites

- Node.js (v20.x recommended)
- PostgreSQL (via Supabase)
- pnpm or yarn
- Docker and Docker Compose (for containerized deployment)

## Environment Setup

The application uses various environment variables for configuration. Key configurations include:

```env
# Database Configuration
DB_HOST=localhost
DB_PORT=5432
DB_NAME=postgres
DB_USER=your_user
DB_PASSWORD=your_password

# API Configuration
PORT=3000
API_PREFIX=/api
SWAGGER_PATH=/api

# Supabase Configuration
SUPABASE_URL="http://localhost:54321"
SUPABASE_SERVICE_KEY="your_service_key"
SUPABASE_ANON_KEY="your_anon_key"

# CORS Configuration
CORS_ORIGINS=http://localhost:3000,http://localhost:3001
```

## Project Structure

```
src/
 core/                   # Core functionality and shared modules
    config/            # Application configuration
    decorators/        # Custom decorators
    guards/            # Authentication and permission guards
    middleware/        # HTTP middleware
    modules/           # Core feature modules
    services/          # Shared services
    types/             # TypeScript type definitions
 content/               # Content management module
 main.ts               # Application entry point
```

## Core Modules

### Permission Module

- Handles role-based access control (RBAC)
- Manages user permissions and authorization
- Files:
  - `permission.module.ts`: Module configuration
  - `permission.service.ts`: Permission logic
  - `permission.guard.ts`: Route protection
  - `permission.decorator.ts`: Custom decorators for routes

### Domain Module

- Manages domain-specific configuration
- Handles middleware and guard setup
- Provides logging capabilities
- Files:
  - `domain-config.ts`: Domain configuration

### Content Module

- Manages various content types (news, articles, research)
- Handles content categorization and tagging
- Provides content search and filtering

## Key Features

- Role-based access control
- JWT Authentication via Supabase
- Content management system
- API documentation with Swagger
- Database integration with Prisma
- Custom logging system
- CORS configuration
- Environment-based configuration
- Docker containerization

## File Types

- `.ts`: TypeScript source files
- `.env`: Environment configuration
- `.json`: Configuration files (package.json, tsconfig.json)
- `.md`: Documentation files
- `.prisma`: Database schema definition
- `Dockerfile`: Container configuration
- `docker-compose.yml`: Multi-container Docker configuration

## Getting Started

### Local Development

1. Clone the repository
2. Install dependencies:
   ```bash
   pnpm install
   ```
3. Set up environment variables:
   ```bash
   cp .env.example .env
   ```
4. Start the development server:
   ```bash
   pnpm run dev
   ```

### Docker Deployment

1. Build and start the containers:

   ```bash
   docker-compose up -d --build
   ```

2. Stop the containers:

   ```bash
   docker-compose down
   ```

3. View logs:

   ```bash
   docker-compose logs -f api
   ```

4. Access the services:
   - API: http://localhost:3000
   - Swagger: http://localhost:3000/docs
   - Supabase: http://localhost:54321
   - PostgreSQL: localhost:5432

### Docker Commands

```bash
# Build the API image
docker build -t astronera-api .

# Manually update prisma from api dir
dotenv -e ../../.env -- npx prisma db pull
dotenv -e ../../.env -- npx prisma generate

# View container logs
docker-compose logs -f [service_name]

# Restart a service
docker-compose restart [service_name]

# Remove all containers and volumes
docker-compose down -v
```

## API Documentation

The API documentation is available through Swagger UI at http://localhost:3000/docs. This provides:

- Detailed endpoint documentation
- Request/response schemas
- Testing interface
- Authentication information

## Development Tools

- **NestJS**: Main framework
- **Prisma**: Database ORM
- **Supabase**: Authentication and database
- **Swagger**: API documentation
- **TypeScript**: Programming language
- **ESLint/Prettier**: Code formatting and linting
- **Docker**: Containerization
- **Docker Compose**: Container orchestration

## Testing

```bash
# Unit tests
npm run test

# E2E tests
npm run test:e2e

# Test coverage
npm run test:cov
```

## Contributing

1. Create a feature branch
2. Make your changes
3. Write/update tests
4. Submit a pull request

## License

[MIT License](LICENSE)

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "baseUrl": ".",
    "outDir": "../../dist/apps/api/src",
    "rootDir": "./src",
    "module": "CommonJS",
    "moduleResolution": "node",
    "target": "ES2022",
    "lib": ["ES2022"],
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,
    "forceConsistentCasingInFileNames": true,
    "strict": true,
    "resolveJsonModule": true,
    "declaration": true,
    "noImplicitAny": false,
    "removeComments": true,
    "skipLibCheck": true,
    "noLib": false,
    "strictNullChecks": false,
    "paths": {
      "@types": ["./src/types"],
      "@core": ["./src/core"],
      "@core/*": ["./src/core/*"],
      "@jobs": ["./src/jobs"],
      "@monitoring": ["./src/monitoring"],
      "@payments": ["./src/payments"],
      "@content": ["./src/content"],
      "@content/*": ["./src/content/*"],
      "@jobs/*": ["./src/jobs/*"],
      "@engagement/*": ["./src/engagement/*"],
      "@monitoring/*": ["./src/monitoring/*"],
      "@payments/*": ["./src/payments/*"],
      "@astronera/db": ["./node_modules/@astronera/db/dist/types"]
    }
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "test", "**/*.test.ts", "**/*.spec.ts", "dist"]
}

================
File: vitest.config.ts
================
import { defineConfig } from 'vitest/config.js'

export default defineConfig({
  test: {
    globals: true,
    setupFiles: ['./vitest.setup.ts'],
    environment: 'node',
    coverage: {
      provider: 'v8',
      reporter: ['text', 'json', 'html'],
    },
    alias: {
      '@core': '/src/core',
      '@content': '/src/content',
      '@auth': '/src/auth',
    },
  },
})

================
File: vitest.setup.ts
================
import { vi } from 'vitest'
import { mockDeep, mockReset } from 'vitest-mock-extended'
import type { PrismaClient } from '@astronera/db'

vi.mock('@astronera/db', () => ({
  PrismaClient: vi.fn(() => mockDeep<PrismaClient>()),
}))

beforeEach(() => {
  mockReset(prismaMock)
})

export const prismaMock = mockDeep<PrismaClient>()
