import fs from 'fs/promises'
import path from 'path'
import { calculateSupabaseCosts } from './storage'
import { calculateAiCost, COST_CONFIG } from './gpt'
import { calculateDigitalOceanCost } from './digital-ocean'
import { calculateLogsCost, type LoggingResult } from './logging'
import { calculateDevopsCosts } from './dev-ops'
import { calculateEmployeeCost } from './employee'
import { calculateSubscriptionCosts, type SoftwareCosts } from './software'
import { calculateOfficeCosts } from './office'
import { calculateInitialLoan, calculateRemainingBalance } from './capital'
import { calculateRevenue, INCOME_STREAMS } from './customers'
import { calculateAllMetrics } from './metrics'
import { generateInfo } from './gen-info'
import { calculateCostPerUser } from './metrics-users'
import { calculateMarketingCost } from './marketing'
import { simulateRealWorldPurchases, type TransactionDetails } from './payments'
import { calculateAnalyticsCost, type AnalyticsResult } from './analytics'

import type { AllMetrics } from './metrics'
import type { CapitalResult, LoanResult } from './capital'
import type { StorageCostResult } from './storage'
import type { DigitalOceanResult } from './digital-ocean'
import type { DevopsResult } from './dev-ops'
import type { OfficeResult } from './office'
import type { EmployeeResult } from './employee'
import type { AiCostResult } from './gpt'
import type { RevenueResult } from './customers'
import type { InfoResult } from './gen-info'

import {
  EFFICIENCY_FACTOR,
  CHURN_TO_LIFESPAN_MONTHS,
  WORDS_TO_CHAR_CHUNKS,
  WORDS_TO_CHARS,
} from './helpers'

// set hard limits for devops usage

// we should cap free users usage wherever possible, removing any paid services if possible.

// Consider capping the total number of free users for different stages, eg Alpha, Beta, etc.

// only run this function once, use a button to trigger it

// extract configs where possible, should be easy to update in one place

// Try to narrow down the margin per user, how many free users will be paid users allow.
// This can be used to create our minimum conversion threshold

// include daily active users, this can be used to narrow down the difference between highly active users and slightly active users.

// incorporate discounts / promotions for free use of paid products, trials etc.
// Calculate revenue per user in each tier, for example free / pro / expert. free will still generate revenue through ads, etc.

// estimate Customer Acquisition Cost (CAC): Cost to acquire a new paying user. (use cost based on employee, software and average)
// estimate Customer Lifetime Value (CLV): Revenue generated by a user over their lifetime. (need to research averages)
// We need to factor in a payment gateway and any associated costs
// Mailchimp or some other email marketing platform should be considered
// Email automation for supabase signups, sendgrid is what we use (I think)
// switch to Cloudflare for the CDN, this will save vs Vercel
// Sentry for error tracking, may not need if we can use BetterStack
// Break-even Point try to calculate this exactly, so we can display on a chart
// seperate expenses into Fixed Costs, Variable Costs, Infrastructure, Third-Party Service, Support

// STILL TO FIX
// Razorpay is only showing transactions to the 21st month
// input and output cost for GPT is the same??

export type CompanyStage = 'start' | 'growth' | 'scaling' | 'secure'
export type Content = 'NEWS' | 'RESEARCH_ABSTRACTS' | 'RESEARCH_PAPERS' | 'JOBS' | 'COMPANIES'
export type StageConfig = Record<Content, ProcessdContentConfig>

export type ContentScalingRules = {
  [key in Content]: {
    totalContentStored: number
    totalVectorStored: number
    sourceGrowthRate: number // Growth rate for sources
    additionsGrowthRate: number // Growth rate for per source additions
    monthlyProcessingGrowthRate: number // Growth rate for monthly processed items
  }
}

function scaleContentConfig(
  CONTENT_CONFIG: StageConfig,
  currentMonth: number,
  rules: ContentScalingRules,
): StageConfig {
  const scaledConfig: StageConfig = JSON.parse(JSON.stringify(CONTENT_CONFIG)) // Deep copy to avoid mutations

  for (const contentType in scaledConfig) {
    const content = scaledConfig[contentType as keyof StageConfig]
    const rule = rules[contentType as Content]

    // Calculate scaling factors for the month
    const sourceFactor = 1 + rule.sourceGrowthRate * currentMonth
    const additionsFactor = 1 + rule.additionsGrowthRate * currentMonth
    const monthlyProcessingFactor = 1 + rule.monthlyProcessingGrowthRate * currentMonth

    // console.log('Scaling Factors:', sourceFactor, additionsFactor, monthlyProcessingFactor)

    if (currentMonth === 1) {
      // Initialize totals for the first month
      rule.totalVectorStored = content.PROCESSED
      rule.totalContentStored = content.TOTAL
    }

    // Scale the sources and per source additions
    content.SOURCES = Math.ceil(content.SOURCES * sourceFactor)
    content.PER_SOURCE_ADDITIONS = Math.ceil(content.PER_SOURCE_ADDITIONS * additionsFactor)

    // Calculate new content added and processed this month
    const newContentAdded = content.SOURCES * content.PER_SOURCE_ADDITIONS
    const newContentProcessed = Math.ceil(content.PROCESSED_MONTHLY * monthlyProcessingFactor)

    // Update total content and vectors stored
    rule.totalContentStored += newContentAdded
    rule.totalVectorStored += newContentProcessed

    // Update the content configuration
    content.PROCESSED_MONTHLY = newContentProcessed
    content.PROCESSED = rule.totalVectorStored
    content.TOTAL = rule.totalContentStored
  }

  console.log('Scaled Content Config for Month:', currentMonth, scaledConfig)
  return scaledConfig
}

function determineCompanyStage(mau: number): CompanyStage {
  if (mau < 10000) return 'start'
  if (mau < 100000) return 'growth'
  if (mau < 500000) return 'scaling'
  return 'secure'
}

interface Growth {
  mau: {
    total: number
    new: number
    existing: number
    churned: number
  }
  revenue: RevenueResult
}

interface AllCost {
  totals: {
    monthlyINR: number
    employees: number
    office: number
    storage: number
    digitalOcean: number
    logging: number
    devOps: number
    openAI: number
    loan: number
    analytics: number
    marketing: number
    software: number
    payments: number
  }
  employees: EmployeeResult
  office: OfficeResult
  storage: StorageCostResult
  digitalOcean: DigitalOceanResult
  logging: LoggingResult
  devOps: DevopsResult
  openAI: AiCostResult
  loan: LoanResult
  analytics: AnalyticsResult
  software: SoftwareCosts
  payments: TransactionDetails
}

export type ContentParams = {
  CONTENT_TYPE: Content
  TOTAL: number
  PROCESSED: number
  CHARS: {
    CONTENT: number
    CHUNKS: number
    PROMPT: number
    OUTPUT: number
  }
}

const AVG_MAU_USAGE = 0.01

export interface AllData {
  mau: any[]
  customers: any[]
  capital: CapitalResult[]
  revenue: RevenueResult[]
  affiliate: any[]
  advertising: any[]
  promotion: any[]
  totals: any[]
  employees: any[]
  office: any[]
  storage: any[]
  digitalOcean: any[]
  logging: any[]
  analytics: any[]
  software: SoftwareCosts[]
  devOps: any[]
  payments: any[]
  openAI: any[]
  metrics: AllMetrics[]
  months: number[]
  stages: CompanyStage[]
}

export function calculateBusinessMetrics(params: BusinessMetricsConfig): AllData {
  const allData: AllData = {
    mau: [],
    customers: [],
    capital: [],
    revenue: [],
    affiliate: [],
    advertising: [],
    promotion: [],
    totals: [],
    employees: [],
    office: [],
    storage: [],
    digitalOcean: [],
    logging: [],
    analytics: [],
    devOps: [],
    software: [],
    payments: [],
    openAI: [],
    metrics: [],
    months: [],
    stages: [],
  }

  let previousMonth = {
    revenue: 0,
    effectiveRevenue: 0,
    expenses: 0,
    balance: 0,
    mau: {
      total: 0,
      new: 0,
      churned: 0,
      churnRate: 0,
    },
    customers: {
      all: 0,
      pro: 0,
      expert: 0,
    },
  }

  for (let month = 1; month <= params.PROJECTION.MONTHS; month++) {
    const marketingCost = calculateMarketingCost({
      mrr: previousMonth.revenue,
      percentage: params.MRR_MARKETING_PERCENTAGE_SPEND,
    })

    const scaledContentConfig = scaleContentConfig(
      params.CONTENT_CONFIG,
      month,
      params.SCALING_RULES,
    )

    // Calculate new MAU
    let mau = Math.ceil(
      previousMonth.mau.total * (1 + params.PROJECTION.MONTHLY_GROWTH_RATE) +
      params.PROJECTION.MANUAL_GROWTH_RATE * month,
    )

    const churnedMAU = Math.ceil(previousMonth.mau.total * previousMonth.mau.churnRate)
    const newMAU = mau - (previousMonth.mau.total - churnedMAU)
    mau -= churnedMAU

    const companyStage = determineCompanyStage(previousMonth.mau.total)

    const revenue = calculateRevenue({
      mau: {
        total: mau,
        new: newMAU,
      },
      customers: {
        pro: previousMonth.customers.pro,
        expert: previousMonth.customers.expert,
      },
    })

    const payments = simulateRealWorldPurchases({
      newCustomers: {
        pro: revenue.customers.pro.new,
        expert: revenue.customers.expert.new,
      },
      frequency: 'Monthly',
    })

    const logging = calculateLogsCost({
      MAU: mau,
      avgMauUsage: AVG_MAU_USAGE,
      month,
      teamMembers: 1,
    })
    const devOps = calculateDevopsCosts(mau)
    const openAI = calculateAiCost({
      mau,
      customers: {
        pro: revenue.customers.pro.count,
        expert: revenue.customers.expert.count,
      },
      isBatch: false,
      CONTENT_CONFIG: scaledContentConfig,
    })

    const contentParams = Object.entries(scaledContentConfig).map(
      ([contentType, contentConfig]) => ({
        CONTENT_TYPE: contentType as Content,
        CHARS: contentConfig.CHARS,
        TOTAL: contentConfig.TOTAL,
        PROCESSED: contentConfig.PROCESSED,
      }),
    )
    const supabase = calculateSupabaseCosts(mau, month, contentParams)

    const analytics = calculateAnalyticsCost({
      MAU: mau,
      month,
      avgMauUsage: 300,
    })

    const employees = calculateEmployeeCost({
      mau,
      stage: companyStage,
      month: month,
      bootstrapMonths: params.BOOTSTRAP_MONTHS,
    })

    const office = calculateOfficeCosts(employees.totalCount)
    const digitalOcean = calculateDigitalOceanCost({ bandwidthGB: supabase.storage.data.total * 2 })
    const devOpsCost = mau > 100_000 ? devOps.inhouse.cost.total : devOps.vercel.cost.total
    const software = calculateSubscriptionCosts(employees.totalCount)

    const userExpenses =
      supabase.totalCost +
      digitalOcean.cost +
      logging.total +
      devOpsCost +
      analytics.total +
      marketingCost

    const monthlyExpenses =
      employees.totalCost +
      supabase.totalCost +
      devOpsCost +
      digitalOcean.cost +
      logging.total +
      openAI.cost.total +
      office.total +
      analytics.total +
      software.totalCost +
      marketingCost +
      payments.totalCost

    console.log('Monthly Expenses:', {
      employees: employees.totalCost,
      supabase: supabase.totalCost,
      devOps: devOpsCost,
      digitalOcean: digitalOcean.cost,
      logging: logging.total,
      openAI: openAI.cost.total,
      office: office.total,
      analytics: analytics.total,
      software: software.totalCost,
      marketing: marketingCost,
      payments: payments.totalCost,
    })

    const totalCustomers = revenue.customers.pro.count + revenue.customers.expert.count
    const metrics = calculateAllMetrics({
      marketing: {
        cost: marketingCost,
        leads: 0,
      },
      currentMonth: month,
      expenses: {
        total: monthlyExpenses,
        free: userExpenses + openAI.chat.free.cost.total,
        pro: userExpenses + openAI.chat.pro.cost.total,
        expert: userExpenses + openAI.chat.expert.cost.total,
      },
      revenue: {
        free: revenue.total.free,
        pro: revenue.customers.pro.revenue,
        expert: revenue.customers.expert.revenue,
      },
      users: {
        mau,
        free: mau - totalCustomers,
        pro: revenue.customers.pro.count,
        expert: revenue.customers.expert.count,
        totalCustomers: totalCustomers,
        new: newMAU,
        newCustomers: revenue.customers.pro.new + revenue.customers.expert.new,
      },
    })

    const capital = calculateRemainingBalance({
      loan: params.LOAN,
      month,
      initialCapital: params.INITIAL_CAPITAL,
      bootstrapMonths: params.BOOTSTRAP_MONTHS,
      expenses: monthlyExpenses,
      income: metrics.monthlyRecurringRevenue.effective,
    })

    allData.totals.push({
      expenses: {
        total: parseInt(monthlyExpenses.toFixed(0)),
      },
      income: {
        total: revenue.total.revenue,
        effective: metrics.monthlyRecurringRevenue.effective,
      },
      employees: employees.totalCost,
      office: office.total,
      storage: supabase.totalCost,
      digitalOcean: digitalOcean.cost,
      logging: logging.total,
      devOps: devOpsCost,
      openAI: openAI.cost.total,
      loan: capital.loan.monthlyInterestOnlyPayment,
      analytics: analytics.total,
      marketing: marketingCost,
      software: software.totalCost,
      payments: payments.totalCost,
    })
    allData.metrics.push(metrics)
    allData.employees.push(employees)
    allData.office.push(office)
    allData.storage.push(supabase)
    allData.digitalOcean.push(digitalOcean)
    allData.logging.push(logging)
    allData.devOps.push(devOps)
    allData.openAI.push(openAI)
    allData.capital.push(capital)
    allData.analytics.push(analytics)
    allData.software.push(software)
    allData.payments.push(payments)
    allData.revenue.push(revenue)
    allData.customers.push(revenue.customers)
    allData.months.push(month)
    allData.stages.push(companyStage)

    previousMonth = {
      revenue: metrics.monthlyRecurringRevenue.effective,
      effectiveRevenue: metrics.monthlyRecurringRevenue.effective,
      expenses: monthlyExpenses,
      balance: capital.balance.end,
      mau: {
        total: mau,
        new: newMAU,
        churned: churnedMAU,
        churnRate: metrics.churn.free.rate,
      },
      customers: {
        all: totalCustomers,
        pro: revenue.customers.pro.count,
        expert: revenue.customers.expert.count,
      },
    }
  }

  return allData
}

type ScalingRules = {
  [key in Content]: {
    totalContentStored: number
    totalVectorStored: number
    sourceGrowthRate: number
    additionsGrowthRate: number
    monthlyProcessingGrowthRate: number
  }
}

type BusinessMetricsConfig = {
  BOOTSTRAP_MONTHS: number
  INITIAL_CAPITAL: number
  MRR_MARKETING_PERCENTAGE_SPEND: number
  MONTHLY_CHURN: {
    MAU: {
      PESSIMISTIC: number
      OPTIMISTIC: number
    }
    CUSTOMERS: {
      PESSIMISTIC: number
      OPTIMISTIC: number
    }
  }
  CURRENT: {
    MAU: number
    USD_TO_INR: number
    EXPENSES: number
    REVENUE: number
  }
  LOAN: {
    AMOUNT: number
    ANNUAL_INTEREST_RATE: number
    TERM_IN_YEARS: number
  }
  PROJECTION: {
    MONTHS: number
    MONTHLY_GROWTH_RATE: number
    MANUAL_GROWTH_RATE: number
    USAGE_HOURS_PER_DAY: number
    USAGE_GROWTH_FACTOR: number
    MAX_DAILY_USAGE: number
  }
  DEVOPS_USAGE: {
    DATA_TRANSFER_GB: number
    ORIGIN_TRANSFER_GB: number
    EDGE_REQUESTS: number
    MIDDLEWARE_INVOCATIONS: number
    SOURCE_IMAGES: number
    FUNCTION_INVOCATIONS: number
    FUNCTION_DURATION_GB_HOURS: number
    EDGE_FUNCTION_EXECUTIONS: number
    DATA_CACHE_READS: number
    DATA_CACHE_WRITES: number
    EDGE_CONFIG_READS: number
    EDGE_CONFIG_WRITES: number
    MONITORING_EVENTS: number
    SPEED_INSIGHTS_DATA_POINTS: number
    WEB_ANALYTICS_EVENTS: number
  }
  CONTENT_CONFIG: {
    NEWS: ProcessdContentConfig
    // RESEARCH_ABSTRACTS: ProcessdContentConfig
    // RESEARCH_PAPERS: ProcessdContentConfig
    COMPANIES: ProcessdContentConfig
    JOBS: ProcessdContentConfig
  }
  SCALING_RULES: ScalingRules
}

export type ProcessdContentConfig = {
  PROCESSED: number
  TOTAL: number
  SOURCES: number
  PER_SOURCE_ADDITIONS: number
  PROCESSED_MONTHLY: number
  CHARS: {
    CONTENT: number
    CHUNKS: number
    PROMPT: number
    OUTPUT: number
  }
}

export const metricConfig = {
  BOOTSTRAP_MONTHS: 12,
  INITIAL_CAPITAL: 1_40_000,
  MRR_MARKETING_PERCENTAGE_SPEND: 0.1,
  MONTHLY_CHURN: {
    MAU: {
      PESSIMISTIC: 0.1,
      OPTIMISTIC: 0.05,
    },
    PRO: {
      PESSIMISTIC: 0.1,
      OPTIMISTIC: 0.04,
    },
    EXPERT: {
      PESSIMISTIC: 0.09,
      OPTIMISTIC: 0.04,
    },
  },
  CURRENT: {
    MAU: 100,
    USD_TO_INR: 83.4,
    REVENUE: 0,
  },
  LOAN: {
    AMOUNT: 10_00_000,
    ANNUAL_INTEREST_RATE: 0.0,
    TERM_IN_YEARS: 2,
    GRACE_PERIOD: 7,
  },
  PROJECTION: {
    MONTHS: 12,
    MONTHLY_GROWTH_RATE: 0.2,
    MANUAL_GROWTH_RATE: 100,
    USAGE_HOURS_PER_DAY: 0.1,
    USAGE_GROWTH_FACTOR: 0.1,
    MAX_DAILY_USAGE: 1.5,
  },
  DEVOPS_USAGE: {
    DATA_TRANSFER_GB: 0.015,
    ORIGIN_TRANSFER_GB: 0.001,
    EDGE_REQUESTS: 150,
    MIDDLEWARE_INVOCATIONS: 75,
    SOURCE_IMAGES: 0,
    FUNCTION_INVOCATIONS: 75,
    FUNCTION_DURATION_GB_HOURS: 0.08,
    EDGE_FUNCTION_EXECUTIONS: 75,
    DATA_CACHE_READS: 800,
    DATA_CACHE_WRITES: 75,
    EDGE_CONFIG_READS: 50,
    EDGE_CONFIG_WRITES: 0.1,
    MONITORING_EVENTS: 0,
    SPEED_INSIGHTS_DATA_POINTS: 0,
    WEB_ANALYTICS_EVENTS: 0,
  },
  CONTENT_CONFIG: {
    NEWS: {
      PROCESSED: 0,
      TOTAL: 120_000,
      SOURCES: 15,
      PER_SOURCE_ADDITIONS: 30,
      PROCESSED_MONTHLY: 2_000,
      CHARS: {
        CONTENT: WORDS_TO_CHARS(1000),
        CHUNKS: WORDS_TO_CHAR_CHUNKS(1000),
        PROMPT: WORDS_TO_CHARS(100),
        OUTPUT: WORDS_TO_CHARS(240),
      },
    },
    // RESEARCH_ABSTRACTS: {
    //   PROCESSED: 0,
    //   TOTAL: 2_400_000,
    //   SOURCES: 2,
    //   PER_SOURCE_ADDITIONS: 1_300,
    //   PROCESSED_MONTHLY: 10_000,
    //   CHARS: {
    //     CONTENT: WORDS_TO_CHARS(280),
    //     CHUNKS: WORDS_TO_CHAR_CHUNKS(280),
    //     PROMPT: WORDS_TO_CHARS(50),
    //     OUTPUT: WORDS_TO_CHARS(60)
    //   }
    // },
    // RESEARCH_PAPERS: {
    //   PROCESSED: 0,
    //   TOTAL: 1000,
    //   SOURCES: 2,
    //   PER_SOURCE_ADDITIONS: 10_000,
    //   PROCESSED_MONTHLY: 10_000,
    //   CHARS: {
    //     CONTENT: WORDS_TO_CHARS(10_000),
    //     CHUNKS: WORDS_TO_CHAR_CHUNKS(10_000),
    //     PROMPT: WORDS_TO_CHARS(100),
    //     OUTPUT: WORDS_TO_CHARS(400)
    //   }
    // },
    COMPANIES: {
      PROCESSED: 0,
      TOTAL: 4_500,
      SOURCES: 1,
      PER_SOURCE_ADDITIONS: 150,
      PROCESSED_MONTHLY: 500,
      CHARS: {
        CONTENT: WORDS_TO_CHARS(20_000),
        CHUNKS: WORDS_TO_CHAR_CHUNKS(20_000),
        PROMPT: WORDS_TO_CHARS(200),
        OUTPUT: WORDS_TO_CHARS(1_000),
      },
    },
    JOBS: {
      PROCESSED: 0,
      TOTAL: 3_000,
      SOURCES: 5,
      PER_SOURCE_ADDITIONS: 30,
      PROCESSED_MONTHLY: 2_000,
      CHARS: {
        CONTENT: WORDS_TO_CHARS(1_000),
        CHUNKS: WORDS_TO_CHAR_CHUNKS(1_000),
        PROMPT: WORDS_TO_CHARS(120),
        OUTPUT: WORDS_TO_CHARS(100),
      },
    },
  },
  SCALING_RULES: {
    // 0.1 = 10%
    NEWS: {
      totalContentStored: 0,
      totalVectorStored: 0,
      sourceGrowthRate: 0.15,
      additionsGrowthRate: 0.15,
      monthlyProcessingGrowthRate: 0.1,
    },
    // RESEARCH_ABSTRACTS: {
    //   totalContentStored: 0,
    //   totalVectorStored: 0,
    //   sourceGrowthRate: 0.02,
    //   additionsGrowthRate: 0.02,
    //   monthlyProcessingGrowthRate: 0.07
    // },
    // RESEARCH_PAPERS: {
    //   totalContentStored: 0,
    //   totalVectorStored: 0,
    //   sourceGrowthRate: 0.01,
    //   additionsGrowthRate: 0.01,
    //   monthlyProcessingGrowthRate: 0.02
    // },
    COMPANIES: {
      totalContentStored: 0,
      totalVectorStored: 0,
      sourceGrowthRate: 0.005,
      additionsGrowthRate: 0.06,
      monthlyProcessingGrowthRate: 0.05,
    },
    JOBS: {
      totalContentStored: 0,
      totalVectorStored: 0,
      sourceGrowthRate: 0.05,
      additionsGrowthRate: 0.1,
      monthlyProcessingGrowthRate: 0.05,
    },
  },
}

export async function generateBusinessMetrics() {
  const data = calculateBusinessMetrics(metricConfig)

  try {
    // Ensure the directory exists
    await fs.mkdir(path.dirname('./assets/business-financials.json'), { recursive: true })

    // Write the data to a JSON file
    await fs.writeFile('./financials/business-financials.json', JSON.stringify(data, null, 2))
    console.log('Business metrics data has been written to business-metrics.json')
  } catch (error) {
    console.error('Error writing business metrics data to file:', error)
  }
}

// Only run this when called directly
if (require.main === module) {
  generateBusinessMetrics()
}
