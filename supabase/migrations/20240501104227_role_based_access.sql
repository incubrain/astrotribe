CREATE TRIGGER create_user_profile AFTER INSERT ON auth.users FOR EACH ROW EXECUTE FUNCTION create_user_profile();


create type "public"."app_plan_enum" as enum ('free', 'basic', 'intermediate', 'premium', 'enterprise', 'custom');

create type "public"."app_role_enum" as enum ('guest', 'user', 'astroguide', 'mentor', 'moderator', 'tenant_member', 'tenant_admin', 'tenant_super_admin', 'admin', 'super_admin');

create type "public"."user_status" as enum ('ONLINE', 'OFFLINE');

drop policy "Enable read access for all users" on "public"."addresses";

drop policy "Enable read access for all users" on "public"."categories";

drop policy "Enable read access for all users" on "public"."cities";

drop policy "Enable read access for all users" on "public"."companies";

drop policy "Enable read access for all users" on "public"."company_employees";

drop policy "Enable read access for all users" on "public"."company_news";

drop policy "Enable read access for all users" on "public"."contacts";

drop policy "Enable read access for all users" on "public"."countries";

drop policy "Enable read access for all users" on "public"."embeddings";

drop policy "Enable delete for users based on user_id" on "public"."feedbacks";

drop policy "Enable insert for authenticated users only" on "public"."feedbacks";

drop policy "Enable read access for all users" on "public"."feedbacks";

drop policy "Enable update for users based on user_id" on "public"."feedbacks";

drop policy "Enable read access for all users" on "public"."news";

drop policy "enable all for service role" on "public"."news";

drop policy "Enable read access for all users" on "public"."news_embeddings";

drop policy "Enable read access for all users" on "public"."news_tags";

drop policy "Enable read access for all users" on "public"."research";

drop policy "service_role_all_permissions" on "public"."research";

drop policy "Enable insert for authenticated users only" on "public"."responses";

drop policy "Enable read access for all users" on "public"."responses";

drop policy "Enable read access for all users" on "public"."roles";

drop policy "Enable insert for authenticated users only" on "public"."searches";

drop policy "Enable read access for all users" on "public"."searches";

drop policy "Enable read access for all users" on "public"."social_media";

drop policy "Enable read access for all users" on "public"."tags";

drop policy "Enable read access for all users" on "public"."user_followers";

drop policy "Enable read access for all users" on "public"."user_profiles";

drop policy "Enable update for users based on email" on "public"."user_profiles";

revoke select on table "public"."roles" from PUBLIC;

revoke select on table "public"."roles" from "anon";

revoke insert on table "public"."roles" from "service_role";

revoke select on table "public"."roles" from "service_role";

revoke update on table "public"."roles" from "service_role";

alter table "public"."user_profiles" drop constraint "public_user_profiles_role_id_fkey";

alter table "public"."roles" drop constraint "roles_pkey";

drop index if exists "public"."roles_pkey";

drop index if exists "public"."roles_title_key";

drop table "public"."roles";

alter type "public"."address_type" rename to "address_type__old_version_to_be_dropped";

create type "public"."address_type" as enum ('residential', 'headquarters', 'office', 'factory', 'lab', 'warehouse', 'research', 'retail', 'showroom', 'branch');

alter type "public"."news_relation_type" rename to "news_relation_type__old_version_to_be_dropped";

create type "public"."news_relation_type" as enum ('source', 'topic', 'mention');

create table "public"."plan_permissions" (
    "id" integer generated by default as identity not null,
    "plan" app_plan_enum not null,
    "feature" character varying not null
);


alter table "public"."plan_permissions" enable row level security;

create table "public"."role_permissions" (
    "id" integer generated by default as identity not null,
    "role" app_role_enum not null,
    "select" boolean default false,
    "insert" boolean default false,
    "update" boolean default false,
    "delete" boolean default false,
    "table_name" character varying not null
);


alter table "public"."role_permissions" enable row level security;

alter table "public"."addresses" alter column address_type type "public"."address_type" using address_type::text::"public"."address_type";

alter table "public"."company_news" alter column relation_type type "public"."news_relation_type" using relation_type::text::"public"."news_relation_type";

drop type "public"."address_type__old_version_to_be_dropped";

drop type "public"."news_relation_type__old_version_to_be_dropped";

alter table "public"."user_profiles" drop column "role_id";

alter table "public"."user_profiles" add column "plan" app_plan_enum default 'free'::app_plan_enum;

alter table "public"."user_profiles" add column "role" app_role_enum not null default 'user'::app_role_enum;

drop sequence if exists "public"."roles_id_seq";

CREATE UNIQUE INDEX role_permission_unique ON public.role_permissions USING btree (role, table_name);

CREATE UNIQUE INDEX role_permissions_pkey ON public.role_permissions USING btree (id);

alter table "public"."role_permissions" add constraint "role_permissions_pkey" PRIMARY KEY using index "role_permissions_pkey";

alter table "public"."role_permissions" add constraint "role_permission_unique" UNIQUE using index "role_permission_unique";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.add_authorize_rls_policies()
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
    table_info RECORD;
BEGIN
    FOR table_info IN SELECT tablename FROM pg_tables WHERE schemaname = 'public'
    LOOP
        -- Enable RLS on the table if not already enabled
        EXECUTE format('ALTER TABLE %I.%I ENABLE ROW LEVEL SECURITY', 'public', table_info.tablename);

        -- Create or replace policies for INSERT
        EXECUTE format('CREATE POLICY insert_policy ON %I.%I FOR INSERT WITH CHECK (authorize(%L))', 
            'public', table_info.tablename, table_info.tablename || '.insert');

        -- Create or replace policies for UPDATE
        EXECUTE format('CREATE POLICY update_policy ON %I.%I FOR UPDATE USING (authorize(%L))', 
            'public', table_info.tablename, table_info.tablename || '.update');

        -- Create or replace policies for DELETE
        EXECUTE format('CREATE POLICY delete_policy ON %I.%I FOR DELETE USING (authorize(%L))', 
            'public', table_info.tablename, table_info.tablename || '.delete');
    END LOOP;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.assign_default_role()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    -- Insert the default role into user_roles
    INSERT INTO public.user_roles (user_id, role)
    VALUES (NEW.id, 'user');

    -- Return the new row to finish the trigger
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.assign_role_permissions_from_config(json_config json)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
    config_element json;
    table_exists boolean;
BEGIN
    FOR config_element IN SELECT * FROM json_array_elements(json_config)
    LOOP
        -- Check if the table exists in the public schema
        SELECT EXISTS (
            SELECT 1 FROM information_schema.tables
            WHERE table_schema = 'public'
              AND table_name = config_element->>'table_name'
        ) INTO table_exists;

        IF table_exists THEN
            INSERT INTO role_permissions ("role", "table_name", "select", "insert", "update", "delete")
            VALUES (
                (config_element->>'role')::app_role_enum, 
                config_element->>'table_name', 
                (config_element->>'select')::boolean, 
                (config_element->>'insert')::boolean, 
                (config_element->>'update')::boolean, 
                (config_element->>'delete')::boolean
            )
            ON CONFLICT ON CONSTRAINT role_permission_unique DO UPDATE 
            SET 
                "select" = EXCLUDED."select",
                "insert" = EXCLUDED."insert",
                "update" = EXCLUDED."update",
                "delete" = EXCLUDED."delete";
        ELSE
            RAISE NOTICE 'Table "%" does not exist in the public schema.', config_element->>'table_name';
        END IF;
    END LOOP;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.authorize(requested_permission text)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
    user_role public.app_role_enum;
    v_table_name text;
    operation text;
    full_jwt json; -- Variable to store the entire JWT object for logging
BEGIN
    full_jwt := auth.jwt(); -- Get the full JWT object
    RAISE LOG 'JWT Object: %', full_jwt; -- Log the entire JWT object

    user_role := ((auth.jwt() -> 'app_metadata') ->> 'user_role')::public.app_role_enum;

    -- Check if user_role is present and valid
    IF user_role IS NULL THEN
        RAISE EXCEPTION 'No user role found in JWT';
    END IF;

    RAISE LOG 'Starting authorization check for user role: %', user_role;

    -- Immediately grant access if the user's role is super_admin
    IF user_role = 'super_admin' THEN
        RAISE LOG 'Super admin detected. Granting access.';
        RETURN TRUE;
    END IF;

    -- Parse requested_permission into table_name and operation
    v_table_name := split_part(requested_permission, '.', 1);
    operation := split_part(requested_permission, '.', 2);

    RAISE LOG 'Requested permission involves table: % and operation: %', v_table_name, operation;

    -- Check permissions for other roles based on the operation
    RETURN EXISTS (
        SELECT 1
        FROM public.role_permissions
        WHERE role = user_role
          AND table_name = v_table_name
          AND ((operation = 'select' AND role_permissions.select)
            OR (operation = 'insert' AND role_permissions.insert)
            OR (operation = 'update' AND role_permissions.update)
            OR (operation = 'delete' AND role_permissions.delete))
    );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.custom_access_token_hook(event jsonb)
 RETURNS jsonb
 LANGUAGE plpgsql
 STABLE
AS $function$
DECLARE
    claims jsonb;
    input_user_id uuid;
    user_role public.app_role_enum;
    user_plan public.app_plan_enum;
BEGIN
    input_user_id := (event->>'user_id')::uuid;
    RAISE LOG 'custom_access_token_hook event user_id: %', input_user_id;
    RAISE LOG 'custom_access_token_hook event event: %', coalesce(event->'claims', '{}'::jsonb);

    -- Check if the user is marked as admin in the profiles table

    SELECT plan, role INTO user_plan, user_role FROM public.user_profiles WHERE id = input_user_id;
    RAISE LOG 'User plan fetch attempt for user_id %: % %', input_user_id, user_plan, user_role;

    claims := coalesce(event->'claims', '{}'::jsonb);

    -- Ensure app_metadata exists
    IF jsonb_typeof(claims->'app_metadata') IS NULL THEN
        claims := jsonb_set(claims, '{app_metadata}', '{}');
    END IF;

    -- Only update user_role and user_plan if not null
    IF user_role IS NOT NULL THEN
        claims := jsonb_set(claims, '{app_metadata,user_role}', to_jsonb(user_role::text));
    END IF;
    IF user_plan IS NOT NULL THEN
        claims := jsonb_set(claims, '{app_metadata,user_plan}', to_jsonb(user_plan::text));
    END IF;

    IF user_role IS NOT NULL OR user_plan IS NOT NULL THEN
        RAISE LOG 'Claims updated with role and/or plan: %', claims;
    ELSE
        RAISE LOG 'User role and plan are NULL, no updates made to claims.';
    END IF;

    event := jsonb_set(event, '{claims}', claims);
    RAISE LOG 'Event to be returned: %', event;

    RETURN event;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.users_columns_updateable()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
    current_user_role public.app_role_enum;
BEGIN
    -- Example of fetching current user's role from JWT; adjust based on your setup
    current_user_role := (auth.jwt() ->> 'user_role')::public.app_role_enum;
    RAISE LOG 'User with role % attempted to change role or plan', current_user_role;


    -- Allow admins or super_admins to change roles and plans
    IF current_user_role IN ('admin', 'super_admin') THEN
        RETURN NEW;
    END IF;

    -- Prevent non-admin users from changing roles and plans
    IF NEW.role IS DISTINCT FROM OLD.role THEN
        RAISE EXCEPTION 'Changing "role" is not allowed.';
    END IF;
    IF NEW.plan IS DISTINCT FROM OLD.plan THEN
        RAISE EXCEPTION 'Changing "plan" is not allowed.';
    END IF;

    RETURN NEW; -- Return the updated row to allow the update to proceed
END;
$function$
;

grant select on table "public"."categories" to "authenticated";

grant select on table "public"."embeddings" to "authenticated";

grant select on table "public"."news" to "authenticated";

grant select on table "public"."news_embeddings" to "authenticated";

grant select on table "public"."news_tags" to "authenticated";

grant delete on table "public"."plan_permissions" to "anon";

grant insert on table "public"."plan_permissions" to "anon";

grant references on table "public"."plan_permissions" to "anon";

grant select on table "public"."plan_permissions" to "anon";

grant trigger on table "public"."plan_permissions" to "anon";

grant truncate on table "public"."plan_permissions" to "anon";

grant update on table "public"."plan_permissions" to "anon";

grant delete on table "public"."plan_permissions" to "authenticated";

grant insert on table "public"."plan_permissions" to "authenticated";

grant references on table "public"."plan_permissions" to "authenticated";

grant select on table "public"."plan_permissions" to "authenticated";

grant trigger on table "public"."plan_permissions" to "authenticated";

grant truncate on table "public"."plan_permissions" to "authenticated";

grant update on table "public"."plan_permissions" to "authenticated";

grant delete on table "public"."plan_permissions" to "service_role";

grant insert on table "public"."plan_permissions" to "service_role";

grant references on table "public"."plan_permissions" to "service_role";

grant select on table "public"."plan_permissions" to "service_role";

grant trigger on table "public"."plan_permissions" to "service_role";

grant truncate on table "public"."plan_permissions" to "service_role";

grant update on table "public"."plan_permissions" to "service_role";

grant delete on table "public"."role_permissions" to "anon";

grant insert on table "public"."role_permissions" to "anon";

grant references on table "public"."role_permissions" to "anon";

grant select on table "public"."role_permissions" to "anon";

grant trigger on table "public"."role_permissions" to "anon";

grant truncate on table "public"."role_permissions" to "anon";

grant update on table "public"."role_permissions" to "anon";

grant delete on table "public"."role_permissions" to "authenticated";

grant insert on table "public"."role_permissions" to "authenticated";

grant references on table "public"."role_permissions" to "authenticated";

grant select on table "public"."role_permissions" to "authenticated";

grant trigger on table "public"."role_permissions" to "authenticated";

grant truncate on table "public"."role_permissions" to "authenticated";

grant update on table "public"."role_permissions" to "authenticated";

grant delete on table "public"."role_permissions" to "service_role";

grant insert on table "public"."role_permissions" to "service_role";

grant references on table "public"."role_permissions" to "service_role";

grant select on table "public"."role_permissions" to "service_role";

grant trigger on table "public"."role_permissions" to "service_role";

grant truncate on table "public"."role_permissions" to "service_role";

grant update on table "public"."role_permissions" to "service_role";

grant select on table "public"."tags" to "authenticated";

grant select on table "public"."user_followers" to "authenticated";

grant delete on table "public"."user_profiles" to "supabase_auth_admin";

grant references on table "public"."user_profiles" to "supabase_auth_admin";

grant select on table "public"."user_profiles" to "supabase_auth_admin";

grant trigger on table "public"."user_profiles" to "supabase_auth_admin";

grant truncate on table "public"."user_profiles" to "supabase_auth_admin";

grant update on table "public"."user_profiles" to "supabase_auth_admin";

create policy "delete_policy"
on "public"."addresses"
as permissive
for delete
to public
using (authorize('addresses.delete'::text));


create policy "insert_policy"
on "public"."addresses"
as permissive
for insert
to public
with check (authorize('addresses.insert'::text));


create policy "read_all_policy"
on "public"."addresses"
as permissive
for select
to authenticated
using (true);


create policy "update_policy"
on "public"."addresses"
as permissive
for update
to public
using (authorize('addresses.update'::text));


create policy "delete_policy"
on "public"."categories"
as permissive
for delete
to public
using (authorize('categories.delete'::text));


create policy "insert_policy"
on "public"."categories"
as permissive
for insert
to public
with check (authorize('categories.insert'::text));


create policy "read_all_policy"
on "public"."categories"
as permissive
for select
to authenticated
using (true);


create policy "update_policy"
on "public"."categories"
as permissive
for update
to public
using (authorize('categories.update'::text));


create policy "delete_policy"
on "public"."cities"
as permissive
for delete
to public
using (authorize('cities.delete'::text));


create policy "insert_policy"
on "public"."cities"
as permissive
for insert
to public
with check (authorize('cities.insert'::text));


create policy "read_all_policy"
on "public"."cities"
as permissive
for select
to authenticated
using (true);


create policy "update_policy"
on "public"."cities"
as permissive
for update
to public
using (authorize('cities.update'::text));


create policy "delete_policy"
on "public"."companies"
as permissive
for delete
to public
using (authorize('companies.delete'::text));


create policy "insert_policy"
on "public"."companies"
as permissive
for insert
to public
with check (authorize('companies.insert'::text));


create policy "read_all_policy"
on "public"."companies"
as permissive
for select
to authenticated
using (true);


create policy "update_policy"
on "public"."companies"
as permissive
for update
to public
using (authorize('companies.update'::text));


create policy "delete_policy"
on "public"."company_employees"
as permissive
for delete
to public
using (authorize('company_employees.delete'::text));


create policy "insert_policy"
on "public"."company_employees"
as permissive
for insert
to public
with check (authorize('company_employees.insert'::text));


create policy "read_all_policy"
on "public"."company_employees"
as permissive
for select
to authenticated
using (true);


create policy "update_policy"
on "public"."company_employees"
as permissive
for update
to public
using (authorize('company_employees.update'::text));


create policy "delete_policy"
on "public"."company_news"
as permissive
for delete
to public
using (authorize('company_news.delete'::text));


create policy "insert_policy"
on "public"."company_news"
as permissive
for insert
to public
with check (authorize('company_news.insert'::text));


create policy "read_all_policy"
on "public"."company_news"
as permissive
for select
to authenticated
using (true);


create policy "update_policy"
on "public"."company_news"
as permissive
for update
to public
using (authorize('company_news.update'::text));


create policy "delete_policy"
on "public"."contacts"
as permissive
for delete
to public
using (authorize('contacts.delete'::text));


create policy "insert_policy"
on "public"."contacts"
as permissive
for insert
to public
with check (authorize('contacts.insert'::text));


create policy "read_all_policy"
on "public"."contacts"
as permissive
for select
to authenticated
using (true);


create policy "update_policy"
on "public"."contacts"
as permissive
for update
to public
using (authorize('contacts.update'::text));


create policy "delete_policy"
on "public"."countries"
as permissive
for delete
to public
using (authorize('countries.delete'::text));


create policy "insert_policy"
on "public"."countries"
as permissive
for insert
to public
with check (authorize('countries.insert'::text));


create policy "read_all_policy"
on "public"."countries"
as permissive
for select
to authenticated
using (true);


create policy "update_policy"
on "public"."countries"
as permissive
for update
to public
using (authorize('countries.update'::text));


create policy "delete_policy"
on "public"."embeddings"
as permissive
for delete
to public
using (authorize('embeddings.delete'::text));


create policy "insert_policy"
on "public"."embeddings"
as permissive
for insert
to public
with check (authorize('embeddings.insert'::text));


create policy "read_all_policy"
on "public"."embeddings"
as permissive
for select
to authenticated
using (true);


create policy "update_policy"
on "public"."embeddings"
as permissive
for update
to public
using (authorize('embeddings.update'::text));


create policy "delete_policy"
on "public"."feedbacks"
as permissive
for delete
to public
using (authorize('feedbacks.delete'::text));


create policy "insert_policy"
on "public"."feedbacks"
as permissive
for insert
to public
with check (authorize('feedbacks.insert'::text));


create policy "read_all_policy"
on "public"."feedbacks"
as permissive
for select
to authenticated
using (true);


create policy "update_policy"
on "public"."feedbacks"
as permissive
for update
to public
using (authorize('feedbacks.update'::text));


create policy "delete_policy"
on "public"."news"
as permissive
for delete
to public
using (authorize('news.delete'::text));


create policy "insert_policy"
on "public"."news"
as permissive
for insert
to public
with check (authorize('news.insert'::text));


create policy "read_all_policy"
on "public"."news"
as permissive
for select
to authenticated
using (true);


create policy "update_policy"
on "public"."news"
as permissive
for update
to public
using (authorize('news.update'::text));


create policy "delete_policy"
on "public"."news_embeddings"
as permissive
for delete
to public
using (authorize('news_embeddings.delete'::text));


create policy "insert_policy"
on "public"."news_embeddings"
as permissive
for insert
to public
with check (authorize('news_embeddings.insert'::text));


create policy "read_all_policy"
on "public"."news_embeddings"
as permissive
for select
to authenticated
using (true);


create policy "update_policy"
on "public"."news_embeddings"
as permissive
for update
to public
using (authorize('news_embeddings.update'::text));


create policy "delete_policy"
on "public"."news_tags"
as permissive
for delete
to public
using (authorize('news_tags.delete'::text));


create policy "insert_policy"
on "public"."news_tags"
as permissive
for insert
to public
with check (authorize('news_tags.insert'::text));


create policy "read_all_policy"
on "public"."news_tags"
as permissive
for select
to authenticated
using (true);


create policy "update_policy"
on "public"."news_tags"
as permissive
for update
to public
using (authorize('news_tags.update'::text));


create policy "delete_policy"
on "public"."plan_permissions"
as permissive
for delete
to public
using (authorize('plan_permissions.delete'::text));


create policy "insert_policy"
on "public"."plan_permissions"
as permissive
for insert
to public
with check (authorize('plan_permissions.insert'::text));


create policy "read_all_policy"
on "public"."plan_permissions"
as permissive
for select
to authenticated
using (true);


create policy "update_policy"
on "public"."plan_permissions"
as permissive
for update
to public
using (authorize('plan_permissions.update'::text));


create policy "delete_policy"
on "public"."research"
as permissive
for delete
to public
using (authorize('research.delete'::text));


create policy "insert_policy"
on "public"."research"
as permissive
for insert
to public
with check (authorize('research.insert'::text));


create policy "read_all_policy"
on "public"."research"
as permissive
for select
to authenticated
using (true);


create policy "update_policy"
on "public"."research"
as permissive
for update
to public
using (authorize('research.update'::text));


create policy "delete_policy"
on "public"."responses"
as permissive
for delete
to public
using (authorize('responses.delete'::text));


create policy "insert_policy"
on "public"."responses"
as permissive
for insert
to public
with check (authorize('responses.insert'::text));


create policy "read_all_policy"
on "public"."responses"
as permissive
for select
to authenticated
using (true);


create policy "update_policy"
on "public"."responses"
as permissive
for update
to public
using (authorize('responses.update'::text));


create policy "delete_policy"
on "public"."role_permissions"
as permissive
for delete
to public
using (authorize('role_permissions.delete'::text));


create policy "insert_policy"
on "public"."role_permissions"
as permissive
for insert
to public
with check (authorize('role_permissions.insert'::text));


create policy "read_all_policy"
on "public"."role_permissions"
as permissive
for select
to authenticated
using (true);


create policy "update_policy"
on "public"."role_permissions"
as permissive
for update
to public
using (authorize('role_permissions.update'::text));


create policy "delete_policy"
on "public"."searches"
as permissive
for delete
to public
using (authorize('searches.delete'::text));


create policy "insert_policy"
on "public"."searches"
as permissive
for insert
to public
with check (authorize('searches.insert'::text));


create policy "read_all_policy"
on "public"."searches"
as permissive
for select
to authenticated
using (true);


create policy "update_policy"
on "public"."searches"
as permissive
for update
to public
using (authorize('searches.update'::text));


create policy "delete_policy"
on "public"."social_media"
as permissive
for delete
to public
using (authorize('social_media.delete'::text));


create policy "insert_policy"
on "public"."social_media"
as permissive
for insert
to public
with check (authorize('social_media.insert'::text));


create policy "read_all_policy"
on "public"."social_media"
as permissive
for select
to authenticated
using (true);


create policy "update_policy"
on "public"."social_media"
as permissive
for update
to public
using (authorize('social_media.update'::text));


create policy "delete_policy"
on "public"."tags"
as permissive
for delete
to public
using (authorize('tags.delete'::text));


create policy "insert_policy"
on "public"."tags"
as permissive
for insert
to public
with check (authorize('tags.insert'::text));


create policy "read_all_policy"
on "public"."tags"
as permissive
for select
to authenticated
using (true);


create policy "update_policy"
on "public"."tags"
as permissive
for update
to public
using (authorize('tags.update'::text));


create policy "delete_policy"
on "public"."user_followers"
as permissive
for delete
to public
using (authorize('user_followers.delete'::text));


create policy "insert_policy"
on "public"."user_followers"
as permissive
for insert
to public
with check (authorize('user_followers.insert'::text));


create policy "read_all_policy"
on "public"."user_followers"
as permissive
for select
to authenticated
using (true);


create policy "update_policy"
on "public"."user_followers"
as permissive
for update
to public
using (authorize('user_followers.update'::text));


create policy "auth_all"
on "public"."user_profiles"
as permissive
for all
to supabase_auth_admin
using (true);


create policy "delete_policy"
on "public"."user_profiles"
as permissive
for delete
to public
using (authorize('user_profiles.delete'::text));


create policy "insert_policy"
on "public"."user_profiles"
as permissive
for insert
to public
with check (authorize('user_profiles.insert'::text));


create policy "read_all_policy"
on "public"."user_profiles"
as permissive
for select
to authenticated
using (true);


create policy "update_policy"
on "public"."user_profiles"
as permissive
for update
to public
using (authorize('user_profiles.update'::text));


CREATE TRIGGER columns_updateable BEFORE UPDATE ON public.user_profiles FOR EACH ROW EXECUTE FUNCTION users_columns_updateable();


drop policy "Enable read access for all users" on "storage"."buckets";

drop policy "Enable read access for all users" on "storage"."objects";

drop policy "Enable select for anon on profile-public" on "storage"."objects";

create policy "Give users access to own folder yuafil_0"
on "storage"."objects"
as permissive
for select
to public
using (((bucket_id = 'profile-public'::text) AND ((auth.uid())::text = (storage.foldername(name))[1])));


create policy "Give users access to own folder yuafil_1"
on "storage"."objects"
as permissive
for insert
to public
with check (((bucket_id = 'profile-public'::text) AND ((auth.uid())::text = (storage.foldername(name))[1])));


create policy "Give users access to own folder yuafil_2"
on "storage"."objects"
as permissive
for update
to public
using (((bucket_id = 'profile-public'::text) AND ((auth.uid())::text = (storage.foldername(name))[1])));


create policy "Give users access to own folder yuafil_3"
on "storage"."objects"
as permissive
for delete
to public
using (((bucket_id = 'profile-public'::text) AND ((auth.uid())::text = (storage.foldername(name))[1])));



