import { calculateSupabaseCosts } from './storage'
import { calculateAiCost, costConfig } from './gpt'
import { calculateDigitalOceanCost } from './digital-ocean'
import { calculateLogsCost, type LoggingResult } from './logging'
import { calculateDevopsCosts } from './dev-ops'
import { calculateEmployeeCost } from './employee'
import { calculateOfficeCosts } from './office'
import { calculateInitialLoan, calculateRemainingBalance } from './capital'
import { calculateRevenue, subscription } from './income'
import { calculateAllMetrics } from './metrics'
import { generateInfo } from './gen-info'
import { calculateAnalyticsCost, type AnalyticsResult } from './analytics'

import type { AllMetrics } from './metrics'
import type { CapitalResult, LoanResult } from './capital'
import type { StorageCostResult } from './storage'
import type { DigitalOceanResult } from './digital-ocean'
import type { DevopsResult } from './dev-ops'
import type { OfficeResult } from './office'
import type { EmployeeResult } from './employee'
import type { AiCostResult } from './gpt'
import type { RevenueResult } from './income'
import type { InfoResult } from './gen-info'

// use the free groq api in place of gpt-3
// set hard limits for devops usage
// digital ocean issue:
// M0: 16.01K - M1: 16.01K - M2: 16.01K - M3: 16.01K - M4: 16.01K - M5: 16.01K - M6: 16.01K - M7: 16.01K - M8: 16.01K - M9: 16.01K - M10: 16.01K - M11: 16.01K - M12: 16.01K - M13: 16.01K - M14: 16.01K - M15: 16.01K - M16: 16.01K - M17: 16.01K - M18: 16.01K - M19: 16.01K - M20: 16.01K - M21: 16.01K - M22: 16.01K - M23: 16.01K -

// we should cap free users usage wherever possible, removing any paid services if possible.
// Consider capping the total number of free users for different stages, eg Alpha, Beta, etc.
// Figure out what the cost per user per day per tier, track this over time (maybe do ranges)
// only run this function once, use a button to trigger it
// extract configs where possible, should be easy to update in one place
// Try to narrow down the margin per user, how many free users will be paid users allow.
// This can be used to create our minimum conversion threshold
// include daily active users, this can be used to narrow down the difference between highly active users and slightly active users.
// incorporate discounts / promotions for free use of paid products, trials etc.
// Calculate revenue per user in each tier, for example free / pro / expert. free will still generate revenue through ads, etc.
// estimate Customer Acquisition Cost (CAC): Cost to acquire a new paying user. (use cost based on employee, software and average)
// estimate Customer Lifetime Value (CLV): Revenue generated by a user over their lifetime. (need to research averages)
// We need to factor in a payment gateway and any associated costs
// Mailchimp or some other email marketing platform should be considered
// Email automation for supabase signups, sendgrid is what we use (I think)
// switch to Cloudflare for the CDN, this will save vs Vercel
// Sentry for error tracking, may not need if we can use BetterStack
// Break-even Point try to calculate this exactly, so we can display on a chart
// seperate expenses into Fixed Costs, Variable Costs, Infrastructure, Third-Party Service, Support


const USD_TO_INR = 83.4 // 5TH JULY 2024
export function USD2INR(usd: number) {
  return parseFloat((usd * USD_TO_INR).toFixed(2))
}

export function ROUND0(value: number) {
  return parseInt(value.toFixed(0))
}

export function ROUND2(value: number) {
  return parseFloat(value.toFixed(2))
}

export type CompanyStage = 'start' | 'growth' | 'scaling' | 'secure'
export type Content = 'news' | 'researchAbstracts' | 'researchPapers' | 'jobs' | 'companies'

type ContentConfig = {
  processed: number
  total: number
  sources?: number
  perSourceAdditions: number
  processedMonthly: number
  words: {
    content: number
    chunks: number
    prompt: number
    output: number
  }
}

export type StageConfig = Record<Content, ContentConfig>

export const CHAR_CHUNK_SIZE = 1024
export const AVG_CHAR_PER_WORD = 4.7

const contentToNumberOfChunks = (words: number) =>
  Math.ceil((words * AVG_CHAR_PER_WORD) / CHAR_CHUNK_SIZE)

export const CONTENT_CONFIG: StageConfig = {
  news: {
    processed: 0,
    total: 120_000,
    sources: 15,
    perSourceAdditions: 30,
    processedMonthly: 2_000,
    words: {
      content: 1000,
      chunks: contentToNumberOfChunks(1000),
      prompt: 100,
      output: 240
    }
  },
  researchAbstracts: {
    processed: 0,
    total: 2_400_000,
    sources: 2,
    perSourceAdditions: 1_300,
    processedMonthly: 10_000,
    words: {
      content: 280,
      chunks: contentToNumberOfChunks(280),
      prompt: 50,
      output: 60
    }
  },
  researchPapers: {
    processed: 0,
    total: 1000,
    sources: 2,
    perSourceAdditions: 10_000,
    processedMonthly: 10_000,
    words: {
      content: 10_000,
      chunks: contentToNumberOfChunks(10_000),
      prompt: 100,
      output: 400
    }
  },
  companies: {
    processed: 0,
    total: 4_500,
    perSourceAdditions: 150,
    processedMonthly: 500,
    words: {
      content: 20_000,
      chunks: contentToNumberOfChunks(20_000),
      prompt: 200,
      output: 1_000
    }
  },
  jobs: {
    processed: 0,
    total: 3_000,
    sources: 5,
    perSourceAdditions: 30,
    processedMonthly: 2_000,
    words: {
      content: 1_000,
      chunks: contentToNumberOfChunks(1_000),
      prompt: 120,
      output: 100
    }
  }
}

interface Income {
  monthlyCostINR: number
  mau: number
  stage: CompanyStage
  previousStage: CompanyStage | null
  loan: InitialLoanResult
}

function processContent(config: ContentConfig, scaleFactor: number) {
  const monthlyAdditions = config.sources
    ? config.sources * config.perSourceAdditions * scaleFactor
    : scaleFactor * config.perSourceAdditions
  const totalProcessedMonthly = config.processedMonthly * scaleFactor
  const newProcessed = Math.min(monthlyAdditions, totalProcessedMonthly)

  console.log('Content:', config, 'Scale Factor:', scaleFactor, 'New Processed:', newProcessed)
  return {
    monthlyAdditions,
    newProcessed,
    totalRemaining: config.total - newProcessed
  }
}

let processedContent = {
  news: {
    additions: 0,
    processed: 0,
    total: 0,
    processedMonthly: 0,
    perSourceAdditions: 0
  },
  researchAbstracts: {
    additions: 0,
    processed: 0,
    total: 0,
    processedMonthly: 0,
    perSourceAdditions: 0
  },
  researchPapers: {
    additions: 0,
    processed: 0,
    total: 0,
    processedMonthly: 0,
    perSourceAdditions: 0
  },
  companies: {
    additions: 0,
    processed: 0,
    total: 0,
    processedMonthly: 0,
    perSourceAdditions: 0
  },
  jobs: {
    additions: 0,
    processed: 0,
    total: 0,
    processedMonthly: 0,
    perSourceAdditions: 0
  }
}

function updateMonthlyData(month: number) {
  const scaleFactor = month * 0.01 + 1
  console.log('Scale Factor:', scaleFactor)
  for (const contentType in CONTENT_CONFIG) {
    if (CONTENT_CONFIG.hasOwnProperty(contentType)) {
      const config = CONTENT_CONFIG[contentType as keyof StageConfig]
      console.log('Raw Config', config)
      const { monthlyAdditions, newProcessed, totalRemaining } = processContent(config, scaleFactor)

      processedContent[contentType as keyof StageConfig].additions = newProcessed
      processedContent[contentType as keyof StageConfig].total = totalRemaining
      processedContent[contentType as keyof StageConfig].processed += newProcessed
      processedContent[contentType as keyof StageConfig].processedMonthly = newProcessed
      processedContent[contentType as keyof StageConfig].perSourceAdditions = monthlyAdditions
    }
  }

  console.log('Processed Content:', processedContent)

  return {
    processedContent,
    scaleFactor
  }
}

function determineCompanyStage(mau: number): CompanyStage {
  if (mau < 10000) return 'start'
  if (mau < 100000) return 'growth'
  if (mau < 500000) return 'scaling'
  return 'secure'
}

interface CalculationResult {
  loan: LoanResult
  capital: CapitalResult
}

interface Growth {
  mau: {
    total: number
    new: number
    existing: number
    churned: number
  }
  revenue: RevenueResult
}

interface AllCost {
  totals: {
    monthlyINR: number
    employees: number
    office: number
    storage: number
    digitalOcean: number
    logging: number
    devOps: number
    openAi: number
    loan: number
    analytics: number
  }
  employees: EmployeeResult
  office: OfficeResult
  storage: StorageCostResult
  digitalOcean: DigitalOceanResult
  logging: LoggingResult
  devOps: DevopsResult
  openAI: AiCostResult
  loan: LoanResult
  analytics: AnalyticsResult
}

interface CalculationParams {
  initialMau: number
  initialLoanAmount: number
  annualInterestRate: number
  termInYears: number
  months: number
  monthlyGrowthRate: number
  manualGrowthRate: number
  initialExpenses: number
  initialRevenue: number
}

interface TotalsResult {
  stages: CompanyStage[]
  months: number[]
  info: InfoResult[]
  cost: AllCost[]
  growth: Growth[]
  metrics: AllMetrics[]
  capital: CapitalResult[]
}

export function calculateBusinessMetrics({
  initialMau,
  initialLoanAmount,
  annualInterestRate,
  termInYears,
  months,
  monthlyGrowthRate,
  manualGrowthRate,
  initialExpenses,
  initialRevenue
}: CalculationParams): TotalsResult {
  const allCost: AllCost[] = []
  const allGrowth: Growth[] = []
  const allMetrics: AllMetrics[] = []
  const allCapital: CapitalResult[] = []
  const allMonths = [] as number[]
  const allStages = [] as CompanyStage[]

  let mau = initialMau
  let balanceRemaining = initialLoanAmount
  let existingMAU = 0
  let newMAU = initialMau
  let proUsers = 0
  let expertUsers = 0
  let churnRate = 0.05 // Assuming 5% churn rate

  const loan = calculateInitialLoan({
    loan: initialLoanAmount,
    annualInterestRate,
    termInYears
  })

  const info = generateInfo()

  for (let month = 1; month <= months; month++) {
    mau = Math.ceil(mau * (1 + monthlyGrowthRate) + manualGrowthRate * month)

    const companyStage = determineCompanyStage(mau)

    const churnedMAU = Math.ceil(existingMAU * churnRate)
    existingMAU = existingMAU - churnedMAU + newMAU
    newMAU = mau - existingMAU

    const revenue = calculateRevenue({
      month,
      mau: {
        total: mau,
        new: newMAU,
        existing: existingMAU,
        churned: churnedMAU
      },
      customers: {
        existing: proUsers + expertUsers,
        pro: proUsers,
        expert: expertUsers
      }
    })

    const storage = updateMonthlyData(month)

    const logging = calculateLogsCost({ MAU: mau, avgMauMonthlyUsage, month, teamMembers: 1 })
    const devOps = calculateDevopsCosts(mau)
    const openAI = calculateAiCost(mau, revenue.customers.totalCount)

    const contentParams = Object.entries(CONTENT_CONFIG).map(([contentType, contentConfig]) => ({
      contentType: contentType as Content,
      words: contentConfig.words,
      total: storage.processedContent[contentType as Content].total
    }))

    const analytics = calculateAnalyticsCost({
      MAU: mau,
      month,
      avgMauMonthlyUsage: 0.01
    })
    const supabase = calculateSupabaseCosts(mau, contentParams)
    const employees = calculateEmployeeCost(mau, companyStage)
    const office = calculateOfficeCosts(employees.totalEmployees)
    const digitalOcean = calculateDigitalOceanCost({ bandwidthGB: supabase.storage.data.total })
    const devOpsCost = mau > 100_000 ? devOps.inhouse.cost.total : devOps.vercel.cost.total

    const monthlyExpenses =
      employees.totalCost +
      supabase.totalCost +
      devOpsCost +
      digitalOcean.cost +
      logging.total +
      openAI.cost.total +
      office.total +
      loan.monthlyInterestOnlyPayment +
      analytics.total

    const capital = calculateRemainingBalance({
      month,
      loan: loan.loanStart,
      expenses: monthlyExpenses,
      income: revenue.total.effective
    })

    const metrics = calculateAllMetrics({
      MAU: mau,
      marketingCost: 0,
      leads: 0,
      customerLifespan: 6,
      currentBalance: balanceRemaining,
      expenses: monthlyExpenses,
      effectiveRevenue: revenue.total.effective,
      customers: {
        all: mau,
        new: newMAU,
        existing: existingMAU,
        churned: churnedMAU
      }
    })

    allMetrics.push(metrics)
    allCapital.push(capital)
    allCost.push({
      totals: {
        monthlyINR: parseInt(monthlyExpenses.toFixed(0)),
        employees: employees.totalCost,
        office: office.total,
        storage: supabase.totalCost,
        digitalOcean: digitalOcean.cost,
        logging: logging.total,
        devOps: devOpsCost,
        openAi: openAI.cost.total,
        loan: loan.monthlyInterestOnlyPayment,
        analytics: analytics.total
      },
      employees,
      office,
      storage: supabase,
      digitalOcean,
      logging,
      devOps,
      openAI,
      loan,
      analytics
    })

    allGrowth.push({
      mau: {
        total: mau,
        new: newMAU,
        existing: existingMAU,
        churned: churnedMAU
      },
      revenue
    })

    allMonths.push(month)
    allStages.push(companyStage)

    proUsers = revenue.customers.pro.count
    expertUsers = revenue.customers.expert.count
  }

  return {
    stages: allStages,
    months: allMonths,
    info,
    loan,
    cost: allCost,
    growth: allGrowth,
    metrics: allMetrics,
    capital: allCapital
  }
}

export function generateBusinessMetrics() {
  return calculateBusinessMetrics({
    initialMau: 200, // Initial MAU
    initialLoanAmount: 20_00_000, // Initial Loan Amount
    annualInterestRate: 0.1, // Annual Interest Rate
    termInYears: 4, // Term in Years
    months: 24, // Number of Months to Project
    monthlyGrowthRate: 0.25, // Monthly Growth Rate (50%)
    manualGrowthRate: 150, // Manual Growth Rate
    initialExpenses: 50000, // Initial Expenses
    initialRevenue: 30000 // Initial Revenue
  })
}
