import { calculateSupabaseCosts } from './storage'
import { calculateAiCost, COST_CONFIG } from './gpt'
import { calculateDigitalOceanCost } from './digital-ocean'
import { calculateLogsCost, type LoggingResult } from './logging'
import { calculateDevopsCosts } from './dev-ops'
import { calculateEmployeeCost } from './employee'
import { calculateSubscriptionCosts, type SoftwareCosts } from './software'
import { calculateOfficeCosts } from './office'
import { calculateInitialLoan, calculateRemainingBalance } from './capital'
import { calculateRevenue, INCOME_STREAMS } from './income'
import { calculateAllMetrics } from './metrics'
import { generateInfo } from './gen-info'
import { calculateCostPerUser } from './users'
import { calculateMarketingCost } from './marketing'
import { simulateRealWorldPurchases, type TransactionDetails } from './payments'
import { calculateAnalyticsCost, type AnalyticsResult } from './analytics'
import { CONTENT_TO_CHUNKS } from '#imports'

import type { AllMetrics } from './metrics'
import type { CapitalResult, LoanResult } from './capital'
import type { StorageCostResult } from './storage'
import type { DigitalOceanResult } from './digital-ocean'
import type { DevopsResult } from './dev-ops'
import type { OfficeResult } from './office'
import type { EmployeeResult } from './employee'
import type { AiCostResult } from './gpt'
import type { RevenueResult } from './income'
import type { InfoResult } from './gen-info'

import { EFFICIENCY_FACTOR, CHURN_TO_LIFESPAN_MONTHS } from './helpers'

// set hard limits for devops usage

// we should cap free users usage wherever possible, removing any paid services if possible.

// Consider capping the total number of free users for different stages, eg Alpha, Beta, etc.

// only run this function once, use a button to trigger it

// extract configs where possible, should be easy to update in one place

// Try to narrow down the margin per user, how many free users will be paid users allow.
// This can be used to create our minimum conversion threshold

// include daily active users, this can be used to narrow down the difference between highly active users and slightly active users.

// incorporate discounts / promotions for free use of paid products, trials etc.
// Calculate revenue per user in each tier, for example free / pro / expert. free will still generate revenue through ads, etc.

// estimate Customer Acquisition Cost (CAC): Cost to acquire a new paying user. (use cost based on employee, software and average)
// estimate Customer Lifetime Value (CLV): Revenue generated by a user over their lifetime. (need to research averages)
// We need to factor in a payment gateway and any associated costs
// Mailchimp or some other email marketing platform should be considered
// Email automation for supabase signups, sendgrid is what we use (I think)
// switch to Cloudflare for the CDN, this will save vs Vercel
// Sentry for error tracking, may not need if we can use BetterStack
// Break-even Point try to calculate this exactly, so we can display on a chart
// seperate expenses into Fixed Costs, Variable Costs, Infrastructure, Third-Party Service, Support

// STILL TO FIX
// Razorpay is only showing transactions to the 21st month
// input and output cost for GPT is the same??

export type CompanyStage = 'start' | 'growth' | 'scaling' | 'secure'
export type Content = 'NEWS' | 'RESEARCH_ABSTRACTS' | 'RESEARCH_PAPERS' | 'JOBS' | 'COMPANIES'
export type StageConfig = Record<Content, ProcessdContentConfig>

export type ContentScalingRules = {
  [key in Content]: {
    totalContentStored: number
    totalVectorStored: number
    sourceGrowthRate: number // Growth rate for sources
    additionsGrowthRate: number // Growth rate for per source additions
    monthlyProcessingGrowthRate: number // Growth rate for monthly processed items
  }
}

const scalingRules: ContentScalingRules = {
  // 0.1 = 10%
  NEWS: {
    totalContentStored: 0,
    totalVectorStored: 0,
    sourceGrowthRate: 0.15,
    additionsGrowthRate: 0.15,
    monthlyProcessingGrowthRate: 0.10
  },
  RESEARCH_ABSTRACTS: {
    totalContentStored: 0,
    totalVectorStored: 0,
    sourceGrowthRate: 0.02,
    additionsGrowthRate: 0.02,
    monthlyProcessingGrowthRate: 0.07
  },
  RESEARCH_PAPERS: {
    totalContentStored: 0,
    totalVectorStored: 0,
    sourceGrowthRate: 0.01,
    additionsGrowthRate: 0.01,
    monthlyProcessingGrowthRate: 0.02
  },
  COMPANIES: {
    totalContentStored: 0,
    totalVectorStored: 0,
    sourceGrowthRate: 0.005,
    additionsGrowthRate: 0.06,
    monthlyProcessingGrowthRate: 0.05
  },
  JOBS: {
    totalContentStored: 0,
    totalVectorStored: 0,
    sourceGrowthRate: 0.05,
    additionsGrowthRate: 0.1,
    monthlyProcessingGrowthRate: 0.05
  }
}

function scaleContentConfig(
  CONTENT_CONFIG: StageConfig,
  currentMonth: number,
  rules: ContentScalingRules
): StageConfig {
  const scaledConfig: StageConfig = JSON.parse(JSON.stringify(CONTENT_CONFIG)) // Deep copy to avoid mutations

  for (const contentType in scaledConfig) {
    const content = scaledConfig[contentType as keyof StageConfig]
    const rule = rules[contentType as Content]

    // Calculate scaling factors for the month
    const sourceFactor = 1 + rule.sourceGrowthRate * currentMonth
    const additionsFactor = 1 + rule.additionsGrowthRate * currentMonth
    const monthlyProcessingFactor = 1 + rule.monthlyProcessingGrowthRate * currentMonth

    // console.log('Scaling Factors:', sourceFactor, additionsFactor, monthlyProcessingFactor)

    if (currentMonth === 1) {
      // Initialize totals for the first month
      rule.totalVectorStored = content.PROCESSED
      rule.totalContentStored = content.TOTAL
    }

    // Scale the sources and per source additions
    content.SOURCES = Math.ceil(content.SOURCES * sourceFactor)
    content.PER_SOURCE_ADDITIONS = Math.ceil(content.PER_SOURCE_ADDITIONS * additionsFactor)

    // Calculate new content added and processed this month
    const newContentAdded = content.SOURCES * content.PER_SOURCE_ADDITIONS
    const newContentProcessed = Math.ceil(content.PROCESSED_MONTHLY * monthlyProcessingFactor)

    // Update total content and vectors stored
    rule.totalContentStored += newContentAdded
    rule.totalVectorStored += newContentProcessed

    // Update the content configuration
    content.PROCESSED_MONTHLY = newContentProcessed
    content.PROCESSED = rule.totalVectorStored
    content.TOTAL = rule.totalContentStored
  }

  console.log('Scaled Content Config for Month:', currentMonth, scaledConfig)
  return scaledConfig
}

function determineCompanyStage(mau: number): CompanyStage {
  if (mau < 10000) return 'start'
  if (mau < 100000) return 'growth'
  if (mau < 500000) return 'scaling'
  return 'secure'
}

interface Growth {
  mau: {
    total: number
    new: number
    existing: number
    churned: number
  }
  revenue: RevenueResult
}

interface AllCost {
  totals: {
    monthlyINR: number
    employees: number
    office: number
    storage: number
    digitalOcean: number
    logging: number
    devOps: number
    openAi: number
    loan: number
    analytics: number
    marketing: number
    software: number
    payments: number
  }
  employees: EmployeeResult
  office: OfficeResult
  storage: StorageCostResult
  digitalOcean: DigitalOceanResult
  logging: LoggingResult
  devOps: DevopsResult
  openAI: AiCostResult
  loan: LoanResult
  analytics: AnalyticsResult
  software: SoftwareCosts
  payments: TransactionDetails
}

export type ContentParams = {
  CONTENT_TYPE: Content
  TOTAL: number
  PROCESSED: number
  WORDS: {
    CONTENT: number
    CHUNKS: number
    PROMPT: number
    OUTPUT: number
  }
}

interface TotalsResult {
  stages: CompanyStage[]
  months: number[]
  info: InfoResult[]
  cost: AllCost[]
  growth: Growth[]
  metrics: AllMetrics[]
  capital: CapitalResult[]
}

const AVG_MAU_USAGE = 0.01

interface AllData {
  cost: AllCost[]
  growth: Growth[]
  metrics: AllMetrics[]
  capital: CapitalResult[]
  months: number[]
  stages: CompanyStage[]
}

export function calculateBusinessMetrics(params: BusinessMetricsConfig): TotalsResult {
  const allData: AllData = {
    cost: [],
    growth: [],
    metrics: [],
    capital: [],
    months: [],
    stages: []
  }

  let mau = params.CURRENT.MAU
  let balanceRemaining = params.LOAN.AMOUNT
  let existingMAU = 0
  let newMAU = params.CURRENT.MAU
  let proUsers = 0
  let expertUsers = 0

  const info = generateInfo()

  for (let month = 1; month <= params.PROJECTION.MONTHS; month++) {
    const scaledContentConfig = scaleContentConfig(metricConfig.CONTENT_CONFIG, month, scalingRules)
    const churnRate = EFFICIENCY_FACTOR({
      currentMonth: month,
      pessimistic: params.YEARLY_CHURN.MAU.PESSIMISTIC,
      optimistic: params.YEARLY_CHURN.MAU.OPTIMISTIC
    })

    mau = Math.ceil(
      mau * (1 + params.PROJECTION.MONTHLY_GROWTH_RATE) +
        params.PROJECTION.MANUAL_GROWTH_RATE * month
    )
    const companyStage = determineCompanyStage(mau)

    const churnedMAU = Math.ceil(existingMAU * churnRate)
    newMAU = mau - (existingMAU - churnedMAU)
    existingMAU = existingMAU - churnedMAU + newMAU

    const revenue = calculateRevenue({
      month,
      mau: {
        total: mau,
        new: newMAU,
        existing: existingMAU,
        churned: churnedMAU
      },
      customers: {
        existing: proUsers + expertUsers,
        pro: proUsers,
        expert: expertUsers
      }
    })

    const payments = simulateRealWorldPurchases({
      newCustomers: {
        pro: revenue.customers.pro.new,
        expert: revenue.customers.expert.new
      },
      frequency: 'Monthly'
    })

    const logging = calculateLogsCost({
      MAU: mau,
      avgMauUsage: AVG_MAU_USAGE,
      month,
      teamMembers: 1
    })
    const devOps = calculateDevopsCosts(mau)
    const openAI = calculateAiCost({
      mau,
      customers: {
        pro: revenue.customers.pro.count,
        expert: revenue.customers.expert.count
      },
      isBatch: false,
      CONTENT_CONFIG: scaledContentConfig
    })

    const contentParams = Object.entries(scaledContentConfig).map(
      ([contentType, contentConfig]) => ({
        CONTENT_TYPE: contentType as Content,
        WORDS: contentConfig.WORDS,
        TOTAL: contentConfig.TOTAL,
        PROCESSED: contentConfig.PROCESSED
      })
    )
    const supabase = calculateSupabaseCosts(mau, month, contentParams)

    const analytics = calculateAnalyticsCost({
      MAU: mau,
      month,
      avgMauUsage: AVG_MAU_USAGE
    })

    const employees = calculateEmployeeCost({
      mau,
      stage: companyStage,
      month: month,
      bootstrapMonths: params.BOOTSTRAP_MONTHS
    })

    const office = calculateOfficeCosts(employees.totalEmployees)
    const digitalOcean = calculateDigitalOceanCost({ bandwidthGB: supabase.storage.data.total * 2 })
    const devOpsCost = mau > 100_000 ? devOps.inhouse.cost.total : devOps.vercel.cost.total
    const software = calculateSubscriptionCosts(employees.totalEmployees)
    const marketingCost = calculateMarketingCost({
      mrr: revenue.total.effective,
      percentage: params.MRR_MARKETING_PERCENTAGE_SPEND
    })

    const monthlyExpenses =
      employees.totalCost +
      supabase.totalCost +
      devOpsCost +
      digitalOcean.cost +
      logging.total +
      openAI.cost.total +
      office.total +
      analytics.total +
      software.totalCost +
      marketingCost +
      payments.totalCost

    const userExpenses =
      supabase.totalCost +
      digitalOcean.cost +
      logging.total +
      devOpsCost +
      analytics.total +
      marketingCost

    const userCost = calculateCostPerUser({
      users: {
        free: mau,
        pro: revenue.customers.pro.count,
        expert: revenue.customers.expert.count
      },
      totalCosts: {
        free: userExpenses + openAI.chat.free.cost.total,
        pro: userExpenses + openAI.chat.pro.cost.total,
        expert: userExpenses + openAI.chat.expert.cost.total
      },
      totalIncome: revenue.total.effective
    })

    const capital = calculateRemainingBalance({
      loan: params.LOAN,
      month,
      initialCapital: params.INITIAL_CAPITAL,
      bootstrapMonths: params.BOOTSTRAP_MONTHS,
      expenses: monthlyExpenses,
      income: revenue.total.effective
    })

    const metrics = calculateAllMetrics({
      MAU: mau,
      marketingCost,
      currentMonth: month,
      leads: 0,
      currentBalance: balanceRemaining,
      expenses: monthlyExpenses,
      effectiveRevenue: revenue.total.effective,
      customers: {
        all: revenue.customers.totalCount,
        new: revenue.customers.newCount,
        churned: revenue.customers.churn.count
      }
    })

    allData.metrics.push({
      ...metrics,
      users: {
        ...userCost,
        lifespanMonths: CHURN_TO_LIFESPAN_MONTHS(churnRate),
        churnRate
      }
    })

    allData.capital.push(capital)

    allData.cost.push({
      totals: {
        monthlyINR: parseInt(monthlyExpenses.toFixed(0)),
        employees: employees.totalCost,
        office: office.total,
        storage: supabase.totalCost,
        digitalOcean: digitalOcean.cost,
        logging: logging.total,
        devOps: devOpsCost,
        openAi: openAI.cost.total,
        loan: capital.loan.monthlyInterestOnlyPayment,
        analytics: analytics.total,
        marketing: marketingCost,
        software: software.totalCost,
        payments: payments.totalCost
      },
      employees,
      office,
      storage: supabase,
      digitalOcean,
      logging,
      devOps,
      openAI,
      loan: capital.loan,
      analytics,
      software,
      payments
    })

    allData.growth.push({
      mau: {
        total: mau,
        new: newMAU,
        existing: existingMAU,
        churned: churnedMAU
      },
      revenue
    })

    allData.months.push(month)
    allData.stages.push(companyStage)

    proUsers = revenue.customers.pro.count
    expertUsers = revenue.customers.expert.count
  }

  return {
    ...allData,
    info
  }
}

type BusinessMetricsConfig = {
  BOOTSTRAP_MONTHS: number
  INITIAL_CAPITAL: number
  MRR_MARKETING_PERCENTAGE_SPEND: number
  YEARLY_CHURN: {
    MAU: {
      PESSIMISTIC: number
      OPTIMISTIC: number
    }
    CUSTOMERS: {
      PESSIMISTIC: number
      OPTIMISTIC: number
    }
  }
  CURRENT: {
    MAU: number
    USD_TO_INR: number
    EXPENSES: number
    REVENUE: number
  }
  LOAN: {
    AMOUNT: number
    ANNUAL_INTEREST_RATE: number
    TERM_IN_YEARS: number
  }
  PROJECTION: {
    MONTHS: number
    MONTHLY_GROWTH_RATE: number
    MANUAL_GROWTH_RATE: number
    USAGE_HOURS_PER_DAY: number
    USAGE_GROWTH_FACTOR: number
    MAX_DAILY_USAGE: number
  }
  DEVOPS_USAGE: {
    DATA_TRANSFER_GB: number
    ORIGIN_TRANSFER_GB: number
    EDGE_REQUESTS: number
    MIDDLEWARE_INVOCATIONS: number
    SOURCE_IMAGES: number
    FUNCTION_INVOCATIONS: number
    FUNCTION_DURATION_GB_HOURS: number
    EDGE_FUNCTION_EXECUTIONS: number
    DATA_CACHE_READS: number
    DATA_CACHE_WRITES: number
    EDGE_CONFIG_READS: number
    EDGE_CONFIG_WRITES: number
    MONITORING_EVENTS: number
    SPEED_INSIGHTS_DATA_POINTS: number
    WEB_ANALYTICS_EVENTS: number
  }
  CONTENT_CONFIG: {
    NEWS: ProcessdContentConfig
    RESEARCH_ABSTRACTS: ProcessdContentConfig
    RESEARCH_PAPERS: ProcessdContentConfig
    COMPANIES: ProcessdContentConfig
    JOBS: ProcessdContentConfig
  }
}

export type ProcessdContentConfig = {
  PROCESSED: number
  TOTAL: number
  SOURCES: number
  PER_SOURCE_ADDITIONS: number
  PROCESSED_MONTHLY: number
  WORDS: {
    CONTENT: number
    CHUNKS: number
    PROMPT: number
    OUTPUT: number
  }
}

export const metricConfig = {
  BOOTSTRAP_MONTHS: 5,
  INITIAL_CAPITAL: 1_00_000,
  MRR_MARKETING_PERCENTAGE_SPEND: 0.1,
  YEARLY_CHURN: {
    MAU: {
      PESSIMISTIC: 0.3,
      OPTIMISTIC: 0.1
    },
    CUSTOMERS: {
      PESSIMISTIC: 0.12,
      OPTIMISTIC: 0.05
    }
  },
  CURRENT: {
    MAU: 200, // Initial MAU
    USD_TO_INR: 83.4, // 5TH JULY 2024
    REVENUE: 0 // Initial Revenue
  },
  LOAN: {
    AMOUNT: 20_00_000, // Initial Loan Amount
    ANNUAL_INTEREST_RATE: 0.12, // Annual Interest Rate
    TERM_IN_YEARS: 4 // Term in Years
  },
  PROJECTION: {
    MONTHS: 24, // Number of Months to Project
    MONTHLY_GROWTH_RATE: 0.2, // Monthly Growth Rate (50%)
    MANUAL_GROWTH_RATE: 100, // Manual Growth Rate
    USAGE_HOURS_PER_DAY: 0.1, // Base Usage Hours per Day
    USAGE_GROWTH_FACTOR: 0.1, // Base Hours Growth Factor
    MAX_DAILY_USAGE: 1.5 // Max Daily Hour Usage
  },
  DEVOPS_USAGE: {
    DATA_TRANSFER_GB: 0.015, // 15 MB per hour per user
    ORIGIN_TRANSFER_GB: 0.001, // 1 MB per hour per user
    EDGE_REQUESTS: 150, // 150 requests per hour per user
    MIDDLEWARE_INVOCATIONS: 75, // 75 middleware invocations per hour per user
    SOURCE_IMAGES: 0, // Assume no usage, handled by supabase
    FUNCTION_INVOCATIONS: 75, // 75 function invocations per hour per user
    FUNCTION_DURATION_GB_HOURS: 0.08, // Adjusted to 0.08 GB-hours per hour per user
    EDGE_FUNCTION_EXECUTIONS: 75, // 75 edge function executions per hour per user
    DATA_CACHE_READS: 800, // Adjusted to 800 data cache reads per hour per user
    DATA_CACHE_WRITES: 75, // 75 data cache writes per hour per user
    EDGE_CONFIG_READS: 50, // Adjusted to 50 edge config reads per hour per user
    EDGE_CONFIG_WRITES: 0.1, // Adjusted to 0.1 edge config writes per hour per user
    MONITORING_EVENTS: 0, // Use posthog instead
    SPEED_INSIGHTS_DATA_POINTS: 0, // Not using
    WEB_ANALYTICS_EVENTS: 0 // Not using
  },
  CONTENT_CONFIG: {
    NEWS: {
      PROCESSED: 0,
      TOTAL: 120_000,
      SOURCES: 15,
      PER_SOURCE_ADDITIONS: 30,
      PROCESSED_MONTHLY: 2_000,
      WORDS: {
        CONTENT: 1000,
        CHUNKS: CONTENT_TO_CHUNKS(1000),
        PROMPT: 100,
        OUTPUT: 240
      }
    },
    RESEARCH_ABSTRACTS: {
      PROCESSED: 0,
      TOTAL: 2_400_000,
      SOURCES: 2,
      PER_SOURCE_ADDITIONS: 1_300,
      PROCESSED_MONTHLY: 10_000,
      WORDS: {
        CONTENT: 280,
        CHUNKS: CONTENT_TO_CHUNKS(280),
        PROMPT: 50,
        OUTPUT: 60
      }
    },
    RESEARCH_PAPERS: {
      PROCESSED: 0,
      TOTAL: 1000,
      SOURCES: 2,
      PER_SOURCE_ADDITIONS: 10_000,
      PROCESSED_MONTHLY: 10_000,
      WORDS: {
        CONTENT: 10_000,
        CHUNKS: CONTENT_TO_CHUNKS(10_000),
        PROMPT: 100,
        OUTPUT: 400
      }
    },
    COMPANIES: {
      PROCESSED: 0,
      TOTAL: 4_500,
      SOURCES: 1,
      PER_SOURCE_ADDITIONS: 150,
      PROCESSED_MONTHLY: 500,
      WORDS: {
        CONTENT: 20_000,
        CHUNKS: CONTENT_TO_CHUNKS(20_000),
        PROMPT: 200,
        OUTPUT: 1_000
      }
    },
    JOBS: {
      PROCESSED: 0,
      TOTAL: 3_000,
      SOURCES: 5,
      PER_SOURCE_ADDITIONS: 30,
      PROCESSED_MONTHLY: 2_000,
      WORDS: {
        CONTENT: 1_000,
        CHUNKS: CONTENT_TO_CHUNKS(1_000),
        PROMPT: 120,
        OUTPUT: 100
      }
    }
  }
}

export async function generateBusinessMetrics() {
  return calculateBusinessMetrics(metricConfig)
}
