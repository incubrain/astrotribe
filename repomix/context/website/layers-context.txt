This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-11-21T14:48:00.935Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>

<additional_info>

For more information about Repomix, visit: https://github.com/yamadashy/repomix
</additional_info>

</file_summary>

<repository_structure>
layers/
  base/
    .playground/
      app.config.ts
      nuxt.config.ts
    components/
      image/
        ImageHero.vue
        ImageWithFallback.vue
      Background.vue
      Breadcrumbs.vue
      Glass.vue
      GlobalTimer.vue
      Grid.vue
      HelloWorld.vue
      HoverCard.vue
      Image.vue
      InfiniteScroll.vue
      Loader.vue
      Modal.vue
      NavHamburger.vue
      NewLabel.vue
      Pagination.vue
      Popover.vue
      Resizable.vue
      Sidebar.vue
      SideNav.vue
      SocialBlock.vue
      TabView.vue
      YT.client.vue
    composables/
      utils/
        arrays.ts
        hasValueChanged.ts
        objects.ts
        strings.ts
        time.ts
      ab-test.ts
      analytics.ts
      glass-card.ts
      metrics.ts
      modal.ts
      notification.ts
      settings.store.ts
      social.store.ts
      useMediaQuery.ts
      useNavigation.ts
      utils.ts
    plugins/
      error-handler.ts
      posthog.client.ts
      sentry.client.ts
    types/
      content.ts
      database.ts
      index.ts
      users.ts
    nuxt.config.ts
    supabase-provider.ts
</repository_structure>

<repository_files>
This section contains the contents of the repository's files.

<file path="layers/base/.playground/app.config.ts">
export default defineAppConfig({
  myLayer: {
    name: 'My amazing Nuxt layer (overwritten)',
  },
})
</file>

<file path="layers/base/.playground/nuxt.config.ts">
export default defineNuxtConfig({
  extends: ['..'],
  modules: ['@nuxt/eslint'],
})
</file>

<file path="layers/base/components/image/ImageHero.vue">
<script setup lang="ts">
import type { TitleType, ImageType } from '../../types/content'

defineProps({
  fit: {
    type: String,
    default: 'cover',
  },
  objectPosition: {
    type: String,
    default: 'center',
  },
  title: {
    type: Object as () => TitleType,
    required: true,
  },
  img: {
    type: Object as () => ImageType,
    required: true,
  },
})

// consider turning the images into short videos using AI
// consider using mix-blend-mode for cool text effect with video
</script>

<template>
  <div class="relative flex items-center justify-center">
    <IBImage
      :img="{
        src: img.src,
        alt: img.alt,
        width: img.width,
        height: img.height,
      }"
      :class="`w-full object-${fit} ${objectPosition} h-screen`"
    />
    <div
      class="absolute z-10 flex flex-col items-center justify-center gap-8 px-4 text-white lg:flex-row lg:gap-16 xl:px-8"
    >
      <slot />
      <div class="flex flex-col gap-4">
        <h2
          :class="`rounded-md bg-black/30 px-4 py-1 text-3xl font-bold shadow-xl lg:text-5xl xl:px-8 text-${title.centered ? 'center' : 'left'}`"
        >
          {{ title.main }}
        </h2>
        <p
          v-if="title.subtitle"
          :class="`inline-block w-auto max-w-2xl rounded-sm px-4 pb-4 text-xl font-semibold lg:text-3xl xl:px-8 text-${title.centered ? 'center' : 'left'}`"
        >
          {{ title.subtitle }}
        </p>
      </div>
    </div>
    <div class="absolute left-0 top-0 h-full w-full bg-black/50" />
  </div>
</template>

<style scoped></style>
</file>

<file path="layers/base/components/image/ImageWithFallback.vue">
<script setup lang="ts">
interface Image {
  src: string
  alt: string | null
  caption: string | null
  credit: string | null
}

interface Options {
  width: number
  height: number
  sizes: string | undefined | null
  quality: number | undefined | null
}

defineProps({
  image: {
    type: Object as () => Image | undefined,
    default: undefined,
  },
  options: {
    type: Object as () => Options | undefined,
    default: () => ({
      width: 50,
      height: 50,
      sizes: null,
      quality: 80,
    }),
  },
})
</script>

<template>
  <div class="relative h-full w-full overflow-hidden rounded-md object-cover">
    <IBImage
      :img="{
        src: image?.src || 'hero-image.jpg',
        alt: image?.alt || 'this is a default fallback for when an image is not present',
        width: options?.width || 60,
        height: options?.height || 37,
        quality: options?.quality || 80,
      }"
      class="h-full w-full object-cover"
    />
    <div
      v-if="!image?.src"
      class="absolute left-0 top-0 z-50 flex h-full w-full items-center justify-center bg-black/40"
    >
      <h3 class="foreground rounded-lg px-3 py-1 text-base"> NO IMAGE </h3>
    </div>
  </div>
</template>
</file>

<file path="layers/base/components/Background.vue">
<template>
  <canvas
    ref="canvas"
    class="w-full h-full"
  />
</template>

<script setup lang="ts">
const CANVAS_WIDTH = computed(() => (window ? window.innerWidth : 0))
const CANVAS_HEIGHT = computed(() => (window ? window.innerHeight + 800 : 0))
const STAR_COUNT = 300 // Number of stars
const COLORS = ['#ffffff', '#ffcccb', '#add8e6'] // White, red, blue

// Refs
const canvas = ref<HTMLCanvasElement | null>(null)
let ctx: CanvasRenderingContext2D | null = null
let animationFrameId: number

// Utility function to get random number within a range
function getRandom(min: number, max: number): number {
  return Math.random() * (max - min) + min
}

// Create stars array
const stars = Array.from({ length: STAR_COUNT }, () => ({
  x: getRandom(0, CANVAS_WIDTH.value),
  y: getRandom(0, CANVAS_HEIGHT.value),
  radius: getRandom(0.5, 2),
  color: COLORS[Math.floor(Math.random() * COLORS.length)],
  speed: 0.01, // Speed of movement
  initialX: 0,
  initialY: 0,
}))

// Initialize star positions
stars.forEach((star) => {
  star.initialX = star.x
  star.initialY = star.y
})

// Draw stars on canvas
function drawStars() {
  if (!ctx) {
    return
  }

  ctx.clearRect(0, 0, CANVAS_WIDTH.value, CANVAS_HEIGHT.value)

  stars.forEach((star) => {
    ctx.beginPath()
    ctx.arc(star.x, star.y, star.radius, 0, 2 * Math.PI, false)
    ctx.fillStyle = star.color
    ctx.shadowColor = star.color
    ctx.shadowBlur = 8
    ctx.fill()
    ctx.closePath()

    // Update star position to follow an inverted arc path
    star.x -= star.speed
    star.y =
      star.initialY - Math.sin((star.x / CANVAS_WIDTH.value) * Math.PI) * (CANVAS_HEIGHT.value / 4)

    // Wrap stars around edges
    if (star.x < 0) {
      star.x = CANVAS_WIDTH.value
      star.initialY = getRandom(0, CANVAS_HEIGHT.value)
    }
  })

  // Request next animation frame
  animationFrameId = requestAnimationFrame(drawStars)
}

// Set up canvas and start animation
onMounted(() => {
  if (canvas.value) {
    canvas.value.width = CANVAS_WIDTH.value
    canvas.value.height = CANVAS_HEIGHT.value
    ctx = canvas.value.getContext('2d')
    if (ctx) {
      ctx.fillStyle = 'black'
      ctx.fillRect(0, 0, CANVAS_WIDTH.value, CANVAS_HEIGHT.value)
      drawStars()
    }
  }
})

// Clean up animation on component unmount
onBeforeUnmount(() => {
  cancelAnimationFrame(animationFrameId)
})
</script>

<style scoped>
canvas {
  width: 100vw;
  height: 120vh;
}
</style>
</file>

<file path="layers/base/components/Breadcrumbs.vue">
<script lang="ts" setup>
const route = useRoute()

const generateBreadcrumbs = (path: string) => {
  const pathParts = path.split('/').filter(Boolean)
  let currentPath = ''
  return pathParts.map((part) => {
    currentPath += `/${part}`
    return {
      to: currentPath,
      label: part.charAt(0).toUpperCase() + part.slice(1),
      ariaLabel: part.charAt(0).toUpperCase() + part.slice(1),
    }
  })
}

const links = computed(() => generateBreadcrumbs(route.path))

// Prepare links by filtering and adjusting labels
const formattedLinks = computed(() => {
  if (!links.value) return []
  console.log('Formatting links', links.value)
  return links.value
    .map((link) => {
      if (!link) return null // Skip if link is undefined or null

      // Filter out the home link if in app route
      if (link.to === '/') {
        console.log('Filtering out home link', link)
        return null
      }

      // Special handling for the 'astrotribe' path
      if (link.to === '/') {
        return { ...link, label: 'Home', ariaLabel: 'Home' }
      }

      if (link.to === '/ask') {
        return { ...link, label: 'Q&A', ariaLabel: 'Q&A' }
      }

      return link // Return unmodified link
    })
    .filter(Boolean) // Remove null entries
})
</script>

<template>
  <PrimeBreadcrumb
    v-if="formattedLinks.length"
    :model="formattedLinks"
    :pt="{
      root: 'foreground p-0 flex items-center justify-start',
      menu: '!mb-0',
    }"
  >
    <template #item="{ item }">
      <NuxtLink :to="item.to">
        <span
          class="text-primary font-semibold"
          :class="item.current ? 'link-active' : ''"
        >
          {{ item.label }}
        </span>
      </NuxtLink>
    </template>
  </PrimeBreadcrumb>
</template>

<style></style>
</file>

<file path="layers/base/components/Glass.vue">
<script setup lang="ts">
const uniqueId = useId()

const tailwindColors = [
  'slate',
  'gray',
  'zinc',
  'neutral',
  'stone',
  'red',
  'orange',
  'amber',
  'yellow',
  'lime',
  'green',
  'emerald',
  'teal',
  'cyan',
  'sky',
  'blue',
  'indigo',
  'violet',
  'purple',
  'fuchsia',
  'pink',
  'rose',
  'primary', // Assuming you have a custom 'primary' color
] as const

type TailwindColor = (typeof tailwindColors)[number]

const props = defineProps({
  color: { type: String as PropType<TailwindColor>, default: 'slate' },
  bgOpacity: { type: Number, default: 20 },
  gradientOpacity: { type: Number, default: 10 },
  blurIntensity: { type: String, default: 'md' },
  disableHover: { type: Boolean, default: false },
  padding: { type: String, default: '6' },
  loading: { type: Boolean, default: false },
  ariaLabel: { type: String, default: 'Glass card' },
})

const cardRef = ref<HTMLElement | null>(null)
const gravityAreaRef = ref<HTMLElement | null>(null)

const {
  handleMouseMove,
  handleMouseLeave,
  cardStyle,
  spotlightStyle,
  bgClasses,
  borderClasses,
  textClasses,
  gradientClasses,
  hoverClasses,
} = useGlassCard(props, uniqueId)
</script>

<template>
  <div
    :id="uniqueId"
    class="relative"
  >
    <div
      ref="gravityAreaRef"
      class="pointer-events-none absolute -inset-[30%] z-0"
    ></div>
    <div
      ref="cardRef"
      :class="[
        'glass-card relative overflow-hidden rounded-md shadow-xl',
        'ring-2 ring-inset ring-white/10',
        `backdrop-blur-${blurIntensity}`,
        `p-${padding}`,
        bgClasses,
        borderClasses,
        textClasses,
        ...hoverClasses,
      ]"
      :style="cardStyle"
      role="region"
      :aria-label="ariaLabel"
      @mousemove="(e) => handleMouseMove(e)"
      @mouseleave="handleMouseLeave"
    >
      <div class="glass-card-content relative z-20">
        <slot name="header"></slot>
        <slot></slot>
      </div>
      <div
        :class="['absolute inset-0 z-10 h-full w-full bg-gradient-to-br', gradientClasses]"
      ></div>
      <div
        class="glass-effect"
        :style="spotlightStyle"
      ></div>
      <div
        v-if="loading"
        class="animate-shimmer absolute inset-0 bg-gradient-to-r from-transparent via-white/10 to-transparent"
      ></div>
    </div>
  </div>
</template>

<style scoped>
.glass-card {
  transition: all 0.3s ease;
}

.glass-effect {
  position: absolute;
  inset: 0;
  pointer-events: none;
  transition: opacity 0.2s;
}

.glass-card-content {
  transition: transform 0.3s ease;
}

.glass-card:hover .glass-card-content {
  transform: translateY(-5px);
}

@keyframes shimmer {
  0% {
    transform: translateX(-100%);
  }
  100% {
    transform: translateX(100%);
  }
}

.animate-shimmer {
  animation: shimmer 1.5s infinite;
}

.spotlight {
  backdrop-filter: blur(2px) contrast(1.2);
  mix-blend-mode: overlay;
}
</style>
</file>

<file path="layers/base/components/GlobalTimer.vue">
<script setup lang="ts">
const isVisible = ref(true)
const isTracking = ref(false)
const elapsedTime = ref(0)
const currentTask = ref('')
let timer: NodeJS.Timeout | null = null
let startTime: number
let pausedTime = 0

function startTimer() {
  if (!import.meta.client) return

  if (!isTracking.value) {
    isTracking.value = true
    startTime = Date.now() - pausedTime
    timer = setInterval(() => {
      elapsedTime.value = Math.floor((Date.now() - startTime) / 1000)
    }, 1000)
  }
}

function pauseTimer() {
  if (isTracking.value) {
    isTracking.value = false
    if (timer) {
      clearInterval(timer)
      timer = null
    }
    pausedTime = Date.now() - startTime
  }
}

function stopTimer() {
  isTracking.value = false
  isVisible.value = false
  if (timer) {
    clearInterval(timer)
    timer = null
  }
  elapsedTime.value = 0
  pausedTime = 0
  currentTask.value = ''
}

function showTimer(taskTitle: string) {
  currentTask.value = taskTitle
  isVisible.value = true
  startTimer()
}

function formatTime(seconds: number) {
  const hours = Math.floor(seconds / 3600)
  const minutes = Math.floor((seconds % 3600) / 60)
  const secs = seconds % 60
  return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`
}

onUnmounted(() => {
  if (timer) clearInterval(timer)
})

defineExpose({
  showTimer,
  stopTimer,
})
</script>

<template>
  <div
    v-if="isVisible"
    class="flex items-center gap-2 rounded-lg bg-gray-800 p-2 text-white shadow-lg"
  >
    <div class="text-sm font-bold">
      {{ currentTask }}
    </div>
    <div class="text-xl"> ⏱️ {{ formatTime(elapsedTime) }} </div>
    <div class="flex space-x-2">
      <PrimeButton
        v-if="!isTracking"
        size="small"
        class="rounded-full bg-green-500 p-2 hover:bg-green-600"
        @click="startTimer"
      >
        <Icon
          name="mdi:play"
          size="24px"
        />
      </PrimeButton>
      <PrimeButton
        v-else
        size="small"
        class="rounded-full bg-yellow-500 p-2 hover:bg-yellow-600"
        @click="pauseTimer"
      >
        <Icon
          name="mdi:pause"
          size="24px"
        />
      </PrimeButton>
      <PrimeButton
        size="small"
        class="rounded-full bg-red-500 p-2 hover:bg-red-600"
        @click="stopTimer"
      >
        <Icon
          name="mdi:stop"
          size="24px"
        />
      </PrimeButton>
    </div>
  </div>
</template>
</file>

<file path="layers/base/components/Grid.vue">
<script setup lang="ts"></script>

<template>
  <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 2xl:grid-cols-4 md:gap-4 xl:gap-8">
    <slot />
  </div>
</template>

<style scoped></style>
</file>

<file path="layers/base/components/HelloWorld.vue">
<script setup lang="ts">
const { myLayer } = useAppConfig()
</script>

<template>
  <div>
    <h1>Hello World!</h1>
    <pre>{{ myLayer }}</pre>
  </div>
</template>
</file>

<file path="layers/base/components/HoverCard.vue">
<script setup lang="ts">
const enableHoverEffect = ref(false)
const hoverPosition = ref(null as null | 'up' | 'down') // 'up', 'center', or 'down'

function checkHoverPosition(event) {
  if (!enableHoverEffect.value) {
    return // Do nothing if hover effects are disabled
  }
  const rect = event.target.getBoundingClientRect()
  const halfScreen = window.innerHeight / 2
  if (rect.top < halfScreen) {
    console.log('top')
    // If the card is in the top third, expand downwards
    hoverPosition.value = 'down'
  } else {
    console.log('bottom')
    // If the card is in the bottom third, expand upwards
    hoverPosition.value = 'up'
  }
}

const checkScreenSize = () => {
  enableHoverEffect.value = window.innerWidth >= 1024 // Tailwind's 'lg' breakpoint
}

const paddingSize = computed(() => (window.innerWidth >= 1280 ? 32 : 16))

onMounted(() => {
  window.addEventListener('resize', checkScreenSize)
  checkScreenSize()
  return () => window.removeEventListener('resize', checkScreenSize)
})

// ui:med:easy:1 - if there is only one card in the grid row, we need to set min h of 100% to prevent the card from collapsing
</script>

<template>
  <div
    class="group relative hover:z-50"
    @mouseenter="checkHoverPosition"
    @mouseleave="hoverPosition = null"
  >
    <div
      :class="[
        'transition-all duration-300 delay-200 p-4 border-b-2 md:border border-color overflow-hidden background',
        'flex flex-col gap-4 w-full h-full md:rounded-md md:shadow-md',
        {
          'lg:group-hover:absolute': enableHoverEffect && !!hoverPosition,
          'top-0': enableHoverEffect && hoverPosition === 'down',
          'bottom-0': enableHoverEffect && hoverPosition === 'up',
        },
      ]"
      :style="{
        height: enableHoverEffect && !!hoverPosition ? `calc(200% + ${paddingSize}px)` : '100%',
      }"
    >
      <slot></slot>
    </div>
  </div>
</template>

<style scoped>
/* Extra styles if needed */
</style>
</file>

<file path="layers/base/components/Image.vue">
<script lang="ts" setup>
const uuid = useId()

const props = defineProps({
  img: {
    type: Object,
    required: true,
  },
  noShrink: {
    type: Boolean,
    default: false,
  },
})

const imageUrl = ref(null)

watch(
  () => props.img.src,
  (newVal) => {
    imageUrl.value = newVal
  },
  { immediate: true },
)

function loadFallbackImage(error: Error) {
  console.error('Image loading error:', error)
  imageUrl.value = `images/defaults/${props.img.type ?? 'fallback'}.jpg`
}
</script>

<template>
  <NuxtImg
    v-if="imageUrl"
    :key="`image-${uuid}`"
    v-bind="$attrs"
    :src="imageUrl"
    :alt="img.alt"
    :width="img.width"
    :height="img.height"
    :format="img.format"
    :quality="img.quality"
    :loading="img.loading"
    crossorigin="anonymous"
    :class="{ 'flex shrink-0': !noShrink }"
    @error="loadFallbackImage"
  />
</template>
</file>

<file path="layers/base/components/InfiniteScroll.vue">
<script setup lang="ts">
const emit = defineEmits(['update:scrollEnd'])
const scrollContainer = ref<HTMLElement | null>(null)
const observer = ref<IntersectionObserver | null>(null)

onMounted(() => {
  if ('IntersectionObserver' in window) {
    observer.value = new IntersectionObserver(
      (entries) => {
        if (entries[0].isIntersecting) {
          emit('update:scrollEnd')
        }
      },
      {
        root: null,
        rootMargin: '200px', // Load more content when within 200px of the bottom
        threshold: 0.1, // Trigger when at least 10% of the target is visible
      },
    )

    if (scrollContainer.value) {
      observer.value.observe(scrollContainer.value)
    }
  } else {
    // Fallback for browsers that don't support IntersectionObserver
    window.addEventListener('scroll', handleScroll)
  }
})

onUnmounted(() => {
  if (observer.value && scrollContainer.value) {
    observer.value.unobserve(scrollContainer.value)
  }
  window.removeEventListener('scroll', handleScroll)
})

const handleScroll = () => {
  if (scrollContainer.value) {
    const rect = scrollContainer.value.getBoundingClientRect()
    if (rect.top <= window.innerHeight) {
      emit('update:scrollEnd')
    }
  }
}
</script>

<template>
  <div>
    <slot />
    <div
      ref="scrollContainer"
      class="h-10 bg-transparent"
      aria-hidden="true"
    />
  </div>
</template>
</file>

<file path="layers/base/components/Loader.vue">
<script setup lang="ts">
const loaderWidth = ref('100%')
const loaderHeight = ref('100%')

defineProps({
  width: {
    type: String,
    default: '100%',
  },
  height: {
    type: String,
    default: '100%',
  },
})
</script>

<template>
  <div
    class="skeleton-loader"
    :style="{ width: loaderWidth, height: loaderHeight }"
  ></div>
</template>

<style scoped>
.skeleton-loader {
  background-color: #f3f3f3;
  animation: skeleton-loading 1s infinite linear;
}

@keyframes skeleton-loading {
  0% {
    background-position: -200px 0;
  }
  100% {
    background-position: 200px 0;
  }
}
</style>
</file>

<file path="layers/base/components/Modal.vue">
<script setup lang="ts">
const isOpen = ref(false)

const toggleModalOpen = () => {
  isOpen.value = !isOpen.value
}

const options = ref({
  isOpen,
  toggleModalOpen,
})
</script>

<template>
  <div>
    <slot
      name="button"
      v-bind="options"
    />
    <PrimeDialog
      v-model:visible="isOpen"
      modal
      :pt="{
        root: 'max-w-2xl w-full',
        content: 'w-full aspect-square',
      }"
      :pt-options="{ mergeProps: true, mergeSections: true }"
    >
      <template #header>
        <slot name="modal:header" />
      </template>
      <slot name="modal:default" />
      <template #footer>
        <slot
          name="modal:footer"
          v-bind="options"
        />
      </template>
    </PrimeDialog>
  </div>
</template>

<style scoped></style>
</file>

<file path="layers/base/components/NavHamburger.vue">
<!-- components/nav/NavHamburger.vue -->
<template>
  <button
    class="md:hidden p-2 hover:bg-gray-800 rounded-lg transition-colors flex"
    @click="toggleMobileNav"
  >
    <Icon
      :name="isMobileSidebarOpen ? 'mdi:close' : 'mdi:menu'"
      size="24px"
    />
  </button>
</template>

<script setup lang="ts">
const { isMobileSidebarOpen } = useNavigation()

const toggleMobileNav = () => {
  isMobileSidebarOpen.value = !isMobileSidebarOpen.value
}
</script>
</file>

<file path="layers/base/components/NewLabel.vue">
<script setup lang="ts">
const props = defineProps({
  date: {
    type: String,
    required: true,
  },
  maxAge: {
    type: Number,
    required: true,
  },
})

const isWithinNumberOfDays = computed(() => {
  const currentDate = new Date()
  const itemDate = new Date(props.date)
  const differenceInDays = Math.floor(
    (currentDate.getTime() - itemDate.getTime()) / (1000 * 3600 * 24),
  )
  return differenceInDays <= props.maxAge
})
</script>

<template>
  <PrimeTag
    v-if="isWithinNumberOfDays"
    severity="success"
    value="NEW"
  />
</template>
</file>

<file path="layers/base/components/Pagination.vue">
<script setup>
import { onMounted, ref } from 'vue'
import { useRoute } from 'vue-router'

// todo:high:1 - implement and test on component

const route = useRoute()
const slug = route.params.slug // Dynamic slug based on the current route
const items = ref([])
const currentPage = ref(1)

// Store and restore pagination state using session storage
const sessionStorageKey = `pagination-${slug}`

function restoreState() {
  const savedState = sessionStorage.getItem(sessionStorageKey)
  if (savedState) {
    const state = JSON.parse(savedState)
    currentPage.value = state.currentPage
    items.value = state.items
  }
}

function storeState() {
  const state = {
    currentPage: currentPage.value,
    items: items.value,
  }
  sessionStorage.setItem(sessionStorageKey, JSON.stringify(state))
}

async function fetchItems() {
  // Placeholder function to simulate fetching items
  const newItems = [{ id: Date.now(), content: `Item ${currentPage.value}` }]
  items.value.push(...newItems)
  currentPage.value += 1
  storeState()
}

function loadMore() {
  fetchItems()
}

onMounted(() => {
  restoreState()
  if (items.value.length === 0) {
    fetchItems()
  }
})
</script>

<template>
  <div>
    <ul v-if="items.length">
      <li
        v-for="item in items"
        :key="item.id"
      >
        {{ item.content }}
      </li>
    </ul>
    <button @click="loadMore"> Load More </button>
  </div>
</template>
</file>

<file path="layers/base/components/Popover.vue">
<script setup lang="ts">
const props = defineProps({
  buttonLabel: { type: String, required: true },
})

const popover = ref(null)

const toggle = (event) => {
  popover.value?.toggle(event)
}
</script>

<template>
  <div>
    <PrimeButton
      type="button"
      size="small"
      severity="secondary"
      :label="buttonLabel"
      @click="toggle"
    />
    <PrimePopover ref="popover">
      <slot></slot>
    </PrimePopover>
  </div>
</template>

<style scoped></style>
</file>

<file path="layers/base/components/Resizable.vue">
<script lang="ts" setup>
const props = defineProps<{
  slots: Record<string, string>
}>()

const container = ref<HTMLElement | null>(null)
const resizer = ref<HTMLElement | null>(null)
const sizes = ref<number[]>([1, 1])

const startResize = (e: MouseEvent) => {
  e.preventDefault()
  window.addEventListener('mousemove', resize)
  window.addEventListener('mouseup', stopResize)
}

const resize = (e: MouseEvent) => {
  if (!container.value) return
  const containerRect = container.value.getBoundingClientRect()
  const newLeftWidth = e.clientX - containerRect.left
  const containerWidth = containerRect.width

  sizes.value = [newLeftWidth / containerWidth, 1 - newLeftWidth / containerWidth]
}

const stopResize = () => {
  window.removeEventListener('mousemove', resize)
  window.removeEventListener('mouseup', stopResize)
}

onMounted(() => {
  if (resizer.value) {
    resizer.value.addEventListener('mousedown', startResize)
  }
})

onUnmounted(() => {
  if (resizer.value) {
    resizer.value.removeEventListener('mousedown', startResize)
  }
  window.removeEventListener('mousemove', resize)
  window.removeEventListener('mouseup', stopResize)
})
</script>

<template>
  <div
    ref="container"
    class="relative flex h-full w-full"
  >
    <div
      v-for="(componentId, index) in Object.values(slots)"
      :key="componentId"
      :class="['overflow-auto', index === 0 ? 'pr-4' : 'pl-4']"
      :style="{ flex: sizes[index] }"
    >
      <slot :name="componentId"></slot>
    </div>
    <div
      ref="resizer"
      class="w-2 cursor-col-resize bg-gray-200 hover:bg-gray-300"
      @mousedown="startResize"
    ></div>
  </div>
</template>

<style scoped>
/* Add any additional styles here */
</style>
</file>

<file path="layers/base/components/Sidebar.vue">
<script setup lang="ts">
const isSideVisible = ref(true)
</script>

<template>
  <div class="top-0 space-y-4 p-8 md:sticky">
    <div class="flex flex-col justify-center md:justify-start">
      <div class="flex gap-4">
        <!-- <PrimeToggleButton
          v-model="isSideVisible"
          on-label="Hide"
          off-label="Show"
        >
          <Icon :name="isSideVisible ? 'mdi:eye' : 'mdi:sun'" />
        </PrimeToggleButton> -->
        <!-- <Transition name="slide-fade">
          <PrimeMessage
            v-show="isSideVisible"
            severity="info"
            :pt="{ root: '', text: 'text-sm text-left' }"
          >
            Filters Coming Soon
          </PrimeMessage>
        </Transition> -->
      </div>
    </div>
  </div>
</template>

<style scoped>
/*
  Enter and leave animations can use different
  durations and timing functions.
*/
.slide-fade-enter-active {
  transition: all 0.3s ease-out;
}

.slide-fade-leave-active {
  transition: all 0.8s cubic-bezier(1, 0.5, 0.8, 1);
}

.slide-fade-enter-from,
.slide-fade-leave-to {
  transform: translateX(-20px);
  opacity: 0;
}

.slide-top-enter-active {
  transition: all 0.3s ease-out;
}

.slide-top-leave-active {
  transition: all 0.8s cubic-bezier(1, 0.5, 0.8, 1);
}

.slide-top-enter-from,
.slide-top-leave-to {
  transform: translateY(-20px);
  opacity: 0;
}
</style>
</file>

<file path="layers/base/components/SideNav.vue">
<script setup lang="ts">
const props = defineProps({
  categories: {
    type: Array,
    required: true,
  },
  showDevHelpers: {
    type: Boolean,
    default: false,
  },
  isMobile: {
    type: Boolean,
    default: false,
  },
  isSidebarOpen: {
    type: Boolean,
    required: true,
  },
  isMobileSidebarOpen: {
    type: Boolean,
    required: true,
  },
})

const route = useRoute()
const emit = defineEmits(['update:isSidebarOpen', 'update:isMobileSidebarOpen'])
// Handle navigation - close mobile nav when navigating
const handleNavigation = () => {
  if (props.isMobile) {
    emit('update:isMobileSidebarOpen', false)
  }
}

// Watch route changes to close mobile nav
watch(
  () => route.path,
  () => {
    if (props.isMobile) {
      emit('update:isMobileSidebarOpen', false)
    }
  },
)
</script>

<template>
  <div class="relative z-50">
    <!-- Mobile Overlay -->
    <div
      v-if="isMobile"
      class="fixed inset-0 z-[90] bg-black/50 transition-opacity duration-300"
      :class="
        isMobileSidebarOpen ? 'opacity-100 pointer-events-auto' : 'opacity-0 pointer-events-none'
      "
      @click="$emit('update:isMobileSidebarOpen', false)"
    />
    <div
      class="flex flex-col background text-gray-300 shadow-lg transition-all duration-300 group"
      :class="[
        // Shared styles
        'h-full',

        // Mobile styles
        isMobile && [
          'fixed left-0 top-0 bottom-0 z-[100]',
          'w-[70vw]',
          isMobileSidebarOpen ? 'translate-x-0' : '-translate-x-full',
        ],

        // Desktop styles
        !isMobile && ['relative', 'md:translate-x-0', isSidebarOpen ? 'md:w-60' : 'md:w-14'],
      ]"
    >
      <!-- Toggle button (desktop only) -->
      <button
        v-if="!isMobile"
        class="absolute !z-[1000] -right-3 top-24 hidden h-6 w-6 -translate-y-1/2 items-center justify-center rounded-full bg-primary-600 text-gray-300 transition-opacity duration-300 hover:bg-primary-400 group-hover:opacity-100 md:flex"
        :class="[
          'z-[110]', // Ensure button is above other elements
          isSidebarOpen ? 'opacity-0' : 'opacity-100',
        ]"
        :title="isSidebarOpen ? 'Collapse sidebar' : 'Expand sidebar'"
        @click="$emit('update:isSidebarOpen', !isSidebarOpen)"
      >
        <Icon
          :name="isSidebarOpen ? 'mdi:chevron-left' : 'mdi:chevron-right'"
          size="12px"
        />
      </button>

      <div class="flex h-full flex-col overflow-hidden">
        <!-- Logo -->
        <div
          class="flex items-center px-4 py-3 transition-all duration-300"
          :class="isMobile || isSidebarOpen ? 'gap-3' : 'justify-center'"
        >
          <div
            class="flex items-center justify-center rounded-md border bg-white transition-all duration-300 delay-150"
            :class="isMobile || isSidebarOpen ? 'h-10 w-10' : 'h-6 w-6'"
          >
            <NuxtLink
              to="/"
              class="flex h-full w-full items-center justify-center"
            >
              <IBImage
                :img="{ src: '/astronera-logo.jpg', width: 36, height: 36 }"
                class="h-full w-full transition-all duration-300"
                :class="isMobile || isSidebarOpen ? 'p-0.5' : 'p-1'"
                no-shrink
              />
            </NuxtLink>
          </div>
          <Transition
            enter-active-class="transition-all duration-150 ease-out"
            leave-active-class="transition-all duration-150 ease-in"
            enter-from-class="opacity-0 -translate-x-4"
            leave-to-class="opacity-0 -translate-x-4"
          >
            <div
              v-if="isMobile || isSidebarOpen"
              class="flex cursor-pointer flex-col items-start justify-center text-sm font-bold uppercase leading-none tracking-normal"
            >
              Astron
              <strong class="font-extrabold text-primary-400">Era</strong>
            </div>
          </Transition>
        </div>

        <!-- Navigation Categories - always expanded on mobile -->
        <nav class="flex-1 space-y-4 px-2 py-4">
          <div
            v-for="category in categories"
            :key="category.id"
            class="space-y-1"
          >
            <div
              v-if="isMobile || isSidebarOpen"
              class="px-2 text-xs font-semibold uppercase text-gray-400"
            >
              {{ category.label }}
            </div>
            <ul>
              <li
                v-for="item in category.items"
                :key="item.slug"
              >
                <NuxtLink
                  :to="item.slug"
                  class="flex items-center rounded-lg px-2 py-2 text-sm font-medium hover:bg-primary-700"
                  :class="{ 'bg-primary-800': route.path === item.slug }"
                  @click="handleNavigation"
                >
                  <Icon
                    :name="item.icon"
                    size="20px"
                    class="mr-3 flex-shrink-0"
                  />
                  <span v-if="isMobile || isSidebarOpen">{{ item.label }}</span>
                </NuxtLink>
              </li>
            </ul>
          </div>
        </nav>
      </div>
    </div>
  </div>
</template>

<style>
.transition-transform {
  transition-property: transform, width, height;
}
</style>
</file>

<file path="layers/base/components/SocialBlock.vue">
<script setup lang="ts">
interface Socials {
  [key: string]: string
}

const props = defineProps({
  socials: {
    type: Object as PropType<Socials>,
    required: true,
  },
  size: {
    type: String,
    default: '24px',
  },
})

const socialIcon = (platform: string) => {
  switch (platform) {
    case 'linkedin':
      return 'mdi:linkedin'
    case 'youtube':
      return 'mdi:youtube'
    case 'instagram':
      return 'mdi:instagram'
    case 'facebook':
      return 'mdi:facebook'
    case 'twitter':
      return 'mdi:twitter'
    default:
      return ''
  }
}

const formattedSocials = computed(() => {
  if (!props.socials) return []
  return Object.entries(props.socials).map(([platform, url]) => {
    return {
      platform: platform.split('_')[0],
      url,
      icon: socialIcon(platform.split('_')[0]),
    }
  })
})
</script>

<template>
  <div
    v-if="formattedSocials.length > 0"
    class="flex gap-2"
  >
    <a
      v-for="social in formattedSocials"
      :key="`${social.platform}-icon`"
      class="flex cursor-pointer items-center"
      target="_blank"
      :href="social.url"
    >
      <Icon
        :name="social.icon"
        :size="size"
      />
    </a>
  </div>
</template>

<style scoped></style>
</file>

<file path="layers/base/components/TabView.vue">
<script setup lang="ts">
interface Tab {
  title: string
  slotName: string
  value: string
}

defineProps<{
  tabs: Tab[]
}>()
</script>

<template>
  <PrimeTabs
    value="0"
    class="h-full"
    scrollable
    :pt="{
      root: 'w-full h-full',
    }"
    :pt-options="{ mergeSections: true }"
  >
    <PrimeTabList
      :pt="{
        root: 'gap-4 sticky top-0 left-0 z-50 flex text-nowrap flex-grow w-full overflow-scroll bg-black no-scrollbar border-b border-color',
      }"
      :pt-options="{ mergeSections: true, mergeProps: true }"
    >
      <PrimeTab
        v-for="tab in tabs"
        :key="tab.title"
        :value="tab.value"
        :pt="{
          root: ({ context }) => ({
            class: [
              'text-nowrap px-6 py-4 border-x border-color h-full',
              { 'bg-primary-900': context.active },
            ],
          }),
        }"
        :pt-options="{ mergeSections: true, mergeProps: true }"
      >
        {{ tab.title }}
      </PrimeTab>
    </PrimeTabList>
    <PrimeTabPanel
      v-for="tab in tabs"
      :key="`tab-index-${tab.title}`"
      :value="tab.value"
      :pt="{
        root: 'overflow-scroll h-full',
      }"
      :pt-options="{ mergeProps: true, mergeSections: true }"
    >
      <slot :name="tab.slotName" />
    </PrimeTabPanel>
  </PrimeTabs>
</template>

<style></style>
</file>

<file path="layers/base/components/YT.client.vue">
<template>
  <div id="player"></div>
</template>

<script setup lang="ts">
const player = ref(null)

onMounted(() => {
  // Load the YouTube IFrame API dynamically if it's not already loaded
  if (!window.YT) {
    // Check if YT object is already present
    const tag = document.createElement('script')
    tag.src = 'https://www.youtube.com/iframe_api'
    const firstScriptTag = document.getElementsByTagName('script')[0]
    firstScriptTag.parentNode.insertBefore(tag, firstScriptTag)

    // Define the callback globally to initialize player when API is ready
    window.onYouTubeIframeAPIReady = initializePlayer
  } else {
    // Initialize the player immediately if YT is already loaded
    initializePlayer()
  }
})

function initializePlayer() {
  // Make sure the YT object and YT.Player are defined
  if (typeof YT !== 'undefined' && YT.Player) {
    player.value = new YT.Player('player', {
      // Ensure the element ID matches your template
      height: '390',
      width: '640',
      listType: 'user_uploads',
      list: 'Fireship', // Make sure 'Fireship' is a correct videoId or replace it with a valid one
      events: {
        onReady: onPlayerReady,
      },
    })
  }
}

function onPlayerReady(event) {
  event.target.playVideo()
}

onBeforeUnmount(() => {
  if (player.value) {
    player.value.destroy()
  }
})
</script>
</file>

<file path="layers/base/composables/utils/arrays.ts">
export const removeDuplicates = <T>(arr: T[]): T[] => [...new Set(arr)]

export const sortBy = <T, K extends keyof T>(arr: T[], key: K): T[] =>
  arr.sort((a, b) => (a[key] > b[key] ? 1 : a[key] < b[key] ? -1 : 0))
</file>

<file path="layers/base/composables/utils/hasValueChanged.ts">
export function deepEqual(obj1: any, obj2: any): boolean {
  if (obj1 === obj2) {
    return true
  }

  if (typeof obj1 !== 'object' || typeof obj2 !== 'object' || obj1 === null || obj2 === null) {
    return false
  }

  if (Array.isArray(obj1) && Array.isArray(obj2)) {
    if (obj1.length !== obj2.length) {
      return false
    }
    for (let i = 0; i < obj1.length; i++) {
      if (!deepEqual(obj1[i], obj2[i])) {
        return false
      }
    }
    return true
  }

  if (Array.isArray(obj1) || Array.isArray(obj2)) {
    return false // One is an array, the other is not
  }

  const keys1 = Object.keys(obj1)
  const keys2 = Object.keys(obj2)

  if (keys1.length !== keys2.length) {
    return false
  }

  for (const key of keys1) {
    if (!keys2.includes(key) || !deepEqual(obj1[key], obj2[key])) {
      return false
    }
  }

  return true
}

export function hasValueChanged(newValue: any, currentValue: any): boolean {
  if (
    typeof newValue === 'string'
    || typeof newValue === 'boolean'
    || typeof newValue === 'number'
    || newValue === null
  ) {
    return newValue !== currentValue
  }

  if (Array.isArray(newValue) || typeof newValue === 'object') {
    return !deepEqual(newValue, currentValue)
  }

  return newValue !== currentValue
}

interface UpdateData {
  [key: string]: any
}

interface CleanDataResult {
  data: UpdateData
  noDataUpdated: boolean
}

export function wasRowDataUpdated(newData: UpdateData, previousData: UpdateData): CleanDataResult {
  const updatedData: UpdateData = {}

  Object.entries(newData).forEach(([key, value]) => {
    if (hasValueChanged(value, previousData[key])) {
      updatedData[key] = value
    }
  })

  return { data: updatedData, noDataUpdated: Object.keys(updatedData).length === 0 }
}
</file>

<file path="layers/base/composables/utils/objects.ts">
export const pluck = <T, K extends keyof T>(objs: T[], key: K): T[K][] =>
  objs.map((obj) => obj[key])
</file>

<file path="layers/base/composables/utils/strings.ts">
export const slugify = (str: string): string => {
  str = str.replace(/^\s+|\s+$/g, '')
  str = str.toLowerCase()

  const from
    = 'ÁÄÂÀÃÅČÇĆĎÉĚËÈÊẼĔȆÍÌÎÏŇÑÓÖÒÔÕØŘŔŠŤÚŮÜÙÛÝŸŽáäâàãåčçćďéěëèêẽĕȇíìîïňñóöòôõøðřŕšťúůüùûýÿžþÞĐđßÆa·/_,:;'
  const to
    = 'AAAAAACCCDEEEEEEEEIIIINNOOOOOORRSTUUUUUYYZaaaaaacccdeeeeeeeeiiiinnooooooorrstuuuuuyyzbBDdBAa------'
  for (let i = 0, l = from.length; i < l; i++) {
    str = str.replace(new RegExp(from.charAt(i), 'g'), to.charAt(i))
  }

  str = str
    .replace(/[^a-z0-9 -]/g, '')
    .replace(/\s+/g, '-')
    .replace(/-+/g, '-')
  return str
}

export function upperCaseFirstLetter(str: string): string {
  const firstLetter = str.slice(0, 1)
  return firstLetter.toUpperCase() + str.substring(1)
}

export const stringIsNull = (value: any): boolean =>
  value === null || value === undefined || value === '' || value.length === 0
</file>

<file path="layers/base/composables/utils/time.ts">
export function toDateObject(inputDate = '2022-03-01T10:30:00-05:00') {
  // !todo - add support for internationalization
  // !todo - add support for dynamic length
  const length = 'short'
  // convert date to local time
  const date = new Date(inputDate.toLocaleString())

  const formattedDate = new Intl.DateTimeFormat('en-US', {
    weekday: length,
    year: 'numeric',
    month: length,
    day: 'numeric',
    hour: 'numeric',
    minute: 'numeric',
    timeZoneName: length,
  }).format(date)

  const dateArray = formattedDate.split(', ')

  return {
    weekday: dateArray[0],
    month: dateArray[1].split(' ')[0],
    day: dateArray[1].split(' ')[1],
    time: dateArray[3].split(' ')[0],
    ampm: dateArray[3].split(' ')[1],
    timezone: dateArray[3].split(' ')[2],
    year: dateArray[2],
  }
}

export function lastSeen(lastSeenTimestamp: string): string {
  const now = new Date()
  const lastSeen = new Date(lastSeenTimestamp)
  const secondsSinceLastSeen = Math.round((now.getTime() - lastSeen.getTime()) / 1000)

  if (secondsSinceLastSeen < 60) {
    return `${secondsSinceLastSeen} second${secondsSinceLastSeen === 1 ? '' : 's'} ago`
  }

  const minutesSinceLastSeen = Math.round(secondsSinceLastSeen / 60)

  if (minutesSinceLastSeen < 60) {
    return `${minutesSinceLastSeen} minute${minutesSinceLastSeen === 1 ? '' : 's'} ago`
  }

  const hoursSinceLastSeen = Math.round(minutesSinceLastSeen / 60)

  if (hoursSinceLastSeen < 24) {
    return `${hoursSinceLastSeen} hour${hoursSinceLastSeen === 1 ? '' : 's'} ago`
  }

  const daysSinceLastSeen = Math.round(hoursSinceLastSeen / 24)
  return `${daysSinceLastSeen} day${daysSinceLastSeen === 1 ? '' : 's'} ago`
}
</file>

<file path="layers/base/composables/ab-test.ts">
import type { DefineComponent } from 'vue'

export enum TestGoal {
  SignUp = 'sign_up',
  Purchase = 'purchase',
  FeatureUsage = 'feature_usage',
  TimeOnPage = 'time_on_page',
  ClickThroughRate = 'click_through_rate',
}

interface ABTestVariant<T> {
  name: string
  value: T
}

interface ABTestConfig<T> {
  experimentName: string
  variants: ABTestVariant<T>[]
  defaultVariant: ABTestVariant<T>
  goals: TestGoal[]
}

export function useABTest<T>({ experimentName, variants, defaultVariant, goals }: ABTestConfig<T>) {
  const { $posthog } = useNuxtApp()

  const selectedVariant = ref<ABTestVariant<T>>(defaultVariant)

  // Use PostHog's experiment feature to get the variant
  const variantName = $posthog.getFeatureFlag(experimentName)
  selectedVariant.value = variants.find((v) => v.name === variantName) || defaultVariant

  // Capture experiment exposure
  $posthog.capture('$experiment_started', {
    experiment: experimentName,
    variant: selectedVariant.value.name,
    goals: goals,
  })

  const value = computed(() => selectedVariant.value.value)

  // Function to track goal completion
  const trackGoal = (goal: TestGoal, properties: Record<string, any> = {}) => {
    $posthog.capture(goal, {
      ...properties,
      $experiment_name: experimentName,
      $variant: selectedVariant.value.name,
    })
  }

  return {
    variant: selectedVariant,
    value,
    trackGoal,
  }
}

// Helper function for component-based A/B tests
type ComponentVariant = ABTestVariant<DefineComponent<any, any, any>>

export function useComponentABTest(config: ABTestConfig<DefineComponent<any, any, any>>) {
  const { variant, trackGoal } = useABTest(config)

  const TestComponent = computed(() => ({
    render() {
      return h(variant.value.value.component)
    },
  }))

  return {
    TestComponent,
    trackGoal,
  }
}
</file>

<file path="layers/base/composables/analytics.ts">
import { ref, onMounted, onUnmounted } from 'vue'
import { useRoute } from 'vue-router'

export enum UserAcquisitionMetric {
  SignUpConversion = 'sign_up_conversion',
  DemoRequest = 'demo_request',
  ContactFormSubmission = 'contact_form_submission',
  FeaturePageEngagement = 'feature_page_engagement',
  BlogTraffic = 'blog_traffic',
}

export enum OnboardingMetric {
  StartRate = 'start_rate',
  StepCompletion = 'step_completion',
  DropOff = 'drop_off',
  CompletionTime = 'completion_time',
}

export enum UserEngagementMetric {
  SessionDuration = 'session_duration',
  ActionsPerSession = 'actions_per_session',
  VisitFrequency = 'visit_frequency',
  FeatureAdoption = 'feature_adoption',
}

export enum ContentPerformanceMetric {
  ArticleView = 'article_view',
  ReadTime = 'read_time',
  Share = 'share',
  Like = 'like',
  Comment = 'comment',
}

export enum JobMarketMetric {
  JobListing = 'job_listing',
  JobView = 'job_view',
  JobApplication = 'job_application',
  CompanyProfileCreation = 'company_profile_creation',
  CompanyFollow = 'company_follow',
}

export enum TechnicalPerformanceMetric {
  PageLoadTime = 'page_load_time',
  APIResponseTime = 'api_response_time',
  ErrorRate = 'error_rate',
  Uptime = 'uptime',
}

export type ContentType = 'blog_post' | 'news_article' | 'company_profile' | 'job_listing'

export type ErrorType = 'javascript_error' | 'api_error' | '404_error'

export interface AnalyticsEventProperties {
  [key: string]: any
}

export function useAnalytics() {
  const { $posthog } = useNuxtApp()
  const route = useRoute()
  const pageEnterTime = ref(Date.now())

  const trackEvent = (eventName: string, properties?: AnalyticsEventProperties) => {
    $posthog.capture(eventName, properties)
  }

  const trackPageView = (properties?: AnalyticsEventProperties) => {
    const timeSpent = Date.now() - pageEnterTime.value
    $posthog.capture('$pageview', {
      path: route.path,
      title: document.title,
      timeSpent,
      ...properties,
    })
    pageEnterTime.value = Date.now()
  }

  const identifyUser = (userId: string, properties?: AnalyticsEventProperties) => {
    $posthog.identify(userId, properties)
  }

  const trackError = (errorType: ErrorType, errorDetails: string, componentName?: string) => {
    $posthog.capture('Error Occurred', {
      errorType,
      errorDetails,
      componentName,
    })
  }

  const trackUserAcquisition = (
    metric: UserAcquisitionMetric,
    properties?: AnalyticsEventProperties,
  ) => {
    $posthog.capture(`User Acquisition - ${metric}`, properties)
  }

  const trackOnboarding = (metric: OnboardingMetric, properties?: AnalyticsEventProperties) => {
    $posthog.capture(`Onboarding - ${metric}`, properties)
  }

  const trackUserEngagement = (
    metric: UserEngagementMetric,
    properties?: AnalyticsEventProperties,
  ) => {
    $posthog.capture(`User Engagement - ${metric}`, properties)
  }

  const trackContentPerformance = (
    metric: ContentPerformanceMetric,
    contentType: ContentType,
    properties?: AnalyticsEventProperties,
  ) => {
    $posthog.capture(`Content Performance - ${contentType} - ${metric}`, properties)
  }

  const trackJobMarketActivity = (
    metric: JobMarketMetric,
    properties?: AnalyticsEventProperties,
  ) => {
    $posthog.capture(`Job Market - ${metric}`, properties)
  }

  const trackTechnicalPerformance = (
    metric: TechnicalPerformanceMetric,
    value: number,
    properties?: AnalyticsEventProperties,
  ) => {
    $posthog.capture(`Technical Performance - ${metric}`, { value, ...properties })
  }

  // Session tracking
  onMounted(() => {
    trackPageView()
    $posthog.capture('Session Started')
  })

  onUnmounted(() => {
    trackPageView()
    $posthog.capture('Session Ended', {
      sessionDuration: Date.now() - pageEnterTime.value,
    })
  })

  return {
    trackEvent,
    trackPageView,
    identifyUser,
    trackUserAcquisition,
    trackOnboarding,
    trackUserEngagement,
    trackContentPerformance,
    trackJobMarketActivity,
    trackTechnicalPerformance,
    trackError,
  }
}

// import {
//   UserAcquisitionMetric,
//   OnboardingMetric,
//   UserEngagementMetric,
//   ContentPerformanceMetric,
//   JobMarketMetric,
//   TechnicalPerformanceMetric,
//   ContentType,
//   ErrorType
// } from '~/types/analytics'

// const {
//   trackUserAcquisition,
//   trackOnboarding,
//   trackUserEngagement,
//   trackContentPerformance,
//   trackJobMarketActivity,
//   trackTechnicalPerformance,
//   trackError
// } = useAnalytics()

// // Track a sign-up conversion
// trackUserAcquisition(UserAcquisitionMetric.SignUpConversion, { source: 'organic' })

// // Track an onboarding step completion
// trackOnboarding(OnboardingMetric.StepCompletion, { step: 'personal_info', timeSpent: 120 })

// // Track a feature adoption
// trackUserEngagement(UserEngagementMetric.FeatureAdoption, { feature: 'job_search' })

// // Track a blog post share
// trackContentPerformance(ContentPerformanceMetric.Share, 'blog_post', { postId: '123', platform: 'twitter' })

// // Track a job application
// trackJobMarketActivity(JobMarketMetric.JobApplication, { jobId: '456', companyId: '789' })

// // Track page load time
// trackTechnicalPerformance(TechnicalPerformanceMetric.PageLoadTime, performance.now())

// // Track an error
// trackError(ErrorType.APIError, 'Failed to fetch job listings', 'JobSearchComponent')
</file>

<file path="layers/base/composables/glass-card.ts">
interface GlassCardProps {
  color: string
  bgOpacity: number
  gradientOpacity: number
  blurIntensity: string
  disableHover: boolean
  padding: string
  loading: boolean
  ariaLabel: string
}

const cardStates = reactive<Record<string, any>>({})

export function useGlassCard(props: GlassCardProps, uniqueId: string) {
  if (!cardStates[uniqueId]) {
    cardStates[uniqueId] = {
      tiltFactor: 0,
      mouseX: 0,
      mouseY: 0,
      isOutside: true,
      cardWidth: 0,
      cardHeight: 0,
    }
  }

  const state = cardStates[uniqueId]

  const handleMouseMove = (event: MouseEvent) => {
    const cardElement = document.getElementById(uniqueId)?.querySelector('.glass-card')
    if (!cardElement) return

    const cardRect = cardElement.getBoundingClientRect()

    state.cardWidth = cardRect.width
    state.cardHeight = cardRect.height

    const gravityArea = 100 // pixels around the card
    const x = event.clientX - cardRect.left
    const y = event.clientY - cardRect.top

    // Check if the mouse is within the gravity field
    if (
      x >= -gravityArea &&
      x <= cardRect.width + gravityArea &&
      y >= -gravityArea &&
      y <= cardRect.height + gravityArea
    ) {
      state.mouseX = x
      state.mouseY = y
      state.isOutside = false

      // Calculate distance from the edge of the card
      const distanceX = Math.max(0, -x, x - cardRect.width)
      const distanceY = Math.max(0, -y, y - cardRect.height)
      const distance = Math.sqrt(distanceX * distanceX + distanceY * distanceY)

      // Calculate tilt factor
      if (x >= 0 && x <= cardRect.width && y >= 0 && y <= cardRect.height) {
        state.tiltFactor = 1 // Cursor is directly over the card
      } else {
        // Smooth transition in the gravity area
        state.tiltFactor = Math.max(0, 1 - distance / gravityArea)
      }
    } else {
      state.tiltFactor = 0
      state.isOutside = true
    }
  }

  const handleMouseLeave = () => {
    state.tiltFactor = 0
    state.isOutside = true
  }

  const cardStyle = computed(() => {
    if (state.isOutside) return {}

    const maxTilt = 4 // maximum tilt in degrees

    // Use cardWidth and cardHeight from state instead of getting them from cardRef
    const centerX = state.cardWidth / 2
    const centerY = state.cardHeight / 2

    const tiltY = ((state.mouseX - centerX) / centerX) * maxTilt * state.tiltFactor
    const tiltX = ((centerY - state.mouseY) / centerY) * maxTilt * state.tiltFactor

    return {
      transform: `perspective(1000px) rotateX(${tiltX}deg) rotateY(${tiltY}deg)`,
      transition: state.isOutside ? 'transform 0.3s ease-out' : 'none',
    }
  })

  const spotlightColor = computed(() => {
    const hue = (state.mouseX / state.cardWidth) * 360
    return `hsl(${hue}, 100%, 70%)`
  })

  const spotlightStyle = computed(() => {
    if (state.isOutside) return { opacity: 0 }

    const spotlightSize = 300 // Fixed 300px radius
    const opacity = 0.07 + state.tiltFactor * 0.08

    return {
      background: `
      radial-gradient(circle ${spotlightSize}px at ${state.mouseX}px ${state.mouseY}px, 
      ${spotlightColor.value}, 
      transparent 70%),
      radial-gradient(circle ${spotlightSize * 0.8}px at ${state.mouseX}px ${state.mouseY}px, 
      ${spotlightColor.value}, 
      transparent 70%)
    `,
      opacity: opacity,
      transition: 'opacity 0.3s ease-out',
      mixBlendMode: 'soft-light',
    }
  })

  const bgClasses = computed(() => [
    `bg-${props.color}-950/${props.bgOpacity}`,
    `hover:bg-${props.color}-900/${props.bgOpacity + 10}`,
  ])

  const borderClasses = computed(() => [
    'border',
    'border-color',
    `hover:border-${props.color}-400/40`,
  ])

  const textClasses = computed(() => [`text-${props.color}-100`])

  const gradientClasses = computed(() => [
    `from-${props.color}-100/${props.gradientOpacity}`,
    `to-${props.color}-500/${props.gradientOpacity}`,
  ])

  const hoverClasses = computed(() =>
    props.disableHover
      ? []
      : ['hover:shadow-2xl', `hover:bg-${props.color}-800/${props.bgOpacity + 10}`],
  )

  return {
    handleMouseMove,
    handleMouseLeave,
    cardStyle,
    spotlightStyle,
    bgClasses,
    borderClasses,
    textClasses,
    gradientClasses,
    hoverClasses,
  }
}
</file>

<file path="layers/base/composables/metrics.ts">
function roundToNDecimalPlaces(value: number, n: number): number {
  return Number(value.toFixed(n))
}

function calculateMedian(arr: number[]): number {
  const sorted = arr.slice().sort((a, b) => a - b)
  const mid = Math.floor(sorted.length / 2)
  return sorted.length % 2 !== 0 ? sorted[mid] : (sorted[mid - 1] + sorted[mid]) / 2
}

function calculateStandardDeviation(valuesArray: number[]): number {
  const mean = valuesArray.reduce((a, b) => a + b) / valuesArray.length
  return Math.sqrt(
    valuesArray.map((x) => Math.pow(x - mean, 2)).reduce((a, b) => a + b) / valuesArray.length,
  )
}

function calculateMean(arr: number[]): number {
  return arr.reduce((a, b) => a + b) / arr.length
}

function calculateVariance(arr: number[]): number {
  const mean = calculateMean(arr)
  return arr.reduce((sum, value) => sum + Math.pow(value - mean, 2), 0) / arr.length
}

function calculateRange(arr: number[]): number {
  return Math.max(...arr) - Math.min(...arr)
}

function calculateSum(arr: number[]): number {
  return arr.reduce((a, b) => a + b, 0)
}

function calculateMode(arr: number[]): number | number[] {
  const frequency: { [key: number]: number } = {}
  let maxFreq = 0
  let modes: number[] = []

  arr.forEach((value) => {
    frequency[value] = (frequency[value] || 0) + 1
    if (frequency[value] > maxFreq) {
      maxFreq = frequency[value]
      modes = [value]
    } else if (frequency[value] === maxFreq) {
      modes.push(value)
    }
  })

  return modes.length === 1 ? modes[0] : modes
}

function calculateMin(arr: number[]): number {
  return Math.min(...arr)
}

function calculateMax(arr: number[]): number {
  return Math.max(...arr)
}

function calculatePercentile(arr: number[], percentile: number): number {
  if (percentile < 0 || percentile > 100) {
    throw new Error('Percentile must be between 0 and 100')
  }
  const sorted = arr.slice().sort((a, b) => a - b)
  const index = (percentile / 100) * (sorted.length - 1)
  const lower = Math.floor(index)
  const upper = lower + 1
  const weight = index % 1

  if (upper >= sorted.length) {
    return sorted[lower]
  }

  return sorted[lower] * (1 - weight) + sorted[upper] * weight
}

export function useBaseMetrics() {
  return {
    format: {
      roundToN: roundToNDecimalPlaces,
    },
    calculate: {
      median: calculateMedian,
      standardDeviation: calculateStandardDeviation,
      mean: calculateMean,
      variance: calculateVariance,
      range: calculateRange,
      sum: calculateSum,
      mode: calculateMode,
      min: calculateMin,
      max: calculateMax,
      percentile: calculatePercentile,
    },
  }
}
</file>

<file path="layers/base/composables/modal.ts">
export function useModal() {
  // was used for news modals at one point
  const currentPost = computed(() => news.value[currentIndex.value])
  const nextPost = computed(() => news.value[nextIndex.value])
  const previousPost = computed(() => news.value[previousIndex.value])
  const isModalOpen = ref(false)
  const currentIndex = ref(0)
  const previousIndex = computed(() => (currentIndex.value > 0 ? currentIndex.value - 1 : 0))
  const nextIndex = computed(() =>
    currentIndex.value < news.value.length - 1 ? currentIndex.value + 1 : currentIndex.value,
  )

  const toggleModal = (postIndex?: number) => {
    isModalOpen.value = !isModalOpen.value
    if (postIndex !== undefined) {
      currentIndex.value = postIndex
    }
  }

  const next = () => {
    if (currentIndex.value < news.value.length - 1) {
      currentIndex.value++
    }
  }

  const previous = () => {
    if (currentIndex.value > 0) {
      currentIndex.value--
    }
  }
}
</file>

<file path="layers/base/composables/notification.ts">
import type { useToast } from 'primevue/usetoast'

interface BaseNotification {
  summary: string
  message: string
}

export function useNotification() {
  const nuxtApp = useNuxtApp()
  const getToast: typeof useToast = () => nuxtApp.vueApp.config.globalProperties.$toast
  const toast = getToast()

  const success = ({ summary, message }: BaseNotification) => {
    toast.add({
      severity: 'success',
      summary: `Success: ${summary}`,
      detail: message,
      life: 5000,
      closable: true,
    })
  }

  const error = ({ summary, message }: BaseNotification) => {
    toast.add({
      severity: 'error',
      summary: `Error: ${summary}`,
      detail: message,
      life: 0,
      closable: true,
    })
  }

  const info = ({ summary, message }: BaseNotification) => {
    toast.add({
      severity: 'info',
      summary: `Info: ${summary}`,
      detail: message,
      life: 5000,
      closable: true,
    })
  }

  const warn = ({ summary, message }: BaseNotification) => {
    toast.add({
      severity: 'warn',
      summary: `Warning: ${summary}`,
      detail: message,
      life: 5000,
      closable: true,
    })
  }

  const feature = ({ summary, message }: BaseNotification) => {
    toast.add({
      severity: 'warn',
      group: 'cta',
      summary: summary,
      detail: message,
      life: 0,
      closable: true,
    })
  }

  return {
    success,
    error,
    info,
    warn,
    feature,
  }
}
</file>

<file path="layers/base/composables/settings.store.ts">
type SettingsKey = 'usersStore' | 'storeNews'

export const useSettingsStore = defineStore('settingsStore', () => {
  const settings = ref({} as Settings)
  const summaryLevel = ref('beginner' as SummaryLevel)

  function toggleSettings(key: SettingsKey) {
    settings.value[key] = !settings.value[key]
  }

  function isSettingsOn(key: SettingsKey) {
    return !settings.value[key]
  }

  const changeSummaryLevel = (level: 'beginner' | 'intermediate' | 'expert') => {
    summaryLevel.value = level
  }

  return {
    toggleSettings,
    isSettingsOn,
  }
})

if (import.meta.hot) {
  import.meta.hot.accept(acceptHMRUpdate(useSettingsStore, import.meta.hot))
}
</file>

<file path="layers/base/composables/social.store.ts">
import { useLogger } from '@ib/logger'

export const useSocialStore = defineStore('settingsStore', () => {
  const errors = useBaseError()
  const logger = useLogger('useSocialStore')
  const { fetch } = useBaseFetch()

  const youtube = ref({})
  async function getYoutubeAnalytics(channelName: string) {
    logger.info(`getting youtube analytics for ${channelName}`)
    const response = await fetch('/api/social/youtube/analytics', {
      method: 'GET',
      query: {
        channelName,
      },
    })

    const data = errors.server({
      response,
      devOnly: false,
      devMessage: 'error getting youtube analytics',
      userMessage: 'something went wrong when getting youtube analytics',
    })

    youtube.value = data
  }

  const instagram = ref<any>(null)
  async function getInstagramAnalytics(userId: string) {
    const logger = useLogger('getInstagramAnalytics')
    logger.info(`Fetching Instagram analytics for ${userId}`)
    try {
      const response = await $fetch(`/api/social/instagram/analytics?userId=${userId}`, {
        method: 'GET',
      })

      const data = errors.server({
        response,
        devOnly: false,
        devMessage: 'Error getting Instagram analytics',
        userMessage: 'Something went wrong when getting Instagram analytics',
      })

      instagram.value = data
    } catch (error) {
      errors.client({
        error,
        devOnly: false,
        devMessage: 'Error getting Instagram analytics',
        userMessage: 'Something went wrong when getting Instagram analytics',
      })
    }
  }

  const linkedin = ref<any>(null)
  async function getLinkedInAnalytics(postId: string) {
    const logger = useLogger('getLinkedInAnalytics')
    logger.info(`Fetching LinkedIn analytics for post ${postId}`)
    try {
      const response = await $fetch(`/api/social/linkedin/analytics?postId=${postId}`, {
        method: 'GET',
      })

      const data = errors.server({
        response,
        devOnly: false,
        devMessage: 'Error getting LinkedIn analytics',
        userMessage: 'Something went wrong when getting LinkedIn analytics',
      })

      linkedin.value = data
    } catch (error) {
      errors.client({
        error,
        devOnly: false,
        devMessage: 'Error getting LinkedIn analytics',
        userMessage: 'Something went wrong when getting LinkedIn analytics',
      })
    }
  }

  const twitter = ref<any>(null)
  async function getTwitterAnalytics(postId: string) {
    const logger = useLogger('getTwitterAnalytics')
    logger.info(`Fetching Twitter analytics for post ${postId}`)
    try {
      const response = await fetch(`/api/social/twitter/analytics?postId=${postId}`, {
        method: 'GET',
      })

      const data = errors.server({
        response,
        devOnly: false,
        devMessage: 'Error getting Twitter analytics',
        userMessage: 'Something went wrong when getting Twitter analytics',
      })

      twitter.value = data
    } catch (error) {
      errors.client({
        error,
        devOnly: false,
        devMessage: 'Error getting Twitter analytics',
        userMessage: 'Something went wrong when getting Twitter analytics',
      })
    }
  }

  return {
    youtube,
    getYoutubeAnalytics,
    //
    instagram,
    getInstagramAnalytics,
    //
    linkedin,
    getLinkedInAnalytics,
    //
    twitter,
    getTwitterAnalytics,
  }
})

if (import.meta.hot) {
  import.meta.hot.accept(acceptHMRUpdate(useSocialStore, import.meta.hot))
}
</file>

<file path="layers/base/composables/useMediaQuery.ts">
// composables/useMediaQuery.ts
export const useMediaQuery = (query: string) => {
  const matches = ref(false)

  if (import.meta.client) {
    const mediaQuery = window.matchMedia(query)
    matches.value = mediaQuery.matches

    const handler = (event: MediaQueryListEvent) => {
      matches.value = event.matches
    }

    // Watch for changes
    mediaQuery.addEventListener('change', handler)

    // Cleanup
    onUnmounted(() => {
      mediaQuery.removeEventListener('change', handler)
    })
  }

  return matches
}
</file>

<file path="layers/base/composables/useNavigation.ts">
// composables/useNavigation.ts
export const useNavigation = () => {
  const isSidebarOpen = useState('nav-sidebar-open', () => true)
  const isMobileSidebarOpen = useState('nav-mobile-sidebar-open', () => false)

  // Create our own media query composable
  const isMobile = useMediaQuery('(max-width: 768px)')

  // Close mobile nav on route changes
  const route = useRoute()
  
  watch(
    () => route.path,
    () => {
      isMobileSidebarOpen.value = false
    },
  )

  return {
    isSidebarOpen,
    isMobileSidebarOpen,
    isMobile,
  }
}
</file>

<file path="layers/base/composables/utils.ts">
import { wasRowDataUpdated } from './utils/hasValueChanged'
import * as time from './utils/time'
import * as strings from './utils/strings'
import * as objects from './utils/objects'
import * as arrays from './utils/arrays'

export function useUtils() {
  return {
    wasRowDataUpdated,
    time: {
      format: time.toDateObject,
      lastSeen: time.lastSeen,
    },
    strings: {
      firstUpper: strings.upperCaseFirstLetter,
      slugify: strings.slugify,
    },
    arrays: {
      removeDuplicates: arrays.removeDuplicates,
      sortBy: arrays.sortBy,
    },
    objects: {
      pluck: objects.pluck,
    },
  }
}
</file>

<file path="layers/base/plugins/error-handler.ts">
import { useErrorHandler } from '@ib/logger'

export default defineNuxtPlugin((nuxtApp) => {
  const { handleError } = useErrorHandler()

  // Set up global error handlers
  if (import.meta.client) {
    window.addEventListener('error', (event) => {
      handleError(event.error, 'Uncaught Exception')
    })

    window.addEventListener('unhandledrejection', (event) => {
      handleError(event.reason, 'Unhandled Promise Rejection')
    })
  }
})
</file>

<file path="layers/base/plugins/posthog.client.ts">
import posthog from 'posthog-js'

export default defineNuxtPlugin((nuxtApp) => {
  const env = nuxtApp.$config.public
  const env2 = useRuntimeConfig().public

  console.log('ENV Key:', env, env2)
  console.log('NODE_ENV:', import.meta.env.NODE_ENV)

  const posthogKey = env.posthogKey || env2.posthogKey
  const posthogUrl = env.posthogUrl || env2.posthogUrl

  // Initialize PostHog
  posthog.init(posthogKey, {
    api_host: posthogUrl,
    autocapture: false, // Disable autocapture as we'll handle events manually
    capture_pageview: false, // We'll capture pageviews manually for more control
    persistence: 'localStorage+cookie',
    // bootstrap: {
    //   distinctID: runtimeConfig.public.posthogDistinctId // Set this in your runtime config if you have a user ID
    // },
    loaded: (posthog) => {
      // This function is called once PostHog is loaded
      if (import.meta.env.NODE_ENV === 'development') {
        // Log to console in development mode
        posthog.debug()
      }
    },
  })

  // Capture page views
  nuxtApp.hook('page:finish', () => {
    posthog.capture('$pageview')
  })

  // Expose PostHog instance and utility functions
  return {
    provide: {
      posthog: {
        // Expose the raw PostHog instance
        raw: posthog,

        // Utility function to capture events
        capture: (eventName: string, properties?: Record<string, any>) => {
          posthog.capture(eventName, properties)
        },

        // Utility function for A/B testing
        getFeatureFlag: (flagName: string, defaultValue?: any) => {
          return posthog.getFeatureFlag(flagName, defaultValue)
        },

        // Utility function to identify users
        identify: (distinctId: string, properties?: Record<string, any>) => {
          posthog.identify(distinctId, properties)
        },

        // Utility function to reset user identity
        reset: () => {
          posthog.reset()
        },

        // Utility function to opt in/out of tracking
        optIn: () => {
          posthog.opt_in_capturing()
        },
        optOut: () => {
          posthog.opt_out_capturing()
        },

        // Utility function for registering super properties
        register: (properties: Record<string, any>) => {
          posthog.register(properties)
        },

        // Utility function for registering one-time super properties
        registerOnce: (properties: Record<string, any>) => {
          posthog.register_once(properties)
        },
      },
    },
  }
})
</file>

<file path="layers/base/plugins/sentry.client.ts">
import * as Sentry from '@sentry/vue'
import { defineNuxtPlugin } from '#app'

export default defineNuxtPlugin((nuxtApp) => {
  const app = nuxtApp.vueApp
  const router = useRouter()

  Sentry.init({
    app,
    dsn: 'https://eec364410b024a5a837f60e00d367513@o1175094.ingest.sentry.io/4504389151621120',
    integrations: [Sentry.browserTracingIntegration({ router }), Sentry.replayIntegration()],
    tracesSampleRate: process.env.NODE_ENV === 'production' ? 0.2 : 1.0,
    tracePropagationTargets: ['localhost', /^https:\/\/yourserver\.io\/api/],
    replaysSessionSampleRate: 0.1,
    replaysOnErrorSampleRate: 1.0,
    attachProps: true,
    trackComponents: true,
  })

  // Sentry.setUser(useSupabaseUser())
  Sentry.setTag('environment', process.env.NODE_ENV)
})
</file>

<file path="layers/base/types/content.ts">
import { z } from 'zod'

export const titleSchema = z.object({
  centered: z.boolean().optional(),
  label: z.string().optional(),
  main: z.string(),
  subtitle: z.string().optional(),
})

export const faqSchema = z.object({
  label: z.string(),
  description: z.string(),
})

export const imageSchema = z.object({
  src: z.string(),
  alt: z.string(),
  width: z.number().optional(),
  height: z.number().optional(),
})

export type ImageType = z.infer<typeof imageSchema>
export type TitleType = z.infer<typeof titleSchema>
export type FaqType = z.infer<typeof faqSchema>
</file>

<file path="layers/base/types/database.ts">
import type { Tables } from '../../../supabase/schema.gen'

export type RowUser = Tables<'user_profiles'>
export type RowUserFollowers = Tables<'user_followers'>
export type RowRole = Tables<'roles'>
export type RowRegisterInterest = Tables<'register_interest'>

export type RowCategory = Tables<'categories'>
export type RowTag = Tables<'tags'>

export type RowNews = Tables<'news'>
export type RowNewsTag = Tables<'news_tags'>

export type RowEmbedding = Tables<'embeddings'>

export type RowPaper = Tables<'papers'>

type ArrayToUnion<A> = A extends readonly (infer T)[] ? T : never

const userCardKeys = [
  'id',
  'given_name',
  'surname',
  'username',
  'avatar',
  'followed_count',
  'followers_count',
  'plan',
] as const

export type UserCard = Pick<RowUser, ArrayToUnion<typeof userCardKeys>>
</file>

<file path="layers/base/types/index.ts">
export * from './users'
export * from './other-type-file'
</file>

<file path="layers/base/types/users.ts">
// don't forget to add to this file if you make any changes in the database
import * as z from 'zod'

export const LocationSchema = z.object({
  id: z.number(),
  created_at: z.string().optional(),
  city: z.string(),
  country: z.string(),
  state: z.string(),
  address: z.string().nullable(),
  latitude: z.number().optional().nullable(),
  longitude: z.number().optional().nullable(),
})

export const UserRoleSchema = z.object({
  id: z.number(),
  name: z.string().nullable(),
  body: z.string().nullable().optional(),
  created_at: z.string().optional(),
  icon: z.string(),
})

export const IdName = z.object({
  id: z.number(),
  name: z.string(),
})

export const UserSkillSchema = z.object({
  id: z.number(),
  title: z.string().nullable(),
  body: z.string().nullable().optional(),
  total_endorsements: z.number(),
  admin_rating: z.number().nullable(),
  avg_rating: z.number().nullable(),
  created_at: z.string().optional(),
})

export const UserSocialSchema = z.object({
  id: z.number(),
  url: z.string(),
  platform: z.string(),
  username: z.string(),
})

export const UserBasicSchema = z.object({
  id: z.string(),
  given_name: z.string(),
  surname: z.string().nullable(),
  username: z.string().nullable(),
  avatar: z.string().nullable(),
  introduction: z.string().nullable(),
  followers_count: z.number().nullable(),
  followed_count: z.number().nullable(),
  is_following: z.boolean().nullable(),
  role: z.number(),
})

export const UserFullSchema = UserBasicSchema.extend({
  email: z.string(),
  dob: z.string().nullable(),
  gender_id: z.number().nullable(),
  created_at: z.string(),
  updated_at: z.string().nullable(),
  quote: z.string().nullable(),
})

export const UserRowSchema = z.object({
  given_name: z.string(),
  email: z.string(),
  surname: z.string().nullable(),
  username: z.string().nullable(),
  avatar: z.string().nullable(),
  introduction: z.string().nullable(),
  plan: z.string().nullish(),
  dob: z.string().nullable(),
  quote: z.string().nullable(),
  gender_id: z.number().nullable(),
})

export const UserRolesSchema = z.array(UserRoleSchema)

export type UserType = z.infer<typeof UserBasicSchema>
export type UserFullType = z.infer<typeof UserFullSchema>
export type UserRoleType = z.infer<typeof UserRoleSchema>
export type UserRowType = z.infer<typeof UserRowSchema>
export type UserSocialType = z.infer<typeof UserSocialSchema>
</file>

<file path="layers/base/nuxt.config.ts">
import { defineNuxtConfig } from 'nuxt/config'

export default defineNuxtConfig({
  workspaceDir: '../../',
  srcDir: '.',

  icon: {
    serverBundle: {
      collections: ['material-symbols', 'mdi'],
    },
  },

  eslint: {
    checker: true,
  },

  image: {
    providers: {
      supabase: {
        provider: '../../layers/base/supabase-provider.ts',
        options: {
          baseURL: process.env.NUXT_PUBLIC_SUPABASE_URL,
        },
      },
    },
    presets: {
      original: {
        modifiers: {
          width: 1920,
          height: 1080,
        },
      },
      mobile: {
        modifiers: {
          width: 768,
          height: 1024,
        },
      },
      thumbnail: {
        modifiers: {
          width: 300,
          height: 200,
        },
      },
    },
  },

  components: [
    {
      path: './components',
      pathPrefix: false,
      prefix: 'IB',
      global: true,
    },
  ],
})
</file>

<file path="layers/base/supabase-provider.ts">
export function getImage(
  src,
  {
    modifiers = { width: null, height: null, format: null },
    baseURL = process.env.NUXT_PUBLIC_SUPABASE_URL,
  } = {},
) {
  const { width, height, format } = modifiers
  const [_, bucket, sizeName, imageFileName] = src.split('/')

  // Determine target size
  let targetSizeName = sizeName
  if (width && height) {
    if (width <= 300 && height <= 200) {
      targetSizeName = 'thumbnail'
    } else if (width <= 768 && height <= 1024) {
      targetSizeName = 'mobile'
    } else {
      targetSizeName = 'original'
    }
  }

  const imageNameWithoutExt = imageFileName.split('.')[0]
  const imageFormat = format || imageFileName.split('.')[1] || 'jpg'

  return {
    url: `${baseURL}/storage/v1/object/public/${bucket}/${targetSizeName}/${imageNameWithoutExt}.${imageFormat}`,
  }
}
</file>

</repository_files>
