This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-11-21T14:47:47.057Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>

<additional_info>

For more information about Repomix, visit: https://github.com/yamadashy/repomix
</additional_info>

</file_summary>

<repository_structure>
apps/
  main-app/
    app/
      router.options.ts
    components/
      bookmark/
        BookmarkCard.vue
        BookmarkFormMove.vue
        BookmarkList.vue
        BookmarkViewFolder.vue
      company/
        CompanyCard.vue
        CompanyCardSkeleton.vue
      content/
        financial-chart.vue
        org-chart.vue
        timeline.vue
      dev/
        ApiDataViewer.vue
        CodePrevies.vue
        ComponentList.vue
        ComponentPlayground.vue
        EventLogger.vue
        Helpers.vue
        PreviewArea.vue
        PropsEditor.vue
        ResponsiveTester.vue
        Settings.vue
        StateManager.vue
      folder/
        FolderForm.vue
        FolderItem.vue
        FolderTree.vue
      form/
        FormPassword.vue
      nav/
        NavAppTop.vue
        NavMobiBottom.vue
        NavMobiSlideover.vue
      news/
        NewsCard.vue
        NewsCardSkeleton.vue
        NewsModal.vue
        NewsNavigationButton.vue
        NewsSummaryLevel.vue
      newsletter/
        NewsletterBasic.vue
      notification/
        Notification.vue
      onboarding/
        Account.vue
        Interests.vue
        Professional.vue
      post/
        PostCard.vue
      research/
        ResearchCard.vue
      search/
        SearchBar.vue
      supa/
        Download.vue
        Realtime.vue
        Upload.vue
      user/
        settings/
          UserSettingsCard.vue
          UserSettingsItem.vue
      vote/
        VoteAnimate.vue
        VoteButton.vue
      AppBackButton.vue
      ConfirmationDialog.vue
      DatabaseTester.vue
      DeleteConfirmation.vue
      FuzzySearch.vue
      PaymentButton.vue
      UploadCropper.vue
    composables/
      companies/
        companies.store.ts
      events/
        events.store.ts
      news/
        news.store.ts
      users/
        user-settings.store.ts
        user.admin.composable.ts
      category-tags.store.ts
      chat.store.ts
      chunks.store.ts
      feedback.store.ts
      onboarding.composable.ts
      useBookmarkManager.ts
      useBookmarks.ts
      useBookmarkView.ts
      useFolderSystem.ts
      usePages.ts
      usePayments.ts
      usePlan.ts
      usePWA.ts
      useVotesStore.ts
    docs/
      uuid.md
    layouts/
      app-settings.vue
      default.vue
    middleware/
      auth.global.ts
      isCurrentUser.ts
    pages/
      feed/
        [feed].vue
        add.vue
      news/
        index.vue
      profile/
        settings/
          password.vue
          payments.vue
          profile.vue
        votes/
          [type].vue
        bookmarks.vue
        index.vue
      ask.vue
      auth-callback.vue
      companies.vue
      database-testing.vue
      events.vue
      index.vue
      offline.vue
      onboarding.vue
      research.vue
    plugins/
      formbricks.client.ts
      pwa.client.ts
    server/
      api/
        ai/
          ask.ts
        bookmarks/
          [id].delete.ts
          index.ts
          move.patch.ts
          toggle.ts
        folders/
          [id].delete.ts
          [id].patch.ts
          index.ts
        payment/
          [provider]/
            create-order.ts
            subscription.get.ts
            verify-payment.post.ts
        users/
          update.post.ts
        votes/
          [contentType]/
            [id].get.ts
            [id].post.ts
          user/
            [voteType].get.ts
          user.get.ts
        webhook/
          database.ts
        database-test.ts
        upload.ts
      middleware/
        feature-limit.ts
      plugins/
        error-handler.ts
      utils/
        openai/
          callOpenAI.ts
          openaiClient.ts
        storage/
          storageSupabase.ts
        agents.ts
        errors.ts
        featureLimits.ts
        formatter.ts
        generateServerToken.ts
        groqClient.ts
        rateLimiter.ts
        validator.ts
    shared/
      constants.ts
      index.ts
    tasks/
      setup-posthog.md
    types/
      bookmarks.ts
      folder.ts
      toasts.ts
    app.config.ts
    app.vue
    error.vue
    nuxt.config.ts
    prompt-app-download.ts
    README.md
    tailwind.config.ts
shared-runtime.config.ts
</repository_structure>

<repository_files>
This section contains the contents of the repository's files.

<file path="apps/main-app/app/router.options.ts">
import type { RouterOptions } from '@nuxt/schema'

export default <RouterOptions>{
  scrollBehavior(to, _from, savedPosition) {
    return new Promise((resolve, _reject) => {
      setTimeout(() => {
        if (savedPosition) {
          resolve(savedPosition)
        } else if (to.hash) {
          resolve({
            el: to.hash,
            top: 0,
          })
        } else {
          resolve({ top: 0 })
        }
      }, 100)
    })
  },
}
</file>

<file path="apps/main-app/components/bookmark/BookmarkCard.vue">
<!-- BookmarksCard -->
<template>
  <div
    :class="[
      'relative group p-4 border border-color rounded-lg hover:shadow-sm transition-shadow',
      selected ? 'ring-2 ring-primary-500 border-transparent' : 'hover:border-color',
    ]"
  >
    <!-- Selection Checkbox -->
    <div class="absolute top-2 left-2 z-10">
      <input
        type="checkbox"
        :checked="selected"
        class="rounded border-color"
        @change="$emit('select', bookmark.id)"
      />
    </div>

    <!-- Content -->
    <div class="space-y-2">
      <NuxtImg
        :src="bookmark.metadata.thumbnail"
        :alt="bookmark.metadata.title"
        class="w-full h-48 object-cover rounded"
      />

      <h3 class="font-medium line-clamp-2">
        {{ bookmark.metadata.title }}
      </h3>

      <p class="text-sm text-gray-600 line-clamp-2">
        {{ bookmark.metadata.description }}
      </p>

      <!-- Folder Badge -->
      <div
        v-if="bookmark.folder"
        class="flex items-center gap-1.5 text-sm text-gray-600"
      >
        <div
          class="w-2 h-2 rounded-full"
          :style="{ backgroundColor: bookmark.folder.color }"
        />
        <span class="truncate">{{ bookmark.folder.name }}</span>
        <Icon
          v-if="bookmark.folder.is_favorite"
          name="mdi:star"
          class="w-4 h-4 text-yellow-400"
        />
      </div>
    </div>

    <!-- Actions -->
    <div class="absolute top-2 right-2 opacity-0 group-hover:opacity-100 transition-opacity">
      <button
        class="p-1.5 text-gray-400 hover:text-gray-600"
        @click="$emit('move')"
      >
        <Icon
          name="mdi:folder-move"
          class="w-5 h-5"
        />
      </button>
      <button
        class="p-1.5 text-gray-400 hover:text-red-600"
        @click="$emit('delete')"
      >
        <Icon
          name="mdi:trash"
          class="w-5 h-5"
        />
      </button>
    </div>
  </div>
</template>

<script setup lang="ts">
import type { Bookmark } from '../../types/bookmarks'

interface Props {
  bookmark: Bookmark
  selected?: boolean
  showSelect?: boolean
}

const props = withDefaults(defineProps<Props>(), {
  selected: false,
  showSelect: false,
})

const emit = defineEmits<{
  (e: 'select', id: string): void
  (e: 'move'): void
  (e: 'delete'): void
}>()
</script>
</file>

<file path="apps/main-app/components/bookmark/BookmarkFormMove.vue">
<script setup lang="ts">
import type { Folder } from '~/types/bookmark'

const props = defineProps<{
  folders: Folder[]
  selectedFolder: Folder | null
}>()

const emit = defineEmits<{
  (e: 'submit', folderId: string): void
  (e: 'cancel'): void
}>()

const targetFolderId = ref<string | null>(null)

const handleSubmit = () => {
  if (targetFolderId.value) {
    emit('submit', targetFolderId.value)
  }
}
</script>

<template>
  <div class="space-y-4">
    <div class="py-4">
      <div class="mb-4">
        <label class="block text-sm font-medium text-gray-700">Select Destination Folder</label>
        <select
          v-model="targetFolderId"
          class="mt-1 block w-full rounded-md border-gray-300"
          required
        >
          <option
            v-for="folder in folders"
            :key="folder.id"
            :value="folder.id"
            :disabled="folder.id === selectedFolder?.id"
          >
            {{ folder.name }}
            {{ folder.id === selectedFolder?.id ? '(Current)' : '' }}
          </option>
        </select>
      </div>
    </div>

    <div class="flex justify-end gap-2">
      <button
        type="button"
        @click="$emit('cancel')"
        class="px-4 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-md hover:bg-gray-50"
      >
        Cancel
      </button>
      <button
        @click="handleSubmit"
        class="px-4 py-2 text-sm font-medium text-white bg-primary-600 rounded-md hover:bg-primary-700 disabled:opacity-50"
        :disabled="!targetFolderId"
      >
        Move
      </button>
    </div>
  </div>
</template>
</file>

<file path="apps/main-app/components/bookmark/BookmarkList.vue">
<!-- BookmarksList -->
<template>
  <div class="flex gap-6">
    <!-- Folder Sidebar -->
    <div class="w-64 flex-shrink-0">
      <FolderTree
        v-model:selected="currentFolderId"
        @select="handleFolderSelect"
      />
    </div>

    <!-- Bookmarks Content -->
    <div class="flex-1 space-y-4">
      <!-- Folder Header -->
      <div
        v-if="currentFolder"
        class="flex items-center justify-between"
      >
        <div class="flex items-center gap-2">
          <div
            class="w-3 h-3 rounded-full"
            :style="{ backgroundColor: currentFolder.color }"
          />
          <h2 class="text-lg font-medium">{{ currentFolder.name }}</h2>
          <span
            v-if="currentFolder.is_favorite"
            class="text-yellow-400"
          >
            <Icon
              name="mdi:star"
              class="w-4 h-4"
            />
          </span>
        </div>

        <!-- Folder Actions -->
        <div class="flex items-center gap-2">
          <label class="flex items-center text-sm text-gray-600">
            <input
              v-model="includeSubfolders"
              type="checkbox"
              class="rounded border border-color mr-2"
            />
            Include subfolders
          </label>
        </div>
      </div>

      <!-- Search -->
      <div class="relative">
        <Icon
          name="mdi:magnify"
          class="absolute left-3 top-1/2 -translate-y-1/2 text-gray-400 w-5 h-5"
        />
        <input
          v-model="searchQuery"
          type="text"
          placeholder="Search bookmarks..."
          class="w-full pl-10 pr-4 py-2 rounded-lg border"
        />
      </div>

      <!-- Bookmarks Grid -->
      <div
        v-if="!loading"
        class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4"
      >
        <BookmarkCard
          v-for="bookmark in displayedBookmarks"
          :key="bookmark.id"
          :bookmark="bookmark"
          :selected="selectedBookmarks.includes(bookmark.id)"
          @select="toggleBookmarkSelection"
          @move="showMoveDialog = true"
        />
      </div>

      <div
        v-else
        class="flex items-center justify-center h-64"
      >
        <Icon
          name="mdi:loading"
          class="w-8 h-8 text-gray-400 animate-spin"
        />
      </div>
    </div>

    <PrimeDialog
      v-model:visible="showMoveModal"
      modal
      header="Move Bookmarks"
      :style="{ width: '90vw', maxWidth: '500px' }"
    >
      <!-- Main Content -->
      <span class="text-surface-500 dark:text-surface-400 block mb-4">
        Select a destination folder for {{ selectedBookmarks.length }} bookmark(s).
      </span>

      <div class="max-h-[400px] overflow-y-auto p-2">
        <FolderTree
          v-model:selected-keys="targetFolderId"
          selection-mode="single"
          :value="folders"
          :filter="true"
          filter-mode="strict"
          class="w-full"
        >
          <template #default="{ node }">
            <div class="flex items-center gap-2">
              <div
                class="w-3 h-3 rounded-full"
                :style="{ backgroundColor: node.color }"
              />
              <span>{{ node.name }}</span>
              <Icon
                v-if="node.is_favorite"
                name="mdi:star"
                class="text-yellow-400 w-4 h-4"
              />
            </div>
          </template>
        </FolderTree>
      </div>

      <!-- Footer -->
      <template #footer>
        <PrimeButton
          label="Cancel"
          class="p-button-text"
          severity="secondary"
          @click="showMoveModal = false"
        />
        <PrimeButton
          label="Move"
          :disabled="!targetFolderId"
          severity="primary"
          @click="(folder) => handleMoveSubmit(folder)"
        />
      </template>
    </PrimeDialog>
  </div>
</template>

<script setup lang="ts">
const { bookmarks, loading, fetchBookmarks, moveBookmarks, searchBookmarks } = useBookmarks()

const { folders, getFavorites } = useFolderSystem()

const currentFolderId = ref<string | null>(null)
const includeSubfolders = ref(true)
const searchQuery = ref('')
const selectedBookmarks = ref<string[]>([])
const showMoveDialog = ref(false)
const targetFolderId = ref<string | null>(null)

const currentFolder = computed(() => folders.value.find((f) => f.id === currentFolderId.value))

const displayedBookmarks = computed(() => {
  if (!searchQuery.value) return bookmarks.value
  return searchBookmarks(searchQuery.value)
})

const handleFolderSelect = async (folder: Folder) => {
  currentFolderId.value = folder.id
  await fetchBookmarks({
    folder_id: folder.id,
    include_subfolders: includeSubfolders.value,
  })
}

const toggleBookmarkSelection = (bookmarkId: string) => {
  const index = selectedBookmarks.value.indexOf(bookmarkId)
  if (index === -1) {
    selectedBookmarks.value.push(bookmarkId)
  } else {
    selectedBookmarks.value.splice(index, 1)
  }
}

const handleMoveBookmarks = async () => {
  if (!targetFolderId.value) return

  await moveBookmarks(selectedBookmarks.value, targetFolderId.value)
  selectedBookmarks.value = []
  showMoveDialog.value = false
  targetFolderId.value = null
}

watch(includeSubfolders, async () => {
  if (currentFolderId.value) {
    await fetchBookmarks({
      folder_id: currentFolderId.value,
      include_subfolders: includeSubfolders.value,
    })
  }
})

onMounted(async () => {
  // Start with default folder if exists
  const defaultFolder = folders.value.find((f) => f.is_default)
  if (defaultFolder) {
    currentFolderId.value = defaultFolder.id
    await handleFolderSelect(defaultFolder)
  } else {
    await fetchBookmarks({})
  }
})
</script>
</file>

<file path="apps/main-app/components/bookmark/BookmarkViewFolder.vue">
<template>
  <div class="space-y-6">
    <div class="flex items-center justify-between mb-4">
      <h2 class="text-xl font-semibold">Folders</h2>
      <PrimeButton
        class="p-button-primary"
        @click="showModal = true"
      >
        <div class="flex items-center gap-2">
          <Icon name="mdi:folder-plus" />
          <span
            >New Folder ({{ folderUsage.used }}/{{
              folderUsage.isUnlimited ? '∞' : folderUsage.limit
            }})</span
          >
        </div>
      </PrimeButton>
    </div>

    <!-- Folders Grid -->
    <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4">
      <div
        v-for="folder in folders"
        :key="folder.id"
        class="p-4 hover:shadow-md transition-shadow bg-card border border-color rounded-lg cursor-pointer group"
        @click="handleEditClick(folder)"
      >
        <div class="flex items-center justify-between">
          <div class="flex items-center gap-2">
            <div
              class="w-3 h-3 rounded-full"
              :style="{ backgroundColor: folder.color }"
            />
            <h3 class="font-medium">{{ folder.name }}</h3>
            <Icon
              v-if="folder.is_favorite"
              name="mdi:star"
              class="w-4 h-4 text-yellow-400"
            />
          </div>
          <div class="flex items-center gap-2">
            <span
              v-if="folder.is_default"
              class="text-sm text-muted-foreground"
            >
              Default
            </span>
            <Icon
              name="mdi:pencil"
              class="w-4 h-4 opacity-0 group-hover:opacity-100 transition-opacity"
            />
          </div>
        </div>
        <p class="mt-2 text-sm text-muted-foreground">
          {{ getFolderBookmarkCount(folder.id) }} bookmarks
        </p>
      </div>
    </div>

    <!-- Modal for both create and edit -->
    <PrimeDialog
      v-model:visible="showModal"
      :modal="true"
      :header="selectedFolder ? 'Edit Folder' : 'New Folder'"
      :style="{ width: '90vw', maxWidth: '500px' }"
    >
      <FolderForm
        :folder="selectedFolder"
        @submit="handleSubmit"
        @delete="handleDelete"
        @cancel="closeModal"
      />
    </PrimeDialog>
  </div>
</template>

<script setup lang="ts">
import type { Folder } from '~/types/folder'

const { folders, createFolder, updateFolder, deleteFolder } = useFolderSystem()
const { bookmarks } = useBookmarks()
const { getFeatureUsage } = usePlan()

const showModal = ref(false)
const selectedFolder = ref<Folder | null>(null)

const folderUsage = computed(() => getFeatureUsage('BOOKMARK_FOLDERS', folders.value.length))

const getFolderBookmarkCount = (folderId: string) => {
  return bookmarks.value.filter((bookmark) => bookmark.folder_id === folderId).length
}

const handleEditClick = (folder: Folder) => {
  selectedFolder.value = folder
  showModal.value = true
}

const closeModal = () => {
  showModal.value = false
  selectedFolder.value = null
}

const handleSubmit = async (data: Partial<Folder>) => {
  if (selectedFolder.value) {
    await updateFolder(selectedFolder.value.id, data)
  } else {
    await createFolder(data)
  }
  closeModal()
}

const handleDelete = async () => {
  if (selectedFolder.value) {
    await deleteFolder(selectedFolder.value.id)
    closeModal()
  }
}
</script>
</file>

<file path="apps/main-app/components/company/CompanyCard.vue">
<script setup lang="ts">
defineProps({
  company: {
    type: Object as () => {},
    required: true,
  },
})

const { getCategoryName } = useCategoryTagStore()

// What to display:
// Company location(s)
// Category
// Tags?
// Name
// Link to website
// Number of news updates
// Scrape Frequency?
// Sector
// Founded Year
// Description - probably a summary of all articles by chatGPT
// Logo
// isHiring (check job board to see, maybe linkedin) - add later, just scrape Linkedin Jobs for now
// isFunded
// valuation
// companySize
// primaryLocation
// country
//
</script>

<template>
  <div class="border-color border-b-2 px-4 py-8">
    <div>
      <div class="space-y-4 pb-4">
        <div class="flex items-center gap-4">
          <IBImage
            v-if="company.logo_url"
            class="border-color rounded-full border"
            :img="{
              src: `companies/${company.logo_url}`,
              width: '60',
              height: '60',
            }"
          />
          <div>
            <h3 class="text-balance text-xl font-semibold md:max-h-16">
              {{ company.name }}
            </h3>
            <p
              v-if="company.category_id !== 16"
              class="text-sm"
            >
              {{ getCategoryName(company.category_id) }}
            </p>
          </div>
          <!-- <span class="text-sm w-auto">
            Scraped: {{ useTimeAgo(company.scraped_at).value }}
          </span> -->
        </div>
      </div>
    </div>
    <div class="flex flex-col gap-4">
      <div class="flex items-center gap-2">
        <PrimeTag severity="info">
          {{ company.is_government ? 'Government' : 'Private' }}
        </PrimeTag>
        <PrimeTag
          v-if="company.founding_year"
          severity="info"
        >
          founded: {{ company.founding_year }}
        </PrimeTag>
        <IBNewLabel
          :date="company.created_at!"
          :max-age="14"
        />
      </div>
      <p
        v-if="company.description"
        class="text-sm"
      >
        {{ company.description }}
      </p>
      <div class="flex w-full items-center justify-between pt-4">
        <div>
          <IBSocialBlock
            v-if="company.social_media"
            :socials="company.social_media"
          />
        </div>
        <NuxtLink
          :to="company.url"
          target="_blank"
          rel="noopener"
        >
          <PrimeButton
            label="Website"
            size="small"
            outlined
          />
        </NuxtLink>
      </div>
    </div>
  </div>
</template>
</file>

<file path="apps/main-app/components/company/CompanyCardSkeleton.vue">
<script setup lang="ts"></script>

<template>
  <div class="border-b-2 border-color px-4 py-8">
    <div>
      <div class="space-y-4 pb-4">
        <div class="flex gap-4 items-center">
          <PrimeSkeleton
            :pt="{
              root: 'max-w-16 min-h-16 rounded-full',
            }"
          />

          <div class="w-full space-y-2">
            <PrimeSkeleton class="max-w-64 min-h-6 rounded-md" />
            <PrimeSkeleton class="max-w-48 h-4 rounded-md" />
          </div>
        </div>
      </div>
    </div>
    <div class="flex flex-col gap-4">
      <div class="flex gap-2 items-center">
        <PrimeSkeleton class="max-w-32 min-h-6 rounded-md" />
        <PrimeSkeleton class="max-w-16 min-h-6 rounded-md" />
      </div>
      <PrimeSkeleton class="w-full min-h-24 rounded-md" />

      <div class="w-full flex justify-between items-center pt-4">
        <PrimeSkeleton class="max-w-32 min-h-6 rounded-md" />
        <PrimeSkeleton class="max-w-24 min-h-10 rounded-md" />
      </div>
    </div>
  </div>
</template>
</file>

<file path="apps/main-app/components/content/financial-chart.vue">
<template>
  <div>
    <Chart
      v-if="chartDataKey"
      :chart="currentChartData"
    />
  </div>
</template>

<script setup lang="ts">
type ChartDataKey =
  | 'users'
  | 'revenue'
  | 'globalMarket'
  | 'indianMarket'
  | 'affiliateRevenue'
  | 'useOfFunds'
  | 'financialProgress'

const props = defineProps({
  chartDataKey: {
    type: String as PropType<ChartDataKey>,
    required: true,
  },
})

// Financial Data
const initialFreeUsers = 10000
const year2FreeUsers = 50000
const year3FreeUsers = 200000

const conversionRateYear1 = 0.03
const conversionRateYear2 = 0.06

const proPricePerMonth = 30
const expertPricePerMonth = 50

const advertisingCPM = 10
const affiliateCommissionYear1 = 0.1
const affiliateCommissionYear2 = 0.15
const affiliateCommissionYear3 = 0.2
const averageSale = 50
const conversionRateAffiliate = 0.05

// User Projections
function getFreeUsers(year: number): number {
  switch (year) {
    case 1:
      return initialFreeUsers
    case 2:
      return year2FreeUsers
    case 3:
      return year3FreeUsers
    default:
      throw new Error('Year must be 1, 2, or 3')
  }
}

function getConversionRate(year: number): number {
  switch (year) {
    case 1:
      return conversionRateYear1
    case 2:
      return conversionRateYear2
    case 3:
      return conversionRateYear2
    default:
      throw new Error('Year must be 1, 2, or 3')
  }
}

function getAffiliateCommission(year: number): number {
  switch (year) {
    case 1:
      return affiliateCommissionYear1
    case 2:
      return affiliateCommissionYear2
    case 3:
      return affiliateCommissionYear3
    default:
      throw new Error('Year must be 1, 2, or 3')
  }
}

// User Segmentation
function calculatePayingUsers(
  freeUsers: number,
  conversionRate: number,
): { proUsers: number, expertUsers: number } {
  const payingUsers = freeUsers * conversionRate
  const proUsers = payingUsers * 0.5
  const expertUsers = payingUsers * 0.5
  return { proUsers, expertUsers }
}

// Revenue Calculations
function calculateSubscriptionRevenue(users: number, pricePerMonth: number): number {
  return users * pricePerMonth * 12 // annual revenue
}

function calculateAdvertisingRevenue(impressionsPerMonth: number, cpm: number): number {
  return (impressionsPerMonth / 1000) * cpm * 12 // annual revenue
}

function calculateAffiliateRevenue(
  clicksPerMonth: number,
  conversionRate: number,
  averageSale: number,
  commissionRate: number,
): number {
  const sales = clicksPerMonth * conversionRate
  const revenue = sales * averageSale
  return revenue * commissionRate * 12 // annual revenue
}

// Yearly Projections
function getClicksPerMonth(year: number): number {
  switch (year) {
    case 1:
      return 10000
    case 2:
      return 50000
    case 3:
      return 200000
    default:
      throw new Error('Year must be 1, 2, or 3')
  }
}

function getImpressionsPerMonth(year: number): number {
  switch (year) {
    case 1:
      return 100000
    case 2:
      return 500000
    case 3:
      return 2000000
    default:
      throw new Error('Year must be 1, 2, or 3')
  }
}

function calculateYearlyRevenue(year: number): {
  proRevenue: number
  expertRevenue: number
  adRevenue: number
  affiliateRevenue: number
} {
  const freeUsers = getFreeUsers(year)
  const conversionRate = getConversionRate(year)
  const clicksPerMonth = getClicksPerMonth(year)
  const impressionsPerMonth = getImpressionsPerMonth(year)
  const affiliateCommission = getAffiliateCommission(year)

  const { proUsers, expertUsers } = calculatePayingUsers(freeUsers, conversionRate)

  const proRevenue = calculateSubscriptionRevenue(proUsers, proPricePerMonth)
  const expertRevenue = calculateSubscriptionRevenue(expertUsers, expertPricePerMonth)
  const adRevenue = calculateAdvertisingRevenue(impressionsPerMonth, advertisingCPM)
  const affiliateRevenue = calculateAffiliateRevenue(
    clicksPerMonth,
    conversionRateAffiliate,
    averageSale,
    affiliateCommission,
  )

  return { proRevenue, expertRevenue, adRevenue, affiliateRevenue }
}

// Example Usage
const year1Revenue = calculateYearlyRevenue(1)
const year2Revenue = calculateYearlyRevenue(2)
const year3Revenue = calculateYearlyRevenue(3)

const labels = {
  years: ['Year 1', 'Year 2', 'Year 3'],
}

const chartStyle = {
  backgroundColor: [
    'rgba(249, 115, 22, 0.2)',
    'rgba(6, 182, 212, 0.2)',
    'rgb(107, 114, 128, 0.2)',
    'rgba(139, 92, 246 0.2)',
  ],
  borderColor: ['rgb(249, 115, 22)', 'rgb(6, 182, 212)', 'rgb(107, 114, 128)', 'rgb(139, 92, 246)'],
  borderWidth: 1,
}

const chartStyleFreeUsers = {
  backgroundColor: 'rgba(249, 115, 22, 0.2)',
  borderColor: 'rgb(249, 115, 22)',
  borderWidth: 1,
}

const chartStyleProUsers = {
  backgroundColor: 'rgba(6, 182, 212, 0.2)',
  borderColor: 'rgb(6, 182, 212)',
  borderWidth: 1,
}

const chartStyleExpertUsers = {
  backgroundColor: 'rgba(107, 114, 128, 0.2)',
  borderColor: 'rgb(107, 114, 128)',
  borderWidth: 1,
}

const financialProgressChart = {
  id: 2,
  title: 'Financial and User Growth Over 12 Months',
  subtitle: 'Revenue, Expenses, User Base, and Capital',
  scaleType: 'logarithmic',
  type: 'bar',
  data: {
    labels: [
      'Month 1',
      'Month 2',
      'Month 3',
      'Month 4',
      'Month 5',
      'Month 6',
      'Month 7',
      'Month 8',
      'Month 9',
      'Month 10',
      'Month 11',
      'Month 12',
    ],
    datasets: [
      {
        label: 'Basic Plan Revenue',
        data: [0, 0, 24000, 46200, 79200, 124800, 189000, 241800, 288000, 326700, 367200, 420000],
        backgroundColor: 'rgba(249, 115, 22, 0.6)',
        borderColor: 'rgb(249, 115, 22)',
        borderWidth: 1,
        stack: 'stack1',
        valueType: 'currency' as const,
      },
      {
        label: 'Medium Plan Revenue',
        data: [0, 0, 48000, 92400, 158400, 249600, 378000, 483600, 576000, 653400, 734400, 840000],
        backgroundColor: 'rgba(6, 182, 212, 0.6)',
        borderColor: 'rgb(6, 182, 212)',
        borderWidth: 1,
        valueType: 'currency' as const,
        stack: 'stack1',
      },
      {
        label: 'Pro Plan Revenue',
        data: [0, 0, 0, 0, 0, 249600, 378000, 483600, 576000, 653400, 734400, 840000],
        backgroundColor: 'rgba(107, 114, 128, 0.6)',
        borderColor: 'rgb(107, 114, 128)',
        borderWidth: 1,
        valueType: 'currency' as const,
        stack: 'stack1',
      },
      {
        label: 'B2B Plan Revenue',
        data: [0, 0, 0, 0, 0, 0, 0, 0, 50000, 100000, 150000, 200000],
        backgroundColor: 'rgba(139, 92, 246, 0.6)',
        borderColor: 'rgb(139, 92, 246)',
        borderWidth: 1,
        valueType: 'currency' as const,
        stack: 'stack1',
      },
      {
        label: 'Ad Revenue',
        data: [
          0, 10000, 20000, 35000, 55000, 80000, 105000, 130000, 150000, 165000, 180000, 200000,
        ],
        backgroundColor: 'rgba(34, 197, 94, 0.6)',
        borderColor: 'rgb(34, 197, 94)',
        borderWidth: 1,
        valueType: 'currency' as const,
        stack: 'stack1',
      },
      {
        label: 'Expenses',
        data: [
          200000, 200000, 200000, 200000, 200000, 200000, 200000, 200000, 200000, 200000, 200000,
          200000,
        ],
        backgroundColor: 'rgba(239, 68, 68, 0.6)',
        borderColor: 'rgb(239, 68, 68)',
        borderWidth: 1,
        valueType: 'currency' as const,
      },
      {
        label: 'Total Users',
        data: [500, 2000, 4000, 7000, 11000, 16000, 21000, 26000, 30000, 33000, 36000, 40000],
        borderColor: 'rgb(59, 130, 246)',
        borderWidth: 2,
        valueType: 'number' as const,
        type: 'line',
      },
      {
        label: 'Paid Users',
        data: [0, 0, 80, 154, 264, 416, 630, 806, 960, 1089, 1224, 1400],
        borderColor: 'rgb(147, 51, 234)',
        borderWidth: 2,
        valueType: 'number' as const,
        type: 'line',
      },
      {
        label: 'Capital',
        data: [
          790000, 610000, 502000, 475600, 568200, 1072200, 1922200, 3061200, 4501200, 6199700,
          8165700, 10365700,
        ],
        borderColor: 'rgb(234, 179, 8)',
        borderWidth: 2,
        valueType: 'currency' as const,
      },
    ],
  },
  info: [
    { name: 'Final Month Revenue', value: '₹24,00,000' },
    { name: 'User Growth', value: '5,000 to 40,000' },
    { name: 'Capital Growth', value: '₹7,90,000 to ₹1,03,65,700' },
    { name: 'Conversion Rate Growth', value: '2.0% to 3.5%' },
  ],
}

const currentChartData = computed(() => chartData[props.chartDataKey])

const useOfFundsChart = {
  id: 1,
  scaleType: 'linear' as const,
  title: 'Use of Funds Breakdown',
  subtitle: 'Allocation of 10,00,000 INR initial investment',
  type: 'pie',
  data: {
    labels: [
      'Product Development',
      'Marketing and User Acquisition',
      'Team Expansion',
      'Operational Costs',
    ],
    datasets: [
      {
        label: 'Cost',
        data: [400000, 300000, 200000, 100000],
        backgroundColor: [
          'rgba(249, 115, 22, 0.6)',
          'rgba(6, 182, 212, 0.6)',
          'rgba(107, 114, 128, 0.6)',
          'rgba(139, 92, 246, 0.6)',
        ],
        borderColor: [
          'rgb(249, 115, 22)',
          'rgb(6, 182, 212)',
          'rgb(107, 114, 128)',
          'rgb(139, 92, 246)',
        ],
        borderWidth: 1,
        valueType: 'currency' as const,
      },
    ],
  },
  info: [
    { name: 'Total Investment', value: '₹10,00,000' },
    { name: 'Largest Allocation', value: 'Product Development (₹4,00,000)' },
    { name: 'Smallest Allocation', value: 'Operational Costs (₹1,00,000)' },
  ],
}

const chartData = {
  financialProgress: financialProgressChart,
  useOfFunds: useOfFundsChart,
  users: {
    labels: labels.years,
    datasets: [
      {
        type: 'line',
        label: 'Free Users',
        data: [initialFreeUsers, year2FreeUsers, year3FreeUsers],
        ...chartStyleFreeUsers,
      },
      {
        type: 'line',
        label: 'Pro Users',
        data: [
          calculatePayingUsers(initialFreeUsers, conversionRateYear1).proUsers,
          calculatePayingUsers(year2FreeUsers, conversionRateYear2).proUsers,
          calculatePayingUsers(year3FreeUsers, conversionRateYear2).proUsers,
        ],
        ...chartStyleProUsers,
      },
      {
        type: 'line',
        label: 'Expert Users',
        data: [
          calculatePayingUsers(initialFreeUsers, conversionRateYear1).expertUsers,
          calculatePayingUsers(year2FreeUsers, conversionRateYear2).expertUsers,
          calculatePayingUsers(year3FreeUsers, conversionRateYear2).expertUsers,
        ],
        ...chartStyleExpertUsers,
      },
    ],
  },
  revenue: {
    labels: labels.years,
    datasets: [
      {
        label: 'Advertising Revenue',
        data: [year1Revenue.adRevenue, year2Revenue.adRevenue, year3Revenue.adRevenue],
        ...chartStyle,
      },
      {
        label: 'Pro Revenue',
        data: [year1Revenue.proRevenue, year2Revenue.proRevenue, year3Revenue.proRevenue],
        ...chartStyle,
      },
      {
        label: 'Expert Revenue',
        data: [year1Revenue.expertRevenue, year2Revenue.expertRevenue, year3Revenue.expertRevenue],
        ...chartStyle,
      },
    ],
  },
  globalMarket: {
    labels: [2023, 2024, 2025, 2026, 2027, 2028, 2029, 2030, 2031, 2032, 2033, 2034, 2035],
    datasets: [
      {
        label: '7.5% YOY Growth',
        data: [
          535.0, 575.125, 618.259375, 664.6288281249999, 714.4759902343749, 768.061689501953,
          825.6663162145994, 887.5912899306943, 954.1606366754963, 1025.7226844261586,
          1102.6518857581204, 1185.3507771899795, 1274.2520854792278,
        ],
      },
      {
        label: '9% YOY Growth',
        data: [
          535.0, 583.1500000000001, 635.6335000000001, 692.8405150000002, 755.1961613500002,
          823.1638158715003, 897.2485592999354, 978.0009296369298, 1066.0210133042535,
          1161.9629045016363, 1266.5395659067838, 1380.5281268383944, 1504.77565825385,
        ],
      },
      {
        label: '16% YOY Growth',
        data: [
          535.0, 620.5999999999999, 719.8959999999998, 835.0793599999997, 968.6920575999997,
          1123.6827868159996, 1303.4720327065595, 1512.0275579396089, 1753.9519672099461,
          2034.5842819635375, 2360.1177670777033, 2737.7366098101356, 3175.774467379757,
        ],
      },
    ],
  },

  indianMarket: {
    labels: [2023, 2024, 2025, 2026, 2027, 2028, 2029, 2030, 2031, 2032, 2033, 2034, 2035],
    datasets: [
      {
        label: '7.5% YOY Growth',
        data: [
          8.4, 9.03, 9.71, 10.44, 11.23, 12.06, 12.97, 13.95, 15.01, 16.14, 17.35, 18.66, 20.06,
        ],
      },
      {
        label: '9% YOY Growth',
        data: [
          8.4, 9.16, 9.99, 10.89, 11.87, 12.93, 14.08, 15.33, 16.69, 18.2, 19.84, 21.63, 23.58,
        ],
      },
      {
        label: '16% YOY Growth',
        data: [8.4, 9.74, 11.3, 13.1, 15.2, 17.63, 20.45, 23.72, 27.51, 31.91, 37.01, 42.93, 49.8],
      },
    ],
  },

  affiliateRevenue: {
    labels: labels.years,
    datasets: [
      {
        label: 'Affiliate Revenue',
        data: [
          year1Revenue.affiliateRevenue,
          year2Revenue.affiliateRevenue,
          year3Revenue.affiliateRevenue,
        ],
        ...chartStyle,
      },
    ],
  },
}
</script>

<style scoped></style>
</file>

<file path="apps/main-app/components/content/org-chart.vue">
<template>
  <div class="card overflow-x-auto">
    <PrimeOrganizationChart
      :value="data"
      collapsible
    >
      <template #person="slotProps">
        <div class="flex flex-col">
          <div class="flex flex-col items-center">
            <NuxtImg
              :alt="slotProps.node.data.name"
              :src="slotProps.node.data.image"
              width="80"
              height="80"
              class="rounded-full"
            />
            <h4 class="pb-2 text-xl font-bold">
              {{ slotProps.node.data.name }}
            </h4>
            <span>{{ slotProps.node.data.title }}</span>
          </div>
        </div>
      </template>
      <template #default="slotProps">
        <span>{{ slotProps.node.label }}</span>
      </template>
    </PrimeOrganizationChart>
  </div>
</template>

<script setup lang="ts">
const data = ref({
  key: '0',
  type: 'person',
  styleClass: 'bg-indigo-900 text-white border-round-xl',
  data: {
    image: 'images/team/shweta-kulkarni.jpg',
    name: 'Shweta Kulkarni',
    title: 'CEO',
  },
  children: [
    {
      key: '0_0',
      type: 'person',
      styleClass: 'bg-teal-900 text-white border-round-xl',
      data: {
        image: 'images/team/drew-macgibbon.jpg',
        name: 'Drew MacGibbon',
        title: 'CTO',
      },
      children: [
        {
          label: 'DevOps Engineers',
          styleClass: 'bg-teal-900 text-white border-round-xl',
        },
        {
          label: 'Frontend Developers',
          styleClass: 'bg-teal-900 text-white border-round-xl',
        },
        {
          label: 'Backend Developers',
          styleClass: 'bg-teal-900 text-white border-round-xl',
        },
        {
          label: 'AI Specialists',
          styleClass: 'bg-teal-900 text-white border-round-xl',
        },
        {
          label: 'UI/UX Developers',
          styleClass: 'bg-teal-900 text-white border-round-xl',
        },
        {
          label: 'Data Processors / QA',
          styleClass: 'bg-teal-900 text-white border-round-xl',
        },
      ],
    },
    {
      key: '0_1',
      type: 'person',
      styleClass: 'bg-purple-900 text-white border-round-xl',
      data: {
        image: 'images/team/gunashri-vesikar.jpg',
        name: 'Gunashri Vesikar',
        title: 'CFO',
      },
      children: [
        {
          label: 'Accountants',
          styleClass: 'bg-purple-900 text-white border-round-xl',
        },
      ],
    },
    {
      key: '0_2',
      type: 'person',
      styleClass: 'bg-orange-900 text-white border-round-xl',
      data: {
        image: 'images/team/unknown.jpg',
        name: 'Unknown',
        title: 'COO',
      },
      children: [
        {
          label: 'Content Writers',
          styleClass: 'bg-orange-900 text-white border-round-xl',
        },
        {
          label: 'Social Media Managers',
          styleClass: 'bg-orange-900 text-white border-round-xl',
        },
        {
          label: 'Customer Support Agents',
          styleClass: 'bg-orange-900 text-white border-round-xl',
        },
        {
          label: 'Sales People',
          styleClass: 'bg-orange-900 text-white border-round-xl',
        },
      ],
    },
  ],
})
</script>
</file>

<file path="apps/main-app/components/content/timeline.vue">
<template>
  <div>
    <h3 class="pb-8 text-center"> Timeline </h3>
    <PrimeTimeline
      :value="events"
      align="alternate"
      class="customized-timeline"
    >
      <template #marker="slotProps">
        <span
          class="z-10 flex items-center justify-center rounded-full border p-1 text-white"
          :style="{ backgroundColor: slotProps.item.color }"
        >
          <Icon
            :name="`mdi:${slotProps.item.icon}`"
            size="32px"
          />
        </span>
      </template>
      <template #content="slotProps">
        <div class="border-color background rounded-lg border p-4">
          <h4 class="m-0 text-2xl">
            {{ slotProps.item.status }}
          </h4>
          <p class="text-lg font-bold">
            {{ slotProps.item.date }}
          </p>
          <p class="text-xl">
            {{ slotProps.item.description }}
          </p>
        </div>
      </template>
    </PrimeTimeline>
  </div>
</template>

<script setup lang="ts">
const events = ref([
  // Year 1
  {
    status: 'AI Model Upgrades',
    date: 'Q1 2024',
    icon: 'chart-line',
    color: '#9C27B0',
    description:
      'Continuously improve the accuracy and capabilities of our AI models by integrating advanced machine learning techniques and user feedback.',
  },
  {
    status: 'Gamification and Loyalty Programs',
    date: 'Q2 2024',
    icon: 'star',
    color: '#673AB7',
    description:
      'Introduce gamification elements and loyalty programs to enhance user engagement and incentivize frequent usage.',
  },
  {
    status: 'Scalability Enhancements',
    date: 'Q3 2024',
    icon: 'cog',
    color: '#FF9800',
    description:
      'Optimize our cloud infrastructure to handle increased traffic and ensure smooth performance.',
  },
  {
    status: 'Educational Partnerships',
    date: 'Q4 2024',
    icon: 'account-group',
    color: '#607D8B',
    description:
      'Partner with educational institutions to provide exclusive content and promote our platform among students.',
  },
  {
    status: 'Progressive Web App (PWA)',
    date: 'Q4 2024',
    icon: 'cellphone-link',
    color: '#FF5722',
    description:
      'Develop and launch a PWA to provide a seamless mobile experience without the need for native app development.',
  },
  {
    status: 'Data Quality Improvements',
    date: 'Q4 2024',
    icon: 'database',
    color: '#795548',
    description:
      'Focus on sourcing high-quality data, improving data processing, and cleaning mechanisms.',
  },

  // Year 2
  {
    status: 'AI Personalization',
    date: 'Q1 2025',
    icon: 'account',
    color: '#4CAF50',
    description:
      'Develop AI-driven personalization features to provide tailored content and recommendations.',
  },
  {
    status: 'Advanced AI Agents',
    date: 'Q2 2025',
    icon: 'robot',
    color: '#FFC107',
    description:
      'Introduce more sophisticated AI agents capable of handling complex queries and providing in-depth analysis.',
  },
  {
    status: 'Consulting Services',
    date: 'Q3 2025',
    icon: 'briefcase',
    color: '#03A9F4',
    description:
      'Offer consulting services to businesses and educational institutions leveraging our AI and data insights.',
  },
  {
    status: 'Multilingual Support',
    date: 'Q4 2025',
    icon: 'translate',
    color: '#E91E63',
    description: 'Add support for multiple languages to cater to a global audience.',
  },
  {
    status: 'Mobile Application Development',
    date: 'Q4 2025',
    icon: 'cellphone',
    color: '#FF9800',
    description: 'Develop and launch a native mobile application.',
  },
  {
    status: 'Premium Content Expansion',
    date: 'Q1 2026',
    icon: 'book',
    color: '#9C27B0',
    description:
      'Expand premium content offerings, such as exclusive webinars, research reports, and advanced data insights.',
  },
  {
    status: 'International Partnerships',
    date: 'Q2 2026',
    icon: 'handshake',
    color: '#673AB7',
    description:
      'Form partnerships with international space agencies, educational institutions, and businesses to expand our reach.',
  },

  // Year 4
  {
    status: 'AR and VR Integration',
    date: 'Q1 2027',
    icon: 'vr',
    color: '#FF5722',
    description:
      'Integrate AR and VR technologies to provide immersive learning experiences and interactive content.',
  },
  {
    status: 'IoT Integration',
    date: 'Q2 2027',
    icon: 'cloud',
    color: '#795548',
    description:
      'Leverage Internet of Things (IoT) devices for real-time data collection and analysis.',
  },
  {
    status: 'User-Generated Content Platform',
    date: 'Q3 2027',
    icon: 'pencil',
    color: '#4CAF50',
    description: 'Develop a platform for users to create and share their content.',
  },

  // Year 5
  {
    status: 'Educational and Sustainability Initiatives',
    date: 'Q1 2028',
    icon: 'school',
    color: '#FFC107',
    description:
      'Launch initiatives aimed at promoting space education in underprivileged communities and sustainability projects.',
  },
  {
    status: 'Continuous Improvement Mechanisms',
    date: 'Q2 2028',
    icon: 'refresh',
    color: '#03A9F4',
    description:
      'Establish continuous feedback loops with users and utilize data analytics to improve our services.',
  },
])
</script>

<style scoped>
@media (max-width: 960px) {
  .customized-timeline .p-timeline-event:nth-child(even) {
    flex-direction: row;
  }

  .customized-timeline .p-timeline-event:nth-child(even) .p-timeline-event-content {
    text-align: left;
  }

  .customized-timeline .p-timeline-event-opposite {
    flex: 0;
  }
}
</style>
</file>

<file path="apps/main-app/components/dev/ApiDataViewer.vue">
<template>
  <div v-if="showComponent">
    <div
      v-tooltip.left="'Page Data Structures'"
      @click="showModal = true"
    >
      <Icon name="ic:baseline-data-object" />
    </div>
    <PrimeDialog
      v-model:visible="showModal"
      modal
      header="API Data Structures"
      class="w-11/12 max-w-6xl"
    >
      <PrimeAccordion
        :multiple="true"
        class="flex flex-col gap-2"
      >
        <!-- <PrimeAccordionPanel
          v-for="(structure, url, index) in apiDataStore.apiData"
          :key="url"
          :value="`${index}`"
        >
          <PrimeAccordionHeader
            :pt="{
              root: 'rounded-md border gap-2 border-color flex items-center foreground p-2',
            }"
          >
            <p>
              {{ url }}
            </p>
          </PrimeAccordionHeader>
          <PrimeAccordionContent>
            <pre class="foreground mt-2 max-h-96 overflow-auto rounded p-4">
              {{ JSON.stringify(structure, null, 2) }}
            </pre>
          </PrimeAccordionContent>
        </PrimeAccordionPanel> -->
      </PrimeAccordion>
    </PrimeDialog>
  </div>
</template>

<script setup lang="ts">
// const apiDataStore = useApiDataStore()

const showModal = ref(false)

const isAdmin = ref(true)

const showComponent = computed((): boolean => {
  return import.meta.dev || isAdmin.value
})
</script>
</file>

<file path="apps/main-app/components/dev/CodePrevies.vue">
<template>
  <div class="code-preview">
    <h3>Code Preview</h3>
    <pre><code>{{ generatedCode }}</code></pre>
  </div>
</template>

<script setup lang="ts">
import { computed } from 'vue'

const props = defineProps<{
  component: { name: string, component: any }
  props: Record<string, any>
  state: Record<string, any>
}>()

const generatedCode = computed(
  () => `
<template>
  <${props.component.name}
    ${Object.entries(props.props)
        .map(([key, value]) => `:${key}="${JSON.stringify(value)}"`)
        .join('\n    ')}
  />
</template>

<script setup>
import { ref } from 'vue'

${Object.entries(props.state)
    .map(([key, value]) => `const ${key} = ref(${JSON.stringify(value)})`)
    .join('\n')}
<\/script>`,
)
</script>
</file>

<file path="apps/main-app/components/dev/ComponentList.vue">
<template>
  <div class="component-list">
    <h2>Components</h2>
    <input
      v-model="search"
      placeholder="Search components..."
    />
    <ul>
      <li
        v-for="componentName in filteredComponentNames"
        :key="componentName"
      >
        <PrimeButton
          size="small"
          @click="$emit('select', componentName)"
        >
          {{ componentName }}
        </PrimeButton>
      </li>
    </ul>
  </div>
</template>

<script setup lang="ts">
import { ref, computed } from 'vue'

const props = defineProps<{
  componentNames: string[]
}>()

const emit = defineEmits<{
  (e: 'select', componentName: string): void
}>()

const search = ref('')

const filteredComponentNames = computed(() =>
  props.componentNames.filter((name) => name.toLowerCase().includes(search.value.toLowerCase())),
)
</script>
</file>

<file path="apps/main-app/components/dev/ComponentPlayground.vue">
<template>
  <div class="component-playground">
    <DevComponentList
      :component-names="availableComponentNames"
      @select="selectComponent"
    />
    <div class="main-area">
      <DevPreviewArea
        v-if="false"
        :component="selectedComponentName.component"
        :props="props"
        :state="state"
        @event="logEvent"
      />
      <DevPropsEditor
        :props="props"
        @update:props="updateProps"
      />
      <DevStateManager
        v-if="hasState"
        :state="state"
        @update:state="updateState"
      />
      <DevEventLogger :events="events" />
      <DevResponsiveTester @change="setViewportSize" />
      <DevCodePreview
        :component="selectedComponent"
        :props="props"
        :state="state"
      />
    </div>
  </div>
</template>

<script setup lang="ts">
const availableComponentNames = ref<string[]>([])
const selectedComponentName = ref<string | null>(null)
const props = ref({})
const state = ref({})
const events = ref([])
const hasState = computed(() => Object.keys(state.value).length > 0)

onMounted(async () => {
  // Dynamically get all component names
  const componentContext = import.meta.glob('~/components/**/*.vue')
  availableComponentNames.value = Object.keys(componentContext).map((key) => {
    return key.split('/').pop()?.replace('.vue', '') || ''
  })
  if (availableComponentNames.value.length > 0) {
    selectComponent(availableComponentNames.value[0])
  }
})

const selectComponent = (component) => {
  selectedComponentName.value = component
  props.value = getDefaultProps(component)
  state.value = getInitialState(component)
  events.value = []
}

const updateProps = (newProps) => {
  props.value = newProps
}

const updateState = (newState) => {
  state.value = newState
}

const logEvent = (event) => {
  events.value.push({
    name: event.name,
    payload: event.payload,
    timestamp: new Date(),
  })
}

const previewAreaSize = ref({ width: '100%', height: '300px' })

const setViewportSize = (size: 'mobile' | 'tablet' | 'desktop') => {
  switch (size) {
    case 'mobile':
      previewAreaSize.value = { width: '375px', height: '667px' }
      break
    case 'tablet':
      previewAreaSize.value = { width: '768px', height: '1024px' }
      break
    case 'desktop':
    default:
      previewAreaSize.value = { width: '100%', height: '600px' }
      break
  }
}

const getDefaultProps = (component: any) => {
  const defaultProps: Record<string, any> = {}
  if (component.props) {
    Object.entries(component.props).forEach(([key, value]: [string, any]) => {
      if (value.default !== undefined) {
        defaultProps[key] = typeof value.default === 'function' ? value.default() : value.default
      } else if (value.type) {
        // Provide sensible defaults based on prop type
        switch (value.type) {
          case String:
            defaultProps[key] = ''
            break
          case Number:
            defaultProps[key] = 0
            break
          case Boolean:
            defaultProps[key] = false
            break
          case Array:
            defaultProps[key] = []
            break
          case Object:
            defaultProps[key] = {}
            break
          // Add more types as needed
        }
      }
    })
  }
  return defaultProps
}

const getInitialState = (component: any) => {
  const initialState: Record<string, any> = {}
  if (component.setup) {
    // This is a basic approach and might not work for all components
    // A more robust solution would involve analyzing the setup function
    const setupResult = component.setup()
    Object.entries(setupResult).forEach(([key, value]: [string, any]) => {
      if (value.value !== undefined) {
        // Assume it's a ref
        initialState[key] = value.value
      } else if (typeof value === 'function') {
        // Assume it's a computed property or method, skip it
      } else {
        // Assume it's a plain value
        initialState[key] = value
      }
    })
  }
  return initialState
}
</script>

<style scoped>
.component-playground {
  display: flex;
  height: 100vh;
}

.main-area {
  flex-grow: 1;
  display: grid;
  grid-template-columns: 1fr 1fr;
  grid-template-rows: auto 1fr 1fr;
  gap: 1rem;
  padding: 1rem;
}
</style>
</file>

<file path="apps/main-app/components/dev/EventLogger.vue">
<template>
  <div class="event-logger">
    <h3>Event Log</h3>
    <ul>
      <li
        v-for="(event, index) in events"
        :key="index"
      >
        <strong>{{ event.name }}</strong>
        <span>{{ formatTimestamp(event.timestamp) }}</span>
        <pre>{{ JSON.stringify(event.payload, null, 2) }}</pre>
      </li>
    </ul>
  </div>
</template>

<script setup lang="ts">
import { defineProps } from 'vue'

interface Event {
  name: string
  payload: any
  timestamp: Date
}

defineProps<{
  events: Event[]
}>()

const formatTimestamp = (timestamp: Date) => {
  return new Intl.DateTimeFormat('en-US', {
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit',
    fractionalSecondDigits: 3,
  }).format(timestamp)
}
</script>

<style scoped>
.event-logger {
  height: 300px;
  overflow-y: auto;
  border: 1px solid #ccc;
  border-radius: 4px;
  padding: 10px;
}

ul {
  list-style-type: none;
  padding: 0;
}

li {
  margin-bottom: 10px;
  border-bottom: 1px solid #eee;
  padding-bottom: 10px;
}

strong {
  color: #333;
}

span {
  color: #666;
  font-size: 0.8em;
  margin-left: 10px;
}

pre {
  background-color: #f5f5f5;
  padding: 5px;
  border-radius: 4px;
  font-size: 0.9em;
  overflow-x: auto;
}
</style>
</file>

<file path="apps/main-app/components/dev/Helpers.vue">
<template>
  <div class="space-y-4 p-4">
    <PrimeButton
      :pt="{ root: 'px-2 py-1 text-sm' }"
      severity="danger"
      @click="clearState"
    >
      Nuxt State
    </PrimeButton>
    <PrimeButton
      :pt="{ root: 'px-2 py-1 text-sm' }"
      severity="danger"
      label="Nuxt Data"
      @click="clearData"
    />
    <PrimeButton
      :pt="{ root: 'px-2 py-1 text-sm' }"
      severity="danger"
      label="Ref Nuxt Data"
      @click="refreshData"
    />
    <PrimeButton
      :pt="{ root: 'px-2 py-1 text-sm' }"
      severity="danger"
      label="Reload App"
      @click="reloadApp"
    />
    <PrimeButton
      :pt="{ root: 'px-2 py-1 text-sm' }"
      severity="danger"
      label="Reset Pinia"
      @click="resetAllStores"
    />
  </div>
</template>

<script setup lang="ts">
import { ref } from 'vue'
import { getActivePinia } from 'pinia'
import type { Store, Pinia } from 'pinia'
import { clearNuxtState, clearNuxtData, refreshNuxtData, reloadNuxtApp } from '#app'

interface ExtendedPinia extends Pinia {
  _s: Map<string, Store>
}

const isRefreshing = ref(false)

const clearState = () => {
  clearNuxtState()
}

const clearData = () => {
  clearNuxtData()
}

const refreshData = async () => {
  isRefreshing.value = true
  try {
    await refreshNuxtData()
  } finally {
    isRefreshing.value = false
  }
}

const reloadApp = () => {
  reloadNuxtApp()
}

const resetPinia = (): Record<string | 'all', () => void> => {
  const pinia = getActivePinia() as ExtendedPinia

  if (!pinia) {
    throw new Error('There are no stores')
  }

  const resetStores: Record<string, () => void> = {}

  pinia._s.forEach((store, name) => {
    resetStores[name] = () => store.$reset()
  })

  resetStores.all = () => pinia._s.forEach((store) => store.$reset())
  return resetStores
}

const resetAllStores = () => {
  const stores = resetPinia()
  stores.all()
}
</script>

<style scoped></style>
</file>

<file path="apps/main-app/components/dev/PreviewArea.vue">
<!-- PreviewArea.vue -->
<template>
  <div class="preview-area">
    <component
      :is="component"
      v-bind="props"
      v-on="eventHandlers"
    />
  </div>
</template>

<script setup lang="ts">
import { computed } from 'vue'

const props = defineProps<{
  component: any
  props: Record<string, any>
  state: Record<string, any>
}>()

const emit = defineEmits<{
  (e: 'event', eventName: string, eventData: any): void
}>()

const eventHandlers = computed(() => {
  return Object.keys(props.component.emits || {}).reduce(
    (acc, eventName) => {
      acc[eventName] = (eventData: any) => emit('event', eventName, eventData)
      return acc
    },
    {} as Record<string, (eventData: any) => void>,
  )
})
</script>

<style scoped>
.preview-area {
  padding: 20px;
  border: 1px solid #ccc;
  border-radius: 4px;
  overflow: auto;
}
</style>
</file>

<file path="apps/main-app/components/dev/PropsEditor.vue">
<template>
  <div class="props-editor">
    <h3>Props</h3>
    <div
      v-for="(value, key) in props"
      :key="key"
    >
      <label>{{ key }}</label>
      <input
        :value="value"
        :type="getInputType(value)"
        @input="updateProp(key, $event.target.value)"
      />
    </div>
  </div>
</template>

<script setup lang="ts">
import { computed } from 'vue'

const props = defineProps<{
  props: Record<string, any>
}>()

const emit = defineEmits<{
  (e: 'update:props', props: Record<string, any>): void
}>()

const updateProp = (key: string, value: any) => {
  emit('update:props', { ...props.props, [key]: value })
}

const getInputType = (value: any) => {
  switch (typeof value) {
    case 'number':
      return 'number'
    case 'boolean':
      return 'checkbox'
    default:
      return 'text'
  }
}
</script>
</file>

<file path="apps/main-app/components/dev/ResponsiveTester.vue">
<template>
  <div class="responsive-tester">
    <button @click="$emit('change', 'mobile')"> Mobile </button>
    <button @click="$emit('change', 'tablet')"> Tablet </button>
    <button @click="$emit('change', 'desktop')"> Desktop </button>
  </div>
</template>

<script setup lang="ts">
defineEmits<{
  (e: 'change', size: 'mobile' | 'tablet' | 'desktop'): void
}>()
</script>

<style scoped>
.responsive-tester {
  display: flex;
  gap: 10px;
  margin-bottom: 10px;
}

button {
  padding: 5px 10px;
  background-color: #f0f0f0;
  border: 1px solid #ccc;
  border-radius: 4px;
  cursor: pointer;
}

button:hover {
  background-color: #e0e0e0;
}
</style>
</file>

<file path="apps/main-app/components/dev/Settings.vue">
<script setup lang="ts">
import { ref, reactive } from 'vue'
import { useRuntimeConfig } from '#app'

const config = useRuntimeConfig()
const { $devHelper } = useNuxtApp()

const showControls = ref(false)
const features = reactive({ ...config.public.devHelper.features })

const updateFeature = (feature: string) => {
  $devHelper.toggleFeature(feature, features[feature])
}

const formatFeatureName = (feature: string) => {
  return feature
    .split(/(?=[A-Z])/)
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ')
}

const closeControls = () => {
  showControls.value = false
}
</script>

<template>
  <div class="foreground rounded-lg shadow-lg">
    <div class="border-color border-b px-4 py-3">
      <h3 class="text-lg font-medium"> Error Logging Controls </h3>
    </div>
    <div class="px-4 py-3">
      <div class="space-y-3">
        <div
          v-for="(enabled, feature) in features"
          :key="feature"
          class="flex items-center"
        >
          <PrimeCheckbox
            :id="feature"
            v-model="features[feature]"
            :binary="true"
            class="mr-3"
            @change="updateFeature(feature)"
          />
          <label
            :for="feature"
            class="cursor-pointer text-sm"
            >{{ formatFeatureName(feature) }}</label
          >
        </div>
      </div>
    </div>
  </div>
</template>
</file>

<file path="apps/main-app/components/dev/StateManager.vue">
<template>
  <div class="state-manager">
    <h3>State</h3>
    <div
      v-for="(value, key) in state"
      :key="key"
    >
      <label>{{ key }}</label>
      <input
        :value="value"
        @input="updateState(key, $event.target.value)"
      />
    </div>
  </div>
</template>

<script setup lang="ts">
const props = defineProps<{
  state: Record<string, any>
}>()

const emit = defineEmits<{
  (e: 'update:state', state: Record<string, any>): void
}>()

const updateState = (key: string, value: any) => {
  emit('update:state', { ...props.state, [key]: value })
}
</script>
</file>

<file path="apps/main-app/components/folder/FolderForm.vue">
<template>
  <form
    class="flex flex-col gap-8"
    @submit.prevent="handleSubmit"
  >
    <div>
      <label class="block text-sm font-medium">Name</label>
      <PrimeInputText
        v-model="formData.name"
        type="text"
        class="mt-1 block w-full rounded-md"
        required
      />
    </div>

    <div class="flex items-center gap-4">
      <label class="block text-sm font-medium">Color</label>
      <div class="mt-1 flex items-center gap-2">
        <PrimeColorPicker v-model="formData.color" />
        <span class="text-sm">{{ formData.color }}</span>
      </div>

      <label class="flex items-center">
        <PrimeCheckbox
          v-model="formData.is_favorite"
          :binary="true"
        />
        <span class="ml-2 text-sm">Add to favorites</span>
      </label>

      <label class="flex items-center">
        <PrimeCheckbox
          v-model="formData.is_default"
          :binary="true"
        />
        <span class="ml-2 text-sm">Set as default</span>
      </label>
    </div>

    <div class="flex justify-between">
      <PrimeButton
        v-if="folder"
        type="button"
        severity="danger"
        @click="$emit('delete')"
      >
        Delete Folder
      </PrimeButton>
      <div
        v-else
        class="flex-grow"
      />

      <div class="flex gap-2">
        <PrimeButton
          type="button"
          severity="secondary"
          @click="$emit('cancel')"
        >
          Cancel
        </PrimeButton>
        <PrimeButton type="submit">
          {{ folder ? 'Save Changes' : 'Create Folder' }}
        </PrimeButton>
      </div>
    </div>
  </form>
</template>

<script setup lang="ts">
import type { Folder } from '~/types/folder'

const props = defineProps<{
  folder?: Folder
}>()

const emit = defineEmits<{
  (e: 'submit', data: Partial<Folder>): void
  (e: 'cancel'): void
  (e: 'delete'): void
}>()

const formData = ref(
  props.folder
    ? {
        ...props.folder,
        color: props.folder.color.startsWith('#') ? props.folder.color : `#${props.folder.color}`,
      }
    : {
        name: '',
        color: '#94A3B8',
        is_favorite: false,
        is_default: false,
      },
)

const handleSubmit = () => {
  const color = formData.value.color.startsWith('#')
    ? formData.value.color
    : `#${formData.value.color}`

  emit('submit', {
    name: formData.value.name,
    color,
    is_favorite: formData.value.is_favorite,
    is_default: formData.value.is_default,
  })
}
</script>
</file>

<file path="apps/main-app/components/folder/FolderItem.vue">
<!-- FolderItem.vue -->
<template>
  <div
    :class="[
      'group flex items-center px-2 py-1.5 rounded-md cursor-pointer',
      isSelected ? 'border' : 'hover:border-primary-950 border border-color foreground',
    ]"
    :style="{ paddingLeft: `${depth * 1.5 + 0.5}rem` }"
  >
    <div class="flex-1 flex items-center min-w-0">
      <div
        class="w-2 h-2 rounded-full mr-2"
        :style="{ backgroundColor: folder.color }"
      />
      <Icon
        v-if="folder.is_favorite"
        name="mdi:star"
        class="w-4 h-4 text-yellow-400 mr-1"
      />
      <span class="truncate">{{ folder.name }}</span>
      <span
        v-if="folder.is_default"
        class="ml-2 px-1.5 py-0.5 text-xs rounded-full bg-primary-900"
      >
        Default
      </span>
    </div>

    <div class="flex items-center gap-1 opacity-0 group-hover:opacity-100">
      <button
        class="p-1"
        @click.stop="$emit('edit', folder)"
      >
        <Icon
          name="mdi:pencil"
          class="w-4 h-4"
        />
      </button>
      <button
        v-if="!folder.is_default"
        class="p-1 hover:text-red-600"
        @click.stop="$emit('delete', folder)"
      >
        <Icon
          name="mdi:trash"
          class="w-4 h-4"
        />
      </button>
    </div>
  </div>

  <div v-if="folder.children?.length">
    <FolderItem
      v-for="child in folder.children"
      :key="child.id"
      :folder="child"
      :depth="depth + 1"
      :selected-id="selectedId"
      @select="$emit('select', $event)"
      @edit="$emit('edit', $event)"
      @delete="$emit('delete', $event)"
    />
  </div>
</template>

<script setup lang="ts">
import type { Folder } from '../../types/bookmarks'

const props = defineProps<{
  folder: Folder
  depth?: number
  selectedId?: string
}>()

defineEmits<{
  (e: 'select' | 'edit' | 'delete', folder: Folder): void
}>()

const isSelected = computed(() => props.folder.id === props.selectedId)
</script>
</file>

<file path="apps/main-app/components/folder/FolderTree.vue">
<!-- FolderTree.vue -->
<script setup lang="ts">
const { folders, flatFolders, getFavorites, createFolder } = useFolderSystem()
const { checkFeatureLimit, getFeatureUsage, getUpgradeMessage } = usePlan()

const canCreateFolder = computed(() => {
  return checkFeatureLimit('BOOKMARK_FOLDERS', folders.value.length)
})

const folderUsage = computed(() => getFeatureUsage('BOOKMARK_FOLDERS', folders.value.length))

const showNewFolderModal = ref(false)
const selectedFolderId = ref<string | null>(null)

const selectFolder = (folder: Folder) => {
  selectedFolderId.value = folder.id
}

const handleNewFolder = () => {
  createNewFolder()
}

const newFolder = ref({
  name: '',
  parent_id: null,
  color: '#94A3B8',
  is_favorite: false,
  is_default: false,
})

const createNewFolder = async () => {
  await createFolder(newFolder.value)
  showNewFolderModal.value = false
  newFolder.value = {
    name: '',
    parent_id: null,
    color: '#94A3B8',
    is_favorite: false,
    is_default: false,
  }
}
</script>

<template>
  <div class="space-y-2">
    <div class="mt-4">
      <button
        v-if="canCreateFolder"
        class="w-full flex items-center justify-center px-4 py-2 text-sm font-medium border border-color bg-primary-500 rounded-md"
        @click="showNewFolderModal = true"
      >
        <Icon
          name="mdi:plus"
          class="w-4 h-4 mr-2"
        />
        New Folder
        <span
          v-if="!folderUsage.isUnlimited"
          class="ml-1"
        >
          ({{ folderUsage.used }}/{{ folderUsage.limit }})
        </span>
      </button>
      <div
        v-else
        class="text-sm p-3 rounded-md"
      >
        <p>You've reached the folder limit.</p>
        <NuxtLink
          to="/premium"
          class="text-primary-600 hover:text-primary-700 font-medium"
        >
          {{ getUpgradeMessage('BOOKMARK_FOLDERS') }}
        </NuxtLink>
      </div>
    </div>

    <div
      v-if="getFavorites.length"
      class="mb-4"
    >
      <h3 class="font-medium mb-2">Favorites</h3>
      <div class="space-y-1">
        <FolderItem
          v-for="folder in getFavorites"
          :key="folder.id"
          :folder="folder"
          @select="selectFolder"
        />
      </div>
    </div>

    <!-- Folder Tree -->
    <div class="space-y-1">
      <FolderItem
        v-for="folder in folders"
        :key="folder.id"
        :folder="folder"
        @select="selectFolder"
      />
    </div>

    <!-- New Folder Dialog -->
    <PrimeDialog
      v-model:visible="showNewFolderModal"
      modal
      header="New Folder"
      :style="{ width: '90vw', maxWidth: '500px' }"
    >
      <!-- Main Content -->
      <span class="block mb-4">Create a new folder to organize your bookmarks.</span>

      <form
        class="space-y-4"
        @submit.prevent="handleNewFolder"
      >
        <div class="flex items-center gap-4 mb-4">
          <label
            for="folderName"
            class="font-semibold w-24"
            >Name</label
          >
          <PrimeInputText
            id="folderName"
            v-model="newFolder.name"
            class="flex-auto"
            required
            autofocus
          />
        </div>

        <div class="flex items-center gap-4 mb-4">
          <label
            for="parentFolder"
            class="font-semibold w-24"
            >Parent</label
          >
          <PrimeSelect
            id="parentFolder"
            v-model="newFolder.parent_id"
            :options="flatFolders"
            option-label="name"
            option-value="id"
            placeholder="Select a parent folder"
            class="flex-auto"
          />
        </div>

        <div class="flex items-center gap-4 mb-4">
          <label
            for="folderColor"
            class="font-semibold w-24"
            >Color</label
          >
          <div class="flex items-center gap-2 flex-auto">
            <input
              id="folderColor"
              v-model="newFolder.color"
              type="color"
              class="h-8 w-8 rounded cursor-pointer"
            />
            <span class="text-sm">{{ newFolder.color }}</span>
          </div>
        </div>

        <div class="flex items-center gap-4">
          <label class="flex items-center flex-1">
            <PrimeCheckbox
              v-model="newFolder.is_favorite"
              :binary="true"
            />
            <span class="ml-2">Add to favorites</span>
          </label>

          <label class="flex items-center flex-1">
            <PrimeCheckbox
              v-model="newFolder.is_default"
              :binary="true"
            />
            <span class="ml-2">Set as default</span>
          </label>
        </div>
      </form>

      <!-- Footer -->
      <template #footer>
        <PrimeButton
          label="Cancel"
          class="p-button-text"
          severity="secondary"
          @click="showNewFolderModal = false"
        />
        <PrimeButton
          label="Create"
          @click="handleNewFolder"
        />
      </template>
    </PrimeDialog>
  </div>
</template>
</file>

<file path="apps/main-app/components/form/FormPassword.vue">
<script setup lang="ts">
interface Props {
  modelValue: string
  id?: string
  suggestions?: string[]
  invalid?: boolean
  placeholder?: string
  disabled?: boolean
  required?: boolean
  inputClass?: string
  label?: string
  mediumRegex?: string
  strongRegex?: string
  feedback?: boolean
}

const props = withDefaults(defineProps<Props>(), {
  label: undefined,
  id: 'password',
  suggestions: () => [
    'At least one lowercase',
    'At least one uppercase',
    'At least one numeric',
    'Minimum 6 characters',
  ],
  invalid: false,
  feedback: true,
  placeholder: undefined,
  disabled: false,
  required: false,
  inputClass: 'w-full',
  mediumRegex:
    '^(((?=.*[a-z])(?=.*[A-Z]))|((?=.*[a-z])(?=.*[0-9]))|((?=.*[A-Z])(?=.*[0-9])))(?=.{6,})',
  strongRegex: '^(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9])(?=.{8,})',
})

const emit = defineEmits<{
  (e: 'update:modelValue', value: string): void
}>()

const onPasswordChange = (value: string) => {
  emit('update:modelValue', value)
}
</script>

<template>
  <label
    v-if="label"
    :for="id"
    >{{ label }}</label
  >
  <PrimePassword
    :id="id"
    class="w-full"
    :input-class="inputClass"
    :feedback="props.feedback"
    :model-value="modelValue"
    :invalid="invalid"
    :disabled="disabled"
    :required="required"
    :placeholder="placeholder"
    :label="props.label"
    @update:model-value="onPasswordChange"
  >
    <template #footer>
      <PrimeDivider />
      <p class="mt-2"> Suggestions </p>
      <ul
        class="ml-2 mt-0 pl-2"
        style="line-height: 1.5"
      >
        <li
          v-for="suggestion in props.suggestions"
          :key="suggestion"
        >
          {{ suggestion }}
        </li>
      </ul>
    </template>
  </PrimePassword>
</template>

<style scoped></style>
</file>

<file path="apps/main-app/components/nav/NavAppTop.vue">
<script setup lang="ts">
const router = useRouter()
const userStore = useCurrentUser()
const toast = useNotification()
const supabase = useSupabaseClient()
const { profile, isAdmin } = storeToRefs(userStore)
const { aeAdminUrl, aeLoginUrl, aeAuthUrl } = useRuntimeConfig().public

const profileMenu = ref(null)
const toggleMenu = (e) => {
  profileMenu.value?.toggle(e)
}

const items = computed(() => {
  const menuItems = [
    {
      label: 'Settings',
      command: () => router.push('/profile/settings/profile'),
    },
    {
      label: 'Logout',
      command: signOut,
    },
  ]

  if (isAdmin.value) {
    menuItems.splice(2, 0, {
      label: 'Admin',
      command: () => navigateTo(aeAdminUrl, { external: true }),
    })
  }

  return menuItems
})

const signOut = async () => {
  const { error } = await supabase.auth.signOut()

  if (error) {
    console.error(error.message)
    toast.error({ summary: 'Could not log out', message: error.message })
  } else {
    return navigateTo(String(`${aeAuthUrl}${aeLoginUrl}`), { external: true })
  }
}

const loading = useLoadingStore()
const isLoading = computed(() => loading.isLoading('currentUser'))

const avatarUrl = ref(null)

watch(
  profile,
  (newProfile) => {
    avatarUrl.value = newProfile?.avatar || '/defaults/avatar.jpg'
  },
  { immediate: true },
)

const logError = (error) => {
  console.log('Error loading image, default image rendered', error)
}

// !todo: show a back button on tablet and below, left of nav.
// !todo: add styling to profileMenu nav to make it full screen on tablet and below
</script>

<template>
  <div
    class="foreground border-color sticky left-0 top-0 z-50 flex min-h-[60px] w-full flex-row items-center justify-between gap-4 border-b px-4 py-1"
  >
    <!-- start -->
    <div class="flex items-center gap-4">
      <IBNavHamburger />
      <IBBreadcrumbs class="hidden text-sm lg:block" />
    </div>
    <!-- center -->
    <div class="flex w-full max-w-[70%] gap-4 px-4 py-2 lg:max-w-xl" />
    <!-- end -->
    <ClientOnly>
      <div
        v-if="isLoading || !profile?.user_role"
        class="flex items-center justify-end gap-4"
      >
        <PrimeSkeleton class="min-h-4 min-w-10 rounded-md" />
        <PrimeSkeleton
          :pt="{
            root: 'min-w-10 min-h-10 rounded-full',
          }"
        />
      </div>
      <div
        v-else-if="profile?.user_role"
        class="flex items-center justify-center gap-4"
      >
        <!-- <AppThemeToggle v-slot="{ toggle, isDark }">
          <Icon
            :name="isDark ? 'heroicons:sun' : 'heroicons:moon'"
            class="cursor-pointer"
                      size="24px"

            @click="toggle"
          />
        </AppThemeToggle> -->
        <PrimeTag v-if="profile.user_role">
          {{ profile.user_role }}
        </PrimeTag>
        <PrimeAvatar
          v-if="avatarUrl"
          :image="avatarUrl"
          size="normal"
          shape="circle"
          class="cursor-pointer"
          aria-haspopup="true"
          aria-controls="overlay_menu"
          crossorigin="anonymous"
          @error="logError"
          @click="toggleMenu"
        />
        <PrimeMenu
          id="overlay_menu"
          ref="profileMenu"
          :model="items"
          :popup="true"
        />
      </div>
    </ClientOnly>
  </div>
</template>
</file>

<file path="apps/main-app/components/nav/NavMobiBottom.vue">
// components/nav/NavMobiBottom.vue
<script setup lang="ts">
const { appLinks } = usePages()

// Function to get main navigation items from categories
const mainNavItems = computed(() => {
  // For mobile, we'll show:
  // 1. Home from 'main' category
  // 2. Feed from 'news' category
  // 3. Profile links
  const items = []

  // Get home from main
  const mainCategory = appLinks.value.find((cat) => cat.id === 'main')
  if (mainCategory?.items?.[0]) {
    items.push(mainCategory.items[0])
  }

  // Get feed from news
  const newsCategory = appLinks.value.find((cat) => cat.id === 'news')
  if (newsCategory?.items?.[0]) {
    items.push(newsCategory.items[0])
  }

  // Get profile section
  const profileCategory = appLinks.value.find((cat) => cat.id === 'profile')
  if (profileCategory?.items?.[0]) {
    // Add first profile item (or you can create a specific profile route)
    items.push({
      id: profileCategory.items[0].id,
      label: 'Profile',
      slug: '/profile',
      icon: 'mdi:account-circle-outline',
    })
  }

  return items
})

// Active route handling
const route = useRoute()
const isActive = (slug: string) => {
  if (slug === '/') {
    return route.path === '/'
  }
  return route.path.startsWith(slug)
}
</script>

<template>
  <div
    class="fixed bottom-0 left-0 flex-row w-full items-center justify-between foreground p-2 h-[var(--mobi-bottom-nav-height)] border-t border-color"
  >
    <ul class="flex flex-row items-center justify-center w-full h-full">
      <li
        v-for="item in mainNavItems"
        :key="item.id"
        class="flex items-center justify-center w-full h-full cursor-pointer"
      >
        <NuxtLink
          :to="item.slug"
          class="flex flex-col justify-center items-center gap-1 px-2"
          :class="{ 'text-primary-500': isActive(item.slug) }"
        >
          <ClientOnly>
            <Icon
              :name="item.icon"
              size="24px"
            />
            <span class="text-xs">{{ item.label }}</span>
          </ClientOnly>
        </NuxtLink>
      </li>
    </ul>
  </div>
</template>

<style scoped>
.router-link-active {
  @apply text-primary-500;
}

/* Optional: Add transition for active state */
.router-link-active .icon {
  @apply transform scale-110 transition-transform;
}
</style>
</file>

<file path="apps/main-app/components/nav/NavMobiSlideover.vue">
<template>
  <div>
    <PrimeButton
      variant="link"
      :padded="false"
      @click="isOpen = true"
    >
      <Icon
        name="mdi:menu"
        class="text-white"
        size="24px"
      />
    </PrimeButton>
    <PrimeDrawer v-model:visible="isOpen">
      <div class="border-color border-r">
        <div class="foreground flex w-full items-center justify-between p-8">
          <NuxtLink
            class="flex items-center gap-4"
            to="/"
            @click="isOpen = false"
          >
            <div class="flex aspect-square rounded-full bg-white p-2">
              <IBImage
                :img="{
                  src: '/astronera-logo.jpg',
                  alt: 'Astron Era Logo',
                }"
                class="h-8 w-8 md:h-12 md:w-12"
              />
            </div>
            <h3 class="text-xl"> AstronEra </h3>
          </NuxtLink>
          <PrimeButton
            variant="solid"
            icon="mdi:chevron-left"
            @click="isOpen = false"
          >
            Return
          </PrimeButton>
        </div>
        <div v-show="links">
          <NuxtLink
            v-for="link in links"
            :key="link.id"
            :to="link.slug"
            class="border-color flex w-full items-center justify-end border-b px-8 py-3 text-sm font-medium"
            @click="isOpen = false"
          >
            {{ link.name }}
            <Icon
              :name="getIcon(link.name)"
              class="ml-2"
              size="24px"
            />
          </NuxtLink>
        </div>
      </div>
    </PrimeDrawer>
  </div>
</template>

<script setup lang="ts">
const isOpen = ref(false)

const getIcon = (val: string) => {
  if (val === 'Contact') return 'material-symbols:info'
  if (val === 'About') return 'material-symbols:call'
  if (val === 'Preview') return 'material-symbols:globe-asia'
  if (val === 'Team') return 'material-symbols:emoji-people'
  if (val === 'Blog') return 'material-symbols:article'
  if (val === 'Community') return 'material-symbols:groups-rounded'
  if (val === 'Conference') return 'mdi:presentation'
}

defineProps({
  links: {
    type: Array as PropType<object[]>,
    required: true,
  },
})
</script>

<style scoped></style>
</file>

<file path="apps/main-app/components/news/NewsCard.vue">
<script setup lang="ts">
import { useTimeAgo } from '@vueuse/core'
import { ref, onMounted } from 'vue'

export interface NewsCardT {
  id: string
  title: string
  description: string
  authorName: string
  published_at?: string
  featured_image: string
  created_at: string
  url: string
  comments: number
  score?: number
}

interface Props {
  news: NewsCardT
}

const props = defineProps<Props>()
const voteStore = useVoteStore()

const { isNewsBookmarked, toggleBookmark } = useBookmarks()

const showModal = ref(false)
const modalContent = ref('')
const currentVote = ref<number | null>(null)
const score = ref(props.news.score || 0)
const bookmarked = computed(() => isNewsBookmarked.value(props.news.id))

const handleBookmark = async () => {
  try {
    await toggleBookmark({
      id: props.news.id,
      type: 'news',
      title: props.news.title,
      thumbnail: props.news.featured_image,
      url: props.news.url,
    })
  } catch (error) {
    console.error('Error handling bookmark:', error)
  }
}

const displayScore = computed(() => {
  const currentScore = voteStore.getScore(props.news.id) ?? score.value

  // Only show negative numbers if user has downvoted
  if (currentScore < 0 && currentVote.value !== -1) {
    return 0
  }
  return currentScore
})

const readTime = computed(() => {
  // Calculate read time based on content length
  // This is a placeholder, replace with actual logic
  return '2m read time'
})

onMounted(async () => {
  try {
    if (voteStore.getScore(props.news.id) == null)
      voteStore.setVotes(props.news.id, props.news.score || 0)
  } catch (error) {
    console.error('Error fetching vote status:', error)
  }
})

const handleVoteChange = ({ change }: { voteType: number | null; change: number }) => {
  score.value += change
}

const openModal = (feature: string) => {
  modalContent.value = `The ${feature} feature is coming soon! Stay tuned for updates.`
  showModal.value = true
}
</script>

<template>
  <div class="rounded-lg relative border border-color w-full">
    <div class="p-4 flex flex-col justify-between h-full">
      <div>
        <div class="flex items-center gap-2 mb-2">
          <NuxtImg
            :src="`https://picsum.photos/24/24?random=${news.id}`"
            alt="Author"
            class="w-6 h-6 rounded-full"
            width="24"
            height="24"
          />
          <span class="text-sm">{{ news.authorName }}</span>
        </div>
        <h2 class="text-xl font-bold mb-2">{{ news.title }}</h2>
        <div class="flex items-center text-sm mb-4">
          <span>{{ useTimeAgo(news.published_at ?? news.created_at).value }}</span>
          <span class="mx-2">•</span>
          <span>{{ readTime }}</span>
        </div>
      </div>
      <div>
        <div class="mb-4">
          <NuxtImg
            :provider="!!news.featured_image && 'supabase'"
            :src="news.featured_image || 'fallback-news.jpg'"
            :alt="news.title"
            class="w-full h-auto rounded-lg"
            width="400"
            height="200"
          />
        </div>
        <div class="flex items-center justify-between">
          <div class="flex items-center gap-4">
            <div class="flex items-center justify-center bg-primary-950 py-1 px-2 rounded-xl">
              <VoteButton
                :content-id="news.id"
                direction="up"
                :initial-vote-type="currentVote"
                @vote-change="handleVoteChange"
              />
              <span class="text-sm font-medium pl-1 pr-2">{{ displayScore }}</span>
              <VoteButton
                :content-id="news.id"
                direction="down"
                :initial-vote-type="currentVote"
                @vote-change="handleVoteChange"
              />
            </div>
            <button
              class="flex items-center gap-2 text-sm hover:text-gray-600"
              @click="openModal('Comments')"
            >
              <Icon
                name="mdi:comment-outline"
                size="20px"
              />
              <span>{{ news.comments }}</span>
            </button>
          </div>
          <div class="flex items-center gap-4">
            <button
              class="hover:text-gray-600"
              @click="handleBookmark"
            >
              <Icon
                :name="bookmarked ? 'mdi:bookmark' : 'mdi:bookmark-outline'"
                size="20px"
                :class="{ 'text-primary-500': bookmarked }"
              />
            </button>
            <NuxtLink
              :to="news.url"
              target="_blank"
              rel="noopener noreferrer nofollow"
              class="hover:text-gray-600"
            >
              <Icon
                name="mdi:link-variant"
                size="20px"
              />
            </NuxtLink>
          </div>
        </div>
      </div>
    </div>
  </div>

  <PrimeDialog
    v-model:visible="showModal"
    modal
    header="Coming Soon"
    :style="{ width: '50vw' }"
  >
    <p>{{ modalContent }}</p>
  </PrimeDialog>
</template>
</file>

<file path="apps/main-app/components/news/NewsCardSkeleton.vue">
<template>
  <div class="border-b border-color">
    <div class="p-6 flex gap-4">
      <PrimeSkeleton
        :pt="{
          root: 'max-w-16 min-h-16 rounded-full',
        }"
      />
    </div>
    <div class="overflow-hidden w-full">
      <PrimeSkeleton class="w-full min-h-[220px] rounded-md" />
    </div>
    <div class="flex flex-col gap-4 p-4">
      <PrimeSkeleton class="w-32 h-4 rounded-md" />
      <PrimeSkeleton class="max-w-64 h-4 rounded-md" />
      <PrimeSkeleton class="max-w-32 h-4 rounded-md" />
      <div class="w-full flex justify-end p-2">
        <PrimeSkeleton class="max-w-32 min-h-12 rounded-md" />
      </div>
    </div>
  </div>
</template>

<script setup lang="ts"></script>

<style scoped></style>
</file>

<file path="apps/main-app/components/news/NewsModal.vue">
<template>
  <div class="foreground relative h-full w-full">
    <div
      class="background sticky left-0 top-0 z-20 flex h-auto w-full items-center justify-between px-4 py-2"
    >
      <h3 class="lg:text-lg text-sm font-semibold">
        {{ posts[currentIndex].title }}
      </h3>
      <div class="flex items-center gap-2">
        <PrimeButton
          to="https://tailwindcss.com/docs/content"
          target="_blank"
          icon="material-symbols:chrome-reader-mode-rounded"
          class="flex items-center justify-end lg:after:content-['Full_Article']"
        />
        <PrimeButton
          icon="mdi:close"
          variant="link"
          @click="$emit('closeNewsModal')"
        />
      </div>
    </div>
    <div class="grid h-full w-full grid-cols-1 gap-4 overflow-scroll py-4 xl:grid-cols-4">
      <div class="grid grid-cols-2 gap-4 xl:col-start-4">
        <NewsNavigationButton
          :condition="nextIndex <= posts.length - 1"
          :is-prev="true"
          :post="posts[nextIndex]"
          :handle-click="nextPost"
        />
        <NewsNavigationButton
          :condition="previousIndex >= 0"
          :post="posts[previousIndex]"
          :handle-click="previousPost"
        />
      </div>
      <div
        v-if="posts[currentIndex].media"
        class="col-start-1 lg:mt-0 xl:col-span-3 xl:row-span-2 xl:row-start-1"
      >
        <LazyImageCarousel
          :media="posts[currentIndex].media"
          class="w-full"
        />
      </div>
      <div
        v-else
        class="col-start-1 overflow-hidden xl:col-span-3 xl:row-span-2 xl:row-start-1"
      >
        <IBImageWithFallback
          :image="undefined"
          :options="{ width: 100, height: 60, quality: 50, sizes: undefined }"
        />
      </div>
      <div class="flex flex-col gap-4">
        <ul class="space-y-2 px-4 pb-8">
          <li
            v-for="sum in posts[currentIndex].summary[summaryLevel]"
            :key="sum"
            class="flex items-start gap-2"
          >
            <Icon
              name="mdi:star"
              class="mt-[3px] flex-shrink-0 text-yellow-500"
              size="18px"
            />
            <p class="flex-grow text-sm leading-snug">
              {{ sum }}
            </p>
          </li>
        </ul>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import type { NewsCardT } from '@/types/news'

defineProps({
  posts: {
    type: Array as () => NewsCardT[],
    required: true,
  },
  currentIndex: {
    type: Number,
    required: true,
  },
  summaryLevel: {
    type: String,
    required: true,
  },
  nextIndex: {
    type: Number,
    required: true,
  },
  previousIndex: {
    type: Number,
    required: true,
  },
  nextPost: {
    type: Function,
    required: true,
  },
  previousPost: {
    type: Function,
    required: true,
  },
})
</script>
</file>

<file path="apps/main-app/components/news/NewsNavigationButton.vue">
<template>
  <PrimeButton
    v-if="condition"
    class="background flex items-center justify-center rounded-md hover:text-primary-500"
    variant="none"
    :padded="false"
    @click="handleClick"
  >
    <div
      class="flex items-center justify-center gap-2 p-2 text-sm font-normal"
      :class="isPrev ? 'flex-row text-right' : 'flex-row-reverse text-left'"
    >
      <Icon
        :name="isPrev ? 'mdi:chevron-left' : 'mdi:chevron-right'"
        class="flex-shrink-0"
        size="24px"
      />
      {{ post.title.substring(0, 54) }}...
    </div>
  </PrimeButton>
</template>

<script setup lang="ts">
import type { NewsCardT } from '@/types/news'

defineProps({
  condition: {
    type: Boolean,
    required: true,
  },
  isPrev: {
    type: Boolean,
    default: false,
  },
  post: {
    type: Object as () => NewsCardT,
    required: true,
  },
  handleClick: {
    type: Function,
    required: true,
  },
})
</script>
</file>

<file path="apps/main-app/components/news/NewsSummaryLevel.vue">
<script setup lang="ts">
const summaryLevels = [
  [
    {
      label: 'Beginner',
      value: 'beginner',
      click: () => news.changeSummaryLevel('beginner'),
    },
  ],
  [
    {
      label: 'Intermediate',
      value: 'intermediate',
      click: () => news.changeSummaryLevel('intermediate'),
    },
  ],
  [
    {
      label: 'Expert',
      value: 'expert',
      click: () => news.changeSummaryLevel('expert'),
    },
  ],
]

const selectedLevel = ref('beginner')
</script>

<template>
  <div class="flex w-full gap-2">
    <PrimeButton @click="news.scrapeBlogs"> Scrape Blogs </PrimeButton>
    <PrimeButton @click="storeImage"> Store Image </PrimeButton>
    <PrimeButton @click="news.getBlogs"> Get Blogs </PrimeButton>
    <div class="mb-4 flex w-full justify-end gap-2">
      <PrimeSelect
        v-model="selectedLevel"
        :options="summaryLevels"
        option-label="label"
        placeholder="Choose Summary Level"
        checkmark
        :highlight-on-select="false"
        mode="hover"
        :popper="{ placement: 'bottom-start' }"
      >
        <PrimeButton
          color="white"
          :label="news.summaryLevel"
          trailing-icon="heroicons:chevron-down-20-solid"
        />
      </PrimeSelect>
    </div>
  </div>
</template>
</file>

<file path="apps/main-app/components/newsletter/NewsletterBasic.vue">
<template>
  <div class="flex justify-center w-full pb-4 mt-10 lg:w-1/2 lg:mt-0 lg:justify-end lg:pb-0">
    <div class="w-10/12 lg:w-1/2">
      <h1 class="mb-6 text-lg font-semibold tracking-wide text-center text-white lg:text-left">
        Subscribe to our Newsletter
      </h1>
      <div class="flex justify-center">
        <div class="relative flex items-center justify-center w-full rounded-2xl">
          <input
            id="email"
            type="email"
            required="true"
            placeholder="Your Email"
            aria-label="email"
            class="w-full h-12 pl-4 text-xs text-gray-700 placeholder-gray-600 bg-transparent rounded-lg lg:h-16 sm:text-base focus:outline-none"
          />
          <button
            type="submit"
            class="absolute inset-y-0 right-0 h-full px-2 py-2 text-xs font-medium transition duration-150 ease-in-out border-l border-gray-300 rounded focus:outline-none lg:text-base text-primary-700 sm:px-6 lg:py-4"
          >
            Subscribe
          </button>
        </div>
      </div>
    </div>
  </div>
</template>
</file>

<file path="apps/main-app/components/notification/Notification.vue">
<script setup lang="ts">
const getIconName = (severity: string) => {
  switch (severity) {
    case 'success':
      return 'mdi:check-circle'
    case 'error':
      return 'mdi:close-circle'
    case 'info':
      return 'mdi:information'
    case 'warn':
      return 'mdi:alert-circle'
    default:
      return 'mdi:information'
  }
}

// :pt="{
//       content: 'border border-color rounded-md shadow-md flex'
//     }"
</script>

<template>
  <PrimeToast
    position="bottom-right"
    group="cta"
  >
    <template #container="{ message, closeCallback }">
      <section class="flex w-full items-start justify-start gap-3 rounded-md p-3 shadow-md">
        <Icon :name="getIconName(message.severity)" />
        <div class="flex w-full flex-col items-start justify-start gap-2">
          <p class="m-0 text-base font-semibold">
            {{ message.summary }}
          </p>
          <p class="m-0 text-base">
            {{ message.detail }}
          </p>
          <div class="mt-2">
            <p class="text-lg foreground rounded-md px-3 py-1 font-bold text-white">
              Premium Plan Coming Soon!
            </p>
            <!-- <NuxtLink :to="message.link">
                <PrimeButton>{{ message.buttonText }}</PrimeButton>
              </NuxtLink> -->
          </div>
        </div>
        <PrimeButton
          severity="contrast"
          @click="closeCallback"
        >
          <Icon name="mdi:close" />
        </PrimeButton>
      </section>
    </template>
  </PrimeToast>
</template>

<style scoped></style>
</file>

<file path="apps/main-app/components/onboarding/Account.vue">
<template>
  <form @submit.prevent="handleSubmit">
    <div class="p-fluid" />
    <div class="mt-4">
      <PrimeButton
        type="button"
        label="Previous"
        class="p-button-secondary mr-2"
        @click="$emit('prev')"
      />
      <PrimeButton
        type="submit"
        label="Submit"
      />
    </div>
  </form>
</template>

<script setup lang="ts">
const { form, errors, validateAndUpdate, accountDetailsSchema } = useOnboarding()

const handleSubmit = () => {
  if (validateAndUpdate(accountDetailsSchema)) {
    // Submit the form data to your API
    console.log('Form submitted:', form)
  }
}

const emit = defineEmits(['prev'])
</script>
</file>

<file path="apps/main-app/components/onboarding/Interests.vue">
<template>
  <div class="p-4">
    <h2 class="text-2xl font-bold mb-4"> Select Your Interests </h2>
    <form @submit.prevent="handleSubmit">
      <div class="p-fluid">
        <div class="p-field">
          <label for="interests">Astronomy and Space Tech Interests</label>
          <PrimeMultiSelect
            id="interests"
            v-model="selectedInterests"
            :options="interestOptions"
            option-label="name"
            placeholder="Select your interests"
            :filter="true"
            :class="{ 'p-invalid': errors.interests }"
          />
          <small
            v-if="errors.interests"
            class="p-error"
            >{{ errors.interests }}</small
          >
        </div>
      </div>
      <PrimeButton
        type="submit"
        label="Save Interests"
        class="mt-4"
      />
    </form>
  </div>
</template>

<script setup lang="ts">
import { z } from 'zod'

const interestOptions = [
  { name: 'Astrophysics' },
  { name: 'Cosmology' },
  { name: 'Planetary Science' },
  { name: 'Exoplanets' },
  { name: 'Astrobiology' },
  { name: 'Radio Astronomy' },
  { name: 'Stellar Evolution' },
  { name: 'Galactic Astronomy' },
  { name: 'Black Holes' },
  { name: 'Dark Matter and Dark Energy' },
  { name: 'Space Exploration' },
  { name: 'Rocket Propulsion' },
  { name: 'Satellite Technology' },
  { name: 'Space Telescopes' },
  { name: 'Gravitational Waves' },
  { name: 'Solar Physics' },
  { name: 'Astrochemistry' },
  { name: 'Astrogeology' },
  { name: 'Space Weather' },
  { name: 'Astronomical Instrumentation' },
  { name: 'Extragalactic Astronomy' },
  { name: 'Astroparticle Physics' },
  { name: 'Spacecraft Engineering' },
  { name: 'Space Medicine' },
  { name: 'Asteroids and Comets' },
]

const selectedInterests = ref([])
const errors = ref({})

const interestsSchema = z.object({
  interests: z.array(z.object({ name: z.string() })).min(1, 'Please select at least one interest'),
})

const handleSubmit = () => {
  const result = interestsSchema.safeParse({ interests: selectedInterests.value })
  if (result.success) {
    // Clear any previous errors
    errors.value = {}
    // Submit the interests to your API
    console.log('Interests submitted:', selectedInterests.value)
    // You can add your API call here
  } else {
    // Update errors
    errors.value = result.error.flatten().fieldErrors
  }
}
</script>
</file>

<file path="apps/main-app/components/onboarding/Professional.vue">
<template>
  <form @submit.prevent="handleSubmit">
    <div class="p-fluid">
      <div class="p-field">
        <label for="occupation">Occupation</label>
        <PrimeSelect
          id="occupation"
          v-model="form.occupation"
          :options="occupationOptions"
          option-label="name"
          option-value="value"
          placeholder="Select an occupation"
          :class="{ 'p-invalid': errors.occupation }"
        />
        <small
          v-if="errors.occupation"
          class="p-error"
          >{{ errors.occupation }}</small
        >
      </div>
      <div class="p-field">
        <label for="organization">Organization</label>
        <PrimeInputText
          id="organization"
          v-model="form.organization"
          :class="{ 'p-invalid': errors.organization }"
        />
        <small
          v-if="errors.organization"
          class="p-error"
          >{{ errors.organization }}</small
        >
      </div>
      <div class="p-field">
        <label for="experience">Years of Experience</label>
        <PrimeInputNumber
          id="experience"
          v-model="form.experience"
          :min="0"
          :max="100"
          :class="{ 'p-invalid': errors.experience }"
        />
        <small
          v-if="errors.experience"
          class="p-error"
          >{{ errors.experience }}</small
        >
      </div>
    </div>
    <div class="mt-4">
      <PrimeButton
        type="button"
        label="Previous"
        class="p-button-secondary mr-2"
        @click="$emit('prev')"
      />
      <PrimeButton
        type="submit"
        label="Next"
      />
    </div>
  </form>
</template>

<script setup lang="ts">
const { form, errors, validateAndUpdate, professionalInfoSchema } = useOnboarding()

const occupationOptions = [
  { name: 'Astronomer', value: 'astronomer' },
  { name: 'Astrophysicist', value: 'astrophysicist' },
  { name: 'Space Engineer', value: 'space_engineer' },
  { name: 'Planetary Scientist', value: 'planetary_scientist' },
  { name: 'Other', value: 'other' },
]

const handleSubmit = () => {
  if (validateAndUpdate(professionalInfoSchema)) {
    emit('next')
  }
}

const emit = defineEmits(['next', 'prev'])
</script>
</file>

<file path="apps/main-app/components/post/PostCard.vue">
<template>
  <div
    v-for="article in store.articles"
    :key="article.id"
    class="group grid origin-left scale-x-0 animate-swipe-in grid-rows-4 overflow-hidden rounded-md shadow-sm"
  >
    <IBImage
      :img="{
        src: s.image.single({
          bucket: 'articles',
          folderPath: `${article.id}`,
          file: article.id,
          isPrivate: false,
        }),
        alt: article.title,
        loading: 'lazy',
      }"
    />
    <div
      class="relative col-span-1 col-start-1 row-span-2 row-start-3 w-full transition-all duration-500 ease-in-out"
    >
      <div class="foreground absolute bottom-0 w-full p-8">
        <NuxtLink :to="`/news/article/${article.id}`">
          <button
            class="absolute left-0 right-0 top-[-20px] mx-auto h-[40px] w-[80%] rounded-md bg-[#440439] px-8 font-bold shadow-lg before:content-['Category'] group-hover:before:content-['Read_more']"
          />
        </NuxtLink>
        <h1 class="pb-4 text-2xl font-semibold">
          {{ article.title }}
        </h1>
        <p
          class="h-[0px] overflow-hidden text-sm transition-all duration-500 ease-in-out group-hover:h-[100px]"
        >
          {{ article.body }}
        </p>
        <!-- <p class="mt-4 text-sm"> {{ article.publisheAt }}</p> -->
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
const store = useArticlesStore()
const s = useStorage()
await store.getArticles()
// const p = useArticlesStore()
</script>

<style scoped></style>
</file>

<file path="apps/main-app/components/research/ResearchCard.vue">
<template>
  <div class="rounded-md border border-color background flex flex-col justify-between">
    <div>
      <div class="space-y-3 p-4">
        <div class="flex gap-2">
          <span class="text-sm w-auto">
            {{ useTimeAgo(research.published_at ?? research.created_at).value }}
          </span>
        </div>
        <h4 class="text-balance text-xl"> {{ research.title.slice(0, 120) }}... </h4>
        <p
          v-if="research.description"
          class="text-sm"
        >
          {{ research.description.slice(0, 360) }}...
        </p>
      </div>
    </div>
    <div class="p-4 flex justify-end items-center">
      <NuxtLink
        :to="`${research.url}v${research.version}`"
        target="_blank"
        rel="noopener"
      >
        <PrimeButton
          label="Read on Axive"
          size="small"
          outlined
        />
      </NuxtLink>
    </div>
  </div>
</template>

<script setup lang="ts">
import type { NewsCardT } from '@/types/news'

defineProps({
  research: {
    type: Object as () => NewsCardT,
    required: true,
  },
  // summaryLevel: {
  //   type: String,
  //   required: true
  // }
})
</script>
</file>

<file path="apps/main-app/components/search/SearchBar.vue">
<script setup lang="ts">
const props = defineProps<{
  selectedPrompt?: string
  systemPrompt?: string
}>()

const chatStore = useChatStore()
const { question, isLoading } = storeToRefs(chatStore)

watch(
  () => props.selectedPrompt,
  (newPrompt) => {
    if (newPrompt) {
      question.value = newPrompt
    }
  },
)

const submitQuestion = async () => {
  if (question.value.trim()) {
    await chatStore.submitQuestion({
      question: question.value,
      systemPrompt: props.systemPrompt,
    })
    question.value = ''
  }
}
</script>

<template>
  <div class="w-full">
    <div class="mx-auto flex w-full max-w-3xl items-center">
      <div
        class="foreground border-color flex w-full items-center rounded-lg border px-2 py-1 pr-2"
      >
        <!-- <PrimeButton
          rounded
          :pt="{ root: 'p-5 flex justify-center items-center relative' }"
          severity="secondary"
        >
          <Icon
            :name="textSearchType === 'fts' ? 'mdi:card-text-outline' : 'mdi:format-list-numbered'"
            class="absolute"
                      size="24px"

          />
        </PrimeButton> -->
        <PrimeTextarea
          ref="messageInput"
          v-model="question"
          auto-resize
          placeholder="Ask Your Question..."
          class="flex resize-none max-h-[120px] w-full items-center justify-center bg-transparent px-4 py-2 outline-none"
          :pt="{ root: 'border-none' }"
          @keyup.enter="submitQuestion"
        />
        <PrimeButton
          pt:root:class="p-0"
          link
          @click="submitQuestion"
        >
          <Icon
            :name="isLoading ? 'mdi:loading' : 'mdi:send'"
            class="font-bold text-primary-500"
            size="24px"
            :class="isLoading ? 'animate-spin' : ''"
          />
        </PrimeButton>
      </div>
    </div>
  </div>
</template>

<style scoped></style>
</file>

<file path="apps/main-app/components/supa/Download.vue">
<template>
  <div class="w-full h-full p-12 example-avatar">
    <button @click="tester"> clicker </button>
    <p>{{ files }}</p>
    <button
      class="p-6 mt-4 bg-red-200"
      @click="tester2"
    >
      clicker2
    </button>
    <p>{{ files2 }}</p>
  </div>
</template>

<script setup>
const files = ref(null)
const files2 = ref(null)

const tester = async () => {
  const { data, error } = await download.folder('9465747a-47a0-46ac-93a7-5151e62b8eff', true)
  if (error) {
    return console.error(error)
  }
  files.value = data
}

const tester2 = async () => {
  const { data, error } = await download.avatar('9465747a-47a0-46ac-93a7-5151e62b8eff', true)
  if (error) {
    return console.error(error)
  }
  files2.value = data
}
</script>

<style scoped></style>
</file>

<file path="apps/main-app/components/supa/Realtime.vue">
<template>
  <div class="flex items-center justify-center w-full h-full p-12 rounded-md shadow-md">
    <div
      v-for="t in store"
      :key="t.id"
    >
      <p> realtime: {{ t }} </p>
    </div>
  </div>
</template>

<script setup lang="ts">
const { table, store } = useRealtime()

table.single()
</script>

<style scoped></style>
</file>

<file path="apps/main-app/components/supa/Upload.vue">
<script setup lang="ts">
const props = defineProps({
  uploadType: {
    type: String as PropType<string>,
    required: true,
  },
})

const imageInput = ref(null) // template ref for file input
const selectedFile = ref(null)
const imageSrc = ref(null)
const img = ref(null)
const cropper = ref({})
const destination = ref(null)

const fileReader = new FileReader()
fileReader.onload = (event) => {
  imageSrc.value = event.target.result
}

const handleImageCropped = () => {
  cropper.value
    .getCroppedCanvas({
      width: 180,
      height: 180,
    })
    .toBlob((blob) => {
      upload.avatar({ file: blob, userId, type: props.uploadType }) // !todo auth user, get id
    }, 'image/png')
  selectedFile.value = null
}
const fileChanged = (e) => {
  const files = e.target.files || e.dataTransfer.files
  if (files.length) {
    selectedFile.value = files[0]
  }
}

const fileCleared = (_) => {
  selectedFile.value = null
}

onMounted(() => {})

onUnmounted(() => {})

watchEffect(() => {
  if (selectedFile.value) {
    fileReader.readAsDataURL(selectedFile.value)
  } else {
    imageSrc.value = null
  }
})

watch(
  imageSrc,
  () => {
    if (imageSrc.value) {
      cropper.value.replace(imageSrc.value)
    }
  },
  {
    flush: 'post', // watch runs after component updates
  },
)
</script>

<template>
  <div class="flex flex-col items-center justify-center w-full h-full gap-4 example-avatar">
    <div
      v-show="imageSrc"
      class="object-fill w-1/2 mx-auto my-4 border-4 rounded-full aspect-ratio border-stone-700"
    >
      <img
        :src="destination"
        class="block w-full rounded-full"
      />
    </div>
    <div
      v-show="imageSrc"
      class="object-fill w-1/2 mx-auto my-2 aspect-ratio"
    >
      <img
        ref="img"
        class="block w-full max-w-full pb-4 aspect-auto"
        :src="imageSrc"
      />
    </div>
    <div class="flex content-end justify-center w-full py-2 mt-2 rounded-md">
      <PrimeButton
        v-if="!imageSrc"
        color="primary"
        @click="imageInput.click()"
      >
        <slot />
      </PrimeButton>
      <PrimeButton
        v-else
        color="primary"
        class="w-32 mx-2"
        @click="handleImageCropped"
      >
        Update
      </PrimeButton>
      <PrimeButton
        v-if="imageSrc"
        color="primary"
        class="w-32 mx-2"
        @click="fileCleared"
      >
        Cancel
      </PrimeButton>
      <input
        ref="imageInput"
        type="file"
        accept=".jpg,.jpeg,.png"
        class="py-4"
        :style="{ display: 'none' }"
        @change="fileChanged"
      />
    </div>
  </div>
</template>

<style scoped>
.preview {
  border: 5px solid #292929;
  overflow: hidden;
  width: 50px;
  height: 50px;
}

.example-avatar .avatar-upload .rounded-circle {
  width: 200px;
  height: 200px;
}

.example-avatar .text-center .btn {
  margin: 0 0.5rem;
}

.example-avatar .avatar-edit-image {
  max-width: 100%;
}

.example-avatar .drop-active {
  top: 0;
  bottom: 0;
  right: 0;
  left: 0;
  position: fixed;
  z-index: 9999;
  opacity: 0.6;
  text-align: center;
  background: #000;
}

.example-avatar .drop-active h3 {
  margin: -0.5em 0 0;
  position: absolute;
  top: 50%;
  left: 0;
  right: 0;
  -webkit-transform: translateY(-50%);
  -ms-transform: translateY(-50%);
  transform: translateY(-50%);
  font-size: 40px;
  color: #fff;
  padding: 0;
}
</style>
</file>

<file path="apps/main-app/components/user/settings/UserSettingsCard.vue">
<script setup lang="ts">
import type { TitleType } from '~/types/content'

defineProps({
  title: {
    type: Object as PropType<TitleType>,
    required: true,
  },
})
</script>

<template>
  <PrimeCard>
    <template #title>
      <div>
        <h2 class="text-2xl font-semibold">
          {{ title.main }}
        </h2>
        <span class="text-base">{{ title.subtitle }}</span>
      </div>
    </template>
    <template #content>
      <div class="flex flex-col">
        <slot />
      </div>
    </template>
    <template #footer>
      <!-- feedback section? -->
    </template>
  </PrimeCard>
</template>

<style scoped></style>
</file>

<file path="apps/main-app/components/user/settings/UserSettingsItem.vue">
<script setup lang="ts">
defineProps({
  item: {
    type: Object,
    required: true,
  },
})
</script>

<template>
  <div
    class="flex flex-col md:flex-row gap-4 md:gap-8 w-full h-auto border-color py-4 justify-between border-y"
  >
    <div class="flex flex-col gap-4 justify-start max-w-48 w-full">
      <div class="space-y-2 w-full">
        <p class="text-lg font-bold">
          {{ item.label }}
        </p>
        <p class="text-sm">
          {{ item.tip }}
        </p>
      </div>
    </div>
    <div class="w-full">
      <slot />
    </div>
  </div>
</template>

<style scoped></style>
</file>

<file path="apps/main-app/components/vote/VoteAnimate.vue">
<script setup lang="ts">
import { ref } from 'vue'

interface Props {
  direction?: 'up' | 'down' | 'none'
  showParticles?: boolean
  contentId: string
}

const props = withDefaults(defineProps<Props>(), {
  direction: 'none',
  showParticles: false,
})

const isAnimating = ref(false)

const createParticles = () => {
  // Debug logging
  console.log('Creating particles for ID:', props.contentId)

  const element = document.querySelector(`#vote-animate-${props.contentId}`)
  if (!element) {
    console.warn('Target element not found:', `#vote-animate-${props.contentId}`)
    return
  }

  const rect = element.getBoundingClientRect()
  console.log('Element position:', rect)

  const particles = 5
  const particleClass = `particle-${props.contentId}`

  // Remove any existing particles first
  document.querySelectorAll(`.${particleClass}`).forEach((el) => el.remove())

  for (let i = 0; i < particles; i++) {
    const particle = document.createElement('div')
    particle.className = particleClass

    // Position particle at button center
    const startX = rect.left + rect.width / 2
    const startY = rect.top + rect.height / 2

    // Calculate random angle and distance
    const angle = Math.random() * Math.PI * 2
    const distance = 30 + Math.random() * 20 // 30-50px distance

    // Calculate end position
    const endX = startX + Math.cos(angle) * distance
    const endY = startY + Math.sin(angle) * distance

    // Set initial position
    particle.style.cssText = `
      position: fixed;
      left: ${startX}px;
      top: ${startY}px;
      width: 8px;
      height: 8px;
      background-color: #3B82F6;
      border-radius: 50%;
      pointer-events: none;
      z-index: 9999;
      transform-origin: center center;
    `

    document.body.appendChild(particle)

    // Force a reflow
    void particle.offsetWidth

    // Add animation styles
    particle.style.transition = 'all 500ms ease-out'
    particle.style.transform = 'translate(0, 0) scale(1)'
    particle.style.opacity = '1'

    // Animate to end position
    requestAnimationFrame(() => {
      particle.style.transform = `translate(${endX - startX}px, ${endY - startY}px) scale(0)`
      particle.style.opacity = '0'
    })

    // Cleanup
    setTimeout(() => {
      if (particle.parentElement) {
        particle.parentElement.removeChild(particle)
      }
    }, 1000)
  }
}

const triggerAnimation = () => {
  console.log('Animation triggered, showParticles:', props.showParticles)
  isAnimating.value = true

  if (props.showParticles) {
    createParticles()
  }

  setTimeout(() => {
    isAnimating.value = false
  }, 300)
}

defineExpose({ triggerAnimation })
</script>

<template>
  <div
    :id="`vote-animate-${contentId}`"
    :class="{
      'animation-wrapper': true,
      'scale-animation': isAnimating,
      'translate-up': isAnimating && direction === 'up',
      'translate-down': isAnimating && direction === 'down',
    }"
  >
    <slot />
  </div>
</template>

<style>
.animation-wrapper {
  display: inline-flex;
  position: relative;
  transition: transform 0.2s ease;
}

.scale-animation {
  animation: popAnimation 300ms ease-in-out;
}

.translate-up {
  transform: translateY(-2px);
}

.translate-down {
  transform: translateY(2px);
}

@keyframes popAnimation {
  0% {
    transform: scale(1);
  }
  50% {
    transform: scale(1.15);
  }
  100% {
    transform: scale(1);
  }
}
</style>
</file>

<file path="apps/main-app/components/vote/VoteButton.vue">
<script setup lang="ts">
// components/VoteButton.vue
import { computed, ref } from 'vue'

interface Props {
  contentId: string
  contentType?: string
  count?: number
  direction: 'up' | 'down'
}

const props = withDefaults(defineProps<Props>(), {
  contentType: 'news',
  count: 0,
})

const emit = defineEmits<{
  (e: 'vote-change', value: { voteType: number | null; change: number }): void
}>()

const voteStore = useVoteStore()
const notification = useNotification()
const animationRef = ref()

const currentVoteType = computed(() => voteStore.getVoteType(props.contentId))
const isPending = computed(() => voteStore.isVotePending(props.contentId))

const isActive = computed(() => {
  return props.direction === 'up' ? currentVoteType.value === 1 : currentVoteType.value === -1
})

onMounted(async () => {
  await voteStore.fetchUserVotes()
})

const handleVote = async () => {
  if (isPending.value) return

  const voteType = props.direction === 'up' ? 1 : -1

  // Trigger animation
  animationRef.value?.triggerAnimation()

  try {
    const result = await voteStore.submitVote(props.contentId, voteType, notification)
    if (result) {
      emit('vote-change', {
        voteType: voteStore.getVoteType(props.contentId),
        change: result.change,
      })
    }
  } catch (error) {
    console.error('Vote error:', error)
  }
}
</script>

<template>
  <VoteAnimate
    ref="animationRef"
    :direction="direction"
    :show-particles="direction === 'up'"
    :content-id="contentId"
  >
    <button
      class="p-1 rounded-md flex transition-all duration-200 disabled:opacity-50 disabled:cursor-not-allowed"
      :class="[
        'hover:bg-gray-100 dark:hover:bg-gray-800',
        {
          'text-green-500 hover:text-green-600 hover:bg-green-50 dark:hover:bg-green-900/20':
            direction === 'up' && isActive,
          'text-red-500 hover:text-red-600 hover:bg-red-50 dark:hover:bg-red-900/20':
            direction === 'down' && isActive,
          'text-gray-700 dark:text-gray-300 hover:text-gray-600 dark:hover:text-gray-400':
            !isActive,
        },
      ]"
      :disabled="isPending"
      @click="handleVote"
    >
      <Icon
        :name="direction === 'up' ? 'mdi:arrow-up' : 'mdi:arrow-down'"
        class="flex transition-transform duration-200"
        size="20px"
        :class="{ 'scale-125': isActive }"
      />
    </button>
  </VoteAnimate>
</template>

<style>
/* Only keeping minimal required custom CSS for the scale transition */
.scale-125 {
  transform: scale(1.25);
}
</style>
</file>

<file path="apps/main-app/components/AppBackButton.vue">
<script setup lang="ts"></script>

<template>
  <div class="background flex items-center justify-center gap-2 rounded-md p-2">
    <NuxtLink to="/">
      <PrimeButton label="Go back"> Go Home </PrimeButton>
    </NuxtLink>
    <!-- <AppThemeToggle v-slot="{ toggle, isDark }">
      <Icon
        :name="isDark ? 'heroicons:sun' : 'heroicons:moon'"
        class="cursor-pointer"
                      size="24px"

        @click="toggle"
      />
    </AppThemeToggle> -->
  </div>
</template>

<style scoped></style>
</file>

<file path="apps/main-app/components/ConfirmationDialog.vue">
<template>
  <PrimeConfirmDialog>
    <template #message="slotProps">
      <div class="flex items-start gap-3">
        <Icon
          v-if="slotProps.message?.icon"
          :name="slotProps.message.icon"
          class="text-2xl"
        />
        <p>{{ slotProps.message?.message }}</p>
      </div>
    </template>
  </PrimeConfirmDialog>
</template>
</file>

<file path="apps/main-app/components/DatabaseTester.vue">
<!-- components/DatabaseTester.vue -->
<template>
  <div class="p-6 max-w-6xl mx-auto">
    <div class="mb-8 flex justify-between items-center">
      <div>
        <h1 class="text-2xl font-bold mb-2">Database Permissions Testing</h1>
        <p class="text-gray-600"
          >Test database operations across different environments and roles</p
        >
      </div>
      <div class="flex gap-2">
        <PrimeButton @click="saveTests"> Save Tests </PrimeButton>
        <input
          ref="fileInput"
          type="file"
          accept=".json"
          class="hidden"
          @change="loadTestFile"
        />
        <PrimeButton @click="$refs.fileInput.click()"> Load Tests </PrimeButton>
        <PrimeButton
          :disabled="isLoading || !selectedTable"
          :loading="isLoading"
          @click="runTest"
        >
          {{ isLoading ? 'Running Test...' : 'Run Test' }}
        </PrimeButton>
      </div>
    </div>

    <div class="grid grid-cols-2 gap-6">
      <div class="space-y-6 col-span-2">
        <!-- Basic Configuration -->
        <PrimeCard>
          <template #title>Configuration</template>

          <!-- Environment Selection -->
          <template #content>
            <div class="space-y-2 mb-4">
              <label class="font-medium">Environment</label>
              <div class="flex gap-3">
                <PrimeSelectButton
                  v-model="selectedEnv"
                  :options="environments"
                  option-label="name"
                  option-value="id"
                />
              </div>
            </div>

            <!-- Table and Operation Selection -->
            <div class="grid grid-cols-2 gap-4 mb-4">
              <div class="space-y-2">
                <label class="font-medium">Table</label>
                <PrimeSelect
                  v-model="selectedTable"
                  :options="tables"
                  option-label="label"
                  option-value="value"
                  placeholder="Select a table"
                  class="w-full"
                />
              </div>

              <div class="space-y-2">
                <label class="font-medium">Operation</label>
                <PrimeSelect
                  v-model="selectedOperation"
                  :options="operations"
                  option-label="label"
                  option-value="value"
                  placeholder="Select operation"
                  class="w-full"
                />
              </div>
            </div>

            <!-- Role Selection -->
            <div class="space-y-2">
              <label class="font-medium">Test as Role</label>
              <PrimeSelect
                v-model="userRole"
                :options="roles"
                option-label="label"
                option-value="value"
                placeholder="Select role"
                class="w-full"
              />
            </div>
          </template>
        </PrimeCard>

        <!-- Where Conditions -->
        <PrimeCard v-if="['SELECT', 'UPDATE', 'DELETE'].includes(selectedOperation)">
          <template #title>Where Conditions</template>
          <template #content>
            <div
              v-for="(condition, index) in whereConditions"
              :key="index"
              class="flex gap-2 mb-2"
            >
              <PrimeInputText
                v-model="condition.column"
                placeholder="Column"
                class="flex-1"
              />
              <PrimeSelect
                v-model="condition.operator"
                :options="operators"
                option-label="label"
                option-value="value"
                class="w-32"
              />
              <PrimeInputText
                v-model="condition.value"
                placeholder="Value"
                class="flex-1"
              />
              <PrimeButton
                severity="danger"
                label="Delete"
                @click="removeWhereCondition(index)"
              />
            </div>
            <PrimeButton
              severity="secondary"
              @click="addWhereCondition"
              class="mt-2"
            >
              Add Condition
            </PrimeButton>
          </template>
        </PrimeCard>

        <!-- Column Selection for SELECT -->
        <PrimeCard v-if="selectedOperation === 'SELECT'">
          <template #title>Select Columns</template>
          <PrimeInputText
            v-model="columnsInput"
            placeholder="* or column1, column2, column3"
            class="w-full"
          />
        </PrimeCard>

        <!-- Custom Payload for INSERT/UPDATE -->
        <PrimeCard v-if="['INSERT', 'UPDATE'].includes(selectedOperation)">
          <template #title>Custom Payload (JSON)</template>
          <template #content>
            <PrimeTextarea
              v-model="customPayload"
              placeholder='{
                "column1": "value1",
                "column2": "value2"
              }'
              rows="5"
              class="w-full font-mono text-sm"
            />
          </template>
        </PrimeCard>
      </div>

      <div class="space-y-6">
        <!-- Test Results -->
        <PrimeCard v-if="testResults">
          <template #title>
            <div class="flex items-center gap-2">
              <i
                :class="[
                  'pi',
                  testResults.success ? 'pi-check text-green-500' : 'pi-times text-red-500',
                ]"
              ></i>
              {{ testResults.success ? 'Test Passed' : 'Test Failed' }}
            </div>
          </template>
          <pre class="font-mono text-sm overflow-auto max-h-96">{{
            JSON.stringify(testResults, null, 2)
          }}</pre>
        </PrimeCard>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref } from 'vue'

const operations = [
  { label: 'SELECT', value: 'SELECT' },
  { label: 'INSERT', value: 'INSERT' },
  { label: 'UPDATE', value: 'UPDATE' },
  { label: 'DELETE', value: 'DELETE' },
]

const environments = [
  { id: 'development', name: 'Development', url: 'dev-db-url' },
  { id: 'staging', name: 'Staging', url: 'staging-db-url' },
  { id: 'production', name: 'Production', url: 'prod-db-url' },
]

const tables = [
  { label: 'news', value: 'news' },
  { label: 'users', value: 'users' },
  { label: 'categories', value: 'categories' },
  { label: 'content', value: 'content' },
]

const operators = [
  { label: '=', value: '=' },
  { label: '!=', value: '!=' },
  { label: '>', value: '>' },
  { label: '>=', value: '>=' },
  { label: '<', value: '<' },
  { label: '<=', value: '<=' },
  { label: 'LIKE', value: 'LIKE' },
  { label: 'IN', value: 'IN' },
  { label: 'IS NULL', value: 'IS NULL' },
  { label: 'IS NOT NULL', value: 'IS NOT NULL' },
]

const roles = [
  { label: 'super_admin', value: 'super_admin' },
  { label: 'admin', value: 'admin' },
  { label: 'user', value: 'user' },
  { label: 'guest', value: 'guest' },
]

const selectedEnv = ref('development')
const selectedTable = ref(null) // Changed from empty string to null
const selectedOperation = ref('SELECT')
const userRole = ref(null) // Changed from 'user' to null
const whereConditions = ref([{ column: '', operator: '=', value: '' }])
const columnsInput = ref('*')
const customPayload = ref('')
const testResults = ref(null)
const isLoading = ref(false)
const fileInput = ref(null)

const addWhereCondition = () => {
  whereConditions.value.push({ column: '', operator: '=', value: '' })
}

const removeWhereCondition = (index) => {
  whereConditions.value.splice(index, 1)
}

const saveTests = () => {
  const testConfig = {
    environment: selectedEnv.value,
    table: selectedTable.value,
    operation: selectedOperation.value,
    role: userRole.value,
    whereConditions: whereConditions.value,
    columns: columnsInput.value,
    customPayload: customPayload.value,
  }

  // Create and download JSON file
  const blob = new Blob([JSON.stringify(testConfig, null, 2)], { type: 'application/json' })
  const url = URL.createObjectURL(blob)
  const a = document.createElement('a')
  a.href = url
  a.download = `db-test-${new Date().toISOString()}.json`
  document.body.appendChild(a)
  a.click()
  document.body.removeChild(a)
  URL.revokeObjectURL(url)
}

const loadTestFile = (event) => {
  const file = event.target.files[0]
  if (file) {
    const reader = new FileReader()
    reader.onload = (e) => {
      try {
        const config = JSON.parse(e.target.result)
        selectedEnv.value = config.environment
        selectedTable.value = config.table
        selectedOperation.value = config.operation
        userRole.value = config.role
        whereConditions.value = config.whereConditions
        columnsInput.value = config.columns
        customPayload.value = config.customPayload
      } catch (error) {
        console.error('Error loading test configuration:', error)
      }
    }
    reader.readAsText(file)
  }
}

const runTest = async () => {
  isLoading.value = true
  try {
    const testConfig = {
      environment: selectedEnv.value,
      table: selectedTable.value,
      operation: selectedOperation.value,
      role: userRole.value,
      whereConditions: whereConditions.value,
      columns: columnsInput.value.split(',').map((c) => c.trim()),
      customPayload: customPayload.value ? JSON.parse(customPayload.value) : undefined,
    }

    console.log('testing', testConfig)
    // Call your API endpoint
    const { data, error } = await useFetch('/api/database-test', {
      method: 'POST',
      body: testConfig,
    })

    if (error.value) throw error.value

    testResults.value = data.value
  } catch (error) {
    testResults.value = {
      success: false,
      error: error.message,
      details: error,
    }
  } finally {
    isLoading.value = false
  }
}
</script>
</file>

<file path="apps/main-app/components/DeleteConfirmation.vue">
<script setup lang="ts">
const props = defineProps<{
  show: boolean
  itemName?: string
}>()

const emit = defineEmits<{
  (e: 'confirm'): void
  (e: 'cancel'): void
}>()
</script>

<template>
  <PrimeDialog
    v-model:visible="show"
    modal
    header="Confirm Delete"
    :style="{ width: '90vw', maxWidth: '400px' }"
  >
    <p>Are you sure you want to delete {{ itemName || 'this item' }}?</p>
    <template #footer>
      <PrimeButton
        label="Cancel"
        class="p-button-text"
        @click="$emit('cancel')"
      />
      <PrimeButton
        label="Delete"
        class="p-button-danger"
        @click="$emit('confirm')"
      />
    </template>
  </PrimeDialog>
</template>
</file>

<file path="apps/main-app/components/FuzzySearch.vue">
<script setup lang="ts">
import Fuse from 'fuse.js'
import type { FuseResult, IFuseOptions } from 'fuse.js'

interface Props<T> {
  modelValue: string
  placeholder?: string
  data: T[]
  fuseOptions?: IFuseOptions<T>
  debounceMs?: number
}

const props = withDefaults(defineProps<Props<any>>(), {
  placeholder: 'Search...',
  debounceMs: 300,
  fuseOptions: () => ({
    threshold: 0.3,
    shouldSort: true,
  }),
})

const emit = defineEmits<{
  'update:modelValue': [value: string]
  'results': [results: FuseResult<any>[]]
}>()

const searchValue = computed({
  get: () => props.modelValue,
  set: (value) => emit('update:modelValue', value),
})

// Debounced search function
const debouncedSearch = useDebounceFn((query: string) => {
  if (!query.trim()) {
    emit('results', [])
    return
  }

  const fuse = new Fuse(props.data, props.fuseOptions)
  const results = fuse.search(query)
  emit('results', results)
}, props.debounceMs)

// Watch for changes in search value or data
watch(
  [() => searchValue.value, () => props.data],
  ([newQuery]) => {
    debouncedSearch(newQuery)
  },
  { immediate: true },
)
</script>

<template>
  <div class="relative flex-1 w-full">
    <PrimeIconField class="w-full">
      <PrimeInputText
        v-model="searchValue"
        :placeholder="placeholder"
        class="w-full !pr-10"
      />
      <Icon
        name="mdi:magnify"
        class="text-gray-400 absolute right-3 top-1/2 -translate-y-1/2"
      />
    </PrimeIconField>
  </div>
</template>
</file>

<file path="apps/main-app/components/PaymentButton.vue">
<template>
  <div class="card background rounded-lg p-4 shadow-lg">
    <h2 class="mb-4 text-2xl font-bold"> Monthly Test Plan </h2>
    <div class="relative h-32 w-32 overflow-hidden rounded-full bg-white p-2">
      <NuxtImg
        src="/astronera-logo.jpg"
        alt="Acme Corp Logo"
        class="h-full w-full"
      />
    </div>
    <p class="mb-4"> Subscribe to our monthly plan for exclusive benefits! </p>
    <PrimeButton
      label="Pay Now"
      icon="pi pi-credit-card"
      :loading="loading"
      :disabled="!isRazorpayLoaded"
      @click="handlePayment"
    />
  </div>
</template>

<script setup lang="ts">
const config = useRuntimeConfig()
const loading = ref(false)
const isRazorpayLoaded = ref(false)

const razorpayOptions = {
  key: 'rzp_test_lV0OE0NDIg6Hr6',
  subscription_id: 'sub_OmnXoFCi6bQSlj',
  name: 'Professional',
  description: 'Monthly Professional Plan',
  image: '/astronera-logo.jpg',
  handler: function (response: any) {
    console.log('Payment ID:', response.razorpay_payment_id)
    console.log('Subscription ID:', response.razorpay_subscription_id)
    console.log('Signature:', response.razorpay_signature)
    // Here you can add logic to verify the payment on your server
  },
  prefill: {
    name: 'Gaurav Kumar',
    email: 'gaurav.kumar@example.com',
    contact: '+919876543210',
  },
  notes: {
    note_key_1: 'Tea. Earl Grey. Hot',
    note_key_2: 'Make it so.',
  },
  theme: {
    color: '#F37254',
  },
}

let rzp: any

useHead({
  script: [
    {
      src: 'https://checkout.razorpay.com/v1/checkout.js',
      async: true,
      onload: () => {
        isRazorpayLoaded.value = true
        rzp = new (window as any).Razorpay(razorpayOptions)
      },
    },
  ],
})

const handlePayment = () => {
  if (!isRazorpayLoaded.value) {
    console.error('Razorpay is not loaded yet')
    return
  }
  loading.value = true
  rzp.open()
  loading.value = false
}
</script>

<style scoped>
/* Add any additional styles here */
</style>
</file>

<file path="apps/main-app/components/UploadCropper.vue">
<script setup lang="ts">
import type { CropperResult, ImageTransforms } from 'vue-advanced-cropper'
import { Cropper, Preview } from 'vue-advanced-cropper'
import 'vue-advanced-cropper/dist/style.css'
import { useNotification } from '../../../layers/crud/composables/notification'
import { useCurrentUser } from '../../../layers/crud/composables/user.current.store'
import { useFileUpload } from '#imports'

type CropperConfigTypes = 'avatar' | 'default'

const MAX_FILE_SIZE = 5 * 1024 * 1024 // 5 MB
const emit = defineEmits(['profile-pic-update'])
const uploadInput = ref(null as HTMLInputElement | null)
const image = ref<string>('')

const props = defineProps({
  cropperType: {
    type: String as PropType<CropperConfigTypes>,
    required: true,
  },
  bucket: {
    type: String,
    required: false,
    default: 'profile',
  },
  path: {
    type: String,
    required: true,
  },
  requireCropping: {
    type: Boolean,
    default: true,
  },
})

const config = computed(() => cropperConfigs[props.cropperType])

export interface CropperConfig {
  name: string
  minHeight: number
  minWidth: number
  maxHeight?: number
  maxWidth?: number
  stencilComponent?: string
  canvas: {
    minWidth: number
    minHeight: number
    maxWidth: number
    maxHeight: number
  }
  stencilSize?: {
    width: number
    height: number
  }
  stencilProps: {
    handlers?: Record<string, any>
    movable: boolean
    resizable?: boolean
    aspectRatio?: number
  }
}

const cropperConfigs: Record<CropperConfigTypes, CropperConfig> = {
  default: {
    name: 'Default',
    minWidth: 160,
    minHeight: 160,
    canvas: {
      minHeight: 0,
      minWidth: 0,
      maxHeight: 480,
      maxWidth: 480,
    },
    stencilProps: {
      aspectRatio: 1,
      movable: true,
    },
  },
  avatar: {
    name: 'avatar',
    minHeight: 160,
    minWidth: 160,
    canvas: {
      minHeight: 0,
      minWidth: 0,
      maxHeight: 480,
      maxWidth: 480,
    },
    stencilProps: {
      aspectRatio: 1,
      movable: true,
    },
  },
}
const { uploadFile, isUploading, uploadProgress } = useFileUpload()
const userStore = useCurrentUser()
const { profile } = storeToRefs(userStore)
const toast = useNotification()

// Checks & Utils
type Compression = 'lossy' | 'lossless' | 'alpha' | 'animation'
function checkWebpFeature(feature: Compression): Promise<boolean> {
  return new Promise((resolve) => {
    const kTestImages = {
      lossy: 'UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA',
      lossless: 'UklGRhoAAABXRUJQVlA4TA0AAAAvAAAAEAcQERGIiP4HAA==',
      alpha:
        'UklGRkoAAABXRUJQVlA4WAoAAAAQAAAAAAAAAAAAQUxQSAwAAAARBxAR/Q9ERP8DAABWUDggGAAAABQBAJ0BKgEAAQAAAP4AAA3AAP7mtQAAAA==',
      animation:
        'UklGRlIAAABXRUJQVlA4WAoAAAASAAAAAAAAAAAAQU5JTQYAAAD/////AABBTk1GJgAAAAAAAAAAAAAAAAAAAGQAAABWUDhMDQAAAC8AAAAQBxAREYiI/gcA',
    }

    const img = new Image()
    img.onload = () => resolve(true)
    img.onerror = () => resolve(false)
    img.src = 'data:image/webp;base64,' + kTestImages[feature]
  })
}

const webpSupport = ref(false)
onMounted(async () => {
  for (const feature of ['lossy', 'lossless', 'alpha', 'animation'] as Compression[]) {
    const result = await checkWebpFeature(feature)
    if (result) {
      webpSupport.value = true
      break
    }
  }
})

async function uploadImage(blob: Blob) {
  try {
    const supabase = useSupabaseClient()

    const result = await uploadFile(new File([blob], 'image.webp', { type: 'image/webp' }), {
      bucket: props.bucket,
      fileType: 'image',
      userId: profile.value.id,
      serverSideOptimize: true,
      maxWidth: 1200,
      maxHeight: 1200,
      quality: 90,
      format: 'webp',
      maxFileSize: MAX_FILE_SIZE,
      allowedMimeTypes: ['image/jpeg', 'image/jpg', 'image/png', 'image/webp'],
      replace: props.cropperType === 'avatar',
      onProgress: (progress) => {
        console.log(`Upload progress: ${progress}%`)
      },
    })

    if (props.cropperType === 'avatar') {
      emit('profile-pic-update', result.publicUrl)
    }

    return result
  } catch (error: any) {
    setError(`Failed to upload image: ${error.message}`)
    throw error
  }
}

// Cropper
const cropper = ref(null as typeof Cropper | null)
const crop = async (toggleModalOpen: () => void) => {
  if (!cropper.value) {
    setError('No cropper instance in crop function.')
    toggleModalOpen()
    return
  }

  const { canvas } = cropper.value.getResult()
  if (!canvas) {
    setError('Cropper failed to get canvas')
    toggleModalOpen()
    return
  }

  const exportMimeType = webpSupport.value ? 'image/webp' : 'image/jpeg'

  canvas.toBlob(
    async (blob) => {
      if (!blob) {
        setError('Failed to convert canvas to blob.')
        return
      }
      try {
        await uploadImage(blob)
        toggleModalOpen()
      } catch (error) {
        console.error('Error uploading cropped image:', error)
      }
    },
    exportMimeType,
    0.9,
  )
}

async function handleFileChange(e: Event, toggleModalOpen: () => void) {
  const input = e.target as HTMLInputElement
  if (!input.files?.length) return

  const file = input.files[0]

  if (!validateFileSize(file.size)) {
    return
  }

  try {
    if (props.requireCropping) {
      image.value = await readFileAsDataURL(file)
      if (!(await checkImageDimensions(image.value, props.cropperType))) {
        return
      }
      toggleModalOpen()
    } else {
      await uploadImage(file)
    }
  } catch (error: any) {
    setError(`An error occurred while processing the file: ${error.message}`)
  } finally {
    if (input) input.value = ''
  }
}

const preview = reactive<CropperResult>({
  image: {
    width: 0,
    height: 0,
    transforms: {} as ImageTransforms,
    src: null,
  },
  visibleArea: {
    width: 0,
    height: 0,
    left: 0,
    top: 0,
  },
  coordinates: {
    left: 0,
    top: 0,
    width: 0,
    height: 0,
  },
})

function onChange({ coordinates, image, canvas }: CropperResult) {
  // realtime changes in the cropper
  if (!coordinates || !image) return

  preview.coordinates = coordinates
  preview.image = image
}

// original file
type CropperConfigDimensions = {
  [key in CropperConfigTypes]: { minWidth: number; minHeight: number }
}

function checkImageDimensions(imageSrc: string, cropperType: CropperConfigTypes): Promise<boolean> {
  const dimensions: CropperConfigDimensions = {
    default: { minWidth: 800, minHeight: 600 },
    avatar: { minWidth: 160, minHeight: 160 },
  }

  return new Promise((resolve) => {
    const img = new Image()
    img.onload = () => {
      const { minWidth, minHeight } = dimensions[cropperType]
      console.log('cropper mins', minHeight, minWidth, img.width, img.height)
      if (img.width >= minWidth && img.height >= minHeight) {
        resolve(true)
      } else {
        setError(
          `Image dimensions must be at least ${minWidth}x${minHeight}px for ${cropperType}. (dimensions ${img.width}x${img.height})`,
        )
        resolve(false)
      }
    }
    img.onerror = () => {
      setError('Failed to load image for dimension check.')
      resolve(false)
    }
    img.src = imageSrc
  })
}

function readFileAsDataURL(file: File): Promise<string> {
  return new Promise((resolve, reject) => {
    const reader = new FileReader()
    reader.onload = () => resolve(reader.result as string)
    reader.onerror = () => reject(reader.error)
    reader.onerror = () => {
      setError(`Failed to read the file: ${reader.error?.message}`)
      reject(new Error(`Failed to read the file: ${reader.error?.message}`))
    }

    reader.readAsDataURL(file)
  })
}

function validateFileSize(fileSize: number): boolean {
  if (fileSize > MAX_FILE_SIZE) {
    setError('File is too large. Please select a file smaller than 5MB.')
    return false
  }
  return true
}

const setError = (error: string) => {
  toast.error({
    summary: 'Error',
    message: error,
  })
}
</script>

<template>
  <div class="space-y-24">
    <IBModal>
      <template #button="{ toggleModalOpen }">
        <label
          v-ripple
          :for="`myFile-${cropperType}`"
          class="border-color bg-primary rounded-lg border px-2 py-1 text-sm"
        >
          Upload {{ cropperType }}
        </label>
        <input
          :id="`myFile-${cropperType}`"
          ref="uploadInput"
          type="file"
          accept="image/jpg, image/jpeg, image/png, image/webp"
          name="filename"
          class="hidden"
          @change="handleFileChange($event, toggleModalOpen)"
        />
      </template>
      <template #modal:header>
        <h2 class="text-xl font-semibold"> Crop your image </h2>
      </template>
      <template #modal:default>
        <Cropper
          v-if="requireCropping"
          ref="cropper"
          :src="image"
          :min-width="config.minWidth"
          :min-height="config.minHeight"
          :canvas="config.canvas"
          :stencil-props="config.stencilProps"
          :debounce="false"
          @change="onChange"
          @error="setError('error loading image')"
        />
        <div
          v-else-if="isUploading"
          class="text-center"
        >
          <p>Uploading: {{ uploadProgress }}%</p>
          <PrimeProgressBar :value="uploadProgress" />
        </div>
      </template>
      <template #modal:footer="{ toggleModalOpen }">
        <div
          v-if="requireCropping"
          class="flex items-center justify-center gap-4"
        >
          <p>Image preview</p>
          <Preview
            v-if="preview.image && config.minWidth"
            class="rounded-full"
            :width="Math.floor(config.minWidth / 3)"
            :height="Math.floor(config.minHeight / 3)"
            :image="preview.image"
            :coordinates="preview.coordinates"
          />
          <PrimeButton
            :disabled="isUploading"
            @click="crop(toggleModalOpen)"
          >
            {{ isUploading ? 'Uploading...' : 'Crop & Upload' }}
          </PrimeButton>
        </div>
      </template>
    </IBModal>
  </div>
</template>

<style scoped></style>
</file>

<file path="apps/main-app/composables/companies/companies.store.ts">
import { useLogger } from '@ib/logger'
import type { FetchInput } from '#imports'

type CompanyType = {
  id: number
  name: string
  address: string
  city: string
  state: string
  zip: string
  phone: string
  email: string
  website: string
  created_at: string
  updated_at: string
}

// What will I need for database?
// Addresses table
// id SERIAL PRIMARY KEY,
// street1 VARCHAR(255) NOT NULL,
// street2 VARCHAR(255),
// city VARCHAR(100) NOT NULL,
// state VARCHAR(100),
// postal_code VARCHAR(20),
// country VARCHAR(100) NOT NULL,
// location GEOGRAPHY(POINT, 4326)

// Countries table:
// id SERIAL PRIMARY KEY,
// name VARCHAR(100) UNIQUE NOT NULL

// Cities Table:
// id SERIAL PRIMARY KEY,
// name VARCHAR(100) NOT NULL,
// country_id INTEGER NOT NULL,
// CONSTRAINT fk_country FOREIGN KEY (country_id) REFERENCES countries(id)

// Companies table
// {
// id: number
// name: string

//
//
//
// }

export const useCompaniesStore = defineStore('companiesStore', () => {
  const companies = ref([] as CompanyType[])
  const logger = useLogger('companiesStore')
  const baseFetch = useBaseFetch()

  async function loadCompanies(input: FetchInput) {
    logger.info('loadCompanies start')
    try {
      const data = await baseFetch.fetchPaginatedData(input)
      console.log('loadCompanies return', data)
      if (!data) {
        return
      }
      logger.info(`returned ${data.length} companies`)
      companies.value.push(...data)
    } catch (error) {
      logger.error('Failed to load companies:', error)
    }
  }

  async function insertCompany(newCompany) {
    try {
      const { data, error } = await $fetch('/api/companies/insert/single', {
        method: 'POST',
        headers: useRequestHeaders(['cookie']),
        body: JSON.stringify({
          newData: newCompany,
          dto: 'insert:company:full',
        }),
      })

      if (error) {
        throw createError(`error inserting company: ${error.value}`)
      }

      logger.info(`Company ${data.name} inserted successfully`)
    } catch (error) {
      logger.error(`Error inserting company ${newCompany.name}:`, error)
    }
  }

  // const companyById = () => {
  //   return (id: number) => companies.value.find((company: CompanyType) => company.id === id)
  // }

  return {
    companies,
    loadCompanies,
    insertCompany,
  }
})
</file>

<file path="apps/main-app/composables/events/events.store.ts">
import { useLogger } from '@ib/logger'
import type { FetchInput } from '#imports'
import type { EventType } from '@/types/events'

export const useEventsStore = defineStore('eventsStore', () => {
  const events = ref([] as EventType[])
  const logger = useLogger('eventsStore')
  const baseFetch = useBaseFetch()

  async function loadEvents(input: FetchInput) {
    logger.info('loadEvents start')
    try {
      const data = await baseFetch.fetchPaginatedData(input)

      if (!data) {
        return
      }
      logger.info(`returned ${data.length} events`)
      events.value.push(...data)
    } catch (error) {
      console.error('Failed to load events:', error)
    }
  }

  // const eventById = () => {
  //   return (id: number) => events.value.find((event: EventType) => event.id === id)
  // }

  return {
    events,
    loadEvents,
  }
})
</file>

<file path="apps/main-app/composables/news/news.store.ts">
import { useLogger } from '@ib/logger'
import type { FetchInput } from '#imports'

export const useNewsStore = defineStore('newsStore', () => {
  const logger = useLogger('newsStore')
  const baseFetch = useBaseFetch()

  const news = ref([])

  async function loadNews(input: FetchInput) {
    logger.info('loadNews start')
    try {
      const data = await baseFetch.fetchPaginatedData(input)

      logger.info('returned data', data)
      if (!data) {
        return
      }

      news.value.push(...data)
    } catch (error) {
      logger.error('Failed to load news:', error)
    }
  }

  // const countDuplicateIds = (data) => {
  //   const ids = data.map((item) => item.id)
  //   const uniqueIds = new Set(ids)
  //   return ids.length - uniqueIds.size
  // }

  return {
    news,
    loadNews,
  }
})
</file>

<file path="apps/main-app/composables/users/user-settings.store.ts">
type SettingsKey = 'usersStore' | 'storeNews'

export const useUserSettingsStore = defineStore('settingsStore', () => {
  const settings = ref({} as Settings)

  function toggleSettings(key: SettingsKey) {
    settings.value[key] = !settings.value[key]
  }

  function isSettingsOn(key: SettingsKey) {
    return !settings.value[key]
  }

  return {
    settings,
    toggleSettings,
    isSettingsOn,
  }
})

if (import.meta.hot) {
  import.meta.hot.accept(acceptHMRUpdate(useUserSettingsStore, import.meta.hot))
}
</file>

<file path="apps/main-app/composables/users/user.admin.composable.ts">
import { useLogger } from '@ib/logger'
import { emailUnvalidatedUserSchema } from '../../../auth-service/types/auth'
import type { UserRowType } from '~/types/users'

interface NewUser {
  email: string
  password: string
}

const DOMAIN_KEY = 'useAdmin'

export function useAdmin() {
  const errors = useBaseError()
  const log = useLogger(DOMAIN_KEY)
  const utils = useUtils()
  const client = useSupabaseClient()
  const toast = useNotification()
  const createdUsers = ref([] as NewUser[])

  const register = async ({ email, password }: { email: string; password: string }) => {
    const { data, error } = await client.auth.signUp({
      email,
      password,
    })
    if (error) {
      throw createError({
        statusCode: 401,
        message: error.message,
      })
    }

    const validatedUser = emailUnvalidatedUserSchema.safeParse(data.user)

    if (!validatedUser.success) {
      throw createError(validatedUser.error)
    }

    return validatedUser.data
  }

  async function addProfilePicture(userId: string, file: File) {
    try {
      const { data, error } = await client.storage
        .from('profile-public')
        .upload(`${userId}/avatar/${file.name}`, file)
      if (error) {
        throw createError(
          `Error uploading profile picture for user with ID ${userId}: ${error.message}`,
        )
      }
      console.log(`Profile picture uploaded successfully for user with ID ${userId}`)
    } catch (error) {
      console.error(`Error uploading profile picture for user with ID ${userId}:`, error)
    }
  }

  async function registerManyUsers() {
    const users: UserRowType[] = []
    for (const user of users) {
      // Extract the given name and surname
      const givenName = user.given_name.charAt(0).toUpperCase() + user.given_name.slice(1)
      const surname = user.surname.charAt(0).toUpperCase() + user.surname.slice(1)

      // Construct the password
      const password = `${givenName}${surname}12345$`

      // Register the user
      try {
        // const newUser = await register({ email: user.email, password })
        // we handle user profile creation with a database trigger
        // now seed the database with the user data
        // createdUsers.value.push({ email: user.email, password })

        // Locate the profile image file based on the user's given name and surname
        const imageName = `${givenName.toLowerCase()}-${surname.toLowerCase()}.jpg`
        const imagePath = `/data/seed/avatars/${imageName}` // Adjust the path as necessary
        const imageFile = new File([await fetch(imagePath).then((r) => r.blob())], imageName, {
          type: 'image/jpeg',
        })

        console.log('file exists', imageFile.size)
        // Upload the profile image
        await addProfilePicture(newUser.id, imageFile)

        // update user profile with data
        await updateSingle(user, newUser.id)
      } catch (error) {
        console.error(`Failed to register user with email ${user.email}:`, error)
      }
    }
  }

  async function updateUser(newData: any, oldData: any) {
    log.info(`Updating user with email ${newData.email}`)
    // we should first parse the data to check if anything has changed and then filter out any undefined values
    try {
      const { noDataUpdated, data: updatedData } = utils.wasRowDataUpdated(newData, oldData)

      if (noDataUpdated) {
        log.info('No changes detected, no update necessary')
        return
      }

      const response = await $fetch('/api/users/update', {
        method: 'POST',
        body: {
          data: updatedData,
          id: newData.id,
        },
      })

      const data = errors.server({
        response,
        devOnly: false,
        showSuccess: true,
        devMessage: `Error updating user with email ${newData.email}`,
        userMessage: `There was an error updating user with email ${newData.email}`,
      })

      log.info(`User with email ${data.email} updated successfully`)
      toast.success({
        summary: 'Success',
        message: `User with email ${data.email} updated successfully`,
      })

      // maybe update state here
    } catch (error) {
      errors.client({
        error,
        devOnly: false,
        devMessage: `Error updating user with email ${newData.email}`,
        userMessage: `There was an error updating user with email ${newData.email}`,
      })
    }
  }

  return {
    registerManyUsers,
    updateUser,
    createdUsers,
  }
}
</file>

<file path="apps/main-app/composables/category-tags.store.ts">
import { z } from 'zod'
import { useLogger } from '@ib/logger'

const CategorySchema = z.object({
  id: z.number(),
  name: z.string(),
  body: z.string().nullish(),
  created_at: z.string().optional(),
  updated_at: z.string().optional(),
})

const TagSchema = z.object({
  id: z.number(),
  name: z.string(),
  body: z.string().nullish(),
  created_at: z.string().optional(),
  updated_at: z.string().optional(),
})

type Category = z.infer<typeof CategorySchema>
type Tag = z.infer<typeof TagSchema>

export const useCategoryTagStore = defineStore('categoryTagStore', () => {
  const logger = useLogger('categoryTagStore')
  const categories = ref<Category[]>([])
  const tags = ref<Tag[]>([])
  const localStorage = useBaseLocalStorage()
  const errors = useBaseError()

  const client = useSupabaseClient()

  async function getCategories() {
    try {
      categories.value = await localStorage.getCachedOrFetch('astronera-categories', async () => {
        const { data, error } = await client.from('categories').select('id, name')
        if (error) throw error
        return z.array(CategorySchema).parse(data)
      })
    } catch (error) {
      logger.error('Error fetching categories:', error)
      errors.server({
        error,
        devOnly: true,
        devMessage: 'Error Fetching Categories from DB',
        userMessage: 'There was an error getting Categories from the database',
      })
    }
  }

  async function getTags() {
    try {
      tags.value = await localStorage.getCachedOrFetch('astronera-tags', async () => {
        const { data, error } = await client.from('tags').select('id, name')
        if (error) throw error
        return z.array(TagSchema).parse(data)
      })
    } catch (error) {
      logger.error('Error fetching tags:', error)
      errors.server({
        error,
        devOnly: true,
        devMessage: 'Error Fetching Tags from DB',
        userMessage: 'There was an error getting Tags from the database',
      })
    }
  }

  const getCategoryName = computed(
    () => (categoryId: number) =>
      categories.value.find((category) => category.id === categoryId)?.name,
  )

  const getTagName = computed(
    () => (tagId: number) => tags.value.find((tag) => tag.id === tagId)?.name,
  )

  return {
    categories,
    tags,
    getCategories,
    getTags,
    getCategoryName,
    getTagName,
    clearAllCaches: localStorage.clearAllCaches,
  }
})

if (import.meta.hot) {
  import.meta.hot.accept(acceptHMRUpdate(useCategoryTagStore, import.meta.hot))
}
</file>

<file path="apps/main-app/composables/chat.store.ts">
import { z } from 'zod'
import { useLogger } from '@ib/logger'

const ChatCompletionSchema = z.object({
  id: z.string(),
  object: z.string(),
  created: z.number(),
  model: z.string(),
  system_fingerprint: z.string(),
  choices: z.array(
    z.object({
      index: z.number(),
      message: z.object({
        role: z.string(),
        content: z.string(),
      }),
      finish_reason: z.string(),
      logprobs: z.null(),
    }),
  ),
  usage: z.object({
    prompt_tokens: z.number(),
    completion_tokens: z.number(),
    total_tokens: z.number(),
    prompt_time: z.number(),
    completion_time: z.number(),
    total_time: z.number(),
  }),
  x_groq: z.object({
    id: z.string(),
  }),
})

type Chat = z.infer<typeof ChatCompletionSchema>

export const useChatStore = defineStore('chatStore', () => {
  const { fetch } = useBaseFetch()
  const loading = useLoadingStore()
  const client = useSupabaseClient()
  const errors = useBaseError()

  const domainKey = 'chat'
  const logger = useLogger(domainKey)

  const chat = ref({} as Chat)
  const messages = ref<Array<{ role: 'user' | 'assistant' | 'system'; content: string }>>([])

  const question = ref('' as string)

  // function handleNavigation() {
  //   const route = useRoute()
  //   if (route.path === '/ask') {
  //     return
  //   }
  //   navigateTo('/ask')
  // }

  async function insertSearchData(userId: string) {
    const response = await client
      .from('searches')
      .insert({
        input: question.value,
        created_at: new Date().toISOString(),
        user_id: userId,
      })
      .select()

    return errors.server({
      response,
      devOnly: true,
      devMessage: 'error inserting search data',
      userMessage: 'something went wrong when inserting search data',
    })
  }

  async function insertResponseData(searchId: number, questionResponseData: Chat) {
    const response = await client.from('responses').insert({
      search_id: searchId,
      output: questionResponseData.choices[0]?.message?.content,
      created_at: new Date().toISOString(),
    })
    return errors.server({
      response,
      devOnly: true,
      devMessage: 'error inserting response data',
      userMessage: 'something went wrong when inserting response data',
    })
  }

  function addMessage(role: 'user' | 'assistant' | 'system', content: string) {
    messages.value.push({ role, content })
  }

  async function submitQuestion(args: { question: string; systemPrompt: string }) {
    console.log('searchMessage', args)

    if (loading.isLoading(domainKey)) {
      return null
    }

    loading.setLoading(domainKey, true)

    try {
      addMessage('user', args.question)

      const messageHistory = messages.value.slice(-5) // Get last 5 messages

      const formattedMessages = [
        ...(args.systemPrompt ? [{ role: 'system', content: args.systemPrompt }] : []),
        ...messageHistory,
      ]

      const questionResponse = await fetch('/api/ai/ask', {
        method: 'POST',
        body: JSON.stringify({
          messages: formattedMessages,
        }),
        headers: {
          'Content-Type': 'application/json',
        },
      })

      const questionResponseData: Chat = errors.server({
        response: questionResponse,
        devOnly: true,
        devMessage: 'error fetching question response',
        userMessage: 'something went wrong when fetching question response',
      })

      addMessage('assistant', questionResponseData.choices[0]?.message?.content)

      // const search = await insertSearchData(userId)
      // insertResponseData(search[0].id, questionResponseData)
    } catch (error) {
      console.error('Error submitting question and handling response:', error)
    } finally {
      await loading.setLoadingInterval(domainKey, false, 1000)
    }
  }

  return {
    isLoading: computed(() => loading.isLoading(domainKey)),
    chat,
    question,
    messages,
    addMessage,
    submitQuestion,
  }
})

if (import.meta.hot) {
  import.meta.hot.accept(acceptHMRUpdate(useChatStore, import.meta.hot))
}
</file>

<file path="apps/main-app/composables/chunks.store.ts">
import { useLogger } from '@ib/logger'

interface BaseNotification {
  summary: string
  message: string
}

export const useChunksStore = defineStore('chunksStore', () => {
  const log = useLogger('chunksStore')
  const toast = useNotification()
  const client = useSupabaseClient()

  const chunks = ref<any[]>([])

  async function flagChunk(chunkId: number, is_flagged: boolean) {
    console.log('flagChunk:', chunkId, is_flagged)
    try {
      const { data, error } = await client
        .from('research_embeddings')
        .update({ is_flagged: !is_flagged })
        .eq('id', chunkId)
        .select()

      console.log('flagChunk: res', data, error)
      if (error) {
        throw new Error(error.message)
      }

      if (!data || data.length === 0) {
        return
      }

      const updatedChunk = data[0]

      if (updatedChunk.is_flagged) {
        flaggedChunks.value.push(updatedChunk)
        chunks.value = chunks.value.filter((chunk: any) => chunk.id !== updatedChunk.id)
      } else {
        flaggedChunks.value = flaggedChunks.value.filter(
          (chunk: any) => chunk.id !== updatedChunk.id,
        )
        chunks.value.push(updatedChunk)
      }
    } catch (error: any) {
      throw new Error(error.message)
    }
  }

  const flaggedChunks = ref<any[]>([])
  async function fetchChunks(isFlagged: boolean = false, maxChunks: number = 100) {
    try {
      let query = client
        .from('research_embeddings')
        .select('id, research_id, chunk, url, is_flagged')
        .eq('is_flagged', isFlagged)
        .range(0, maxChunks)
      console.log('working 1')

      if (isFlagged) {
        query = query.order('updated_at', { ascending: false })
      } else {
        console.log('working 2')
        query = query.order('created_at', { ascending: false })
      }

      const { data, error } = await query
      console.log('working 3', data, error)

      if (error) {
        throw new Error(error.message)
      }

      if (isFlagged) {
        flaggedChunks.value.push(...data)
      } else {
        chunks.value.push(...data)
      }
    } catch (error: any) {
      log.error('fetchChunks:', error)
      throw new Error(error.message)
    }
  }

  const similarChunks = ref<any[]>([])
  interface SimilarDocs {
    search: string
    searchType: 'fts' | 'vector'
    matchThreshold?: number
    matchCount?: number
  }

  async function fetchSimilarDocuments({
    search,
    searchType,
    matchThreshold = 0.41,
    matchCount = 25,
  }: SimilarDocs) {
    try {
      const userId = useCookie('userId').value!
      let response

      if (searchType === 'vector') {
        response = await client.functions.invoke('openai', {
          method: 'POST',
          body: {
            query: search,
            match_threshold: matchThreshold,
            match_count: matchCount,
            user_id: userId,
          },
        })

        if (!response.data) {
          return
        }
      } else {
        const formattedSearch = search.replaceAll(' ', ' & ')
        response = await client.from('research').select().textSearch('fts', formattedSearch)
      }

      similarChunks.value.push(...response.data)
    } catch (error: any) {
      throw new Error(error.message)
    }
  }

  async function deleteChunk(chunkId: number) {
    log.info('deleteChunk:', chunkId)
    try {
      const { error } = await client.from('research_embeddings').delete().eq('id', chunkId)

      console.log('deleteChunk: res', error)
      if (error) {
        throw new Error(error.message)
      }

      flaggedChunks.value = flaggedChunks.value.filter((chunk: any) => chunk.id !== chunkId)
      toast.info({ summary: 'Chunk Deleted', message: 'The chunk has been deleted' })
    } catch (error: any) {
      toast.error({ summary: 'Error Deleting Chunk', message: error.message })
      throw new Error(error.message)
    }
  }

  function cleanText(text: string) {
    // Regular expression to match the pattern [chars(num/char/|)]
    const withoutPlaceholders = text.replace(/\[research_.*?\([^\)]+\)\]/g, '')

    return withoutPlaceholders
      .replace(/undefined/g, '')
      .replace(/ ,/g, ',')
      .replace(/ ,/g, '')
      .replace(/ :/g, ':')
      .replace(/ \./g, '.')
      .replace(/ ;/g, ';')
      .replace(/ \(/g, '(')
      .replace(/ \)/g, ')')
      .replace(/\s+/g, ' ')
      .trim()
  }

  return {
    flagChunk,
    fetchChunks,
    fetchSimilarDocuments,
    deleteChunk,
    cleanText,
    chunks,
    similarChunks,
    flaggedChunks,
  }
})

if (import.meta.hot) {
  import.meta.hot.accept(acceptHMRUpdate(useChunksStore, import.meta.hot))
}
</file>

<file path="apps/main-app/composables/feedback.store.ts">
import { useLogger } from '@ib/logger'

export const useFeedbackStore = defineStore('feedbackStore', () => {
  const { fetch } = useBaseFetch()
  const storeKey = 'feedbacks'
  const logger = useLogger(storeKey)
  const loading = useLoadingStore()
  const toast = useNotification()

  async function submitFeedback(newFeedback: any) {
    console.log('newFeedback', newFeedback)

    if (loading.isLoading(storeKey)) {
      return null
    }

    loading.setLoading(storeKey, true)

    try {
      const response = await fetch('/api/feedback/insert/single', {
        method: 'POST',
        body: newFeedback,
      })

      toast.info({ summary: 'Feedback Sent', message: response.message })
    } catch (error: any) {
      toast.error({ summary: 'Feedback Not Sent', message: error.message })
      logger.error('Error submitting question and handling response:', error)
    } finally {
      await loading.setLoadingInterval(storeKey, false, 1000)
    }
  }

  return {
    submitFeedback,
  }
})

if (import.meta.hot) {
  import.meta.hot.accept(acceptHMRUpdate(useFeedbackStore, import.meta.hot))
}
</file>

<file path="apps/main-app/composables/onboarding.composable.ts">
import { ref, reactive } from 'vue'
import type { ZodSchema, z } from 'zod'

const accountDetailsSchema = z.object({
  dateOfBirth: z.date().max(new Date(), 'Date of birth cannot be in the future'),
})

const professionalInfoSchema = z.object({
  occupation: z.string().min(1, 'Please select an occupation'),
  organization: z.string().min(2, 'Organization name must be at least 2 characters'),
  experience: z
    .number()
    .min(0, 'Experience cannot be negative')
    .max(100, 'Experience cannot exceed 100 years'),
})

export interface SignupForm {
  dateOfBirth: Date | null
  occupation: string
  organization: string
  experience: number | null
  interests: string[]
}

export function useOnboarding() {
  const form = reactive<SignupForm>({
    dateOfBirth: null,
    occupation: '',
    organization: '',
    experience: null,
    interests: [],
  })

  const errors = reactive<Partial<Record<keyof SignupForm, string>>>({})

  const validateAndUpdate = (schema: ZodSchema) => {
    const result = schema.safeParse(form)
    if (result.success) {
      Object.keys(errors).forEach((key) => delete errors[key as keyof SignupForm])
      return true
    } else {
      result.error.issues.forEach((issue) => {
        errors[issue.path[0] as keyof SignupForm] = issue.message
      })
      return false
    }
  }

  return {
    form,
    errors,
    validateAndUpdate,
    professionalInfoSchema,
    accountDetailsSchema,
  }
}
</file>

<file path="apps/main-app/composables/useBookmarkManager.ts">
// useBookmarkManager.ts
import type { Folder } from '../types/bookmarks'

export const useBookmarkManager = () => {
  const selectedBookmarks = ref<string[]>([])
  const showMoveModal = ref(false)
  const targetFolderId = ref<string | null>(null)
  const { moveBookmarks, fetchBookmarks } = useBookmarks()

  const toggleBookmarkSelection = (bookmarkId: string) => {
    const index = selectedBookmarks.value.indexOf(bookmarkId)
    if (index === -1) {
      selectedBookmarks.value.push(bookmarkId)
    } else {
      selectedBookmarks.value.splice(index, 1)
    }
  }

  const handleMoveBookmarks = async () => {
    if (!targetFolderId.value) return

    await moveBookmarks(selectedBookmarks.value, targetFolderId.value)
    selectedBookmarks.value = []
    showMoveModal.value = false
    targetFolderId.value = null
  }

  const handleDeleteBookmark = async (bookmarkId: string | string[]) => {
    const ids = Array.isArray(bookmarkId) ? bookmarkId : [bookmarkId]

    await Promise.all(
      ids.map((id) =>
        $fetch(`/api/bookmarks/${id}`, {
          method: 'DELETE',
        }),
      ),
    )

    await fetchBookmarks({})
    selectedBookmarks.value = selectedBookmarks.value.filter((id) => !ids.includes(id))
  }

  const handleNewFolder = async (folderData: Partial<Folder>) => {
    const { createFolder } = useFolderSystem()
    return await createFolder(folderData)
  }

  const handleMoveSubmit = async (targetFolder: Folder) => {
    targetFolderId.value = targetFolder.id
    await handleMoveBookmarks()
  }

  return {
    selectedBookmarks,
    showMoveModal,
    targetFolderId,
    toggleBookmarkSelection,
    handleMoveBookmarks,
    handleDeleteBookmark,
    handleNewFolder,
    handleMoveSubmit,
  }
}
</file>

<file path="apps/main-app/composables/useBookmarks.ts">
// useBookmarks.ts
import Fuse from 'fuse.js'

interface BookmarkContent {
  id: string
  type: string
  title: string
  description?: string
  thumbnail?: string
  url?: string
}

interface BookmarkParams {
  content_type?: string
  folder_id?: string
  include_subfolders?: boolean
}

interface Bookmark {
  id: string
  user_id: string
  folder_id: string | null
  content_type: string
  content_id: string
  metadata: {
    title: string
    description?: string
    thumbnail?: string
    url?: string
  }
  created_at: string
  folder?: {
    id: string
    name: string
    color: string
    is_favorite: boolean
  }
}

export const useBookmarks = () => {
  const bookmarks = ref<Bookmark[]>([])
  const bookmarkCache = new Map<string, boolean>()
  const error = ref<string | null>(null)

  const loading = ref(false)
  const { getDefaultFolder } = useFolderSystem()

  const updateCache = (
    item: { content_type: string; content_id: string } | null,
    isBookmarked: boolean,
    data?: Bookmark,
  ) => {
    if (!item) return
    if (data) {
      bookmarks.value.push(data)
    } else if (!data && !isBookmarked) {
      const index = bookmarks.value.findIndex(
        (bookmark) =>
          bookmark.content_id === item.content_id && bookmark.content_type === item.content_type,
      )
      if (index > -1) {
        bookmarks.value.splice(index, 1)
      }
    }

    const cacheKey = `${item.content_type}:${item.content_id}`
    bookmarkCache.set(cacheKey, isBookmarked)
  }

  const updateBatchCache = (
    items: Array<{ content_type: string; content_id: string }>,
    isBookmarked: boolean,
  ) => {
    items.forEach((item) => updateCache(item, isBookmarked))
  }

  const init = async () => {
    const session = await useSupabaseSession()
    if (session.value) {
      await fetchBookmarks({})
    }
  }

  const isNewsBookmarked = computed(() => {
    return (newsId: string) => {
      // Check if this news ID exists in our bookmarks
      return bookmarks.value.some(
        (bookmark) => bookmark.content_id === newsId && bookmark.content_type === 'news',
      )
    }
  })

  const fetchBookmarks = async (params: BookmarkParams) => {
    loading.value = true
    error.value = null

    try {
      // Get last month of bookmarks by default if no specific params

      const defaultParams = {
        content_type: 'news',
        created_at: 'gte.' + new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString(),
        ...params,
      }

      const response = await $fetch('/api/bookmarks', {
        params: {
          params: defaultParams,
          include_subfolders: true,
        },
      })

      bookmarks.value = response.data || []

      // Update cache with current bookmarks
      updateBatchCache(
        bookmarks.value.map((bookmark) => ({
          content_type: bookmark.content_type,
          content_id: bookmark.content_id,
        })),
        true,
      )
    } catch (e) {
      error.value = 'Failed to fetch bookmarks'
      bookmarks.value = []
    } finally {
      loading.value = false
    }
  }

  // Update toggleBookmark to use the new cache function
  const toggleBookmark = async (content: BookmarkContent) => {
    const { getDefaultFolder } = useFolderSystem()

    const response = await $fetch('/api/bookmarks/toggle', {
      method: 'POST',
      body: {
        content_id: content.id,
        content_type: content.type,
        folder_id: getDefaultFolder.value?.id,
        metadata: {
          title: content.title,
          description: content.description,
          thumbnail: content.thumbnail,
          url: content.url,
        },
      },
    })

    const isBookmarked = response.bookmarked ?? false
    updateCache(
      {
        content_type: content.type,
        content_id: content.id,
      },
      isBookmarked,
      response.data,
    )

    return response.data
  }

  // Update isBookmarked to use the new cache function
  const isBookmarked = async (contentId: string, contentType: string = 'news') => {
    const cacheKey = `${contentType}:${contentId}`

    if (bookmarkCache.has(cacheKey)) {
      return bookmarkCache.get(cacheKey)
    }

    const response = await $fetch('/api/bookmarks/check', {
      params: { content_id: contentId, content_type: contentType },
    })

    updateCache(
      {
        content_type: contentType,
        content_id: contentId,
      },
      !!response.data,
    )

    return !!response.data
  }

  const createBookmark = async (content: BookmarkContent, folderId?: string) => {
    const folder_id = folderId || getDefaultFolder.value?.id

    const response = await $fetch('/api/bookmarks/create', {
      method: 'POST',
      body: {
        content_id: content.id,
        content_type: content.type,
        folder_id,
        metaresponse: {
          title: content.title,
          description: content.description,
          thumbnail: content.thumbnail,
        },
      },
    })
    return response.data
  }

  const moveBookmarks = async (bookmarkIds: string[], targetFolderId: string) => {
    const response = await $fetch('/api/bookmarks/move', {
      method: 'PATCH',
      body: {
        bookmarkIds,
        targetFolderId,
      },
    })

    await fetchBookmarks({})

    return response.data
  }

  const searchBookmarks = (query: string) => {
    const fuse = new Fuse(bookmarks.value, {
      keys: ['metadata.title', 'metadata.description'],
      threshold: 0.3,
    })

    return fuse.search(query)
  }

  const clearCache = () => bookmarkCache.clear()

  onMounted(() => {
    init()
  })

  return {
    bookmarks,
    loading,
    init,
    fetchBookmarks,

    searchBookmarks,
    toggleBookmark,
    createBookmark,
    moveBookmarks,
    isNewsBookmarked,
    isBookmarked,
  }
}
</file>

<file path="apps/main-app/composables/useBookmarkView.ts">
// useBookmarkView.ts
import type { Folder } from '../types/bookmarks'

export const useBookmarkView = () => {
  const viewMode = ref<'grid' | 'list'>('grid')
  const searchQuery = ref('')
  const includeSubfolders = ref(true)
  const showFolderPanel = ref(false)
  const showNewFolderModal = ref(false)
  const currentFolder = ref<Folder | null>(null)

  const handleFolderSelect = async (folder: Folder) => {
    currentFolder.value = folder
    const { fetchBookmarks } = useBookmarks()
    await fetchBookmarks({
      folder_id: folder.id,
      include_subfolders: includeSubfolders.value,
    })

    // On mobile, close the folder panel after selection
    if (import.meta.client && window.innerWidth < 768) {
      showFolderPanel.value = false
    }
  }

  const toggleFolderPanel = () => {
    showFolderPanel.value = !showFolderPanel.value
  }

  const debouncedSearch = useDebounceFn((query: string) => {
    // Implement search logic here
    console.log('Searching:', query)
  }, 300)

  watch(searchQuery, (newQuery) => {
    debouncedSearch(newQuery)
  })

  return {
    viewMode,
    searchQuery,
    includeSubfolders,
    showFolderPanel,
    showNewFolderModal,
    currentFolder,
    handleFolderSelect,
    toggleFolderPanel,
  }
}
</file>

<file path="apps/main-app/composables/useFolderSystem.ts">
import { useErrorHandler } from '@ib/logger'
import type { Folder } from '~/types/folder'

export const useFolderSystem = () => {
  const folders = ref<Folder[]>([])
  const loading = ref(false)
  const errorHandler = useErrorHandler('FolderSystem')

  const fetchFolders = async () => {
    loading.value = true
    try {
      const response = await $fetch('/api/folders')
      const data = errorHandler.handleFetchError({
        response,
        devMessage: 'Failed to fetch folders',
        userMessage: 'Unable to load folders',
      })
      folders.value = data || []
    } catch (error) {
      errorHandler.handleError(error, {
        context: 'fetchFolders',
        userMessage: 'Failed to load folders',
      })
      folders.value = []
    } finally {
      loading.value = false
    }
  }

  const createFolder = async (folder: Partial<Folder>) => {
    loading.value = true
    try {
      const response = await $fetch('/api/folders', {
        method: 'POST',
        body: folder,
      })
      const data = errorHandler.handleFetchError({
        response,
        devMessage: 'Failed to create folder',
        userMessage: 'Unable to create folder',
      })
      if (data) {
        await fetchFolders()
      }
      return data
    } catch (error) {
      errorHandler.handleError(error, {
        context: 'createFolder',
        userMessage: 'Failed to create folder',
      })
      return null
    } finally {
      loading.value = false
    }
  }

  const updateFolder = async (folderId: string, updates: Partial<Folder>) => {
    loading.value = true
    try {
      const response = await $fetch(`/api/folders/${folderId}`, {
        method: 'PATCH',
        body: updates,
      })
      const data = errorHandler.handleFetchError({
        response,
        devMessage: `Failed to update folder ${folderId}`,
        userMessage: 'Unable to update folder',
      })
      if (data) {
        await fetchFolders()
      }
      return data
    } catch (error) {
      errorHandler.handleError(error, {
        context: 'updateFolder',
        userMessage: 'Failed to update folder',
      })
      return null
    } finally {
      loading.value = false
    }
  }

  const deleteFolder = async (folderId: string) => {
    loading.value = true
    try {
      const response = await $fetch(`/api/folders/${folderId}`, {
        method: 'DELETE',
      })
      const data = errorHandler.handleFetchError({
        response,
        devMessage: `Failed to delete folder ${folderId}`,
        userMessage: 'Unable to delete folder',
      })
      if (data !== null) {
        await fetchFolders()
      }
      return true
    } catch (error) {
      errorHandler.handleError(error, {
        context: 'deleteFolder',
        userMessage: 'Failed to delete folder',
      })
      return false
    } finally {
      loading.value = false
    }
  }

  // Initialize folders
  onMounted(() => {
    fetchFolders()
  })

  // Computed properties for convenience
  const getDefaultFolder = computed(() => folders.value.find((f) => f.is_default) || null)
  const getFavorites = computed(() => folders.value.filter((f) => f.is_favorite) || [])

  return {
    folders,
    loading,
    fetchFolders,
    createFolder,
    updateFolder,
    deleteFolder,
    getDefaultFolder,
    getFavorites,
  }
}
</file>

<file path="apps/main-app/composables/usePages.ts">
import { ref } from 'vue'

export interface PageType {
  id: string
  label: string
  slug: string
  icon: string
  children?: PageType[]
}

export interface NavigationCategory {
  id: string
  label: string
  items: PageType[]
}

const navigationCategories = ref([
  {
    id: 'main',
    label: 'Main',
    items: [
      {
        id: 1,
        label: 'Home',
        slug: '/',
        icon: 'material-symbols:home-rounded',
      },
    ],
  },
  {
    id: 'news',
    label: 'News',
    items: [
      {
        id: '2',
        label: 'Feed',
        slug: '/news',
        icon: 'mdi:newspaper-variant-outline',
      },
      {
        id: '3',
        label: '+ Create Feed',
        slug: '/feed/add',
        icon: 'mdi:plus',
      },
    ],
  },
  {
    id: 'profile',
    label: 'Profile',
    items: [
      {
        id: 4,
        label: 'Upvoted',
        slug: '/profile/votes/upvoted',
        icon: 'mdi:arrow-up-bold',
      },
      {
        id: 5,
        label: 'Downvoted',
        slug: '/profile/votes/downvoted',
        icon: 'mdi:arrow-down-bold',
      },
      {
        id: 6,
        label: 'Bookmarks',
        slug: '/profile/bookmarks',
        icon: 'mdi:bookmark-outline',
      },
    ],
  },
] as NavigationCategory[])

export default function usePages() {
  const client = useSupabaseClient()
  const { profile } = useCurrentUser()

  const addFeed = (id: string, label: string) => {
    const newsCategory = navigationCategories.value.find((cat) => cat.id === 'news')

    if (!newsCategory.items.some((item) => item.id === id)) {
      newsCategory.items.push({
        id,
        label,
        slug: `/feed/${id}`,
        icon: 'mdi:newspaper-variant-multiple-outline',
      })
    }
  }

  const deleteFeed = (feedId: string) => {
    const newsCategory = navigationCategories.value.find((cat) => cat.id === 'news')
    const index = newsCategory.items.findIndex((item) => item.id == feedId)

    if (index > -1) {
      newsCategory.items.splice(index, 1)
    }
  }

  const initializeFeeds = () => {
    if (profile.id) {
      const toast = useNotification()
      client
        .from('feeds')
        .select('id, name')
        .eq('user_id', profile.id)
        .then(({ data, error }) => {
          if (error) {
            toast.error({
              summary: 'Failed to get custom feeds',
              message: 'Could not get custom feeds',
            })
            return
          }

          // Add custom feeds to the News category
          const newsCategory = navigationCategories.value.find((cat) => cat.id === 'news')
          if (newsCategory) {
            data.forEach((feed) => {
              if (!newsCategory.items.some((item) => item.id === feed.id)) {
                newsCategory.items.push({
                  id: feed.id,
                  label: feed.name,
                  slug: `/feed/${feed.id}`,
                  icon: 'mdi:newspaper-variant-multiple-outline',
                })
              }
            })
          }
        })
    }
  }

  onMounted(initializeFeeds)

  return {
    appLinks: navigationCategories,
    addFeed,
    deleteFeed,
  }
}
</file>

<file path="apps/main-app/composables/usePayments.ts">
import { ref } from 'vue'
import { useRuntimeConfig } from '#app'

export const usePayments = (provider: 'razorpay' | 'stripe') => {
  const config = useRuntimeConfig()
  const isLoading = ref(false)
  const error = ref(null)

  const initializePayment = async (options: any) => {
    isLoading.value = true
    error.value = null

    try {
      if (provider === 'razorpay') {
        const razorpay = new (window as any).Razorpay({
          key: 'rzp_test_lV0OE0NDIg6Hr6',
          ...options,
        })
        razorpay.open()
      } else if (provider === 'stripe') {
        // Placeholder for Stripe implementation
        console.log('Stripe payment initialization', options)
      }
    } catch (error: any) {
      console.error(`Error initializing payment with ${provider}:`, error)
    } finally {
      isLoading.value = false
    }
  }

  const createOrder = async (planId: string) => {
    isLoading.value = true
    error.value = null

    try {
      const response = await $fetch(`/api/payment/${provider}/create-order`, {
        method: 'POST',
        body: { plan_id: planId },
      })
      return response
    } catch (error) {
      console.error(`Error creating order with ${provider}:`, error)
    } finally {
      isLoading.value = false
    }
  }

  const verifyPayment = async (paymentData: any) => {
    isLoading.value = true
    error.value = null

    try {
      const response = await $fetch(`/api/payment/${provider}/verify-payment`, {
        method: 'POST',
        body: paymentData,
      })
      return response
    } catch (error: any) {
      console.error(`Error verifying payment with ${provider}:`, error)
    } finally {
      isLoading.value = false
    }
  }

  const fetchSubscription = async () => {
    isLoading.value = true
    error.value = null

    try {
      const response = await $fetch(`/api/payment/${provider}/subscription`)
      return response
    } catch (error: any) {
      console.error(`Error verifying payment with ${provider}:`, error)
    } finally {
      isLoading.value = false
    }
  }

  return {
    isLoading,
    error,
    initializePayment,
    createOrder,
    verifyPayment,
    fetchSubscription,
  }
}
</file>

<file path="apps/main-app/composables/usePlan.ts">
import { FEATURES } from '#shared/constants'

// composables/usePlan.ts
export enum PlanType {
  FREE = 'free',
  PRO = 'pro',
}

export interface PlanFeature {
  name: string
  limit: {
    [PlanType.FREE]: number
    [PlanType.PRO]: number
  }
  description: string
  comingSoon?: boolean
}

export const usePlan = () => {
  // For now, we'll assume everyone is on free plan
  // Later this can be updated based on your auth/subscription system
  const userPlan = ref<PlanType>(PlanType.FREE)

  // Utility functions
  const getFeatureLimit = (featureKey: keyof typeof FEATURES) => {
    return FEATURES[featureKey].limit[userPlan.value]
  }

  const isFeatureAvailable = (featureKey: keyof typeof FEATURES) => {
    const feature = FEATURES[featureKey]
    return !feature.comingSoon && getFeatureLimit(featureKey) !== 0
  }

  const checkFeatureLimit = async (
    featureKey: keyof typeof FEATURES,
    currentCount: number,
  ): Promise<boolean> => {
    const limit = getFeatureLimit(featureKey)
    return limit === -1 || currentCount < limit
  }

  const getUpgradeMessage = (featureKey: keyof typeof FEATURES) => {
    const feature = FEATURES[featureKey]
    if (userPlan.value === PlanType.FREE) {
      return feature.limit.pro === -1
        ? `Upgrade to Pro for unlimited ${feature.name}`
        : `Upgrade to Pro for up to ${feature.limit.pro} ${feature.name}`
    }
    return ''
  }

  // This can be used to show remaining quota
  const getFeatureUsage = (featureKey: keyof typeof FEATURES, currentCount: number) => {
    const limit = getFeatureLimit(featureKey)
    return {
      used: currentCount,
      limit,
      remaining: limit === -1 ? -1 : limit - currentCount,
      isUnlimited: limit === -1,
    }
  }

  return {
    FEATURES,
    userPlan,
    getFeatureLimit,
    isFeatureAvailable,
    checkFeatureLimit,
    getUpgradeMessage,
    getFeatureUsage,
  }
}
</file>

<file path="apps/main-app/composables/usePWA.ts">
export const usePWA = () => {
  const nuxtApp = useNuxtApp()
  const { $pwaState, $pwaActions } = nuxtApp

  if (!$pwaState || !$pwaActions) {
    throw new Error('PWA plugin not installed')
  }

  return {
    // States
    isInstallable: $pwaState.isInstallable,
    isUpdateAvailable: $pwaState.isUpdateAvailable,
    isOfflineReady: $pwaState.isOfflineReady,
    isPWAInstalled: $pwaState.isPWAInstalled,
    hasError: $pwaState.hasError,
    isActivated: $pwaState.isActivated,

    // Actions
    install: $pwaActions.install,
    update: $pwaActions.update,
    cancelInstall: $pwaActions.cancelInstall,
    cancelUpdate: $pwaActions.cancelUpdate,
  }
}
</file>

<file path="apps/main-app/composables/useVotesStore.ts">
// stores/useVoteStore.ts
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'

interface VoteResponse {
  success: boolean
  action: 'voted' | 'removed'
}

export const useVoteStore = defineStore('votes', () => {
  // State
  const votes = ref<Record<string, number>>({})
  const userVotes = ref<Record<string, number>>({})
  const pendingVotes = ref<Record<string, Promise<VoteResponse>>>({})
  const isLoading = ref(false)
  const error = ref<Error | null>(null)

  // Getters
  const getVoteType = computed(() => {
    return (contentId: string): number | null => userVotes.value[contentId] ?? null
  })

  const getScore = computed(() => {
    return (contentId: string): number | null => votes.value[contentId] ?? null
  })

  const isVotePending = computed(() => {
    return (contentId: string): boolean => !!pendingVotes.value[contentId]
  })

  // Actions
  const fetchUserVotes = async () => {
    if (isLoading.value) return

    isLoading.value = true
    error.value = null

    try {
      const response = await $fetch('/api/votes/user')
      userVotes.value = response.votes
    } catch (err) {
      console.error('Error fetching votes:', err)
      error.value = err as Error
      throw err
    } finally {
      isLoading.value = false
    }
  }

  const fetchVotedPosts = async (voteType: 1 | -1) => {
    try {
      const response = await $fetch(`/api/votes/user/${voteType}`)
      return response
    } catch (err) {
      console.error('Error fetching voted posts:', err)
      error.value = err as Error
      throw err
    }
  }

  const setVotes = (contentId: string, score: number) => {
    votes.value[contentId] = score
  }

  const submitVote = async (
    contentId: string,
    voteType: number,
    { success: successNotify, error: errorNotify }: ReturnType<typeof useNotification>,
  ) => {
    // Check for pending vote
    if (pendingVotes.value[contentId]) {
      return
    }

    const currentVote = getVoteType.value(contentId)
    const isRemoving = currentVote === voteType
    const oldVote = currentVote

    try {
      // Create the vote promise
      pendingVotes.value[contentId] = $fetch(`/api/votes/news/${contentId}`, {
        method: 'POST',
        body: { voteType },
      })

      // Optimistically update UI
      userVotes.value = {
        ...userVotes.value,
        [contentId]: isRemoving ? null : voteType,
      }

      // Wait for the response
      const response = await pendingVotes.value[contentId]

      // Show success notification
      successNotify({
        summary: 'Vote Recorded',
        message: `Successfully ${response.action === 'removed' ? 'removed vote' : 'voted'}`,
      })

      // Calculate score change
      let change = 0
      if (isRemoving) {
        change = -voteType
      } else {
        change = oldVote ? voteType * 2 : voteType
      }
      const newVotes = votes.value[contentId] + change

      votes.value = {
        ...votes.value,
        [contentId]: newVotes,
      }

      return { success: true, change }
    } catch (err: any) {
      // Revert optimistic update
      userVotes.value = {
        ...userVotes.value,
        [contentId]: oldVote,
      }

      // Handle specific error cases
      if (err.statusCode === 401) {
        errorNotify({
          summary: 'Authentication Required',
          message: 'Please log in to vote',
        })
      } else {
        errorNotify({
          summary: 'Vote Failed',
          message: 'Unable to record your vote. Please try again.',
        })
      }

      throw err
    } finally {
      // Clean up pending vote
      delete pendingVotes.value[contentId]
    }
  }

  return {
    // State
    votes,
    userVotes,
    isLoading,
    error,

    // Getters
    setVotes,
    getScore,
    getVoteType,
    isVotePending,

    // Actions
    fetchUserVotes,
    submitVote,
    fetchVotedPosts, // Added this to the returned object
  }
})
</file>

<file path="apps/main-app/docs/uuid.md">
We use UUID 1 Because it stores timestamps along with the file, we also want to discourage LOTs of
user generated content, we just want the premium content, which can be achived by restricting users
to 1 post per day.

### UUID Version 1 Details:

- **Timestamp-Based**: Incorporates the current time and date as part of the UUID itself, meaning
  that each UUID is not only unique but also time-ordered.
- **Structure**: Contains a 60-bit timestamp (the number of 100-nanosecond intervals since October
  15, 1582), a 14-bit clock sequence (for uniqueness if the clock is set backwards or if there are
  multiple UUIDs generated at the same timestamp), and a 48-bit node identifier (usually the MAC
  address of the machine generating the UUID).

### Benefits of Using UUID Version 1 for Images:

1. **Traceability**: Each image file can be traced back to its exact creation time from its UUID,
   without needing additional metadata fields.
2. **Sorting and Retrieval**: Images can be sorted or retrieved based on their creation times
   directly from their UUIDs, facilitating chronological organization and access.
3. **Scalability and Uniqueness**: Provides a high level of uniqueness and is suitable for
   distributed systems, ensuring that UUIDs generated from different machines at the same time are
   distinct.

### Example of UUID Version 1:

```javascript
import { v1 as uuidv1 } from 'uuid'

// Generate a UUID with embedded timestamp
const imageUUID = uuidv1()
console.log(imageUUID) // Outputs: '2c5ea4c0-4067-11e9-8bad-9b1deb4d3b7d'
```

### Usage for All Images:

If you choose UUID version 1 for all image types (avatars, posts, covers), you ensure consistency
across your file naming conventions and take full advantage of the built-in timestamp feature for
all your image-related assets.

In summary, UUID version 1 is an excellent choice for your scenario where timestamp information is
crucial, and it aligns well with your needs for both organizational and technical efficiency.
</file>

<file path="apps/main-app/layouts/app-settings.vue">
<script setup lang="ts">
const user = useCurrentUser()

const settingsRoutes = computed(() => [
  {
    key: 'settings-account',
    label: 'Account Profile',
    url: '/profile/settings/profile',
    icon: 'material-symbols:home',
    visible: true,
    disabled: false,
  },
  {
    key: 'settings-password',
    label: 'Update Password',
    url: '/profile/settings/password',
    icon: 'material-symbols:key',
    visible: user.profile?.providers.includes('email'),
    disabled: false,
  },
  // {
  //   key: 'settings-payments',
  //   label: 'Payments',
  //   url: '/profile/settings/payments',
  //   icon: 'mdi:credit-card',
  //   visible: true,
  //   disabled: false,
  // },
  {
    key: 'settings-notifications',
    label: 'Notifications',
    url: '/profile/settings/notifications',
    icon: 'material-symbols:notifications',
    visible: true,
    disabled: true,
  },
])
</script>

<template>
  <div class="flex flex-col h-screen">
    <NuxtLayout name="app">
      <AppBackButton class="rounded-none !justify-start !items-start" />
      <div class="overflow-auto h-screen flex flex-col p-4 bg-black md:flex-row md:gap-8 lg:p-8">
        <PrimeMenu
          :model="settingsRoutes"
          :pt="{
            root: 'border-none !bg-transparent relative md:w-64',
            list: 'md:sticky md:top-8 flex md:flex-col justify-left !w-full items-center md:justify-end md:items-end overflow-auto',
            item: 'w-full',
          }"
          :pt-options="{ mergeSections: true, mergeProps: true }"
        >
          <template #item="{ item }">
            <NuxtLink
              v-if="item.url && !item.disabled"
              v-ripple
              :to="item.url"
              exact-active-class="bg-primary-950 text-white w-full"
              class="flex w-full justify-between gap-2 rounded-md px-3 py-2"
            >
              <span class="text-nowrap md:mr-4">{{ item.label }}</span>
              <div class="hidden md:block">
                <Icon
                  v-if="item.icon"
                  :name="item.icon"
                />
              </div>
            </NuxtLink>
          </template>
        </PrimeMenu>
        <div class="flex-grow">
          <slot />
        </div>
      </div>
    </NuxtLayout>
  </div>
</template>

<style scoped></style>
</file>

<file path="apps/main-app/layouts/default.vue">
<script setup lang="ts">
const { appLinks } = usePages()
const { isSidebarOpen, isMobileSidebarOpen, isMobile } = useNavigation()
</script>

<template>
  <div class="w-full h-screen flex background relative overflow-hidden lg:py-4 lg:pr-4">
    <IBSideNav
      v-model:is-sidebar-open="isSidebarOpen"
      v-model:is-mobile-sidebar-open="isMobileSidebarOpen"
      :categories="appLinks"
      :is-mobile="isMobile"
    />
    <div
      class="w-full h-full pb-[var(--mobi-bottom-nav-height)] lg:pb-0 relative flex flex-col rounded-lg overflow-hidden"
    >
      <NavAppTop />
      <div class="overflow-y-scroll h-full foreground">
        <div class="h-full">
          <slot />
        </div>
      </div>
    </div>
    <NavMobiBottom class="lg:hidden" />
  </div>
</template>
</file>

<file path="apps/main-app/middleware/auth.global.ts">
import { defineNuxtRouteMiddleware, navigateTo, useNuxtApp } from '#app'
import { useRuntimeConfig, useSupabaseClient } from '#imports'

export default defineNuxtRouteMiddleware(async (to) => {
  const config = useRuntimeConfig()
  const { $formbricks } = useNuxtApp()

  console.log('AUTH_MIDDLEWARE', $formbricks)

  const { aeLoginUrl, aeAuthUrl } = config.public
  const supabase = useSupabaseClient()

  // List of public routes that don't require authentication
  const publicRoutes = ['/auth-callback']

  if (publicRoutes.includes(to.path)) {
    return // Allow access to public routes without checking auth
  }

  const { data, error } = await supabase.auth.getSession()

  if (error || !data.session) {
    console.log('USER_NOT_LOGGED_IN', `${aeAuthUrl}${aeLoginUrl}`)
    return navigateTo(String(`${aeAuthUrl}${aeLoginUrl}`), { external: true })
  } else {
    console.log('USER_LOGGED_IN', data.session, $formbricks)
    // $formbricks.setUserId(data.session.user.id)
  }
})
</file>

<file path="apps/main-app/middleware/isCurrentUser.ts">
export default defineNuxtRouteMiddleware((to, from) => {
  const user = useSupabaseUser()

  if (!!to.params.id && to.params.id !== user.value.id) {
    const newPath = to.fullPath.replace(to.params.id, user.value.id)
    return navigateTo(newPath)
  }
})
</file>

<file path="apps/main-app/pages/feed/[feed].vue">
<script setup lang="ts">
const route = useRoute()
const feedId = computed(() => String(route.params.feed))
const { deleteFeed } = usePages()

const { store: categoriesStore } = useSelectData('feed_categories', {
  columns: 'id, feed_id, categories(id, name)',
  filters: {
    feed_id: { eq: feedId.value },
  },
  orderBy: { column: 'created_at', ascending: false },
  initialFetch: true,
})

const removeFeed = async () => {
  const { deleteData, isDeleting } = useDeleteData('feeds')
  await deleteData(feedId.value)

  if (!isDeleting.value) {
    deleteFeed(feedId.value)
    navigateTo('/')
  }
}

const { items: proxyCategories } = storeToRefs(categoriesStore)

const categories = computed(() => proxyCategories.value.map((item) => toRaw(item).categories))

const news = ref([])
const newsStore = ref(null)
const loadMoreFunc = ref(null)

const domainKey = 'news'

watch(
  categories,
  (newCategories) => {
    if (newCategories.length) {
      news.value = []

      const { store, loadMore, refresh } = useSelectData<News>('news', {
        columns:
          'id, title, body, published_at, created_at, description, category_id, author, url, keywords, featured_image, company_id, companies(*)',
        filters: {
          category_id: { in: newCategories.map((category) => category.id) },
        },
        orderBy: { column: 'created_at', ascending: false },
        initialFetch: true,
      })

      newsStore.value = store
      loadMoreFunc.value = loadMore

      // Update news when store items change
      watch(
        () => store.items,
        (newItems) => {
          news.value = newItems.map((item) => toRaw(item))
        },
        { immediate: true },
      )
    } else {
      news.value = []
      newsStore.value = null
      loadMoreFunc.value = null
    }
  },
  { immediate: true },
)

const loading = useLoadingStore()
const isLoading = computed(() => loading.isLoading(domainKey))
</script>

<template>
  <div class="p-2">
    <PrimeButton
      v-for="(category, index) in categories"
      :key="index"
      color="primary"
      :aria-label="category.name"
      :label="category.name"
      size="small"
      class="m-1"
    />
    <div>
      <IBInfiniteScroll @update:scroll-end="loadMoreFunc && loadMoreFunc()">
        <div
          class="mx-auto w-full grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 md:col-start-2 gap-4 md:gap-8 p-4 md:p-8 max-w-[940px]"
        >
          <NewsCard
            v-for="(item, i) in news"
            :key="`news-post-${item.id}`"
            :news="item"
          />
          <NewsCardSkeleton v-show="isLoading" />
        </div>
      </IBInfiniteScroll>
    </div>
    <PrimeButton
      label="Delete feed"
      class="bg-red-800"
      @click="removeFeed"
    />
  </div>
</template>

<style scoped></style>
</file>

<file path="apps/main-app/pages/feed/add.vue">
<script setup lang="ts">
import Fuse from 'fuse.js'

const { addFeed } = usePages()

const { store, loadMore, refresh, isSelecting } = useSelectData('categories', {
  columns: 'id, name',
  orderBy: { column: 'name', ascending: true },
  limit: 100,
  initialFetch: true,
})

const name = ref('')
const search = ref('')
const fuseInstance = ref<Fuse<any> | null>(null)

const { items: proxyCategories } = storeToRefs(store)

const initializeSelection = () => {
  proxyCategories.value = proxyCategories.value.map((item) => ({
    ...item,
    selected: false,
  }))
}

watchEffect(() => {
  if (proxyCategories.value.length > 0) {
    initializeSelection()
    fuseInstance.value = new Fuse(proxyCategories.value, {
      keys: ['name'],
      threshold: 0.3,
      distance: 100,
      ignoreLocation: true,
      shouldSort: true,
    })
  }
})

const toggleSelect = (id: string) => {
  const category = proxyCategories.value.find((item) => item.id === id)
  if (category) {
    category.selected = !category.selected
  }
}

const onSearch = () => {
  if (!search.value || search.value.trim().length < 2) {
    return proxyCategories.value
  }

  if (fuseInstance.value) {
    const results = fuseInstance.value.search(search.value.trim())
    return results.map((result) => ({
      ...result.item,
      selected: proxyCategories.value.find((cat) => cat.id === result.item.id)?.selected || false,
    }))
  }

  return proxyCategories.value
}

const categories = computed(() => onSearch())

const selectedCategories = computed(() => proxyCategories.value.filter((cat) => cat.selected))

const save = async () => {
  const toast = useNotification()
  const selected = selectedCategories.value

  if (!name.value) {
    toast.error({ summary: 'Feed name cannot be empty', message: 'Please enter a feed name' })
    return
  }

  if (!selected.length) {
    toast.error({ summary: 'No categories selected', message: 'Please select some categories' })
    return
  }

  const { profile } = useCurrentUser()
  const client = useSupabaseClient()

  if (profile?.id) {
    const user_id = profile.id
    const feed = { user_id, name: name.value }
    try {
      const { data, error, status } = await client.from('feeds').insert(feed).select('id')

      if (!error) {
        const feed_id = data[0].id
        const res = await Promise.all(
          selected.map((category) =>
            client.from('feed_categories').insert({ feed_id, category_id: category.id }),
          ),
        )

        if (res.every(({ error }) => !error)) {
          toast.success({
            summary: 'Feed created successfully',
            message: `${name.value} was created successfully`,
          })
          addFeed(data[0].id, name.value)
        } else {
          res.forEach(
            ({ error }) =>
              error && toast.error({ summary: 'Could not create feed', message: error.message }),
          )
        }
      } else {
        toast.error({ summary: 'Could not create feed', message: error.message })
      }
    } catch (error) {
      toast.error({ summary: 'Could not create feed', message: error })
    }
  } else {
    toast.error({ summary: 'User Not Authenticated', message: 'Please login again' })
  }
}

const discard = () => {
  name.value = ''
  search.value = ''
  proxyCategories.value.forEach((item) => (item.selected = false))
}

const removeSelected = (id: string) => {
  const category = proxyCategories.value.find((item) => item.id === id)
  if (category) {
    category.selected = false
  }
}

const selectedItems = computed({
  get: () => selectedCategories.value,
  set: () => {}, // We handle removal through the removeSelected method
})

definePageMeta({
  name: 'Add Feed',
})
</script>

<template>
  <div class="mx-auto p-4">
    <!-- Header -->
    <div class="mb-6">
      <h1 class="text-2xl font-semibold mb-2">Create New Feed</h1>
      <p class="text-gray-500">Select categories to include in your feed</p>
    </div>

    <!-- Main Layout -->
    <div class="grid grid-cols-1 gap-6">
      <!-- Top Panel - Input and Selected Categories -->
      <PrimeCard class="bg-gray-900">
        <template #content>
          <div class="grid grid-cols-12 gap-4">
            <!-- Feed Name Input -->
            <div class="col-span-12 md:col-span-4">
              <PrimeFloatLabel>
                <PrimeInputText
                  id="feedname"
                  v-model="name"
                  class="w-full"
                  required
                />
                <label for="feedname">Enter feed name</label>
              </PrimeFloatLabel>
            </div>

            <!-- Action Buttons -->
            <div class="col-span-12 md:col-span-8 flex items-center gap-2 justify-end">
              <PrimeSelect
                v-model="selectedItems"
                :options="selectedCategories"
                placeholder="No categories selected"
                option-label="name"
                :close-on-select="false"
                multiple
                class="w-full"
              >
                <template #header>
                  <div class="px-4 py-2 text-gray-400 text-sm font-medium">
                    Selected Categories
                  </div>
                </template>
                <template #value="{ value }">
                  <div class="flex items-center gap-2">
                    <span class="text-gray-300">{{
                      value?.length
                        ? `${value.length} categories selected`
                        : 'No categories selected'
                    }}</span>
                    <PrimeBadge
                      v-if="value?.length"
                      :value="value.length"
                      severity="info"
                    />
                  </div>
                </template>
                <template #option="{ option }">
                  <div class="flex items-center justify-between w-full px-2 py-1">
                    <span>{{ option.name }}</span>
                    <button
                      class="text-gray-400 hover:text-red-500 p-1 rounded-full hover:bg-gray-700/50"
                      @click.stop="removeSelected(option.id)"
                    >
                      <Icon
                        name="mdi:close"
                        size="16px"
                      />
                    </button>
                  </div>
                </template>
              </PrimeSelect>
              <PrimeButton
                label="Save"
                :disabled="!name || !selectedCategories.length"
                class="flex shrink-0"
                @click="save"
              />
              <button
                class="p-2 hover:bg-gray-800 rounded-full transition-colors"
                @click="discard"
              >
                <Icon
                  name="mdi:trash-can-outline"
                  size="22px"
                  class="text-red-500"
                />
              </button>
            </div>
            <!-- Search -->
            <div class="col-span-12">
              <PrimeFloatLabel>
                <PrimeInputText
                  id="search"
                  v-model="search"
                  class="w-full"
                />
                <label for="search">Search categories</label>
              </PrimeFloatLabel>
            </div>
          </div>
        </template>
      </PrimeCard>

      <!-- Search and Categories -->
      <PrimeCard class="bg-gray-900">
        <template #content>
          <!-- Categories Grid -->
          <PrimeProgressSpinner
            v-if="proxyCategories.length === 0"
            class="w-8 h-8 mx-auto"
          />
          <div
            v-else
            class="h-[500px] overflow-y-auto custom-scrollbar"
          >
            <div class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-2">
              <PrimeButton
                v-for="category in categories"
                :key="category.id"
                :label="category.name"
                :outlined="!category.selected"
                size="small"
                class="whitespace-normal h-auto py-2 justify-start"
                @click="toggleSelect(category.id)"
              />
            </div>
          </div>
        </template>
      </PrimeCard>
    </div>
  </div>
</template>

<style scoped>
:deep(.p-card) {
  background: transparent;
}

:deep(.p-button) {
  justify-content: flex-start;
}

:deep(.p-inputtext) {
  width: 100%;
  background: theme('colors.gray.800');
}

:deep(.p-dropdown),
:deep(.p-multiselect) {
  background: theme('colors.gray.800');
  border-color: theme('colors.gray.700');
}

:deep(.p-dropdown-panel),
:deep(.p-multiselect-panel) {
  background: theme('colors.gray.800');
  border-color: theme('colors.gray.700');
}

:deep(.p-dropdown-item),
:deep(.p-multiselect-item) {
  color: theme('colors.gray.300');
}

:deep(.p-dropdown-item:hover),
:deep(.p-multiselect-item:hover) {
  background: theme('colors.gray.700');
}

.custom-scrollbar {
  scrollbar-width: thin;
  scrollbar-color: theme('colors.gray.600') theme('colors.gray.800');
}

.custom-scrollbar::-webkit-scrollbar {
  width: 8px;
}

.custom-scrollbar::-webkit-scrollbar-track {
  background: theme('colors.gray.800');
  border-radius: 4px;
}

.custom-scrollbar::-webkit-scrollbar-thumb {
  background-color: theme('colors.gray.600');
  border-radius: 4px;
}

:deep(.p-float-label) {
  display: block;
}

:deep(.p-float-label input:focus) ~ label,
:deep(.p-float-label input.p-filled) ~ label {
  background: theme('colors.gray.900');
  padding: 0 4px;
}
</style>
</file>

<file path="apps/main-app/pages/news/index.vue">
<script setup lang="ts">
// !todo:critical - add summaries for news articles
// !todo:high - allow news to toggle summary level
// !todo:bug:critical - infinite scroll is loading duplicate posts with pagination, probably a supabase issue
const { init: initBookmarks } = useBookmarks()

const domainKey = 'news'
const { store, loadMore, refresh } = useSelectData<News>('news', {
  columns:
    'id, title, body, published_at, created_at, description, category_id, author, url, keywords, featured_image, company_id, companies(*), score',
  filters: {
    // content_status: { eq: 'draft' },
    body: { neq: 'null' },
  },
  orderBy: { column: 'created_at', ascending: false },
  initialFetch: true,
  pagination: { page: 1, limit: 20 },
})

const { items: proxyNews } = storeToRefs(store)

const news = computed(() => proxyNews.value.map((item) => toRaw(item)))

console.log('news', news)

const loading = useLoadingStore()
const isLoading = computed(() => loading.isLoading(domainKey))

onMounted(async () => {
  await initBookmarks()
})

// Add this to refresh bookmarks after route changes
const route = useRoute()
watch(
  () => route.path,
  async () => {
    await initBookmarks()
  },
)

definePageMeta({
  name: 'News',
})
</script>

<template>
  <div>
    <IBInfiniteScroll @update:scroll-end="loadMore()">
      <div
        class="mx-auto w-full grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 md:col-start-2 gap-4 md:gap-8 p-4 md:p-8 max-w-[940px]"
      >
        <div class="col-span-full w-full justify-between flex">
          <PrimeButton @click="refresh()"> Feed Categories </PrimeButton>
          <PrimeButton
            link
            @click="refresh()"
          >
            Feed Settings
          </PrimeButton>
        </div>
        <NewsCard
          v-for="(item, i) in news"
          :key="`news-post-${i}`"
          :news="item"
        />
        <NewsCardSkeleton v-show="isLoading" />
      </div>
    </IBInfiniteScroll>
  </div>
</template>

<style scoped></style>
</file>

<file path="apps/main-app/pages/profile/settings/password.vue">
<script setup lang="ts">
const schema = [
  {
    id: 'new_password',
    label: 'New Password',
    tip: 'New password must be at least 6 characters long',
    placeholder: 'Your new password',
    value: ref(''),
    type: 'password',
  },
  {
    id: 'confirm_new_password',
    label: 'Confirm Password',
    tip: 'Please confirm your new password',
    placeholder: 'Confirm Your password',
    value: ref(''),
    type: 'password',
  },
]

const currentUser = useCurrentUser()
const toast = useNotification()

const {
  store: userProfile,
  loadMore,
  refresh,
} = await useSelectData<User>('user_profiles', {
  columns: 'id, given_name, surname, email, avatar, dob, username',
  filters: { id: { eq: currentUser.profile.id } },
  initialFetch: true,
  limit: 1,
})

async function handlePasswordUpdate() {
  const supabase = useSupabaseClient()
  const { new_password, confirm_new_password } = schema.reduce(
    (acc, field) => ({ ...acc, [field.id]: field.value.value }),
    {
      new_password: '',
      confirm_new_password: '',
    },
  )

  if (new_password !== confirm_new_password) {
    toast.error({
      summary: "Passwords Don't Match",
      message: "The two passwords entered don't match",
    })
    return
  }

  const { error } = await supabase.auth.updateUser({ password: new_password })

  if (error) {
    toast.error({ summary: 'Could Not Update Password', message: error.message })
  } else {
    toast.success({
      summary: 'Successfully Updated Password',
      message: 'Your password was updated',
    })
  }
}

definePageMeta({
  layoutTransition: false,
  name: 'Password',
  layout: 'app-settings',
})

const settings = reactive({
  password: '',
  new_password: '',
  confirm_new_password: '',
})

const isPasswordUpdatable = computed(() =>
  currentUser.profile ? currentUser.profile?.providers.includes('email') : false,
)
</script>

<template>
  <div>
    <UserSettingsCard
      :title="{
        main: 'Update Password',
        subtitle: 'Change your password here',
      }"
    >
      <div v-if="isPasswordUpdatable">
        <UserSettingsItem
          v-for="item in schema"
          :key="item.id"
          :item="item"
        >
          <FormPassword
            :id="item.id"
            v-model="item.value.value"
            :feedback="item.id !== 'confirm_new_password'"
            :required="true"
          />
        </UserSettingsItem>
        <div class="flex justify-start pt-12">
          <PrimeButton
            label="Update Password"
            @click="handlePasswordUpdate"
          />
        </div>
      </div>
      <PrimeMessage
        v-else-if="currentUser.profile"
        severity="info"
      >
        You used {{ currentUser.profile.provider }} to authenticate
      </PrimeMessage>
    </UserSettingsCard>
  </div>
</template>
</file>

<file path="apps/main-app/pages/profile/settings/payments.vue">
<script setup lang="ts">
import { ref } from 'vue'

const { isLoading, error, initializePayment, createOrder, verifyPayment, fetchSubscription }
  = usePayments('razorpay')

const result = ref(null as any)

const handleCreateOrder = async () => {
  result.value = await createOrder('plan_OmmnufyFh3id2P')
}

const handleInitializePayment = async () => {
  const order = await createOrder('plan_OmmnufyFh3id2P')
  if (order) {
    await initializePayment({
      amount: order.amount,
      currency: order.currency,
      order_id: order.id,
      handler: handleVerifyPayment,
    })
  }
}

const handleVerifyPayment = async (response: any) => {
  result.value = await verifyPayment(response)
}

const handleFetchSubscription = async () => {
  result.value = await fetchSubscription()
}

useHead({
  script: [
    {
      src: 'https://checkout.razorpay.com/v1/checkout.js',
      defer: true,
    },
  ],
})

definePageMeta({
  layoutTransition: false,
  name: 'Payments',
  layout: 'app-settings',
})
</script>

<template>
  <UserSettingsCard
    :title="{
      main: 'Payment Settings',
      subtitle: 'Manage your subscription and payment options',
    }"
  >
    <div class="flex gap-4 items-center">
      <PrimeButton
        :loading="isLoading"
        @click="handleCreateOrder"
      >
        Create Order
      </PrimeButton>
      <PaymentButton />
      <PrimeButton
        :loading="isLoading"
        @click="handleInitializePayment"
      >
        Initialize Payment
      </PrimeButton>
      <PrimeButton
        :loading="isLoading"
        @click="handleVerifyPayment"
      >
        Verify Payment
      </PrimeButton>
      <PrimeButton
        :loading="isLoading"
        @click="handleFetchSubscription"
      >
        Fetch Subscription
      </PrimeButton>
    </div>

    <div
      v-if="error"
      class="mt-4 text-red-500"
    >
      {{ error }}
    </div>

    <div
      v-if="result"
      class="mt-4"
    >
      <pre>{{ JSON.stringify(result, null, 2) }}</pre>
    </div>
  </UserSettingsCard>
</template>
</file>

<file path="apps/main-app/pages/profile/settings/profile.vue">
<script setup lang="ts">
import { z } from 'zod'
import { useFileUpload } from '#imports'

const schema = [
  {
    value: 'given_name',
    label: 'Given Name',
    tip: 'Your first name',
    placeholder: 'Your first name',
    type: 'text',
  },
  {
    value: 'surname',
    label: 'Surname',
    tip: 'Your last name',
    placeholder: 'Your last name',
    type: 'text',
  },
  {
    value: 'email',
    label: 'Email',
    tip: 'Contact support to update your email',
    placeholder: 'Your email address',
    type: 'email',
    disabled: true,
  },
  {
    value: 'username',
    label: 'Username',
    tip: 'Contact support to update your username',
    placeholder: 'Your username',
    type: 'username',
    disabled: true,
  },
]

const SettingsAccountValidation = z.object({
  given_name: z.string().min(1, 'Given Name is required'),
  surname: z.string().min(1, 'Surname is required'),
  username: z.string(),
  email: z.string().email(),
  introduction: z.string().min(240, 'At least 240 characters required').optional(),
  quote: z.string().min(10, 'At least 10 characters required').optional(),
})

const currentUser = useCurrentUser()

const profileCopy = ref({})

onMounted(() => {
  profileCopy.value = { ...currentUser.profile }
})

const updateProfileImage = (newImage: string) => {
  const avatar = `${newImage}?v=${Date.now()}`
  currentUser.updateProfile({ avatar })
  profileCopy.value.avatar = avatar
}

definePageMeta({
  layoutTransition: false,
  name: 'Profile',
  layout: 'app-settings',
})
</script>

<template>
  <div>
    <UserSettingsCard
      v-if="currentUser"
      :title="{
        main: 'Account Profile',
        subtitle: 'Update your account information',
      }"
    >
      <div class="relative w-full max-w-[1200px]">
        <div
          class="left-16 flex h-32 w-32 items-center justify-center overflow-hidden rounded-full bg-red-50"
        >
          <PrimeAvatar
            v-if="profileCopy && profileCopy.avatar"
            :image="profileCopy.avatar"
            shape="circle"
            class="w-full h-full cursor-pointer"
            aria-haspopup="true"
            aria-controls="overlay_menu"
            crossorigin="anonymous"
          />
          <UploadCropper
            cropper-type="avatar"
            class="absolute bottom-0 z-20"
            bucket="profile-public"
            @profile-pic-update="updateProfileImage"
          />
        </div>
      </div>

      <div class="pt-24">
        <UserSettingsItem
          v-for="item in schema"
          :key="item.value"
          :item="item"
        >
          <div class="w-full">
            <PrimeInputText
              v-model="profileCopy[item.value]"
              class="w-96"
              :type="item.type"
              :disabled="item.disabled"
              :placeholder="profileCopy[item.value] || item.placeholder"
            />
          </div>
        </UserSettingsItem>
        <div class="flex py-8 gap-2">
          <PrimeButton
            class="text-white"
            @click="currentUser.updateProfile(profileCopy)"
          >
            Save changes
          </PrimeButton>
        </div>
      </div>
    </UserSettingsCard>
  </div>
</template>
</file>

<file path="apps/main-app/pages/profile/votes/[type].vue">
<script setup lang="ts">
import { ref, computed } from 'vue'

const route = useRoute()
const voteStore = useVoteStore()

const voteString = computed(() => route.params.type)
const voteType = computed(() => (voteString.value === 'upvoted' ? 1 : -1))
const posts = ref([])
const isLoading = ref(false)

const fetchVotedPosts = async () => {
  isLoading.value = true
  try {
    posts.value = await voteStore.fetchVotedPosts(voteType.value)
  } catch (error) {
    console.error('Error fetching voted posts:', error)
  } finally {
    isLoading.value = false
  }
}

// Initialize vote store if needed
onMounted(async () => {
  if (Object.keys(voteStore.votes).length === 0) {
    await voteStore.fetchUserVotes()
  }
  fetchVotedPosts()
})

// Update posts when route type changes
watch(() => voteString, fetchVotedPosts)
</script>

<template>
  <div class="p-4 md:p-8">
    <h1 class="text-2xl font-bold pb-4 md:pb-8 text-center">
      {{ voteString === 'upvoted' ? 'Upvoted' : 'Downvoted' }} Posts
    </h1>

    <div
      v-if="isLoading"
      class="flex justify-center py-8"
    >
      <PrimeSpinner />
    </div>

    <div
      v-else-if="posts.length === 0"
      class="text-center py-8"
    >
      No posts found
    </div>

    <div
      v-else
      class="mx-auto w-full grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 md:col-start-2 gap-4 md:gap-8 max-w-[940px]"
    >
      <NewsCard
        v-for="post in posts"
        :key="post.id"
        :news="post"
      />
    </div>
  </div>
</template>
</file>

<file path="apps/main-app/pages/profile/bookmarks.vue">
<script setup lang="ts">
import type { FuseResult } from 'fuse.js'
import type { Folder } from '~/composables/useFolderSystem'

const { getFeatureUsage } = usePlan()
const { folders, loading: foldersLoading } = useFolderSystem()
const { bookmarks, loading: bookmarksLoading, fetchBookmarks } = useBookmarks()
const {
  selectedBookmarks,
  showMoveModal,
  handleNewFolder,
  handleMoveSubmit,
  handleDeleteBookmark,
} = useBookmarkManager()

const {
  viewMode,
  searchQuery,
  includeSubfolders,
  showFolderPanel,
  showNewFolderModal,
  currentFolder,
  handleFolderSelect,
  toggleFolderPanel,
} = useBookmarkView()

const folderUsage = computed(() => getFeatureUsage('BOOKMARK_FOLDERS', folders.value.length))
const displayedBookmarks = ref<typeof bookmarks.value>([])

const toggleSelection = (id: string) => {
  const index = selectedBookmarks.value.indexOf(id)
  if (index === -1) {
    selectedBookmarks.value.push(id)
  } else {
    selectedBookmarks.value.splice(index, 1)
  }
}

const clearSelection = () => {
  selectedBookmarks.value = []
}

const handleBulkDelete = async () => {
  if (!selectedBookmarks.value.length) return
  await handleDeleteBookmark(selectedBookmarks.value)
  clearSelection()
}

// Search configuration
const searchFuseOptions = {
  keys: ['metadata.title', 'metadata.description', 'metadata.author'],
  threshold: 0.3,
  shouldSort: true,
}

// Handle search results
const handleSearchResults = (results: FuseResult<any>[]) => {
  if (results.length === 0 && !searchQuery.value) {
    displayedBookmarks.value = bookmarks.value
  } else {
    displayedBookmarks.value = results.map((result) => result.item)
  }
}

const loading = computed(() => foldersLoading.value || bookmarksLoading.value)

onMounted(async () => {
  const session = await useSupabaseSession()
  if (session.value) {
    await fetchBookmarks({})
  }
})

// Update initial display when bookmarks change
watch(
  () => bookmarks.value,
  (newBookmarks) => {
    if (!searchQuery.value) {
      displayedBookmarks.value = newBookmarks
    }
  },
  { immediate: true },
)
</script>

<template>
  <div class="min-h-screen p-4 space-y-4">
    <BookmarkViewFolder v-if="!searchQuery" />

    <!-- Simplified toolbar without left hamburger -->
    <PrimeToolbar
      class="sticky top-0 z-40"
      :pt="{
        start: 'flex-grow',
      }"
    >
      <template #start>
        <div class="w-full max-w-xl">
          <FuzzySearch
            v-model="searchQuery"
            :data="bookmarks"
            :fuse-options="searchFuseOptions"
            placeholder="Search bookmarks..."
            class="w-full"
            @results="handleSearchResults"
          />
        </div>
      </template>

      <template #end>
        <div class="flex items-center gap-4">
          <!-- Selection Actions -->
          <template v-if="selectedBookmarks.length > 0">
            <span class="text-sm text-gray-600">{{ selectedBookmarks.length }} selected</span>
            <PrimeButton
              severity="danger"
              size="small"
              @click="handleBulkDelete"
            >
              Delete
            </PrimeButton>
            <PrimeButton
              size="small"
              @click="showMoveModal = true"
            >
              Move to Folder
            </PrimeButton>
            <PrimeButton
              size="small"
              text
              @click="clearSelection"
            >
              Clear
            </PrimeButton>
          </template>

          <!-- Regular Actions -->
          <template v-else>
            <PrimeCheckbox
              v-if="currentFolder"
              v-model="includeSubfolders"
              :binary="true"
              label="Include subfolders"
            />
          </template>
        </div>
      </template>
    </PrimeToolbar>

    <div class="flex">
      <!-- Main Content -->
      <div class="flex-1 overflow-auto">
        <div class="max-w-7xl mx-auto space-y-6">
          <!-- Current Folder Info -->
          <div
            v-if="currentFolder"
            class="flex items-center gap-2"
          >
            <div
              class="w-3 h-3 rounded-full"
              :style="{ backgroundColor: currentFolder.color }"
            />
            <h2 class="text-xl font-semibold">{{ currentFolder.name }}</h2>
            <Icon
              v-if="currentFolder.is_favorite"
              name="mdi:star"
              class="text-yellow-400"
            />
          </div>

          <!-- Loading State -->
          <div
            v-if="loading"
            class="flex items-center justify-center h-64"
          >
            <PrimeProgressSpinner />
          </div>

          <!-- Bookmarks Grid -->
          <div
            v-else
            class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4"
          >
            <TransitionGroup
              enter-active-class="transition-all duration-300 ease-out"
              enter-from-class="opacity-0 transform scale-95"
              enter-to-class="opacity-100 transform scale-100"
              leave-active-class="transition-all duration-200 ease-in"
              leave-from-class="opacity-100 transform scale-100"
              leave-to-class="opacity-0 transform scale-95"
            >
              <div
                v-for="bookmark in displayedBookmarks"
                :key="bookmark.id"
                class="relative group flex"
              >
                <div
                  class="absolute w-full h-10 inset-0 z-10 flex items-start justify-end p-2 bg-black/5"
                  :class="
                    selectedBookmarks.includes(bookmark.id)
                      ? 'opacity-100'
                      : 'opacity-0 group-hover:opacity-100 transition-opacity'
                  "
                >
                  <PrimeCheckbox
                    :model-value="selectedBookmarks.includes(bookmark.id)"
                    :binary="true"
                    @update:model-value="toggleSelection(bookmark.id)"
                  />
                </div>

                <NewsCard
                  :news="{
                    id: bookmark.content_id,
                    title: bookmark.metadata.title,
                    description: bookmark.metadata.description,
                    authorName: bookmark.metadata.author || 'Unknown',
                    featured_image: bookmark.metadata.thumbnail,
                    url: bookmark.metadata.url,
                    comments: 0,
                    score: 0,
                  }"
                  :class="{ 'opacity-75': selectedBookmarks.includes(bookmark.id) }"
                />
              </div>
            </TransitionGroup>
          </div>

          <!-- Empty State -->
          <div
            v-if="!loading && (!displayedBookmarks || displayedBookmarks.length === 0)"
            class="flex flex-col items-center justify-center h-64 text-gray-500"
          >
            <Icon
              name="mdi:bookmark-outline"
              size="48"
            />
            <p class="mt-4 text-lg">No bookmarks found</p>
            <p class="text-sm">
              {{
                searchQuery ? 'Try a different search term' : 'Start by bookmarking some articles'
              }}
            </p>
          </div>
        </div>
      </div>
    </div>

    <PrimeDialog
      v-model:visible="showMoveModal"
      modal
      header="Move Bookmark"
      :style="{ width: '90vw', maxWidth: '500px' }"
    >
      <BookmarkFormMove
        :folders="folders"
        :selected-folder="currentFolder"
        @submit="(folder: Folder) => handleMoveSubmit(folder)"
        @cancel="showMoveModal = false"
      />
    </PrimeDialog>
  </div>
</template>

<style scoped>
@media (min-width: 768px) {
  :deep(.p-drawer) {
    position: relative;
    height: 100%;
    transform: none !important;
  }

  :deep(.p-drawer-mask) {
    display: none;
  }
}
</style>
</file>

<file path="apps/main-app/pages/profile/index.vue">
<template>
  <div> WIP</div>
</template>

<script setup lang="ts">
definePageMeta({
  layoutTransition: false,
  name: 'Profile',
})
</script>

<style scoped></style>
</file>

<file path="apps/main-app/pages/ask.vue">
<script setup lang="ts">
interface ChatAgent {
  id: number
  name: string
  features: string[]
  systemMessage: string
  enabled: boolean
  starterPrompts: string[]
}

interface Message {
  role: 'user' | 'assistant'
  content: string
}

const agents: ChatAgent[] = [
  {
    id: 1,
    name: 'Astronomy Communicator',
    features: [
      'Break down complex astronomy concepts',
      'Explain in an engaging, Carl Sagan-inspired style',
      'Make astronomy accessible to all',
    ],
    systemMessage:
      'You are an enthusiastic astronomy science communicator who can break down even the most complex topics into something easy to understand. Channel the spirit of Carl Sagan in your explanations, using vivid imagery and relatable analogies. Your goal is to inspire wonder and curiosity about the cosmos in every interaction.',
    enabled: true,
    starterPrompts: [
      'Can you explain black holes in a way that would captivate a 10-year-old?',
      "What's the most mind-blowing fact about our universe that you can share?",
      "How would you describe the concept of light-years to someone who's never heard of it before?",
    ],
  },
  {
    id: 2,
    name: 'Space Tech Analyst',
    features: [
      'Research astronomy and space tech companies',
      'Provide insights for job seekers and competitors',
      'Analyze company profiles and trends',
    ],
    systemMessage:
      'You are an astronomy and space tech company researcher. Your database contains information on numerous companies in the field. Your role is to answer questions about these companies, help users find potential employers, and perform competitor analysis. Provide detailed, factual information and insightful comparisons when asked.',
    enabled: true,
    starterPrompts: [
      'What are the top 3 companies currently leading in commercial space flight, and how do they compare?',
      "I'm an aerospace engineer looking for job opportunities. Which companies should I be watching?",
      'Can you provide a brief analysis of the current trends in the satellite industry?',
    ],
  },
  {
    id: 3,
    name: 'Space News Reporter',
    features: [
      'Report on latest astronomy and space news',
      'Provide expert analysis on recent developments',
      'Offer context and implications of news stories',
    ],
    systemMessage:
      'You are an expert news reporter specializing in astronomy and space news. Your knowledge is based on a constantly updated database of news articles. When asked, provide the latest developments in the field, offer expert analysis, and explain the significance of recent news stories. Your reporting should be accurate, engaging, and informative.',
    enabled: true,
    starterPrompts: [
      "What's the most significant space exploration news from the past week?",
      'Can you give me an update on the latest developments in the search for exoplanets?',
      'What are the potential implications of the most recent Mars rover discoveries?',
    ],
  },
  {
    id: 4,
    name: 'Astronomy Fact Generator',
    features: [
      'Share random, fascinating astronomy facts',
      'Cover a wide range of astronomical topics',
      'Provide brief, engaging explanations',
    ],
    systemMessage:
      'You are an astronomy fact generator. Your purpose is to share interesting and fun facts about astronomy and space. When prompted, randomly select a topic from your vast knowledge base and provide a fascinating fact along with a brief, engaging explanation. Your facts should spark curiosity and encourage further exploration of astronomical topics.',
    enabled: true,
    starterPrompts: [
      "Tell me an interesting fact about Saturn's rings.",
      'Share a mind-blowing fact about the scale of the universe.',
      "What's a surprising fact about stars that most people don't know?",
    ],
  },
  {
    id: 5,
    name: 'Research Assistant',
    features: [
      'Find relevant astronomy papers',
      'Summarize key findings',
      'Suggest related research',
    ],
    systemMessage:
      'You are a research assistant specializing in astronomy and astrophysics. Your role is to help users find relevant scientific papers, summarize key findings, and suggest related research. Provide concise, accurate information and guide users towards valuable resources in their area of interest.',
    enabled: false,
    starterPrompts: [
      'Can you find recent papers on dark matter detection methods?',
      'What are the key findings from the latest research on exoplanet atmospheres?',
      "I'm interested in radio astronomy. What are some fundamental papers I should read to get started?",
    ],
  },
  {
    id: 6,
    name: 'Space Station Life Simulator',
    features: [
      'Describe daily routines in space',
      'Explain space-specific challenges',
      'Simulate space station experiences',
    ],
    systemMessage:
      'You are a Space Station Life Simulator, an expert on daily life and challenges of living in space. Your role is to provide accurate, detailed, and engaging descriptions of life aboard a space station, drawing from real astronaut experiences and scientific knowledge.',
    enabled: true,
    starterPrompts: [
      "What's the most challenging aspect of personal hygiene in space?",
      "Describe a typical 'day' for an astronaut on the International Space Station.",
      'How do astronauts exercise in zero gravity, and why is it so important?',
    ],
  },
  {
    id: 7,
    name: 'Dark Matter & Energy Theorist',
    features: [
      'Explain current dark matter theories',
      'Discuss dark energy research',
      'Explore implications for the universe',
    ],
    systemMessage:
      'You are a Dark Matter & Energy Theorist, well-versed in current theories and research on these mysterious components of the universe. Your goal is to explain complex concepts in an understandable way, discuss ongoing research, and explore the implications for our understanding of the universe.',
    enabled: true,
    starterPrompts: [
      "What's the strongest evidence we have for the existence of dark matter?",
      'How does dark energy affect the expansion of the universe?',
      'What are some alternative theories to dark matter and dark energy?',
    ],
  },
  {
    id: 8,
    name: 'Rocket Science Explainer',
    features: [
      'Break down rocket propulsion basics',
      'Explain different types of rockets',
      'Discuss challenges in rocketry',
    ],
    systemMessage:
      'You are a Rocket Science Explainer, adept at breaking down the principles of rocketry and propulsion systems. Your role is to make complex rocket science concepts accessible to a general audience, explaining how rockets work and the challenges involved in space launch systems.',
    enabled: true,
    starterPrompts: [
      'Can you explain how a rocket generates thrust in simple terms?',
      'What are the main differences between liquid and solid fuel rockets?',
      "What's the concept behind reusable rockets, and why are they important?",
    ],
  },
  {
    id: 9,
    name: 'Astrobiology Specialist',
    features: [
      'Discuss potential for extraterrestrial life',
      'Explain habitable zone concepts',
      'Describe astrobiology research methods',
    ],
    systemMessage:
      'You are an Astrobiology Specialist, focusing on the potential for life in the universe and related research. Your role is to discuss the conditions necessary for life, explain current research in astrobiology, and explore the implications of potentially finding life beyond Earth.',
    enabled: true,
    starterPrompts: [
      'What are the key factors that make a planet potentially habitable?',
      'How do scientists search for signs of life on other planets?',
      'What would be the implications if we found microbial life on Mars?',
    ],
  },
  {
    id: 10,
    name: 'Cosmic Calendar Creator',
    features: [
      'Inform about upcoming astronomical events',
      'Explain significance of celestial phenomena',
      'Provide viewing tips for events',
    ],
    systemMessage:
      'You are a Cosmic Calendar Creator, an expert on upcoming astronomical events and phenomena. Your role is to inform users about interesting celestial events, explain their significance, and provide tips on how to best observe or appreciate these cosmic occurrences.',
    enabled: true,
    starterPrompts: [
      'What are the most exciting astronomical events coming up in the next month?',
      'Can you explain what causes a solar eclipse and when the next one will be visible?',
      'How can I best prepare to view the next meteor shower?',
    ],
  },
  {
    id: 11,
    name: 'Astrophotography Coach',
    features: [
      'Offer tips for capturing celestial images',
      'Explain astrophotography equipment',
      'Provide post-processing guidance',
    ],
    systemMessage:
      'You are an Astrophotography Coach, skilled in the art and science of capturing stunning astronomical images. Your role is to offer tips and techniques for astrophotography, explain equipment choices, and provide guidance on image processing to help users create beautiful cosmic photographs.',
    enabled: true,
    starterPrompts: [
      "What's the best way to start astrophotography on a budget?",
      'Can you explain the technique of stacking in astrophotography?',
      'What settings should I use to photograph the Milky Way?',
    ],
  },
  {
    id: 12,
    name: 'Space Mission Planner',
    features: [
      'Explain space mission planning stages',
      'Discuss challenges in space exploration',
      'Describe different types of space missions',
    ],
    systemMessage:
      'You are a Space Mission Planner, an expert in the complexities of planning and executing space missions. Your role is to help users understand the various stages of mission planning, the challenges involved, and the different types of missions undertaken in space exploration.',
    enabled: true,
    starterPrompts: [
      'What are the key stages in planning a mission to Mars?',
      'How do space agencies choose landing sites for planetary missions?',
      'What are the main challenges in planning a long-duration space mission?',
    ],
  },
  {
    id: 13,
    name: 'Cosmic Scale Visualizer',
    features: [
      'Provide comparisons for cosmic scales',
      'Explain distances in space',
      'Visualize sizes of celestial objects',
    ],
    systemMessage:
      'You are a Cosmic Scale Visualizer, adept at helping users comprehend the vast distances and sizes in the universe. Your role is to provide relatable comparisons, explain cosmic distances in understandable terms, and help visualize the scale of celestial objects and cosmic structures.',
    enabled: true,
    starterPrompts: [
      'Can you explain the size of our solar system using a relatable analogy?',
      'How can we visualize the distance to the nearest star beyond our Sun?',
      "What's a good way to understand the scale of the Milky Way galaxy?",
    ],
  },
]

const chatStore = useChatStore()

definePageMeta({ name: 'Q&A' })

const selectedAgent = ref(null as ChatAgent | null)
const message = ref('')
const conversation = ref<Message[]>([])
const selectedStarterPrompts = ref([] as string[])

const selectAgent = (agent: ChatAgent) => {
  if (agent.enabled) {
    selectedAgent.value = selectedAgent.value?.id === agent.id ? null : agent
    selectedStarterPrompts.value = selectedAgent.value?.starterPrompts || []
    conversation.value = []
  }
}

const closeAgent = () => {
  selectedAgent.value = null
  selectedStarterPrompts.value = []
  conversation.value = []
}

const selectPrompt = (prompt: string) => {
  message.value = prompt
  selectedStarterPrompts.value = []
}

const responsiveOptions = ref([
  {
    breakpoint: '1199px',
    numVisible: 3,
    numScroll: 3,
  },
  {
    breakpoint: '991px',
    numVisible: 2,
    numScroll: 2,
  },
  {
    breakpoint: '767px',
    numVisible: 1,
    numScroll: 1,
  },
])
</script>

<template>
  <div class="flex h-[calc(100vh-32px)] flex-col">
    <div
      class="mx-auto grid h-full max-w-[1000px] grid-cols-1 overflow-scroll p-4 md:grid-cols-[1fr_minmax(200px,700px)_1fr]"
    >
      <div class="w-full md:col-span-3 md:col-start-1 md:row-start-1">
        <div class="space-y-2 pb-6 text-center">
          <h1 class="text-5xl font-semibold"> Galactic Guide </h1>
          <div class="flex gap-2 pt-2">
            <PrimeMessage
              severity="info"
              class="flex w-full justify-center"
            >
              3 question limit per 30 min
            </PrimeMessage>
            <PrimeMessage
              severity="warn"
              class="flex w-full justify-center"
            >
              Always validate answers.
            </PrimeMessage>
          </div>
        </div>
        <PrimeCarousel
          :value="agents"
          :num-visible="3"
          :num-scroll="3"
          :responsive-options="responsiveOptions"
        >
          <template #item="slotProps">
            <div
              class="m-2 rounded border border-color p-4"
              :class="{
                'cursor-pointer transition-shadow hover:shadow-lg': slotProps.data.enabled,
                'opacity-50': !slotProps.data.enabled,
              }"
              @click="slotProps.data.enabled && selectAgent(slotProps.data)"
            >
              <div class="mb-4 font-medium">
                {{ slotProps.data.name }}
              </div>
              <div class="mb-4">
                <ul class="list-disc pl-5">
                  <li
                    v-for="feature in slotProps.data.features"
                    :key="feature"
                    class="text-sm"
                  >
                    {{ feature }}
                  </li>
                </ul>
              </div>
              <div class="flex items-center justify-between">
                <PrimeTag
                  :value="slotProps.data.enabled ? 'Enabled' : 'Disabled'"
                  :severity="slotProps.data.enabled ? 'success' : 'danger'"
                />

                <PrimeTag
                  v-if="selectedAgent?.id === slotProps.data.id"
                  value="Selected"
                  severity="info"
                />
              </div>
            </div>
          </template>
        </PrimeCarousel>
      </div>
      <div
        class="mx-auto flex h-full w-full flex-col justify-between gap-4 md:col-start-2 md:row-start-2 xl:gap-8"
      >
        <div
          v-if="chatStore.messages.length"
          class="space-y-4 pb-4 xl:space-y-8 xl:pb-8"
        >
          <div
            v-for="(msg, index) in chatStore.messages"
            :key="index"
            :class="msg.role"
          >
            <p class="pb-2 pl-2">
              <strong class="pb-4">{{ msg.role === 'user' ? 'You' : 'Assistant' }}</strong>
            </p>
            <div class="w-full rounded-md bg-primary-950 p-4 text-surface-300">
              <MDC
                :value="msg.content"
                class="prose prose-invert"
              />
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Fixed Bottom Bar -->

    <div class="foreground border-color flex-shrink-0 border-t p-4">
      <div class="mx-auto max-w-[600px]">
        <div
          v-if="selectedStarterPrompts.length"
          class="space-y-2 pb-2"
        >
          <div class="flex justify-center items-center">
            <p class="text-center flex-grow font-semibold"> Example Questions </p>
            <PrimeButton
              severity="secondary"
              class="text-end ml-auto text-white font-semibold"
              @click="closeAgent"
            >
              X
            </PrimeButton>
          </div>
          <PrimeButton
            v-for="prompt in selectedStarterPrompts"
            :key="prompt"
            severity="secondary"
            outlined
            class="mb-2 mr-2 flex w-full items-start justify-start text-left"
            @click="selectPrompt(prompt)"
          >
            {{ prompt }}
          </PrimeButton>
        </div>
        <SearchBar
          :selected-prompt="message"
          :system-prompt="selectedAgent?.systemMessage"
        />
      </div>
    </div>
  </div>
</template>

<style scoped></style>
</file>

<file path="apps/main-app/pages/auth-callback.vue">
// pages/auth-callback.vue
<template>
  <div class="w-full h-full flex justify-center items-center">Authenticating...</div>
</template>

<script setup lang="ts">
import { useRoute, useRouter } from 'vue-router'
import { useSupabaseClient } from '#imports'

const route = useRoute()
const router = useRouter()
const supabase = useSupabaseClient()

const isProcessing = ref(false)

const handleAuth = async () => {
  if (isProcessing.value) return
  isProcessing.value = true

  const code = route.query.code as string

  if (!code) {
    console.error('No code found in URL')
    router.push('/login')
    return
  }

  try {
    const { data, error } = await supabase.auth.getSession()

    if (error) throw error

    if (data.session) {
      console.log('Session established:', data.session)
      router.push('/')
    } else {
      throw new Error('No session established')
    }
  } catch (error) {
    console.error('Error during authentication:', error)
    router.push('/login')
  } finally {
    isProcessing.value = false
  }
}

onMounted(() => {
  handleAuth()
})
</script>
</file>

<file path="apps/main-app/pages/companies.vue">
<script setup lang="ts">
const domainKey = 'companies'
const { store, loadMore } = await useSelectData<Companies>('companies', {
  columns:
    'id, name, description, logo_url, url, scrape_frequency, founding_year, created_at, updated_at, is_government, category_id, social_media_id, scrape_rating, content_status, scraped_at, keywords',
  filters: { content_status: { eq: 'draft' } },
  orderBy: { column: 'created_at', ascending: false },
  initialFetch: true,
  pagination: { page: 1, limit: 20 },
})

const { items: companies } = storeToRefs(store)

const loading = useLoadingStore()
const isLoading = computed(() => loading.isLoading(domainKey))

definePageMeta({ name: 'Companies' })
</script>

<template>
  <div>
    <IBInfiniteScroll @update:scroll-end="loadMore">
      <div class="grid grid-cols-1 md:grid-cols-[1fr_minmax(200px,480px)_1fr]">
        <div class="mx-auto flex w-full max-w-sm flex-col md:col-start-2">
          <CompanyCard
            v-for="(company, i) in companies"
            :key="`companies-post-${i}`"
            :company="company"
          />
          <CompanyCardSkeleton v-show="isLoading" />
        </div>
        <IBAdvertisement />
      </div>
    </IBInfiniteScroll>
  </div>
</template>
</file>

<file path="apps/main-app/pages/database-testing.vue">
<template>
  <div>
    <DatabaseTester />
  </div>
</template>

<script setup lang="ts"></script>

<style scoped></style>
</file>

<file path="apps/main-app/pages/events.vue">
<script setup lang="ts">
const domainKey = 'events'
const eventsStore = useEventsStore()
const { events } = storeToRefs(eventsStore)

const haveEvents = computed(() => events.value !== null && events.value.length > 0)

const fetchInput = ref({
  domainKey,
  endpoint: '/api/events/select/cards',
  criteria: {
    dto: 'select:events:card',
  },
}) as Ref<FetchInput>

watchEffect(() => {
  if (haveEvents.value === false) {
    console.log('Fetching events')
    eventsStore.loadEvents(fetchInput.value)
  }
})

const loading = useLoadingStore()
const isLoading = computed(() => loading.isLoading(domainKey))

definePageMeta({ name: 'Events' })
</script>

<template>
  <div>
    <IBInfiniteScroll
      :domain-key="domainKey"
      :pagination="{
        page: 1,
        limit: 20,
      }"
      @update:scroll-end="eventsStore.loadEvents(fetchInput)"
    >
      <div
        v-if="haveEvents"
        class="grid grid-cols-1 md:grid-cols-2 md:gap-4 lg:grid-cols-3 xl:grid-cols-4 xl:gap-8"
      >
        <EventCard
          v-for="(event, i) in events"
          :key="`events-post-${i}`"
          :events="event"
        />
      </div>
      <div
        v-else
        class="grid grid-cols-1 md:grid-cols-2 md:gap-4 lg:grid-cols-3 2xl:grid-cols-4 2xl:gap-8"
      >
        <div class="foreground space-y-1 rounded-md p-8 shadow-md">
          <h3 class="pb-4 text-xl font-semibold"> No events to show, check back soon. </h3>
          <p>
            We have regularly scheduled events and are in the process of getting this page working.
          </p>
        </div>
      </div>
    </IBInfiniteScroll>
  </div>
</template>
</file>

<file path="apps/main-app/pages/index.vue">
<script setup lang="ts">
definePageMeta({
  name: 'AstroTribe',
})

const userStore = useCurrentUser()
const { profile } = storeToRefs(userStore)

const comingSoon = [
  'Adding all major companies',
  'Adding all major news sources',
  'Improving the quality of news/company data',
  'AI generated Weekly/Monthly newsletter',
]
</script>

<template>
  <div
    class="grid w-full grid-cols-1 gap-4 p-0 md:grid-cols-2 md:p-4 lg:grid-cols-3 xl:gap-8 xl:p-8"
  >
    <PrimeCard
      class="border-color border"
      :pt="{ body: 'justify-between h-full' }"
      :pt-options="{ mergeProps: true, mergeSections: true }"
    >
      <template #content>
        <h1 class="pb-4 text-2xl font-semibold"> Welcome {{ profile?.given_name ?? '' }} 👋 </h1>
        <h3 class="text-primary-600 pb-4 text-lg font-semibold">
          AstroTribe Is Currently In Open Alpha
        </h3>
        <p>
          This means we have limited functionality for now, but be sure to check back often as we
          will roll out new features regularly!
        </p>
      </template>
    </PrimeCard>
    <PrimeCard class="border-color border">
      <template #content>
        <div class="space-y-4">
          <h3 class="text-xl font-semibold"> Latest News </h3>
          <p class="text-base text-slate-200">
            Stay current with leading government space agencies and private sector companies from
            around the globe.
          </p>
        </div>
      </template>
      <template #footer>
        <NuxtLink to="/news">
          <PrimeButton outlined> Explore Now </PrimeButton>
        </NuxtLink>
      </template>
    </PrimeCard>
    <!-- <PrimeCard
      class="border-color border"
      :pt="{ body: 'justify-between h-full' }"
      :pt-options="{ mergeProps: true, mergeSections: true }"
    >
      <template #content>
        <div class="space-y-4">
          <h3 class="text-xl font-semibold"> Companies </h3>
          <p class="text-base text-slate-200">
            Follow the companies that will take us to the Moon, Mars, and beyond. India is our first
            focus, then we go global!
          </p>
        </div>
      </template>
      <template #footer>
        <NuxtLink to="/companies">
          <PrimeButton outlined> Search Companies </PrimeButton>
        </NuxtLink>
      </template>
    </PrimeCard> -->

    <div class="row-span-2 space-y-4 md:col-start-2 md:row-start-1 lg:col-start-3">
      <PrimeMessage severity="info"> What we're working on </PrimeMessage>
      <ul>
        <li
          v-for="item in comingSoon"
          :key="item"
          class="py-2"
        >
          <Icon
            name="mdi:chevron-right"
            size="16px"
            class="text-primary-500"
          />
          <span class="pl-2">{{ item }}</span>
        </li>
      </ul>
      <IBFeedback cta="Have an idea? We would love to hear it!" />
    </div>
  </div>
</template>

<style scoped></style>
</file>

<file path="apps/main-app/pages/offline.vue">
<template>
  <div class="flex flex-col items-center justify-center p-4 h-full">
    <div class="max-w-md w-full text-center space-y-6">
      <div class="flex justify-center">
        <Icon
          name="material-symbols:wifi-off"
          class="w-20 h-20"
        />
      </div>

      <h1 class="text-3xl font-bold"> No Internet Connection </h1>

      <div class="space-y-4">
        <p class="">
          The page you're trying to access requires an internet connection. Please check your
          connection and try again.
        </p>

        <Button
          class="inline-flex items-center px-4 py-2 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
          @click="reload"
        >
          Try Again
        </Button>
      </div>

      <div class="text-sm">
        <p>Some features may still be available offline</p>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
const { $isOffline } = useNuxtApp()

// Watch for online status changes
watch($isOffline, (offline) => {
  if (!offline) {
    // Optionally reload when connection is restored
    window.location.reload()
  }
})

const reload = () => {
  window.location.reload()
}
</script>
</file>

<file path="apps/main-app/pages/onboarding.vue">
<template>
  <div class="p-4">
    <h1 class="mb-4 text-3xl font-bold"> Complete Your Profile </h1>
    <PrimeStepper
      v-model:value="activeStep"
      linear
    >
      <PrimeStepList>
        <PrimeStep value="1"> Personal Info </PrimeStep>
        <PrimeStep value="2"> Professional Info </PrimeStep>
        <PrimeStep value="3"> Interests </PrimeStep>
      </PrimeStepList>
      <PrimeStepPanels>
        <PrimeStepPanel value="1">
          <OnboardingAccount @next="nextStep" />
        </PrimeStepPanel>
        <PrimeStepPanel value="2">
          <OnboardingProfessional
            @next="nextStep"
            @prev="prevStep"
          />
        </PrimeStepPanel>
        <PrimeStepPanel value="3">
          <OnboardingInterests
            @prev="prevStep"
            @submit="handleSubmit"
          />
        </PrimeStepPanel>
      </PrimeStepPanels>
    </PrimeStepper>
  </div>
</template>

<script setup lang="ts">
const activeStep = ref('1')
const { form } = useOnboarding()

const nextStep = () => {
  activeStep.value = String(Number(activeStep.value) + 1)
}

const prevStep = () => {
  activeStep.value = String(Number(activeStep.value) - 1)
}

const handleSubmit = () => {
  console.log('Form submitted:', form)
  // You can add your API call here
}
</script>
</file>

<file path="apps/main-app/pages/research.vue">
<script setup lang="ts">
const researchStore = useResearchStore()
const domainKey = 'research'

const { research } = storeToRefs(researchStore)
const haveResearch = computed(() => research.value !== null && research.value.length > 0)

const fetchInput = ref({
  domainKey,
  endpoint: '/api/research/select/cards',
  criteria: {
    dto: 'select:research:card',
  },
})

watchEffect(() => {
  if (haveResearch.value === false) {
    console.log('Fetching research')
    researchStore.loadResearch(fetchInput.value)
  }
})

console.log('research', research)

definePageMeta({
  name: 'Research',
})
</script>

<template>
  <div class="relative flex h-full w-full flex-col">
    <!-- <SummaryLevel /> -->
    <IBInfiniteScroll
      :domain-key="domainKey"
      :pagination="{
        page: 1,
        limit: 20,
      }"
      @update:scroll-end="researchStore.loadResearch('select:venue:card')"
    >
      <div class="mx-auto grid grid-cols-1 md:grid-cols-2 md:gap-4 xl:grid-cols-3 xl:gap-8">
        <ResearchCard
          v-for="(item, index) in research"
          :key="`research-post-${index}`"
          :research="item"
        />
      </div>
    </IBInfiniteScroll>
  </div>
</template>
</file>

<file path="apps/main-app/plugins/formbricks.client.ts">
import formbricks from '@formbricks/js'

export default defineNuxtPlugin((nuxtApp) => {
  const { formbricksHost, formbricksEnvironment } = nuxtApp.$config.public

  if (typeof window !== 'undefined') {
    formbricks.init({
      environmentId: formbricksEnvironment,
      apiHost: formbricksHost,
    })
  }

  console.log('Formbricks initialized', formbricks)
  // Make formbricks available throughout the app
  nuxtApp.provide('formbricks', formbricks)

  // Register route change handler
  nuxtApp.hook('page:finish', () => {
    if (typeof formbricks !== 'undefined') {
      formbricks.registerRouteChange()
    }
  })
})
</file>

<file path="apps/main-app/plugins/pwa.client.ts">
export default defineNuxtPlugin(() => {
  const notification = useNotification()
  const isOffline = ref(!navigator.onLine)
  const { $pwa } = useNuxtApp()

  if (import.meta.dev && import.meta.client) {
    console.log('Development mode: Cleaning up service workers...')

    if ('serviceWorker' in navigator) {
      navigator.serviceWorker
        .getRegistrations()
        .then((registrations) => {
          registrations.forEach((registration) => {
            registration.unregister()
            console.log('Service worker unregistered:', registration.scope)
          })
        })
        .catch((error) => {
          console.error('Service worker cleanup failed:', error)
        })
    }
  }

  if (import.meta.client) {
    // Handle online/offline status
    window.addEventListener('online', () => {
      isOffline.value = false
      notification.success({
        summary: 'Connection Restored',
        message: 'Your internet connection has been restored',
      })
    })

    window.addEventListener('offline', () => {
      isOffline.value = true
      notification.warn({
        summary: 'Offline Mode',
        message: 'You are currently offline. Some features may be limited',
      })
    })

    // PWA functionality
    if ($pwa) {
      // Handle offline ready
      watch(
        () => $pwa.offlineReady.value,
        (ready) => {
          if (ready) {
            notification.success({
              summary: 'App Ready',
              message: 'Content has been cached for offline use',
            })
          }
        },
      )

      // Handle updates
      watch(
        () => $pwa.needRefresh.value,
        (needRefresh) => {
          if (needRefresh) {
            notification.info({
              summary: 'Update Available',
              message: 'Click here to update to the latest version',
            })
          }
        },
      )
    }
  }

  return {
    provide: {
      isOffline: readonly(isOffline),
    },
  }
})
</file>

<file path="apps/main-app/server/api/ai/ask.ts">
import { useLogger } from '@ib/logger'
import { openAI } from '~/server/utils/openai/callOpenAI'
import { serverSupabaseUser } from '#supabase/server'

const log = useLogger('API:ASK')

export default defineEventHandler({
  onRequest: [rateLimiter],
  onBeforeResponse: [],
  handler: async (event) => {
    const { messages } = await readBody(event)

    if (!Array.isArray(messages) || messages.length === 0) {
      return {
        statusCode: 400,
        error: {
          message: 'messages must be a non-empty array',
        },
      }
    }

    const isValidMessage = (msg) =>
      msg &&
      typeof msg === 'object' &&
      ['system', 'user', 'assistant'].includes(msg.role) &&
      typeof msg.content === 'string'

    if (!messages.every(isValidMessage)) {
      return {
        statusCode: 400,
        error: {
          message: 'Invalid message format',
        },
      }
    }

    console.log('messages', messages)

    try {
      const user = await serverSupabaseUser(event)
      let chatCompletion

      const plan = user?.app_metadata?.plan

      if (plan === 'free') {
        console.log('getGroqChatCompletion')
        chatCompletion = await getGroqChatCompletion(messages)
      } else if (plan === 'pro' || plan === 'expert') {
        console.log('openAI.createChatCompletion')
        chatCompletion = openAI.createChatCompletion(messages)
      } else {
        log.warn('no user plan', plan)
      }

      return {
        error: null,
        statusCode: 200,
        data: chatCompletion || '',
      }
    } catch (error) {
      log.error('error', error)
      return {
        data: null,
        error,
        statusCode: 500,
      }
    }
  },
})
</file>

<file path="apps/main-app/server/api/bookmarks/[id].delete.ts">
import { serverSupabaseUser, serverSupabaseClient } from '#supabase/server'

// server/api/bookmarks/[id].delete.ts
export default defineEventHandler(async (event) => {
  const user = await serverSupabaseUser(event)
  const bookmarkId = event.context.params.id

  if (!user) {
    throw createError({
      statusCode: 401,
      message: 'Unauthorized',
    })
  }

  const supabase = await serverSupabaseClient(event)

  const { error } = await supabase
    .from('bookmarks')
    .delete()
    .eq('id', bookmarkId)
    .eq('user_id', user.id)

  if (error) {
    throw createError({
      statusCode: 500,
      message: 'Failed to delete bookmark',
    })
  }

  return { success: true }
})
</file>

<file path="apps/main-app/server/api/bookmarks/index.ts">
import { serverSupabaseUser, serverSupabaseClient } from '#supabase/server'

// server/api/bookmarks/index.ts
export default defineEventHandler(async (event) => {
  try {
    const { content_type = 'news', folder_id = null, include_subfolders = false } = getQuery(event)
    const user = await serverSupabaseUser(event)
    const supabase = await serverSupabaseClient(event)

    if (!user) {
      throw createError({
        statusCode: 401,
        message: 'Unauthorized',
      })
    }

    // Simplify the query first to debug
    let query = supabase
      .from('bookmarks')
      .select(
        `
          *,
          folder:folder_id (
            id,
            name,
            color,
            path,
            is_favorite
          )
        `,
      )
      .eq('user_id', user.id)
      .eq('content_type', content_type)

    if (folder_id) {
      if (include_subfolders) {
        const { data: folderPath } = await supabase
          .from('bookmark_folders')
          .select('path')
          .eq('id', folder_id)
          .single()

        if (folderPath) {
          const { data: subFolders } = await supabase
            .from('bookmark_folders')
            .select('id')
            .eq('user_id', user.id)
            .like('path', `${folderPath.path}%`)

          const folderIds = subFolders?.map((f) => f.id) || []
          query = query.in('folder_id', [folder_id, ...folderIds])
        }
      } else {
        query = query.eq('folder_id', folder_id)
      }
    }

    const { data, error } = await query

    if (error) {
      console.error('Supabase query error:', error)
      throw createError({
        statusCode: 500,
        message: error.message,
      })
    }

    // If we got the bookmarks, now get the news content
    if (data && data.length > 0) {
      const contentIds = data.map((b) => b.content_id)
      const { data: newsData, error: newsError } = await supabase
        .from('news')
        .select('*')
        .in('id', contentIds)

      if (newsError) {
        console.error('News fetch error:', newsError)
        throw createError({
          statusCode: 500,
          message: newsError.message,
        })
      }

      // Merge the news data with bookmarks
      const enrichedBookmarks = data.map((bookmark) => {
        const newsItem = newsData?.find((n) => n.id === bookmark.content_id)
        return {
          ...bookmark,
          news: newsItem,
        }
      })

      return { data: enrichedBookmarks }
    }

    return { data: data || [] }
  } catch (error) {
    console.error('Error in bookmark endpoint:', error)
    throw error
  }
})
</file>

<file path="apps/main-app/server/api/bookmarks/move.patch.ts">
import { serverSupabaseUser, serverSupabaseClient } from '#supabase/server'

export default defineEventHandler(async (event: H3Event) => {
  const user = await serverSupabaseUser(event)

  if (!user) {
    return createError({
      status: 401,
      message: 'Unauthorized',
    })
  }

  const supabase = await serverSupabaseClient(event)
  const { bookmarkIds, targetFolderId } = await readBody(event)

  return await supabase
    .from('bookmarks')
    .update({ folder_id: targetFolderId })
    .in('id', bookmarkIds)
    .eq('user_id', user.id)
})
</file>

<file path="apps/main-app/server/api/bookmarks/toggle.ts">
import { serverSupabaseUser, serverSupabaseClient } from '#supabase/server'

export default defineEventHandler(async (event) => {
  const body = await readBody(event)
  const user = await serverSupabaseUser(event)
  const { content_id, content_type, metadata } = body

  if (!user) {
    return createError({
      status: 401,
      message: 'Unauthorized',
    })
  }

  const supabase = await serverSupabaseClient(event)

  // Check if bookmark exists
  const { data: existing } = await supabase
    .from('bookmarks')
    .select('id')
    .eq('user_id', user.id)
    .eq('content_id', content_id)
    .eq('content_type', content_type)
    .maybeSingle()

  if (existing) {
    // Remove bookmark
    const { error: deleteError } = await supabase
      .from('bookmarks')
      .delete()
      .match({ id: existing.id })

    if (deleteError) {
      throw createError({
        statusCode: 500,
        message: 'Failed to remove bookmark',
      })
    }

    return {
      bookmarked: false,
    }
  }

  // Get default folder if needed
  let folder_id = null
  const { data: defaultFolder } = await supabase
    .from('bookmark_folders')
    .select('id')
    .eq('user_id', user.id)
    .eq('is_default', true)
    .single()

  if (defaultFolder) {
    folder_id = defaultFolder.id
  }

  // Create new bookmark
  const { data: newBookmark, error: bookError } = await supabase
    .from('bookmarks')
    .insert({
      user_id: user.id,
      content_id,
      content_type,
      folder_id,
      metadata: {
        ...metadata,
        bookmarked_at: new Date().toISOString(),
      },
    })
    .select()
    .single()

  if (bookError) {
    throw createError({
      statusCode: 500,
      message: 'Failed to create bookmark',
    })
  }

  return {
    bookmarked: true,
    data: newBookmark,
  }
})
</file>

<file path="apps/main-app/server/api/folders/[id].delete.ts">
// server/api/folders/[id].delete.ts
import type { H3Event } from 'h3'
import { serverSupabaseUser, serverSupabaseClient } from '#supabase/server'

export default defineEventHandler(async (event: H3Event) => {
  try {
    const user = await serverSupabaseUser(event)
    if (!user) {
      throw createError({ statusCode: 401, message: 'Unauthorized' })
    }

    const supabase = await serverSupabaseClient(event)
    const id = event.context.params.id

    // Check if this is the default folder
    const { data: folder } = await supabase
      .from('bookmark_folders')
      .select('is_default')
      .eq('id', id)
      .single()

    if (folder?.is_default) {
      throw createError({
        statusCode: 400,
        message: 'Cannot delete the default folder',
      })
    }

    // Delete the folder
    const { error } = await supabase
      .from('bookmark_folders')
      .delete()
      .eq('id', id)
      .eq('user_id', user.id)

    if (error) throw error
    return { success: true }
  } catch (err) {
    console.error('Folder Delete Error:', err)
    throw createError({
      statusCode: err.statusCode || 500,
      message: err.message || 'Internal server error',
    })
  }
})
</file>

<file path="apps/main-app/server/api/folders/[id].patch.ts">
// server/api/folders/[id].patch.ts
import type { H3Event } from 'h3'
import { serverSupabaseUser, serverSupabaseClient } from '#supabase/server'

export default defineEventHandler(async (event: H3Event) => {
  try {
    const user = await serverSupabaseUser(event)
    if (!user) {
      throw createError({ statusCode: 401, message: 'Unauthorized' })
    }

    const supabase = await serverSupabaseClient(event)
    const id = event.context.params.id
    const updates = await readBody(event)

    // Validate updates
    if (updates.name !== undefined && !updates.name.trim()) {
      throw createError({
        statusCode: 400,
        message: 'Folder name cannot be empty',
      })
    }

    const { data, error } = await supabase
      .from('bookmark_folders')
      .update(updates)
      .eq('id', id)
      .eq('user_id', user.id)
      .select()
      .single()

    if (error) throw error
    return { data }
  } catch (err) {
    console.error('Folder Update Error:', err)
    throw createError({
      statusCode: err.statusCode || 500,
      message: err.message || 'Internal server error',
    })
  }
})
</file>

<file path="apps/main-app/server/api/folders/index.ts">
// server/api/folders/index.ts
import type { H3Event } from 'h3'
import { serverSupabaseUser, serverSupabaseClient } from '#supabase/server'

export default defineEventHandler(async (event: H3Event) => {
  try {
    const user = await serverSupabaseUser(event)
    if (!user) {
      throw createError({ statusCode: 401, message: 'Unauthorized' })
    }

    const supabase = await serverSupabaseClient(event)

    // GET /api/folders
    if (event.method === 'GET') {
      const { data, error } = await supabase
        .from('bookmark_folders')
        .select('*')
        .eq('user_id', user.id)
        .order('position')

      if (error) throw error
      return { data }
    }

    // POST /api/folders
    if (event.method === 'POST') {
      const body = await readBody(event)

      // Validate required fields
      if (!body.name?.trim()) {
        throw createError({
          statusCode: 400,
          message: 'Folder name is required',
        })
      }

      // Get current folder count
      const { count } = await supabase
        .from('bookmark_folders')
        .select('*', { count: 'exact' })
        .eq('user_id', user.id)

      // Validate feature limit
      await validateFeatureLimit(event, 'BOOKMARK_FOLDERS', count || 0)

      // Insert new folder
      const { data, error: insertError } = await supabase
        .from('bookmark_folders')
        .insert({
          ...body,
          user_id: user.id,
          position: count || 0,
        })
        .select()
        .single()

      if (insertError) throw insertError
      return { data }
    }

    throw createError({ statusCode: 405, message: 'Method not allowed' })
  } catch (err) {
    console.error('Folder API Error:', err)
    throw createError({
      statusCode: err.statusCode || 500,
      message: err.message || 'Internal server error',
    })
  }
})
</file>

<file path="apps/main-app/server/api/payment/[provider]/create-order.ts">
// server/api/payment/[provider]/create-order.post.ts
import { useRuntimeConfig } from '#imports'
import { generateServerToken } from '~/server/utils/generateServerToken'

export default defineEventHandler(async (event) => {
  const provider = getRouterParam(event, 'provider')
  const body = await readBody(event)
  const config = useRuntimeConfig().public

  console.log('provider:', provider)

  let backendUrl = config.scraperUrl
  if (provider === 'razorpay') {
    console.log('provider is razorpay')
    backendUrl = backendUrl.concat('/api/customer/subscription/create')
  } else if (provider === 'stripe') {
    backendUrl = backendUrl.concat('/api/customer/subscription/create')
  } else {
    throw createError({
      statusCode: 400,
      statusMessage: 'Invalid payment provider',
    })
  }

  console.log('backendUrl:', backendUrl)

  const token = generateServerToken()

  try {
    const response = await $fetch(backendUrl, {
      method: 'POST',
      body,
      headers: {
        Authorization: `Bearer ${token}`,
      },
    })

    return response
  } catch (error) {
    console.error(`Error creating order with ${provider}:`, error)
    throw createError({
      statusCode: 500,
      statusMessage: `Failed to create order with ${provider}`,
    })
  }
})
</file>

<file path="apps/main-app/server/api/payment/[provider]/subscription.get.ts">
import { useRuntimeConfig } from '#imports'
import { generateServerToken } from '~/server/utils/generateServerToken'

export default defineEventHandler(async (event) => {
  const provider = getRouterParam(event, 'provider')
  const config = useRuntimeConfig().public

  const backendUrl = config.scraperUrl
  if (provider === 'razorpay') {
    backendUrl.concat('/api/customer/subscription')
  } else if (provider === 'stripe') {
    backendUrl.concat('/api/customer/subscription')
  } else {
    throw createError({
      statusCode: 400,
      statusMessage: 'Invalid payment provider',
    })
  }

  const token = generateServerToken()

  try {
    const response = await $fetch(backendUrl, {
      headers: {
        Authorization: `Bearer ${token}`,
      },
    })
    return response
  } catch (error) {
    console.error(`Error fetching subscription from ${provider}:`, error)
    throw createError({
      statusCode: 500,
      statusMessage: `Failed to fetch subscription from ${provider}`,
    })
  }
})
</file>

<file path="apps/main-app/server/api/payment/[provider]/verify-payment.post.ts">
// server/api/payment/[provider]/verify-payment.post.ts
import { useRuntimeConfig } from '#imports'
import { generateServerToken } from '~/server/utils/generateServerToken'

export default defineEventHandler(async (event) => {
  const provider = getRouterParam(event, 'provider')
  const body = await readBody(event)
  const config = useRuntimeConfig().public

  const backendUrl = config.scraperUrl
  if (provider === 'razorpay') {
    backendUrl.concat('/api/customer/subscription/verify-payment')
  } else if (provider === 'stripe') {
    backendUrl.concat('/api/customer/subscription/verify-payment')
  } else {
    throw createError({
      statusCode: 400,
      statusMessage: 'Invalid payment provider',
    })
  }

  const token = generateServerToken()

  try {
    const response = await $fetch(backendUrl, {
      method: 'POST',
      body,
      headers: {
        Authorization: `Bearer ${token}`,
      },
    })
    return response
  } catch (error) {
    console.error(`Error verifying payment with ${provider}:`, error)
    throw createError({
      statusCode: 500,
      statusMessage: `Failed to verify payment with ${provider}`,
    })
  }
})
</file>

<file path="apps/main-app/server/api/users/update.post.ts">
import { serverSupabaseClient } from '#supabase/server'

export default defineEventHandler(async (event) => {
  try {
    const body = await readBody(event)

    const supabase = await serverSupabaseClient(event)

    const { data } = await supabase.auth.getUser()
    const { user } = data

    if (user && user.email) {
      const response = await supabase.from('user_profiles').update(body).eq('id', user.id)

      if (response.error) {
        return {
          error: response.error,
          data: [],
          status: 500,
          message: 'Error Updating User',
        }
      } else {
        return {
          error: null,
          data: [],
          status: 200,
          message: 'User Updated',
        }
      }
    }

    return {
      error: null,
      data: [],
      status: 500,
      message: 'Something went wrong',
    }
  } catch (error) {
    return {
      error,
      data: [],
      status: 500,
      message: 'Error',
    }
  }
})
</file>

<file path="apps/main-app/server/api/votes/[contentType]/[id].get.ts">
import { serverSupabaseClient, serverSupabaseUser } from '#supabase/server'

export default defineEventHandler(async (event) => {
  const client = await serverSupabaseClient(event)
  const user = await serverSupabaseUser(event)

  if (!user) {
    throw createError({
      statusCode: 401,
      message: 'Unauthorized',
    })
  }

  const { contentType, id } = event.context.params

  try {
    const { data, error } = await client
      .from('votes')
      .select('vote_type')
      .match({
        content_type: contentType,
        content_id: id,
        user_id: user.id,
      })
      .single()

    if (error && error.code !== 'PGRST116') throw error

    return {
      voteType: data?.vote_type || null,
    }
  } catch (error) {
    console.error('Get vote error:', error)
    throw createError({
      statusCode: 500,
      message: 'Failed to get vote status',
    })
  }
})
</file>

<file path="apps/main-app/server/api/votes/[contentType]/[id].post.ts">
import { serverSupabaseClient, serverSupabaseUser } from '#supabase/server'

export default defineEventHandler(async (event) => {
  const client = await serverSupabaseClient(event)
  const user = await serverSupabaseUser(event)

  if (!user) {
    throw createError({
      statusCode: 401,
      message: 'Unauthorized',
    })
  }

  const { contentType, id } = event.context.params
  const { voteType } = await readBody(event)

  // Validate content type (only news for now)
  if (contentType !== 'news') {
    throw createError({
      statusCode: 400,
      message: 'Invalid content type',
    })
  }

  // Validate vote type
  if (![1, -1].includes(voteType)) {
    throw createError({
      statusCode: 400,
      message: 'Invalid vote type',
    })
  }

  try {
    // Handle vote removal if same vote type is sent
    const { data: existingVote } = await client
      .from('votes')
      .select('vote_type')
      .match({
        content_type: contentType,
        content_id: id,
        user_id: user.id,
      })
      .single()

    if (existingVote?.vote_type === voteType) {
      // Remove the vote if it's the same type
      const { error } = await client.from('votes').delete().match({
        content_type: contentType,
        content_id: id,
        user_id: user.id,
      })

      if (error) throw error
      return { success: true, action: 'removed' }
    }

    // Insert or update the vote
    const { error } = await client.from('votes').upsert(
      {
        content_type: contentType,
        content_id: id,
        user_id: user.id,
        vote_type: voteType,
      },
      {
        onConflict: 'content_type,content_id,user_id',
      },
    )

    if (error) throw error
    return { success: true, action: 'voted' }
  } catch (error) {
    console.error('Vote error:', error)
    throw createError({
      statusCode: 500,
      message: 'Failed to process vote',
    })
  }
})
</file>

<file path="apps/main-app/server/api/votes/user/[voteType].get.ts">
import { serverSupabaseClient, serverSupabaseUser } from '#supabase/server'

export default defineEventHandler(async (event) => {
  const client = await serverSupabaseClient(event)
  const user = await serverSupabaseUser(event)

  if (!user) {
    throw createError({
      statusCode: 401,
      message: 'Unauthorized',
    })
  }

  const voteType = parseInt(event.context.params.voteType) // 1 for upvotes, -1 for downvotes

  if (![1, -1].includes(voteType)) {
    throw createError({
      statusCode: 400,
      message: 'Invalid vote type',
    })
  }

  try {
    const { data, error } = await client
      .from('votes')
      .select('content_id')
      .eq('content_type', 'news')
      .eq('user_id', user.id)
      .eq('vote_type', voteType)

    if (error) throw error

    // Get the actual news items
    const { data: news, error: newsError } = await client
      .from('news')
      .select('*')
      .in(
        'id',
        data.map((v) => v.content_id),
      )
      .order('created_at', { ascending: false })

    if (newsError) throw newsError

    return news
  } catch (error) {
    console.error('Get voted news error:', error)
    throw createError({
      statusCode: 500,
      message: 'Failed to get voted news',
    })
  }
})
</file>

<file path="apps/main-app/server/api/votes/user.get.ts">
import { serverSupabaseClient, serverSupabaseUser } from '#supabase/server'

export default defineEventHandler(async (event) => {
  const client = await serverSupabaseClient(event)
  const user = await serverSupabaseUser(event)

  if (!user) {
    throw createError({
      statusCode: 401,
      message: 'Unauthorized',
    })
  }

  try {
    const { data, error } = await client
      .from('votes')
      .select('content_id, vote_type')
      .eq('content_type', 'news')
      .eq('user_id', user.id)

    if (error) throw error

    // Transform into a more efficient lookup object
    const voteLookup = data.reduce(
      (acc, vote) => {
        acc[vote.content_id] = vote.vote_type
        return acc
      },
      {} as Record<string, number>,
    )

    return {
      votes: voteLookup,
    }
  } catch (error) {
    console.error('Get votes error:', error)
    throw createError({
      statusCode: 500,
      message: 'Failed to get votes',
    })
  }
})
</file>

<file path="apps/main-app/server/api/webhook/database.ts">
export default defineEventHandler(async (event) => {
  const data = await readBody(event)

  console.log('SUPABASE DB WEBHOOK EVENT', data)
})
</file>

<file path="apps/main-app/server/api/database-test.ts">
// server/api/database-test.ts
import { createClient } from '@supabase/supabase-js'

export default defineEventHandler(async (event) => {
  const body = await readBody(event)
  const { environment, table, operation, role, whereConditions, columns, customPayload } = body as {
    environment: 'development' | 'staging' | 'production'
    table: string
    operation: 'SELECT' | 'INSERT' | 'UPDATE' | 'DELETE'
    role: string
    whereConditions: Array<{ column: string; operator: string; value: string }>
    columns: string[]
    customPayload: any
  }

  // Get environment configuration
  const config = {
    development: {
      url: process.env.SUPABASE_URL,
      key: process.env.SUPABASE_SERVICE_KEY,
    },
    staging: {
      url: process.env.SUPABASE_STAGING_URL,
      key: process.env.SUPABASE_STAGING_SERVICE_KEY,
    },
    production: {
      url: process.env.SUPABASE_PROD_URL,
      key: process.env.SUPABASE_PROD_SERVICE_KEY,
    },
  }[environment]

  if (!config) {
    throw createError({
      statusCode: 400,
      message: 'Invalid environment',
    })
  }

  const supabase = createClient(config.url!, config.key!)

  try {
    let query = supabase.from(table)

    switch (operation) {
      case 'SELECT': {
        query = query.select(columns.join(',')) as any
        break
      }
      case 'INSERT': {
        query = query.insert(customPayload)
        break
      }
      case 'UPDATE': {
        query = query.update(customPayload)
        break
      }
      case 'DELETE': {
        query = query.delete()
        break
      }
      default:
        throw new Error('Invalid operation')
    }

    // Apply where conditions
    if (whereConditions?.length > 0) {
      whereConditions.forEach((condition) => {
        switch (condition.operator) {
          case 'IN':
            query = query.eq(
              condition.column,
              condition.value.split(',').map((v) => v.trim()),
            )
            break
          case 'IS NULL':
            query = query.is(condition.column, null)
            break
          case 'IS NOT NULL':
            query = query.not('is', null, { column: condition.column })
            break
          case '=':
            query = query.eq(condition.column, condition.value)
            break
          case '!=':
            query = query.neq(condition.column, condition.value)
            break
          case '>':
            query = query.gt(condition.column, condition.value)
            break
          case '>=':
            query = query.gte(condition.column, condition.value)
            break
          case '<':
            query = query.lt(condition.column, condition.value)
            break
          case '<=':
            query = query.lte(condition.column, condition.value)
            break
          case 'LIKE':
            query = query.like(condition.column, `%${condition.value}%`)
            break
          default:
            query = query.eq(condition.column, condition.value)
        }
      })
    }

    console.log('sending query', query, config, body)

    const { data, error } = await query

    return {
      success: !error,
      operation,
      table,
      role,
      environment,
      data,
      error,
    }
  } catch (error: any) {
    return {
      success: false,
      operation,
      table,
      role,
      environment,
      error: {
        message: error.message,
        details: error,
      },
    }
  }
})
</file>

<file path="apps/main-app/server/api/upload.ts">
import crypto from 'crypto'
import { defineEventHandler, createError } from 'h3'
import { PDFDocument } from 'pdf-lib'
import lame from 'node-lame'
import ffmpeg from 'fluent-ffmpeg'
import { serverSupabaseClient } from '#supabase/server'

// Base optimizer interface
interface FileOptimizer {
  optimize(
    buffer: Buffer,
    options: any,
  ): Promise<{
    data: Buffer
    extension: string
    mimeType: string
  }>
}

// Image optimizer using Sharp
// class ImageOptimizer implements FileOptimizer {
//   async optimize(buffer: Buffer, options: any) {
//     const { maxWidth = 1920, maxHeight = 1080, quality = 80 } = options
//     const optimized = await sharp(buffer)
//       .resize(maxWidth, maxHeight, { fit: 'inside', withoutEnlargement: true })
//       .webp({ quality })
//       .toBuffer()
//     return { data: optimized, extension: 'webp', mimeType: 'image/webp' }
//   }
// }

// PDF optimizer using pdf-lib
class PDFOptimizer implements FileOptimizer {
  async optimize(buffer: Buffer, options: any) {
    const pdfDoc = await PDFDocument.load(buffer)
    // Implement PDF optimization logic here
    const optimized = await pdfDoc.save({ useObjectStreams: false })
    return { data: Buffer.from(optimized), extension: 'pdf', mimeType: 'application/pdf' }
  }
}

class VideoOptimizer implements FileOptimizer {
  async optimize(buffer: Buffer, options: any) {
    const {
      maxWidth = 1920,
      maxHeight = 1080,
      videoBitrate = '1000k',
      audioBitrate = '128k',
    } = options

    return new Promise((resolve, reject) => {
      ffmpeg()
        .input(buffer)
        .videoFilters(
          `scale='min(${maxWidth},iw)':min'(${maxHeight},ih)':force_original_aspect_ratio=decrease`,
        )
        .videoBitrate(videoBitrate)
        .audioBitrate(audioBitrate)
        .toFormat('mp4')
        .on('end', (stdout, stderr) => {
          resolve({ data: stdout, extension: 'mp4', mimeType: 'video/mp4' })
        })
        .on('error', reject)
        .pipe()
    })
  }
}

class AudioOptimizer implements FileOptimizer {
  async optimize(buffer: Buffer, options: any) {
    const { bitrate = 128 } = options

    const encoder = new lame.Lame({
      output: 'buffer',
      bitrate: bitrate,
    }).setBuffer(buffer)

    const encodedBuffer = await encoder.encode()
    return { data: encodedBuffer, extension: 'mp3', mimeType: 'audio/mpeg' }
  }
}

// Optimizer factory
class OptimizerFactory {
  private optimizers: Map<string, FileOptimizer> = new Map()

  register(mimeType: string, optimizer: FileOptimizer) {
    this.optimizers.set(mimeType, optimizer)
  }

  getOptimizer(mimeType: string): FileOptimizer | undefined {
    return this.optimizers.get(mimeType)
  }
}

// Create and configure the optimizer factory
const optimizerFactory = new OptimizerFactory()
// optimizerFactory.register('image', new ImageOptimizer())
optimizerFactory.register('application/pdf', new PDFOptimizer())
optimizerFactory.register('video', new VideoOptimizer())
optimizerFactory.register('audio', new AudioOptimizer())

export default defineEventHandler(async (event) => {
  console.log('File optimization and upload eventHandler')
  const form = await readMultipartFormData(event)
  if (!form?.length) {
    throw createError({ statusCode: 400, statusMessage: 'No form data provided' })
  }

  const userId = form.find((item) => item.name === 'userId')?.data.toString()
  const fileType = form.find((item) => item.name === 'fileType')?.data.toString()
  const bucket = form.find((item) => item.name === 'bucket')?.data.toString()
  const path = form.find((item) => item.name === 'path')?.data.toString()
  const optimizationOptions = JSON.parse(
    form.find((item) => item.name === 'optimizationOptions')?.data.toString() || '{}',
  )

  const file = form.find((item) => item.name === 'file')
  if (!file) {
    throw createError({ statusCode: 400, statusMessage: 'No file provided' })
  }

  if (!userId || !fileType || !bucket || !path) {
    throw createError({ statusCode: 400, statusMessage: 'Missing required parameters' })
  }

  const fileName = `${fileType}-${crypto.randomUUID()}`
  const mimeType = file.type || 'application/octet-stream'

  console.log('Processing file:', userId, fileType, fileName, mimeType)

  try {
    let optimizedFile: Buffer
    let finalExtension: string
    let finalMimeType: string

    const optimizerKey = mimeType.split('/')[0]
    const optimizer
      = optimizerFactory.getOptimizer(optimizerKey) || optimizerFactory.getOptimizer(mimeType)

    if (optimizer) {
      const result = await optimizer.optimize(file.data, optimizationOptions)
      optimizedFile = result.data
      finalExtension = result.extension
      finalMimeType = result.mimeType
    } else {
      console.log('No optimizer found for this file type, uploading as-is')
      optimizedFile = file.data
      finalExtension = mimeType.split('/')[1]
      finalMimeType = mimeType
    }

    const client = await serverSupabaseClient(event)
    const { error } = await client.storage
      .from(bucket)
      .upload(`${path}/${fileName}.${finalExtension}`, optimizedFile, {
        contentType: finalMimeType,
        cacheControl: '3600',
        upsert: true,
      })

    if (error) {
      throw createError({ statusCode: 500, statusMessage: error.message })
    }

    // If this is a profile-related upload, update the user_profiles table
    if (bucket === 'user-profiles' && ['avatar', 'cover-photo'].includes(fileType)) {
      const { error: updateError, data } = await client
        .from('user_profiles')
        .update({ [fileType]: `${fileName}.${finalExtension}` })
        .eq('id', userId)
        .select()

      if (updateError) {
        console.error('Error updating user profile:', updateError)
      } else {
        console.log('User profile updated:', data)
      }
    }

    return {
      statusCode: 200,
      body: JSON.stringify({
        message: 'File successfully uploaded and optimized',
        fileName: `${fileName}.${finalExtension}`,
      }),
    }
  } catch (error: any) {
    console.error('Error processing file:', error)
    throw createError({ statusCode: 500, statusMessage: error.message })
  }
})
</file>

<file path="apps/main-app/server/middleware/feature-limit.ts">
import { handleFeatureLimitError } from '../utils/errors'
import { validateFeatureLimit } from '../utils/featureLimits'
import { serverSupabaseUser, serverSupabaseClient } from '#supabase/server'

export default defineEventHandler(async (event) => {
  // Only check POST requests
  if (event.method !== 'POST') return

  // Get the path to determine which feature to check
  const path = getRequestPath(event)

  // Map endpoints to features
  const featureMap: Record<string, string> = {
    '/api/bookmarks': 'BOOKMARKS',
    '/api/folders': 'BOOKMARK_FOLDERS',
  }

  const feature = featureMap[path]
  if (!feature) return // Not a feature-limited endpoint

  try {
    const user = await serverSupabaseUser(event)

    if (!user) {
      throw createError({
        statusCode: 401,
        message: 'Unauthorized',
      })
    }

    const supabase = await serverSupabaseClient(event)

    // Get the table name from the path
    const table = path.split('/')[2] // 'bookmarks' or 'folders'

    // Check current count
    const { count } = await supabase
      .from(table)
      .select('*', { count: 'exact' })
      .eq('user_id', user.id)

    await validateFeatureLimit(event, feature, count ?? 0)
  } catch (error) {
    handleFeatureLimitError(error)
  }
})
</file>

<file path="apps/main-app/server/plugins/error-handler.ts">
// server/plugins/error-handler.ts
import { useLoggerAsync, ErrorType } from '@ib/logger'
import type { H3Error } from 'h3'

interface ApiResponse {
  error?: {
    code: typeof ErrorType
    message: string
    details?: any
  }
  status: number
}

export default defineNitroPlugin((nitro) => {
  nitro.hooks.hook('error', async (error: Error, { event }) => {
    const isDev = useRuntimeConfig().public.nodeEnv === 'development'
    const logger = await useLoggerAsync('nitro:error')

    // Extract API response from error.data if it exists, or create a new one
    const apiResponse: ApiResponse = (error.data as ApiResponse) || {
      error: {
        code: error.statusCode === 404 ? ErrorType.SERVER_ERROR : ErrorType.SERVER_ERROR,
        message: error.message || 'An unexpected error occurred',
        details: isDev
          ? {
              name: error.name,
              cause: error.cause,
              stack: error.stack,
            }
          : undefined,
      },
      status: error.statusCode || 500,
    }

    if (event) {
      // Log the error with full context
      logger.error(`[${event.path}] ${event.method} Error:`, {
        code: apiResponse.error?.code,
        statusCode: error.statusCode,
        message: error.message,
        name: error.name,
        cause: isDev ? error.cause : undefined,
        stack: isDev ? error.stack : undefined,
      })

      // Set response
      event.node.res.statusCode = apiResponse.status
      event.node.res.setHeader('Content-Type', 'application/json')

      // Send sanitized response
      const safeResponse = {
        ...apiResponse,
        error: isDev
          ? apiResponse.error
          : {
              code: apiResponse.error?.code,
              message: apiResponse.error?.message,
            },
      }

      event.node.res.end(JSON.stringify(safeResponse))
    } else {
      // Log error even if no event context
      logger.error('Unhandled Server Error:', {
        code: apiResponse.error?.code,
        statusCode: error.statusCode,
        message: error.message,
        name: error.name,
        cause: isDev ? error.cause : undefined,
        stack: isDev ? error.stack : undefined,
      })
    }
  })
})
</file>

<file path="apps/main-app/server/utils/openai/callOpenAI.ts">
import openAiClient from './openaiClient'

type CallOpenAIConfig = {
  temperature?: number // Controls randomness: lower is more deterministic.
  max_tokens?: number // Maximum number of tokens to generate.
  top_p?: number // Nucleus sampling: higher allows more diversity.
}

// Asynchronous function to call the OpenAI API with specified parameters.

interface OpenAIInput {
  prompt: string
  systemMessage: string
  config?: CallOpenAIConfig
}

const createChatCompletion = async ({ prompt, systemMessage, config }: OpenAIInput) => {
  try {
    // Make an API call to OpenAI's chat completion endpoint.
    const response = await openAiClient.chat.completions.create({
      model: 'gpt-3.5-turbo', // Specifies the model to use.
      messages: [
        // An array of messages that precedes the function call.
        { role: 'system', content: systemMessage },
        { role: 'user', content: prompt },
      ],
      temperature: config?.temperature || 0.5,
      max_tokens: config?.max_tokens || 600,
      top_p: config?.top_p || 0.7,
    })

    return response
  } catch (error: any) {
    console.error('Error calling OpenAI API', error)
    throw createError({ message: error.message || 'Failed to call OpenAI API' })
  }
}

export const openAI = {
  createChatCompletion,
}
</file>

<file path="apps/main-app/server/utils/openai/openaiClient.ts">
import OpenAI from 'openai/index.mjs'

const openaiClient = new OpenAI({
  organization: process.env.OPENAI_ORG_ID,
  project: process.env.OPENAI_PROJECT_ID,
})

export default openaiClient
</file>

<file path="apps/main-app/server/utils/storage/storageSupabase.ts">
type FileType = 'venue-logo' | 'venue-featured-image' | 'venue-images' | 'user-avatar'

const defaultFileOptions: Record<FileType, string> = {
  'venue-logo': 'logo.jpg',
  'venue-featured-image': 'featured-image.jpg',
  'venue-images': 'images/',
  'user-avatar': 'avatar.jpg',
}

type BucketKey = 'profile-public' | 'posts' | 'venues'

const selectBucket: Record<FileType, BucketKey> = {
  'venue-logo': 'venues',
  'venue-images': 'venues',
  'venue-featured-image': 'venues',
  'user-avatar': 'profile-public',
}

interface UrlConstructorOptions {
  baseURL: string
  bucket: BucketKey
  file: string | null
  folderPath: string
  fileType: FileType
  isPrivate?: boolean
  transform?: {
    width?: number
    height?: number
    fit?: 'contain' | 'cover' | 'fill'
    quality?: number
  } | null
}

const stringIsNull = (value: any): boolean =>
  value === null || value === undefined || value === '' || value.length === 0

export const constructUrl = (options: UrlConstructorOptions) => {
  const {
    baseURL,
    bucket,
    file,
    folderPath,
    fileType,
    isPrivate = false,
    transform = null,
  } = options

  if (stringIsNull(file)) {
    console.log('No file provided, using default file for', fileType)
    return `images/defaults/${defaultFileOptions[fileType]}`
  }

  if (file && file.startsWith('http')) {
    return file
  }

  const filePath = `${folderPath}/${file}`
  const accessType = isPrivate ? 'private' : 'public'
  const path = transform
    ? `/render/image/${accessType}/${bucket}/${filePath}`
    : `/storage/v1/object/${accessType}/${bucket}/${filePath}`
  const url = new URL(path, baseURL)

  if (transform) {
    Object.entries(transform).forEach(([key, value]) => {
      if (value !== undefined) {
        url.searchParams.append(key, value.toString())
      }
    })
  }

  return url.href
}

export interface GetImageUrlOptions
  extends Omit<UrlConstructorOptions, 'baseURL' | 'bucket' | 'isPrivate' | 'folderPath'> {
  data: any
}

function getFileProperty(fileType: FileType, data: any) {
  switch (fileType) {
    case 'user-avatar':
      return {
        file: data.avatar,
        fileCategory: 'avatar',
      }
    default:
      throw createError({ message: 'Invalid fileType in getFileProperty' })
  }
}

function formatImageInput(fileType: FileType, data: any) {
  const { file, fileCategory } = getFileProperty(fileType, data)
  return {
    bucket: selectBucket[fileType],
    folderPath: `${data.id}/${fileCategory}`,
    isPrivate: false,
    file,
  }
}

export const getImageURL = ({ data, fileType, transform }: GetImageUrlOptions): string => {
  const baseURL = useRuntimeConfig().public.supabaseUrl
  const { bucket, folderPath, isPrivate, file } = formatImageInput(fileType, data)
  if (!baseURL) {
    throw createError({
      message: 'baseURL not defined in getImageURL',
    })
  }

  if (!fileType) {
    throw createError({ message: 'fileType is required in constructUrl' })
  }

  return constructUrl({
    baseURL,
    bucket,
    file,
    fileType,
    folderPath,
    isPrivate,
    transform,
  })
}

export interface GetStorageImagesOptions extends Omit<UrlConstructorOptions, 'baseURL' | 'file'> {}

// export async function getStorageImages(options: GetStorageImagesOptions): Promise<string[]> {
//   const { bucket, fileType, folderPath, isPrivate, transform } = options
//   const baseURL = useRuntimeConfig().public.supabaseUrl
//   if (!bucket || !folderPath) {
//     console.error('Bucket and folder are required parameters')
//     return []
//   }

//   const images: string[] = []

//   const { data, error } = await client.storage.from(bucket).list(folderPath)

//   if (error) {
//     console.error(`Error fetching images from ${bucket}:`, error)
//     return []
//   }

//   if (!data || data.length === 0) {
//     console.info(`No data returned from Supabase for bucket ${bucket}`)

//     // use constructUrl to create a default image URL
//     const defaultUrlOptions: UrlConstructorOptions = {
//       baseURL,
//       bucket,
//       file: null,
//       folderPath: '',
//       fileType,
//       isPrivate
//     }
//     return [constructUrl(defaultUrlOptions)]
//   }

//   // If you want to store full URLs
//   await data.forEach((file: FileObject) => {
//     if (!file.name.startsWith('.')) {
//       // use constructUrl to create image URLs
//       const urlOptions: UrlConstructorOptions = {
//         baseURL,
//         bucket,
//         file: file.name,
//         folderPath,
//         fileType,
//         isPrivate,
//         transform
//       }
//       images.push(constructUrl(urlOptions))
//     }
//   })

//   return images
// }
</file>

<file path="apps/main-app/server/utils/agents.ts">
export const agents = [
  {
    id: 1,
    name: 'Research Assistant',
    features: ['Find Papers', 'Bullet two'],
    systemMessage: 'This is an example base prompt',
  },
  {
    id: 2,
    name: 'Summarizer',
    features: ['Summarize all content consicely', 'Bullet two'],
    systemMessage: 'This is an example base prompt',
  },
]
</file>

<file path="apps/main-app/server/utils/errors.ts">
export const handleFeatureLimitError = (error: any) => {
  // Feature limit errors
  if (error.statusCode === 403) {
    throw createError({
      statusCode: 403,
      message: error.message || 'Feature limit reached',
      data: {
        code: 'FEATURE_LIMIT_REACHED',
      },
    })
  }

  // Auth errors
  if (error.statusCode === 401) {
    throw createError({
      statusCode: 401,
      message: 'Authentication required',
      data: {
        code: 'AUTH_REQUIRED',
      },
    })
  }

  // Validation errors
  if (error.statusCode === 400) {
    throw createError({
      statusCode: 400,
      message: error.message || 'Invalid request',
      data: {
        code: 'VALIDATION_ERROR',
      },
    })
  }

  // Default error
  throw createError({
    statusCode: error.statusCode || 500,
    message: error.message || 'An unexpected error occurred',
    data: {
      code: 'INTERNAL_SERVER_ERROR',
    },
  })
}
</file>

<file path="apps/main-app/server/utils/featureLimits.ts">
import { FEATURES } from '#shared/constants'

enum PlanType {
  FREE = 'free',
  PRO = 'pro',
}

export const validateFeatureLimit = async (
  event: H3Event,
  feature: string,
  currentCount: number,
) => {
  // For now, assume free plan
  const userPlan = PlanType.FREE

  const limit = FEATURES[feature].limit[userPlan]

  if (limit !== -1 && currentCount >= limit) {
    throw createError({
      statusCode: 403,
      message: `You have reached the ${FEATURES[feature].name.toLowerCase()} limit for your plan.`,
    })
  }
}
</file>

<file path="apps/main-app/server/utils/formatter.ts">
import { z } from 'zod'

// use .default("") to set defaults, I think this makes more sense than setting defaults in the database
// can add a .catch(catchValue) value to set a value if the parsing fails

const uuid = z.string().uuid()
const string = z.string()
const stringNullish = z.string().nullish()
const stringNull = z.string().nullable()
const stringOptional = z.string().optional()

export const datetimeOffset = (
  errorMsg: string = 'Invalid datetime string! Must be UTC.',
  offset?: boolean,
) => ({
  optional: z
    .string()
    .datetime({ message: errorMsg, offset: offset ?? true })
    .optional(),
  nullish: z
    .string()
    .datetime({ message: errorMsg, offset: offset ?? true })
    .nullish(),
})

export const formatAvatarUrl = (user: any) => {
  return getImageURL({
    fileType: 'user-avatar',
    data: user,
  })
}

export type UserDTOKey = 'select:user:card' | 'select:user:profile' | 'select:user:settings'

export function roleIconMapping(role: AppRoleEnum): string {
  switch (role) {
    case 'admin':
      return 'material-symbols:shield-lock' // ADMIN
    case 'moderator':
      return 'material-symbols:manage-accounts' // MODERATOR
    case 'mentor':
      return 'mdi:account-school' // MENTOR
    case 'astroguide':
      return 'mdi:telescope' // ASTROGUIDE
    case 'user':
      return 'material-symbols:account-circle' // USER
    default:
      return 'material-symbols:account-circle' // DEFAULT
  }
}

export const formatDob = (date: string) => new Date(date).toISOString()

// todo:easy:1 add moderator to role table in supabase

// logic:med:med:4 - create a set of rules for formatting data to and from the database, add to DTOs
export const rules = {
  toDB: {
    uuid,
    string,
    stringNullish,
    stringNull,
    stringOptional,
    datetimeOffset,
  },
  toClient: {
    uuid: (userData: any) => uuid.parse(userData),
    string: (userData: any) => string.parse(userData),
    stringNullish: (userData: any) => stringNullish.parse(userData),
    stringNull: (userData: any) => stringNull.parse(userData),
    stringOptional: (userData: any) => stringOptional.parse(userData),
  },
}
</file>

<file path="apps/main-app/server/utils/generateServerToken.ts">
import jwt from 'jsonwebtoken'
import { useRuntimeConfig } from '#imports'

export function generateServerToken() {
  const config = useRuntimeConfig()
  return jwt.sign({ sender: 'AstronEra' }, config.scraperKey, {
    algorithm: 'HS256',
    expiresIn: '1h',
  })
}
</file>

<file path="apps/main-app/server/utils/groqClient.ts">
import { Groq } from 'groq-sdk/index.mjs'

const groq = new Groq({
  apiKey: process.env.GROQ_API_KEY,
})

interface AgentInput {
  message: string
  systemPrompt: string
}

interface Message {
  role: 'user' | 'assistant'
  content: string
}

export async function getGroqChatCompletion(messages: Message[]) {
  return await groq.chat.completions.create({
    messages: messages,
    model: 'llama3-70b-8192',
    // Controls randomness: lowering results in less random completions.
    // As the temperature approaches zero, the model will become
    // deterministic and repetitive.
    temperature: 0.3,

    // The maximum number of tokens to generate. Requests can use up to
    // 2048 tokens shared between prompt and completion.
    max_tokens: 1500,
    // Controls diversity via nucleus sampling: 0.5 means half of all
    // likelihood-weighted options are considered.
    top_p: 0.6,

    // A stop sequence is a predefined or user-specified text string that
    // signals an AI to stop generating content, ensuring its responses
    // remain focused and concise. Examples include punctuation marks and
    // markers like "[end]".
    // stop: 'None',

    // If set, partial message deltas will be sent.
    // streaming is not supported in JSON mode
    stream: false,
    // Enable JSON mode by setting the response format
    // response_format: { type: 'json_object' }
  })
}
</file>

<file path="apps/main-app/server/utils/rateLimiter.ts">
import { serverSupabaseUser } from '#supabase/server'

type PlanKey = 'free' | 'basic' | 'intermediate' | 'premium'
type FeatureKey = 'ask'

const rateLimitConfig = {
  free: {
    ask: {
      interval: 1800000,
      maxRequests: 3,
    },
  },
  basic: {
    ask: {
      interval: 1800000,
      maxRequests: 10,
    },
  },
  intermediate: {
    ask: {
      interval: 1800000,
      maxRequests: 20,
    },
  },
  premium: {
    ask: {
      interval: 1800000,
      maxRequests: 30,
    },
  },
}

// consider using   const ip = getRequestIP(event); // "192.0.2.0"
// consider using   const userAgent = getRequestHeader(event, 'user-agent');
// consider using   const referer = getRequestHeader(event, 'referer');
// getRequestFingerprint(event, opts) instead of correlation-id

// this can probably be improved once we have role based access implmented
// all info can be appended to the event.context object

interface RateLimitInfo {
  requestCount: number
  expiresAt: number
}

const getFeatureFromPath = (path: string): FeatureKey => {
  const feature = path.split('/').pop()?.split('?')[0] as FeatureKey
  console.log('getFeatureFromPath', feature)
  return feature
}

export async function rateLimiter() {
  const event = useEvent()
  const feature = getFeatureFromPath(event.path)
  const user = await serverSupabaseUser(event)

  if (!user) {
    throw createError({ message: 'User not found, You must be logged in to use this endpoint' })
  }
  const userPlan = (user?.app_metadata.plan as PlanKey) ?? 'free'
  const storage = useStorage('session')
  const storageKey = `rateLimit:endpoint:${userPlan}:${user?.id}`
  const settings = rateLimitConfig[userPlan][feature]

  let rateLimit = await storage.getItem<RateLimitInfo>(storageKey)
  if (!rateLimit || rateLimit.expiresAt < Date.now()) {
    console.info('Rate limit not found, or it has expired')
    rateLimit = {
      requestCount: 1,
      expiresAt: Date.now() + settings.interval,
    }
  }

  if (rateLimit.requestCount > settings.maxRequests) {
    throw createError({
      statusCode: 429,
      statusMessage: `Exceeded ${feature.charAt(0).toUpperCase()}${feature.slice(1)} Limits`,
      message: `You have exceeded your limit of ${settings.maxRequests}
       requests in the last ${settings.interval / 60000} minutes`,
    })
  }

  rateLimit.requestCount++

  await storage.setItem(storageKey, rateLimit)
}
</file>

<file path="apps/main-app/server/utils/validator.ts">
import type { H3Event } from 'h3'
import type { AnyZodObject } from 'zod'

export async function validateBody(event: H3Event, parser: AnyZodObject) {
  const validatedBody = await readValidatedBody(event, parser.safeParse)

  if (!validatedBody.success) {
    throw createError({
      statusCode: 422,
      statusMessage: 'Unprocessable Entity: Feedback Format',
      message: JSON.stringify(validatedBody.error.errors),
    })
  }

  return validatedBody.data
}
</file>

<file path="apps/main-app/shared/constants.ts">
export const FEATURES = {
  BOOKMARK_FOLDERS: {
    name: 'Bookmark Folders',
    limit: {
      free: 2,
      pro: -1, // unlimited
    },
    description: 'Organize your bookmarks into folders',
  },
  BOOKMARKS: {
    name: 'Bookmarks',
    limit: {
      free: 100,
      pro: -1,
    },
    description: 'Save articles for later',
  },
  CUSTOM_FOLDER_COLORS: {
    name: 'Custom Folder Colors',
    limit: {
      free: 0,
      pro: -1,
    },
    description: 'Personalize your folders with custom colors',
    comingSoon: true,
  },
} as const
</file>

<file path="apps/main-app/shared/index.ts">
export * from './constants'
</file>

<file path="apps/main-app/tasks/setup-posthog.md">
# PostHog Setup Guide for A/B Testing and Analytics

## 1. Initial Setup

1. Sign up for a PostHog account if you haven't already.
2. Create a new project for your application.
3. Get your project API key from the project settings.

## 2. Install PostHog in Your Nuxt Application

1. Install the PostHog client library:
   ```
   npm install posthog-js
   ```
2. Set up the PostHog plugin in your Nuxt app as we discussed earlier.

## 3. Configure Event Capture

1. In the PostHog dashboard, go to "Data Management" > "Events".
2. Create event definitions for each of your main event types (e.g., "User Acquisition",
   "Onboarding", "User Engagement", etc.).
3. For each event, define properties that you expect to capture.

## 4. Set Up Properties

1. Go to "Data Management" > "Properties".
2. Define and describe the properties you'll be using across different events.

## 5. Create Dashboards

1. Go to "Dashboards" and create a new dashboard for each main category:
   - User Acquisition Dashboard
   - Onboarding Dashboard
   - User Engagement Dashboard
   - Content Performance Dashboard
   - Job Market Activity Dashboard
   - Technical Performance Dashboard
2. In each dashboard, add relevant charts and metrics based on the events and properties you've
   defined.

## 6. Set Up Funnels

1. Go to "Product Analytics" > "Funnels".
2. Create funnels for important user journeys, such as:
   - Sign-up process
   - Onboarding steps
   - Job application process

## 7. Configure Cohorts

1. Go to "Persons & Cohorts" > "Cohorts".
2. Create cohorts based on user behaviors or properties, such as:
   - Active users (daily, weekly, monthly)
   - Users who have completed onboarding
   - Job seekers vs. employers

## 8. Set Up A/B Testing (Experiments)

1. Go to "Experiments" in the PostHog dashboard.
2. Click "New Experiment" to create a new A/B test.
3. Define your experiment:
   - Name: Choose a descriptive name (e.g., "Homepage CTA Button Color")
   - Description: Explain the purpose and hypothesis of the experiment
   - Feature Flag: Create a new feature flag or select an existing one
   - Variants: Define your control and variant(s) (e.g., "blue" and "green")
   - Goal Metrics: Select the events that will determine the success of your experiment
4. Set the percentage of users who will be part of the experiment.
5. Launch the experiment when ready.

## 9. Configure Feature Flags

1. Go to "Feature Flags" in the PostHog dashboard.
2. Create feature flags for each feature or component you want to A/B test.
3. Set up the distribution of these flags (e.g., 50% see version A, 50% see version B).

## 10. Set Up Alerts

1. Go to "Alerts" in the PostHog dashboard.
2. Set up alerts for important metrics or events, such as:
   - Sudden drop in user engagement
   - Spike in error rates
   - Reaching a certain number of job applications

## 11. Configure Data Management

1. Go to "Data Management" > "Aggregation".
2. Set up aggregation queries for complex metrics that require data processing.

## 12. Set Up User Identification

1. Ensure your `identifyUser` function in the analytics composable is correctly calling PostHog's
   identify method.
2. In PostHog, go to "Data Management" > "Persons" to verify that user data is being correctly
   associated.

## 13. Test Your Setup

1. Use your application with the analytics and A/B testing composables implemented.
2. Check the PostHog dashboard to ensure events are being captured correctly.
3. Verify that your A/B tests are running as expected.
4. Make sure your dashboards are populating with real data.

## 14. Implement Consent Management (if necessary)

1. If you're operating in regions with strict privacy laws (e.g., GDPR), set up a consent management
   system.
2. Use the `opt_in_capturing()` and `opt_out_capturing()` methods provided by PostHog in your
   consent management flow.

Remember to regularly review and refine your analytics setup as your application evolves and your
data needs change.
</file>

<file path="apps/main-app/types/bookmarks.ts">
// types/bookmark.ts
export interface BookmarkContent {
  id: string
  type: string
  title: string
  description?: string
  thumbnail?: string
  url?: string
  created_at?: string
  authorName?: string
}

export interface BookmarkParams {
  content_type?: string
  folder_id?: string
  include_subfolders?: boolean
}

export interface Bookmark {
  id: string
  user_id: string
  folder_id: string | null
  content_type: string
  content_id: string
  metadata: {
    title: string
    description?: string
    thumbnail?: string
    url?: string
    created_at?: string
    authorName?: string
  }
  created_at: string
  folder?: {
    id: string
    name: string
    color: string
    is_favorite: boolean
    path?: string
  }
}

export interface Folder {
  id: string
  name: string
  color: string
  parent_id: string | null
  is_default: boolean
  is_favorite: boolean
  position: number
  path: string
  children?: Folder[]
}
</file>

<file path="apps/main-app/types/folder.ts">
export interface Folder {
  id: string
  name: string
  color: string
  parent_id: string | null
  is_default: boolean
  is_favorite: boolean
  position: number
  path: string
  children?: Folder[]
}
</file>

<file path="apps/main-app/types/toasts.ts">
import { z } from 'zod'

export const ToastActionSchema = z.object({
  variant: z.string(),
  color: z.string(),
  label: z.string(),
})

export const ToastSchema = z.object({
  id: z.union([z.string(), z.number()]),
  title: z.string(),
  description: z.string().optional(),
  icon: z.string().optional(),
  color: z.string().optional(),
  timeout: z.number().optional(),
  ui: z.unknown().optional(),
  avatar: z.unknown().optional(),
  closeButton: z.unknown().optional(),
  actions: z.array(ToastActionSchema).optional(),
  callback: z.function().optional(),
})

export const ToastStateSchema = z.object({
  toasts: z.array(ToastSchema),
})

export type ToastType = z.infer<typeof ToastSchema>
export type ToastActionType = z.infer<typeof ToastActionSchema>
export type ToastStateType = z.infer<typeof ToastStateSchema>
</file>

<file path="apps/main-app/app.config.ts">
// This supports HMR
export default defineAppConfig({
  title: 'AstronEra - AstroTribe',
})
</file>

<file path="apps/main-app/app.vue">
<script setup lang="ts">
const catTagStore = useCategoryTagStore()
const currentUser = useCurrentUser()

onMounted(async () => {
  document.documentElement.classList.add('dark')
  await catTagStore.getCategories()
  await catTagStore.getTags()
})

useHead({
  htmlAttrs: {
    lang: 'en',
  },
  meta: [
    {
      name: 'viewport',
      content: 'width=device-width, initial-scale=1',
    },
  ],
  link: [
    {
      rel: 'icon',
      type: 'image/png',
      href: '/favicon.png',
    },
  ],
})
</script>

<template>
  <div class="h-full w-full">
    <NuxtLoadingIndicator />
    <Head>
      <link rel="manifest" href="/manifest.webmanifest" />
    </Head>
    <NuxtPwaAssets />
    <NuxtLayout>
      <NuxtPage />
    </NuxtLayout>
    <PrimeToast position="bottom-right" />
    <!-- <Notification /> -->
  </div>
</template>

<style>
html {
  margin: 0;
  padding: 0;
}

#__nuxt {
  width: 100%;
  height: 100%;
  padding: 0;
  margin: 0;
}

.layout-enter-active,
.layout-leave-active {
  transition: all 0.4s;
}

.layout-enter-from,
.layout-leave-to {
  opacity: 0;
  filter: blur(1rem);
}
</style>
</file>

<file path="apps/main-app/error.vue">
<template>
  <div class="flex h-auto items-center justify-center foreground min-h-screen">
    <div class="max-w-md rounded-lg p-8 shadow-lg background">
      <h1 class="mb-4 text-3xl font-bold text-red-600"> An error occurred </h1>
      <p class="text-lg mb-4">
        {{ error.message }}
      </p>
      <p class="mb-2 text-sm text-gray-600"> Error ID: {{ error.errorId }} </p>
      <p
        v-if="error.stack"
        class="mb-4 overflow-auto text-xs text-gray-500"
      >
        <strong>Stack trace:</strong><br />
        {{ error.stack }}
      </p>
      <div class="flex justify-between">
        <button
          v-if="error.retryAction"
          class="rounded bg-blue-500 px-4 py-2 text-white hover:bg-blue-600"
          @click="retryAction"
        >
          Retry
        </button>
        <button
          class="rounded bg-gray-300 px-4 py-2 text-gray-800 hover:bg-gray-400"
          @click="goHome"
        >
          Go to Home
        </button>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
const props = defineProps({
  error: Object,
})

const retryAction = () => {
  if (props.error.retryAction) {
    props.error.retryAction()
  }
}

const goHome = () => {
  clearError({ redirect: '/' })
}
</script>
</file>

<file path="apps/main-app/nuxt.config.ts">
import { fileURLToPath } from 'url'
import { dirname, join, resolve } from 'path'
import { defineNuxtConfig } from 'nuxt/config'
import runtimeConfig from '../../shared-runtime.config'

const currentDir = dirname(fileURLToPath(import.meta.url))

export default defineNuxtConfig({
  workspaceDir: '../../',
  srcDir: '.',
  extends: ['../../layers/base', '../../layers/auth', '../../layers/crud', '../../layers/advert'],

  vite: {
    optimizeDeps: {
      exclude: ['fsevents'],
    },
  },

  build: {
    transpile: ['@formbricks/js'],
  },

  plugins: [{ src: '~/plugins/formbricks.client.ts' }],

  debug: true,

  modules: [
    'nuxt-tiptap-editor',
    '@nuxt/devtools',
    '@vueuse/nuxt',
    '@nuxt/image',
    '@pinia/nuxt',
    '@nuxt/icon',
    '@nuxt/eslint',
    '@nuxtjs/tailwindcss',
    '@nuxtjs/mdc',
    '@primevue/nuxt-module',
    '@vite-pwa/nuxt',
  ],

  experimental: {
    asyncContext: true,
  },

  tailwindcss: {
    configPath: `${currentDir}/tailwind.config.ts`,
    cssPath: [`${currentDir}/assets/css/tailwind.css`, { injectPosition: 0 }],
    exposeConfig: true,
    viewer: true,
  },

  primevue: {
    importPT: { from: resolve(currentDir, '../../theme/index.js') },
    autoImport: true,
    components: {
      prefix: 'Prime',
      include: '*',
      exclude: ['Editor'],
    },

    composables: {
      include: '*',
    },

    options: {
      ripple: true,
      unstyled: true,
      theme: {
        options: {
          cssLayer: true,
        },
      },
    },
  },

  image: {
    format: ['webp', 'jpg'],
  },

  tiptap: {
    prefix: 'Tiptap',
  },

  pwa: {
    registerType: 'autoUpdate',
    manifest: false, // We'll use our own manifest file
    workbox: {
      navigateFallback: '/offline',
      globPatterns: ['**/*.{js,css,html,ico,png,svg}'],
      cleanupOutdatedCaches: true,
      runtimeCaching: [
        {
          urlPattern: /^\/api\//,
          handler: 'NetworkFirst',
        },
      ],
    },
    client: {
      installPrompt: true,
    },
  },

  alias: {
    '#shared': fileURLToPath(new URL('./shared', import.meta.url)),
  },

  // Add proper MIME type handling
  nitro: {
    routeRules: {
      '/manifest.webmanifest': {
        headers: {
          'Content-Type': 'application/manifest+json',
          'Cache-Control': 'public, max-age=0',
        },
      },
      '/api/bookmarks/**': {
        appMiddleware: ['feature-limit'],
      },
      '/api/folders/**': {
        appMiddleware: ['feature-limit'],
      },
    },
    alias: {
      '#shared': fileURLToPath(new URL('./shared', import.meta.url)),
    },
  },

  ...runtimeConfig,
})
</file>

<file path="apps/main-app/prompt-app-download.ts">
function isMobileDevice() {
  return /Mobi|Android|iPhone/i.test(navigator.userAgent)
}

let deferredPrompt

window.addEventListener('beforeinstallprompt', (e) => {
  // Prevent the mini-infobar from appearing on mobile
  e.preventDefault()
  // Stash the event so it can be triggered later
  deferredPrompt = e

  // Check if the device is mobile
  if (isMobileDevice()) {
    // Show your custom install button or prompt
    showInstallButton()
  }
})

function showInstallButton() {
  // Display your custom install UI for mobile users
  const installButton = document.getElementById('install-button')
  installButton.style.display = 'block'

  installButton.addEventListener('click', async () => {
    // Hide the install button
    installButton.style.display = 'none'

    // Show the install prompt
    deferredPrompt.prompt()

    // Wait for the user to respond to the prompt
    const { outcome } = await deferredPrompt.userChoice
    if (outcome === 'accepted') {
      console.log('User accepted the install prompt')
    } else {
      console.log('User dismissed the install prompt')
    }
    deferredPrompt = null
  })
}
</file>

<file path="apps/main-app/README.md">
<h1 align="center" style="margin-top: 0px;">AstroTribe</h1>
<!-- <p align="center" style="margin-bottom: 0px !important;">
  <img width="200" src="https://github.com/Drew-Macgibbon/design-portfolio/blob/main/public/readme/doom-logo.png" align="center">
</p> -->
<p align="center" >The AstroTribe App is a social network for astronomers and wannabe astronomers around the globe.</p>

<p align="center">
  <a href="https://astronera.org/">Production</a> --- |  .  | --- <a href="https://astrotribe.vercel.app/">Development</a>
</p>

We're currently working towards an open beta release. If you'd like to be notified when we launch,
register your interest [here](https://astrotribe.vercel.app/register)

### Contributing:

Clone the `develop` Branch Create your Feature Branch `git checkout -b feature/amazing-feature` Open
a Pull Request against `develop` when the feature is ready for review

### Development Setup:

supabase: http://localhost:54323/project/default

#### Find Work:

##### Domain / Category

1. **`infra:` Infrastructure & Foundations**

   - **Scope**: This domain encompasses all backend infrastructure elements critical to application
     functionality. It includes the management of server environments, authentication systems,
     application programming interfaces (APIs), data storage solutions, logging systems, and any
     other foundational services or protocols that support application operations.
   - **Example Tasks**: Set up secure authentication methods, optimize API performance, implement
     comprehensive logging systems, and configure cloud storage solutions.

2. **`logic:` Business Logic & Processing**

   - **Scope**: Focuses on the core functionality that users interact with directly. This domain
     includes the creation and maintenance of the operational logic that drives the application's
     primary features—from user inputs leading to actions (like button clicks) to data processing
     and output formatting.
   - **Example Tasks**: Develop a new feature that formats user data for reports, refactor
     validation logic to enhance security, create storage procedures for user inputs.

3. **`design:` User Interface & Experience Design**

   - **Scope**: Dedicated to the aesthetic and functional design of user interfaces and the
     underlying software architecture. This domain covers everything from UI/UX design for improved
     user interaction to strategic database and software architecture planning for efficient data
     management and flow.
   - **Example Tasks**: Redesign the user interface for enhanced usability, create a responsive
     design for mobile platforms, plan and model a new database schema for scalability.

4. **`test:` Quality Assurance & Testing**

   - **Scope**: Ensures that all features operate as intended before they reach end-users. This
     domain involves developing and maintaining a robust testing framework, including unit tests,
     integration tests, system tests, and ensuring new functionalities are covered as they are
     developed.
   - **Example Tasks**: Write integration tests for a new API endpoint, update existing tests to
     cover recent changes in business logic, automate regression testing scenarios.

5. **`bug:` Issue Resolution & Debugging**
   - **Scope**: A cross-domain responsibility focused on identifying, tracking, and resolving bugs
     throughout the application. This domain ensures that issues are promptly addressed to maintain
     the integrity and performance of the application across all other domains.
   - **Example Tasks**: Fix a critical bug affecting user login, resolve a recurring error in data
     formatting, debug a performance issue in database queries.

##### Search for Jobs

Key = category | priority | difficulty | time estimate

<!-- // teams work in small groups on single feature end to end -->

**Remove '~' from your search, it's for doc search exclusion**

```ts
// Frontend Work
//
// ~infra:low:easy:1 - Routine Check: Perform daily server status check.
// ~logic:med:med:2 - Update Rollout: Deploy new software updates to the server cluster.
// ~design:high:challenge:4 - Infrastructure Overhaul: Redesign the network architecture for increased efficiency.
// ~test:urgent:hard:8 - Disaster Recovery: Implement immediate fixes following a critical system failure.
// ~bug:critical:extreme:12 - Full System Rebuild: Reconstruct server environment and restore all critical services post-major outage.
```

**Backend uses a ! prefix**

```ts
// Backend Work (! prefix)
//
// ~!infra:low:easy:1
```

**Database uses # for comments**

```bash
# Database Work (# for comments)
#
# ~infra:low:easy:1
```

#### Stack

- Nuxt
- Vercel
- Supabase

#### Links

- Dev Site: https://astrotribe-git-develop-incubrain.vercel.app

#### Supabase:

install supabase locally if you don't have it already.

```bash
brew install supabase/tap/supabase
```

```bash
// make sure docker is open
// download the images
supabase start
//
supabase login
// link the local project to production
supabase link --project-ref <project-id>
// pull down the database
supabase db pull
```

#### Migrations:

```bash
// create a migration based on changes made in local studio
supabase db diff -f new_employee
// reset db to verify changes
supabase db reset
```

<!-- 11:28 battery full -->
</file>

<file path="apps/main-app/tailwind.config.ts">
import { fileURLToPath } from 'url'
import { dirname, resolve } from 'path'
import type { Config } from 'tailwindcss'
import baseConfig from '../../tailwind.config.base'

const currentDir = dirname(fileURLToPath(import.meta.url))

const config: Partial<Config> = {
  presets: [baseConfig],
  theme: {
    extend: {
      // Add app-specific extensions here
    },
  },
  content: [resolve(currentDir, '**/*.{js,vue,ts}'), '../../theme/**/*.{js,css,ts}'],
}

export default config
</file>

<file path="shared-runtime.config.ts">
import { config } from 'dotenv'

config()

export default defineNuxtConfig({
  runtimeConfig: {
    public: {
      strapiUrl: process.env.NUXT_PUBLIC_STRAPI_URL,
      formbricksEnvironment: process.env.NUXT_PUBLIC_FORMBRICKS_ENVIRONMENT,
      formbricksHost: process.env.NUXT_PUBLIC_FORMBRICKS_HOST,
      supabaseUrl: process.env.NUXT_PUBLIC_SUPABASE_URL,
      supabaseKey: process.env.NUXT_PUBLIC_SUPABASE_KEY,
      aeAuthUrl: process.env.NUXT_PUBLIC_AE_AUTH_URL,
      aeLoginUrl: process.env.NUXT_PUBLIC_AE_LOGIN_URL,
      aeAppUrl: process.env.NUXT_PUBLIC_AE_APP_URL,
      aeAdminUrl: process.env.NUXT_PUBLIC_AE_ADMIN_URL,
      aeMonitoringUrl: process.env.NUXT_PUBLIC_AE_MONITORING_URL,
      aeWebsiteUrl: process.env.NUXT_PUBLIC_AE_WEBSITE_URL,
      nodeEnv: process.env.NUXT_PUBLIC_NODE_ENV,
      logLevel: process.env.NUXT_PUBLIC_LOG_LEVEL,
      posthogKey: process.env.NUXT_PUBLIC_POSTHOG_KEY,
      posthogUrl: process.env.NUXT_PUBLIC_POSTHOG_URL,
      studioTokens: process.env.NUXT_PUBLIC_STUDIO_TOKENS,
      scraperUrl: process.env.NUXT_PUBLIC_SCRAPER_URL,
      devHelper: {
        enabled: true,
        features: {
          networkErrorClassifier: true,
          infiniteLoopDetector: true,
          unhandledPromiseRejectionTracker: true,
          environmentConsistencyChecker: true,
        },
      },
    },
    strapiUrl: process.env.NUXT_STRAPI_URL,
    supabaseServiceKey: process.env.NUXT_SUPABASE_SERVICE_KEY,
    googleApiKey: process.env.NUXT_GOOGLE_API_KEY,
    nasaApiKey: process.env.NUXT_NASA_API_KEY,
    openaiApiKey: process.env.NUXT_OPENAI_API_KEY,
    openaiOrg: process.env.NUXT_OPENAI_ORG,
    redisFlushKey: process.env.NUXT_REDIS_FLUSH_KEY,
    scraperKey: process.env.NUXT_SCRAPER_KEY,
    razorpayKey: process.env.NUXT_RAZORPAY_KEY,
    razorpaySecret: process.env.NUXT_RAZORPAY_SECRET,
    razorpayTestKey: process.env.NUXT_RAZORPAY_TEST_KEY,
    razorpayTestSecret: process.env.NUXT_RAZORPAY_TEST_SECRET,
  },
})
</file>

</repository_files>
