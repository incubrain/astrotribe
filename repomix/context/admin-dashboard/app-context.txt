This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-11-21T14:47:20.223Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>

<additional_info>

For more information about Repomix, visit: https://github.com/yamadashy/repomix
</additional_info>

</file_summary>

<repository_structure>
apps/
  admin-dashboard/
    components/
      chart/
        Chart.vue
      chat/
        MessageBar.vue
        SearchResponse.vue
      financial/
        Analytics.vue
        Charts.vue
        Data.vue
        DevOps.vue
        Employees.vue
        Logging.vue
        OpenAI.vue
        Operations.vue
        Payments.vue
        Storage.vue
        Totals.vue
      social/
        Instagram.vue
        Linkedin.vue
        Overview.vue
        Twitter.vue
        Youtube.vue
      tasks/
        TasksCalendar.vue
        TasksForm.vue
        TasksMilestones.vue
        TasksTimeTracker.vue
        TasksUpcoming.vue
      AdminTools.vue
      BusinessPlan.client.vue
      BusinessSystems.vue
      DatabaseMetrics.vue
      ErrorLogViewer.vue
      FileViewer.vue
      GrowthMetrics.vue
      MetricCard.vue
      RedisManagement.vue
      ScriptExecution.vue
      ServerErrors.vue
      ServerJobs.vue
      SpiderAnalytics.vue
      TableGrowth.vue
      Upload.vue
      UserProfiles.vue
    composables/
      createAdminDashboard.ts
      crud-factory.ts
      useFinancials.ts
      useServerAnalytics.client.ts
      useTasks.ts
    content/
      bp/
        1.summary.md
        10.appendix.md
        12.todo.md
        2.company-description.md
        3.market-analysis.md
        4.products.md
        5.marketing.md
        6.management-operations.md
        7.financials.md
        8.risk-analysis.md
        9.roadmap.md
        appendix-data-sources.md
        appendix-financials.md
        appendix-funding.md
        appendix-hires.md
        appendix-legal.md
        appendix-market.md
        appendix-supporting-docs.md
        company-details.md
        company-model.md
        company-objectives.md
        costs.md
        executive-summary.md
        financials-break-even.md
        financials-cashflow.md
        financials-expenses.md
        financials-funding-request.md
        financials-profit-loss.md
        financials-projections.md
        management-customer-support.md
        management-executives.md
        market-competitors.md
        market-opportunities.md
        market-research.md
        market-size.md
        market-swot.md
        market-trends.md
        marketing-collaborations.md
        marketing-customer-aquisition.md
        marketing-funnel.md
        marketing-objectives.md
        marketing-plan.md
        operations-automation.md
        operations-growth-1.md
        operations-growth-2.md
        operations-growth-3.md
        operations-growth-extra.md
        operations-tech.md
        operations-workflow.md
        products-companies.md
        products-courses.md
        products-jobs.md
        products-misc.md
        products-news.md
        products-personalization.md
        products-research.md
        products-search.md
        products-social.md
        products-subscription.md
        products-summaries.md
        products-why-us.md
        risk-customer.md
        risk-financial.md
        risk-market.md
        risk-operational.md
        risk-regulatory.md
        risk-technical.md
        summary-financials.md
        summary-market.md
        summary-milestones.md
        summary-problem-solution.md
        summary-products.md
        summary-usp.md
        summary-vision.md
    financials/
      analytics.ts
      capital.ts
      customers.ts
      dev-ops.ts
      digital-ocean.ts
      employee.ts
      gen-info.ts
      gpt.ts
      helpers.ts
      logging.ts
      marketing.ts
      metrics-users.ts
      metrics.ts
      office.ts
      payments.ts
      software.ts
      storage.ts
      totals.ts
    layouts/
      default.vue
    middleware/
      auth.global.ts
      is-admin.ts
    pages/
      business-systems/
        index.vue
      analytics.vue
      business-plan.vue
      classifier.vue
      errors.vue
      financials.vue
      growth.vue
      index.vue
      redis.vue
      socials.vue
      spider.vue
      timeline.vue
      upload.vue
      users.vue
    plugins/
      dev-helper.ts
    server/
      api/
        classifier/
          [action].ts
        create/
          many-public-users.post.ts
          roles.post.ts
        error/
          [type].ts
        social/
          instagram/
            analytics.ts
          linkedin/
            analytics.ts
          twitter/
            analytics.ts
          youtube/
            analytics.ts
            channel-videos.ts
        update/
          user-profile.post.ts
        users/
          bulk-upload.ts
          update.ts
        _ws.ts
        cron-jobs.post.ts
        execute-script.ts
        goals.ts
        healthy.ts
        milestones.ts
        server-jobs.ts
        store-image.ts
      utils/
        socials/
          getYoutubeContent.ts
          useInstagramAnalytics.ts
          useLinkedinAnalytics.ts
          useTwitterAnalytics.ts
    app.vue
    nuxt.config.ts
    tailwind.config.ts
shared-runtime.config.ts
</repository_structure>

<repository_files>
This section contains the contents of the repository's files.

<file path="apps/admin-dashboard/components/chart/Chart.vue">
<script setup lang="ts">
import type { ChartOptions, TooltipItem, LegendOptions, Plugin } from 'chart.js'

const componentId = useId()

const { formatCurrency, formatStorage, formatNumber } = useFinancials()

const isFullScreen = ref(false)

type DataType = 'currency' | 'storage' | 'number' | 'months' | 'percentage' | 'users' | 'employees'
type AxisType = 'y-2'
type AxisPosiion = 'top' | 'right' | 'bottom' | 'left'
type ScaleType = 'logarithmic' | 'linear'

type ChartType = 'line' | 'bar' | 'doughnut' | 'pie' | 'polarArea' | 'bubble' | 'scatter' | 'radar'

interface Dataset {
  label: string
  data: number[]
  backgroundColor: string
  borderColor?: string
  valueType: DataType
  type?: ChartType
}

interface ChartProps {
  id: number
  scaleType: 'logarithmic' | 'linear'
  title: string
  subtitle: string
  type: ChartType
  data: {
    labels: string[]
    datasets: Array<{
      label: string
      data: number[]
      backgroundColor: string
      valueType: string
      type?: ChartType
      yAxisID?: string
    }>
  }
  info?: Array<{ name: string, value: string }>
}

const props = defineProps<{
  chart: ChartProps
}>()

const preformattedCharts = computed(() => {
  if (!isChartDataReady.value) return null

  return {
    ...props.chart,
    data: {
      ...props.chart.data,
      datasets: props.chart.data.datasets?.map((dataset: Dataset) => {
        const yAxisID = dataset.type ? 'y-2' : 'y'
        return {
          yAxisID,
          ...dataset,
        }
      }),
    },
  }
})

const customPaddingPlugin: Plugin = {
  id: 'customPaddingPlugin',
  beforeInit: (chart: any) => {
    const originalFit = chart.legend.fit
    chart.legend.fit = function fit() {
      // Call the original function and bind scope in order to use `this` correctly inside it
      originalFit.bind(chart.legend)()
      // Change the height as suggested in other answers
      this.height += 20
    }
  },
}

function getFirstNumber(...values: any[]): number {
  for (const value of values) {
    if (typeof value === 'number' && !isNaN(value)) {
      return value
    }
  }
  return 0
}

const chartOptions = computed((): ChartOptions<ChartType> => {
  if (!isChartDataReady.value) return {}

  const isPieChart = props.chart.type === 'pie' || props.chart.type === 'doughnut'

  return {
    indexAxis: props.chart.horizontal ? 'y' : 'x', // Apply horizontal layout if specified
    maintainAspectRatio: false,
    responsive: true,
    plugins: {
      tooltip: {
        mode: 'index',
        intersect: false,
        padding: 10,
        callbacks: {
          label: formatTooltipLabel,
          labelColor: (context: any) => {
            return {
              borderColor: 'black',
              backgroundColor: context.dataset.backgroundColor,
              borderWidth: 2,
              borderRadius: 2,
            }
          },
        },
      },
      legend: generateLegend,
      datalabels: false,
    },
    scales: generateScales(
      preformattedCharts.value.data.datasets,
      props.chart.scaleType,
      isPieChart || props.chart.hideAxes,
    ),
    animations: {
      y: {
        easing: 'easeInOutElastic',
        from: (ctx: any) => {
          if (ctx.type === 'data') {
            if (ctx.mode === 'default' && !ctx.dropped) {
              ctx.dropped = true
              return 0
            }
          }
        },
      },
    },
  }
})

const generateLegend = (): Partial<LegendOptions<ChartType>> => {
  return {
    labels: {
      color: '#fff',
      usePointStyle: false,
      pointStyle: 'rectRounded',
      pointStyleWidth: 10,
      boxWidth: 10,
      boxHeight: 10,
      boxPadding: 20,
      borderRadius: 100,
      font: {
        size: 14,
        weight: 'bold',
      },
    },
    position: 'top',
    align: 'center',
  }
}

const gridColor = 'rgba(255, 255, 255, 0.1)'
function generateScales(
  datasets: Dataset[],
  scaleType: ScaleType = 'linear',
  hideAxes: boolean,
): Record<string, any> {
  if (hideAxes) {
    return {
      x: { display: false },
      y: { display: false },
    }
  }

  const scales: Record<string, any> = {
    x: {
      ticks: { color: '#fff' },
      grid: {
        color: gridColor,
      },
    },
  }

  if (!datasets) return scales

  datasets?.forEach((dataset: Dataset) => {
    const axisId = dataset.yAxisID

    switch (axisId) {
      case 'y-2':
        scales[axisId] = {
          display: true,
          type: 'linear',
          position: 'right',
          title: {
            display: true,
            text: formatTitle(dataset.valueType),
          },
          ticks: {
            callback: dataFormatters[dataset.valueType],
            color: '#fff',
          },
          grid: {
            drawOnChartArea: false, // only want the grid lines for one axis to show up
            color: gridColor,
          },
        }
        break
      default:
        scales.y = {
          display: true,
          type: scaleType,
          title: {
            display: true,
            text: formatTitle(dataset.valueType),
          },
          ticks: {
            callback: dataFormatters[dataset.valueType],
            color: '#fff',
          },
          grid: {
            color: gridColor,
          },
        }
    }
  })

  return scales
}

function formatTitle(dataType: DataType) {
  switch (dataType) {
    case 'currency':
      return 'INR'
    case 'storage':
      return 'GB'
    case 'number':
      return 'Number'
    case 'months':
      return 'Months'
    case 'percentage':
      return 'Percent'
    case 'users':
      return 'Users'
    case 'employees':
      return 'Employees'
    default:
      return ''
  }
}

function formatTooltipLabel(tooltipItem: TooltipItem<'line'>) {
  const dataset = props.chart.data.datasets[tooltipItem.datasetIndex] as Dataset
  const value = tooltipItem.raw as number
  const formattedValue = dataFormatters[dataset.valueType](value)
  return `${dataset.label}: ${formattedValue}`
}

const isChartDataReady = computed(() => {
  return (
    props.chart
    && props.chart.data
    && props.chart.data.datasets
    && props.chart.data.datasets.length > 0
    && props.chart.data.labels
    && props.chart.data.labels.length > 0
  )
})

const dataFormatters = {
  currency: (value: number) => formatCurrency(value, 'INR'), // Example default, can be dynamic
  storage: (value: number) => formatStorage(value),
  number: (value: number) => formatNumber(value, 'INR'),
  users: (value: number) => formatNumber(value, 'USD'),
  employees: (value: number) => formatNumber(value, 'USD'),
  months: (value: number) => {
    return `M${Math.round(value)}`
  },
  percentage: (value: number) => {
    if (Math.abs(value) < 1 && value !== 0) {
      return `${value.toFixed(2)}%` // For small non-zero decimals, show two decimal places
    }
    return `${value.toFixed(2)}%` // Round to whole numbers for clarity
  },
} as const
</script>

<template>
  <div
    v-if="isChartDataReady"
    class="relative flex w-full flex-col gap-4"
  >
    <PrimeDrawer
      v-model:visible="isFullScreen"
      position="full"
      :pt="{ content: 'bg-black w-full flex justify-center items-center' }"
    >
      <template #header>
        <div class="flex flex-col gap-3">
          <h2 class="text-xl font-bold">
            {{ chart.title }}
          </h2>
          <p class="text-sm">
            {{ chart.subtitle }}
          </p>
        </div>
      </template>
      <div
        v-if="chart.info"
        class="border-color w-full max-w-xs rounded-lg border p-4"
      >
        <ul class="pt-4">
          <li
            v-for="info in chart.info"
            :key="info.name"
            class="w-full py-1 text-sm"
          >
            <strong class="text-primary-950">{{ info.name }}: </strong> {{ info.value }}
          </li>
        </ul>
      </div>
      <PrimeChart
        :id="`chart-${componentId}-fullscreen`"
        class="mx-auto h-full max-h-[80vh] w-full max-w-[78vw] flex-grow pt-4"
        :type="chart.type"
        :data="preformattedCharts.data"
        :options="chartOptions"
      />
    </PrimeDrawer>
    <PrimeChart
      :id="`chart-${componentId}`"
      class="flex max-h-[600px] min-h-96 min-w-full items-center justify-center"
      :type="chart.type"
      :data="preformattedCharts.data"
      :plugins="[customPaddingPlugin]"
      :options="chartOptions"
    />
    <div class="border-color flex w-full gap-2 rounded-lg border px-3 py-2">
      <button
        class="border-color flex gap-2 border-r pr-2"
        @click="isFullScreen = true"
      >
        fullscreen
        <Icon
          class="h-6 w-6"
          name="mdi:fullscreen"
        />
      </button>
    </div>
  </div>
</template>

<style></style>
</file>

<file path="apps/admin-dashboard/components/chat/MessageBar.vue">
<script setup lang="ts">
const message = ref('')
const messageInput = ref<Ref | null>(null)

const chunksStore = useChunksStore()

const handleKeyUp = (event: KeyboardEvent) => {
  if (event.key === 'Enter' && !event.shiftKey) {
    sendMessage()
  }
}

type SearchType = 'fts' | 'vector'
const textSearchType = ref('fts' as SearchType)

const toggleTextSearchType = () => {
  if (textSearchType.value === 'fts') {
    textSearchType.value = 'vector'
  } else {
    textSearchType.value = 'fts'
  }
}

const sendMessage = () => {
  if (message.value.trim()) {
    console.log('Sending message:', message.value)
    chunksStore.fetchSimilarDocuments({ search: message.value, searchType: textSearchType.value })
    message.value = ''
  }
}
</script>

<template>
  <div class="mx-auto flex w-full max-w-3xl items-center">
    <div
      class="foreground border-color flex w-full items-center rounded-full border px-2 py-1 pr-2"
    >
      <PrimeButton
        rounded
        :pt="{ root: 'p-5 flex justify-center items-center relative' }"
        severity="secondary"
        @click="toggleTextSearchType"
      >
        <Icon
          :name="textSearchType === 'fts' ? 'mdi:card-text-outline' : 'mdi:format-list-numbered'"
          class="absolute"
          size="24px"
        />
      </PrimeButton>
      <PrimeTextarea
        ref="messageInput"
        v-model="message"
        auto-resize
        placeholder="Ask Your Question..."
        class="flex max-h-[120px] w-full items-center justify-center bg-transparent px-4 py-2 outline-none"
        :pt="{ root: 'border-none' }"
        @keyup.enter="handleKeyUp"
      />
      <PrimeButton
        rounded
        :pt="{ root: 'p-5 flex justify-center items-center relative' }"
        severity="secondary"
      >
        <Icon
          name="mdi:send"
          class="absolute text-white"
          size="24px"
        />
      </PrimeButton>
    </div>
  </div>
</template>

<style scoped>
.p-inputtextarea {
  overflow: scroll !important;
}
</style>
</file>

<file path="apps/admin-dashboard/components/chat/SearchResponse.vue">
<script setup lang="ts">
import { useChangeCase } from '@vueuse/integrations/useChangeCase'
import katex from 'katex'

const renderLatex = (text: string) => {
  return text.replace(/(\$.*?\$)/g, (match) => {
    try {
      return katex.renderToString(match.replace(/\$/g, ''), {
        throwOnError: true,
      })
    } catch (error) {
      console.error('Error rendering LaTeX:', error)
      return `failed(${match})`
    }
  })
}

const chunksStore = useChunksStore()
const { similarChunks } = storeToRefs(chunksStore)
</script>

<template>
  <div
    class="padded-x border-color mx-auto grid h-full max-h-[65vh] w-full flex-grow grid-cols-1 gap-4 overflow-y-scroll rounded-md border p-4 md:grid-cols-2 lg:gap-8 lg:p-8 xl:grid-cols-3"
  >
    <div
      v-for="doc in similarChunks"
      :key="doc.id"
      class="border-color background h-full max-h-[600px] min-h-[600px] space-y-4 overflow-scroll text-wrap rounded-lg border p-4"
    >
      <h4 class="text-xl font-semibold">
        {{ useChangeCase(doc.title, 'capitalCase').value }}
      </h4>
      <div v-html="renderLatex(doc.abstract)"></div>
    </div>
  </div>
</template>

<style>
.katex .katex-html {
  display: none;
}
</style>
</file>

<file path="apps/admin-dashboard/components/financial/Analytics.vue">
<script setup lang="ts">
const { months, analytics, rgba } = useFinancials()

console.log('dataAnalytics', analytics.value, months.value)

const charts = computed(() => {
  if (!months.value || !analytics.value) {
    return []
  }

  return [
    {
      title: 'Analytics Costs Breakdown',
      subtitle: 'Shows the breakdown of analytics costs for the selected timeperiod.',
      type: 'bar',
      data: {
        labels: [
          'Events Cost',
          'Recordings Cost',
          'Feature Requests Cost',
          'Survey Responses Cost',
        ],
        datasets: [
          {
            label: 'Total Analytics Costs',
            valueType: 'currency',
            data: [
              analytics.value.flatMap((month) => month.events.cost).reduce((a, b) => a + b, 0),
              analytics.value.flatMap((month) => month.recordings.cost).reduce((a, b) => a + b, 0),
              analytics.value
                .flatMap((month) => month.featureRequests.cost)
                .reduce((a, b) => a + b, 0),
              analytics.value
                .flatMap((month) => month.surveyResponses.cost)
                .reduce((a, b) => a + b, 0),
            ],
            backgroundColor: [
              rgba('lightGreen', 0.5),
              rgba('darkBlue', 0.5),
              rgba('darkBlue', 0.5),
              rgba('darkBlue', 0.5),
            ],
          },
        ],
      },
    },
    {
      title: 'Total Analytics Cost and Breakdown',
      subtitle: 'Shows the total analytics cost and its breakdown over time.',
      type: 'line',
      data: {
        labels: months.value,
        datasets: [
          {
            label: 'Events Cost',
            valueType: 'currency',
            data: analytics.value.flatMap((month) => month.events.cost),
            backgroundColor: rgba('black', 1),
            borderColor: rgba('lightBlue', 0.5),
          },
          {
            label: 'Recordings Cost',
            valueType: 'currency',
            data: analytics.value.flatMap((month) => month.recordings.cost),
            backgroundColor: rgba('black', 1),
            borderColor: rgba('darkRed', 0.5),
          },
          {
            label: 'Feature Requests Cost',
            valueType: 'currency',
            data: analytics.value.flatMap((month) => month.featureRequests.cost),
            backgroundColor: rgba('black', 1),
            borderColor: rgba('lightGreen', 0.5),
          },
          {
            label: 'Survey Responses Cost',
            valueType: 'currency',
            data: analytics.value.flatMap((month) => month.surveyResponses.cost),
            backgroundColor: rgba('black', 1),
            borderColor: rgba('lightRed', 0.5),
          },
          {
            label: 'Total Cost',
            valueType: 'currency',
            type: 'bar',
            data: analytics.value.flatMap((month) => month.total),
            backgroundColor: rgba('darkBlue', 0.5),
          },
        ],
      },
    },
    {
      title: 'Usage Metrics Over Time',
      subtitle:
        'Tracks the usage metrics for events, recordings, feature requests, and survey responses over time.',
      type: 'line',
      data: {
        labels: months.value,
        datasets: [
          {
            label: 'Events Usage',
            valueType: 'number',
            data: analytics.value.flatMap((month) => month.events.usage),
            borderColor: rgba('lightBlue', 0.5),
            backgroundColor: rgba('lightBlue', 0.2),
          },
          {
            label: 'Recordings Usage',
            valueType: 'number',
            data: analytics.value.flatMap((month) => month.recordings.usage),
            borderColor: rgba('darkRed', 0.5),
            backgroundColor: rgba('darkRed', 0.2),
          },
          {
            label: 'Feature Requests Usage',
            valueType: 'number',
            data: analytics.value.flatMap((month) => month.featureRequests.usage),
            borderColor: rgba('lightGreen', 0.5),
            backgroundColor: rgba('lightGreen', 0.2),
          },
          {
            label: 'Survey Responses Usage',
            valueType: 'number',
            data: analytics.value.flatMap((month) => month.surveyResponses.usage),
            borderColor: rgba('lightRed', 0.5),
            backgroundColor: rgba('lightRed', 0.2),
          },
        ],
      },
    },
    {
      title: 'Cost Efficiency Over Time',
      subtitle: 'Shows the cost efficiency by comparing costs to usage over time.',
      type: 'line',
      data: {
        labels: months.value,
        datasets: [
          {
            label: 'Events Cost Efficiency',
            valueType: 'currency',
            data: analytics.value.flatMap((month) => month.events.cost / month.events.usage),
            borderColor: rgba('lightBlue', 0.5),
            backgroundColor: rgba('lightBlue', 0.2),
          },
          {
            label: 'Recordings Cost Efficiency',
            valueType: 'currency',
            data: analytics.value.flatMap(
              (month) => month.recordings.cost / month.recordings.usage,
            ),
            borderColor: rgba('darkRed', 0.5),
            backgroundColor: rgba('darkRed', 0.2),
          },
          {
            label: 'Feature Requests Cost Efficiency',
            valueType: 'currency',
            data: analytics.value.flatMap(
              (month) => month.featureRequests.cost / month.featureRequests.usage,
            ),
            borderColor: rgba('lightGreen', 0.5),
            backgroundColor: rgba('lightGreen', 0.2),
          },
          {
            label: 'Survey Responses Cost Efficiency',
            valueType: 'currency',
            data: analytics.value.flatMap(
              (month) => month.surveyResponses.cost / month.surveyResponses.usage,
            ),
            borderColor: rgba('lightRed', 0.5),
            backgroundColor: rgba('lightRed', 0.2),
          },
        ],
      },
    },
  ]
})
</script>

<template>
  <FinancialCharts :charts="charts" />
</template>

<style scoped></style>
</file>

<file path="apps/admin-dashboard/components/financial/Charts.vue">
<script setup lang="ts">
defineProps<{
  charts: Chart
}>()
</script>

<template>
  <div class="grid h-full w-full grid-cols-1 gap-4 xl:gap-12">
    <div
      v-for="(chart, index) in charts"
      :key="`financial-chart-${index}`"
      class="flex flex-col gap-4 lg:flex-row xl:gap-12"
    >
      <div
        class="border-color w-full min-w-[260px] space-y-4 rounded-lg border p-4 lg:max-w-[360px]"
      >
        <h3 class="text-2xl font-semibold text-primary-600">
          {{ chart.title }}
        </h3>
        <p class="text-lg">
          {{ chart.subtitle }}
        </p>
      </div>
      <LazyChart
        class="flex h-full w-full items-center justify-center py-8"
        :chart="chart"
      />
    </div>
  </div>
</template>

<style scoped></style>
</file>

<file path="apps/admin-dashboard/components/financial/Data.vue">
<script setup lang="ts">
const {
  advertising,
  analytics,
  capital,
  employees,
  logging,
  metrics,
  openAI,
  payments,
  storage,
  customers,
  totals,
  rgba,
  formatNumber,
} = useFinancials()

const allDatasets = [
  { name: 'Customers', data: customers.value },
  { name: 'Metrics', data: metrics.value },
  { name: 'Storage', data: storage.value },
  { name: 'OpenAI', data: openAI.value },
  { name: 'Analytics', data: analytics.value },
  { name: 'Employees', data: employees.value },
  { name: 'Capital', data: capital.value },
  { name: 'Advertising', data: advertising.value },
  { name: 'Logging', data: logging.value },
  { name: 'Payments', data: payments.value },
  { name: 'Totals', data: totals.value },
]

function getType(value: any): string {
  return Object.prototype.toString.call(value).slice(8, -1)
}

function traverseObject(
  obj: any,
): Record<string, Array<{ path: string, value: any, type: string }>> {
  const result: Record<string, Array<{ path: string, value: any, type: string }>> = {}
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      const value = obj[key]
      if (
        Array.isArray(value)
        && value.length > 0
        && typeof value[0] === 'object'
        && value[0] !== null
      ) {
        const childResults = traverseNestedObject(value[0], key)
        result[key] = childResults
      } else if (typeof value === 'object' && value !== null) {
        const childResults = traverseNestedObject(value, key)
        result[key] = childResults
      } else {
        if (!result['Root']) {
          result['Root'] = []
        }
        result['Root'].push({
          path: key,
          value: value,
          type: getType(value),
        })
      }
    }
  }
  return result
}

function traverseNestedObject(
  obj: any,
  parentKey: string,
): Array<{ path: string, value: any, type: string }> {
  let result: Array<{ path: string, value: any, type: string }> = []
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      const newPath = `${parentKey}.${key}`
      const value = obj[key]
      if (
        Array.isArray(value)
        && value.length > 0
        && typeof value[0] === 'object'
        && value[0] !== null
      ) {
        result = result.concat(traverseNestedObject(value[0], newPath))
      } else if (typeof value === 'object' && value !== null) {
        result = result.concat(traverseNestedObject(value, newPath))
      } else {
        result.push({
          path: newPath,
          value: value,
          type: getType(value),
        })
      }
    }
  }
  return result
}

const columnsCount = 3
const columns = computed(() => {
  const result = Array.from({ length: columnsCount }, () => [])
  allDatasets.forEach((dataset, index) => {
    result[index % columnsCount].push(dataset)
  })
  return result
})

function copyToClipboard(text: string) {
  navigator.clipboard.writeText(text).then(
    () => {
      console.log(`Copied to clipboard: ${text}`)
    },
    (err) => {
      console.error('Could not copy text: ', err)
    },
  )
}
</script>

<template>
  <div class="grid grid-cols-1 gap-2 p-4 md:grid-cols-2 md:gap-4 xl:grid-cols-3 xl:p-8">
    <PrimeAccordion
      v-for="(column, columnIndex) in columns"
      :key="`masonry-column-${columnIndex}`"
      class="space-y-4"
      :value="['0']"
      multiple
    >
      <PrimeAccordionPanel
        v-for="(dataset, index) in column"
        :key="`metrics-dataset-${columnIndex}-${index}`"
        class="border-color rounded-lg border p-4"
        :value="`${index}`"
      >
        <PrimeAccordionHeader>
          <h2 class="text-2xl font-bold text-primary-600">
            {{ dataset.name }}
          </h2>
        </PrimeAccordionHeader>
        <PrimeAccordionContent v-if="!!dataset.data">
          <div
            v-for="(group, parent) in traverseObject(dataset.data[0])"
            :key="`group-${dataset.name}-${parent}`"
            class="border-color border-b pb-4 pt-2 last:border-b-0 last:pb-0"
          >
            <p class="text-xl font-semibold text-primary-600">
              {{ parent || 'Total' }}
            </p>
            <div
              v-for="(entry, idx) in group"
              :key="`entry-${dataset.name}-${idx}`"
              class="flex items-center justify-between"
            >
              <span class="text-sm">
                <strong class="font-semibold">
                  {{ entry.path.replace(`${entry.path.split('.')[0]}.`, '') }} -
                </strong>
                {{ entry.type }} | {{ formatNumber(entry.value) }}
              </span>
              <button
                class=""
                @click="copyToClipboard(entry.path)"
              >
                <Icon
                  name="mdi:content-copy"
                  size="24px"
                />
              </button>
            </div>
          </div>
        </PrimeAccordionContent>
      </PrimeAccordionPanel>
    </PrimeAccordion>
  </div>
</template>

<style scoped></style>
</file>

<file path="apps/admin-dashboard/components/financial/DevOps.vue">
<script setup lang="ts">
const { months, devOps, rgba } = useFinancials()

const breakdown = computed(() => devOps?.value.flatMap((m) => m.vercel.cost.breakdown))

const charts = computed(() => {
  if (!months.value || !devOps.value) {
    return []
  }

  return [
    {
      title: 'Vercel Costs Breakdown',
      subtitle: 'Shows the breakdown of Vercel costs for the selected time period.',
      type: 'bar',
      data: {
        labels: [
          'Base Cost',
          'Data Transfer Cost',
          'Origin Transfer Cost',
          'Edge Requests Cost',
          'Middleware Invocations Cost',
          'Function Invocations Cost',
          'Function Duration Cost',
          'Edge Function Executions Cost',
          'Data Cache Reads Cost',
          'Data Cache Writes Cost',
          'Edge Config Reads Cost',
          'Edge Config Writes Cost',
        ],
        datasets: [
          {
            label: 'Total Vercel Costs',
            valueType: 'currency',
            data: [
              breakdown.value.flatMap((m) => m.base).reduce((a, b) => a + b, 0),
              breakdown.value.flatMap((m) => m.dataTransfer).reduce((a, b) => a + b, 0),
              breakdown.value.flatMap((m) => m.originTransfer).reduce((a, b) => a + b, 0),
              breakdown.value.flatMap((m) => m.edgeRequests).reduce((a, b) => a + b, 0),
              breakdown.value.flatMap((m) => m.middlewareInvocations).reduce((a, b) => a + b, 0),
              breakdown.value.flatMap((m) => m.functionInvocations).reduce((a, b) => a + b, 0),
              breakdown.value.flatMap((m) => m.functionDuration).reduce((a, b) => a + b, 0),
              breakdown.value.flatMap((m) => m.edgeFunctionExecutions).reduce((a, b) => a + b, 0),
              breakdown.value.flatMap((m) => m.dataCacheReads).reduce((a, b) => a + b, 0),
              breakdown.value.flatMap((m) => m.dataCacheWrites).reduce((a, b) => a + b, 0),
              breakdown.value.flatMap((m) => m.edgeConfigReads).reduce((a, b) => a + b, 0),
              breakdown.value.flatMap((m) => m.edgeConfigWrites).reduce((a, b) => a + b, 0),
            ],
            backgroundColor: [
              rgba('lightGreen', 0.5),
              rgba('darkBlue', 0.5),
              rgba('darkBlue', 0.5),
              rgba('darkBlue', 0.5),
              rgba('darkBlue', 0.5),
              rgba('darkBlue', 0.5),
              rgba('darkBlue', 0.5),
              rgba('darkBlue', 0.5),
              rgba('darkBlue', 0.5),
              rgba('darkBlue', 0.5),
              rgba('darkBlue', 0.5),
              rgba('darkBlue', 0.5),
            ],
          },
        ],
      },
    },
    {
      title: 'Total DevOps Cost and Breakdown',
      subtitle: 'Shows the total DevOps cost and its breakdown over time.',
      type: 'line',
      data: {
        labels: months.value,
        datasets: [
          {
            label: 'Base Cost',
            valueType: 'currency',
            data: devOps.value.flatMap((month) => month.vercel.cost.base),
            borderColor: rgba('lightCyan', 0.5),
          },
          {
            label: 'Data Transfer Cost',
            valueType: 'currency',
            data: devOps.value.flatMap((month) => month.vercel.cost.dataTransfer),
            borderColor: rgba('darkRed', 0.5),
          },
          {
            label: 'Origin Transfer Cost',
            valueType: 'currency',
            data: devOps.value.flatMap((month) => month.vercel.cost.originTransfer),
            borderColor: rgba('lightGreen', 0.5),
          },
          {
            label: 'Edge Requests Cost',
            valueType: 'currency',
            data: devOps.value.flatMap((month) => month.vercel.cost.edgeRequests),
            borderColor: rgba('lightRed', 0.5),
          },
          {
            label: 'Middleware Invocations Cost',
            valueType: 'currency',
            data: devOps.value.flatMap((month) => month.vercel.cost.middlewareInvocations),
            borderColor: rgba('darkGreen', 0.5),
          },
          {
            label: 'Function Invocations Cost',
            valueType: 'currency',
            data: devOps.value.flatMap((month) => month.vercel.cost.functionInvocations),
            borderColor: rgba('darkOrange', 0.5),
          },
          {
            label: 'Function Duration Cost',
            valueType: 'currency',
            data: devOps.value.flatMap((month) => month.vercel.cost.functionDuration),
            borderColor: rgba('darkPurple', 0.5),
          },
          {
            label: 'Edge Function Executions Cost',
            valueType: 'currency',
            data: devOps.value.flatMap((month) => month.vercel.cost.edgeFunctionExecutions),
            borderColor: rgba('darkPink', 0.5),
          },
          {
            label: 'Data Cache Reads Cost',
            valueType: 'currency',
            data: devOps.value.flatMap((month) => month.vercel.cost.dataCacheReads),
            borderColor: rgba('darkCyan', 0.5),
          },
          {
            label: 'Data Cache Writes Cost',
            valueType: 'currency',
            data: devOps.value.flatMap((month) => month.vercel.cost.dataCacheWrites),
            borderColor: rgba('darkBlue', 0.5),
          },
          {
            label: 'Edge Config Reads Cost',
            valueType: 'currency',
            data: devOps.value.flatMap((month) => month.vercel.cost.edgeConfigReads),
            borderColor: rgba('darkBrown', 0.5),
          },
          {
            label: 'Edge Config Writes Cost',
            valueType: 'currency',
            data: devOps.value.flatMap((month) => month.vercel.cost.edgeConfigWrites),
            borderColor: rgba('darkBlue', 0.5),
          },
          {
            label: 'Total Cost',
            type: 'bar',
            valueType: 'currency',
            data: devOps.value.flatMap((month) => month.vercel.cost.total),
            backgroundColor: rgba('darkBlue', 0.3),
          },
        ],
      },
    },
    {
      title: 'Vercel Usage Metrics Over Time',
      subtitle: 'Tracks the usage metrics for various Vercel components over time.',
      type: 'line',
      data: {
        labels: months.value,
        datasets: [
          {
            label: 'Data Transfer GB',
            valueType: 'storage',
            data: devOps.value.flatMap((m) => m.vercel.usage.dataTransferGB),
            borderColor: rgba('lightBlue', 0.5),
            backgroundColor: rgba('lightBlue', 0.2),
          },
          {
            label: 'Origin Transfer GB',
            valueType: 'storage',
            data: devOps.value.flatMap((m) => m.vercel.usage.originTransferGB),
            borderColor: rgba('darkRed', 0.5),
            backgroundColor: rgba('darkRed', 0.2),
          },
          {
            label: 'Edge Requests',
            valueType: 'number',
            data: devOps.value.flatMap((m) => m.vercel.usage.edgeRequests),
            borderColor: rgba('lightGreen', 0.5),
            backgroundColor: rgba('lightGreen', 0.2),
          },
          {
            label: 'Middleware Invocations',
            valueType: 'number',
            data: devOps.value.flatMap((m) => m.vercel.usage.middlewareInvocations),
            borderColor: rgba('lightRed', 0.5),
            backgroundColor: rgba('lightRed', 0.2),
          },
          {
            label: 'Function Invocations',
            valueType: 'number',
            data: devOps.value.flatMap((m) => m.vercel.usage.functionInvocations),
            borderColor: rgba('darkOrange', 0.5),
            backgroundColor: rgba('darkOrange', 0.2),
          },
          {
            label: 'Function Duration GB Hours',
            valueType: 'number',
            data: devOps.value.flatMap((m) => m.vercel.usage.functionDurationGBHours),
            borderColor: rgba('darkPurple', 0.5),
            backgroundColor: rgba('darkPurple', 0.2),
          },
          {
            label: 'Edge Function Executions',
            valueType: 'number',
            data: devOps.value.flatMap((m) => m.vercel.usage.edgeFunctionExecutions),
            borderColor: rgba('darkPink', 0.5),
            backgroundColor: rgba('darkPink', 0.2),
          },
          {
            label: 'Data Cache Reads',
            valueType: 'number',
            data: devOps.value.flatMap((m) => m.vercel.usage.dataCacheReads),
            borderColor: rgba('darkCyan', 0.5),
            backgroundColor: rgba('darkCyan', 0.2),
          },
          {
            label: 'Data Cache Writes',
            valueType: 'number',
            data: devOps.value.flatMap((m) => m.vercel.usage.dataCacheWrites),
            borderColor: rgba('darkBlue', 0.5),
            backgroundColor: rgba('darkBlue', 0.2),
          },
          {
            label: 'Edge Config Reads',
            valueType: 'number',
            data: devOps.value.flatMap((m) => m.vercel.usage.edgeConfigReads),
            borderColor: rgba('darkBrown', 0.5),
            backgroundColor: rgba('darkBrown', 0.2),
          },
          {
            label: 'Edge Config Writes',
            valueType: 'number',
            data: devOps.value.flatMap((m) => m.vercel.usage.edgeConfigWrites),
            borderColor: rgba('darkBlue', 0.5),
            backgroundColor: rgba('darkBlue', 0.2),
          },
        ],
      },
    },
    {
      title: 'Function Invocations and Duration',
      subtitle: 'Tracks the number of function invocations, their duration, and costs over time.',
      type: 'line',
      data: {
        labels: months.value,
        datasets: [
          {
            label: 'Function Invocations',
            valueType: 'number',
            data: devOps.value.flatMap((m) => m.vercel.usage.functionInvocations),
            borderColor: rgba('darkBlue', 0.5),
          },
          {
            label: 'Function Duration (GB Hours)',
            valueType: 'number',
            data: devOps.value.flatMap((m) => m.vercel.usage.functionDurationGBHours),
            borderColor: rgba('lightGreen', 0.5),
          },
          {
            label: 'Function Invocations Cost',
            type: 'bar',
            valueType: 'currency',
            data: devOps.value.flatMap((m) => m.vercel.cost.functionInvocations),
            backgroundColor: rgba('lightRed', 0.5),
          },
          {
            label: 'Function Duration Cost',
            type: 'bar',
            valueType: 'currency',
            data: devOps.value.flatMap((m) => m.vercel.cost.functionDuration),
            backgroundColor: rgba('darkOrange', 0.5),
          },
        ],
      },
    },
    {
      title: 'Edge Function Executions and Data Cache Operations',
      subtitle:
        'Tracks the number of edge function executions, data cache reads/writes, and costs over time.',
      type: 'line',
      data: {
        labels: months.value,
        datasets: [
          {
            label: 'Edge Function Executions',
            valueType: 'number',
            data: devOps.value.flatMap((m) => m.vercel.usage.edgeFunctionExecutions),
            borderColor: rgba('lightBlue', 0.5),
            backgroundColor: rgba('lightBlue', 0.2),
          },
          {
            label: 'Data Cache Reads',
            valueType: 'number',
            data: devOps.value.flatMap((m) => m.vercel.usage.dataCacheReads),
            borderColor: rgba('lightGreen', 0.5),
            backgroundColor: rgba('lightGreen', 0.2),
          },
          {
            label: 'Data Cache Writes',
            valueType: 'number',
            data: devOps.value.flatMap((m) => m.vercel.usage.dataCacheWrites),
            borderColor: rgba('lightRed', 0.5),
            backgroundColor: rgba('lightRed', 0.2),
          },
          {
            label: 'Edge Function Executions Cost',
            valueType: 'currency',
            data: devOps.value.flatMap((m) => m.vercel.cost.edgeFunctionExecutions),
            borderColor: rgba('darkOrange', 0.5),
            backgroundColor: rgba('darkOrange', 0.2),
          },
          {
            label: 'Data Cache Reads Cost',
            valueType: 'currency',
            data: devOps.value.flatMap((m) => m.vercel.cost.dataCacheReads),
            borderColor: rgba('darkPurple', 0.5),
            backgroundColor: rgba('darkPurple', 0.2),
          },
          {
            label: 'Data Cache Writes Cost',
            valueType: 'currency',
            data: devOps.value.flatMap((m) => m.vercel.cost.dataCacheWrites),
            borderColor: rgba('darkPink', 0.5),
            backgroundColor: rgba('darkPink', 0.2),
          },
        ],
      },
    },
    {
      title: 'Total Usage Metrics',
      subtitle: 'Provides an overview of all significant usage metrics over time.',
      type: 'line',
      data: {
        labels: months.value,
        datasets: [
          {
            label: 'Data Transfer GB',
            type: 'bar',
            valueType: 'storage',
            data: devOps.value.flatMap((m) => m.vercel.usage.dataTransferGB),
            borderColor: rgba('lightBlue', 0.5),
            backgroundColor: rgba('lightBlue', 0.2),
          },
          {
            label: 'Origin Transfer GB',
            type: 'bar',
            valueType: 'storage',
            data: devOps.value.flatMap((m) => m.vercel.usage.originTransferGB),
            borderColor: rgba('lightGreen', 0.5),
            backgroundColor: rgba('lightGreen', 0.2),
          },
          {
            label: 'Edge Requests',
            valueType: 'number',
            data: devOps.value.flatMap((m) => m.vercel.usage.edgeRequests),
            borderColor: rgba('lightRed', 0.5),
            backgroundColor: rgba('lightRed', 0.2),
          },
          {
            label: 'Middleware Invocations',
            valueType: 'number',
            data: devOps.value.flatMap((m) => m.vercel.usage.middlewareInvocations),
            borderColor: rgba('darkOrange', 0.5),
            backgroundColor: rgba('darkOrange', 0.2),
          },
          {
            label: 'Function Invocations',
            valueType: 'number',
            data: devOps.value.flatMap((m) => m.vercel.usage.functionInvocations),
            borderColor: rgba('darkPurple', 0.5),
            backgroundColor: rgba('darkPurple', 0.2),
          },
        ],
      },
    },

    {
      title: 'Cost Breakdown by Function Type',
      subtitle: 'Shows the cost breakdown for different Vercel functions over time.',
      type: 'bar',
      data: {
        labels: months.value,
        datasets: [
          {
            label: 'Edge Requests Cost',
            valueType: 'currency',
            data: devOps.value.flatMap((month) => month.vercel.cost.edgeRequests),
            backgroundColor: rgba('lightBlue', 0.5),
          },
          {
            label: 'Middleware Invocations Cost',
            valueType: 'currency',
            data: devOps.value.flatMap((month) => month.vercel.cost.middlewareInvocations),
            backgroundColor: rgba('lightGreen', 0.5),
          },
          {
            label: 'Function Invocations Cost',
            valueType: 'currency',
            data: devOps.value.flatMap((month) => month.vercel.cost.functionInvocations),
            backgroundColor: rgba('lightRed', 0.5),
          },
          {
            label: 'Function Duration Cost',
            valueType: 'currency',
            data: devOps.value.flatMap((month) => month.vercel.cost.functionDuration),
            backgroundColor: rgba('darkOrange', 0.5),
          },
          {
            label: 'Data Cache Reads Cost',
            valueType: 'currency',
            data: devOps.value.flatMap((month) => month.vercel.cost.dataCacheReads),
            backgroundColor: rgba('darkPurple', 0.5),
          },
        ],
      },
    },
    {
      title: 'Data Transfer and Processing Costs',
      subtitle: 'Shows the costs associated with data transfer and processing over time.',
      type: 'line',
      data: {
        labels: months.value,
        datasets: [
          {
            label: 'Data Transfer Cost',
            valueType: 'currency',
            data: devOps.value.flatMap((month) => month.vercel.cost.dataTransfer),
            borderColor: rgba('lightBlue', 0.5),
            backgroundColor: rgba('lightBlue', 0.2),
          },
          {
            label: 'Origin Transfer Cost',
            valueType: 'currency',
            data: devOps.value.flatMap((month) => month.vercel.cost.originTransfer),
            borderColor: rgba('lightGreen', 0.5),
            backgroundColor: rgba('lightGreen', 0.2),
          },
          {
            label: 'Function Duration Cost',
            valueType: 'currency',
            data: devOps.value.flatMap((month) => month.vercel.cost.functionDuration),
            borderColor: rgba('lightRed', 0.5),
            backgroundColor: rgba('lightRed', 0.2),
          },
          {
            label: 'Data Cache Writes Cost',
            valueType: 'currency',
            data: devOps.value.flatMap((month) => month.vercel.cost.dataCacheWrites),
            borderColor: rgba('darkOrange', 0.5),
            backgroundColor: rgba('darkOrange', 0.2),
          },
        ],
      },
    },
  ]
})
</script>

<template>
  <FinancialCharts :charts="charts" />
</template>

<style scoped></style>
</file>

<file path="apps/admin-dashboard/components/financial/Employees.vue">
<script setup lang="ts">
const {
  totals,
  months,
  employees,
  software,
  office,
  storage,
  digitalOcean,
  devOps,
  logging,
  findLargestValue,
  rgba,
} = useFinancials()

const charts = computed(() => {
  if (!months.value || !employees.value) {
    return []
  }

  return [
    {
      title: 'Monthly Expenses Breakdown',
      subtitle:
        'Provides transparency on how funds are being allocated, reassuring investors about cost management and spending efficiency.',
      type: 'bar',
      data: {
        labels: months.value,
        datasets: [
          {
            label: 'Marketing',
            valueType: 'currency',
            stack: 'stack1',
            data: totals.value.flatMap((m) => m.marketing),
            backgroundColor: rgba('darkBrown', 0.5),
          },
          {
            label: 'Employee Total Cost',
            valueType: 'currency',
            stack: 'stack1',
            data: totals.value.flatMap((m) => m.employees),
            backgroundColor: rgba('lightGreen', 0.5),
          },
          {
            label: 'OpenAI Total Cost',
            valueType: 'currency',
            stack: 'stack1',
            data: totals.value.flatMap((m) => m.openAI),
            backgroundColor: rgba('darkOrange', 0.5),
          },
          {
            label: 'Office Total Cost',
            valueType: 'currency',
            stack: 'stack1',
            data: totals.value.flatMap((m) => m.office),
            backgroundColor: rgba('darkPurple', 0.5),
          },
          {
            label: 'Storage Total Cost',
            valueType: 'currency',
            stack: 'stack1',
            data: totals.value.flatMap((m) => m.storage),
            backgroundColor: rgba('darkBlue', 0.5),
          },
          {
            label: 'Digital Ocean Total Cost',
            valueType: 'currency',
            stack: 'stack1',
            data: totals.value.flatMap((m) => m.digitalOcean),
            backgroundColor: rgba('lightOrange', 0.5),
          },
          {
            label: 'Logging Total Cost',
            valueType: 'currency',
            stack: 'stack1',
            data: totals.value.flatMap((m) => m.logging),
            backgroundColor: rgba('darkGray', 0.5),
          },
          {
            label: 'DevOps Total Cost',
            valueType: 'currency',
            stack: 'stack1',
            data: totals.value.flatMap((m) => m.devOps),
            backgroundColor: rgba('darkRed', 0.5),
          },
          {
            label: 'Loan Total Cost',
            valueType: 'currency',
            stack: 'stack1',
            data: totals.value.flatMap((m) => m.loan),
            backgroundColor: rgba('darkGreen', 0.5),
          },
        ],
      },
    },
    {
      title: 'Employee Costs',
      subtitle: 'Shows the employee cost by type for the selected timeperiod',
      type: 'bar',
      data: {
        labels: [
          'Core Total Salary',
          'Core Total Extras',
          'Support Total Salary',
          'Support Total Extras',
          'Experts Total Salary',
          'Experts Total Extras',
          'Founders Total Salary',
          'Founders Total Extras',
          'Software Total Cost',
        ],
        datasets: [
          {
            label: 'Employee Expenses Breakdown',
            valueType: 'currency',
            data: [
              employees.value.flatMap((m) => m.core.totalSalary).reduce((a, b) => a + b, 0),
              employees.value.flatMap((m) => m.core.totalExtras).reduce((a, b) => a + b, 0),
              employees.value.flatMap((m) => m.support.totalSalary).reduce((a, b) => a + b, 0),
              employees.value.flatMap((m) => m.support.totalExtras).reduce((a, b) => a + b, 0),
              employees.value.flatMap((m) => m.experts.totalSalary).reduce((a, b) => a + b, 0),
              employees.value.flatMap((m) => m.experts.totalExtras).reduce((a, b) => a + b, 0),
              employees.value.flatMap((m) => m.founders.totalSalary).reduce((a, b) => a + b, 0),
              employees.value.flatMap((m) => m.founders.totalExtras).reduce((a, b) => a + b, 0),
              software.value.flatMap((m) => m.totalCost).reduce((a, b) => a + b, 0),
            ],
            backgroundColor: [
              rgba('lightGreen', 0.5),
              rgba('lightGreen', 0.5),
              rgba('lightBlue', 0.5),
              rgba('lightBlue', 0.5),
              rgba('darkRed', 0.5),
              rgba('darkRed', 0.5),
              rgba('lightOrange', 0.5),
              rgba('lightOrange', 0.5),
              rgba('darkGray', 0.5),
            ],
          },
        ],
      },
    },
    {
      title: 'Employee Count',
      subtitle: 'Shows the MAX employee count for each type for the selected timeperiod',
      type: 'bar',
      data: {
        labels: [
          'Founders Total Count',
          'Support Total Count',
          'Core Total Count',
          'Experts Total Count',
        ],
        datasets: [
          {
            label: 'Employee Counts',
            valueType: 'employees',
            data: [
              findLargestValue(employees.value.flatMap((month) => month.founders.employeeCount)),
              findLargestValue(employees.value.flatMap((month) => month.support.employeeCount)),
              findLargestValue(employees.value.flatMap((month) => month.core.employeeCount)),
              findLargestValue(employees.value.flatMap((month) => month.experts.employeeCount)),
            ],
            backgroundColor: [
              rgba('darkRed', 0.5),
              rgba('lightPurple', 0.5),
              rgba('lightOrange', 0.5),
              rgba('darkGray', 0.5),
            ],
          },
        ],
      },
    },
  ]
})
</script>

<template>
  <FinancialCharts :charts="charts" />
</template>

<style scoped></style>
</file>

<file path="apps/admin-dashboard/components/financial/Logging.vue">
<script setup lang="ts">
const { months, logging, rgba } = useFinancials()

const charts = computed(() => {
  if (!months.value || !logging.value) {
    return []
  }

  return [
    {
      title: 'Logging Costs Breakdown',
      subtitle: 'Shows the breakdown of logging costs for the selected time period.',
      type: 'bar',
      data: {
        labels: ['Ingested Cost', 'Retention Cost', 'Metrics Cost', 'Analytics Cost'],
        datasets: [
          {
            label: 'Total Logging Costs',
            valueType: 'currency',
            data: [
              logging.value.flatMap((month) => month.ingested).reduce((a, b) => a + b, 0),
              logging.value.flatMap((month) => month.retention).reduce((a, b) => a + b, 0),
              logging.value.flatMap((month) => month.metrics).reduce((a, b) => a + b, 0),
              logging.value.flatMap((month) => month.analytics).reduce((a, b) => a + b, 0),
            ],
            backgroundColor: [
              rgba('lightGreen', 0.5),
              rgba('darkBlue', 0.5),
              rgba('darkBlue', 0.5),
              rgba('darkBlue', 0.5),
            ],
          },
        ],
      },
    },
    {
      title: 'Ingested vs. Retention Costs',
      subtitle: 'Comparison of ingested and retention costs over time.',
      type: 'bar',
      data: {
        labels: months.value,
        datasets: [
          {
            label: 'Total Cost',
            type: 'line',
            valueType: 'currency',
            data: logging.value.flatMap((cost) => cost.total),
            backgroundColor: rgba('black', 1),
            borderColor: rgba('lightYellow', 0.5),
          },
          {
            label: 'Ingested Cost',
            valueType: 'currency',
            stack: 'stack1',
            data: logging.value.flatMap((cost) => cost.ingested),
            backgroundColor: rgba('lightBlue', 0.5),
          },
          {
            label: 'Retention Cost',
            valueType: 'currency',
            stack: 'stack1',
            data: logging.value.flatMap((cost) => cost.retention),
            backgroundColor: rgba('darkBlue', 0.5),
          },
          {
            label: 'Metrics Cost',
            valueType: 'currency',
            stack: 'stack2',
            data: logging.value.flatMap((cost) => cost.metrics),
            backgroundColor: rgba('lightOrange', 0.5),
          },
          {
            label: 'Analytics Cost',
            stack: 'stack2',
            valueType: 'currency',
            data: logging.value.flatMap((cost) => cost.analytics),
            backgroundColor: rgba('darkOrange', 0.5),
          },
        ],
      },
    },

    {
      title: 'Detailed Breakdown of Logging Costs',
      subtitle: 'Shows detailed breakdown of logging costs over time.',
      type: 'line',
      data: {
        labels: months.value,
        datasets: [
          {
            label: 'Ingested Cost',
            valueType: 'currency',
            data: logging.value.flatMap((cost) => cost.ingested),
            borderColor: rgba('lightBlue', 0.5),
            backgroundColor: rgba('black', 1),
          },
          {
            label: 'Retention Cost',
            valueType: 'currency',
            data: logging.value.flatMap((cost) => cost.retention),
            borderColor: rgba('lightGreen', 0.5),
            backgroundColor: rgba('black', 1),
          },
          {
            label: 'Metrics Cost',
            valueType: 'currency',
            data: logging.value.flatMap((cost) => cost.metrics),
            borderColor: rgba('lightOrange', 0.5),
            backgroundColor: rgba('black', 1),
          },
          {
            label: 'Analytics Cost',
            valueType: 'currency',
            data: logging.value.flatMap((cost) => cost.analytics),
            borderColor: rgba('lightRed', 0.5),
            backgroundColor: rgba('black', 1),
          },
        ],
      },
    },
  ]
})
</script>

<template>
  <FinancialCharts :charts="charts" />
</template>

<style scoped></style>
</file>

<file path="apps/admin-dashboard/components/financial/OpenAI.vue">
<script setup lang="ts">
const { months, openAI, rgba } = useFinancials()

const embeddingDetails = computed(() => {
  if (!months.value || !openAI.value) {
    return []
  }
  return openAI.value.map((month) =>
    month.breakdown.reduce(
      (acc, detail) => {
        acc.totalCost += detail.embedding.totalCost
        acc.totalTokens += detail.embedding.tokens.total
        return acc
      },
      {
        totalCost: 0,
        totalTokens: 0,
        model: '',
        batch: '',
      },
    ),
  )
})

const summaryDetails = computed(() => {
  if (!months.value || !openAI.value) {
    return []
  }

  return openAI.value.map((month) =>
    month.breakdown.reduce(
      (acc, detail) => {
        acc.totalCost += detail.summary.cost.total
        acc.inputCost += detail.summary.cost.input
        acc.outputCost += detail.summary.cost.output
        acc.totalTokens += detail.summary.tokens.total
        acc.inputTokens += detail.summary.tokens.input
        acc.outputTokens += detail.summary.tokens.output
        return acc
      },
      {
        totalCost: 0,
        inputCost: 0,
        outputCost: 0,
        totalTokens: 0,
        inputTokens: 0,
        outputTokens: 0,
        model: '',
        batch: '',
      },
    ),
  )
})

console.log('details', summaryDetails.value)
// embeddingDetails.value.flatMap((detail) =>
//   detail.map((d) => d.totalCost).reduce((a, b) => a + b, 0)
// )

const charts = computed(() => {
  if (!months.value || !openAI.value) {
    return []
  }

  return [
    {
      title: 'OpenAI Costs Breakdown',
      subtitle: 'Shows the breakdown of OpenAI costs for the selected time period.',
      type: 'bar',
      data: {
        labels: ['Total Cost', 'Embedding Cost', 'Summary Cost', 'Chat Cost'],
        datasets: [
          {
            label: 'Total OpenAI Costs',
            valueType: 'currency',
            data: [
              openAI.value.map((month) => month.cost.total).reduce((a, b) => a + b, 0),
              openAI.value.map((month) => month.cost.embedding).reduce((a, b) => a + b, 0),
              openAI.value.map((month) => month.cost.summary).reduce((a, b) => a + b, 0),
              openAI.value.map((month) => month.cost.chat).reduce((a, b) => a + b, 0),
            ],
            backgroundColor: [
              rgba('lightGreen', 0.5),
              rgba('darkBlue', 0.5),
              rgba('darkBlue', 0.5),
              rgba('darkBlue', 0.5),
              rgba('darkBlue', 0.5),
            ],
          },
        ],
      },
    },
    {
      title: 'OpenAI Token Breakdown',
      subtitle: 'Shows the breakdown of OpenAI token usage for the selected time period.',
      type: 'bar',
      data: {
        labels: [
          'Free Chat Input',
          'Free Chat Output',
          'Pro Chat Input',
          'Pro Chat Output',
          'Expert Chat Input',
          'Expert Chat Output',
          'Embeddings',
          'Summary Input',
          'Summary Output',
        ],
        datasets: [
          {
            label: 'Token Usage',
            valueType: 'number',
            data: [
              openAI.value
                .flatMap((month) => month.chat.free.tokens.input)
                .reduce((a, b) => a + b, 0),
              openAI.value
                .flatMap((month) => month.chat.free.tokens.output)
                .reduce((a, b) => a + b, 0),
              openAI.value
                .flatMap((month) => month.chat.pro.tokens.input)
                .reduce((a, b) => a + b, 0),
              openAI.value
                .flatMap((month) => month.chat.pro.tokens.output)
                .reduce((a, b) => a + b, 0),
              openAI.value
                .flatMap((month) => month.chat.expert.tokens.input)
                .reduce((a, b) => a + b, 0),
              openAI.value
                .flatMap((month) => month.chat.expert.tokens.output)
                .reduce((a, b) => a + b, 0),
              embeddingDetails.value.map((d) => d.totalTokens).reduce((a, b) => a + b, 0),
              summaryDetails.value.map((d) => d.inputTokens).reduce((a, b) => a + b, 0),
              summaryDetails.value.map((d) => d.outputTokens).reduce((a, b) => a + b, 0),
            ],
            backgroundColor: [
              rgba('lightGreen', 0.5),
              rgba('darkBlue', 0.5),
              rgba('darkBlue', 0.5),
              rgba('darkBlue', 0.5),
              rgba('darkBlue', 0.5),
              rgba('darkBlue', 0.5),
              rgba('darkBlue', 0.5),
              rgba('darkBlue', 0.5),
              rgba('darkBlue', 0.5),
            ],
          },
        ],
      },
    },
    {
      title: 'OpenAI Cost Breakdown',
      subtitle: 'Shows the total cost breakdown for OpenAI services over time.',
      type: 'bar',
      data: {
        labels: months.value,
        datasets: [
          {
            label: 'Total Cost',
            valueType: 'currency',
            type: 'line',
            data: openAI.value.flatMap((month) => month.cost.total),
            borderColor: rgba('lightBlue', 0.5),
          },
          {
            label: 'Embedding Cost',
            stack: 'stack1',
            valueType: 'currency',
            data: openAI.value.flatMap((month) => month.cost.embedding),
            backgroundColor: rgba('lightGreen', 0.5),
          },
          {
            label: 'Summary Cost',
            valueType: 'currency',
            stack: 'stack1',
            data: openAI.value.flatMap((month) => month.cost.summary),
            backgroundColor: rgba('lightRed', 0.5),
          },
          {
            label: 'Free Chat Cost',
            valueType: 'currency',
            stack: 'stack2',
            data: openAI.value.flatMap((month) => month.chat.free.cost.total),
            backgroundColor: rgba('darkBlue', 0.5),
          },
          {
            label: 'Pro Chat Cost',
            valueType: 'currency',
            stack: 'stack2',
            data: openAI.value.flatMap((month) => month.chat.pro.cost.total),
            backgroundColor: rgba('darkPink', 0.5),
          },
          {
            label: 'Expert Chat Cost',
            valueType: 'currency',
            stack: 'stack2',
            data: openAI.value.flatMap((month) => month.chat.expert.cost.total),
            backgroundColor: rgba('darkPurple', 0.5),
          },
        ],
      },
    },
    {
      title: 'Embedding Details',
      subtitle: 'Shows detailed embedding costs and usage over time.',
      type: 'line',
      data: {
        labels: months.value,
        datasets: [
          {
            label: 'Embedding Total Cost',
            valueType: 'currency',
            data: embeddingDetails.value.map((detail) => detail.totalCost),
            borderColor: rgba('lightBlue', 0.5),
            backgroundColor: rgba('black', 1),
          },
          {
            label: 'Token Usage',
            valueType: 'number',
            type: 'bar',
            data: embeddingDetails.value.map((detail) => detail.totalTokens),
            backgroundColor: rgba('darkOrange', 0.3),
          },
        ],
      },
    },
    {
      title: 'Summary Details',
      subtitle: 'Shows detailed summary costs and usage over time.',
      type: 'line',
      data: {
        labels: months.value,
        datasets: [
          {
            label: 'Summary Total Cost',
            valueType: 'currency',
            data: summaryDetails.value.map((d) => d.totalCost),
            borderColor: rgba('lightRed', 0.5),
            backgroundColor: rgba('lightRed', 0.2),
          },
          {
            label: 'Input Cost',
            valueType: 'currency',
            data: summaryDetails.value.map((d) => d.inputCost),
            borderColor: rgba('darkOrange', 0.5),
            backgroundColor: rgba('darkOrange', 0.2),
          },
          {
            label: 'Output Cost',
            valueType: 'currency',
            data: summaryDetails.value.map((d) => d.outputCost),
            borderColor: rgba('darkPurple', 0.5),
            backgroundColor: rgba('darkPurple', 0.2),
          },
          {
            label: 'Tokens Used',
            valueType: 'number',
            type: 'bar',
            data: summaryDetails.value.map((d) => d.totalTokens),
            borderColor: rgba('darkBlue', 0.5),
            backgroundColor: rgba('darkBlue', 0.2),
          },
        ],
      },
    },
    {
      title: 'Chat Cost Breakdown',
      subtitle: 'Shows the breakdown of chat costs for free, pro, and expert users over time.',
      type: 'bar',
      data: {
        labels: months.value,
        datasets: [
          {
            label: 'Free Chat Total Cost',
            type: 'line',
            valueType: 'currency',
            data: openAI.value.flatMap((month) => month.chat.free.cost.total),
            borderColor: rgba('lightBlue', 0.5),
          },
          {
            label: 'Pro Chat Total Cost',
            type: 'line',
            valueType: 'currency',
            data: openAI.value.flatMap((month) => month.chat.pro.cost.total),
            borderColor: rgba('darkOrange', 0.5),
          },
          {
            label: 'Expert Chat Total Cost',
            type: 'line',
            valueType: 'currency',
            data: openAI.value.flatMap((month) => month.chat.expert.cost.total),
            borderColor: rgba('darkOrange', 0.5),
          },
          {
            label: 'Pro Chat Input Cost',
            valueType: 'currency',
            data: openAI.value.flatMap((month) => month.chat.pro.cost.input),
            backgroundColor: rgba('darkPurple', 0.5),
          },
          {
            label: 'Pro Chat Output Cost',
            valueType: 'currency',
            data: openAI.value.flatMap((month) => month.chat.pro.cost.output),
            backgroundColor: rgba('darkBlue', 0.5),
          },
          {
            label: 'Expert Chat Input Cost',
            valueType: 'currency',
            data: openAI.value.flatMap((month) => month.chat.expert.cost.input),
            backgroundColor: rgba('darkPurple', 0.5),
          },
          {
            label: 'Expert Chat Output Cost',
            valueType: 'currency',
            data: openAI.value.flatMap((month) => month.chat.expert.cost.output),
            backgroundColor: rgba('darkBlue', 0.5),
          },
        ],
      },
    },
    {
      title: 'Chat Usage',
      subtitle:
        'Shows the token usage and request counts for free, pro, and expert chat users over time.',
      type: 'line',
      data: {
        labels: months.value,
        datasets: [
          {
            label: 'Free Chat Tokens',
            valueType: 'number',
            data: openAI.value.flatMap((month) => month.chat.free.tokens.total),
            borderColor: rgba('lightBlue', 0.5),
            backgroundColor: rgba('lightBlue', 0.2),
          },
          {
            label: 'Free Chat Requests',
            valueType: 'number',
            data: openAI.value.flatMap((month) => month.chat.free.requests.total),
            borderColor: rgba('lightGreen', 0.5),
            backgroundColor: rgba('lightGreen', 0.2),
          },
          {
            label: 'Pro Chat Tokens',
            valueType: 'number',
            data: openAI.value.flatMap((month) => month.chat.pro.tokens.total),
            borderColor: rgba('lightRed', 0.5),
            backgroundColor: rgba('lightRed', 0.2),
          },
          {
            label: 'Pro Chat Requests',
            valueType: 'number',
            data: openAI.value.flatMap((month) => month.chat.pro.requests.total),
            borderColor: rgba('darkOrange', 0.5),
            backgroundColor: rgba('darkOrange', 0.2),
          },
          {
            label: 'Expert Chat Tokens',
            valueType: 'number',
            data: openAI.value.flatMap((month) => month.chat.expert.tokens.total),
            borderColor: rgba('lightRed', 0.5),
            backgroundColor: rgba('lightRed', 0.2),
          },
          {
            label: 'Expert Chat Requests',
            valueType: 'number',
            data: openAI.value.flatMap((month) => month.chat.expert.requests.total),
            borderColor: rgba('darkOrange', 0.5),
            backgroundColor: rgba('darkOrange', 0.2),
          },
        ],
      },
    },
    {
      title: 'Monthly Token Usage Comparison',
      subtitle:
        'Compares the token usage across embeddings, summaries, and chat services over time.',
      type: 'line',
      data: {
        labels: months.value,
        datasets: [
          {
            label: 'Embedding Tokens',
            valueType: 'number',
            data: openAI.value.flatMap((detail) => detail.tokens.embedding),
            borderColor: rgba('lightBlue', 0.5),
            backgroundColor: rgba('black', 1),
          },
          {
            label: 'Summary Tokens',
            valueType: 'number',
            data: openAI.value.flatMap((detail) => detail.tokens.summary),
            borderColor: rgba('lightGreen', 0.5),
            backgroundColor: rgba('black', 1),
          },
          {
            label: 'Chat Tokens',
            valueType: 'number',
            data: openAI.value.flatMap((month) => month.tokens.chat),
            borderColor: rgba('lightRed', 0.5),
            backgroundColor: rgba('black', 1),
          },
          {
            label: 'Total Tokens',
            valueType: 'number',
            type: 'bar',
            data: openAI.value.flatMap((month) => month.tokens.total),
            backgroundColor: rgba('darkOrange', 0.3),
          },
        ],
      },
    },
    {
      title: 'Embedding Cost vs. Summary Cost',
      subtitle: 'Compares the costs of embeddings and summaries over time.',
      type: 'bar',
      data: {
        labels: months.value,
        datasets: [
          {
            label: 'Embedding Cost',
            valueType: 'currency',
            data: openAI.value.flatMap((month) => month.cost.embedding),
            backgroundColor: rgba('lightBlue', 0.5),
          },
          {
            label: 'Summary Cost',
            valueType: 'currency',
            data: openAI.value.flatMap((month) => month.cost.summary),
            backgroundColor: rgba('lightGreen', 0.5),
          },
        ],
      },
    },
    {
      title: 'Monthly OpenAI Service Costs',
      subtitle: 'Shows the monthly costs for each OpenAI service.',
      type: 'line',
      data: {
        labels: months.value,
        datasets: [
          {
            label: 'Embedding Cost',
            valueType: 'currency',
            data: openAI.value.flatMap((month) => month.cost.embedding),
            borderColor: rgba('lightBlue', 0.5),
            backgroundColor: rgba('lightBlue', 0.2),
          },
          {
            label: 'Summary Cost',
            valueType: 'currency',
            data: openAI.value.flatMap((month) => month.cost.summary),
            borderColor: rgba('lightGreen', 0.5),
            backgroundColor: rgba('lightGreen', 0.2),
          },
          {
            label: 'Chat Cost',
            valueType: 'currency',
            data: openAI.value.flatMap((month) => month.cost.chat),
            borderColor: rgba('lightRed', 0.5),
            backgroundColor: rgba('lightRed', 0.2),
          },
        ],
      },
    },
  ]
})
</script>

<template>
  <FinancialCharts :charts="charts" />
</template>

<style scoped></style>
</file>

<file path="apps/admin-dashboard/components/financial/Operations.vue">
<script setup lang="ts">
const { months, metrics, capital, customers, rgba } = useFinancials()

console.log('dataMetrics', metrics.value)

const charts = computed(() => {
  if (!months.value || !metrics.value) {
    return []
  }

  console.log('should not fire', metrics.value)

  return [
    {
      title: 'Balance Over Time',
      subtitle:
        'Shows the company\'s financial health and sustainability, indicating the ability to cover expenses.',
      type: 'bar',
      data: {
        labels: months.value,
        datasets: [
          {
            label: 'PL Margin',
            type: 'line',
            valueType: 'percentage',
            data: metrics.value.map((m) => m.profitLossMargin),
            borderColor: rgba('lightOrange', 0.5),
            backgroundColor: rgba('lightOrange', 0.5),
          },
          {
            label: 'Burn Rate',
            valueType: 'currency',
            data: capital.value.map((m) => m.burnRate),
            borderColor: rgba('darkRed', 0.5),
            backgroundColor: rgba('darkRed', 0.5),
          },
          {
            label: 'Balance End',
            valueType: 'currency',
            data: capital.value.map((m) => m.balance.end),
            borderColor: rgba('darkGreen', 0.5),
            backgroundColor: rgba('darkGreen', 0.5),
          },
        ],
      },
    },
    {
      title: 'Subscription Revenue by Plan',
      subtitle:
        'Breaks down subscription revenue by different plans, highlighting the most profitable segments.',
      type: 'bar',
      data: {
        labels: months.value,
        datasets: [
          {
            label: 'Total Conversion Rate',
            type: 'line',
            valueType: 'percentage',
            data: metrics.value.flatMap((m) => m.conversionRate.total),
            borderColor: rgba('lightPurple', 0.5),
          },
          {
            label: 'Free Users Revenue',
            valueType: 'currency',
            data: customers.value.flatMap((m) => m.free.revenue),
            backgroundColor: rgba('lightGreen', 0.5),
          },
          {
            label: 'Pro Users Revenue',
            valueType: 'currency',
            data: customers.value.flatMap((m) => m.pro.revenue),
            backgroundColor: rgba('lightGreen', 0.5),
          },
          {
            label: 'Expert Users Revenue',
            valueType: 'currency',
            data: customers.value.flatMap((m) => m.expert.revenue),
            backgroundColor: rgba('lightBlue', 0.5),
          },
        ],
      },
    },
  ]
})
</script>

<template>
  <FinancialCharts :charts="charts" />
</template>

<style scoped></style>
</file>

<file path="apps/admin-dashboard/components/financial/Payments.vue">
<script setup lang="ts">
const { months, payments, totals, metrics, rgba } = useFinancials()

const stripePaymentTypes = ['InternationalCard', 'AmericanExpress', 'MasterCardVisa']

const stripeTransactions = computed(() => {
  if (!months.value || !payments.value) {
    return []
  }

  return stripePaymentTypes.reduce((acc, type) => {
    const transactions = payments.value.flatMap((month) =>
      month.stripe.transactions.flatMap((transaction) =>
        transaction.paymentMethod === type
          ? [
              {
                totalCost: transaction.pro.totalCost + transaction.expert.totalCost || 0,
                totalTransactions: transaction.methodCustomers || 0,
                additionalFees:
                  transaction.pro.fees.additionalFees + transaction.expert.fees.additionalFees || 0,
                gst: transaction.pro.fees.gst + transaction.expert.fees.gst || 0,
                subscription:
                  transaction.pro.fees.subscription + transaction.expert.fees.subscription || 0,
                platform: transaction.pro.fees.platform + transaction.expert.fees.platform || 0,
              },
            ]
          : [],
      ),
    )

    acc[type] = {
      transactions,
      totals: transactions.reduce(
        (totals, transaction) => {
          totals.totalCost += transaction.totalCost
          totals.totalTransactions += transaction.totalTransactions
          totals.additionalFees += transaction.additionalFees
          totals.gst += transaction.gst
          totals.subscription += transaction.subscription
          totals.platform += transaction.platform
          return totals
        },
        {
          totalCost: 0,
          totalTransactions: 0,
          additionalFees: 0,
          gst: 0,
          subscription: 0,
          platform: 0,
        },
      ),
    }

    return acc
  }, {})
})

const totalStripeTransactions = computed(() => {
  const initialTotals = {
    totalCost: 0,
    totalTransactions: 0,
    additionalFees: 0,
    gst: 0,
    subscription: 0,
    platform: 0,
  }

  if (!months.value || !payments.value) {
    return []
  }

  return payments.value.reduce((totals, month) => {
    month.stripe.transactions.forEach((transaction) => {
      totals.totalCost += transaction.pro.totalCost + transaction.expert.totalCost || 0
      totals.totalTransactions += transaction.methodCustomers || 0
      totals.additionalFees
        += transaction.pro.fees.additionalFees + transaction.expert.fees.additionalFees || 0
      totals.gst += transaction.pro.fees.gst + transaction.expert.fees.gst || 0
      totals.subscription
        += transaction.pro.fees.subscription + transaction.expert.fees.subscription || 0
      totals.platform += transaction.pro.fees.platform + transaction.expert.fees.platform || 0
    })
    return totals
  }, initialTotals)
})

console.log('totalStripeTransactions', payments.value)

const razorpayPaymentTypes = ['Visa', 'MasterCard', 'UPI']

const razorpayTransactions = computed(() => {
  if (!months.value || !payments.value) {
    return []
  }

  return razorpayPaymentTypes.reduce((acc, type) => {
    const transactions = payments.value.flatMap((month) =>
      month.razorpay.transactions.flatMap((transaction) =>
        transaction.paymentMethod === type
          ? [
              {
                totalCost: transaction.pro?.totalCost + transaction.expert?.totalCost || 0,
                totalTransactions: transaction.methodCustomers || 0,
                additionalFees:
                  transaction.pro?.fees?.additionalFees
                  + transaction.expert?.fees?.additionalFees || 0,
                gst: transaction.pro?.fees?.gst + transaction.expert?.fees?.gst || 0,
                subscription:
                  transaction.pro?.fees?.subscription + transaction.expert?.fees?.subscription || 0,
                platform: transaction.pro?.fees?.platform + transaction.expert?.fees?.platform || 0,
              },
            ]
          : [],
      ),
    )

    // Calculate totals for each type and store them in the accumulator
    acc[type] = {
      transactions,
      totals: transactions.reduce(
        (totals, transaction) => {
          totals.totalCost += transaction.totalCost
          totals.totalTransactions += transaction.totalTransactions
          totals.additionalFees += transaction.additionalFees
          totals.gst += transaction.gst
          totals.subscription += transaction.subscription
          totals.platform += transaction.platform
          return totals
        },
        {
          totalCost: 0,
          totalTransactions: 0,
          additionalFees: 0,
          gst: 0,
          subscription: 0,
          platform: 0,
        },
      ),
    }

    return acc
  }, {})
})

console.log('razorpayTransactions', razorpayTransactions)

const totalRazorpayTransactions = computed(() => {
  const initialTotals = {
    totalCost: 0,
    totalTransactions: 0,
    additionalFees: 0,
    gst: 0,
    subscription: 0,
    platform: 0,
  }

  if (!months.value || !payments.value) {
    return []
  }

  return payments.value.reduce((totals, month) => {
    month.razorpay.transactions.forEach((transaction) => {
      totals.totalCost += transaction.pro.totalCost + transaction.expert.totalCost || 0
      totals.totalTransactions += transaction.methodCustomers || 0
      totals.additionalFees
        += transaction.pro.fees.additionalFees + transaction.expert.fees.additionalFees || 0
      totals.gst += transaction.pro.fees.gst + transaction.expert.fees.gst || 0
      totals.subscription
        += transaction.pro.fees.subscription + transaction.expert.fees.subscription || 0
      totals.platform += transaction.pro.fees.platform + transaction.expert.fees.platform || 0
    })
    return totals
  }, initialTotals)
})

const stripe = computed(() => {
  if (!months.value || !payments.value) {
    return []
  }

  return payments.value.flatMap((month) => month.stripe)
})

const razorpay = computed(() => {
  if (!months.value || !payments.value) {
    return []
  }

  return payments.value.flatMap((month) => month.razorpay)
})

const charts = computed(() => {
  if (!months.value || !payments.value) {
    return []
  }

  if (!months.value.length) {
    return []
  }

  return [
    {
      title: 'Payment Fee Breakdown',
      subtitle:
        'Shows the breakdown of payment fee costs by provider for the selected time period.',
      type: 'bar',
      data: {
        labels: [
          'Stripe Platform Fees',
          'Stripe Subscription Fees',
          'Stripe Extra Fees',
          'Razorpay Platform Fees',
          'Razorpay Subscription Fees',
          'Razorpay Extra Fees',
        ],
        datasets: [
          {
            label: 'Total Fees',
            valueType: 'currency',
            data: [
              totalStripeTransactions.value.platform,
              totalStripeTransactions.value.subscription,
              totalStripeTransactions.value.additionalFees,
              totalRazorpayTransactions.value.platform,
              totalRazorpayTransactions.value.subscription,
              totalRazorpayTransactions.value.additionalFees,
            ],
            backgroundColor: [
              rgba('lightGreen', 0.5),
              rgba('darkBlue', 0.5),
              rgba('lightBlue', 0.5),
              rgba('darkRed', 0.5),
              rgba('lightRed', 0.5),
              rgba('darkCyan', 0.5),
            ],
          },
        ],
      },
    },
    {
      title: 'Total Payment Costs by Provider',
      subtitle: 'Shows the total payment costs for Razorpay and Stripe over time.',
      type: 'bar',
      data: {
        labels: months.value,
        datasets: [
          {
            label: 'Razorpay Total Transactions',
            type: 'line',
            valueType: 'number',
            data: razorpay.value.flatMap((month) => month.totalCustomers),
            borderColor: rgba('darkOrange', 0.8),
            backgroundColor: rgba('black', 1),
          },
          {
            label: 'Stripe Total Transactions',
            type: 'line',
            valueType: 'number',
            data: stripe.value.flatMap((month) => month.totalCustomers),
            borderColor: rgba('darkBlue', 0.8),
            backgroundColor: rgba('black', 1),
          },
          {
            label: 'Razorpay Total Cost',
            valueType: 'currency',
            data: razorpay.value.flatMap((month) => month.totalCost),
            backgroundColor: rgba('darkOrange', 0.3),
          },
          {
            label: 'Stripe Total Cost',
            valueType: 'currency',
            data: stripe.value.flatMap((month) => month.totalCost),
            backgroundColor: rgba('darkBlue', 0.3),
          },
        ],
      },
    },
    {
      title: 'Domestic Payment Costs - Razorpay Totals',
      subtitle: 'Shows the costs for different domestic payment methods over time.',
      type: 'line',
      data: {
        labels: months.value,
        datasets: [
          {
            label: 'Visa Cost',
            valueType: 'currency',
            data: razorpayTransactions.value.Visa.transactions.map((m) => m.totalCost),
            borderColor: rgba('lightBlue', 0.5),
            backgroundColor: rgba('black', 1),
          },
          {
            label: 'MasterCard Cost',
            valueType: 'currency',
            data: razorpayTransactions.value.MasterCard.transactions.map((m) => m.totalCost),
            borderColor: rgba('lightGreen', 0.5),
            backgroundColor: rgba('black', 1),
          },
          {
            label: 'UPI Cost',
            valueType: 'currency',
            data: razorpayTransactions.value.UPI.transactions.map((m) => m.totalCost),
            borderColor: rgba('lightRed', 0.5),
            backgroundColor: rgba('black', 1),
          },
          {
            label: 'Domestic Transactions',
            type: 'bar',
            valueType: 'number',
            data: razorpay.value.map((m) => m.totalCustomers),
            borderColor: rgba('darkOrange', 0.5),
            backgroundColor: rgba('darkOrange', 0.2),
          },
        ],
      },
    },
    {
      title: 'Razorpay UPI Fees',
      subtitle: 'Domestic payment fees for UPI transactions.',
      type: 'bar',
      data: {
        labels: months.value,
        datasets: [
          {
            label: 'Total Transactions',
            type: 'line',
            valueType: 'number',
            data: razorpayTransactions.value.UPI.transactions.map((m) => m.totalTransactions),
            borderColor: rgba('darkGray', 0.5),
            backgroundColor: rgba('black', 1),
          },
          {
            label: 'Platform Fees',
            valueType: 'currency',
            data: razorpayTransactions.value.UPI.transactions.map((m) => m.platform),
            backgroundColor: rgba('darkRed', 0.5),
          },
          {
            label: 'Subscription Fees',
            valueType: 'currency',
            data: razorpayTransactions.value.UPI.transactions.map((m) => m.subscription),
            backgroundColor: rgba('darkOrange', 0.5),
            stack: 'stack1',
          },
          {
            label: 'GST Fees',
            valueType: 'currency',
            data: razorpayTransactions.value.UPI.transactions.map((m) => m.gst),
            backgroundColor: rgba('darkPurple', 0.5),
            stack: 'stack1',
          },
          {
            label: 'Extra Fees',
            valueType: 'currency',
            data: razorpayTransactions.value.UPI.transactions.map((m) => m.additionalFees),
            backgroundColor: rgba('darkBlue', 0.3),
            stack: 'stack1',
          },
        ],
      },
    },
    {
      title: 'Razorpay Visa Fees',
      subtitle: 'Domestic payment fees for Visa transactions.',
      type: 'bar',
      data: {
        labels: months.value,
        datasets: [
          {
            label: 'Total Transactions',
            type: 'line',
            valueType: 'number',
            data: razorpayTransactions.value.Visa.transactions.map((m) => m.totalTransactions),
            borderColor: rgba('darkGray', 0.5),
            backgroundColor: rgba('black', 1),
          },
          {
            label: 'Platform Fees',
            valueType: 'currency',
            data: razorpayTransactions.value.Visa.transactions.map((m) => m.platform),
            backgroundColor: rgba('darkRed', 0.5),
          },
          {
            label: 'Subscription Fees',
            valueType: 'currency',
            data: razorpayTransactions.value.Visa.transactions.map((m) => m.subscription),
            backgroundColor: rgba('darkOrange', 0.5),
            stack: 'stack1',
          },
          {
            label: 'GST Fees',
            valueType: 'currency',
            data: razorpayTransactions.value.Visa.transactions.map((m) => m.gst),
            backgroundColor: rgba('darkPurple', 0.5),
            stack: 'stack1',
          },
          {
            label: 'Extra Fees',
            valueType: 'currency',
            data: razorpayTransactions.value.Visa.transactions.map((m) => m.additionalFees),
            backgroundColor: rgba('darkBlue', 0.3),
            stack: 'stack1',
          },
        ],
      },
    },
    {
      title: 'Razorpay MasterCard Fees',
      subtitle: 'International payment fees for MasterCard transactions.',
      type: 'bar',
      data: {
        labels: months.value,
        datasets: [
          {
            label: 'Total Transactions',
            type: 'line',
            valueType: 'number',
            data: razorpayTransactions.value.MasterCard.transactions.flatMap(
              (m) => m.totalTransactions,
            ),
            borderColor: rgba('darkGray', 0.5),
            backgroundColor: rgba('black', 1),
          },
          {
            label: 'Platform Fees',
            valueType: 'currency',
            data: razorpayTransactions.value.MasterCard.transactions.flatMap((m) => m.platform),
            backgroundColor: rgba('darkRed', 0.7),
          },
          {
            label: 'Subscription Fees',
            valueType: 'currency',
            data: razorpayTransactions.value.MasterCard.transactions.flatMap((m) => m.subscription),
            backgroundColor: rgba('darkOrange', 0.5),
            stack: 'stack1',
          },
          {
            label: 'GST Fees',
            valueType: 'currency',
            data: razorpayTransactions.value.MasterCard.transactions.flatMap((m) => m.gst),
            backgroundColor: rgba('darkPurple', 0.5),
            stack: 'stack1',
          },
          {
            label: 'Extra Fees',
            valueType: 'currency',
            data: razorpayTransactions.value.Visa.transactions.flatMap((m) => m.additionalFees),
            backgroundColor: rgba('darkBlue', 0.3),
            stack: 'stack1',
          },
        ],
      },
    },
    {
      title: 'Stripe International Payments - Total Costs',
      subtitle: 'Shows the costs for different international payment methods over time.',
      type: 'line',
      data: {
        labels: months.value,
        datasets: [
          {
            label: 'MasterCard/Visa Cost',
            valueType: 'currency',
            data: stripeTransactions.value.MasterCardVisa.transactions.map((m) => m.totalCost),
            backgroundColor: rgba('black', 1),
            borderColor: rgba('darkBlue', 0.6),
          },
          {
            label: 'American Express Cost',
            valueType: 'currency',
            data: stripeTransactions.value.AmericanExpress.transactions.map((m) => m.totalCost),
            backgroundColor: rgba('black', 1),
            borderColor: rgba('lightGreen', 0.5),
          },
          {
            label: 'International Card Cost',
            valueType: 'currency',
            data: stripeTransactions.value.InternationalCard.transactions.map((m) => m.totalCost),
            backgroundColor: rgba('black', 1),
            borderColor: rgba('lightRed', 0.5),
          },
          {
            label: 'International Transactions',
            type: 'bar',
            valueType: 'number',
            data: stripe.value.map((m) => m.totalCustomers),
            borderColor: rgba('darkOrange', 0.5),
            backgroundColor: rgba('darkOrange', 0.2),
          },
        ],
      },
    },
    {
      title: 'Stripe International Card Fees',
      subtitle:
        'International payment fees from all non Visa/MasterCard/AmericanExpress transactions.',
      type: 'bar',
      data: {
        labels: months.value,
        datasets: [
          {
            label: 'Total Transactions',
            type: 'line',
            valueType: 'number',
            data: stripeTransactions.value.InternationalCard.transactions.flatMap(
              (m) => m.totalTransactions,
            ),
            borderColor: rgba('darkGray', 0.5),
            backgroundColor: rgba('black', 1),
          },
          {
            label: 'Platform Fees',
            valueType: 'currency',
            data: stripeTransactions.value.InternationalCard.transactions.map(
              (cost) => cost.platform,
            ),
            backgroundColor: rgba('darkRed', 0.5),
          },
          {
            label: 'Subscription Fees',
            valueType: 'currency',
            data: stripeTransactions.value.InternationalCard.transactions.map(
              (cost) => cost.subscription,
            ),
            backgroundColor: rgba('darkOrange', 0.5),
            stack: 'stack1',
          },
          {
            label: 'GST Fees',
            valueType: 'currency',
            data: stripeTransactions.value.InternationalCard.transactions.map((cost) => cost.gst),
            backgroundColor: rgba('darkPurple', 0.5),
            stack: 'stack1',
          },
          {
            label: 'Extra Fees',
            valueType: 'currency',
            data: stripeTransactions.value.InternationalCard.transactions.map(
              (cost) => cost.additionalFees,
            ),
            backgroundColor: rgba('darkBlue', 0.3),
            stack: 'stack1',
          },
        ],
      },
    },
    {
      title: 'Stripe MasterCard / Visa Fees',
      subtitle: 'International payment fees from all Visa MasterCard transactions.',
      type: 'bar',
      data: {
        labels: months.value,
        datasets: [
          {
            label: 'Total Transactions',
            type: 'line',
            valueType: 'number',
            data: stripeTransactions.value.MasterCardVisa.transactions.flatMap(
              (m) => m.totalTransactions,
            ),
            borderColor: rgba('darkGray', 0.5),
            backgroundColor: rgba('black', 1),
          },
          {
            label: 'Platform Fees',
            valueType: 'currency',
            data: stripeTransactions.value.MasterCardVisa.transactions.map((cost) => cost.platform),
            backgroundColor: rgba('darkRed', 0.7),
          },
          {
            label: 'Subscription Fees',
            valueType: 'currency',
            data: stripeTransactions.value.MasterCardVisa.transactions.map(
              (cost) => cost.subscription,
            ),
            backgroundColor: rgba('darkOrange', 0.5),
            stack: 'stack1',
          },
          {
            label: 'GST Fees',
            valueType: 'currency',
            data: stripeTransactions.value.MasterCardVisa.transactions.map((cost) => cost.gst),
            backgroundColor: rgba('darkPurple', 0.5),
            stack: 'stack1',
          },
          {
            label: 'Extra Fees',
            valueType: 'currency',
            data: stripeTransactions.value.MasterCardVisa.transactions.map(
              (cost) => cost.additionalFees,
            ),
            backgroundColor: rgba('darkBlue', 0.3),
            stack: 'stack1',
          },
        ],
      },
    },
    {
      title: 'Stripe AmericanExpress Fees',
      subtitle: 'International payment fees for AmericanExpress transactions.',
      type: 'bar',
      data: {
        labels: months.value,
        datasets: [
          {
            label: 'Total Transactions',
            type: 'line',
            valueType: 'number',
            data: stripeTransactions.value.AmericanExpress.transactions.flatMap(
              (m) => m.totalTransactions,
            ),
            borderColor: rgba('darkGray', 0.5),
            backgroundColor: rgba('black', 1),
          },
          {
            label: 'Platform Fees',
            valueType: 'currency',
            data: stripeTransactions.value.AmericanExpress.transactions.map(
              (cost) => cost.platform,
            ),
            backgroundColor: rgba('darkRed', 0.5),
          },
          {
            label: 'Subscription Fees',
            valueType: 'currency',
            data: stripeTransactions.value.AmericanExpress.transactions.map(
              (cost) => cost.subscription,
            ),
            backgroundColor: rgba('darkOrange', 0.5),
            stack: 'stack1',
          },
          {
            label: 'GST Fees',
            valueType: 'currency',
            data: stripeTransactions.value.AmericanExpress.transactions.map((cost) => cost.gst),
            backgroundColor: rgba('darkPurple', 0.5),
            stack: 'stack1',
          },
          {
            label: 'Extra Fees',
            valueType: 'currency',
            data: stripeTransactions.value.AmericanExpress.transactions.map(
              (cost) => cost.additionalFees,
            ),
            backgroundColor: rgba('darkBlue', 0.3),
            stack: 'stack1',
          },
        ],
      },
    },
  ]
})
</script>

<template>
  <FinancialCharts :charts="charts" />
</template>

<style scoped></style>
</file>

<file path="apps/admin-dashboard/components/financial/Storage.vue">
<script setup lang="ts">
const { months, storage, rgba } = useFinancials()

const storageDetails = computed(() => storage.value?.flatMap((m) => m.storage.data.details) || [])

const charts = computed(() => {
  if (!months.value || !storage.value) {
    return []
  }

  return [
    {
      title: 'Storage Costs Breakdown',
      subtitle: 'Shows the breakdown of storage costs for the selected time period.',
      type: 'bar',
      data: {
        labels: [
          'Storage Base Cost',
          'Storage MAU Cost',
          'Database Cost',
          'Bandwidth Cost',
          'File Storage Cost',
          'Compute Cost',
        ],
        datasets: [
          {
            label: 'Total Storage Costs',
            valueType: 'currency',
            data: [
              storage.value.flatMap((m) => m.storage.cost.base).reduce((a, b) => a + b, 0),
              storage.value.flatMap((m) => m.storage.cost.mau).reduce((a, b) => a + b, 0),
              storage.value.flatMap((m) => m.storage.cost.db).reduce((a, b) => a + b, 0),
              storage.value.flatMap((m) => m.storage.cost.bandwidth).reduce((a, b) => a + b, 0),
              storage.value.flatMap((m) => m.storage.cost.fileStorage).reduce((a, b) => a + b, 0),
              storage.value.flatMap((m) => m.compute.cost.total).reduce((a, b) => a + b, 0),
            ],
            backgroundColor: [
              rgba('lightGreen', 0.5),
              rgba('darkBlue', 0.5),
              rgba('lightBlue', 0.5),
              rgba('darkRed', 0.5),
              rgba('lightRed', 0.5),
              rgba('darkCyan', 0.5),
            ],
          },
        ],
      },
    },
    {
      title: 'Storage Data Breakdown',
      subtitle: 'Shows the breakdown of storage data over time.',
      type: 'line',
      data: {
        labels: months.value,
        datasets: [
          {
            label: 'Database Data',
            valueType: 'storage',
            data: storage.value.flatMap((m) => m.storage.data.db),
            borderColor: rgba('darkBlue', 0.5),
            backgroundColor: rgba('darkBlue', 0.2),
          },
          {
            label: 'Vector Data',
            valueType: 'storage',
            data: storage.value.flatMap((m) => m.storage.data.vector),
            borderColor: rgba('darkRed', 0.5),
            backgroundColor: rgba('darkRed', 0.2),
          },
        ],
      },
    },
    {
      title: 'Compute Costs',
      subtitle: 'Shows the compute costs over time.',
      type: 'line',
      data: {
        labels: months.value,
        datasets: [
          {
            label: 'Hourly Cost',
            valueType: 'currency',
            data: storage.value.flatMap((m) => m.compute.cost.hourly),
            borderColor: rgba('lightGreen', 0.5),
            backgroundColor: rgba('lightGreen', 0.2),
          },
          {
            label: 'Monthly Cost',
            valueType: 'currency',
            data: storage.value.flatMap((m) => m.compute.cost.monthly),
            borderColor: rgba('lightBlue', 0.5),
            backgroundColor: rgba('lightBlue', 0.2),
          },
        ],
      },
    },
    {
      title: 'Storage Requirements by Content Type',
      subtitle: 'Shows the requirements of storage in GB by content type over time.',
      type: 'line',
      data: {
        labels: months.value,
        datasets: [
          {
            label: 'News',
            valueType: 'storage',
            data: storageDetails.value.flatMap((detail) =>
              detail.content.type === 'NEWS' ? detail.storage.total : [],
            ),
            borderColor: rgba('lightGreen', 0.5),
          },
          {
            label: 'Research Abstracts',
            valueType: 'storage',
            data: storageDetails.value.flatMap((detail) =>
              detail.content.type === 'RESEARCH_ABSTRACTS' ? detail.storage.total : [],
            ),
            borderColor: rgba('darkBlue', 0.5),
          },
          {
            label: 'Research Papers',
            valueType: 'storage',
            data: storageDetails.value.flatMap((detail) =>
              detail.content.type === 'RESEARCH_PAPERS' ? detail.storage.total : [],
            ),
            borderColor: rgba('lightBlue', 0.5),
          },
          {
            label: 'Jobs',
            valueType: 'storage',
            data: storageDetails.value.flatMap((detail) =>
              detail.content.type === 'JOBS' ? detail.storage.total : [],
            ),
            borderColor: rgba('darkRed', 0.5),
          },
          {
            label: 'Companies',
            valueType: 'storage',
            data: storageDetails.value.flatMap((detail) =>
              detail.content.type === 'COMPANIES' ? detail.storage.total : [],
            ),
            borderColor: rgba('lightRed', 0.5),
          },
        ],
      },
    },
    {
      title: 'Storage Costs vs. Data Usage',
      subtitle: 'Shows the correlation between storage costs and data usage over time.',
      type: 'line',
      data: {
        labels: months.value,
        datasets: [
          {
            label: 'Total Cost',
            valueType: 'number',
            data: storage.value.flatMap((m) => m.totalCost),
            borderColor: rgba('lightRed', 0.5),
            backgroundColor: rgba('lightRed', 0.2),
          },
          {
            label: 'Compute Cost',
            valueType: 'number',
            data: storage.value.flatMap((m) => m.compute.cost.total),
            borderColor: rgba('lightOrange', 0.5),
            backgroundColor: rgba('lightOrange', 0.2),
          },
          {
            label: 'Storage Cost',
            valueType: 'number',
            data: storage.value.flatMap((m) => m.storage.cost.total),
            borderColor: rgba('lightYellow', 0.5),
            backgroundColor: rgba('lightYellow', 0.2),
          },
          {
            label: 'Total Data',
            valueType: 'storage',
            type: 'bar',
            data: storage.value.flatMap((m) => m.storage.data.total),
            borderColor: rgba('darkGreen', 0.5),
            backgroundColor: rgba('darkGreen', 0.5),
          },
        ],
      },
    },
  ]
})
</script>

<template>
  <FinancialCharts :charts="charts" />
</template>

<style scoped></style>
</file>

<file path="apps/admin-dashboard/components/financial/Totals.vue">
<script setup lang="ts">
const {
  months,
  capital,
  revenue,
  totals,
  metrics,
  employees,
  advertising,
  affiliate,
  promotion,
  customers,
  filteredData,
  rgba,
} = useFinancials()

const charts = computed(() => {
  console.log('computed data', capital.value)
  if (!capital.value) {
    return []
  }

  return [
    {
      id: 0,
      title: 'Complete Costs Breakdown',
      subtitle: 'Shows the breakdown of OpenAI costs for the selected time period.',
      type: 'bar',
      data: {
        labels: [
          'Employees Total',
          'Software Cost',
          'Office Total Cost',
          'Loan Total Cost',
          'Marketing Cost',
          'Payments Cost',
          'Storage Cost',
          'DevOps Cost',
          'Digital Ocean Total Cost',
          'Logging Cost',
          'Analytics Cost',
          'OpenAI Total Cost',
        ],
        datasets: [
          {
            label: 'Expense Totals',
            valueType: 'currency',
            data: [
              totals.value.flatMap((month) => month.employees).reduce((a, b) => a + b, 0),
              totals.value.flatMap((month) => month.software).reduce((a, b) => a + b, 0),
              totals.value.flatMap((month) => month.office).reduce((a, b) => a + b, 0),
              totals.value.flatMap((month) => month.loan).reduce((a, b) => a + b, 0),
              totals.value.flatMap((month) => month.marketing).reduce((a, b) => a + b, 0),
              totals.value.flatMap((month) => month.payments).reduce((a, b) => a + b, 0),
              totals.value.flatMap((month) => month.storage).reduce((a, b) => a + b, 0),
              totals.value.flatMap((month) => month.devOps).reduce((a, b) => a + b, 0),
              totals.value.flatMap((month) => month.digitalOcean).reduce((a, b) => a + b, 0),
              totals.value.flatMap((month) => month.logging).reduce((a, b) => a + b, 0),
              totals.value.flatMap((month) => month.analytics).reduce((a, b) => a + b, 0),
              totals.value.flatMap((month) => month.openAI).reduce((a, b) => a + b, 0),
            ],
            backgroundColor: new Array(12).fill(rgba('darkBlue', 0.5)),
          },
        ],
      },
    },
    {
      id: 1,
      title: 'Revenue Growth Over Time',
      subtitle:
        'Shows the increase in revenue, highlighting the business\'s financial health and growth potential.',
      type: 'bar',
      data: {
        labels: months.value,
        datasets: [
          {
            label: 'Burn Rate',
            type: 'line',
            valueType: 'currency',
            data: capital.value.flatMap((month) => month.burnRate),
            borderColor: rgba('darkOrange', 1),
            backgroundColor: rgba('black', 1),
          },
          {
            label: 'Effective Revenue',
            valueType: 'currency',
            data: totals.value.flatMap((month) => month.income.effective),
            borderColor: rgba('lightGreen', 0.3),
            backgroundColor: rgba('darkGreen', 0.3),
          },
          {
            label: 'Expenses',
            valueType: 'currency',
            data: totals.value.flatMap((month) => month.expenses.total),
            borderColor: rgba('lightRed', 0.3),
            backgroundColor: rgba('darkRed', 0.3),
          },
        ],
      },
    },
    {
      id: 2,
      title: 'Monthly Revenue Breakdown by Stream',
      subtitle:
        'Shows the diversity of revenue sources, highlighting multiple income streams which reduce financial risk.',
      type: 'bar',
      data: {
        labels: months.value,
        datasets: [
          {
            label: 'Advertising Revenue',
            valueType: 'currency',
            type: 'line',
            data: revenue.value.flatMap((month) => month.total.advertising),
            borderColor: rgba('darkCyan', 1),
            backgroundColor: rgba('black', 1),
          },
          {
            label: 'Affiliate Revenue',
            valueType: 'currency',
            type: 'line',
            data: revenue.value.flatMap((month) => month.total.affiliate),
            borderColor: rgba('darkOrange', 0.8),
            backgroundColor: rgba('black', 1),
          },
          {
            label: 'Promotion Revenue',
            valueType: 'currency',
            type: 'line',
            data: revenue.value.flatMap((month) => month.total.promotion),
            borderColor: rgba('darkYellow', 0.7),
            backgroundColor: rgba('black', 1),
          },
          {
            label: 'Pro Subscription Revenue',
            valueType: 'currency',
            stack: 'stack1',
            data: customers.value.flatMap((month) => month.pro.revenue),
            backgroundColor: rgba('darkGreen', 0.5),
          },
          {
            label: 'Expert Subscription Revenue',
            valueType: 'currency',
            stack: 'stack1',
            data: customers.value.flatMap((month) => month.expert.revenue),
            backgroundColor: rgba('darkBlue', 0.3),
          },
        ],
      },
    },
    {
      id: 3,
      title: 'Capital Balance and Burn Rate',
      subtitle:
        'Offers a comprehensive view of financial health by showing cash reserves against spending rates.',
      type: 'line',
      data: {
        labels: months.value,
        datasets: [
          {
            label: 'Capital Balance',
            valueType: 'currency',
            data: capital.value.flatMap((month) => month.balance.end),
            borderColor: rgba('lightGreen', 1),
            backgroundColor: rgba('black', 1),
          },
          {
            label: 'Burn Rate',
            valueType: 'currency',
            type: 'bar',
            data: capital.value.flatMap((month) => month.burnRate),
            borderColor: rgba('lightRed', 0.5),
            backgroundColor: rgba('darkRed', 0.3),
          },
        ],
      },
    },

    //
    {
      id: 4,
      title: 'Revenue and Expenses Forecast',
      subtitle:
        'Projects future financial performance, helping investors understand potential growth trajectories.',
      type: 'line',
      data: {
        labels: months.value,
        datasets: [
          {
            label: 'Effective Revenue',
            valueType: 'currency',
            data: totals.value.flatMap((month) => month.income.effective),
            borderColor: rgba('lightGreen', 0.5),
            backgroundColor: rgba('black', 1),
          },
          {
            label: 'Total Revenue',
            valueType: 'currency',
            data: revenue.value.flatMap((month) => month.total.revenue),
            borderColor: rgba('lightPurple', 0.5),
            backgroundColor: rgba('black', 1),
          },
          {
            label: 'Total Expenses',
            valueType: 'currency',
            data: totals.value.flatMap((month) => month.expenses.total),
            borderColor: rgba('lightRed', 0.5),
            backgroundColor: rgba('black', 1),
          },
          {
            label: 'Capital Balance',
            valueType: 'currency',
            data: capital.value.flatMap((month) => month.balance.end),
            type: 'bar',
            backgroundColor: rgba('darkBlue', 0.3),
          },
        ],
      },
    },
    // GROWTH
    {
      title: 'MAU vs Customers',
      subtitle: 'Demonstrates monthly active user acquisition and employee count over time.',
      type: 'line',
      data: {
        labels: months.value,
        datasets: [
          {
            label: 'MAU',
            valueType: 'users',
            data: metrics.value.flatMap((month) => month.mau.total),
            borderColor: rgba('lightGreen', 0.5),
            backgroundColor: rgba('darkGreen', 0.5),
          },
          {
            label: 'Customers',
            type: 'bar',
            valueType: 'users',
            data: metrics.value.flatMap((month) => month.mau.customers),
            borderColor: rgba('lightCyan', 0.5),
            backgroundColor: rgba('darkCyan', 0.5),
          },
        ],
      },
    },
    {
      title: 'Monthly vs. Annual Subscription Growth',
      subtitle:
        'Differentiates between short-term and long-term revenue streams, showcasing subscription stability.',
      type: 'line',
      data: {
        labels: months.value,
        datasets: [
          {
            label: 'Monthly Subscription Revenue',
            valueType: 'currency',
            data: metrics.value.flatMap((month) => month.monthlyRecurringRevenue.effective),
            borderColor: rgba('lightGreen', 0.5),
            backgroundColor: rgba('darkGreen', 0.5),
          },
          {
            label: 'Annual Subscription Revenue',
            valueType: 'currency',
            data: metrics.value.flatMap((month) => month.annualRecurringRevenue.effective),
            borderColor: rgba('lightBlue', 0.5),
            backgroundColor: rgba('darkBlue', 0.5),
          },
        ],
      },
    },
    {
      title: 'User Acquisition / Churn vs Employees',
      subtitle:
        'Tracks new, existing, and churned monthly active users, offering insights into user retention and acquisition strategies.',
      type: 'line',
      data: {
        labels: months.value,
        datasets: [
          {
            label: 'New Users',
            valueType: 'users',
            data: metrics.value.flatMap((month) => month.mau.new),
            borderColor: rgba('lightGreen', 0.5),
            backgroundColor: rgba('darkGreen', 0.5),
          },
          {
            label: 'Total Users',
            valueType: 'users',
            data: metrics.value.flatMap((month) => month.mau.total),
            borderColor: rgba('lightBlue', 0.5),
            backgroundColor: rgba('darkBlue', 0.5),
          },
          {
            label: 'Churned Users',
            valueType: 'users',
            data: metrics.value.flatMap((month) => month.mau.churned),
            borderColor: rgba('darkRed', 0.5),
            backgroundColor: rgba('darkRed', 0.5),
          },
          {
            label: 'Employees',
            valueType: 'employees',
            type: 'bar',
            data: employees.value.flatMap((month) => month.totalCount),
            borderColor: rgba('darkPurple', 0.3),
            backgroundColor: rgba('darkPurple', 0.3),
          },
        ],
      },
    },
    // METRICS
    {
      title: 'Monthly Recurring Revenue (MRR) and Annual Recurring Revenue (ARR) Trends',
      subtitle:
        'Highlights the predictability and stability of revenue, crucial for long-term financial planning.',
      type: 'line',
      data: {
        labels: months.value,
        datasets: [
          {
            label: 'MRR',
            valueType: 'currency',
            data: metrics.value.flatMap((month) => month.monthlyRecurringRevenue.effective),
            borderColor: rgba('darkGreen', 0.7),
            backgroundColor: rgba('black', 1),
          },
          {
            label: 'ARR',
            valueType: 'currency',
            data: metrics.value.flatMap((month) => month.annualRecurringRevenue.effective),
            borderColor: rgba('darkBlue', 0.7),
            backgroundColor: rgba('black', 1),
          },
          {
            label: 'Customers',
            valueType: 'users',
            type: 'bar',
            data: metrics.value.flatMap((month) => month.mau.customers),
            backgroundColor: rgba('darkOrange', 0.3),
          },
        ],
      },
    },
    {
      title: 'Gross Margin and Profit/Loss Margin',
      subtitle:
        'Demonstrates profitability and operational efficiency, key metrics for evaluating business viability.',
      type: 'line',
      data: {
        labels: months.value,
        datasets: [
          {
            label: 'Gross Margin',
            valueType: 'percentage',
            data: metrics.value.flatMap((month) => month.grossMargin),
            borderColor: rgba('lightGreen', 0.5),
            backgroundColor: rgba('darkGreen', 0.2),
          },
          {
            label: 'Profit/Loss Margin',
            valueType: 'percentage',
            data: metrics.value.flatMap((month) => month.profitLossMargin),
            borderColor: rgba('darkRed', 0.5),
            backgroundColor: rgba('darkRed', 0.2),
          },
        ],
      },
    },
    {
      title: 'Cost Per User',
      subtitle:
        'Measures the effectiveness of marketing expenditures in driving revenue, essential for optimizing marketing strategies.',
      type: 'line',
      data: {
        labels: months.value,
        datasets: [
          {
            label: 'Cost Per Free User',
            valueType: 'currency',
            data: metrics.value.flatMap((month) => month.userCost.free.singleCost),
            borderColor: rgba('lightRed', 0.5),
            backgroundColor: rgba('darkRed', 0.5),
          },
          {
            label: 'Cost Per Pro User',
            valueType: 'currency',
            data: metrics.value.flatMap((month) => month.userCost.pro.singleCost),
            borderColor: rgba('lightBlue', 0.5),
            backgroundColor: rgba('darkBlue', 0.5),
          },
          {
            label: 'Cost Per Expert User',
            valueType: 'currency',
            data: metrics.value.flatMap((month) => month.userCost.expert.singleCost),
            borderColor: rgba('lightGreen', 0.5),
            backgroundColor: rgba('darkGreen', 0.5),
          },
        ],
      },
    },
    {
      title: 'Churn Rate and Retention Rate',
      subtitle:
        'Provides insights into customer loyalty and satisfaction, critical for long-term growth.',
      type: 'bar',
      data: {
        labels: months.value,
        datasets: [
          {
            label: 'Total Churn Rate',
            valueType: 'percentage',
            data: metrics.value.flatMap((month) => month.churn.total.rate),
            backgroundColor: rgba('darkOrange', 0.5),
          },
          {
            label: 'Free Churn Rate',
            valueType: 'percentage',
            data: metrics.value.flatMap((month) => month.churn.free.rate),
            backgroundColor: rgba('darkOrange', 0.5),
          },
          {
            label: 'Pro Churn Rate',
            valueType: 'percentage',
            data: metrics.value.flatMap((month) => month.churn.pro.rate),
            backgroundColor: rgba('darkRed', 0.5),
          },
          {
            label: 'Expert Churn Rate',
            valueType: 'percentage',
            data: metrics.value.flatMap((month) => month.churn.expert.rate),
            backgroundColor: rgba('darkRed', 0.5),
          },
          {
            label: 'Free Retention Rate',
            type: 'line',
            valueType: 'percentage',
            data: metrics.value.flatMap((month) => month.retentionRate.free),
            backgroundColor: rgba('black', 1),
            borderColor: rgba('darkOrange', 0.5),
          },
          {
            label: 'Pro Retention Rate',
            type: 'line',
            valueType: 'percentage',
            data: metrics.value.flatMap((month) => month.retentionRate.pro),
            backgroundColor: rgba('black', 1),
            borderColor: rgba('darkRed', 0.5),
          },
          {
            label: 'Expert Retention Rate',
            type: 'line',
            valueType: 'percentage',
            data: metrics.value.flatMap((month) => month.retentionRate.expert),
            backgroundColor: rgba('black', 1),
            borderColor: rgba('darkRed', 0.5),
          },
        ],
      },
    },
    {
      title: 'Customer Lifetime Value (LTV) vs. Customer Acquisition Cost (CAC)',
      subtitle:
        'Shows the return on investment in acquiring customers, indicating business sustainability.',
      type: 'bar',
      scaleType: 'logarithmic',
      data: {
        labels: months.value,
        datasets: [
          {
            label: 'Customer Lifespan',

            valueType: 'months',
            type: 'line',
            data: metrics.value.flatMap((month) => month.customerLifespan.average),
            borderColor: rgba('lightPink', 0.5),
            backgroundColor: rgba('black', 1),
          },
          {
            label: 'LTV',
            valueType: 'currency',
            data: metrics.value.flatMap((month) => month.customerLifetimeValue.average),
            backgroundColor: rgba('lightGreen', 0.5),
          },
          {
            label: 'Free CAC',
            valueType: 'currency',
            data: metrics.value.flatMap((month) => month.customerAcquisitionCost.free),
            backgroundColor: rgba('lightRed', 0.5),
          },
          {
            label: 'Pro CAC',
            valueType: 'currency',
            data: metrics.value.flatMap((month) => month.customerAcquisitionCost.pro),
            backgroundColor: rgba('lightRed', 0.5),
          },
          {
            label: 'Expert CAC',
            valueType: 'currency',
            data: metrics.value.flatMap((month) => month.customerAcquisitionCost.expert),
            backgroundColor: rgba('lightRed', 0.5),
          },
        ],
      },
    },
  ]
})
</script>

<template>
  <FinancialCharts :charts="charts" />
</template>

<style scoped></style>
</file>

<file path="apps/admin-dashboard/components/social/Instagram.vue">
<template>
  <div class="p-4">
    <h1 class="text-2xl font-bold mb-4"> Instagram Profile Metrics </h1>
    <div
      v-if="instagram"
      class="mb-4"
    >
      <PrimeCard>
        <template #header>
          <h2 class="text-xl font-semibold"> Profile Statistics </h2>
        </template>
        <p>Followers Count: {{ instagram.analytics.followers_count }}</p>
        <p>Media Count: {{ instagram.analytics.media_count }}</p>
        <p>Follows Count: {{ instagram.analytics.follows_count }}</p>
      </PrimeCard>
    </div>
    <div v-if="instagram && instagram.insights.length">
      <h2 class="text-xl font-semibold mb-2"> Recent Insights </h2>
      <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
        <PrimeCard
          v-for="insight in instagram.insights"
          :key="insight.id"
          class="w-full"
        >
          <template #header>
            <h3 class="text-lg font-medium">
              {{ insight.title }}
            </h3>
          </template>
          <p>Value: {{ insight.values[0].value }}</p>
          <p>Period: {{ insight.period }}</p>
          <p>End Time: {{ new Date(insight.values[0].end_time).toLocaleDateString() }}</p>
        </PrimeCard>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
const props = defineProps({
  userId: {
    type: String,
    required: true,
  },
})

const social = useSocialStore()
const { instagram } = storeToRefs(social)

onMounted(() => {
  social.getInstagramAnalytics(props.userId)
})
</script>

<style scoped></style>
</file>

<file path="apps/admin-dashboard/components/social/Linkedin.vue">
<template>
  <div class="p-4">
    <h1 class="text-2xl font-bold mb-4"> LinkedIn Page Analytics </h1>
    <div
      v-if="linkedin"
      class="mb-4"
    >
      <PrimeCard>
        <template #header>
          <h2 class="text-xl font-semibold"> Page Statistics </h2>
        </template>
        <p>Impressions: {{ linkedin.impressions }}</p>
        <p>Reactions: {{ linkedin.reactions }}</p>
        <p>Comments: {{ linkedin.comments }}</p>
        <p>Reposts: {{ linkedin.reposts }}</p>
      </PrimeCard>
    </div>
  </div>
</template>

<script setup lang="ts">
const props = defineProps({
  postId: {
    type: String,
    required: true,
  },
})

const social = useSocialStore()
const { linkedin } = storeToRefs(social)

onMounted(() => {
  social.getLinkedInAnalytics(props.postId)
})
</script>

<style scoped></style>
</file>

<file path="apps/admin-dashboard/components/social/Overview.vue">
<template>
  <div>
    <h3> Overview dashboard </h3>
    <PrimeMessage severity="info"> This is a work in progress </PrimeMessage>
  </div>
</template>

<script setup lang="ts"></script>

<style scoped></style>
</file>

<file path="apps/admin-dashboard/components/social/Twitter.vue">
<template>
  <div class="p-4">
    <h1 class="text-2xl font-bold mb-4"> Twitter Post Metrics </h1>
    <div
      v-if="twitter"
      class="mb-4"
    >
      <PrimeCard>
        <template #header>
          <h2 class="text-xl font-semibold"> Post Statistics </h2>
        </template>
        <p>Impressions: {{ twitter.impression_count }}</p>
        <p>Likes: {{ twitter.like_count }}</p>
        <p>Replies: {{ twitter.reply_count }}</p>
        <p>Retweets: {{ twitter.retweet_count }}</p>
        <p>Quote Tweets: {{ twitter.quote_count }}</p>
        <p>URL Link Clicks: {{ twitter.url_link_clicks }}</p>
        <p>User Profile Clicks: {{ twitter.user_profile_clicks }}</p>
      </PrimeCard>
    </div>
  </div>
</template>

<script setup lang="ts">
const props = defineProps({
  postId: {
    type: String,
    required: true,
  },
})

const social = useSocialStore()
const { twitter } = storeToRefs(social)

onMounted(() => {
  social.getTwitterAnalytics(props.postId)
})
</script>

<style scoped></style>
</file>

<file path="apps/admin-dashboard/components/social/Youtube.vue">
<template>
  <div class="p-4">
    <h1 class="text-2xl font-bold mb-4"> YouTube Channel Metrics </h1>
    <div
      v-if="youtube"
      class="mb-4"
    >
      <PrimeCard>
        <template #header>
          <h2 class="text-xl font-semibold"> Channel Statistics </h2>
        </template>
        <p>Channel {{ youtube }}</p>
        <!-- <p>Subscriber Count: {{ youtube.subscriberCount }}</p>
        <p>Total Views: {{ youtube.viewCount }}</p>
        <p>Total Videos: {{ youtube.videoCount }}</p> -->
      </PrimeCard>
    </div>
    <div v-if="youtube && youtube?.videos?.length">
      <h2 class="text-xl font-semibold mb-2"> Recent Videos </h2>
      <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
        <PrimeCard
          v-for="video in youtube.videos"
          :key="video.id.videoId"
          class="w-full"
        >
          <template #header>
            <div class="flex items-center">
              <img
                :src="video.snippet.thumbnails.default.url"
                alt="Thumbnail"
                class="w-16 h-16 mr-4"
              />
              <h3 class="text-lg font-medium">
                {{ video.snippet.title }}
              </h3>
            </div>
          </template>
          <p>Published At: {{ new Date(video.snippet.publishedAt).toLocaleDateString() }}</p>
          <p v-if="video.statistics"> Views: {{ video.statistics.viewCount }} </p>
          <p v-if="video.statistics"> Likes: {{ video.statistics.likeCount }} </p>
        </PrimeCard>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
const props = defineProps({
  id: {
    type: String,
    default: 'AstronEra',
  },
})
const social = useSocialStore()
const { youtube } = storeToRefs(social)

onMounted(() => {
  social.getYoutubeAnalytics(props.id)
})
</script>

<style scoped></style>
</file>

<file path="apps/admin-dashboard/components/tasks/TasksCalendar.vue">
<script setup lang="ts">
import FullCalendar from '@fullcalendar/vue3'
import dayGridPlugin from '@fullcalendar/daygrid'
import interactionPlugin from '@fullcalendar/interaction'

interface Employee {
  id: number
  name: string
}

interface Subtask {
  id: number
  title: string
  completed: boolean
}

interface Task {
  id: number
  title: string
  category: 'financial' | 'metrics' | 'hiring' | 'events' | 'development' | 'milestone'
  assigneeId: number
  gitHubIssueId?: number
  recurrence?: {
    frequency: 'daily' | 'weekly' | 'monthly' | 'yearly'
    interval: number
    endDate?: string
  }
}

interface Goal extends Task {
  date: string
  completed: boolean
  milestoneId?: number
  progress: number
  priority: 'low' | 'medium' | 'high'
  timeSpent: number // in minutes
  description: string
  subtasks: Subtask[]
}

const showTimeTrackerModal = ref(false)
const selectedGoal = ref<Goal | null>(null)
const milestones = ref<Milestone[]>([])
const toast = useNotification()
const tasks = useTasks()

const goals = ref(tasks.goals.value)
watch(
  () => tasks.goals.value,
  (newGoals) => {
    goals.value = newGoals
  },
)

onMounted(async () => {
  await tasks.fetchGoals()
  await tasks.fetchMilestones()
  // await tasks.updateGoalsWithDefaultValues()
})

const employees = ref<Employee[]>([
  { id: 0, name: 'Team' },
  { id: 1, name: 'Shweta' },
  { id: 2, name: 'Mac' },
  { id: 3, name: 'Ruchera' },
  { id: 4, name: 'Omkar' },
  { id: 5, name: 'Ruturaj' },
])

const categories = [
  { name: 'Financial', value: 'financial' },
  { name: 'Metrics', value: 'metrics' },
  { name: 'Hiring', value: 'hiring' },
  { name: 'Events', value: 'events' },
  { name: 'Development', value: 'development' },
  { name: 'Milestone', value: 'milestone' },
]

const selectedEmployee = ref<Employee>({ id: 0, name: 'Team' })
const dragDropEnabled = ref(false)

const showModal = ref(false)
const editingGoal = ref<Goal | null>(null)
const currentGoal = computed(
  () =>
    editingGoal.value ?? {
      id: goals.value.length + 1,
      title: '',
      date: '',
      category: 'events',
      completed: false,
      assigneeId: 0,
    },
)

const priorityFilter = ref('all')

const upcomingGoals = computed(() => {
  const today = new Date()
  return goals.value
    .filter((goal) => !goal.completed && new Date(goal.date) >= today)
    .sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime())
    .slice(0, 5)
})

function handleDateClick(arg: { dateStr: string }) {
  editingGoal.value = {
    id: goals.value.length + 1,
    title: '',
    date: arg.dateStr,
    category: 'events',
    assigneeId: employees.value[0].id,
    completed: false,
  }
  showModal.value = true
}

function handleEventClick(info: { event: { id: string } }) {
  console.log('eventzzz', info)
  const goal = goals.value.find((g) => g.id === parseInt(info.event.id))
  if (goal) {
    console.log('eventzzz', goal)
    selectedGoal.value = goal
    showTimeTrackerModal.value = true
    editingGoal.value = { ...goal }
    showModal.value = true
  }
}

const isNew = (goal: Goal) => !goals.value.some((g) => g.id === goal.id)

async function saveGoal(goal: Goal) {
  try {
    if (isNew(goal)) {
      await tasks.createGoal(goal)
      toast.success({ message: 'Goal created successfully', summary: 'Success' })
    } else {
      await tasks.updateGoal(goal)
      toast.success({ message: 'Goal updated successfully', summary: 'Success' })
    }
    await tasks.fetchGoals()
    showModal.value = false
  } catch (error) {
    toast.error({ message: `Failed to save goal: ${error.message}`, summary: 'Error' })
  }
}

async function deleteGoal(goal: Goal) {
  try {
    await tasks.deleteGoal(goal)
    toast.success({ message: 'Goal deleted successfully', summary: 'Success' })
    await tasks.fetchGoals()
    showModal.value = false
  } catch (error) {
    toast.error({ message: `Failed to delete goal: ${error.message}`, summary: 'Error' })
  }
}

function getEmployeeName(id: number): string {
  const employee = employees.value.find((emp) => emp.id === id)
  return employee ? employee.name : 'Unassigned'
}

const selectedEmployeeId = ref<number>(0)

watch(selectedEmployeeId, (newId) => {
  const selected = employees.value.find((e) => e.id === newId)
  if (selected) {
    filterByAssignee(selected)
  }
})

function filterByAssignee(employee: Employee) {
  console.log('Selected employee', employee)
  selectedEmployee.value = employee
}

const filteredGoals = computed(() => {
  let filtered = goals.value
  if (selectedEmployee.value?.id !== 0) {
    filtered = filtered.filter((goal) => goal.assigneeId === selectedEmployee.value?.id)
  }
  if (priorityFilter.value !== 'all') {
    filtered = filtered.filter((goal) => goal.priority === priorityFilter.value)
  }
  return filtered
})

function formatTime(minutes: number): string {
  const hours = Math.floor(minutes / 60)
  const mins = minutes % 60
  return `${hours}h ${mins}m`
}

const calendarOptions = computed(() => {
  const today = new Date()
  const start = new Date(today.getFullYear(), today.getMonth() - 1, 1) // Start of previous month
  const end = new Date(today.getFullYear() + 1, today.getMonth(), 0)

  return {
    plugins: [dayGridPlugin, interactionPlugin],
    initialView: 'dayGridYear',
    views: {
      dayGridYear: {
        displayEventTime: true,
        duration: { months: 13 },
        buttonText: '13 months',
      },
    },
    initialDate: today,
    timeZone: 'local',
    headerToolbar: {
      start: 'title',
      center: '',
      end: 'prev,next today',
      right: 'dayGridYear,dayGridMonth,dayGridWeek,dayGridDay', // user can switch between the two
    },
    events: filteredGoals.value.map((goal) => ({
      id: goal.id.toString(),
      title: goal.title,
      start: goal.date,
      end: goal.date,
      classNames: [goal.category, goal.completed ? 'completed' : '', `priority-${goal.priority}`],
      extendedProps: {
        assignee: getEmployeeName(goal.assigneeId),
        description: goal.description,
        subtasks: goal.subtasks,
        progress: goal.progress,
      },
    })),
    eventContent: (arg) => {
      const titleEl = document.createElement('div')
      titleEl.innerHTML = arg.event.title
      titleEl.style.fontWeight = 'bold'
      titleEl.style.marginBottom = '2px'

      const progressBar = document.createElement('div')
      progressBar.style.width = `${arg.event.extendedProps.progress}%`
      progressBar.style.height = '4px'
      progressBar.style.backgroundColor = 'rgba(255, 255, 255, 0.7)'
      progressBar.style.position = 'absolute'
      progressBar.style.bottom = '0'
      progressBar.style.left = '0'

      const timeSpent = document.createElement('div')
      timeSpent.innerHTML = ` ${formatTime(arg.event.extendedProps.timeSpent)}`
      timeSpent.style.fontSize = '0.8em'
      timeSpent.style.marginTop = '2px'

      const subtasksInfo = document.createElement('div')
      const completedSubtasks = arg.event.extendedProps.subtasks?.filter(
        (st) => st.completed,
      ).length
      const totalSubtasks = arg.event.extendedProps.subtasks.length
      subtasksInfo.innerHTML = `Subtasks: ${completedSubtasks}/${totalSubtasks}`
      subtasksInfo.style.fontSize = '0.8em'
      subtasksInfo.style.marginTop = '2px'

      return { domNodes: [titleEl, progressBar, timeSpent, subtasksInfo] }
    },
    dateClick: handleDateClick,
    eventClick: handleEventClick,
    height: 'auto',
    visibleRange: {
      start: start,
      end: end,
    },
    editable: dragDropEnabled,
    eventDrop: handleEventDrop,
    showNonCurrentDates: true,
    fixedWeekCount: false,
    dayMaxEvents: 2,
    firstDay: 1,
  }
})

function toggleGoalCompletion(goal: Goal) {
  goal.completed = !goal.completed
  if (goal.completed) {
    goal.subtasks = goal.subtasks.map((st) => ({ ...st, completed: true }))
  }
  tasks.updateGoal(goal)
}

async function handleEventDrop(dropInfo: any) {
  const { event } = dropInfo
  console.log('dropInfo', dropInfo)
  const goal = goals.value.find((g) => g.id.toString() === event.id)
  if (goal) {
    const droppedDate = new Date(event.start)
    console.log('drag 1', droppedDate)
    droppedDate.setDate(droppedDate.getDate() + 1)

    console.log('drag 2', droppedDate)

    const updatedGoal = {
      ...goal,
      date: droppedDate.toISOString().split('T')[0],
    }

    try {
      await tasks.updateGoal(updatedGoal)
      toast.success({ message: 'Goal date updated successfully', summary: 'Success' })
    } catch (error) {
      toast.error({ message: 'Failed to update goal date', summary: 'Error' })
      dropInfo.revert()
    }
  }
}

function toggleDragDrop() {
  dragDropEnabled.value = !dragDropEnabled.value
  toast.info({
    message: `Drag and drop is now ${dragDropEnabled.value ? 'enabled' : 'disabled'}`,
    summary: 'Info',
  })
}

async function fetchGitHubIssue(issueId: number) {
  // Replace with your actual GitHub API call
  const response = await fetch(`https://api.github.com/repos/your-repo/issues/${issueId}`)
  return await response.json()
}

// Function to open GitHub issue in a new tab
function openGitHubIssue(issueId: number) {
  window.open(`https://github.com/your-repo/issues/${issueId}`, '_blank')
}

function handleSubtaskUpdate(goalId: number, subtaskId: number, completed: boolean) {
  const goal = goals.value.find((g) => g.id === goalId)
  if (goal) {
    updateSubtaskCompletion(goal, subtaskId, completed)
  }
}

function updateSubtaskCompletion(goal: Goal, subtaskId: number, completed: boolean) {
  const updatedGoal = { ...goal }
  const subtaskIndex = updatedGoal.subtasks.findIndex((st) => st.id === subtaskId)
  if (subtaskIndex !== -1) {
    updatedGoal.subtasks[subtaskIndex].completed = completed
    updatedGoal.completed = updatedGoal.subtasks.every((st) => st.completed)
    tasks.updateGoal(updatedGoal)
  }
}
</script>

<template>
  <div class="company-goals-calendar h-full">
    <TasksUpcoming
      :goals="upcomingGoals"
      @toggle-completion="toggleGoalCompletion"
    />

    <TasksMilestones
      :goals="filteredGoals"
      :milestones="tasks.milestones"
    />

    <div class="assignee-filter mb-4">
      <PrimeSelect
        v-model="selectedEmployeeId"
        :options="[...employees]"
        option-label="name"
        option-value="id"
        placeholder="Select an assignee"
        @change="filterByAssignee"
      />
    </div>

    <PrimeSelect
      v-model="priorityFilter"
      :options="[
        { label: 'All', value: 'all' },
        { label: 'Low', value: 'low' },
        { label: 'Medium', value: 'medium' },
        { label: 'High', value: 'high' },
      ]"
      option-label="label"
      option-value="value"
      placeholder="Filter by priority"
      class="mb-4"
    />

    <PrimeButton
      :label="dragDropEnabled ? 'Disable Drag & Drop' : 'Enable Drag & Drop'"
      :class="{ 'p-button-success': dragDropEnabled, 'p-button-secondary': !dragDropEnabled }"
      class="mb-4"
      @click="toggleDragDrop"
    />

    <FullCalendar
      :options="calendarOptions"
      class="custom-calendar w-full"
    />

    <PrimeDialog
      v-model:visible="showModal"
      :modal="true"
      :header="editingGoal ? 'Edit Goal' : 'Create Goal'"
    >
      <TasksForm
        :goal="currentGoal"
        :employees="employees"
        :categories="categories"
        :milestones="tasks.milestones"
        :is-new="isNew(currentGoal)"
        @save="saveGoal"
        @delete="deleteGoal"
        @update-subtask="handleSubtaskUpdate"
      />
    </PrimeDialog>
  </div>
</template>

<style scoped>
.upcoming-goals {
  list-style-type: none;
  padding: 0;
}

.upcoming-goals li {
  margin-bottom: 10px;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.upcoming-goals li.completed span {
  text-decoration: line-through;
  color: #888;
}

.goal-form {
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.goal-form input,
.goal-form select {
  padding: 5px;
}

:deep(.fc-daygrid-day-events) {
  padding: 2px;
}

:deep(.fc-event) {
  margin-bottom: 2px;
  line-height: 115%;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  max-height: 60px; /* Approx. two lines of text */
}

:deep(.financial) {
  background-color: #4caf50;
}

:deep(.metrics) {
  background-color: #2196f3;
}

:deep(.hiring) {
  background-color: #ffc107;
}

:deep(.fc-day-disabled) {
  opacity: 0.08;
  background-color: #0084ff;
  pointer-events: none;
}

:deep(.fc-col-header-cell) {
  background-color: #245883 !important;
  border-color: #2196f3;
}

:deep(.fc-scrollgrid-section-header) {
  border-color: #245883 !important;
}

:deep(.events) {
  background-color: #9c27b0;
}

:deep(.completed) {
  opacity: 0.6;
}

.custom-calendar {
  min-height: 1500px;
  /* Header background color */
  --fc-theme-standard-header-bg-color: #3490dc;
  --fc-theme-standard-header-text-color: #ffffff;

  /* Border color */
  --fc-border-color: rgba(255, 255, 255, 0.1);

  /* Navigation button color */
  --fc-button-bg-color: #ffffff;
  --fc-button-border-color: #ffffff;
  --fc-button-text-color: #3490dc;
  --fc-button-hover-bg-color: #f8fafc;
  --fc-button-hover-border-color: #f8fafc;
  --fc-button-hover-text-color: #2779bd;

  /* Today button color */
  --fc-today-button-bg-color: #ffffff;
  --fc-today-button-border-color: #ffffff;
  --fc-today-button-text-color: #3490dc;
  --fc-today-button-hover-bg-color: #f8fafc;
  --fc-today-button-hover-border-color: #f8fafc;
  --fc-today-button-hover-text-color: #2779bd;
}

.custom-calendar .fc .fc-button {
  text-transform: capitalize;
}

:deep(.financial) {
  background-color: #4caf50;
}
:deep(.metrics) {
  background-color: #2196f3;
}
:deep(.hiring) {
  background-color: #ffc107;
}
:deep(.events) {
  background-color: #9c27b0;
}
:deep(.development) {
  background-color: #ff5722;
}
:deep(.milestone) {
  background-color: #795548;
}
:deep(.fc-event-title) {
  color: white;
}

:deep(.priority-low) {
  border-left: 4px solid #4caf50;
}
:deep(.priority-medium) {
  border-left: 4px solid #ffc107;
}
:deep(.priority-high) {
  border-left: 4px solid #f44336;
}
</style>
</file>

<file path="apps/admin-dashboard/components/tasks/TasksForm.vue">
<script setup lang="ts">
interface Subtask {
  title: string
  completed: boolean
}

interface ExtendedGoal extends Goal {
  subtasks: Subtask[]
}

const props = defineProps<{
  goal: ExtendedGoal
  employees: Employee[]
  categories: { name: string, value: string }[]
  milestones: Milestone[]
  isNew: boolean
}>()

const emit = defineEmits<{
  (e: 'save', goal: Goal): void
  (e: 'delete', goal: Goal): void
  (e: 'updateSubtask', goalId: number, subtaskId: number, completed: boolean): void
}>()

const formData = ref<ExtendedGoal>({ ...props.goal, subtasks: props.goal.subtasks || [] })

watch(
  () => props.goal,
  (newGoal) => {
    formData.value = { ...newGoal, subtasks: newGoal.subtasks || [] }
  },
  { deep: true },
)

const progress = computed(() => {
  if (formData.value.subtasks.length === 0) return 0
  const completedSubtasks = formData.value.subtasks.filter((subtask) => subtask.completed).length
  return Math.round((completedSubtasks / formData.value.subtasks.length) * 100)
})

function handleSubmit() {
  emit('save', formData.value)
}

function updateSubtask(subtaskId: number, completed: boolean) {
  const subtask = formData.value.subtasks.find((st) => st.id === subtaskId)
  if (subtask) {
    subtask.completed = completed
    emit('updateSubtask', formData.value.id, subtaskId, completed)
  }
}

function addSubtask() {
  formData.value.subtasks.push({
    id: Date.now(), // Use a temporary ID
    title: '',
    completed: false,
  })
}

function removeSubtask(subtaskId: number) {
  formData.value.subtasks = formData.value.subtasks.filter((st) => st.id !== subtaskId)
}

function updateTimeSpent(time: number) {
  formData.value.timeSpent = time
}
</script>

<template>
  <form
    class="flex gap-6 text-sm"
    @submit.prevent="handleSubmit"
  >
    <!-- Left column: Title, Milestone, Description, and Subtasks -->
    <div class="flex-grow">
      <div class="mb-4">
        <PrimeInputText
          id="title"
          v-model="formData.title"
          placeholder="Goal title"
          class="w-full text-2xl font-bold"
          required
        />
      </div>

      <div class="mb-4">
        <label
          for="milestone"
          class="mb-2 flex items-center font-medium"
        >
          <Icon
            name="mdi:flag"
            class="mr-2"
          />
          Milestone
        </label>
        <PrimeSelect
          id="milestone"
          v-model="formData.milestoneId"
          :options="milestones"
          option-label="title"
          option-value="id"
          placeholder="Select a milestone"
          class="w-full"
        />
      </div>

      <div class="mb-4">
        <label
          for="description"
          class="mb-2 flex items-center font-medium"
        >
          <Icon
            name="mdi:text"
            class="mr-2"
          />
          Description
        </label>
        <PrimeTextarea
          id="description"
          v-model="formData.description"
          rows="6"
          auto-resize
          placeholder="Add a more detailed description..."
          class="w-full"
        />
      </div>

      <div class="mb-4">
        <h3 class="mb-2 flex items-center font-medium">
          <Icon
            name="mdi:checkbox-marked"
            class="mr-2"
          />
          Subtasks
        </h3>
        <ul class="space-y-2 pb-2">
          <li
            v-for="(subtask, index) in formData.subtasks"
            :key="index"
            class="flex items-center"
          >
            <PrimeCheckbox
              v-model="subtask.completed"
              :binary="true"
              class="mr-2"
              @change="updateSubtask(subtask.id, $event)"
            />
            <PrimeInputText
              v-model="subtask.title"
              class="flex-grow"
              placeholder="Subtask title"
            />
            <PrimeButton
              link
              @click="removeSubtask(index)"
            >
              <Icon
                name="mdi:trash"
                size="24px"
              />
            </PrimeButton>
          </li>
        </ul>
        <PrimeButton
          size="small"
          class="flex gap-2"
          @click="addSubtask"
        >
          <Icon
            name="mdi:plus"
            size="24px"
          />
          Add
        </PrimeButton>
      </div>
    </div>

    <!-- Right column: Other details -->
    <div class="w-64">
      <div class="mb-4">
        <label class="mb-2 flex items-center font-medium">
          <Icon
            name="mdi:progress-check"
            class="mr-2"
          />
          Progress
        </label>
        <PrimeProgressBar
          :value="progress"
          class="h-2"
        />
        <span class="text-sm text-gray-600">{{ progress }}% Complete</span>
      </div>

      <div class="mb-4">
        <label
          for="date"
          class="mb-2 flex items-center font-medium"
        >
          <Icon
            name="mdi:calendar"
            class="mr-2"
          />
          Due Date
        </label>
        <PrimeDatePicker
          id="date"
          v-model="formData.date"
          date-format="yy-mm-dd"
          :show-icon="true"
          class="w-full"
          required
        />
      </div>

      <div class="mb-4">
        <label
          for="category"
          class="mb-2 flex items-center font-medium"
        >
          <Icon
            name="mdi:tag"
            class="mr-2"
          />
          Category
        </label>
        <PrimeSelect
          id="category"
          v-model="formData.category"
          :options="categories"
          option-label="name"
          option-value="value"
          placeholder="Select a category"
          class="w-full"
        />
      </div>

      <div class="mb-4">
        <label
          for="priority"
          class="mb-2 flex items-center font-medium"
        >
          <Icon
            name="mdi:flag"
            class="mr-2"
          />
          Priority
        </label>
        <PrimeSelect
          id="priority"
          v-model="formData.priority"
          :options="[
            { label: 'Low', value: 'low' },
            { label: 'Medium', value: 'medium' },
            { label: 'High', value: 'high' },
          ]"
          option-label="label"
          option-value="value"
          placeholder="Select priority"
          class="w-full"
        />
      </div>

      <div class="mb-4">
        <label
          for="assignee"
          class="mb-2 flex items-center font-medium"
        >
          <Icon
            name="mdi:account"
            class="mr-2"
          />
          Assignee
        </label>
        <PrimeSelect
          id="assignee"
          v-model="formData.assigneeId"
          :options="employees"
          option-label="name"
          option-value="id"
          placeholder="Select an assignee"
          class="w-full"
        />
      </div>

      <div class="mb-4">
        <label class="mb-2 flex items-center font-medium">
          <Icon
            name="mdi:clock"
            class="mr-2"
          />
          Time Tracking
        </label>
        <TasksTimeTracker
          :goal="formData"
          @update:time-spent="updateTimeSpent"
        />
      </div>

      <div class="mt-6 flex justify-between">
        <PrimeButton
          type="submit"
          class="mr-2 w-full"
        >
          {{ isNew ? 'Create Goal' : 'Update Goal' }}
        </PrimeButton>
        <PrimeButton
          v-if="!isNew"
          type="button"
          severity="danger"
          class="ml-2 w-full"
          @click="$emit('delete', formData)"
        >
          Delete Goal
        </PrimeButton>
      </div>
    </div>
  </form>
</template>
</file>

<file path="apps/admin-dashboard/components/tasks/TasksMilestones.vue">
<script setup lang="ts">
import { ref, computed } from 'vue'

const props = defineProps<{
  goals: Goal[]
  milestones: Milestone[]
}>()

const showMilestoneDetails = ref(false)
const selectedMilestone = ref<Milestone | null>(null)

const getTasksForMilestone = computed(
  () => (milestoneId: number) => props.goals.filter((goal) => goal.milestoneId === milestoneId),
)

function calculateMilestoneProgress(milestoneId: number) {
  const tasks = getTasksForMilestone.value(milestoneId)
  if (tasks.length === 0) return 0
  const totalProgress = tasks.reduce((sum, task) => sum + task.progress, 0)
  return Math.round(totalProgress / tasks.length)
}

function openMilestoneDetails(milestone: Milestone) {
  selectedMilestone.value = milestone
  showMilestoneDetails.value = true
}
</script>

<template>
  <div class="milestone-overview">
    <h2>Milestones</h2>
    <ul class="milestone-list">
      <li
        v-for="milestone in milestones"
        :key="milestone.id"
        class="milestone-item"
      >
        <div
          class="milestone-header"
          @click="openMilestoneDetails(milestone)"
        >
          <h3>{{ milestone.title }}</h3>
          <span>{{ getTasksForMilestone(milestone.id).length }} tasks</span>
        </div>
        <div class="progress-bar">
          <div
            class="progress"
            :style="{ width: `${calculateMilestoneProgress(milestone.id)}%` }"
          ></div>
        </div>
      </li>
    </ul>

    <PrimeDialog
      v-model:visible="showMilestoneDetails"
      :header="selectedMilestone?.title"
    >
      <div v-if="selectedMilestone">
        <p>{{ selectedMilestone.description }}</p>
        <h4>Tasks:</h4>
        <ul>
          <li
            v-for="task in getTasksForMilestone(selectedMilestone.id)"
            :key="task.id"
          >
            {{ task.title }} ({{ task.progress }}% complete)
          </li>
        </ul>
      </div>
    </PrimeDialog>
  </div>
</template>

<style scoped>
.milestone-list {
  list-style-type: none;
  padding: 0;
}

.milestone-item {
  margin-bottom: 10px;
}

.milestone-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  cursor: pointer;
}

.progress-bar {
  background-color: #056993;
  height: 20px;
  border-radius: 5px;
  overflow: hidden;
}

.progress {
  background-color: #4caf50;
  height: 100%;
}
</style>
</file>

<file path="apps/admin-dashboard/components/tasks/TasksTimeTracker.vue">
<script setup lang="ts">
const props = defineProps<{
  goal: Goal
}>()

const emit = defineEmits<{
  (e: 'update:timeSpent', time: number): void
}>()

const isTracking = ref(false)
let timer: NodeJS.Timeout | null = null
let startTime: number

const startGlobalTimer = inject('startGlobalTimer') as (taskTitle: string) => void
const stopGlobalTimer = inject('stopGlobalTimer') as () => void

function startTimer() {
  if (import.meta.client) {
    isTracking.value = true
    startTime = Date.now()
    timer = setInterval(() => {
      const elapsed = Math.floor((Date.now() - startTime) / 60000)
      emit('update:timeSpent', props.goal.timeSpent + elapsed)
    }, 60000)
    startGlobalTimer(props.goal.title)
  }
}

function stopTimer() {
  if (timer) {
    clearInterval(timer)
    const elapsed = Math.floor((Date.now() - startTime) / 60000)
    emit('update:timeSpent', props.goal.timeSpent + elapsed)
  }
  isTracking.value = false
  stopGlobalTimer()
}

function formatTime(minutes: number) {
  const hours = Math.floor(minutes / 60)
  const remainingMinutes = minutes % 60
  return `${hours}h ${remainingMinutes}m`
}
</script>

<template>
  <div class="flex flex-col space-y-2">
    <h3 class="text-lg font-semibold"> Time Spent: {{ formatTime(goal.timeSpent) }} </h3>
    <div class="flex space-x-2">
      <PrimeButton
        class="rounded-full bg-green-500 p-2 hover:bg-green-600"
        @click="startTimer"
      >
        <Icon
          name="mdi:play"
          size="24px"
        />
      </PrimeButton>
      <PrimeButton
        class="rounded-full bg-red-500 p-2 hover:bg-red-600"
        @click="stopTimer"
      >
        <Icon
          name="mdi:stop"
          size="24px"
        />
      </PrimeButton>
    </div>
  </div>
</template>
</file>

<file path="apps/admin-dashboard/components/tasks/TasksUpcoming.vue">
<script setup lang="ts">
defineProps<{
  goals: Goal[]
}>()

const emits = defineEmits<{
  (e: 'toggle-completion', goal: Goal): void
}>()
</script>

<template>
  <PrimeFieldset
    legend="Upcoming Goals"
    :toggleable="true"
    collapsed
  >
    <ul class="upcoming-goals">
      <li
        v-for="goal in goals"
        :key="goal.id"
        :class="{ completed: goal.completed }"
      >
        <span>{{ goal.title }} ({{ goal.date }})</span>
        <PrimeButton @click="$emit('toggle-completion', goal)">
          {{ goal.completed ? 'Undo' : 'Complete' }}
        </PrimeButton>
      </li>
    </ul>
  </PrimeFieldset>
</template>

<style scoped>
.upcoming-goals {
  list-style-type: none;
  padding: 0;
}

.upcoming-goals li {
  margin-bottom: 10px;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.upcoming-goals li.completed span {
  text-decoration: line-through;
  color: #888;
}
</style>
</file>

<file path="apps/admin-dashboard/components/AdminTools.vue">
<template>
  <div
    class="fixed bottom-5 right-5 z-50 flex cursor-pointer gap-2 rounded-full bg-blue-500 p-3 text-white"
  >
    <IBGlobalTimer ref="globalTimer" />
  </div>
</template>

<script setup lang="ts">
const showPlayground = ref(true)

// You might want to add a method to toggle the playground
const togglePlayground = () => {
  showPlayground.value = !showPlayground.value
}

const globalTimer = ref<InstanceType<typeof IBGlobalTimer> | null>(null)

function startGlobalTimer(taskTitle: string) {
  globalTimer.value?.showTimer(taskTitle)
}

function stopGlobalTimer() {
  globalTimer.value?.stopTimer()
}

provide('startGlobalTimer', startGlobalTimer)
provide('stopGlobalTimer', stopGlobalTimer)
</script>

<style scoped></style>
</file>

<file path="apps/admin-dashboard/components/BusinessPlan.client.vue">
<script setup lang="ts">
const props = defineProps({
  bpSection: {
    type: String,
    required: true,
  },
})

const { error, data: bpMarkdown } = await useLazyAsyncData(`business-plan-${props.bpSection}`, () =>
  queryContent('/bp')
    .where({ section: { $eq: props.bpSection } })
    .findOne(),
)

if (error.value) {
  console.error(error.value)
}

console.log('bpMarkdown', bpMarkdown)
</script>

<template>
  <div class="mx-auto overflow-x-hidden p-4 md:p-6">
    <MDC
      v-if="bpMarkdown"
      :value="bpMarkdown"
      tag="article"
      class="list-item-primary-700 background custom-content prose prose-lg marker:text-primary-700 prose-headings:no-underline prose-h1:border-b-0 prose-h2:border-b-0 prose-h3:border-b-0 prose-h4:border-b-0 prose-h5:border-b-0 prose-h6:border-b-0 mx-auto w-full rounded-md p-8 marker:h-3 marker:w-3"
    />
  </div>
</template>

<style>
.custom-content {
  color: #c8c8c8;
  line-height: 1.6;
  font-family: 'Arial', sans-serif;
  max-width: 700px !important;
}

/* Heading styles */
.custom-content h1,
.custom-content h2,
.custom-content h3,
.custom-content h4,
.custom-content h5,
.custom-content h6 {
  color: #0d7daa;
}

.custom-content h1 a,
.custom-content h2 a,
.custom-content h3 a,
.custom-content h4 a,
.custom-content h5 a,
.custom-content h6 a {
  font-weight: bold;
  color: #0d7daa;
  text-decoration: none !important;
}

/* Bold text */
.custom-content strong {
  color: #957137;
}

/* List items */
.custom-content li {
  color: #c8c8c8;
}

.custom-content ul {
  list-style-type: none;
}

.custom-content ul li::before {
  content: ''; /* You can use any character or emoji here */
  color: #f2f4f6; /* Choose your desired color */
  display: inline-block;
  width: 1em;
  margin-left: -1em;
  margin-right: 0.5em;
}

li::marker {
  color: rgb(255, 255, 255) !important;
}

/* Override max-width for specific elements */
.custom-content > table,
.custom-content > img {
  background-color: #1e1e1e;
  max-width: none !important;
  width: auto !important;
  position: relative !important;
  margin-left: -30% !important;
  margin-right: -30% !important;
}

.custom-content table {
  display: block;
  overflow-x: auto;
  white-space: nowrap;
  border-collapse: separate;
  border-spacing: 0;
  margin: 2em 0;
}

.custom-content th,
.custom-content td {
  min-width: 120px;
  padding: 12px 16px;
  border: 1px solid #1a1a1a;
  text-align: left;
}

.custom-content th {
  background-color: #79bbdd82;
  font-weight: bold;
}

.custom-content tr:nth-child(even) {
  background-color: #67676731;
}

.custom-content pre {
  overflow-x: auto;
  white-space: pre-wrap;
  word-wrap: break-word;
  background-color: #1e1e1e;
  border-radius: 4px;
  padding: 1em;
  font-family: 'Consolas', 'Monaco', monospace;
}

.custom-content img {
  max-width: 100%;
  height: auto;
  display: block;
  margin: 2em auto;
}

@media (max-width: 640px) {
  .custom-content {
    font-size: 16px;
  }
}
</style>
</file>

<file path="apps/admin-dashboard/components/BusinessSystems.vue">
<template>
  <div v-if="diagram">
    <ContentRenderer :value="diagram">
      <div class="prose prose-invert mx-auto pt-10">
        <ContentRendererMarkdown :value="diagram" />
      </div>
    </ContentRenderer>
  </div>
</template>

<script setup lang="ts">
const props = defineProps({
  systemName: {
    type: String,
    required: true,
  },
})

const { data: diagram } = await useAsyncData(`diagram-${props.systemName}`, () =>
  queryContent(`/systems/${props.systemName}`).findOne(),
)
</script>
</file>

<file path="apps/admin-dashboard/components/DatabaseMetrics.vue">
<script setup lang="ts">
import { ref, computed } from 'vue'

interface TimePeriod {
  name: string
  value: string
}

interface TableOption {
  name: string
  value: string
}

interface GrowthData {
  period_end_time: string
  row_count: number
  growth_count: number
  growth_percentage: number
}

const supabase = useSupabaseClient()

const tables: TableOption[] = [
  { name: 'Companies', value: 'companies' },
  { name: 'Company URLs', value: 'company_urls' },
  { name: 'News', value: 'news' },
  { name: 'Users', value: 'user_profiles' },
]

const timePeriods: TimePeriod[] = [
  { name: 'Day', value: '1 day' },
  { name: 'Week', value: '1 week' },
  { name: 'Month', value: '1 month' },
  { name: 'Quarter', value: '3 months' },
  { name: 'Year', value: '1 year' },
]

const selectedTable = ref<string>('companies')
const selectedTimePeriod = ref<string>('1 day')
const numPeriods = ref<number>(6)
const growthData = ref<GrowthData[]>([])
const loading = ref<boolean>(false)
const error = ref<string | null>(null)

const dummyCalculateTableGrowth = (
  tableName: string,
  timePeriod: string,
  numPeriods: number,
): Promise<{ data: GrowthData[], error: any }> => {
  return new Promise((resolve) => {
    setTimeout(() => {
      const baseCount
        = {
          companies: 1000,
          users: 10000,
          products: 5000,
        }[tableName] || 1000

      const growthRates = {
        '1 day': 0.01,
        '1 week': 0.05,
        '1 month': 0.1,
        '3 months': 0.2,
        '1 year': 0.5,
      }

      const baseGrowthRate = growthRates[timePeriod] || 0.01
      const variability = 0.5 // 50% variability in growth rate

      const data: GrowthData[] = []
      let currentCount = baseCount

      for (let i = 0; i < numPeriods; i++) {
        const growthRate = baseGrowthRate * (1 + (Math.random() - 0.5) * variability)
        const growthCount = Math.round(currentCount * growthRate)
        const newCount = currentCount + growthCount

        data.push({
          period_end_time: new Date(Date.now() - i * getMilliseconds(timePeriod)).toISOString(),
          row_count: newCount,
          growth_count: growthCount,
          growth_percentage: growthRate * 100,
        })

        currentCount = newCount
      }

      resolve({ data: data.reverse(), error: null })
    }, 500) // Simulate network delay
  })
}

const getMilliseconds = (period: string): number => {
  const ms = {
    '1 day': 24 * 60 * 60 * 1000,
    '1 week': 7 * 24 * 60 * 60 * 1000,
    '1 month': 30 * 24 * 60 * 60 * 1000,
    '3 months': 90 * 24 * 60 * 60 * 1000,
    '1 year': 365 * 24 * 60 * 60 * 1000,
  }
  return ms[period] || ms['1 day']
}

const fetchData = async () => {
  loading.value = true
  error.value = null
  try {
    const { data, error: rpcError } = await dummyCalculateTableGrowth(
      selectedTable.value,
      selectedTimePeriod.value,
      numPeriods.value,
    )

    // await supabase.rpc('calculate_table_growth', {
    //   p_table_name: selectedTable.value,
    //   p_time_period: selectedTimePeriod.value,
    //   p_num_periods: numPeriods.value
    // })
    if (rpcError) throw rpcError
    growthData.value = data
  } catch (err) {
    error.value = 'Failed to fetch growth data'
    console.error(err)
  }
  loading.value = false
}

const calculateTotalGrowth = () => {
  return growthData.value.reduce((total, period) => total + period.growth_count, 0)
}

const calculateAverageGrowthRate = () => {
  const totalGrowthRate = growthData.value.reduce(
    (total, period) => total + period.growth_percentage,
    0,
  )
  return totalGrowthRate / (growthData.value.length - 1) // Exclude the first period as it's always 0
}

const chartData = computed(() => ({
  labels: growthData.value.map((d) => new Date(d.period_end_time).toLocaleDateString()).reverse(),
  datasets: [
    {
      label: 'Row Count',
      data: growthData.value.map((d) => d.row_count).reverse(),
      borderColor: '#42A5F5',
      tension: 0.4,
    },
    {
      label: 'Growth Percentage',
      data: growthData.value.map((d) => d.growth_percentage).reverse(),
      borderColor: '#66BB6A',
      tension: 0.4,
    },
  ],
}))

const chartOptions = {
  responsive: true,
  maintainAspectRatio: false,
  scales: {
    y: {
      beginAtZero: true,
    },
  },
}

const exportToCSV = () => {
  const headers = ['Period End Time', 'Row Count', 'Growth Count', 'Growth Percentage']
  const csvContent = [
    headers.join(','),
    ...growthData.value.map((row) =>
      [row.period_end_time, row.row_count, row.growth_count, row.growth_percentage].join(','),
    ),
  ].join('\n')

  const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' })
  const link = document.createElement('a')
  if (link.download !== undefined) {
    const url = URL.createObjectURL(blob)
    link.setAttribute('href', url)
    link.setAttribute('download', `${selectedTable.value}_growth_data.csv`)
    link.style.visibility = 'hidden'
    document.body.appendChild(link)
    link.click()
    document.body.removeChild(link)
  }
}
</script>

<template>
  <div class="p-4">
    <h1 class="mb-4 text-2xl font-bold"> Table Growth </h1>

    <div class="mb-4 flex flex-wrap gap-4">
      <PrimeSelect
        v-model="selectedTable"
        :options="tables"
        option-label="name"
        option-value="value"
        placeholder="Select Table"
      />
      <PrimeSelect
        v-model="selectedTimePeriod"
        :options="timePeriods"
        option-label="name"
        option-value="value"
        placeholder="Select Time Period"
      />
      <PrimeInputNumber
        v-model="numPeriods"
        :min="1"
        :max="10"
        placeholder="Number of Periods"
      />
      <PrimeButton
        label="Fetch Data"
        @click="fetchData"
      />
      <PrimeButton
        label="Export to CSV"
        @click="exportToCSV"
      />
    </div>

    <PrimeMessage
      v-if="loading"
      severity="info"
      :life="3000"
    >
      Loading data...
    </PrimeMessage>
    <PrimeMessage
      v-if="error"
      severity="error"
      :closable="true"
    >
      {{ error }}
    </PrimeMessage>

    <div
      v-if="growthData.length"
      class="mb-4 grid grid-cols-1 gap-4 md:grid-cols-3"
    >
      <PrimeCard>
        <template #title> Current Count </template>
        <template #content>
          <p class="text-2xl font-bold">
            {{ growthData[0].row_count }}
          </p>
        </template>
      </PrimeCard>
      <PrimeCard>
        <template #title> Total Growth </template>
        <template #content>
          <p class="text-2xl font-bold">
            {{ calculateTotalGrowth() }}
          </p>
        </template>
      </PrimeCard>
      <PrimeCard>
        <template #title> Average Growth Rate </template>
        <template #content>
          <p class="text-2xl font-bold"> {{ calculateAverageGrowthRate().toFixed(2) }}% </p>
        </template>
      </PrimeCard>
    </div>

    <PrimeCard v-if="growthData.length">
      <template #title> Growth Trend </template>
      <template #content>
        <PrimeChart
          class="min-h-64"
          type="line"
          :data="chartData"
          :options="chartOptions"
        />
      </template>
    </PrimeCard>
  </div>
</template>
</file>

<file path="apps/admin-dashboard/components/ErrorLogViewer.vue">
<script setup lang="ts">
import { useTimeAgo } from '@vueuse/core'

// Define a standard log entry interface
interface NormalizedLogEntry {
  source: string
  message: string
  timestamp: string
  count: number
  severity?: string
  domain?: string
  action?: string
  error?: string
  stack?: string
  [key: string]: any // Allow for additional fields
}

// Create normalizer functions for each source
const normalizeDatabaseLog = (log: any): NormalizedLogEntry => ({
  source: 'DB',
  message: log.event_message.split('ERROR:')[1] || log.body?.event_message || 'Unknown error',
  timestamp:
    log.timestamp || (log.body?.timestamp ? new Date(log.body.timestamp).toISOString() : ''),
  count: 1,
  severity: 'CRITICAL',
  domain: 'database',
  id: log.id || log.body?.id,
  // Note: 'error' and 'stack' fields are not present in the provided structure
  // You might want to extract these from the event_message if they're embedded there
})

const normalizeAPILog = (log: any): NormalizedLogEntry => ({
  source: 'API',
  message: log.message || log,
  timestamp: log.timestamp,
  count: 1,
  severity: log.level,
  domain: log.metadata?.service,
  action: log.endpoint,
  error: log.status_code?.toString(),
  stack: log.stack || JSON.stringify(log.metadata.context),
})

const normalizeFrontendLog = (log: any): NormalizedLogEntry => ({
  source: 'Frontend',
  message: log.message || 'Unknown error',
  timestamp: log.time,
  count: 1,
  severity: log.level,
  domain: log.component,
  action: log.action,
  error: log.type,
  stack: log.stack,
})

// Function to normalize logs from all sources
const normalizeAllLogs = (logs: { source: string, entries: any[] }[]): NormalizedLogEntry[] => {
  return logs.flatMap((sourceLog) => {
    console.log('sourceLog', sourceLog)
    const normalizer
      = sourceLog.source === 'DB'
        ? normalizeDatabaseLog
        : sourceLog.source === 'API'
          ? normalizeAPILog
          : sourceLog.source === 'Frontend'
            ? normalizeFrontendLog
            : (log: any) => ({ ...log, source: sourceLog.source, count: 1 }) // Default normalizer

    return sourceLog.entries.map(normalizer)
  })
}

const props = defineProps<{
  logs: { source: string, entries: any[] }[]
}>()

const normalizedLogs = computed(() => normalizeAllLogs(props.logs))

const uniqueLogs = computed(() => {
  const logMap = new Map()
  normalizedLogs.value.forEach((log) => {
    const key = `${log.source}-${log.message}`
    if (logMap.has(key)) {
      const existingLog = logMap.get(key)
      existingLog.count++
      if (new Date(log.timestamp) > new Date(existingLog.timestamp)) {
        existingLog.timestamp = log.timestamp
      }
    } else {
      logMap.set(key, { ...log })
    }
  })
  return Array.from(logMap.values()).sort((a, b) => {
    if (b.count !== a.count) return b.count - a.count
    return new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime()
  })
})

const copyErrorContext = (log: NormalizedLogEntry) => {
  const context = JSON.stringify(log, null, 2)
  navigator.clipboard.writeText(context)
  // You might want to add a toast notification here to inform the user that the context has been copied
}
</script>

<template>
  <div class="border-color overflow-x-auto rounded-lg border p-4">
    <PrimeAccordion
      :multiple="true"
      :active-index="[0]"
      class="w-full space-y-4"
    >
      <PrimeAccordionPanel
        v-for="(log, index) in uniqueLogs"
        :key="index"
        :value="`${index}`"
      >
        <PrimeAccordionHeader
          :pt="{
            root: 'w-full flex items-center justify-between p-2 rounded-md background',
            toggleicon: 'mr-2',
          }"
          :pt-options="{ mergeSections: true, mergeProps: true }"
        >
          <template #default>
            <div class="w-full items-center justify-between rounded-md p-2">
              <div class="flex w-full items-center gap-2">
                <PrimeTag severity="warning">
                  {{ log.source }}
                </PrimeTag>
                <PrimeTag
                  v-if="log.count > 1"
                  severity="info"
                >
                  {{ log.count }} times
                </PrimeTag>

                <div class="tags-container flex flex-wrap items-center justify-center gap-2">
                  <PrimeTag
                    v-if="log.severity"
                    severity="danger"
                  >
                    {{ log.severity }}
                  </PrimeTag>
                  <PrimeTag
                    v-if="log.domain"
                    severity="info"
                  >
                    {{ log.domain }}
                  </PrimeTag>
                  <PrimeTag
                    v-if="log.action"
                    severity="success"
                  >
                    {{ log.action }}
                  </PrimeTag>

                  <span class="log-timestamp text-sm text-gray-400">
                    {{ useTimeAgo(log.timestamp) }}
                  </span>
                </div>
              </div>
            </div>
          </template>
        </PrimeAccordionHeader>
        <PrimeAccordionContent>
          <div class="log-entry mb-4 rounded-md p-4">
            <p class="log-message mr-2 text-left text-yellow-600">
              {{ log.message }}
            </p>
            <PrimeButton
              severity="link"
              tooltip="Copy error context"
              @click.stop="copyErrorContext(log)"
            >
              <Icon name="mdi:content-copy" />
            </PrimeButton>
            <!-- Error Stack -->
            <div
              v-if="log.stack"
              class="mb-4"
            >
              <h3 class="text-lg mb-2 font-semibold"> Error Stack </h3>
              <pre
                class="max-h-96 overflow-auto whitespace-pre-wrap rounded-md bg-gray-800 p-4 text-sm"
                >{{ log.stack }}</pre
              >
            </div>

            <!-- Additional Fields -->
            <div
              v-for="(value, key) in log"
              :key="key"
              class="mb-2"
            >
              <template
                v-if="
                  ![
                    'source',
                    'message',
                    'timestamp',
                    'count',
                    'severity',
                    'domain',
                    'action',
                    'error',
                    'stack',
                  ].includes(key)
                "
              >
                <strong>{{ key }}:</strong> {{ value }}
              </template>
            </div>
          </div>
        </PrimeAccordionContent>
      </PrimeAccordionPanel>
    </PrimeAccordion>
  </div>
</template>

<style scoped></style>
</file>

<file path="apps/admin-dashboard/components/FileViewer.vue">
<script setup lang="ts">
import { ref, onMounted } from 'vue'

const files = ref([])
const selectedFile = ref('')
const fileContent = ref('')

onMounted(async () => {
  await loadFiles()
})

const loadFiles = async () => {
  try {
    const response = await $fetch('/api/list-files')
    files.value = response.files
  } catch (error) {
    console.error('Error loading files:', error)
  }
}

const viewFile = async (fileName: string) => {
  try {
    const response = await $fetch('/api/view-file', {
      method: 'POST',
      body: { fileName },
    })
    selectedFile.value = fileName
    fileContent.value = response.content
  } catch (error) {
    console.error('Error viewing file:', error)
    fileContent.value = 'Error loading file content'
  }
}
</script>

<template>
  <div class="file-viewer">
    <h2>File Viewer</h2>
    <div class="file-list">
      <ul>
        <li
          v-for="file in files"
          :key="file.name"
        >
          <span @click="viewFile(file.name)">{{ file.name }}</span>
          <span>({{ file.size }} bytes)</span>
        </li>
      </ul>
    </div>
    <div
      v-if="selectedFile"
      class="file-content"
    >
      <h3>{{ selectedFile }}</h3>
      <pre>{{ fileContent }}</pre>
    </div>
  </div>
</template>

<style scoped>
.file-viewer {
  margin-top: 20px;
  border: 1px solid #ccc;
  padding: 20px;
  border-radius: 5px;
}
.file-list ul {
  list-style-type: none;
  padding: 0;
}
.file-list li {
  cursor: pointer;
  margin-bottom: 5px;
}
.file-list li:hover {
  text-decoration: underline;
}
.file-content {
  margin-top: 20px;
  background-color: #f0f0f0;
  padding: 10px;
  border-radius: 5px;
}
</style>
</file>

<file path="apps/admin-dashboard/components/GrowthMetrics.vue">
<script setup lang="ts">
import { useErrorHandler } from '@ib/logger'

const { store, loadMore, refresh, isSelecting } = useSelectData('table_statistics', {
  columns: 'table_name, table_size, row_count, capture_time',
  orderBy: { column: 'capture_time', ascending: false },
  limit: 100,
  initialFetch: true,
})

const { handleError } = useErrorHandler()
const toast = useNotification()
const { format, calculate } = useBaseMetrics()

const isLoading = ref(true)
const metrics = ref([] as any)
const chartData = ref(null)

const chartOptions = reactive({
  plugins: {
    legend: {
      labels: { color: '#ffffff' },
    },
  },
  scales: {
    x: {
      ticks: { color: '#ffffff' },
      grid: { color: 'rgba(255, 255, 255, 0.2)' },
    },
    y: {
      ticks: { color: '#ffffff' },
      grid: { color: 'rgba(255, 255, 255, 0.2)' },
    },
  },
})

const formatBytes = (bytes: number): string => {
  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB']
  if (bytes === 0) return '0 Bytes'
  const i = Math.floor(Math.log(bytes) / Math.log(1024))
  return `${format.roundToN(bytes / Math.pow(1024, i), 2)} ${sizes[i]}`
}

const processData = () => {
  const data = store.items
  if (data.length === 0) return

  const latestData = data[0]
  const previousWeekData = data.find(
    (d) => new Date(d.capture_time) <= new Date(latestData.capture_time - 7 * 24 * 60 * 60 * 1000),
  )

  const uniqueTables = new Set(data.map((d) => d.table_name))

  metrics.value = [
    {
      name: 'Total Tables',
      value: uniqueTables.size,
      growth: 0,
    },
    {
      name: 'Total Size',
      value: formatBytes(latestData.table_size),
      growth: calculate.percentile([latestData.table_size, previousWeekData?.table_size || 0], 50),
    },
    {
      name: 'Total Rows',
      value: latestData.row_count.toLocaleString(),
      growth: calculate.percentile([latestData.row_count, previousWeekData?.row_count || 0], 50),
    },
    {
      name: 'Avg Size per Table',
      value: formatBytes(latestData.table_size / uniqueTables.size),
      growth: calculate.percentile(
        [
          latestData.table_size / uniqueTables.size,
          previousWeekData
            ? previousWeekData.table_size /
              new Set(
                data
                  .filter((d) => d.capture_time <= previousWeekData.capture_time)
                  .map((d) => d.table_name),
              ).size
            : 0,
        ],
        50,
      ),
    },
  ]

  const chartDataMap = data.reverse().reduce((acc, curr) => {
    const date = new Date(curr.capture_time).toLocaleDateString()
    if (!acc[date]) {
      acc[date] = curr.table_size / (1024 * 1024) // Convert to MB
    }
    return acc
  }, {})

  chartData.value = {
    labels: Object.keys(chartDataMap),
    datasets: [
      {
        label: 'Total Table Size (MB)',
        data: Object.values(chartDataMap),
        fill: false,
        borderColor: '#42A5F5',
        tension: 0.4,
      },
    ],
  }
}

onMounted(async () => {
  try {
    await loadMore()
    processData()
  } catch (error) {
    handleError(error, 'Error loading dashboard data')
    toast.error({
      summary: 'Data Load Error',
      message: 'Failed to load dashboard data. Please try again later.',
    })
  } finally {
    isLoading.value = false
  }
})
</script>

<template>
  <div>
    <h1 class="mb-6 text-3xl font-bold"> Growth Dashboard </h1>
    <div
      v-if="isLoading"
      class="flex h-64 items-center justify-center"
    >
      <PrimeProgressSpinner />
    </div>
    <div v-else>
      <div class="grid gap-4">
        <div
          v-for="metric in metrics"
          :key="metric.name"
          class="col-12 md:col-6 lg:col-3"
        >
          <PrimeCard class="h-full">
            <template #title>
              <h2 class="mb-2 text-xl font-semibold">
                {{ metric.name }}
              </h2>
            </template>
            <template #content>
              <div class="mb-2 text-3xl font-bold">
                {{ metric.value }}
              </div>
              <div class="text-sm">
                <span
                  :class="{
                    'text-green-500': metric.growth > 0,
                    'text-red-500': metric.growth < 0,
                  }"
                >
                  {{ metric.growth > 0 ? '' : '' }}
                  {{ Math.abs(metric.growth).toFixed(2) }}%
                </span>
                <span class="ml-1">since last week</span>
              </div>
            </template>
          </PrimeCard>
        </div>
      </div>
      <div class="mt-8">
        <h2 class="mb-4 text-2xl font-semibold"> Table Size Growth </h2>
        <PrimeChart
          type="line"
          :data="chartData"
          :options="chartOptions"
          class="h-96"
        />
      </div>
    </div>
  </div>
</template>

<style scoped></style>
</file>

<file path="apps/admin-dashboard/components/MetricCard.vue">
<template>
  <div class="rounded-lg border border-color background p-4 shadow-lg">
    <h3 class="mb-4 text-xl font-semibold">
      {{ title }}
    </h3>
    <slot></slot>
  </div>
</template>

<script setup lang="ts">
defineProps<{
  title: string
}>()
</script>
</file>

<file path="apps/admin-dashboard/components/RedisManagement.vue">
<script lang="ts" setup>
import { FilterMatchMode } from '@primevue/core/api'

const PAGE_SIZE = 50

const scraperUrl = useRuntimeConfig().public.scraperUrl

const tableData = ref([])
const loading = ref(false)
const totalRecords = ref(0)
const filters = ref({
  table: { matchMode: FilterMatchMode.CONTAINS, value: null },
  category: { matchMode: FilterMatchMode.CONTAINS, value: null },
  type: { matchMode: FilterMatchMode.CONTAINS, value: null },
})

const dialogVisible = ref(false)
const dialogMode = ref<'view' | 'edit'>('view')
const dialogHeader = computed(() => (dialogMode.value === 'view' ? 'View Value' : 'Edit Value'))
const selectedValue = ref('')
const editedValue = ref('')
const selectedKey = ref('')

const loadKeys = async (page = 0, pageSize = PAGE_SIZE) => {
  loading.value = true
  try {
    const response = await fetch(
      `${scraperUrl}/admin/redis/keys?page=${page}&pageSize=${pageSize}&includeValues=true`,
    )

    const data = await response.json()
    console.log('REDIS DATA', data)
    tableData.value = data.keys.map(parseKey)
    totalRecords.value = data.total
  } catch (error) {
    console.error('Failed to fetch keys', error)
  } finally {
    loading.value = false
  }
}

const parseKey = (item: { key: string, value: string }) => {
  const match = item.key.match(/\{(.+?)\}:(.+?):(.+)/)
  if (match) {
    return {
      key: item.key,
      table: match[1],
      category: match[2],
      type: match[3],
      value: item.value,
    }
  }
  return { key: item.key, table: '', category: '', type: '', value: item.value }
}

const onPage = (event: any) => {
  loadKeys(event.page, event.rows)
}

const truncateValue = (value: string) => {
  return value.split(',')
}

const viewFullValue = (data: any) => {
  selectedKey.value = data.key
  selectedValue.value = data.value
  dialogMode.value = 'view'
  dialogVisible.value = true
}

const editValue = (data: any) => {
  selectedKey.value = data.key
  editedValue.value = JSON.stringify(data.value, null, 2)
  dialogMode.value = 'edit'
  dialogVisible.value = true
}

const saveEditedValue = async () => {
  try {
    await fetch(`${scraperUrl}/admin/redis/keys/${encodeURIComponent(selectedKey.value)}`, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ value: editedValue.value }),
    })
    dialogVisible.value = false
    loadKeys() // Refresh the data
  } catch (error) {
    console.error('Failed to update value', error)
  }
}

const deleteKey = async (key: string) => {
  if (confirm('Are you sure you want to delete this key?')) {
    try {
      await fetch(`${scraperUrl}/admin/redis/keys/${encodeURIComponent(key)}`, { method: 'DELETE' })
      loadKeys() // Refresh the data
    } catch (error) {
      console.error('Failed to delete key', error)
    }
  }
}

const flushDatabase = async () => {
  if (confirm('Are you sure you want to flush the entire database?')) {
    try {
      await fetch(`${scraperUrl}/admin/redis/flush`, { method: 'POST' })
      alert('Database flushed successfully')
      loadKeys()
    } catch (error) {
      console.error('Failed to flush database', error)
    }
  }
}

loadKeys()
</script>

<template>
  <div class="p-4">
    <div class="border-color background mb-4 flex items-center gap-4 rounded-md border p-4">
      <h1>Redis Management</h1>
      <PrimeButton @click="loadKeys"> Refresh Keys </PrimeButton>
      <PrimeButton
        severity="danger"
        @click="flushDatabase"
      >
        Flush Database
      </PrimeButton>
    </div>

    <PrimeDataTable
      v-model:filters="filters"
      :value="tableData"
      :paginator="true"
      :rows="PAGE_SIZE"
      filter-display="row"
      :global-filter-fields="['table', 'category']"
      :loading="loading"
      :total-records="totalRecords"
      @page="onPage"
    >
      <PrimeColumn
        field="table"
        header="Table"
        style="max-width: 8rem"
        :sortable="true"
      >
        <template #filter="{ filterModel }">
          <PrimeInputText
            v-model="filterModel.value"
            placeholder="Search by table"
          />
        </template>
      </PrimeColumn>
      <PrimeColumn
        field="category"
        header="Category"
        :sortable="true"
      >
        <template #filter="{ filterModel }">
          <InputText
            v-model="filterModel.value"
            placeholder="Search by category"
          />
        </template>
      </PrimeColumn>
      <PrimeColumn
        field="type"
        header="Type"
        :sortable="true"
      >
        <template #filter="{ filterModel }">
          <PrimeInputText
            v-model="filterModel.value"
            placeholder="Search by type"
          />
        </template>
      </PrimeColumn>
      <PrimeColumn
        field="value"
        header="Value"
        :sortable="false"
      >
        <template #body="slotProps">
          <div class="flex flex-col text-sm max-w-64 text-wrap overflow-scroll">
            <pre>{{ slotProps.data.value }}</pre>
          </div>
        </template>
      </PrimeColumn>
      <PrimeColumn
        field="edit"
        header="Edit"
      >
        <template #body="slotProps">
          <div class="flex flex-col">
            <div class="mt-2 flex gap-2">
              <PrimeButton
                label="View"
                size="small"
                @click="viewFullValue(slotProps.data)"
              />
              <PrimeButton
                label="Edit"
                size="small"
                severity="secondary"
                @click="editValue(slotProps.data)"
              />
              <PrimeButton
                label="Delete"
                size="small"
                severity="danger"
                @click="deleteKey(slotProps.data.key)"
              />
            </div>
          </div>
        </template>
      </PrimeColumn>
    </PrimeDataTable>

    <PrimeDialog
      v-model:visible="dialogVisible"
      :header="dialogHeader"
      :modal="true"
    >
      <template v-if="dialogMode === 'view'">
        <pre>{{ selectedValue }}</pre>
      </template>
      <template v-else-if="dialogMode === 'edit'">
        <PrimeTextarea
          v-model="editedValue"
          rows="10"
          class="w-full"
        ></PrimeTextarea>
      </template>
      <template
        v-if="dialogMode === 'edit'"
        #footer
      >
        <PrimeButton
          label="Save"
          @click="saveEditedValue"
        />
        <PrimeButton
          label="Cancel"
          severity="secondary"
          @click="dialogVisible = false"
        />
      </template>
    </PrimeDialog>
  </div>
</template>
</file>

<file path="apps/admin-dashboard/components/ScriptExecution.vue">
<script setup lang="ts">
import { ref } from 'vue'

const scripts = [
  { name: 'build-all', label: 'Build All', type: 'sh' },
  { name: 'db-setup', label: 'Setup Database', type: 'ts' },
  { name: 'generate-lazy-routes', label: 'Generate Lazy Routes', type: 'ts' },
  { name: 'clean-packages', label: 'Clean Packages', type: 'sh' },
  // Add more scripts as needed
]

const output = ref('')

const executeScript = async (scriptName: string) => {
  try {
    const response = await $fetch('/api/execute-script', {
      method: 'POST',
      body: { scriptName },
    })
    output.value = response.output
  } catch (error) {
    console.error('Error executing script:', error)
    output.value = 'Error executing script. Check console for details.'
  }
}
</script>

<template>
  <div class="script-execution-panel">
    <h2>Script Execution Panel</h2>
    <div class="script-buttons flex gap-2">
      <PrimeButton
        v-for="script in scripts"
        :key="script.name"
        :label="`${script.label} (${script.type})`"
        @click="executeScript(script.name)"
      />
    </div>
    <div
      v-if="output"
      class="output-display"
    >
      <h3>Output:</h3>
      <pre>{{ output }}</pre>
    </div>
  </div>
</template>

<style scoped>
/* ... (styles remain the same) ... */
</style>
</file>

<file path="apps/admin-dashboard/components/ServerErrors.vue">
<script setup lang="ts">
const useErrorDashboard = defineStore('errorDashboard', () => {
  const { fetch } = useBaseFetch()

  const errorReport = ref(null)
  const errorTrends = ref([])
  const errorLogs = ref([])
  const errorPG = ref([])
  const totalLogs = ref(0)
  const currentPage = ref(1)
  const totalPages = ref(1)
  const pageSize = ref(50)
  const selectedDate = ref(new Date())
  const loading = ref(false)
  const error = ref(null as string | null)

  const errorsByDomain = computed(() => errorReport.value?.domainDistribution || {})
  const errorsBySeverity = computed(() => errorReport.value?.severityDistribution || {})
  const errorReduction = computed(() => errorReport.value?.errorReduction || 0)
  const mostFrequentErrors = computed(
    () => errorReport.value?.mostFrequentErrors?.slice(0, 5) || [],
  )
  const errorsByHour = computed(() => {
    return (
      errorLogs.value?.reduce((acc, log) => {
        const hour = new Date(log.timestamp).getHours()
        acc[hour] = (acc[hour] || 0) + 1
        return acc
      }, {}) || {}
    )
  })
  const averageErrorsPerDay = computed(() => {
    const trends = errorReport.value?.historicalTrends?.errorTrends || []
    if (trends.length === 0) return 0
    const total = trends.reduce((sum, day) => sum + day.totalErrors, 0)
    return total / trends.length
  })

  async function fetchErrorReport() {
    loading.value = true
    error.value = null
    try {
      const response = await fetch('/api/error/report', {
        query: { date: selectedDate.value.toISOString() },
      })
      if (!response || !response.data) {
        throw new Error('No data returned from the server')
      }
      errorReport.value = response.data
    } catch (err) {
      console.error('Failed to fetch error report', err)
      error.value = 'Failed to load error report. Please try again later.'
      errorReport.value = null
    } finally {
      loading.value = false
    }
  }

  async function fetchErrorTrends() {
    loading.value = true
    error.value = null
    try {
      const response = await fetch('/api/error/trends', {
        query: { date: selectedDate.value.toISOString() },
      })
      if (!response || !response.data) {
        throw new Error('No data returned from the server')
      }
      errorTrends.value = response.data.trends || []
    } catch (err: any) {
      console.error('Failed to fetch error trends', err)
      error.value = 'Failed to load error trends. Please try again later.'
      errorTrends.value = []
    } finally {
      loading.value = false
    }
  }

  async function fetchErrorLogs() {
    loading.value = true
    error.value = null
    try {
      const response = await fetch('/api/error/logs', {
        query: {
          date: selectedDate.value.toISOString(),
          page: currentPage.value,
          pageSize: pageSize.value,
        },
      })
      if (!response || !response.data) {
        throw new Error('No data returned from the server')
      }
      errorLogs.value = response.data.logs || []
      totalLogs.value = response.data.total || 0
      totalPages.value = response.data.totalPages || 1
    } catch (err) {
      console.error('Failed to fetch error logs', err)
      error.value = 'Failed to load error logs. Please try again later.'
      errorLogs.value = []
      totalLogs.value = 0
      totalPages.value = 1
    } finally {
      loading.value = false
    }
  }

  async function fetchPostgresErrors() {
    loading.value = true
    error.value = null
    try {
      const response = await fetch('/api/error/postgres', {
        query: { date: selectedDate.value.toISOString() },
      })
      if (!response || !response.data) {
        throw new Error('No data returned from the server')
      }
      errorPG.value = response.data || []
    } catch (err) {
      console.error('Failed to fetch postgres errors', err)
      error.value = 'Failed to load postgres errors. Please try again later.' + err
      errorPG.value = []
    } finally {
      loading.value = false
    }
  }

  async function refreshData() {
    await Promise.all([
      fetchErrorReport(),
      fetchErrorLogs(),
      fetchPostgresErrors(),
      fetchErrorTrends(),
    ])
  }

  function setDate(date: Date) {
    selectedDate.value = date
    currentPage.value = 1
    refreshData()
  }

  function setPage(page: number) {
    currentPage.value = page
    fetchErrorLogs()
  }

  watch(pageSize, () => {
    currentPage.value = 1
    fetchErrorLogs()
  })

  return {
    errorReport,
    errorLogs,
    errorPG,
    totalLogs,
    currentPage,
    totalPages,
    pageSize,
    selectedDate,
    loading,
    error,
    errorsByDomain,
    errorsBySeverity,
    errorTrends,
    errorReduction,
    mostFrequentErrors,
    errorsByHour,
    averageErrorsPerDay,
    fetchErrorReport,
    fetchErrorLogs,
    refreshData,
    setDate,
    setPage,
  }
})

const errorDashboard = useErrorDashboard()

const {
  errorsByDomain,
  errorsBySeverity,
  error,
  errorLogs,
  errorPG,
  errorReport,
  errorTrends,
  mostFrequentErrors,
  errorReduction,
  averageErrorsPerDay,
  pageSize,
  totalLogs,
  errorsByHour,
  loading,
  currentPage,
  totalPages,
} = storeToRefs(errorDashboard)

const domainChartData = computed(() => ({
  labels: Object.keys(errorsByDomain.value),
  datasets: [
    {
      data: Object.values(errorsByDomain.value),
      backgroundColor: ['#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF'],
    },
  ],
}))

const severityChartData = computed(() => ({
  labels: Object.keys(errorsBySeverity.value),
  datasets: [
    {
      label: 'Errors',
      data: Object.values(errorsBySeverity.value),
      backgroundColor: '#36A2EB',
    },
  ],
}))

const chartOptions = {
  responsive: true,
  maintainAspectRatio: false,
}

// Computed properties for chart data
const hourlyErrorChartData = computed(() => ({
  labels:
    errorReport.value?.errorTrends?.map((trend) => trend.interval.split(' ')[1].slice(0, 5)) || [],
  datasets: [
    {
      label: 'Hourly Errors',
      data: errorReport.value?.errorTrends?.map((trend) => trend.count) || [],
      backgroundColor: '#FF6384',
      borderColor: '#FF6384',
      valueType: 'number',
      type: 'bar',
    },
  ],
}))

const dailyErrorChartData = computed(() => ({
  labels: errorReport.value?.historicalTrends?.map((trend) => trend.date) || [],
  datasets: [
    {
      label: 'Daily Errors',
      data: errorReport.value?.historicalTrends?.map((trend) => trend.totalErrors) || [],
      backgroundColor: '#36A2EB',
      borderColor: '#36A2EB',
      valueType: 'number',
      type: 'line',
    },
  ],
}))

// Chart configurations
const hourlyErrorChart = computed(() => ({
  id: 1,
  scaleType: 'linear',
  title: 'Hourly Error Trends',
  subtitle: 'Number of errors per hour in the last 24 hours',
  type: 'bar',
  data: hourlyErrorChartData.value,
}))

const dailyErrorChart = computed(() => ({
  id: 2,
  scaleType: 'linear',
  title: 'Daily Error Trends',
  subtitle: 'Total errors per day over time',
  type: 'line',
  data: dailyErrorChartData.value,
}))

onMounted(errorDashboard.refreshData)

const rawDataArray = computed(() => [
  { title: 'Error Trends', data: errorTrends.value },
  { title: 'Error Logs', data: errorLogs.value },
  { title: 'Postgres Errors', data: errorPG.value },
  { title: 'Error Report', data: errorReport.value },
])

const settings = ref()

const toggle = (event) => {
  settings.value.toggle(event)
}
</script>

<template>
  <div class="flex h-full flex-col">
    <PrimeSplitter class="h-full">
      <PrimeSplitterPanel class="h-full overflow-scroll p-4">
        <div class="flex h-full flex-col">
          <div class="flex items-center justify-between gap-4 p-4">
            <h2 class="text-xl font-bold"> {{ totalLogs }} Error Logs </h2>
            <div class="flex items-center gap-2">
              <!-- <PrimeButton
                type="button"
                label="Settings"
                @click="toggle"
              /> -->
              <!-- <PrimePopover ref="settings">
                <DevSettings />
              </PrimePopover> -->
              <PrimeButton
                :loading="loading"
                class="h-full"
                @click="errorDashboard.refreshData"
              >
                <Icon name="mdi:refresh" />
              </PrimeButton>
            </div>
          </div>
          <ErrorLogViewer
            v-if="errorLogs.length > 0 && errorPG.length > 0"
            :logs="[
              { source: 'DB', entries: errorPG },
              { source: 'API', entries: errorLogs },
            ]"
            class="no-scrollbar flex-grow overflow-auto"
          />
          <p
            v-else-if="error"
            class="text-red-500"
          >
            {{ error }}
          </p>
          <p
            v-else-if="loading"
            class="text-gray-500"
          >
            Loading error logs...
          </p>
          <p
            v-else
            class="text-gray-500"
          >
            No logs available for the selected date.
          </p>
        </div>
      </PrimeSplitterPanel>
      <PrimeSplitterPanel class="h-full overflow-scroll p-4">
        <div
          v-if="!loading && !error && errorReport"
          class="h-full overflow-auto"
        >
          <h2 class="mb-4 text-2xl font-bold"> Error Metrics </h2>
          <div class="mb-4 grid grid-cols-1 gap-4 md:grid-cols-2">
            <PrimeCard>
              <template #title> Total Errors </template>
              <template #content>
                <div class="text-4xl font-bold">
                  {{ errorReport.totalErrors }}
                </div>
                <div class="text-sm text-gray-500">
                  {{ errorReduction.toFixed(2) }}% change from yesterday
                </div>
              </template>
            </PrimeCard>
            <PrimeCard>
              <template #title> Average Errors per Day </template>
              <template #content>
                <div class="text-4xl font-bold">
                  {{ averageErrorsPerDay.toFixed(2) }}
                </div>
              </template>
            </PrimeCard>
          </div>
          <PrimeCard
            v-if="Object.keys(errorsByDomain).length > 0"
            class="mb-4"
          >
            <template #title> Domain Distribution </template>
            <template #content>
              <PrimeChart
                type="pie"
                :data="domainChartData"
                :options="chartOptions"
              />
            </template>
          </PrimeCard>
          <PrimeCard
            v-if="Object.keys(errorsBySeverity).length > 0"
            class="mb-4"
          >
            <template #title> Severity Distribution </template>
            <template #content>
              <PrimeChart
                type="bar"
                :data="severityChartData"
                :options="chartOptions"
              />
            </template>
          </PrimeCard>
          <PrimeCard
            v-if="mostFrequentErrors.length > 0"
            class="mb-4"
          >
            <template #title> Most Frequent Errors </template>
            <template #content>
              <ul class="list-disc pl-5">
                <li
                  v-for="freqError in mostFrequentErrors"
                  :key="freqError.message"
                  class="mb-2"
                >
                  {{ freqError.message }} ({{ freqError.count }} occurrences)
                </li>
              </ul>
            </template>
          </PrimeCard>
          <div class="mb-4 grid grid-cols-1 gap-4">
            <PrimeCard>
              <template #title> Hourly Error Trends </template>
              <template #content>
                <Chart :chart="hourlyErrorChart" />
              </template>
            </PrimeCard>
            <PrimeCard>
              <template #title> Daily Error Trends </template>
              <template #content>
                <Chart :chart="dailyErrorChart" />
              </template>
            </PrimeCard>
          </div>
        </div>
        <p
          v-else-if="error"
          class="text-red-500"
        >
          {{ error }}
        </p>
        <p
          v-else-if="loading"
          class="text-gray-500"
        >
          Loading error metrics...
        </p>
        <p
          v-else
          class="text-gray-500"
        >
          No error report available for the selected date.
        </p>
      </PrimeSplitterPanel>
    </PrimeSplitter>
  </div>
</template>
</file>

<file path="apps/admin-dashboard/components/ServerJobs.vue">
<script setup lang="ts">
const store = useServerAnalyticsStore()
const { company, news_links, performance, queue, isConnected, haveMetrics } = storeToRefs(store)

interface FlatMetric {
  key: string
  value: any
  path: string[]
}

function formatMetricValue(value: any, key: string): string {
  if (typeof value === 'number') {
    switch (key) {
      case 'cpu_usage':
      case 'memory_usage':
        return `${value.toFixed(2)}%`
      case 'free_memory':
      case 'total_memory':
      case 'heap_used':
      case 'heap_total':
      case 'external_memory':
      case 'heap_limit':
        return formatBytes(value)
      case 'load_average_1m':
      case 'load_average_5m':
      case 'load_average_15m':
        return value.toFixed(2)
      case 'uptime':
        return formatUptime(value)
      default:
        return value.toLocaleString()
    }
  } else if (value instanceof Date) {
    return value.toLocaleString()
  } else {
    return String(value)
  }
}

function formatBytes(bytes: number): string {
  const units = ['B', 'KB', 'MB', 'GB', 'TB']
  let i = 0
  while (bytes >= 1024 && i < units.length - 1) {
    bytes /= 1024
    i++
  }
  return `${bytes.toFixed(2)} ${units[i]}`
}

function formatUptime(seconds: number): string {
  const days = Math.floor(seconds / (3600 * 24))
  const hours = Math.floor((seconds % (3600 * 24)) / 3600)
  const minutes = Math.floor((seconds % 3600) / 60)
  const remainingSeconds = Math.floor(seconds % 60)

  const parts = []
  if (days > 0) parts.push(`${days}d`)
  if (hours > 0) parts.push(`${hours}h`)
  if (minutes > 0) parts.push(`${minutes}m`)
  if (remainingSeconds > 0 || parts.length === 0) parts.push(`${remainingSeconds}s`)

  return parts.join(' ')
}

function flattenMetrics(obj: any, prefix: string[] = []): FlatMetric[] {
  let flattened: FlatMetric[] = []

  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      const value = obj[key]
      const newPrefix = [...prefix, key]

      if (typeof value === 'object' && value !== null && !(value instanceof Date)) {
        flattened = flattened.concat(flattenMetrics(value, newPrefix))
      } else {
        flattened.push({
          key: key,
          value: value,
          path: newPrefix,
        })
      }
    }
  }

  return flattened
}

const allMetrics = computed(() => ({
  company: company.value,
  news_links: news_links.value,
  performance: performance.value,
  queue: queue.value,
}))

const flatMetrics = computed<FlatMetric[]>(() => {
  return flattenMetrics(allMetrics.value)
})

const metricCategories = computed(() => {
  return [...new Set(flatMetrics.value.map((metric) => metric.path[0]))]
})

function getCategoryMetrics(category: string): FlatMetric[] {
  return flatMetrics.value.filter((metric) => metric.path[0] === category)
}

function formatCategoryName(name: string): string {
  return name.replace(/([A-Z])/g, ' $1').trim()
}

function formatMetricName(name: string): string {
  return name.replace(/([A-Z])/g, ' $1').trim()
}
</script>

<template>
  <div class="metrics-display flex flex-col justify-start items-start gap-4">
    <div
      v-if="isConnected"
      class="text-green-500 p-2 rounded-md border border-green-500"
    >
      Scraper Connected
    </div>
    <div
      v-else
      class="text-red-500 p-2 rounded-md border border-red-500"
    >
      Disconnected
    </div>
    <div
      v-if="haveMetrics"
      class="grid gap-4 md:grid-cols-2 xl:grid-cols-3 xl:gap-8"
    >
      <div
        v-for="category in metricCategories"
        :key="category"
        class="mb-8"
      >
        <h2 class="mb-4 text-2xl font-semibold capitalize">
          {{ formatCategoryName(category) }}
        </h2>
        <PrimeCard class="shadow-md">
          <template #title>
            {{ formatCategoryName(category) }}
          </template>
          <template #content>
            <div
              v-for="metric in getCategoryMetrics(category)"
              :key="metric.path.join('.')"
              class="mb-2"
            >
              <strong>{{ formatMetricName(metric.key) }}:</strong>
              {{ formatMetricValue(metric.value, metric.key) }}
            </div>
          </template>
        </PrimeCard>
      </div>
    </div>
  </div>
</template>
</file>

<file path="apps/admin-dashboard/components/SpiderAnalytics.vue">
<script setup lang="ts">
const store = useServerAnalyticsStore()
const { news_links, isConnected, haveMetrics } = storeToRefs(store)

watch(
  news_links,
  (newMetrics) => {
    console.log('Spider Metrics updated:', newMetrics)
  },
  { deep: true },
)

const urlDepthChart = ref(null)
const protocolChart = ref(null)

// Common chart options
const commonChartOptions = {
  responsive: true,
  maintainAspectRatio: false,
  animation: false, // Disable default animations
  transitions: {
    active: {
      animation: {
        duration: 300,
      },
    },
    resize: {
      animation: {
        duration: 500,
        easing: 'easeOutQuad',
      },
    },
  },
  plugins: {
    legend: {
      labels: {
        font: {
          family: '\'Helvetica Neue\', \'Helvetica\', \'Arial\', sans-serif',
        },
      },
    },
  },
}

const urlDepthChartOptions = {
  ...commonChartOptions,
  scales: {
    x: {
      ticks: {
        font: {
          family: '\'Helvetica Neue\', \'Helvetica\', \'Arial\', sans-serif',
        },
      },
    },
    y: {
      beginAtZero: true,
      ticks: {
        font: {
          family: '\'Helvetica Neue\', \'Helvetica\', \'Arial\', sans-serif',
        },
      },
    },
  },
}

const protocolChartOptions = {
  ...commonChartOptions,
  plugins: {
    ...commonChartOptions.plugins,
    legend: {
      ...commonChartOptions.plugins.legend,
      position: 'bottom',
    },
  },
}

const urlDepthChartData = computed(() => {
  const depthStats = news_links.value?.depthStats ?? {}
  return {
    labels: Object.keys(depthStats),
    datasets: [
      {
        label: 'New URLs',
        data: Object.values(depthStats).map((stat: any) => stat?.new ?? 0),
        backgroundColor: '#36A2EB',
      },
      {
        label: 'Allowed URLs',
        data: Object.values(depthStats).map((stat: any) => stat?.allowed ?? 0),
        backgroundColor: '#FFCE56',
      },
    ],
  }
})

const protocolChartData = computed(() => ({
  labels: ['HTTP', 'HTTPS'],
  datasets: [
    {
      data: [
        news_links.value?.protocolDistribution?.http ?? 0,
        news_links.value?.protocolDistribution?.https ?? 0,
      ],
      backgroundColor: ['#FF6384', '#36A2EB'],
    },
  ],
}))

const isSpiderActive = computed(() => !!news_links.value?.crawlDuration)

const rawDataArray = computed(() =>
  isSpiderActive.value
    ? [
        {
          title: 'Spider Metrics',
          data: {
            crawlDuration: news_links.value.crawlDuration,
            urlsPerSecond: news_links.value.urlsPerSecond,
            responseTimeStats: news_links.value.responseTimeStats,
            urlCounts: news_links.value.urlCounts,
            depthStats: news_links.value.depthStats,
            protocolDistribution: news_links.value.protocolDistribution,
          },
        },
        {
          title: 'URL Depth Data',
          data: urlDepthChartData.value,
        },
        {
          title: 'Protocol Distribution Data',
          data: protocolChartData.value,
        },
      ]
    : [],
)
</script>

<template>
  <div class="p-4">
    {{ news_links }}
    <div v-if="isConnected"> Connected </div>
    <div v-else> Disconnected </div>
    <div v-if="haveMetrics && isSpiderActive">
      <div class="mb-8">
        <h2 class="mb-4 text-2xl font-semibold"> Spider Metrics </h2>
        <div class="grid grid-cols-1 gap-4 pb-4 md:grid-cols-2 lg:grid-cols-3">
          <PrimeCard class="foreground">
            <template #title> Crawl Duration </template>
            <template #content>
              <div class="text-4xl font-bold"> {{ news_links.crawlDuration / 1000 }}s </div>
            </template>
          </PrimeCard>
          <PrimeCard class="shadow-md">
            <template #title> URLs per Second </template>
            <template #content>
              <div class="text-4xl font-bold">
                {{ news_links.urlsPerSecond }}
              </div>
            </template>
          </PrimeCard>
          <PrimeCard class="shadow-md">
            <template #title> Avg Response Time </template>
            <template #content>
              <div class="text-4xl font-bold"> {{ news_links.responseTimeStats.average }}ms </div>
            </template>
          </PrimeCard>
        </div>
        <PrimeCard class="shadow-md">
          <template #title> Total URLs </template>
          <template #content>
            <div class="text-4xl font-bold">
              {{ news_links.urlCounts.total }}
            </div>
          </template>
        </PrimeCard>
        <PrimeCard class="shadow-md">
          <template #title> New URLs </template>
          <template #content>
            <div class="text-4xl font-bold">
              {{ news_links.urlCounts.new }}
            </div>
          </template>
        </PrimeCard>
        <PrimeCard class="shadow-md">
          <template #title> Allowed URLs </template>
          <template #content>
            <div class="text-4xl font-bold">
              {{ news_links.urlCounts.allowed }}
            </div>
          </template>
        </PrimeCard>
      </div>

      <div class="mt-6 grid grid-cols-1 gap-6 md:grid-cols-2">
        <PrimeChart
          ref="urlDepthChart"
          type="bar"
          :data="urlDepthChartData"
          :options="urlDepthChartOptions"
          class="h-64"
        />
        <PrimeChart
          ref="protocolChart"
          type="doughnut"
          :data="protocolChartData"
          :options="protocolChartOptions"
          class="h-64"
        />
      </div>
    </div>
    <div v-else>
      <div class="background border-color rounded-md border p-2 text-2xl font-semibold">
        Spider is not active
      </div>
    </div>
  </div>
</template>
</file>

<file path="apps/admin-dashboard/components/TableGrowth.vue">
<script setup lang="ts">
import { useChangeCase } from '@vueuse/integrations/useChangeCase'
import { useErrorHandler } from '@ib/logger'

const supabase = useSupabaseClient()
const { handleError } = useErrorHandler()
const toast = useNotification()

const tables = [
  'news',
  'companies',
  'company_urls',
  'user_profiles',
  'content_sources',
  'contents',
  'blacklisted_domains',
  'blacklisted_urls',
  'searches',
  'research',
]

const growthData = ref<Record<string, any>>({})
const isLoading = ref(true)
const useFakeData = ref(false)

const fetchGrowthData = async (table: string) => {
  if (useFakeData.value) {
    return generateFakeGrowthData(table)
  }

  try {
    const [daily, weekly, monthly] = await Promise.all([
      supabase.rpc('calculate_table_growth', {
        p_table_name: table,
        p_time_period: '1 day',
        p_num_periods: 30,
      }),
      supabase.rpc('calculate_table_growth', {
        p_table_name: table,
        p_time_period: '1 week',
        p_num_periods: 12,
      }),
      supabase.rpc('calculate_table_growth', {
        p_table_name: table,
        p_time_period: '1 month',
        p_num_periods: 12,
      }),
    ])

    return {
      daily: daily.data,
      weekly: weekly.data,
      monthly: monthly.data,
    }
  } catch (error) {
    handleError(error, `Error fetching growth data for ${table}`)
    return null
  }
}

const generateFakeGrowthData = (table: string) => {
  const generatePeriodData = (periodCount: number, baseRowCount: number) => {
    let rowCount = baseRowCount
    return Array.from({ length: periodCount }, (_, i) => {
      const growth = Math.random() * 0.1 - 0.05 // Random growth between -5% and 5%
      rowCount = Math.max(0, Math.round(rowCount * (1 + growth)))
      return {
        period_end_time: new Date(Date.now() - (periodCount - i - 1) * 86400000).toISOString(),
        row_count: rowCount,
        growth_count: i === 0 ? 0 : rowCount - baseRowCount,
        growth_percentage: i === 0 ? 0 : ((rowCount - baseRowCount) / baseRowCount) * 100,
      }
    })
  }

  const baseRowCount = Math.floor(Math.random() * 10000) + 1000 // Random base count between 1000 and 11000
  return {
    daily: generatePeriodData(30, baseRowCount),
    weekly: generatePeriodData(12, baseRowCount),
    monthly: generatePeriodData(12, baseRowCount),
  }
}

const processGrowthData = (data: any) => {
  if (!data) return null

  const getLatestGrowth = (periodData: any[]) => {
    return periodData.sort(
      (a, b) => new Date(b.period_end_time).getTime() - new Date(a.period_end_time).getTime(),
    )[0]
  }

  return {
    daily: {
      latest: getLatestGrowth(data.daily),
      data: data.daily,
    },
    weekly: {
      latest: getLatestGrowth(data.weekly),
      data: data.weekly,
    },
    monthly: {
      latest: getLatestGrowth(data.monthly),
      data: data.monthly,
    },
  }
}

const fetchAllGrowthData = async () => {
  for (const table of tables) {
    const data = await fetchGrowthData(table)
    growthData.value[table] = processGrowthData(data)
  }
  isLoading.value = false
}

const formatNumber = (num: number) => {
  if (isNaN(num) || num < 0) return 'N/A'
  return new Intl.NumberFormat().format(Math.round(num))
}

const formatPercentage = (num: number) => {
  if (isNaN(num)) return 'N/A'
  return `${num > 0 ? '+' : ''}${num.toFixed(2)}%`
}

const getGrowthClass = (growth: number) => {
  if (isNaN(growth)) return 'text-gray-500'
  return growth > 0 ? 'text-green-500' : growth < 0 ? 'text-red-500' : 'text-gray-500'
}

const getGrowthIcon = (growth: number) => {
  if (isNaN(growth)) return 'mdi:minus-circle-outline'
  return growth > 0
    ? 'material-symbols:trending-up-rounded'
    : growth < 0
      ? 'material-symbols:trending-down-rounded'
      : 'mdi:minus-circle-outline'
}

const totalRowCount = computed(() => {
  return Object.values(growthData.value).reduce((sum, table: any) => {
    const count = table?.daily?.latest.row_count || 0
    return sum + (count > 0 ? count : 0)
  }, 0)
})

const getSparklineData = (table: string, period: string) => {
  const data = growthData.value[table]?.[period]?.data || []

  const borderColor =
    growthData.value[table]?.[period]?.latest.growth_percentage > 0 ? '#4CAF50' : '#F44336'

  return {
    labels: data.map((d: any) => d.period_end_time),
    datasets: [
      {
        data: data.map((d: any) => d.row_count),
        borderColor,
        borderWidth: 2,
        fill: false,
        pointRadius: 0,
      },
    ],
  }
}

const sparklineOptions = {
  responsive: true,
  maintainAspectRatio: false,
  plugins: {
    legend: { display: false },
    tooltip: { enabled: false },
  },
  scales: { x: { display: false }, y: { display: false } },
  elements: {
    line: {
      tension: 0.4, // Smooth line
    },
    point: {
      radius: 0, // Hide points
    },
  },
  interaction: {
    intersect: false,
    mode: 'index',
    hover: {
      mode: null, // Disable hover mode
    },
  },
  animation: {
    duration: 0, // Disable all animations
  },
}

onMounted(async () => {
  try {
    await fetchAllGrowthData()
  } catch (error) {
    handleError(error, 'Error loading dashboard data')
    toast.error({
      summary: 'Data Load Error',
      message: 'Failed to load dashboard data. Please try again later.',
    })
  }
})
</script>

<template>
  <div class="table-growth-dashboard overflow-hidden bg-gray-900 p-4 text-white">
    <h1 class="mb-8 py-12 text-center text-5xl font-bold"> Table Growth Dashboard </h1>
    <div
      v-if="isLoading"
      class="flex h-64 items-center justify-center"
    >
      <PrimeProgressSpinner />
    </div>
    <div v-else>
      <div class="mb-8 grid grid-cols-1 gap-6 md:grid-cols-2 lg:grid-cols-3">
        <IBGlass class="lg:col-start-2">
          <template #header>
            <h2 class="mb-2 text-2xl font-semibold"> Total Row Count </h2>
          </template>
          <template #default>
            <div class="text-5xl font-bold">
              {{ formatNumber(totalRowCount) }}
            </div>
          </template>
        </IBGlass>
      </div>
      <div class="mb-8 grid grid-cols-1 gap-6 md:grid-cols-2 lg:grid-cols-3">
        <IBGlass
          v-for="table in tables"
          :key="table"
        >
          <template #header>
            <h2 class="pb-4 text-2xl font-bold">
              {{ useChangeCase(table, 'capitalCase') }}
            </h2>
          </template>
          <template #default>
            <div v-if="growthData[table]">
              <div
                v-for="period in ['daily', 'weekly', 'monthly']"
                :key="period"
                class="mb-2"
              >
                <div class="flex items-center justify-between">
                  <strong class="capitalize">{{ period }} Growth:</strong>
                  <div class="flex items-center">
                    <Icon
                      :name="getGrowthIcon(growthData[table][period].latest.growth_percentage)"
                      :class="getGrowthClass(growthData[table][period].latest.growth_percentage)"
                      class="mr-2"
                      size="24px"
                    />
                    <span
                      :class="getGrowthClass(growthData[table][period].latest.growth_percentage)"
                    >
                      {{ formatPercentage(growthData[table][period].latest.growth_percentage) }}
                    </span>
                  </div>
                </div>
                <PrimeChart
                  type="line"
                  :data="getSparklineData(table, period)"
                  :options="sparklineOptions"
                  class="mt-1 h-8"
                />
              </div>
              <div class="mt-4">
                <strong>Total Rows:</strong>
                {{ formatNumber(growthData[table].daily.latest.row_count) }}
              </div>
            </div>
            <div
              v-else
              class="italic text-gray-400"
            >
              No data available
            </div>
          </template>
        </IBGlass>
      </div>
    </div>
  </div>
</template>

<style scoped>
.table-growth-dashboard {
  font-family: 'Arial', sans-serif;
}
.p-card {
  transition: all 0.3s ease;
}
.p-card:hover {
  transform: translateY(-5px);
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
}
</style>
</file>

<file path="apps/admin-dashboard/components/Upload.vue">
<script setup lang="ts">
import { useFileUpload } from '#imports'

const user = useSupabaseUser()

const {
  uploadFile,
  queueUpload,
  cancelUpload,
  clearQueue,
  isUploading,
  isProcessing,
  uploadProgress,
  currentUpload,
  uploadQueue,
} = useFileUpload()

const buckets = [
  { name: 'user-profiles', label: 'User Profiles' },
  { name: 'public-assets', label: 'Public Assets' },
  { name: 'private-documents', label: 'Private Documents' },
]

const paths = {
  'user-profiles': ['avatars', 'cover-photos', 'galleries'],
  'public-assets': ['blog-images', 'marketing-materials'],
  'private-documents': ['user-uploads'],
}

const fileTypes = [
  { name: 'avatar', label: 'Avatar' },
  { name: 'cover-photo', label: 'Cover Photo' },
  { name: 'gallery-image', label: 'Gallery Image' },
  { name: 'document', label: 'Document' },
  { name: 'other', label: 'Other' },
]

const bucket = ref(buckets[0].name)
const path = ref(paths[bucket.value][0])
const fileType = ref(fileTypes[0].name)

const maxFileSize = ref(5 * 1024 * 1024) // 5MB

const allowedMimeTypes = ref(['image/*', 'application/pdf'])

const uploadedFiles = ref<any[]>([])

const onUpload = (event: any) => {
  uploadedFiles.value.push(...event.files)
}

const onSelect = (event: any) => {
  event.files.forEach((file: File) => {
    queueUpload(file, {
      bucket: bucket.value,
      path: path.value,
      fileType: fileType.value as any,
      userId: user.value?.id,
      optimizeImage: true,
      maxWidth: 1200,
      maxHeight: 1200,
      quality: 80,
      format: 'webp',
      rateLimitMs: 1000,
      maxFileSize: maxFileSize.value,
      allowedMimeTypes: allowedMimeTypes.value,
      onProgress: (progress) => {
        console.log(`Upload progress: ${progress}%`)
      },
      auditLog: async (action, details) => {
        console.log(action, details)
        // Implement your audit logging here
      },
    })
  })
}

const onRemove = (event: any) => {
  console.log('File removed:', event.file)
}

const formatSize = (bytes: number) => {
  if (bytes === 0) return '0 B'
  const k = 1024
  const sizes = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']
  const i = Math.floor(Math.log(bytes) / Math.log(k))
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i]
}

const totalSize = computed(() => {
  return formatSize(uploadQueue.value.reduce((acc, file) => acc + file.size, 0))
})

const totalSizePercent = computed(() => {
  const total = uploadQueue.value.reduce((acc, file) => acc + file.size, 0)
  return (total / maxFileSize.value) * 100
})

const uploadEvent = (uploadCallback: () => void) => {
  uploadCallback()
}

const fileURL = (file: File) => URL.createObjectURL(file)

watch(bucket, (newBucket) => {
  path.value = paths[newBucket][0]
})
</script>

<template>
  <div class="p-4">
    <h2 class="mb-4 text-2xl font-bold"> File Uploads </h2>
    <div class="mb-4 flex flex-wrap gap-4">
      <span class="flex flex-col gap-2">
        <label
          for="bucket"
          class="pl-2"
          >Bucket</label
        >
        <PrimeSelect
          id="bucket"
          v-model="bucket"
          :options="buckets"
          option-label="label"
          option-value="name"
        />
      </span>
      <span class="flex flex-col gap-2">
        <label
          for="path"
          class="pl-2"
          >Path</label
        >
        <PrimeSelect
          id="path"
          v-model="path"
          :options="paths[bucket]"
        />
      </span>
      <span class="flex flex-col gap-2">
        <label
          for="fileType"
          class="pl-2"
          >File Type</label
        >
        <PrimeSelect
          id="fileType"
          v-model="fileType"
          :options="fileTypes"
          option-label="label"
          option-value="name"
        />
      </span>
    </div>
    <PrimeFileUpload
      name="demo[]"
      url="/api/upload"
      :multiple="true"
      accept="image/*,application/pdf"
      :max-file-size="maxFileSize"
      @upload="onUpload"
      @select="onSelect"
      @remove="onRemove"
    >
      <template #header="{ chooseCallback, uploadCallback, clearCallback, files }">
        <div class="flex flex-1 flex-wrap items-center justify-between gap-4">
          <div class="flex gap-2">
            <PrimeButton
              rounded
              outlined
              severity="contrast"
              @click="chooseCallback()"
            >
              <Icon
                name="mdi:file-image"
                size="32px"
              />
            </PrimeButton>
            <PrimeButton
              rounded
              outlined
              severity="success"
              :disabled="!files || files.length === 0"
              @click="uploadEvent(uploadCallback)"
            >
              <Icon
                name="mdi:cloud-upload"
                size="32px"
              />
            </PrimeButton>
            <PrimeButton
              rounded
              outlined
              severity="danger"
              :disabled="!files || files.length === 0"
              @click="clearCallback()"
            >
              <Icon
                name="mdi:delete"
                size="32px"
              />
            </PrimeButton>
          </div>
          <PrimeProgressBar
            :value="totalSizePercent"
            :show-value="false"
            class="md:w-20rem h-1 w-full md:ml-auto"
          >
            <span class="whitespace-nowrap">{{ totalSize }} / {{ formatSize(maxFileSize) }}</span>
          </PrimeProgressBar>
        </div>
      </template>
      <template #content="{ files, removeUploadedFileCallback, removeFileCallback }">
        <div class="flex flex-col gap-8 pt-4">
          <div v-if="files.length > 0">
            <h5>Pending</h5>
            <div class="flex flex-wrap gap-4">
              <div
                v-for="(file, index) of files"
                :key="file.name + file.type + file.size"
                class="flex flex-col items-center gap-4 border p-8 border-surface rounded-border"
              >
                <div>
                  <NuxtImg
                    v-if="file.type.startsWith('image/')"
                    role="presentation"
                    :alt="file.name"
                    :src="fileURL(file)"
                    width="100"
                    height="50"
                  />
                  <Icon
                    v-else
                    name="mdi:file"
                    class="text-4xl"
                  ></Icon>
                </div>
                <span
                  class="max-w-60 overflow-hidden text-ellipsis whitespace-nowrap font-semibold"
                  >{{ file.name }}</span
                >
                <div>{{ formatSize(file.size) }}</div>
                <PrimeBadge
                  value="Pending"
                  severity="warn"
                />
                <PrimeButton
                  icon="pi pi-times"
                  outlined
                  rounded
                  severity="danger"
                  @click="removeFileCallback(index)"
                />
              </div>
            </div>
          </div>
          <div v-if="uploadedFiles.length > 0">
            <h5>Completed</h5>
            <div class="flex flex-wrap gap-4">
              <div
                v-for="(file, index) of uploadedFiles"
                :key="file.name + file.type + file.size"
                class="flex flex-col items-center gap-4 border p-8 border-surface rounded-border"
              >
                <div>
                  <NuxtImg
                    v-if="file.type.startsWith('image/')"
                    role="presentation"
                    :alt="file.name"
                    :src="fileURL(file)"
                    width="100"
                    height="50"
                  />
                  <Icon
                    v-else
                    name="mdi:cloud-upload"
                    class="text-4xl"
                  ></Icon>
                </div>
                <span
                  class="max-w-60 overflow-hidden text-ellipsis whitespace-nowrap font-semibold"
                  >{{ file.name }}</span
                >
                <div>{{ formatSize(file.size) }}</div>
                <PrimeBadge
                  value="Completed"
                  class="mt-4"
                  severity="success"
                />
                <PrimeButton
                  outlined
                  rounded
                  severity="danger"
                  @click="removeUploadedFileCallback(index)"
                >
                  <Icon name="mdi:delete" />
                </PrimeButton>
              </div>
            </div>
          </div>
        </div>
      </template>
      <template #empty>
        <div class="flex flex-col items-center justify-center">
          <div
            class="flex h-20 w-20 items-center justify-center rounded-full border-2 bg-primary-500 text-white"
          >
            <Icon
              name="mdi:cloud-upload"
              size="48px"
            />
          </div>
          <p class="mb-0 mt-6"> Drag and drop files here to upload. </p>
        </div>
      </template>
    </PrimeFileUpload>
  </div>
</template>
</file>

<file path="apps/admin-dashboard/components/UserProfiles.vue">
<script setup lang="ts">
const editingRows = ref([])

const admin = useAdmin()

const {
  store: userProfiles,
  loadMore,
  refresh,
} = await useSelectData<User>('user_profiles', {
  columns: 'id, given_name, surname, avatar, email, created_at, updated_at',
  filters: { content_status: { eq: 'pending_agent_action' } },
  orderBy: { column: 'created_at', ascending: false },
  initialFetch: true,
  pagination: { page: 1, limit: 20 },
})

const onRowEditSave = async (event) => {
  const { data, newData } = event

  // Update the user profile in Supabase
  await admin.updateUser(newData, data.id)
}
</script>

<template>
  <div>
    <PrimeDataTable
      v-model:editing-rows="editingRows"
      :value="userProfiles"
      edit-mode="row"
      data-key="id"
      :pt="{
        table: { style: 'min-width: 50rem' },
        column: {
          bodycell: ({ state }) => ({
            style: state['d_editing'] && 'padding-top: 0.6rem; padding-bottom: 0.6rem',
          }),
        },
      }"
      @row-edit-save="onRowEditSave"
    >
      <PrimeColumn
        field="id"
        header="ID"
        style="width: 10%"
      ></PrimeColumn>
      <PrimeColumn
        field="first_name"
        header="First Name"
        style="width: 20%"
      >
        <template #editor="{ data, field }">
          <PrimeInputText v-model="data[field]" />
        </template>
      </PrimeColumn>
      <PrimeColumn
        field="last_name"
        header="Last Name"
        style="width: 20%"
      >
        <template #editor="{ data, field }">
          <PrimeInputText v-model="data[field]" />
        </template>
      </PrimeColumn>
      <PrimeColumn
        field="email"
        header="Email"
        style="width: 30%"
      >
        <template #editor="{ data, field }">
          <PrimeInputText v-model="data[field]" />
        </template>
      </PrimeColumn>
      <PrimeColumn
        :row-editor="true"
        style="width: 10%; min-width: 8rem"
        body-style="text-align:center"
      ></PrimeColumn>
    </PrimeDataTable>
  </div>
</template>
</file>

<file path="apps/admin-dashboard/composables/createAdminDashboard.ts">
import DataTable from 'primevue/datatable'
import Column from 'primevue/column'
import InputText from 'primevue/inputtext'
import Button from 'primevue/button'
import Dialog from 'primevue/dialog'
import type { DataTableFilterMeta } from 'primevue/datatable'
import ConfirmDialog from 'primevue/confirmdialog'
import { useConfirm } from 'primevue/useconfirm'
import { useStorage } from '@vueuse/core'
import type { createCRUDComposable } from './crud-factory.js'
import { Icon } from '#components'

export interface AdminColumn<T> {
  field: keyof T
  header: string
  sortable?: boolean
  filter?: boolean
  filterMatchMode?: string
  bodyComponent?: (item: T) => any
  editComponent?: (item: T, field: keyof T) => any
  insertComponent?: () => any
  width?: string
}

export function createAdminDashboard<T extends { id: string | number }>(
  entityName: string,
  columns: AdminColumn<T>[],
  useEntityComposable: () => ReturnType<ReturnType<typeof createCRUDComposable<T>>>,
) {
  return defineComponent({
    name: `${entityName}AdminDashboard`,
    props: {
      title: {
        type: String,
        default: `Manage ${entityName}`,
      },
      customActions: {
        type: Object as PropType<Record<string, (item: T) => void>>,
        default: () => ({}),
      },
      class: 'p-4',
    },
    setup(props) {
      const { entities, isLoading, fetchEntities, insertEntity, updateEntity, deleteEntity } =
        useEntityComposable()
      const confirm = useConfirm()
      const filters = ref({})
      const showInsertDialog = ref(false)
      const newEntity = ref({} as Omit<T, 'id'>)

      const orderedColumns = ref<(keyof T)[]>(columns.map((col) => col.field))
      const handleRowEditSave = async (event: { data: T; newData: Partial<T> }) => {
        try {
          await updateEntity(event.data.id, event.newData)
        } catch (error) {
          // Handle error (e.g., show toast message)
        }
      }

      const onColumnReorder = (event: { dragIndex: number; dropIndex: number }) => {
        const newOrder = [...orderedColumns.value]
        const [reorderedItem] = newOrder.splice(event.dragIndex, 1)
        newOrder.splice(event.dropIndex, 0, reorderedItem)
        orderedColumns.value = newOrder
      }

      const onCellEditComplete = async (event) => {
        const { data, newValue, field, oldValue } = event
        // 4. Only trigger the update function if the value has changed
        if (newValue !== oldValue) {
          console.log('updating', newValue, oldValue)
          try {
            await updateEntity(data.id, { [field]: newValue })
          } catch (error) {
            // Handle error (e.g., show toast message)
          }
        }
      }

      const handleDeleteEntity = (item: T) => {
        confirm.require({
          message: `Are you sure you want to delete this ${entityName}?`,
          header: 'Delete Confirmation',
          icon: 'pi pi-exclamation-triangle',
          accept: async () => {
            try {
              await deleteEntity(item.id)
              // Show success message
            } catch (error) {
              // Handle error (e.g., show toast message)
            }
          },
        })
      }

      const handleInsertEntity = async () => {
        try {
          await insertEntity(newEntity.value)
          showInsertDialog.value = false
          newEntity.value = {} as Omit<T, 'id'>
          // Show success message
        } catch (error) {
          // Handle error (e.g., show toast message)
        }
      }

      onMounted(() => {
        fetchEntities()
      })

      return {
        entities,
        isLoading,
        handleRowEditSave,
        handleDeleteEntity,
        handleInsertEntity,
        onCellEditComplete,
        onColumnReorder,
        filters,
        showInsertDialog,
        newEntity,
        orderedColumns,
      }
    },
    render() {
      return h('div', { class: 'admin-dashboard-wrapper' }, [
        h('div', { class: 'admin-dashboard-headder p-4' }, [
          this.$slots.title
            ? this.$slots.title()
            : h('h2', { class: 'text-2xl font-bold mb-4' }, this.title),
          h(Button, {
            label: `Add New ${entityName}`,
            class: 'p-button-success mb-4',
            onClick: () => (this.showInsertDialog = true),
          }),
        ]),
        h('div', { class: 'admin-dashboard-content' }, [
          h(
            DataTable,
            {
              value: this.entities,
              paginator: true,
              rows: 100,
              filters: this.filters,
              editMode: 'cell',
              onCellEditComplete: this.onCellEditComplete,
              loading: this.isLoading,
              responsiveLayout: 'scroll',
              resizableColumns: true,
              columnResizeMode: 'expand',
              showGridlines: true,
              reorderableColumns: true,
              onColumnReorder: this.onColumnReorder,
            },
            {
              header: () =>
                h('div', { class: 'flex justify-between' }, [
                  h(InputText, {
                    'modelValue': this.filters['global']?.value,
                    'onUpdate:modelValue': (value) => {
                      this.filters['global'] = { value, matchMode: 'contains' }
                    },
                    'placeholder': 'Global Search',
                  }),
                ]),
              default: () =>
                this.orderedColumns
                  .map((field, index) => {
                    const col = columns.find((c) => c.field === field)
                    if (!col) return null
                    return h(
                      Column,
                      {
                        key: col.field,
                        field: col.field,
                        header: col.header,
                        sortable: col.sortable ?? true,
                        filter: col.filter ?? true,
                        filterMatchMode: col.filterMatchMode ?? 'contains',
                        class: 'whitespace-nowrap overflow-hidden',
                        style: { maxWidth: col.width || '200px' },
                      },
                      {
                        body: (slotProps) =>
                          col.bodyComponent
                            ? col.bodyComponent(slotProps.data)
                            : slotProps.data[col.field],
                        editor: (slotProps) =>
                          col.editComponent
                            ? col.editComponent(slotProps.data, col.field)
                            : h(InputText, {
                                'modelValue': slotProps.data[col.field],
                                'onUpdate:modelValue': (value) =>
                                  (slotProps.data[col.field] = value),
                              }),
                      },
                    )
                  })
                  .filter(Boolean)
                  .concat([
                    h(Column, {
                      key: 'row-editor',
                      rowEditor: true,
                      style: { width: '10%', minWidth: '8rem' },
                    }),
                    h(
                      Column,
                      {
                        key: 'actions',
                        header: 'Actions',
                        style: { width: '10%', minWidth: '8rem' },
                        class: 'whitespace-nowrap',
                      },
                      {
                        body: (slotProps) => [
                          h(Button, {
                            label: 'delete',
                            severity: 'danger',
                            size: 'small',
                            onClick: () => this.handleDeleteEntity(slotProps.data),
                          }),
                          ...Object.entries(this.customActions).map(([label, action]) =>
                            h(Button, {
                              label,
                              onClick: () => action(slotProps.data),
                            }),
                          ),
                        ],
                      },
                    ),
                  ]),
            },
          ),
          h(
            Dialog,
            {
              'header': `Add New ${entityName}`,
              'visible': this.showInsertDialog,
              'onUpdate:visible': (value) => (this.showInsertDialog = value),
              'style': { width: '50vw' },
            },
            {
              default: () => [
                ...this.orderedColumns
                  .filter((col) => col.field !== 'id')
                  .map((col) =>
                    h('div', { class: 'field' }, [
                      h('label', { for: col.field }, col.header),
                      col.insertComponent
                        ? col.insertComponent()
                        : h(InputText, {
                            'id': col.field,
                            'modelValue': this.newEntity[col.field],
                            'onUpdate:modelValue': (value) => (this.newEntity[col.field] = value),
                            'class': 'w-full',
                          }),
                    ]),
                  ),
                h(Button, {
                  label: `Add ${entityName}`,
                  onClick: this.handleInsertEntity,
                }),
              ],
            },
          ),
          h(ConfirmDialog),
        ]),
      ])
    },
  })
}
</file>

<file path="apps/admin-dashboard/composables/crud-factory.ts">
import { useErrorHandler, AppError, ErrorType, ErrorSeverity } from '@ib/logger'
import { useUpdateData, useSelectData, useDeleteData, useInsertData } from '#imports'

export interface CRUDOptions<T> {
  initialFetch?: boolean
  orderBy?: { column: keyof T; ascending: boolean }
  limit?: number
  customSelectLogic?: (data: T[]) => T[]
  validateInsert?: (data: Omit<T, 'id'>) => boolean | Promise<boolean>
  validateUpdate?: (data: Partial<T>) => boolean | Promise<boolean>
  validateDelete?: (id: string | number) => boolean | Promise<boolean>
  afterInsert?: (insertedItem: T) => void | Promise<void>
  afterUpdate?: (updatedItem: T) => void | Promise<void>
  afterDelete?: (deletedId: string | number) => void | Promise<void>
}

export function createCRUDComposable<T extends { id: string | number }>(
  entityName: string,
  options: CRUDOptions<T> = {},
) {
  return function () {
    const { store, isSelecting, loadMore } = useSelectData<T>(entityName, {
      initialFetch: options.initialFetch ?? true,
      orderBy: options.orderBy as any,
      limit: options.limit ?? 100,
    })

    const { insertData, isInserting } = useInsertData<T>(entityName)
    const { updateData, isUpdating } = useUpdateData<T>(entityName)
    const { deleteData, isDeleting } = useDeleteData<T>(entityName)
    const { handleError } = useErrorHandler()

    const entities = computed(() => {
      const data = store.items
      return options.customSelectLogic ? options.customSelectLogic(data as T[]) : data
    })

    const isLoading = computed(() => isSelecting.value || isUpdating.value || isDeleting.value)

    const fetchEntities = async () => {
      try {
        await loadMore()
      } catch (error: any) {
        handleError(error, `Error fetching ${entityName}`)
      }
    }

    const insertEntity = async (data: Omit<T, 'id'>) => {
      try {
        if (options.validateInsert && !(await options.validateInsert(data))) {
          throw new AppError({
            type: ErrorType.VALIDATION_ERROR,
            message: 'Insert validation failed',
            severity: ErrorSeverity.MEDIUM,
            stack: 'no stack',
            context: `${entityName} insert`,
          })
        }
        const insertedItem = (await insertData(data as T)) as T
        if (options.afterInsert) {
          await options.afterInsert(insertedItem)
        }
        await fetchEntities() // Refresh the list after insertion
        return insertedItem
      } catch (error: any) {
        handleError(error, `Error inserting ${entityName}`)
        throw error
      }
    }

    const updateEntity = async (id: string | number, data: Partial<T>) => {
      try {
        if (options.validateUpdate && !(await options.validateUpdate(data))) {
          throw new AppError({
            type: ErrorType.VALIDATION_ERROR,
            message: 'Update validation failed',
            severity: ErrorSeverity.MEDIUM,
            context: `${entityName} update`,
            stack: 'no stack',
          })
        }
        const updatedItem = await updateData(id, data)
        if (options.afterUpdate) {
          await options.afterUpdate(updatedItem)
        }
        return updatedItem
      } catch (error: any) {
        handleError(error, `Error updating ${entityName}`)
        throw error
      }
    }

    const deleteEntity = async (id: string | number) => {
      try {
        if (options.validateDelete && !(await options.validateDelete(id))) {
          throw new AppError({
            type: ErrorType.VALIDATION_ERROR,
            message: 'Delete validation failed',
            severity: ErrorSeverity.MEDIUM,
            context: `${entityName} delete`,
            stack: 'no stack',
          })
        }
        await deleteData(id)
        if (options.afterDelete) {
          await options.afterDelete(id)
        }
        await fetchEntities() // Refresh the list after deletion
      } catch (error: any) {
        handleError(error, `Error deleting ${entityName}`)
        throw error
      }
    }

    return {
      entities,
      isLoading,
      insertEntity,
      fetchEntities,
      updateEntity,
      deleteEntity,
    }
  }
}
</file>

<file path="apps/admin-dashboard/composables/useFinancials.ts">
import data from '../assets/business-financials.json'

function formatNumber(value: number, style: 'INR' | 'USD' = 'INR'): string {
  const absValue = Math.abs(value)
  let formattedNumber

  switch (style) {
    case 'INR':
      if (absValue >= 1_00_00_00_000) {
        formattedNumber = `${(absValue / 1_00_00_00_000).toFixed(2)} T`
      } else if (absValue >= 1_00_00_000) {
        formattedNumber = `${(absValue / 1_00_00_000).toFixed(2)} CR`
      } else if (absValue >= 1_00_000) {
        formattedNumber = `${(absValue / 1_00_000).toFixed(2)} L`
      } else if (absValue >= 1_000) {
        formattedNumber = `${(absValue / 1_000).toFixed(2)} K`
      } else {
        formattedNumber = absValue.toFixed(2)
      }
      break
    case 'USD':
      if (absValue >= 1_000_000_000) {
        formattedNumber = `${(absValue / 1_000_000_000).toFixed(2)} B`
      } else if (absValue >= 1_000_000) {
        formattedNumber = `${(absValue / 1_000_000).toFixed(2)} M`
      } else if (absValue >= 1_000) {
        formattedNumber = `${(absValue / 1_000).toFixed(2)} K`
      } else {
        formattedNumber = absValue.toString()
      }
      break
  }

  return value < 0 ? '-' + formattedNumber : formattedNumber
}

function formatCurrency(amount: number, currencyType: 'INR' | 'USD'): string {
  const formattedNumber = formatNumber(amount, currencyType)
  const currencySymbol = currencyType === 'INR' ? '' : '$'
  return `${currencySymbol}${formattedNumber}`
}

function formatStorage(sizeInGB: number): string {
  const absSize = Math.abs(sizeInGB)
  let formattedSize: string

  if (absSize >= 1_000_000) {
    formattedSize = `${(absSize / 1_000_000).toFixed(2)} PB`
  } else if (absSize >= 1_000) {
    formattedSize = `${(absSize / 1_000).toFixed(2)} TB`
  } else if (absSize >= 1) {
    formattedSize = `${absSize.toFixed(2)} GB`
  } else {
    formattedSize = `${(absSize * 1_000).toFixed(2)} MB`
  }

  return sizeInGB < 0 ? '-' + formattedSize : formattedSize
}

function findLargestValue(values: number[]): number {
  return Math.max(...values)
}

const colorPalette = {
  darkBlue: [0, 102, 255],
  mediumBlue: [83, 104, 120],
  lightBlue: [122, 138, 153],
  darkGray: [161, 176, 186],
  mediumGray: [182, 194, 207],
  lightGray: [199, 210, 221],
  veryLightGray: [216, 226, 235],
  extraLightGray: [233, 241, 245],
  darkRed: [139, 0, 0],
  mediumRed: [178, 34, 34],
  lightRed: [220, 20, 60],
  darkGreen: [0, 100, 0],
  mediumGreen: [34, 139, 34],
  lightGreen: [46, 139, 87],
  darkOrange: [255, 140, 0],
  mediumOrange: [255, 165, 0],
  lightOrange: [255, 215, 0],
  darkPurple: [75, 0, 130],
  mediumPurple: [138, 43, 226],
  lightPurple: [147, 112, 219],
  darkPink: [255, 20, 147],
  mediumPink: [255, 105, 180],
  lightPink: [255, 182, 193],
  darkYellow: [255, 255, 0],
  mediumYellow: [255, 255, 0],
  lightYellow: [255, 255, 153],
  darkCyan: [0, 139, 139],
  mediumCyan: [0, 255, 255],
  lightCyan: [224, 255, 255],
  darkBrown: [139, 69, 19],
  mediumBrown: [160, 82, 45],
  lightBrown: [210, 105, 30],
  black: [0, 0, 0],
}

type ColorName =
  | 'darkBlue'
  | 'mediumBlue'
  | 'lightBlue'
  | 'darkGray'
  | 'mediumGray'
  | 'lightGray'
  | 'veryLightGray'
  | 'extraLightGray'
  | 'darkRed'
  | 'mediumRed'
  | 'lightRed'
  | 'darkGreen'
  | 'mediumGreen'
  | 'lightGreen'
  | 'darkOrange'
  | 'mediumOrange'
  | 'lightOrange'
  | 'darkPurple'
  | 'mediumPurple'
  | 'lightPurple'
  | 'darkPink'
  | 'mediumPink'
  | 'lightPink'
  | 'darkYellow'
  | 'mediumYellow'
  | 'lightYellow'
  | 'darkCyan'
  | 'mediumCyan'
  | 'lightCyan'
  | 'darkBrown'
  | 'mediumBrown'
  | 'lightBrown'
  | 'black'

interface FinancialDataItem {
  [key: string]: any
}

interface FinancialData {
  [key: string]: FinancialDataItem[] | number[] | string[]
}

// Function to convert RGB to RGBA
function rgba(colorName: ColorName, opacity: number = 1): string {
  const color = colorPalette[colorName]
  return `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${opacity})`
}

export default function useFinancials() {
  const globalChartRange = reactive({ start: 0, end: 12 })

  const filteredData = reactive(
    Object.entries(data).reduce((acc, [key, value]) => {
      if (Array.isArray(value)) {
        acc[key] = value.slice(globalChartRange.start, globalChartRange.end)
      } else {
        acc[key] = value
      }
      return acc
    }, {} as FinancialData),
  )

  // function updateGlobalRange(newRange: { start: number; end: number }): void {
  //   globalChartRange.start = newRange.start
  //   globalChartRange.end = newRange.end
  //   // Re-filter data when range changes
  // }

  const haveData = computed(() => !!filteredData && filteredData.months?.length > 0)

  const months = computed(() => filteredData?.months?.map((month: number) => `M${month}`) || [])

  console.log('data in composable:', filteredData)

  return {
    ...toRefs(filteredData),
    haveData,
    months,
    formatCurrency,
    formatNumber,
    formatStorage,
    updateGlobalRange: () => console.log('hi'),
    findLargestValue,
    rgba,
  }
}
</file>

<file path="apps/admin-dashboard/composables/useServerAnalytics.client.ts">
import { defineStore } from 'pinia'
import { ref, reactive, onUnmounted, watchEffect } from 'vue'

export const useServerAnalyticsStore = defineStore('serverAnalytics', () => {
  const company = reactive({})
  const queue = reactive({})
  const performance = reactive({})
  const news_links = reactive({})

  const availableMetrics = ref<string[]>([])

  const isConnected = ref(false)
  const haveMetrics = ref(false)

  const socket = ref<WebSocket | null>(null)
  const reconnectAttempts = ref(0)
  const maxReconnectAttempts = 5
  const reconnectInterval = 3000 // 3 seconds

  function updateMetrics(newData: any) {
    console.log('Updating metrics with:', newData)
    Object.entries(newData).forEach(([key, value]) => {
      const targetMetric = {
        company,
        performance,
        news_links,
        queue,
      }[key as keyof typeof newData]

      if (targetMetric && Array.isArray(value)) {
        value.forEach((metric: any) => {
          if (metric.name && metric.value !== undefined) {
            targetMetric[metric.name] = metric.value
            if (metric.metadata) {
              targetMetric[`${metric.name}_metadata`] = metric.metadata
            }
          }
        })
      }
    })
    haveMetrics.value = true
  }

  function setAvailableMetrics(metrics: string[]) {
    availableMetrics.value = metrics
  }

  function setConnectionStatus(status: boolean) {
    isConnected.value = status
  }

  function getMetricsByType(type: string) {
    return {
      company,
      news_links,
      performance,
      queue,
    }[type]
  }

  function getAllMetrics() {
    return {
      company,
      news_links,
      performance,
      queue,
    }
  }

  function connectWebSocket() {
    console.log('Attempting to connect WebSocket...')
    if (socket.value?.readyState === WebSocket.OPEN) {
      console.log('WebSocket is already open')
      return
    }

    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:'
    const host = window.location.host
    socket.value = new WebSocket(`${protocol}//${host}/api/server-jobs`)

    socket.value.onopen = () => {
      console.log('WebSocket connection established')
      setConnectionStatus(true)
      reconnectAttempts.value = 0
    }

    socket.value.onmessage = (event) => {
      const data = JSON.parse(event.data)
      console.log('Received message from Analytics server:', data)
      if (data.type === 'availableMetrics') {
        setAvailableMetrics(data.metrics)
      } else if (data.type === 'error') {
        console.error('WebSocket error:', data.message)
      } else if (data.domain && data.metrics) {
        console.log('Updating metrics:', data)
        updateMetrics({ [data.domain]: data.metrics })
      } else {
        console.warn('Received unexpected data structure:', data)
      }
    }

    socket.value.onerror = (error) => {
      console.error('WebSocket error:', error)
    }

    socket.value.onclose = () => {
      console.log('WebSocket connection closed')
      setConnectionStatus(false)
      reconnect()
    }
  }

  function reconnect() {
    if (reconnectAttempts.value < maxReconnectAttempts) {
      reconnectAttempts.value++
      console.log(`Attempting to reconnect (${reconnectAttempts.value}/${maxReconnectAttempts})...`)
      setTimeout(connectWebSocket, reconnectInterval)
    } else {
      console.log('Max reconnect attempts reached. Please refresh the page.')
    }
  }

  function disconnectWebSocket() {
    if (socket.value) {
      socket.value.close()
      socket.value = null
      setConnectionStatus(false)
    }
  }

  function subscribeToMetrics(metricTypes: string[]) {
    if (socket.value && socket.value.readyState === WebSocket.OPEN) {
      socket.value.send(
        JSON.stringify({
          action: 'subscribe',
          metrics: metricTypes,
        }),
      )
    }
  }

  function unsubscribeFromMetrics(metricTypes: string[]) {
    if (socket.value && socket.value.readyState === WebSocket.OPEN) {
      socket.value.send(
        JSON.stringify({
          action: 'unsubscribe',
          metrics: metricTypes,
        }),
      )
    }
  }

  watchEffect(() => {
    if (!socket.value || socket.value.readyState !== WebSocket.OPEN) {
      connectWebSocket()
    }
  })

  onUnmounted(() => {
    disconnectWebSocket()
  })

  return {
    queue,
    company,
    news_links,
    performance,
    availableMetrics,
    isConnected,
    haveMetrics,
    connectWebSocket,
    disconnectWebSocket,
    subscribeToMetrics,
    unsubscribeFromMetrics,
    getMetricsByType,
    getAllMetrics,
  }
})
</file>

<file path="apps/admin-dashboard/composables/useTasks.ts">
// to add
// PWA
// move to monorepo structure
// extract out base func / components etc.

export interface Goal {
  id: number
  title: string
  date: string
  category: 'financial' | 'metrics' | 'hiring' | 'events' | 'development' | 'milestone'
  assigneeId: number
  completed: boolean
  recurrence?: {
    frequency: 'daily' | 'weekly' | 'monthly' | 'yearly'
    interval: number
    endDate?: string
  }
}

interface Milestone {
  id: number
  title: string
  description: string
  startDate: string
  endDate: string
  status: 'not_started' | 'in_progress' | 'completed'
  progress: number
  parentMilestoneId: number | null
}

export default function useTasks() {
  const goals = ref<Goal[]>([])
  const milestones = ref<Milestone[]>([])
  const toast = useNotification()

  async function fetchGoals() {
    try {
      console.log('fetchGoals')
      const response = await $fetch('/api/goals', {
        method: 'POST',
        body: { action: 'read' },
      })

      console.log('fetchGoals response', response)
      if (response.success) {
        goals.value = response.goals
        generateRecurringTasks()
      } else {
        throw new Error(response.message)
      }
    } catch (error) {
      console.error('Error fetching goals:', error)
      throw error
    }
  }

  function generateRecurringTasks() {
    const today = new Date()
    const oneYearLater = new Date(today.getFullYear() + 1, today.getMonth(), today.getDate())
    const newGoals: Goal[] = []

    goals.value.forEach((task) => {
      if (task.recurrence) {
        const currentDate = new Date(task.date)
        while (currentDate <= oneYearLater) {
          if (task.recurrence.endDate && new Date(task.recurrence.endDate) < currentDate) {
            break
          }
          if (currentDate > today) {
            newGoals.push({
              ...task,
              id: Math.max(...goals.value.map((g) => g.id), 0) + 1,
              date: currentDate.toISOString().split('T')[0],
              completed: false,
            })
          }
          advanceDate(currentDate, task.recurrence.frequency, task.recurrence.interval)
        }
      }
    })

    goals.value = [...goals.value, ...newGoals]
  }

  function advanceDate(date: Date, frequency: string, interval: number) {
    switch (frequency) {
      case 'daily':
        date.setDate(date.getDate() + interval)
        break
      case 'weekly':
        date.setDate(date.getDate() + 7 * interval)
        break
      case 'monthly':
        date.setMonth(date.getMonth() + interval)
        break
      case 'yearly':
        date.setFullYear(date.getFullYear() + interval)
        break
    }
  }

  async function createGoal(goal: Goal) {
    goal.subtasks = goal.subtasks.map((subtask, index) => ({
      ...subtask,
      id: subtask.id || Date.now() + index,
    }))
    return handleGoalCrud('create', goal)
  }

  async function updateGoal(goal: Goal) {
    goal.subtasks = goal.subtasks.map((subtask, index) => ({
      ...subtask,
      id: subtask.id || Date.now() + index,
    }))
    return handleGoalCrud('update', goal)
  }

  async function deleteGoal(goal: Goal) {
    return handleGoalCrud('delete', goal)
  }

  async function handleGoalCrud(action: 'create' | 'update' | 'delete', goal: Goal) {
    try {
      const response = await $fetch('/api/goals', {
        method: 'POST',
        body: { action, goal },
      })
      if (response.success) {
        if (action === 'update') {
          // Update the goal in the local state
          const index = goals.value.findIndex((g) => g.id === goal.id)
          if (index !== -1) {
            goals.value[index] = { ...goal, subtasks: goal.subtasks }
          }
        } else {
          // For create and delete, re-fetch all goals
          await fetchGoals()
        }
      } else {
        throw new Error(response.message)
      }
    } catch (error) {
      console.error(`Error ${action}ing goal:`, error)
      throw error
    }
  }

  async function updateGoalsWithDefaultValues() {
    const updatedGoals = goals.value.map((goal) => ({
      ...goal,
      progress: goal.progress ?? 0,
      priority: goal.priority ?? 'medium',
      timeSpent: goal.timeSpent ?? 0,
      description: goal.description ?? '',
      subtasks: goal.subtasks ?? [],
    }))

    for (const goal of updatedGoals) {
      await updateGoal(goal)
    }

    await fetchGoals()
  }

  async function fetchMilestones() {
    try {
      const response = await fetch('/api/milestones')

      console.log('milestones', response)
      if (!response.ok) {
        throw new Error('Failed to fetch milestones')
      }
      const data = await response.json()
      milestones.value = data
    } catch (error) {
      console.error('Error fetching milestones:', error)
      toast.error({ message: 'Failed to fetch milestones', summary: 'Error' })
    }
  }

  return {
    goals,
    milestones,
    fetchMilestones,
    updateGoalsWithDefaultValues,
    fetchGoals,
    createGoal,
    updateGoal,
    deleteGoal,
  }
}
</file>

<file path="apps/admin-dashboard/content/bp/1.summary.md">
---
section: summary
---

### Executive Summary

#### Brief Introduction to AstronEra

AstronEra is a cutting-edge SaaS company based in India, dedicated to creating an all-encompassing
Online Astronomy Hub driving science popularization. Our platform serves as a one-stop destination
for astronomy enthusiasts, professionals, students, and businesses, providing a comprehensive suite
of services that include news aggregation, research papers company profiles, social interaction,
AI-driven summarization, job listings, courses, and advanced AI search capabilities to enhance
research and learning.

---

<!-- Bulk of content -->

---

## Conclusion

By leveraging our innovative technology, comprehensive content, and strong community focus,
AstronEra is poised to become the leading platform in the astronomy space, driving user engagement
and growth while providing valuable tools and resources to our diverse user base.
</file>

<file path="apps/admin-dashboard/content/bp/10.appendix.md">
---
section: appendix
---

### Appendix (Overview)

The Appendix section will provide supporting documents and data to substantiate the claims and
projections made throughout the business plan. It will include market research reports, detailed
financial forecasts, and legal and regulatory considerations. Here is a detailed breakdown based on
the information provided.

---

<!-- Bulk of content -->

---

### Conclusion
</file>

<file path="apps/admin-dashboard/content/bp/12.todo.md">
---
section: todo
---

## Research Immediate Timeline

1. [ ] Extract all current papers with links to PDF, Abstract, Title, Authors, Date, Pages, Figure
       Count, Subjects (Categories), HTML Link, Abs Link, Tables Count, Publ/Journal Details

2. [ ] Create DB Table / Update what we have. Store Metrics per month

3. [ ] Cycle through the abs links and extract all Abstracts (research and see if it needs parsing)

4. [ ] Calculate the cost of vectorizing all abstracts 400 tokens for ~250 words (avg abst length) x
       300k papers = 120000000 tokens, 1 million tokens text-embed-small = 2 cents usd. Total cost
       for 300k abstracts $2.4 USD. First test 1,000 abstracts to validate cost. Depending on
       outcome either vectorize all at once or 1000 per weeek

5. [ ] Add search for research articles

- [ ] vectorize the question
- [ ] store the question (unique col) with vector
- [ ] search question table before vector in future

6.  [ ] Allow the user to return full abstracts, references/titles only, links to PDF, summaries,
        LLM response (last to add)

- [ ] in future have different styles of references
- [ ] allow users to bookmark the papers, experts can have groups of bookmarks (for when they are
      working on multiple papers at once)
- [ ] in future sort by number of cites
- [ ] in future show number of references in papers
- [ ] show authors
- [ ] show category

7. [ ] Setup cron to extract new papers every month

---

Later improvements:

- store the references / citations links in a separate table using https://www.prophy.science/
- use https://www.prophy.science/ reference to find the common terms in the paper
- Also use prophy to extract the author information (affiliations / ORCID / Citations / Academic Age
  / Years Active, H-index / Articles / Notibal Articles)
- if we navigate to their prophy page we can see more info: top co-authors, top author concepts
  total citations, manuscript types, 5 newest articles with all above info

## Ideas

- Different styles of citations, Harvard etc. Samwell AI for example
- We could have a panelist of people selected from our userbase through application, their job is to
  act as mentors / a sounding board for us, similar to a board of directors. Might appeal to retired
  experts, people seeking status in industry. We should also rotate the board every 3 years.
- Add social share buttons to content Allow users to connect their social media accounts, so when
  they post on astronEra we automatically post on the other social platforms as well.
- Allow users to upload a PDF if we do not have it in our database, it will then be chunked and they
  can perform rag search on it.

## What are we missing:

# Websites to scrape

- Linkedin for Companies and Jobs
- https://orcid.org/ researchers database, has cite count, can search by Astronomy etc.
- Can potentially find citations from this website if Arxiv papers don't have links, just titles.
  https://www.semanticscholar.org/

<!--
https://www.bplans.com/saas-business-plan/
https://www.saastock.com/wp-content/uploads/2020/02/SaaS-Marketing-eBook.pdf
 -->

3. How our solution solves this problem, go in depth on benefits later.
4. Comprehensive Market Research (competitors and market size), Label if it is a direct competitor
   or indirect.
5. Market Size should have a pie chart or pyramid
6. Show some metric cards in a grid (color coded)
7. two column sections, image or text on the right
8. Testimonials can be added
9. Box content for social media marketing plans, could have icon on the left then the plan on the
   right for each platform.
10. edit prose to match our brand colors etc: https://github.com/tailwindlabs/tailwindcss-typography
11. Mention products / affiliates and how we will incorporate them into the app more, potentially
    use an API like https://www.webscrapingapi.com/amazon-api

# Competitors:

- https://www.samwell.ai/ - for research papers
-

## Must Do

- Comprehensive Competitor Analysis
- Comprehensive Market Research
- Reliable Estimations for Financials
  - Must know how much it costs per Company / Research Paper / News Article / etc etc.
  - How much it costs to store our data, need to know rough size of Company / ...
  - How many employees for different stages, all associated employee costs
  - Finalize projected revenue, must have references for how we have come up with Affilaite numbers,
    advertising revenue, why we have priced our monthly subscripion at $x and $$x for pro/expert
  - Decide on what Financial Charts to include in the Business plan, and which are required for
    Slide Deck
- Rough estimation on how much data is available for companies / news / research papers
- Explain what data we are extracting from research papers and why (for future AI training,
  additional features)
- Clarity on our USP and positioning, needs to be in the summary
- Clarity on the problem we are solving.
</file>

<file path="apps/admin-dashboard/content/bp/2.company-description.md">
---
section: description
---

### Company Overview

---

<!-- Bulk of content -->

---

### Conclusion

By focusing on these comprehensive strategies, AstronEra aims to build a robust platform that
addresses the needs of its diverse user base, fosters a global community, and drives innovation and
growth in the field of astronomy.
</file>

<file path="apps/admin-dashboard/content/bp/3.market-analysis.md">
---
section: market-analysis
---

### Market Research on the Astronomy/Space Sector (overview)

The global space economy is projected to experience substantial growth, reaching an estimated value
of $1.8 trillion by 2035, up from $630 billion in 2023. This growth will be driven by advancements
in space-enabled technologies, such as satellite communications, Earth observation, and positioning
services, which are becoming increasingly integral to various industries beyond traditional space
applications.

---

<!-- Bulk of content -->

---

### Conclusion

AstronEra is well-positioned to capitalize on the burgeoning space economy. By targeting a diverse
user base that includes companies, professionals, students, and enthusiasts, and leveraging
advancements in space technology, AstronEra can achieve significant growth. Continued investment in
technology, strategic partnerships, and a robust marketing plan will be key to realizing these
projections and sustaining long-term success in the rapidly expanding space sector.

### References

1. [World Economic Forum - Space Economy Set to Triple to $1.8 Trillion by 2035](https://www.weforum.org/press/2023/06/space-economy-set-to-triple-to-1-8-trillion-by-2035-new-research-reveals).

2. [World Economic Forum - Space is booming. Here's how to embrace the $1.8 trillion opportunity](https://www.weforum.org/agenda/2023/06/space-is-booming-heres-how-to-embrace-the-1-8-trillion-opportunity/).

3. [McKinsey - Space: The $1.8 trillion opportunity for global economic growth](https://www.mckinsey.com/industries/aerospace-and-defense/our-insights/space-the-1-point-8-trillion-dollar-opportunity-for-global-economic-growth).

4. [Space Foundation - The Space Report 2024 Q1](https://www.spacefoundation.org/2024/01/29/space-report-2024-q1-finds-growth-in-us-space-workforce-record-2024-launch-pace-leaps-in-commercial-and-civil-spacecraft-technology/).

5. [Grand View Research - SpaceTech Market Size & Growth Analysis Report, 2030](https://www.grandviewresearch.com/industry-analysis/space-tech-market).
</file>

<file path="apps/admin-dashboard/content/bp/4.products.md">
---
section: products
---

### Detailed Description of the Online Astronomy Hub

### Overview

- **Primary Purpose and Mission:**
  - To democratize access to astronomy knowledge and resources.
  - To further humanity's understanding of the universe and our place in it.
- **Platform Functionality:**
  - **User Journey:**
    - Users sign up and select their interests.
    - Users receive personalized newsfeeds, summaries, and updates.
    - Users interact with customized AI agents for queries.
    - Users can participate in community-driven events, discussions, and projects.
  - **Key Functionalities:**
    - Personalized news aggregation.
    - Detailed company profiles.
    - Social interaction with content.
    - AI-driven summarization.
    - Jobs portal.
    - Courses and educational resources.
    - Advanced AI RAG (Retrieval-Augmented Generation) search.

1. **Sources:**
   - **Types of News Sources:**
     1. Scientific journals
     2. Research papers
     3. Space/astronomy companies and their blogs
     4. News agencies with an astronomy focus
     5. Social media of major space agencies
     6. Space agencies
     7. Research institutions
     8. Events
   - **Update Frequency:**
     - Initially, most sources will be updated once per day.
     - As manpower scales, multiple scraping jobs will reduce the time between updates to a few
       hours.

AstronEra aggregates content from a wide array of sources, including scientific journals, research
papers, blogs of space companies, news agencies focused on astronomy, social media of major space
agencies, and research institutions. Initially updated once per day, the frequency will increase as
the platform scales. Users can tailor their newsfeed to their interests and receive summaries
curated by advanced AI, ensuring they stay informed on the latest developments.

---

<!-- Bulk of content -->

---

### Conclusion

AstronEra distinguishes itself with a unique combination of astronomy expertise and AI technology.
It serves diverse user segments, from casual enthusiasts to professionals, by providing centralized
access to all aspects of astronomy. The platform supports sustainable development and night sky
conservation, promotes scientific temperament, and reduces superstitions through credible, curated
information. By continuously updating with advancing technologies and connecting everyday life with
cosmic knowledge, AstronEra remains at the forefront of innovation in the astronomy domain.
</file>

<file path="apps/admin-dashboard/content/bp/5.marketing.md">
---
section: marketing
---

### Marketing and Sales Strategy

This comprehensive approach will ensure a robust marketing and sales strategy for AstronEra, helping
to attract and retain users while fostering growth and engagement. By measuring the effectiveness of
user acquisition strategies, mitigating potential risks in digital marketing, and enhancing customer
retention strategies, AstronEra can ensure long-term success and user satisfaction.
</file>

<file path="apps/admin-dashboard/content/bp/6.management-operations.md">
---
section: management-operations
---

### Management Team Structure and Operations Plan

::org-chart ::
</file>

<file path="apps/admin-dashboard/content/bp/7.financials.md">
---
section: financials
---

### Financial Plan

## ::financial-chart

title: 3 Year User Projections chartType: line chartDataKey: users

---

::
</file>

<file path="apps/admin-dashboard/content/bp/8.risk-analysis.md">
---
section: risk-analysis
---

### Risk Analysis (overview)

---

<!-- Bulk of content -->

---

### Conclusion

By addressing these potential risks and implementing robust mitigation strategies, AstronEra can
better navigate the challenges in the dynamic space industry and maintain a competitive edge.
</file>

<file path="apps/admin-dashboard/content/bp/9.roadmap.md">
---
section: roadmap
---

### Roadmap

AstronEra aims to become a leading platform in the space and astronomy sector, providing
cutting-edge technology, comprehensive content, and a robust user experience. Our future growth
strategy focuses on rolling out new features and expanding our user base through innovative
solutions, strategic partnerships, and continuous improvement in our services.

---

<!-- Bulk of content -->

---

### Conclusion

By strategically rolling out these features and continuously enhancing our platform, AstronEra aims
to lead the space and astronomy sector, providing unparalleled value to our users and partners. This
phased growth strategy ensures we remain agile and responsive to market demands while pursuing our
long-term vision.

::timeline ::
</file>

<file path="apps/admin-dashboard/content/bp/appendix-data-sources.md">
### Research Papers

## Summary

Thomson Reuterss (now Clarivate Analytics) Web of Science (WoS) bibliographic database was utilized
to gather bibliographical data of referred research publications from India. Using the 'Advance
search' option with the field tags SU (Subject) and CU (Country) combined with the Boolean
operator AND (i.e., (SU=Astronomy & Astrophysics) AND (CU=India)), data was collected over a
thirty-year period from 1988 to 2017. A total of 20,311 research papers were retrieved for
scientometric analysis. Bibexcel and Pajek software were employed for data analysis, processing, and
visualization.

### Table: Top 20 Astronomy & Astrophysics Research Countries (1988-2017)

| Rank | Country     | Research Publications | Percentage (%) |
| ---- | ----------- | --------------------- | -------------- |
| 1    | USA         | 234,310               | 39.87          |
| 2    | Germany     | 82,522                | 14.04          |
| 3    | England     | 67,641                | 11.51          |
| 4    | France      | 59,062                | 10.05          |
| 5    | Italy       | 54,751                | 9.32           |
| 6    | Japan       | 41,942                | 7.14           |
| 7    | Russia      | 36,961                | 6.29           |
| 8    | Spain       | 35,742                | 6.08           |
| 9    | China       | 30,209                | 5.14           |
| 10   | Canada      | 29,381                | 5.00           |
| 11   | Netherlands | 24,602                | 4.19           |
| 12   | Australia   | 20,807                | 3.54           |
| 13   | India       | 20,311                | 3.46           |
| 14   | Switzerland | 19,844                | 3.38           |
| 15   | Brazil      | 15,099                | 2.57           |
| 16   | Chile       | 14,714                | 2.50           |
| 17   | Poland      | 14,357                | 2.44           |
| 18   | Sweden      | 11,538                | 1.96           |
| 19   | Scotland    | 11,499                | 1.96           |
| 20   | Mexico      | 11,038                | 1.87           |

**Total Research Publications: 818,391** (check tally)

## Summary

The following table lists the top 20 prolific journals in Astronomy & Astrophysics research in India
based on various metrics.

### Table: Top 20 Prolific Journals in Astronomy & Astrophysics Research

| Rank | Journal                                                   | Total Papers (TP) | Total Citations (TC) | Average Citations Per Paper (ACPP) | Web of Science Citations (WSC) | Crossref Citations (CA) | Web of Science Core Collection Citations (WCA) | H-index | Impact Factor (IF) |
| ---- | --------------------------------------------------------- | ----------------- | -------------------- | ---------------------------------- | ------------------------------ | ----------------------- | ---------------------------------------------- | ------- | ------------------ |
| 1    | Physical Review D                                         | 3,752             | 83,369               | 22.22                              | 75,671                         | 48,281                  | 45,667                                         | 102     | 4.57               |
| 2    | Physics Letters B                                         | 2,131             | 64,332               | 30.19                              | 61,860                         | 43,204                  | 42,026                                         | 93      | 4.81               |
| 3    | Monthly Notices of the Royal Astronomical Society (MNRAS) | 1,815             | 29,555               | 16.28                              | 25,863                         | 18,812                  | 17,657                                         | 64      | 4.96               |
| 4    | Astrophysics and Space Science                            | 1,681             | 10,047               | 5.98                               | 7,717                          | 4,684                   | 3,912                                          | 36      | 1.62               |
| 5    | Astrophysical Journal                                     | 1,493             | 32,597               | 21.83                              | 30,622                         | 23,123                  | 22,268                                         | 75      | 5.53               |
| 6    | Astronomy & Astrophysics                                  | 1,226             | 39,938               | 32.58                              | 36,688                         | 26,254                  | 25,619                                         | 78      | 5.01               |
| 7    | Advances in Space Research                                | 557               | 2,928                | 5.26                               | 2,697                          | 2,470                   | 2,343                                          | 25      | 1.40               |
| 8    | Journal of Geophysical Research - Space Physics           | 505               | 6,166                | 12.21                              | 5,229                          | 4,109                   | 3,769                                          | 35      | 2.73               |
| 9    | Journal of Astrophysics and Astronomy                     | 502               | 2,151                | 4.28                               | 2,002                          | 1,859                   | 1,761                                          | 19      | 0.39               |
| 10   | Classical and Quantum Gravity                             | 454               | 10,275               | 22.63                              | 9,919                          | 7,609                   | 7,413                                          | 50      | 3.12               |
| 11   | Solar Physics                                             | 454               | 5,419                | 11.94                              | 4,862                          | 3,623                   | 3,366                                          | 36      | 2.68               |
| 12   | Indian Journal of Radio Space Physics                     | 446               | 934                  | 2.09                               | 934                            | 756                     | 756                                            | 13      | -                  |
| 13   | International Journal of Modern Physics D                 | 403               | 8,346                | 20.71                              | 8,101                          | 6,105                   | 5,962                                          | 30      | 2.48               |
| 14   | General Relativity and Gravitation                        | 338               | 4,192                | 12.40                              | 4,074                          | 3,165                   | 3,074                                          | 31      | 1.62               |
| 15   | Astronomical Society of the Pacific Conference Series     | 335               | 429                  | 1.28                               | 413                            | 386                     | 374                                            | 10      | -                  |
| 16   | Annales Geophysicae                                       | 287               | 3,585                | 12.49                              | 3,409                          | 2,644                   | 2,540                                          | 26      | 1.61               |
| 17   | Journal of Cosmology and Astroparticle Physics            | 259               | 3,882                | 14.82                              | 3,655                          | 3,259                   | 3,147                                          | 24      | 4.73               |
| 18   | International Astronomical Union (IAU) Symposia           | 218               | 28                   | 0.13                               | 28                             | 28                      | 28                                             | 3       | -                  |
| 19   | Journal of Physics Conference Series                      | 190               | 236                  | 1.24                               | 236                            | 226                     | 226                                            | 7       | -                  |
| 20   | Planetary and Space Science                               | 186               | 1,879                | 10.10                              | 1,775                          | 1,542                   | 1,483                                          | 21      | 1.89               |

**Total Publications: 17,232 (84.84%)**

Here is a table with links to the top 20 prolific journals in Astronomy & Astrophysics research:

| Rank | Journal                                                   | Link                                                                                                           |
| ---- | --------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------- |
| 1    | Physical Review D                                         | [Physical Review D](https://journals.aps.org/prd)                                                              |
| 2    | Physics Letters B                                         | [Physics Letters B](https://www.journals.elsevier.com/physics-letters-b)                                       |
| 3    | Monthly Notices of the Royal Astronomical Society (MNRAS) | [MNRAS](https://academic.oup.com/mnras)                                                                        |
| 4    | Astrophysics and Space Science                            | [Astrophysics and Space Science](https://www.springer.com/journal/10509)                                       |
| 5    | Astrophysical Journal                                     | [Astrophysical Journal](https://iopscience.iop.org/journal/0004-637X)                                          |
| 6    | Astronomy & Astrophysics                                  | [Astronomy & Astrophysics](https://www.aanda.org/)                                                             |
| 7    | Advances in Space Research                                | [Advances in Space Research](https://www.journals.elsevier.com/advances-in-space-research)                     |
| 8    | Journal of Geophysical Research - Space Physics           | [Journal of Geophysical Research - Space Physics](https://agupubs.onlinelibrary.wiley.com/journal/21699402)    |
| 9    | Journal of Astrophysics and Astronomy                     | [Journal of Astrophysics and Astronomy](https://www.ias.ac.in/Journals/Journal_of_Astrophysics_and_Astronomy/) |
| 10   | Classical and Quantum Gravity                             | [Classical and Quantum Gravity](https://iopscience.iop.org/journal/0264-9381)                                  |
| 11   | Solar Physics                                             | [Solar Physics](https://www.springer.com/journal/11207)                                                        |
| 12   | Indian Journal of Radio Space Physics                     | [Indian Journal of Radio Space Physics](http://nopr.niscpr.res.in/handle/123456789/44)                         |
| 13   | International Journal of Modern Physics D                 | [International Journal of Modern Physics D](https://www.worldscientific.com/worldscinet/ijmpd)                 |
| 14   | General Relativity and Gravitation                        | [General Relativity and Gravitation](https://www.springer.com/journal/10714)                                   |
| 15   | Astronomical Society of the Pacific Conference Series     | [ASP Conference Series](https://www.aspbooks.org/)                                                             |
| 16   | Annales Geophysicae                                       | [Annales Geophysicae](https://angeo.copernicus.org/)                                                           |
| 17   | Journal of Cosmology and Astroparticle Physics            | [Journal of Cosmology and Astroparticle Physics](https://iopscience.iop.org/journal/1475-7516)                 |
| 18   | International Astronomical Union (IAU) Symposia           | [IAU Symposia](https://www.iau.org/publications/symposia/)                                                     |
| 19   | Journal of Physics Conference Series                      | [Journal of Physics Conference Series](https://iopscience.iop.org/journal/1742-6596)                           |
| 20   | Planetary and Space Science                               | [Planetary and Space Science](https://www.journals.elsevier.com/planetary-and-space-science)                   |

This table includes links to each journal's website for further reference.

- [Nature](https://www.nature.com/)
- []()
- []()
- []()
- []()
- []()
- []()

### Databases

- [Astronomy Outreach Network](https://www.explorescientific.com/pages/astronomy-outreach-network)
- [Space Industry Database](https://spaceindustrydatabase.com/)
- []()
- []()
- []()
</file>

<file path="apps/admin-dashboard/content/bp/appendix-financials.md">
#### Detailed Financial Forecasts

1. **Revenue Projections:**

   - Subscription revenue projections for Free, Pro, and Expert tiers over the next three years.
   - Additional revenue streams from advertising and affiliate marketing.

2. **Cost Structure and Budget:**

   - Breakdown of operational costs, including salaries, infrastructure, marketing, AI and data
     processing, customer support, and development costs.
   - Miscellaneous costs such as legal, administrative, and office space expenses.

3. **Profit and Loss Statements:**

   - Projected profit and loss statements for the next three years.
   - Calculation of net profit by subtracting total expenses from total revenue.

4. **Cash Flow Analysis:**

   - Expected cash inflows from subscriptions and other revenue streams.
   - Expected cash outflows for operational, development, and miscellaneous expenses.
   - Net cash flow analysis.

5. **Break-even Analysis:**
   - Calculation of the break-even point in terms of revenue and time.
   - Monthly and yearly analysis of how long it will take to reach the break-even point.
</file>

<file path="apps/admin-dashboard/content/bp/appendix-funding.md">
1. https://blume.vc/funds/fund-iv
2. https://www.spacecapital.com/portfolio
3.
</file>

<file path="apps/admin-dashboard/content/bp/appendix-hires.md">
### Show Hires beyond year 1
</file>

<file path="apps/admin-dashboard/content/bp/appendix-legal.md">
#### Legal and Regulatory Considerations

1. **Compliance Documents:**

   - Documentation of compliance with data protection regulations such as GDPR and CCPA.
   - Legal requirements for operating in the target markets (e.g., India, Europe, North America).

2. **Terms of Service and Privacy Policy:**

   - Detailed terms of service outlining user rights and responsibilities.
   - Privacy policy detailing how user data will be collected, used, and protected.

3. **Intellectual Property:**

   - Documentation of trademarks, copyrights, and patents relevant to AstronEras technology and
     content.

4. **Risk Management:**
   - Detailed risk analysis reports outlining potential risks and challenges, mitigation strategies,
     and contingency plans.
</file>

<file path="apps/admin-dashboard/content/bp/appendix-market.md">
### Summary (https://www2.deloitte.com/xe/en/insights/industry/aerospace-defense/future-of-space-economy.html)

The space economy has experienced rapid growth due to advances in technology, increased private
sector investment, and rising demand for space data. This growth is opening opportunities for new
and existing players in the industry. Key factors and challenges include:

#### Key Points:

- **Technological Advances:**

  - Development of reusable launch vehicles, SmallSats, and CubeSats has reduced costs.
  - SmallSats accounted for about 95% of spacecraft launched in 2022.
  - Innovations like satellite constellations can provide global coverage.

- **Private Sector Investment:**

  - Significant private equity (PE) and venture capital (VC) investments in the space sector.
  - PE investments totaled about $272 billion into 1,791 unique companies since 2013.
  - The FY23 U.S. national security space budget allocated $20.8 billion, a 19.5% increase from
    FY22.
  - Over 5,000 broadband satellites expected in Low Earth Orbit (LEO) by the end of 2023.
  - Potentially 40,000-50,000 satellites to serve over 10 million end-users by 2030.

- **Rising Demand for Space Data:**
  - Demand for space data is increasing, with applications in military communications, environmental
    monitoring, and emergency response.
  - Data sent to and from space expected to grow to over 500 exabytes from 2020 to 2030.
  - AI and edge computing are expected to transform space data services.

#### Challenges:

- **Supply Chain Disruptions:** Developing competitive space-grade products and components.
- **Regulatory Issues:** Complex and overlapping regulations from multiple agencies.
- **Environmental Concerns:** Space debris, congestion, and greenhouse gas emissions.
- **Technical Barriers:** Cost of launching equipment into space and lack of in-space manufacturing
  infrastructure.

#### Opportunities:

- **In-Space Manufacturing:** Using microgravity and vacuum conditions for production.
- **Additive Manufacturing:** 3D printing in space to create complex objects and reduce costs.
- **Robotics:** Use of robotics for exploration, maintenance, and assembly in space.
- **Space Sustainability:** Addressing space debris and congestion through active debris removal and
  end-of-life disposal maneuvers.

#### Industry and Market Growth:

- **Public-Private Collaboration:** Crucial for scaling opportunities and leveraging investments.
- **Emerging Trends:** Expansion of private companies roles, space data services, and in-space
  manufacturing.
- **Future Business Models:** Shift towards higher volume, lower cost, and standardized offerings.

#### Key Statistics:

- **186 successful rocket launches in 2022, 41 more than in 2021.**
- **95% of spacecraft launched in 2022 were SmallSats.**
- **Global space sector attracted PE investments of about $272 billion since 2013.**
- **FY23 U.S. national security space budget allocated $20.8 billion, a 19.5% increase from FY22.**
- **Over 5,000 broadband satellites in LEO by the end of 2023.**
- **Potential for 40,000-50,000 satellites serving over 10 million end-users by 2030.**
- **Data from space expected to grow to over 500 exabytes from 2020 to 2030.**
- **98% of senior executives believe in increased demand for space data and the expansion of private
  companies' roles.**

---

### Summary of the Space Technology Market Analysis

The global space technology market, valued at USD 443.20 billion in 2023, is projected to reach USD
916.85 billion by 2033, growing at a CAGR of 7.54% from 2024 to 2033.

#### Key Statistics:

- **North America's Market Share (2023):** >55%
- **Asia Pacific's Expected CAGR (2024-2033):** 9.05%
- **Space Vehicles Market Share (2023):** 67%
- **Commercial Segment Market Share (2023):** 62%
- **Navigation and Mapping Segment Market Share (2023):** 21%
- **U.S. Market Size (2023):** USD 170.63 billion, projected to reach USD 355.51 billion by 2033

#### Key Drivers:

- Technological advancements (e.g., reusable rockets, SmallSats, CubeSats)
- Increased private sector investment (e.g., SpaceX, Blue Origin)
- Rising demand for satellite data and services (e.g., navigation, Earth observation)

For a more detailed analysis, visit the full report
[here](https://www.precedenceresearch.com/space-technology-market).

---

### Summary of the Space Exploration Market Report

**Market Size & Growth:**

- 2022: USD 486 billion
- 2032: USD 1879 billion
- CAGR: 16.21% (2022-2032)

**Key Segments:**

- **Space Technology:** Satellites (largest share, 34.9%)
- **Mission Type:** Unmanned missions (significant growth)
- **Exploration Type:** Moon exploration (57.2% share)
- **End-Use:** Commercial sector (47.8% share)

**Regional Insights:**

- North America: Dominates with 38.7% share
- Asia Pacific: Fastest growth predicted

**Key Players:**

- SpaceX, NASA, Blue Origin, Lockheed Martin, Airbus Defense & Space

**Driving Factors:**

- Technological advancements
- Private sector investment
- Increased demand for space data

**Challenges:**

- High costs
- Space debris management
- Regulatory complexities

For more detailed information, visit the
[report page](https://www.sphericalinsights.com/reports/space-exploration-market).

---

The article from the World Economic Forum discusses the projected growth of the space economy,
expecting it to reach $1.8 trillion by 2035. Key points include:

- **Rapid Growth**: The space economy, currently valued at $630 billion, is forecasted to grow at 9%
  per year.
- **Technological Advancements**: Innovations in satellite and rocket technologies are driving this
  growth.
- **Diverse Benefits**: Space technologies are enhancing various sectors, including agriculture,
  disaster mitigation, and digital communications.
- **Broader Investment**: Both state and private investments in space are increasing, with more than
  $70 billion invested in 2021-2022.

For more details, visit the article
[here](https://www.weforum.org/agenda/2024/04/space-economy-technology-invest-rocket-opportunity/).

---

### Summary: Space: The $1.8 Trillion Opportunity for Global Economic Growth

#### Executive Summary

- **Projected Growth**: Space economy to reach $1.8 trillion by 2035 from $630 billion in 2023,
  growing at 9% per year.
- **Technological Impact**: Innovations in satellite and rocket technologies are key growth drivers.
- **Industry Impact**: Space technologies will influence various sectors, including supply chain,
  agriculture, disaster mitigation, and digital communications.

#### Main Drivers

1. **Decrease in Launch Costs**: 10-fold decrease over 20 years.
2. **Commercial Innovation**: Smaller, more capable satellites.
3. **Diversified Investment**: Over $70 billion private investment in 2021-2022.
4. **Cultural Awareness**: Increased global interest in space activities.

#### Key Metrics

- **Space Economy Growth**: $1.8 trillion by 2035, 9% CAGR.
- **Commercial Communications**: $133 billion to $218 billion by 2035.
- **Positioning, Navigation, and Timing (PNT)**: Revenue growth from $40 billion to $95 billion
  by 2035.
- **Earth Observation (EO)**: Increase from $2 billion to $9 billion by 2035.

#### Industry Impacts

- **Supply Chain & Transportation**: Enhanced logistics and real-time tracking.
- **Food & Beverage**: Revolutionized delivery systems.
- **Retail & Consumer Goods**: Increased adoption of satellite-enabled devices.
- **Media & Entertainment**: Shift towards online platforms enabled by satellite internet.
- **State-Sponsored Applications**: Strategic importance for national security and research.

#### Global Participation

- **Established Space Nations**: Increased investments (e.g., India, Japan).
- **Emerging Space Nations**: New investments (e.g., Saudi Arabia, Thailand).
- **Geopolitical Conflicts**: Space capabilities in modern warfare (e.g., Ukraine).

### References

- **World Economic Forum in partnership with McKinsey & Company**

For more detailed information, you can view the full report on the
[World Economic Forum's website](https://www3.weforum.org/docs/WEF_Space_2024.pdf).

### References

- [Market Growth Q1 23](https://www.newspace.capital/wp-content/uploads/2023/11/Space-Industry-Review_Q1-2023_compressed.pdf)
- [Research Paper on Industry Growth April 24](https://www.oecd-ilibrary.org/docserver/9ae9a28d-en.pdf?expires=1718003766&id=id&accname=guest&checksum=0040C7D689A36606E846C58D7A8D8CDA)
- [Number of Investors in Industry](https://brycetech.com/reports/report-documents/Bryce_Start_Up_Space_2023.pdf)
- [Australia Report](https://assets.kpmg.com/content/dam/kpmg/au/pdf/2023/prosperous-future-report-space.pdf)
- [Space Sector Report Q1 2024](https://spacecapital.docsend.com/view/ajdahcajuyxa2zq9)
- [Space Sector Investment](https://app.powerbi.com/view?r=eyJrIjoiNGY4MWI4OWEtMjNmZS00OTM3LWE5M2QtYTgxZTdjODk3YTllIiwidCI6IjYzMDZkMTJjLTEwODMtNGNhOS04Yjk2LTdjYzM3ODcwMWIzMiIsImMiOjN9)
- [World Economic Forum Space Sector 2024](https://www3.weforum.org/docs/WEF_Space_2024.pdf)
- [The role in space driving sustainable development](https://www.mckinsey.com/~/media/mckinsey/industries/aerospace%20and%20defense/our%20insights/the%20role%20of%20space%20in%20driving%20sustainability%20security%20and%20development%20on%20earth/the-role-of-space-in-driving-sustainability-security-and-development-on-earth-vf.pdf)

### Indian Market

The space sector in India has been growing steadily over the past few years, driven by significant
advancements and initiatives by the Indian Space Research Organisation (ISRO) and the increasing
involvement of private companies. Here is an overview of the key aspects of the Indian space sector:

### Growth Over the Last Few Years

1. **ISRO's Achievements:**

   - **Mars Orbiter Mission (Mangalyaan):** Launched in 2013, it made India the first country to
     successfully reach Mars in its first attempt.
   - **Chandrayaan Missions:** The Chandrayaan-2 mission in 2019 aimed to explore the Moon's south
     pole.
   - **Satellite Launches:** ISRO has been launching satellites for various purposes, including
     communication, Earth observation, and navigation. The PSLV (Polar Satellite Launch Vehicle) has
     been a workhorse for ISRO, with numerous successful missions.

2. **Private Sector Involvement:**

   - Companies like OneWeb and SpaceX have shown interest in launching satellites using ISRO's
     launch vehicles.
   - Indian startups like Skyroot Aerospace and Agnikul Cosmos are emerging, focusing on developing
     private launch capabilities and small satellite technology.

3. **Commercial Satellite Launches:**

   - India has been a preferred destination for launching small satellites for other countries due
     to its cost-effective launch solutions. ISROs Antrix Corporation, the commercial arm, has been
     successful in attracting international clients.

4. **Policy and Infrastructure:**
   - The Indian government has been working on policies to boost private sector participation. The
     creation of IN-SPACe (Indian National Space Promotion and Authorization Center) aims to provide
     a level playing field for private companies.
   - Investment in space infrastructure, including new launch sites and the development of the Human
     Spaceflight program (Gaganyaan), is ongoing.

### Projections to 2035

1. **Market Size and Growth:**

   - The Indian space sector is expected to grow significantly, with projections indicating that it
     could reach a market size of around $50 billion by 2030.
   - The sector's growth rate is expected to be robust, driven by increased demand for
     satellite-based services, commercial launches, and new space exploration missions.

2. **Key Areas of Growth:**

   - **Satellite Launches:** Continued growth in the launch of communication, Earth observation, and
     navigation satellites.
   - **Space Exploration:** Missions like Chandrayaan-3, Gaganyaan (human spaceflight), and future
     interplanetary missions.
   - **Space-Based Services:** Expansion in services like satellite internet, remote sensing, and
     satellite-based navigation (NavIC).

3. **Private Sector Expansion:**

   - Increased involvement of private companies in manufacturing, launching, and providing
     space-based services.
   - Growth of startups and innovation hubs focused on space technology.

4. **Government Initiatives:**
   - Continued support through policies and funding, aiming to make India a global space hub.
   - Collaboration with international space agencies and participation in global space missions.

### Recent Developments

1. **ISRO's Budget:**

   - The Indian government has been increasing the budget allocation for ISRO, reflecting the
     growing importance of space activities.

2. **Human Spaceflight Program:**

   - The Gaganyaan mission aims to send Indian astronauts into space, which would be a significant
     milestone.

3. **International Collaborations:**
   - ISRO has been collaborating with other space agencies like NASA, ESA, and Roscosmos for various
     missions and technology sharing.

### Challenges

1. **Funding and Investment:**

   - While the government has been supportive, increasing private investment is crucial for
     sustained growth.

2. **Regulatory Framework:**

   - Streamlining regulatory processes to facilitate easier entry and operation for private
     companies.

3. **Technological Advancements:**
   - Keeping pace with global advancements in space technology and innovation.

---

### Department of Space Year-End Review 2022: Key Achievements from 2014 to December 2022

#### Overview

The Indian Space Programme has been highly dynamic and vibrant, achieving several milestones over
the past eight years. Below are the key missions, technological advancements, and strategic
initiatives by the Department of Space (DoS) and ISRO.

#### Key Missions

- **Launches and Missions:**
  - **44 spacecraft missions**, **42 launch vehicle missions**, and **5 technology demonstrators**
    have been successfully executed since 2014.
  - **GSLV-D5 (2014):** First successful flight with indigenous Cryogenic Upper Stage.
  - **Mars Orbiter Mission (2014):** Successfully entered Mars orbit, operational beyond its
    designed life.
  - **GSLV MKIII (2014):** Experimental flight of the next-generation launch vehicle.
  - **AstroSat (2015):** First dedicated Indian astronomy mission, discovering five new galaxies.
  - **NavIC (2016):** Navigation with Indian Constellation operational with 7 satellites.
  - **Reusable Launch Vehicle-Technology Demonstrator (2016):** Successful flight testing.
  - **PSLV C-37 (2017):** World record by placing 104 satellites in orbit during a single launch.
  - **GSLV Mk-III D1 (2017):** Successfully launched GSAT-19.
  - **Chandrayaan-2 (2019):** Launched India's second mission to the Moon.
  - **Quantum Key Distribution (2022):** Demonstrated real-time QKD and quantum-secure
    communication.
  - **OneWeb India-1 Mission (2022):** Successfully launched by LVM3.

#### Technological and Strategic Advancements

- **Human Spaceflight:**
  - **Gaganyaan Programme (2018):** Announced to mark India's foray into human space exploration.
  - **Crew Escape System (2018):** Pad Abort Test for human spaceflight safety.
- **High Throughput Satellites:**
  - **GSAT-29 (2018):** Launched to provide connectivity to remote regions.
  - **GSAT-11 (2018):** Heaviest satellite built by ISRO, launched from French Guiana.
- **Innovations:**
  - **Scramjet Engine (2016):** First experimental mission of Air Breathing Propulsion System.
  - **Inflatable Aerodynamic Decelerator (2022):** New technology demonstration for future missions.
- **Space Policy and Industry Participation:**
  - **NewSpace India Limited (NSIL, 2019):** Incorporated to scale up high-technology manufacturing
    and commercial exploitation of space products and services.
  - **IN-SPACe (2020):** Established to enhance private sector participation and boost India's
    market share in the global space economy.
  - **Private Launches (2022):** First private launchpad and mission control center by Agnikul
    Cosmos and the launch of Vikram-S by Skyroot Aerospace.

#### Academic Support and Outreach

- **Space Technology Incubational Centres (STIC):**
  - Established at key locations to boost space research activities. Currently, nine Space
    Technology Cells, six STICs, and six Regional Academic Centres for Space (RACS) are operational.
- **Capacity Building:**
  - **UNNATI Programme (2018):** Training on nanosatellites development with international
    participants.
  - **Young Scientist Programme (YUVIKA, 2019):** Imparts basic knowledge on space technology to
    young talents.
- **Innovation Network:**
  - **SpaceTech Innovation Network (SpIN, 2022):** Launched to support the burgeoning space
    entrepreneurial ecosystem.

#### Reforms and Enhanced Industry Participation

- **Space Sector Reforms (2020):** Major transformation to include private players in the Indian
  space programme.
- **Technology Transfer:**
  - NSIL has signed multiple Technology Transfer Agreements, transferring ISRO-developed
    technologies to Indian Industry.
- **Contracts and Commercial Launches:**
  - HAL and L&T consortia to produce PSLV.
  - Launch of GSAT-24, a demand-driven mission by NSIL.

#### Conclusion

The Indian space sector has achieved significant milestones in mission execution, technological
advancements, and strategic reforms, positioning India as a major player in the global space
economy. The initiatives have not only enhanced India's space capabilities but also opened avenues
for increased private sector participation and international collaboration.

---

### Snapshot of the Indian Space Sector

#### Overview

The Indian space sector is renowned for its cost-effective satellite solutions and successful launch
missions, such as the Mars Orbiter Mission (Mangalyaan). Currently, India holds 2-3% of the global
space economy, with ambitions to increase this share to over 10% by 2030.

#### Sector Specifics

**Satellite Manufacturing:**

- Collaboration between government agencies and private parties for manufacturing satellite parts
  and launchers.
- PSLV-C53 marked the first official public-private collaboration for a space launcher in India.

**Satellite Launches:**

- **Mars Orbiter Mission (2013):** India became the first nation to reach Mars orbit on its first
  attempt.
- **Gaganyaan Mission:** Scheduled to launch India's first crewed flight into space by 2024.
- **Other Missions:** Research satellites, navigation satellites (NavIC), and student satellites.

**Satellite Launch Services:**

- ISRO provides launch facilities for private and foreign organizations.
- Two operational launchers: Polar Satellite Launch Vehicle (PSLV) and Geosynchronous Satellite
  Launch Vehicle (GSLV).
- **PSLV:** 55 launches with 52 successes (as of July 2022).
- **NewSpace India Limited (NSIL):** Established as ISRO's commercial arm to drive private sector
  demand through technology transfer and aggregator models.
- India launched 381 foreign satellites for 34 countries (1999-2022), including 36 OneWeb Gen 1
  communication satellites in October 2022.

**Satellite Applications:**

- Applications include remote sensing, navigation, earth observation, disaster management, testing,
  and data analysis.
- Shift from building capabilities under ISRO to commercializing space-based technology and
  increasing private sector involvement.
- Potential future areas: space tourism and asteroid mining.

#### Key Achievements and Statistics

- **Foreign Satellite Launches:** 424 foreign satellites launched, earning over $279 million in
  revenue.
- **ISRO Agreements:** Six agreements with four countries (2021-2023) for launching foreign
  satellites, with a revenue potential of $141 million.
- **Private Sector Growth:** Over 400 private space companies, making India the fifth globally in
  the number of space companies.
- **Start-Up Growth:** From 1 start-up in 2012 to 189 in 2023, with funding growing to $124.7
  million in 2023.

#### Industry Scenario

- **Sector Valuation:** Valued at $9.6 billion in 2020, contributing 2%-3% of the global space
  economy. Expected to reach $13 billion by 2025 and capture close to 10% of the global economy
  by 2030.
- **Private Sector Role:** Emphasized by Prime Minister to increase India's share in the global
  space industry.
- **NSIL Investment:** Announced $1.2 billion investment over the next 5 years to boost industry
  involvement and commercial activities.
- **International Collaboration:** India is the 27th country to sign the Artemis Accords, guiding
  space exploration cooperation among nations participating in NASAs Artemis program.
- **Policy Changes:** Space Policy 2023 highlights private sector as a critical stakeholder. Space
  Activities Bill and 10 draft policies are in progress to provide regulatory frameworks and
  investment channels.

#### Growth Drivers

- **Increasing Demand:** For satellite services, including geospatial data-based services.
- **Encouraging Private Players:** Opportunities in setting up ground stations, small satellite
  segments, and component manufacturing.
- **Emerging Areas:** Space tourism and commercial recovery of space resources.
- **Complementary Sectors:** Strong support from India's leading aviation, defense, IT, and software
  industries.

This comprehensive overview highlights India's strategic advancements and growing potential in the
global space sector, driven by strong public-private partnerships and innovative policies.

---

India's space economy is projected to reach $40 billion by 2040, according to Union Minister
Jitendra Singh. The sector has grown significantly due to increased private sector participation and
various reforms, including the creation of IN-SPACe, which facilitates private industry
participation. Singh highlighted the importance of satellite communication, Earth observation, and
navigation, and emphasized India's cost-effective satellite launches. The government's focus on
innovation and strategic partnerships aims to enhance India's position in the global space economy.

For more details, read the full article
[here](https://www.livemint.com/news/india/indias-space-economy-to-soar-to-40-billion-by-2040-union-minister-jitendra-singh-11700977122020.html).

---

The Indian space sector has made significant advancements, transitioning from primarily
government-driven initiatives to increasing private sector involvement. Key milestones include the
establishment of the Indian Space Research Organisation (ISRO), notable achievements in satellite
launches, and successful interplanetary missions. The sector is supported by policies promoting
private investment, technological innovation, and international collaborations. Future growth is
expected to be driven by satellite manufacturing, launch services, and space-based applications,
with a focus on enhancing India's global presence and market share in the space economy.

For more details, visit the
[full document](https://www.eoiparis.gov.in/page/overview-of-the-indian-space-sector/).

---

The Indian Space Economy is projected to grow from $8.4 billion to $44 billion by 2033. Key
developments include the rise of space start-ups from 1 in 2014 to 189 in 2023, with investments
reaching $124.7 million in 2023. The Indian Space Policy 2023 aims to enhance private sector
involvement in satellite manufacturing, launch vehicle production, and ground systems. Initiatives
include promoting foreign direct investment, establishing private launchpads, and integrating space
technology education. IN-SPACe has signed 45 MoUs with NGEs to bolster industry participation.

For more detailed information, visit
[PIB Press Release](https://pib.gov.in/PressReleaseIframePage.aspx?PRID=1988864).

---

## ::financial-chart

title: Projected Indian Market Growth chartType: line chartDataKey: indianMarket

---

::

### References

- [Invest India Space Sector](https://www.investindia.gov.in/sector/space)
- [End of Year Review 2022 Space](https://static.investindia.gov.in/s3fs-public/2023-01/PIB1887687.pdf)
- [ISRO Opening Space](https://www.isro.gov.in/g20selm/assets/img/PDF/OpeningupSpace.pdf)

---

## Jobs Market

### Summary of Employment in the Space Sector and Gender Perspectives

This chapter provides an overview of employment in the global space sector, with a focus on gender
perspectives and the production of indicators to evaluate the sector from this viewpoint. The data
covers government space agencies, higher education institutions, and the private sector.

#### State of Employment in the Space Sector

- **Global Workforce**: Approximately 1 million people were employed in the space sector globally in
  2017, with significant concentrations in the United States (350,000), Russia (200,000), and Europe
  (60,000).
- **Employment Categories**: Jobs span public administration, core space manufacturing (rockets,
  satellites, ground systems), and the broader space services sector (mainly commercial satellite
  telecommunications).

#### Trends and Regional Insights

- **Stability and Growth**: Space manufacturing employment has been stable or increasing in most
  OECD countries over the past decade.
  - In Europe, employment reached 43,000 full-time equivalents in 2017.
  - In North America, US employment levels remained stable with 80,000 people employed in space
    manufacturing in 2017, while Canada employed almost 5,000.
  - In Asia, Japan employed about 9,000 people in space manufacturing, with Korea employing almost
    3,000.

#### Gender Gap and Female Employment

- **Current Status**: Women are under-represented across all segments of the space sector, from
  government to private industry.

  - Higher female employment rates are observed in administrative and project management roles
    compared to technical and engineering roles.
  - In Ukraine's National Space Agency, women represent 48% of employees.
  - At NASA, women account for 34% of total employment but only 23% of science and engineering
    occupations.

- **Trends in Higher Education**: Female participation in space-related higher education fields
  remains low but shows some positive trends.
  - In Korea, women accounted for 17% of doctoral and masters students in space-related fields
    in 2016.
  - In France, women made up 34% of permanent research personnel in space-related academic research
    institutions in 2016.

#### Gender Diversity in the Private Sector

- **Variability Across Segments**: Female employment rates in space manufacturing hover around 20%
  in Europe and the United States.
  - The Russian Federation reported a 46% female employment rate in the space manufacturing sector.
  - Women tend to have higher representation in downstream segments such as earth observation and
    satellite telecommunications.

#### Initiatives to Address Gender Disparity

- **Policy Actions and Programs**: Various initiatives are in place to promote gender equality in
  the space sector.
  - **Awareness and Engagement**: High-level conferences and workshops (e.g., Space for Women by
    UNOOSA/UN Women).
  - **Educational Initiatives**: Scholarships, mentorship programs, and dedicated internships to
    attract women to space-related higher education.
  - **Professional Setting**: Gender bias training, recruitment policies aiming for gender balance,
    and work-life balance schemes in organizations like NASA, ESA, and JAXA.

#### Future Directions

- **Generation Change**: The retirement of baby boomers is creating opportunities for younger
  professionals.
- **Digitalization and Automation**: Growing automation and digitalization trends may impact future
  job creation in space manufacturing.

This summary underscores the importance of continuous efforts to bridge the gender gap and
highlights the ongoing trends and challenges within the global space sector's workforce. For more
detailed information, you can refer to the full report from the OECD and other sources.

#### References

- [OECD Report on Space Employment](https://www.oecd-ilibrary.org/docserver/9ae9a28d-en.pdf?expires=1718003766&id=id&accname=guest&checksum=0040C7D689A36606E846C58D7A8D8CDA)
- [NASA Workforce Profile](https://wicn.nssc.nasa.gov/wicn_cubes.html)
- [Eurospace Facts & Figures](https://www.eurospace.org/)
- [Korean Space Industry Survey](https://www.kari.re.kr/eng.do)

---

### Summary of Employment in the U.S. Space Economy (2012-2021)

#### Overview:

- **Report Released**: June 27, 2023
- **Period Covered**: 2012-2021
- **Key Metrics**: Gross output, GDP contribution, private employment, and compensation.

#### Major Findings:

- **2021 Economic Impact**:
  - **Gross Output**: $211.6 billion
  - **GDP Contribution**: $129.9 billion (0.6% of total U.S. GDP)
  - **Private Industry Compensation**: $51.1 billion
  - **Private Industry Jobs**: 360,000

#### Employment and Compensation:

- **Total Private Employment**: 360,000 jobs in 2021
- **Sector Breakdown**:
  - **Manufacturing**:
    - **Share of Employment**: 35%
    - **Share of Compensation**: 45% ($182,762 average compensation)
  - **Information Sector**:
    - **Share of Employment**: 23%
    - **Share of Compensation**: 18%

#### Industry Performance (2012-2021):

- **Growth**:
  - **Gross Output**: Increased from $180.6 billion (2012) to $211.6 billion (2021)
  - **Real Gross Output**: Growth varied with an increase of 2.2% in 2019, a decrease of 1.9% in
    2020, and a further decrease of 0.4% in 2021.
  - **Real Value Added**: Increased 3.0% in 2019, decreased 0.4% in 2020, and decreased 3.6%
    in 2021.
- **Manufacturing**: Strong growth in 2019 (9.5%) and 2021 (5.8%)
- **Government Sector**: Increased 9.3% in 2019 and 3.4% in 2021; no decrease in 2020.

#### Government Employment:

- **Nondefense Federal, State, and Local Space Employment (2021)**: 19,111
  - **NASA**: 15,762 employees
  - **NOAA**: 2,030 employees
  - **Space Force**: 9,979 employees (defense-related, 2021 data)
  - **Other Federal Agencies**: FAA and U.S. Geological Survey among others.

#### Revisions and Methodology:

- **Methodological Improvements**: Corrected R&D spending estimates and included new insurance data.
- **Updated Source Data**: Reflected in gross output and value added by industry, incorporating new
  receipts and shipments data from the U.S. Census Bureau and IRS.

#### Next Steps:

- **Future Enhancements**: Estimating space economic activity by more specific categories (e.g.,
  launch and R&D) and potentially by state.
- **Feedback Request**: BEA encourages suggestions for improving space economy estimates.

#### Summary:

The U.S. space economy shows significant growth and economic contribution, with notable employment
in both private and public sectors. Continuous updates and methodological improvements aim to refine
these statistics and provide more detailed insights into the space economy's impact.

For detailed data and further information, you can visit the
[U.S. Bureau of Economic Analysis (BEA) space economy website](https://www.bea.gov/data/special-topics/space-economy).

---

### Summary of Employment in the Global Space Sector

#### Market Overview:

- **2021 Valuation**: The global space market was valued at $388.50 billion.
- **2026 Projection**: Expected to reach $540.75 billion.
- **Growth**: The sector grew by 70% between 2010 and 2020.
- **CAGR (2022-2026)**: Predicted at 6.84%.
- **Long-term Forecast**: Expected to reach $1 trillion in annual revenue by 2040.

#### Key Factors Driving Growth:

- **Cost Reduction**: Launch costs lowered by 95%.
- **Private Investment**: Around $14.5 billion invested in space infrastructure companies in the
  previous year, with expectations of increased investment.
- **Public-Private Partnerships**: Collaboration between public agencies and private companies is
  growing.

#### Employment Impact:

- **Current Jobs**: Estimated at around 400,000 jobs in the space sector.
- **Future Projection**: Expected to rise to 1.5 million jobs.
- **Job Categories**: Includes roles in accounting, marketing, design, IT, manufacturing, and STEM
  fields.
- **U.S. Manufacturing**: Advanced manufacturing for launch services generates over $2 billion
  annually, supporting 40% of global commercial launches.

#### Segment and Regional Insights:

- **Satellite Market**: Comprises over 70% of the space economy, with significant revenue from
  television services, broadband Internet, and mobile connectivity.
- **Reusable Rockets**: Expected to reduce costs and increase the feasibility of new space
  initiatives.
- **Lunar Exploration**: Renewed interest in the moon as a testing ground for Mars missions.
- **Climate Change Initiatives**: Investments in space technology to combat climate change and
  achieve the United Nations Sustainable Development Goals.
- **Market Segmentation**: The commercial space segment holds the largest market share (76% in
  2021).

#### Emerging Trends:

- **Space Tourism**: Private companies are advancing space tourism.
- **Technological Innovations**: Includes uninterrupted Internet, small satellites, space resource
  utilization, in-space manufacturing, asteroid mining, and interplanetary transportation systems.

#### Regional Market Dynamics:

- **North America**: Leading in Earth observation with nearly half of the global market share
  in 2021.
- **Africa and the Middle East**: Emerging market for satellite navigation, growing at a CAGR of
  11%.

#### Conclusion:

The global space sector is expanding rapidly, driven by technological advancements, increasing
private investment, and strategic public-private partnerships. This growth is creating substantial
employment opportunities and fostering innovation across various industries.

For more detailed information, you can refer to sources such as the OECD's space industry reports
and market analysis from Precedence Research and the World Economic Forum.

---

#### References

- [State of employment in the space sector 2017](https://www.oecd-ilibrary.org/sites/c5996201-en/1/2/3/index.html?itemId=/content/publication/c5996201-en&mimeType=text/html&_csp_=ffe5a6bbc1382ae4f0ead9dd2da73ff4&itemIGO=oecd&itemContentType=book#:~:text=The%20global%20space%20sector%20employed,around%2060%20000%20in%20Europe.)
- [Occupational Outlook Handbook](https://www.bls.gov/ooh/life-physical-and-social-science/physicists-and-astronomers.htm)
- [USA Space Job Market 2021](https://apps.bea.gov/scb/issues/2023/06-june/0623-space-economy.htm)
- []()
- []()
- []()
</file>

<file path="apps/admin-dashboard/content/bp/appendix-supporting-docs.md">
#### Supporting Documents and Data

1. **Company Overview and Mission Statement:**

   - A document detailing AstronEras mission, vision, and core values.
   - Background information about the company, its founders, and the inspiration behind its
     creation.

2. **Product Descriptions:**

   - Detailed descriptions of the Online Astronomy Hub features, including:
     - News Aggregation
     - Company Profiles
     - Social Interaction
     - AI-driven Summarization
     - Jobs Portal
     - Courses
     - AI RAG Search for Scraped Content
   - Explanation of the tiered subscription model (Free, Pro, Expert) and the specific features
     included in each tier.

3. **Marketing and Sales Strategy:**

   - Detailed marketing and sales strategy documents, including objectives, customer acquisition
     strategies, digital marketing and SEO plans, social media engagement strategies, sales funnel,
     and conversion strategies.
   - Partnership and collaboration plans.

4. **Operations Plan:**

   - Overview of business operations and workflow.
   - Detailed description of the technology stack and infrastructure.
   - AI agents for content updates and automation.
   - Content sourcing and quality control processes.
   - Customer support and service plans.

5. **Management Team:**
   - Organizational structure and roles and responsibilities of key team members.
   - Profiles of advisory board members and consultants.
</file>

<file path="apps/admin-dashboard/content/bp/company-details.md">
#### Company History and Background

1. **Founding Details:**

   - **Founding Date:** AstronEra was founded on 29th August 2018.
   - **Founders:** Shweta Kiran Kulkarni, with over 10 years of experience as a science
     communicator, dark sky advocate, and astropreneur.
   - **Inspiration:** AstronEra was created to bridge the gap between the general public and
     professionals in the field of astronomy, making astronomy accessible to all and fostering
     scientific temperment.

2. **Milestones:**

   - **IIMB Incubation (March 2018):** Shweta, among the top 100 women entrepreneurs in India,
     helped shape AstronEra, which was registered as AEII Pvt. Ltd.
   - **AstronEra Founded (November 2018):** The first astronomy e-learning platform was launched at
     Pune's Chandrasekhar Auditorium to an audience of over 800 business folk, esteemed guests, and
     renowned scientists.
   - **IAU Award (March 2019):** Efforts to popularize astronomy among tribal students were
     acknowledged by the International Astronomical Union (IAU).
   - **OAD, IAU Funding (January 2022):** Received an IAU, Office of Astronomy Development (OAD)
     grant to train tribal students as AstroGuides through the AstroTribe project.
   - **AstroTourism (March 2023):** Department of Science and Technology, (DST), Gov. India granted
     funds for AstroTourism and light pollution awareness in Himachal Pradesh and Ladakh.
   - **IDSPAC 2023:** Hosted the International Dark Sky Preservation and Astro-Tourism Conference
     represented a groundbreaking event in India, shedding light on the critical importance of
     preserving Dark Skies and harnessing the immense potential of Astro-Tourism.
   - **Significant Developments:** Expansion of services from just stargazing and educational
     content to a full astronomy hub, aligning with our original vision.

3. **Location:**
   - **Headquarters:** Pune, India.
   - **Additional Locations:** Completed projects in Himachal Pradesh, Ladakh, and througout
     Marharashtra.
   - **Global Presence:** Presented in prominent conferences around the globe including, Australia,
     UK, Israel, Canada, Ethiopeia and France.
</file>

<file path="apps/admin-dashboard/content/bp/company-model.md">
#### Business Model and Revenue Streams

1. **Revenue Streams:**

   - **Subscription Tiers:**
     - **Free Tier:**
       - Access to basic news summarization, basic AI questions, and limited agents using free or
         low-cost LLMs.
       - Access to root content such as news, research, companies, events, courses, etc.
     - **Pro Tier ($30/month):**
       - Advanced AI features, premium content access, and enhanced content summarization.
       - Access to premium news, company insights, job listings, events, and social media
         integration.
     - **Expert Tier ($50/month):**
       - Full AI capabilities with the latest models, extensive AI agents for specialized queries,
         comprehensive content summarization, and advanced search capabilities.
       - Exclusive webinars, collaborative research tools, advanced data insights, and personalized
         content.
   - **Additional Revenue Sources:**
     - **Advertising:** Simple paid advertising slots in the newsfeed or sidebar, with a future
       dashboard for businesses to create and manage their own ads.
     - **Affiliate Marketing:** Links in human-generated content, promoting recommended products.

2. **Customer Segments:**

   - **Primary Customers:**
     - **Astronomy Professionals:** Stay updated with the latest news, job openings, use AI tools,
       network with other professionals, grow a following, find resources/tools.
     - **Students:** Set up career paths, find jobs or internships, help with study planning and
       research, find resources/tools.
     - **Science Communicators/Influencers:** Simplify complex topics with AI, expand reach and
       audience, promote content.
     - **Astronomy Businesses:** Outreach and awareness, talent acquisition, promote jobs, customize
       profiles, user interactions.
     - **Enthusiasts:** Stay updated with the latest news, access all astronomy needs, connect with
       professionals, explore career shifts.

3. **Value Proposition:**
   - **Unique Value:**
     - Over a decade of experience in science communication.
     - Diversity of thought and opinions.
     - Established network providing extra value to users.
     - User experience-first approach, ensuring ease of use and access to information.
     - Pioneering AI Copilot for astronomers and tailored AI-curated content.
   - **Differentiation:**
     - Comprehensive astronomy platform serving all user segments.
     - Unique combination of astronomy expertise and AI knowledge.
     - Established brand with significant experience and partnerships in the astronomy industry.
     - One-stop shop for astronomy, accessible to all levels of users.
     - Focus on sustainable development and conservation of the night sky.
</file>

<file path="apps/admin-dashboard/content/bp/company-objectives.md">
#### Company Objectives and Goals

1. **Short-term Goals:**

   - **Objectives (1-2 years):**
     - Expansive dataset of research papers, news articles, courses, textbooks, jobs, and company
       information.
     - User growth: 10k after 1 year, 50k after 2 years, with conversion rates improving from 3% to
       6%.
     - Dominance in astronomy communication and community building.
     - Securing a globally known brand ambassador.
   - **Milestones:**
     - User growth milestones: 1k, 5k, 10k, 25k, 50k users.
     - Establishing a dark sky community.
     - Pioneering astronomy science communication curriculum.
     - Launching the AI Copilot.
     - Promoting AstroTourism in India.

2. **Long-term Vision:**

   - **Vision (5-10 years):**
     - Global one-stop shop for astronomy.
     - Best AI system for astronomy research.
     - Platform for collective intelligence and recognition.
     - Acquisition target of over $10 billion USD.
     - Largest user base of astronomy professionals and enthusiasts.
     - Leading movement for dark sky conservation.
     - Reducing global light pollution.
     - Marketplace for astronomy products and services.
   - **Strategic Goals:**
     - Continued investment in AI systems and data quality.
     - Hiring top talent passionate about astronomy and technology.
     - Centralization of the science community for technical institutions.
     - Promoting light pollution reduction and dark sky conservation.
     - Targeting academic institutes and businesses for research and promotion.
     - Partnering with organisations around the globe for loacalised curated content/services.

3. **KPIs and Metrics:**
   - **Key Performance Indicators:**
     - Growing user base and monthly recurring revenue.
     - Improved conversion rates and user engagement.
     - Increased social mentions and backlinks.
   - **Metrics:**
     - Monthly Active Users (MAU)
     - Customer Churn Rate (CCR)
     - Monthly Recurring Revenue (MRR)
     - Customer Acquisition Cost (CAC)
     - Website Bounce Rate
     - Organic Traffic
     - Paid Traffic
     - Virality Score
     - Social Mentions
     - Conversion Rate
     - Average User Engagement
     - Average Session Duration
     - Average Customer Lifetime Value (CLV)
</file>

<file path="apps/admin-dashboard/content/bp/costs.md">
#### Supabase: $25 PM

- 100,000 monthly active users (then $0.00325 per MAU)
- 8GB database space (then $0.125 per GB)
- 250GB bandwidth (then $0.09 per GB)
- 100GB file storage (then $0.021 per GB, $21 USD PM for 1TB s3)
- Email support
- Daily backups stored for 7 days
- 7-day log retention
</file>

<file path="apps/admin-dashboard/content/bp/executive-summary.md">
---
section: executive-summary
---

# Startup Budget Plan for AstronEra

## Executive Summary

Our startup is developing a SaaS platform that provides a comprehensive Online Astronomy Hub for
enthusiasts, professionals, students, and businesses. We're targeting a rapidly growing market with
a current size of $630 billion and projected annual growth to reach $1.8 trillion by 2035.

Key highlights of our 12-month plan:

- Projected user growth from 100 to 40,000
- Revenue growth to 1,19,19,800 by year-end
- Profitability achieved in Month 6
- Introduction of B2B offering with projected 4 enterprise clients by year-end
- Net profit of 75,62,175 in the first year

We're seeking an investment of 10,00,000 to fuel our growth and achieve these projections. The
repayment plan includes 12,00,000 to be repaid starting after 12 months.

### Investor Payback

- **Initial Investment:** 10,00,000
- **20% Interest:** 2,00,000
- **Total Payback Due:** 12,00,000

### Key Offerings

- News and content aggregation with AI-driven summarization
- Company profiles and job listings
- Social interaction features and community-driven events
- Courses ranging from hobbyist to advanced levels
- Custom AI search capabilities

**Pricing and Plan Distribution:**

- Basic Plan: 500/month (60% of paid users, starts Month 3)
- Pro Plan: 2,000/month (30% of paid users, starts Month 5)
- Expert Plan: 4,000/month (15% of paid users, starts Month 7)
- B2B: 50,000/month (4 companies by end of year, starts Month 9)

## Month 1: Setting Up and Initial Expenditures

- Office Rent: 30,000
- Director Salary: 25,000
- CTO Salary: 25,000
- Operations Manager Salary: 25,000
- Developer 1 Salary: 25,000
- Developer 2 Salary: 25,000
- DEV Operating Costs: 25,000
- Marketing Costs: 10,000
- Miscellaneous Expenses: 10,000

**Total Expenditure: 2,10,000**

**Remaining Funds: 7,90,000**

**Income: 0**

## First Year Monthly Breakdown

| Month | Total Users | Paid Users (Conv. Rate) | Basic Plan      | Medium Plan      | Pro Plan        | B2B Plan     | Ad Revenue | Total Revenue | Expenses  | Monthly Profit/Loss | Capital    |
| ----- | ----------- | ----------------------- | --------------- | ---------------- | --------------- | ------------ | ---------- | ------------- | --------- | ------------------- | ---------- |
| 1     | 500         | 0                       | -               | -                | -               | -            | 0         | 0            | 2,00,000 | -2,00,000          | 7,90,000  |
| 2     | 2,000       | 0                       | -               | -                | -               | -            | 10,000    | 10,000       | 2,00,000 | -1,90,000          | 6,10,000  |
| 3     | 4,000       | 80 (2.0%)               | 40,000 (80)    | -                | -               | -            | 20,000    | 60,000       | 2,00,000 | -1,40,000          | 4,70,000  |
| 4     | 7,000       | 154 (2.2%)              | 77,000 (154)   | -                | -               | -            | 35,000    | 1,12,000     | 3,20,000 | -2,08,000          | 2,62,000  |
| 5     | 11,000      | 264 (2.4%)              | 79,200 (158)   | 2,12,000 (106)  | -               | -            | 55,000    | 3,46,200     | 3,20,000 | 26,200             | 2,88,200  |
| 6     | 16,000      | 416 (2.6%)              | 1,24,800 (250) | 3,32,000 (166)  | -               | -            | 80,000    | 5,36,800     | 3,20,000 | 2,16,800           | 5,05,000  |
| 7     | 21,000      | 630 (3.0%)              | 1,89,000 (378) | 5,04,000 (252)  | 3,78,000 (94)  | -            | 1,05,000  | 11,76,000    | 3,20,000 | 8,56,000           | 13,61,000 |
| 8     | 26,000      | 806 (3.1%)              | 2,41,800 (484) | 6,44,000 (322)  | 4,84,000 (121) | -            | 1,30,000  | 14,99,800    | 3,20,000 | 11,79,800          | 25,40,800 |
| 9     | 30,000      | 960 (3.2%)              | 2,88,000 (576) | 7,68,000 (384)  | 5,76,000 (144) | 50,000 (1)  | 1,50,000  | 18,32,000    | 3,20,000 | 15,12,000          | 40,52,800 |
| 10    | 33,000      | 1,089 (3.3%)            | 3,26,700 (653) | 8,71,200 (436)  | 6,53,400 (163) | 100,000 (2) | 1,65,000  | 20,16,300    | 3,20,000 | 16,96,300          | 57,49,100 |
| 11    | 36,000      | 1,224 (3.4%)            | 3,67,200 (734) | 9,79,200 (490)  | 7,34,400 (184) | 150,000 (3) | 1,80,000  | 22,60,800    | 3,20,000 | 19,40,800          | 76,89,900 |
| 12    | 40,000      | 1,400 (3.5%)            | 4,20,000 (840) | 11,20,000 (560) | 8,40,000 (210) | 200,000 (4) | 2,00,000  | 26,00,000    | 3,20,000 | 22,80,000          | 99,69,900 |

### Summary After 12 Months

- **Total Expenses:** 24,00,000
- **Total Revenue:** 1,17,65,700
- **Net Profit:** 93,65,700
- **Ending Capital:** 1,03,65,700

## Key Performance Indicators (KPIs) (Industry Standard)

1. Monthly Recurring Revenue (MRR) (15% month-over-month growth)
2. User Growth Rate (20% month-over-month growth)
3. Conversion Rate (Free to Paid) (5-7%)
4. Customer Acquisition Cost (CAC) (1/3 of Customer Lifetime Value)
5. Customer Lifetime Value (CLV) (3x CAC)
6. Churn Rate (5.3% monthly)
7. Net Promoter Score (NPS) (30-50 for SaaS)
8. Feature Adoption Rate (50-60%)
9. B2B Client Acquisition Rate (10-20% annual growth)
10. Burn Rate and Runway (12-18 months runway)

## Risk Analysis and Mitigation Strategies

1. **Market Risks:**

   - **Changes in Market Demand:**
     - **Risk:** Potential changes in public interest in astronomy and space-related content.
     - **Mitigation:** Regularly monitor trends and adjust content strategies accordingly.
   - **Competition:**
     - **Risk:** High competition from existing platforms offering similar content.
     - **Mitigation:** Differentiate through unique features, advanced AI-driven content, and a
       strong value proposition.

2. **Financial Risks:**

   - **Funding and Cash Flow:**
     - **Risk:** Difficulty in securing initial and ongoing funding.
     - **Mitigation:** Build strong relationships with investors, present a clear and compelling
       business case.
   - **Economic Downturns:**
     - **Risk:** Impact of global or regional economic downturns on user subscriptions and
       advertising revenue.
     - **Mitigation:** Diversify revenue streams and maintain a financial buffer.

3. **Operational Risks:**

   - **Scaling Operations:**
     - **Risk:** Challenges in scaling the platform to handle a growing user base.
     - **Mitigation:** Use scalable cloud infrastructure and plan for modular architecture.
   - **Data Security and Privacy:**
     - **Risk:** Potential data breaches or non-compliance with data protection regulations.
     - **Mitigation:** Adopt industry-standard security practices and conduct regular audits.

4. **Technical Risks:**
   - **AI Integration:**
     - **Risk:** Challenges in integrating and maintaining AI technologies.
     - **Mitigation:** Use phased integration of AI features and continuous model updates.
   - **Accuracy and Performance:**
     - **Risk:** Ensuring the AI models provide accurate and relevant summaries and answers.
     - **Mitigation:** Continuous training and leveraging user feedback for improvements.

By addressing these potential risks and implementing robust mitigation strategies, AstronEra can
better navigate the challenges in the dynamic space industry and maintain a competitive edge.
</file>

<file path="apps/admin-dashboard/content/bp/financials-break-even.md">
#### Break-even Analysis

1. **Break-even Point:**

   - Calculation of the break-even point in terms of revenue and time:
     - **Break-even Revenue:** $324,010 (Year 1 expenses)
     - **Break-even Time:** Achieved in the first year
     - **Number of Users Needed:** Pro and Expert subscriptions to cover costs

2. **Break-even Analysis:**
   - Monthly and yearly analysis of how long it will take to reach the break-even point:
     - **Year 1:** Break-even achieved within the first year
     - **Year 2:** Significantly profitable
     - **Year 3:** Highly profitable
</file>

<file path="apps/admin-dashboard/content/bp/financials-cashflow.md">
#### Cash Flow Analysis

1. **Cash Inflows:**

   - Expected cash inflows from subscriptions and other revenue streams:
     - **Year 1:** $330,000
     - **Year 2:** $1,725,000
     - **Year 3:** $9,000,000

2. **Cash Outflows:**

   - Expected cash outflows for operational costs, development costs, and miscellaneous expenses:
     - **Year 1:** $324,010
     - **Year 2:** $595,510
     - **Year 3:** $1,573,510

3. **Net Cash Flow:**
   - Difference between cash inflows and outflows over time:
     - **Year 1:** $5,990
     - **Year 2:** $1,129,490
     - **Year 3:** $7,426,490
</file>

<file path="apps/admin-dashboard/content/bp/financials-expenses.md">
#### Cost Structure and Budget

1. **Operational Costs:**

   - **Salaries and Wages:**
     - Management Team: 5 members \* 1 lakh/month = 5 lakh/month
     - Other Employees: 10 members \* 50k/month = 5 lakh/month
     - **Total Monthly Salaries:** 10 lakh/month
   - **Infrastructure and Hosting Costs:**
     - Supabase, Vercel, Digital Ocean: $2,000/month
   - **Marketing and Advertising Expenses:**
     - Suggested Budget: $5,000/month
   - **AI and Data Processing Costs:**
     - News Articles: 10,000 articles/month \* $0.02 = $200
     - Research Papers: 2,000 papers/month \* $0.03 = $60
     - Company Scraping: 1,000 companies \* $1 = $1,000
     - Ongoing Company Monitoring: 1,000 companies \* $0.50/year = $500/year
   - **Customer Support and Service Costs:**
     - Year 1: 1 agent \* 40k/month = 40k/month
     - Year 2: 10 agents \* 40k/month = 4 lakh/month
     - Year 3: 20 agents \* 40k/month = 8 lakh/month

2. **Development Costs:**

   - **Initial Development Costs:**
     - Machine Learning Expert: 1 lakh/month
     - Database Expert: 1 lakh/month
     - Frontend/UI Developer: 1 lakh/month
     - Fullstack Developer: 1 lakh/month
     - DevOps Person: 1 lakh/month
     - **Total Initial Development Costs:** 5 lakh/month
   - **Ongoing Development and Maintenance Costs:**
     - Triple the team size in Year 2 and again in Year 3
     - **Year 2:** 15 developers \* 1 lakh/month = 15 lakh/month
     - **Year 3:** 45 developers \* 1 lakh/month = 45 lakh/month

3. **Miscellaneous Costs:**
   - **Legal and Administrative Expenses:**
     - Accounting: 30k/year
     - Business Admin: 30k/year
     - Legal Counsel: 30k/year
   - **Office Space and Utilities:**
     - Rent for Pune: 1 lakh/month for office space for 30 people
     - Additional Setup Costs: 10 lakh (one-time)
     - Leasing Apple M1 MacBooks: 1 lakh/month
   - **Total Miscellaneous Costs:** 15 lakh/year + 10 lakh one-time setup

Sure, let's extend the projections to include years 6, 7, 8, and 9 and consolidate all the
information into one comprehensive table.

### Comprehensive Financial and Employee Projections (Years 1-10)

| **Year**           | **Role**                     | **Number of Employees** | **Annual Salary (USD)** | **Total Annual Salary** | **Total Revenue (USD)** | **Total Salary Expense (USD)** | **Other Operational Costs (USD)** | **Total Expenses (USD)** | **Net Revenue (USD)** |
| ------------------ | ---------------------------- | ----------------------- | ----------------------- | ----------------------- | ----------------------- | ------------------------------ | --------------------------------- | ------------------------ | --------------------- |
| **Year 1** (2024)  | CEO                          | 1                       | $16,000                 | $16,000                 | $16,780,000             | $113,000                       | $214,000                          | $327,000                 | $16,453,000           |
|                    | CTO                          | 1                       | $16,000                 | $16,000                 |                         |                                |                                   |                          |                       |
|                    | AI Engineers/Data Scientists | 3                       | $9,000 each             | $27,000                 |                         |                                |                                   |                          |                       |
|                    | Platform Developers          | 2                       | $9,000 each             | $18,000                 |                         |                                |                                   |                          |                       |
|                    | Customer Support             | 2                       | $9,000 each             | $18,000                 |                         |                                |                                   |                          |                       |
|                    | Sales/Marketing              | 2                       | $9,000 each             | $18,000                 |                         |                                |                                   |                          |                       |
|                    | **Total Employees**          | 10                      | -                       | **$113,000**            |                         |                                |                                   |                          |                       |
| **Year 2** (2025)  | CEO                          | 1                       | $19,200                 | $19,200                 | $22,000,000             | $178,800                       | $350,000                          | $528,800                 | $21,471,200           |
|                    | CTO                          | 1                       | $19,200                 | $19,200                 |                         |                                |                                   |                          |                       |
|                    | AI Engineers/Data Scientists | 4                       | $10,800 each            | $43,200                 |                         |                                |                                   |                          |                       |
|                    | Platform Developers          | 3                       | $10,800 each            | $32,400                 |                         |                                |                                   |                          |                       |
|                    | Customer Support             | 3                       | $10,800 each            | $32,400                 |                         |                                |                                   |                          |                       |
|                    | Sales/Marketing              | 3                       | $10,800 each            | $32,400                 |                         |                                |                                   |                          |                       |
|                    | **Total Employees**          | 14                      | -                       | **$178,800**            |                         |                                |                                   |                          |                       |
| **Year 3** (2026)  | CEO                          | 1                       | $28,800                 | $28,800                 | $30,000,000             | $394,200                       | $400,000                          | $794,200                 | $29,205,800           |
|                    | CTO                          | 1                       | $28,800                 | $28,800                 |                         |                                |                                   |                          |                       |
|                    | AI Engineers/Data Scientists | 6                       | $16,200 each            | $97,200                 |                         |                                |                                   |                          |                       |
|                    | Platform Developers          | 4                       | $16,200 each            | $64,800                 |                         |                                |                                   |                          |                       |
|                    | Customer Support             | 4                       | $16,200 each            | $64,800                 |                         |                                |                                   |                          |                       |
|                    | Sales/Marketing              | 4                       | $16,200 each            | $64,800                 |                         |                                |                                   |                          |                       |
|                    | Product Manager              | 1                       | $28,800                 | $28,800                 |                         |                                |                                   |                          |                       |
|                    | Data Analyst                 | 1                       | $16,200                 | $16,200                 |                         |                                |                                   |                          |                       |
|                    | **Total Employees**          | 21                      | -                       | **$394,200**            |                         |                                |                                   |                          |                       |
| **Year 4** (2027)  | CEO                          | 1                       | $34,560                 | $34,560                 | $40,000,000             | $701,000                       | $500,000                          | $1,201,000               | $38,799,000           |
|                    | CTO                          | 1                       | $34,560                 | $34,560                 |                         |                                |                                   |                          |                       |
|                    | AI Engineers/Data Scientists | 8                       | $19,440 each            | $155,520                |                         |                                |                                   |                          |                       |
|                    | Platform Developers          | 6                       | $19,440 each            | $116,640                |                         |                                |                                   |                          |                       |
|                    | Customer Support             | 6                       | $19,440 each            | $116,640                |                         |                                |                                   |                          |                       |
|                    | Sales/Marketing              | 6                       | $19,440 each            | $116,640                |                         |                                |                                   |                          |                       |
|                    | Product Managers             | 2                       | $34,560 each            | $69,120                 |                         |                                |                                   |                          |                       |
|                    | Data Analysts                | 2                       | $19,440 each            | $38,880                 |                         |                                |                                   |                          |                       |
|                    | HR Manager                   | 1                       | $19,440                 | $19,440                 |                         |                                |                                   |                          |                       |
|                    | **Total Employees**          | 32                      | -                       | **$701,000**            |                         |                                |                                   |                          |                       |
| **Year 5** (2028)  | CEO                          | 1                       | $48,000                 | $48,000                 | $50,340,000             | $1,293,000                     | $620,000                          | $1,913,000               | $48,427,000           |
|                    | CTO                          | 1                       | $48,000                 | $48,000                 |                         |                                |                                   |                          |                       |
|                    | AI Engineers/Data Scientists | 10                      | $27,000 each            | $270,000                |                         |                                |                                   |                          |                       |
|                    | Platform Developers          | 8                       | $27,000 each            | $216,000                |                         |                                |                                   |                          |                       |
|                    | Customer Support             | 8                       | $27,000 each            | $216,000                |                         |                                |                                   |                          |                       |
|                    | Sales/Marketing              | 8                       | $27,000 each            | $216,000                |                         |                                |                                   |                          |                       |
|                    | Product Managers             | 3                       | $48,000 each            | $144,000                |                         |                                |                                   |                          |                       |
|                    | Data Analysts                | 3                       | $27,000 each            | $81,000                 |                         |                                |                                   |                          |                       |
|                    | HR Manager                   | 1                       | $27,000                 | $27,000                 |                         |                                |                                   |                          |                       |
|                    | Finance Manager              | 1                       | $27,000                 | $27,000                 |                         |                                |                                   |                          |                       |
|                    | **Total Employees**          | 43                      | -                       | **$1,293,000**          |                         |                                |                                   |                          |                       |
| **Year 6** (2029)  | CEO                          | 1                       | $57,600                 | $57,600                 | $70,000,000             | $2,011,200                     | $800,000                          | $2,811,200               | $67,188,800           |
|                    | CTO                          | 1                       | $57,600                 | $57,600                 |                         |                                |                                   |                          |                       |
|                    | AI Engineers/Data Scientists | 12                      | $32,400 each            | $388,800                |                         |                                |                                   |                          |                       |
|                    | Platform Developers          | 10                      | $32,400 each            | $324,000                |                         |                                |                                   |                          |                       |
|                    | Customer Support             | 10                      | $32,400 each            | $324,000                |                         |                                |                                   |                          |                       |
|                    | Sales/Marketing              | 10                      | $32,400 each            | $324,000                |                         |                                |                                   |                          |                       |
|                    | Product Managers             | 4                       | $57,600 each            | $230,400                |                         |                                |                                   |                          |                       |
|                    | Data Analysts                | 4                       | $32,400 each            | $129,600                |                         |                                |                                   |                          |                       |
|                    | HR Manager                   | 2                       | $32,400 each            | $64,800                 |                         |                                |                                   |                          |                       |
|                    | Finance Manager              | 2                       | $32,400 each            | $64,800                 |                         |                                |                                   |                          |                       |
|                    | **Total Employees**          | 47                      | -                       | **$2,011,200**          |                         |                                |                                   |                          |                       |
| **Year 7** (2030)  | CEO                          | 1                       | $69,120                 | $69,120                 | $90,000,000             | $2,701,920                     | $1,000,000                        | $3,701,920               | $86,298,080           |
|                    | CTO                          | 1                       | $69,120                 | $69,120                 |                         |                                |                                   |                          |                       |
|                    | AI Engineers/Data Scientists | 14                      | $38,880 each            | $544,320                |                         |                                |                                   |                          |                       |
|                    | Platform Developers          | 12                      | $38,880 each            | $466,560                |                         |                                |                                   |                          |                       |
|                    | Customer Support             | 12                      | $38,880 each            | $466,560                |                         |                                |                                   |                          |                       |
|                    | Sales/Marketing              | 12                      | $38,880 each            | $466,560                |                         |                                |                                   |                          |                       |
|                    | Product Managers             | 5                       | $69,120 each            | $345,600                |                         |                                |                                   |                          |                       |
|                    | Data Analysts                | 5                       | $38,880 each            | $194,400                |                         |                                |                                   |                          |                       |
|                    | HR Manager                   | 2                       | $38,880 each            | $77,760                 |                         |                                |                                   |                          |                       |
|                    | Finance Manager              | 2                       | $38,880 each            | $77,760                 |                         |                                |                                   |                          |                       |
|                    | **Total Employees**          | 58                      | -                       | **$2,701,920**          |                         |                                |                                   |                          |                       |
| **Year 8** (2031)  | CEO                          | 1                       | $82,944                 | $82,944                 | $110,000,000            | $3,527,808                     | $1,200,000                        | $4,727,808               | $105,272,192          |
|                    | CTO                          | 1                       | $82,944                 | $82,944                 |                         |                                |                                   |                          |                       |
|                    | AI Engineers/Data Scientists | 16                      | $46,656 each            | $746,496                |                         |                                |                                   |                          |                       |
|                    | Platform Developers          | 14                      | $46,656 each            | $653,184                |                         |                                |                                   |                          |                       |
|                    | Customer Support             | 14                      | $46,656 each            | $653,184                |                         |                                |                                   |                          |                       |
|                    | Sales/Marketing              | 14                      | $46,656 each            | $653,184                |                         |                                |                                   |                          |                       |
|                    | Product Managers             | 5                       | $82,944 each            | $414,720                |                         |                                |                                   |                          |                       |
|                    | Data Analysts                | 5                       | $46,656 each            | $233,280                |                         |                                |                                   |                          |                       |
|                    | HR Manager                   | 2                       | $46,656 each            | $93,312                 |                         |                                |                                   |                          |                       |
|                    | Finance Manager              | 2                       | $46,656 each            | $93,312                 |                         |                                |                                   |                          |                       |
|                    | **Total Employees**          | 68                      | -                       | **$3,527,808**          |                         |                                |                                   |                          |                       |
| **Year 9** (2032)  | CEO                          | 1                       | $99,532.80              | $99,532.80              | $130,000,000            | $4,553,049.60                  | $1,350,000                        | $5,903,049.60            | $124,096,950.40       |
|                    | CTO                          | 1                       | $99,532.80              | $99,532.80              |                         |                                |                                   |                          |                       |
|                    | AI Engineers/Data Scientists | 18                      | $55,987.20 each         | $1,007,769.60           |                         |                                |                                   |                          |                       |
|                    | Platform Developers          | 16                      | $55,987.20 each         | $895,795.20             |                         |                                |                                   |                          |                       |
|                    | Customer Support             | 16                      | $55,987.20 each         | $895,795.20             |                         |                                |                                   |                          |                       |
|                    | Sales/Marketing              | 16                      | $55,987.20 each         | $895,795.20             |                         |                                |                                   |                          |                       |
|                    | Product Managers             | 6                       | $99,532.80 each         | $597,196.80             |                         |                                |                                   |                          |                       |
|                    | Data Analysts                | 6                       | $55,987.20 each         | $335,923.20             |                         |                                |                                   |                          |                       |
|                    | HR Manager                   | 2                       | $55,987.20 each         | $111,974.40             |                         |                                |                                   |                          |                       |
|                    | Finance Manager              | 2                       | $55,987.20 each         | $111,974.40             |                         |                                |                                   |                          |                       |
|                    | **Total Employees**          | 78                      | -                       | **$4,553,049.60**       |                         |                                |                                   |                          |                       |
| **Year 10** (2033) | CEO                          | 1                       | $600,000                | $600,000                | $167,800,000            | $7,440,000                     | $1,500,000                        | $8,940,000               | $158,860,000          |
|                    | CTO                          | 1                       | $600,000                | $600,000                |                         |                                |                                   |                          |                       |
|                    | COO                          | 1                       | $600,000                | $600,000                |                         |                                |                                   |                          |                       |
|                    | CFO                          | 1                       | $600,000                | $600,000                |                         |                                |                                   |                          |                       |
|                    | AI Engineers/Data Scientists | 20                      | $60,000 each            | $1,200,000              |                         |                                |                                   |                          |                       |
|                    | Platform Developers          | 15                      | $60,000 each            | $900,000                |                         |                                |                                   |                          |                       |
|                    | Customer Support             | 15                      | $60,000 each            | $900,000                |                         |                                |                                   |                          |                       |
|                    | Sales/Marketing              | 15                      | $60,000 each            | $900,000                |                         |                                |                                   |                          |                       |
|                    | Product Managers             | 5                       | $120,000 each           | $600,000                |                         |                                |                                   |                          |                       |
|                    | Data Analysts                | 5                       | $60,000 each            | $300,000                |                         |                                |                                   |                          |                       |
|                    | HR Managers                  | 2                       | $60,000 each            | $120,000                |                         |                                |                                   |                          |                       |
|                    | Finance Managers             | 2                       | $60,000 each            | $120,000                |                         |                                |                                   |                          |                       |
|                    | **Total Employees**          | 83                      | -                       | **$7,440,000**          |                         |                                |                                   |                          |                       |

### Summary

**Projected Growth**: $1.8 trillion by 2035, from $630 billion in 2023, at 9% CAGR.

**Revenue Projections:**

- **Year 1 (2024)**: Total Revenue: $16,780,000; Total Expenses: $327,000; Net Revenue: $16,453,000
- **Year 2 (2025)**: Total Revenue: $22,000,000; Total Expenses: $528,800; Net Revenue: $21,471,200
- **Year 3 (2026)**: Total Revenue: $30,000,000; Total Expenses: $794,200; Net Revenue: $29,205,800
- **Year 4 (2027)**: Total Revenue: $40,000,000; Total Expenses: $1,201,000; Net Revenue:
  $38,799,000
- **Year 5 (2028)**: Total Revenue: $50,340,000; Total Expenses: $1,913,000; Net Revenue:
  $48,427,000
- **Year 6 (2029)**: Total Revenue: $70,000,000; Total Expenses: $2,811,200; Net Revenue:
  $67,188,800
- **Year 7 (2030)**: Total Revenue: $90,000,000; Total Expenses: $3,701,920; Net Revenue:
  $86,298,080
- **Year 8 (2031)**: Total Revenue: $110,000,000; Total Expenses: $4,727,808; Net Revenue:
  $105,272,192
- **Year 9 (2032)**: Total Revenue: $130,000,000; Total Expenses: $5,903,049.60; Net Revenue:
  $124,096,950.40
- **Year 10 (2033)**: Total Revenue: $167,800,000; Total Expenses: $8,940,000; Net Revenue:
  $158,860,000

**Employee Growth:**

- **Year 1**: 10 employees
- **Year 2**: 14 employees
- **Year 3**: 21 employees
- **Year 4**: 32 employees
- **Year 5**: 43 employees
- **Year 6**: 47 employees
- **Year 7**: 58 employees
- **Year 8**: 68 employees
- **Year 9**: 78 employees
- **Year 10**: 83 employees

This table provides a comprehensive year-by-year breakdown of financial projections and employee
growth, ensuring a clear roadmap for scaling the company while maintaining focus on core software
development and supporting roles.
</file>

<file path="apps/admin-dashboard/content/bp/financials-funding-request.md">
#### Funding Requirements and Use of Funds

1. **Funding Needs:**

   - Total amount of funding required to cover initial and ongoing costs until break-even:
     - **Estimated Funding Needs:** $300,000 (to cover initial costs and buffer for unforeseen
       expenses)

2. **Use of Funds:**
   - Detailed breakdown of how the funds will be used (e.g., development, marketing, hiring,
     infrastructure):
     - **Development:** $100,000
     - **Marketing:** $50,000
     - **Hiring:** $50,000
     - **Infrastructure:** $50,000
     - **Miscellaneous and Buffer:** $50,000
</file>

<file path="apps/admin-dashboard/content/bp/financials-profit-loss.md">
#### Profit and Loss Statements

1. **Revenue:**

   - Total projected revenue from all sources:
     - **Year 1:** $330,000
     - **Year 2:** $1,725,000
     - **Year 3:** $9,000,000

2. **Expenses:**

   - Breakdown of all expenses (operational, development, miscellaneous):

     - **Year 1:**

       - Operational Costs: 10 lakh/month \* 12 = 1.2 crore (~$150,000)
       - AI and Data Processing: $1,760
       - Marketing and Advertising: $5,000/month \* 12 = $60,000
       - Customer Support: 40k/month \* 12 = 4.8 lakh (~$6,000)
       - Development Costs: 5 lakh/month \* 12 = 60 lakh (~$75,000)
       - Miscellaneous Costs: 15 lakh/year + 10 lakh setup (~$31,250)
       - **Total Expenses Year 1:** $324,010

     - **Year 2:**

       - Operational Costs: 15 lakh/month \* 12 = 1.8 crore (~$225,000)
       - AI and Data Processing: $6,760
       - Marketing and Advertising: $5,000/month \* 12 = $60,000
       - Customer Support: 4 lakh/month \* 12 = 48 lakh (~$60,000)
       - Development Costs: 15 lakh/month \* 12 = 1.8 crore (~$225,000)
       - Miscellaneous Costs: 15 lakh/year (~$18,750)
       - **Total Expenses Year 2:** $595,510

     - **Year 3:**
       - Operational Costs: 45 lakh/month \* 12 = 5.4 crore (~$675,000)
       - AI and Data Processing: $24,760
       - Marketing and Advertising: $5,000/month \* 12 = $60,000
       - Customer Support: 8 lakh/month \* 12 = 96 lakh (~$120,000)
       - Development Costs: 45 lakh/month \* 12 = 5.4 crore (~$675,000)
       - Miscellaneous Costs: 15 lakh/year (~$18,750)
       - \*\*Total Expenses Year

3:\*\* $1,573,510

3. **Net Profit:**
   - Calculated by subtracting total expenses from total revenue:
     - **Year 1:** $330,000 - $324,010 = $5,990
     - **Year 2:** $1,725,000 - $595,510 = $1,129,490
     - **Year 3:** $9,000,000 - $1,573,510 = $7,426,490
</file>

<file path="apps/admin-dashboard/content/bp/financials-projections.md">
#### Revenue Model and Projections

1. **Subscription Tiers:**

   - **Free Tier:**

     - **Features:**
       - Access to all news summarization
       - Basic AI questions and limited agents using free or low-cost LLMs
       - Access to all root content such as news, research, companies, events, courses, etc.
     - **Expected Conversion Rate to Paid Tiers:**
       - 3% initial conversions, growth to 6% after 2 years of operations
     - **User Projections:**
       - 10k free users after 1 year, 50k after 2 years, 200k after 3 years

   - **Pro Tier ($30/month):**

     - **Features:**
       - Advanced AI questions with more sophisticated AI models
       - Access to more AI agents
       - Enhanced content summarization
       - Access to all features in the free tier plus premium news, company insights, job listings,
         events, and social media integration
     - **User Projections:**
       - Year 1: 300 users
       - Year 2: 1,500 users
       - Year 3: 6,000 users

   - **Expert Tier ($50/month):**
     - **Features:**
       - Full AI capabilities with the latest models
       - Extensive AI agents for specialized queries
       - Comprehensive content summarization and advanced search capabilities
       - Access to all Pro tier features plus exclusive webinars, collaborative research tools,
         advanced data insights, and personalized content
     - **User Projections:**
       - Year 1: 300 users
       - Year 2: 1,500 users
       - Year 3: 6,000 users

2. **Additional Revenue Streams:**

   - **Advertising:**

     - Premium advertisement position in highly trafficked newsfeed
     - **Estimated Impressions and Clicks:**
       - Year 1: 100k impressions/month, 10k clicks/month
       - Year 2: 500k impressions/month, 50k clicks/month
       - Year 3: 2M impressions/month, 200k clicks/month
     - **Suggested Pricing:**
       - $10 per 1,000 impressions (CPM), $1 per click (CPC)

   - **Affiliate Marketing:**
     - Affiliate links in human-generated content
     - **Estimated Clicks and Conversion Rate:**
       - Conversion rate: 5%
       - Year 1: 10k clicks/month _ 5% conversion _ $50 average sale _ 12 months _ 10% commission =
         $30,000
       - Year 2: 50k clicks/month _ 5% conversion _ $50 average sale _ 12 months _ 15% commission =
         $225,000
       - Year 3: 200k clicks/month _ 5% conversion _ $50 average sale _ 12 months _ 20% commission =
         $3,000,000

3. **Revenue Projections:**

   - **Year 1:**

     - Pro Tier: 300 users _ $30/month _ 12 months = $108,000
     - Expert Tier: 300 users _ $50/month _ 12 months = $180,000
     - Advertising: 100k impressions/month _ $10/CPM _ 12 months = $12,000
     - Affiliate Marketing: $30,000
     - **Total Revenue Year 1:** $330,000

   - **Year 2:**

     - Pro Tier: 1,500 users _ $30/month _ 12 months = $540,000
     - Expert Tier: 1,500 users _ $50/month _ 12 months = $900,000
     - Advertising: 500k impressions/month _ $10/CPM _ 12 months = $60,000
     - Affiliate Marketing: $225,000
     - **Total Revenue Year 2:** $1,725,000

   - **Year 3:**
     - Pro Tier: 6,000 users _ $30/month _ 12 months = $2,160,000
     - Expert Tier: 6,000 users _ $50/month _ 12 months = $3,600,000
     - Advertising: 2M impressions/month _ $10/CPM _ 12 months = $240,000
     - Affiliate Marketing: $3,000,000
     - **Total Revenue Year 3:** $9,000,000
</file>

<file path="apps/admin-dashboard/content/bp/management-customer-support.md">
#### Customer Support and Service

1. **Support Channels:**

   - Expand support channels to include live chat and social media support. Use a comprehensive
     knowledge base to address common inquiries.

2. **Response Time:**

   - **Email:** 24 working hours
   - **AI:** Immediate response
   - **Human:** Aim for a 1-hour response time in the first 12 months; beyond that, with a scaled
     customer service team, aim for < 5 minute response times.

3. **Support Team:**

   - **Structure:** Support agents, technical specialists, and additional roles as needed. Provide
     continuous training to improve customer service skills.

4. **Service Levels:**
   - Priority support for Pro and Expert users, with different service levels based on subscription
     tiers. Implement a tiered support structure to provide efficient and effective customer
     service.
</file>

<file path="apps/admin-dashboard/content/bp/management-executives.md">
#### Executive Team

1. **Chief Executive Officer (CEO)**

   - Role: Overall strategic direction and leadership of the company.
   - Responsibilities: Vision and mission alignment, stakeholder management, overall company
     performance, key decision-making.

2. **Chief Technology Officer (CTO)**

   - Role: Leading the technology and development teams.
   - Responsibilities: Technology strategy, development oversight, infrastructure management,
     innovation and R&D.

3. **Chief Operations Officer (COO)**

   - Role: Overseeing daily operations and workflow.
   - Responsibilities: Process optimization, operations management, scaling operations,
     cross-departmental coordination.

4. **Chief Marketing Officer (CMO)**

   - Role: Leading marketing and customer acquisition efforts.
   - Responsibilities: Marketing strategy, customer acquisition, brand management, market research.

5. **Chief Financial Officer (CFO)**

   - Role: Managing financial planning and analysis.
   - Responsibilities: Financial strategy, budgeting, accounting, investor relations.

6. **Chief Customer Officer (CCO)**
   - Role: Overseeing customer support and service.
   - Responsibilities: Customer satisfaction, support operations, customer feedback, retention
     strategies.

#### Department Heads and Key Roles

1. **Development Team**

   - **Head of Development (CTO)**
     - **Frontend Developers**
       - Responsibilities: Building and maintaining user interfaces, ensuring responsive design,
         connecting backend data to frontend code, creating responsive features, fixing bugs,
         writing tests.
     - **Backend Developers**
       - Responsibilities: Server-side logic, PostgreSQL database design and optimization,
         connecting server to third-party services (e.g., payment gateways), API development handled
         by Supabase.
     - **DevOps Engineers**
       - Responsibilities: Managing deployments, infrastructure, system reliability, scalability
         using CI/CD pipelines, and Digital Ocean App platform for scraping server.

2. **AI and Data Team**

   - **Head of AI and Data (CTO)**
     - **AI Specialists**
       - Responsibilities: Developing and maintaining AI models, integrating AI features, enhancing
         AI performance based on user feedback.
     - **Data Processors/QA**
       - Responsibilities: Ensuring data quality, processing data for AI models, conducting quality
         assurance, automating data quality checks.

3. **Marketing Team**

   - **Head of Marketing (CMO)**
     - **Content Writers**
       - Responsibilities: Creating and editing articles, blog posts, social media content. Content
         goes through an automation process with AI agents.
     - **Social Media Managers**
       - Responsibilities: Managing social media engagement, posting, and monitoring. Initially
         through platform-specific UI, with potential to adopt third-party software or develop an
         in-house solution.
     - **SEO Specialists**
       - Responsibilities: Keyword optimization, backlink building, content strategy.

4. **Operations Team**

   - **Head of Operations (COO)**
     - **UI/UX Developers**
       - Responsibilities: Designing user interfaces, improving user experience, conducting user
         research, usability testing, and implementing design systems.
     - **Customer Support Agents**
       - Responsibilities: Assisting users with inquiries, troubleshooting issues, using an in-house
         ticketing system.

5. **Sales Team**

   - **Head of Sales (CCO)**
     - **Sales Representatives**
       - Responsibilities: Generating leads, converting prospects, managing customer relationships
         with a focus on customer acquisition. Use a CRM system like HubSpot for managing leads.

6. **Finance Team**
   - **Head of Finance (CFO)**
     - **Accountants**
       - Responsibilities: Financial planning, budgeting, accounting, financial reporting.

#### Advisory Board and Consultants

1. **Advisory Board Members**
   - Responsibilities: Providing strategic guidance, industry insights, and networking
     opportunities.
2. **Consultants**
   - Responsibilities: Offering specialized expertise in areas like technology, marketing, finance,
     and operations.
</file>

<file path="apps/admin-dashboard/content/bp/market-competitors.md">
### Competitive Analysis and Positioning

1. **Competitor Identification:**

   - **Direct Competitors:**

     - Online platforms offering astronomy news, courses, companies, research, events, and community
       interaction.'

     Here is a table with 20 organizations that dominate in the space of online platforms offering
     astronomy news, courses, companies, research, events, and community interaction:

| Company Name                           | Website                     | Industry        | Description                                                                                      |
| -------------------------------------- | --------------------------- | --------------- | ------------------------------------------------------------------------------------------------ |
| Sky & Telescope                        | www.skyandtelescope.com     | Astronomy News  | Leading source of news, observing tips, and celestial event information for amateur astronomers. |
| Slooh                                  | www.slooh.com               | Astronomy       | Provides live, online viewing of celestial objects using robotic telescopes.                     |
| Astronomy.com                          | www.astronomy.com           | Astronomy News  | Offers news, feature articles, and observing tips for astronomy enthusiasts.                     |
| Space.com                              | www.space.com               | Space News      | Comprehensive source for space and astronomy news, and space science topics.                     |
| CosmoQuest                             | www.cosmoquest.org          | Citizen Science | Engages the public in citizen science projects related to space and astronomy.                   |
| Universe Today                         | www.universetoday.com       | Space News      | Provides space and astronomy news, including updates on missions and discoveries.                |
| Coursera                               | www.coursera.org            | Online Courses  | Offers online courses in astronomy and space science from top universities.                      |
| edX                                    | www.edx.org                 | Online Courses  | Provides free online courses in astronomy from universities like Harvard and MIT.                |
| FutureLearn                            | www.futurelearn.com         | Online Courses  | Offers online courses in astronomy and space science from various educational institutions.      |
| International Astronomical Union (IAU) | www.iau.org                 | Research        | Professional organization of astronomers promoting and safeguarding the science of astronomy.    |
| NASA                                   | www.nasa.gov                | Space Agency    | Provides extensive resources on space exploration, missions, and educational content.            |
| European Space Agency (ESA)            | www.esa.int                 | Space Agency    | Offers comprehensive information on European space missions and astronomy research.              |
| American Astronomical Society (AAS)    | www.aas.org                 | Research        | Professional association of astronomers, supporting research and education in astronomy.         |
| AstroBin                               | www.astrobin.com            | Community       | Online platform for sharing astrophotography images and connecting with other astronomers.       |
| Stellarium                             | www.stellarium.org          | Software        | Open-source planetarium software that shows a realistic sky in 3D.                               |
| Astronomy Stack Exchange               | astronomy.stackexchange.com | Community       | Q&A community for astronomers and astronomy enthusiasts to share knowledge and advice.           |
| Zooniverse                             | www.zooniverse.org          | Citizen Science | Platform for citizen science projects, including astronomy and space research.                   |
| SpaceWeather.com                       | www.spaceweather.com        | Space News      | Tracks and reports on solar and space weather events affecting Earth.                            |
| Astrobiology Magazine                  | www.astrobio.net            | Space News      | Provides news and research articles on astrobiology and the search for life beyond Earth.        |
| The Planetary Society                  | www.planetary.org           | Community       | Non-profit organization promoting space exploration and science education.                       |

- **Indirect Competitors:**

  - General science education platforms.
  - AI-driven summarization and news aggregation tools.

  Here is a table with 20 organizations that dominate in the space of general science education
  platforms and AI-driven summarization and news aggregation tools:

| Company Name      | Website                   | Industry                | Description                                                                                       |
| ----------------- | ------------------------- | ----------------------- | ------------------------------------------------------------------------------------------------- |
| Coursera          | www.coursera.org          | Online Courses          | Offers a wide range of science courses from top universities and institutions.                    |
| edX               | www.edx.org               | Online Courses          | Provides online courses in various scientific disciplines from renowned universities.             |
| Khan Academy      | www.khanacademy.org       | Online Education        | Offers free online courses and educational resources across multiple subjects, including science. |
| Udemy             | www.udemy.com             | Online Courses          | Hosts a wide array of courses in science and technology topics.                                   |
| LinkedIn Learning | www.linkedin.com/learning | Professional Education  | Provides online courses, including science and technology training.                               |
| FutureLearn       | www.futurelearn.com       | Online Courses          | Offers science and technology courses from various educational institutions.                      |
| MasterClass       | www.masterclass.com       | Online Education        | Provides courses taught by experts across various fields, including science.                      |
| Brilliant         | www.brilliant.org         | Online Learning         | Focuses on interactive learning in science and mathematics.                                       |
| Skillshare        | www.skillshare.com        | Online Courses          | Offers courses on a wide range of topics, including science and technology.                       |
| Codecademy        | www.codecademy.com        | Online Coding Education | Provides coding education, including data science and programming.                                |
| DeepL             | www.deepl.com             | AI-driven Translation   | AI-powered translation service that can be used for summarizing text in multiple languages.       |
| QuillBot          | www.quillbot.com          | AI-driven Summarization | AI tool for paraphrasing and summarizing text content.                                            |
| Grammarly         | www.grammarly.com         | AI-driven Writing       | AI-powered writing assistant that includes summarization features.                                |
| Feedly            | www.feedly.com            | News Aggregation        | AI-powered news aggregation tool for personalized content.                                        |
| Inoreader         | www.inoreader.com         | News Aggregation        | Aggregates news and content from various sources, offering AI-powered filtering.                  |
| Flipboard         | www.flipboard.com         | News Aggregation        | Curates and summarizes news articles from a variety of sources.                                   |
| Pocket            | www.getpocket.com         | News Aggregation        | Saves and summarizes articles for later reading, with AI-driven recommendations.                  |
| SmartNews         | www.smartnews.com         | News Aggregation        | AI-driven news app that aggregates and curates top news stories.                                  |
| Google News       | news.google.com           | News Aggregation        | Aggregates news from multiple sources, offering personalized content through AI.                  |
| Yahoo News        | www.news.yahoo.com        | News Aggregation        | Aggregates and summarizes news articles from a variety of sources.                                |

### Competitive Landscape:

#### Strengths of Competitors:

- **Established Brand Presence:**
  - Competitors have been in the market for a longer time, allowing them to build a trusted and
    recognizable brand.
- **Comprehensive, Established Content Libraries:**
  - Extensive collections of content built over years, providing a vast resource for users.
  - Variety in content types, including articles, videos, interactive tools, and forums.
- **Strong Community Engagement:**
  - Large and active user communities that foster interaction, knowledge sharing, and user-generated
    content.
  - Regular events, webinars, and community-driven projects that keep users engaged and loyal.

#### Weaknesses of Competitors:

- **Outdated User Interfaces:**
  - Some platforms may have outdated or less intuitive user interfaces, affecting user experience.
- **Limited Use of AI and Automation:**
  - Traditional platforms may not leverage the latest AI and automation technologies for content
    personalization and summarization.
- **Fragmented Services:**
  - Many competitors offer specialized services (e.g., only news, only courses) rather than an
    integrated solution.

## Additional Links

| **Source**                                       | **Description**                                                                                         | **Link**                                                                                |
| ------------------------------------------------ | ------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------- |
| **NASA**                                         | Research, market reports, and industry analysis on space exploration and technology                     | [NASA](https://www.nasa.gov)                                                            |
| **NOAA**                                         | Data on space weather and satellite operations                                                          | [NOAA](https://www.noaa.gov)                                                            |
| **ESA**                                          | Reports and market studies on space missions and technology in Europe                                   | [ESA](https://www.esa.int)                                                              |
| **USGS**                                         | Satellite data and earth observation resources                                                          | [USGS](https://www.usgs.gov)                                                            |
| **Space Foundation**                             | Annual reports on the space economy, industry trends, and forecasts                                     | [Space Foundation](https://www.spacefoundation.org)                                     |
| **AIAA**                                         | Industry analysis, white papers, and technical publications                                             | [AIAA](https://www.aiaa.org)                                                            |
| **Commercial Spaceflight Federation**            | Insights on commercial spaceflight companies                                                            | [Commercial Spaceflight Federation](https://www.commercialspaceflight.org)              |
| **Frost & Sullivan**                             | Market research reports and analysis specific to the space industry                                     | [Frost & Sullivan](https://www.frost.com)                                               |
| **Allied Market Research**                       | Reports on various aspects of the space sector, including satellite services and exploration            | [Allied Market Research](https://www.alliedmarketresearch.com)                          |
| **NSR (Northern Sky Research)**                  | Market research and consulting services focused on the satellite and space sectors                      | [NSR](https://www.nsr.com)                                                              |
| **Bloomberg**                                    | Financial news and data analytics specific to publicly traded companies in the space sector             | [Bloomberg](https://www.bloomberg.com)                                                  |
| **Morningstar**                                  | Investment research and financial data on space-related companies                                       | [Morningstar](https://www.morningstar.com)                                              |
| **Space Capital**                                | Quarterly reports on venture capital investments in the space economy                                   | [Space Capital](https://www.spacecapital.com)                                           |
| **MIT Media Lab's Space Exploration Initiative** | Research and publications on space exploration technologies                                             | [MIT Media Lab](https://www.media.mit.edu/groups/space-exploration-initiative/overview) |
| **Caltechs Jet Propulsion Laboratory (JPL)**    | Research papers and data on space missions and technology                                               | [JPL](https://www.jpl.nasa.gov)                                                         |
| **University Space Research Association (USRA)** | Academic research and industry studies                                                                  | [USRA](https://www.usra.edu)                                                            |
| **ProQuest**                                     | Access to dissertations, theses, and industry reports related to space technology and exploration       | [ProQuest](https://www.proquest.com)                                                    |
| **JSTOR**                                        | Access to academic journals and research studies specific to astronomy and space sciences               | [JSTOR](https://www.jstor.org)                                                          |
| **Library of Congress**                          | Extensive resources, including access to space-related publications and reports                         | [Library of Congress](https://www.loc.gov)                                              |
| **SpaceNews**                                    | News, analysis, and market data on the global space industry                                            | [SpaceNews](https://spacenews.com)                                                      |
| **Aerospace America**                            | Insights into the aerospace and space sectors, including technological advancements and industry trends | [Aerospace America](https://aerospaceamerica.aiaa.org)                                  |
| **The Space Review**                             | In-depth analysis and commentary on space policy, industry developments, and exploration                | [The Space Review](http://www.thespacereview.com)                                       |
</file>

<file path="apps/admin-dashboard/content/bp/market-opportunities.md">
#### Opportunities for AstronEra:

- **AI and Automation Integration:**
  - Leveraging AI for content curation, summarization, and personalization to provide a superior
    user experience.
- **Holistic Platform Offering:**
  - Combining news aggregation, courses, social interaction, job listings, and research tools into
    one integrated platform.
- **Scalable Content Updates:**
  - Using AI agents to automate the process of content updates, ensuring timely and relevant
    information.
- **Market Expansion:**

  - Targeting emerging markets and underrepresented user segments with tailored offerings.

  #### Market Needs and How AstronEra Addresses Them

1. **Market Pain Points:**

   - **Problems:**
     - Lack of a centralized platform for all aspects of astronomy.
     - Need for simplified, streamlined, and auditable research processes.
     - Desire for credible information from a variety of sources.
     - Demand for knowledge communicated at different expertise levels.
     - Requirement for awareness of opportunities like jobs, courses, internships.
     - Need to foster scientific temperament and reduce superstitions.
   - **Significance:** These problems are critical for the future of astronomy and space
     exploration, fostering the next generation of curious minds and bridging the gap between the
     industry and the general population.

2. **Solutions Offered:**
   - **Features:**
     - AI chatbots programmed for specific roles like Physics Tutor, Science Communicator, Astronaut
       Trainer, guide for study and career.
     - Live global summarized news from reliable sources.
     - E-learning courses.
     - Diverse network of people.
     - Access to opportunities and career guidance.
     - Tools to connect startups with investment opportunities.
     - Access to dedicated astronomical audiance for relevant businesses to promote themselves on
       AstronEra.
</file>

<file path="apps/admin-dashboard/content/bp/market-research.md">
### Global Space Sector Market Research Summary

#### Technological Advances

- **Reusable Launch Vehicles**: Significant cost reduction.
- **SmallSats and CubeSats**: Accounted for 95% of spacecraft launched in 2022.
- **Satellite Constellations**: Enable global coverage.

#### Private Sector Investment

- **Investment**: $272 billion since 2013 in 1,791 companies.
- **U.S. National Security Space Budget**: $20.8 billion in FY23, a 19.5% increase.
- **LEO Satellites**: Over 5,000 by end of 2023, potentially 40,000-50,000 by 2030.

#### Demand for Space Data

- **Growth**: Data transfer to exceed 500 exabytes by 2030.
- **Applications**: Military communications, environmental monitoring, emergency response.
- **Technologies**: AI and edge computing.

#### Challenges

- **Supply Chain**: Developing competitive space-grade products.
- **Regulations**: Complex and overlapping from multiple agencies.
- **Environmental**: Space debris, congestion, greenhouse gas emissions.
- **Technical**: High cost of launch, lack of in-space manufacturing infrastructure.

#### Opportunities

- **In-Space Manufacturing**: Utilizes microgravity and vacuum conditions.
- **Additive Manufacturing**: 3D printing to create complex objects.
- **Robotics**: For exploration, maintenance, and assembly.
- **Sustainability**: Active debris removal and end-of-life disposal.

#### Industry Growth

- **Public-Private Collaboration**: Essential for leveraging investments.
- **Emerging Trends**: Expansion of private companies, space data services, in-space manufacturing.
- **Future Business Models**: Higher volume, lower cost, standardized offerings.

#### Key Statistics

- **Rocket Launches**: 186 in 2022, 41 more than in 2021.
- **SmallSats**: 95% of spacecraft launched in 2022.
- **Private Equity Investment**: $272 billion since 2013.
- **U.S. Space Budget**: $20.8 billion in FY23.
- **LEO Satellites**: Over 5,000 by end of 2023.
- **Space Data**: Expected to grow to over 500 exabytes by 2030.
- **Executive Belief**: 98% foresee increased demand for space data and private company expansion.

### Global Space Technology Market

- **Market Size (2023)**: $443.20 billion.
- **Projected Size (2033)**: $916.85 billion.
- **CAGR (2024-2033)**: 7.54%.

#### Key Drivers

- **Technological Advancements**: Reusable rockets, SmallSats, CubeSats.
- **Private Sector Investment**: SpaceX, Blue Origin.
- **Satellite Data Demand**: Navigation, Earth observation.

#### Market Breakdown

- **North America Market Share (2023)**: >55%.
- **Asia Pacific CAGR (2024-2033)**: 9.05%.
- **Space Vehicles Market Share (2023)**: 67%.
- **Commercial Segment Market Share (2023)**: 62%.
- **Navigation & Mapping Segment Market Share (2023)**: 21%.
- **U.S. Market Size (2023)**: $170.63 billion, projected $355.51 billion by 2033.

### Space Exploration Market

- **Market Size (2022)**: $486 billion.
- **Projected Size (2032)**: $1879 billion.
- **CAGR (2022-2032)**: 16.21%.

This Chart showing the projected growth of the space industry from 2023 to 2035 based on three
different annual growth rates (9%, 7.5%, and 16%). The initial value in 2023 is taken as the median
of 440 and 630 billion USD.

## ::financial-chart

title: Projected Global Market Growth chartType: line chartDataKey: globalMarket

---

::

#### Segments & Regions

- **Space Technology**: Largest segment in satellites (34.9%).
- **Mission Type**: Unmanned missions growing significantly.
- **Exploration Type**: Moon exploration (57.2%).
- **End-Use**: Commercial sector (47.8%).
- **Regional Insights**: North America dominates (38.7% share), Asia Pacific fastest growth.

#### Key Players & Factors

- **Key Players**: SpaceX, NASA, Blue Origin, Lockheed Martin, Airbus Defense & Space.
- **Drivers**: Technological advancements, private investment, demand for space data.
- **Challenges**: High costs, space debris management, regulatory complexities.

### Space Economy Growth

- **Projected Growth**: $1.8 trillion by 2035, from $630 billion in 2023, at 9% CAGR.
- **Technological Impact**: Innovations in satellites and rockets.
- **Industry Influence**: Enhances agriculture, disaster mitigation, digital communications.
- **Investment Growth**: Over $70 billion in 2021-2022.

#### Main Drivers

1. **Launch Cost Decrease**: 10-fold reduction over 20 years.
2. **Commercial Innovation**: Smaller, capable satellites.
3. **Diversified Investment**: Significant private investments.
4. **Cultural Awareness**: Increased global interest in space.

#### Metrics & Industry Impact

- **Commercial Communications**: From $133 billion to $218 billion by 2035.
- **PNT**: From $40 billion to $95 billion by 2035.
- **Earth Observation**: From $2 billion to $9 billion by 2035.
- **Supply Chain & Transportation**: Enhanced logistics and tracking.
- **Food & Beverage**: Improved delivery systems.
- **Retail & Consumer Goods**: Satellite-enabled devices.
- **Media & Entertainment**: Satellite internet platforms.
- **State-Sponsored Applications**: National security and research.

#### Global Participation

- **Established Nations**: Increased investments (e.g., India, Japan).
- **Emerging Nations**: New investments (e.g., Saudi Arabia, Thailand).
- **Geopolitical Conflicts**: Space capabilities in modern warfare.

---

### Overview of the Indian Space Market

#### Current Status and Growth Projections

The Indian space sector, currently valued between $8.4 billion in 2023, is experiencing rapid
growth. Driven by significant achievements by the Indian Space Research Organisation (ISRO) and
increasing private sector participation, the market is projected to grow to $44 billion by 2035. Key
drivers include cost-effective satellite launches, international collaborations, and innovative
missions like the Mars Orbiter Mission and upcoming Gaganyaan human spaceflight mission.

#### Key Metrics and Achievements

- **Satellite Launches**: India has successfully launched over 400 foreign satellites, earning $279
  million in revenue.
- **ISRO's Success**: Notable missions include the Mars Orbiter Mission, Chandrayaan-2, and
  PSLV-C37's world record of 104 satellites in a single launch.
- **Private Sector Involvement**: From just one startup in 2012 to 189 in 2023, private investment
  reached $124.7 million in 2023.
- **Policy Initiatives**: The Space Policy 2023 aims to enhance private sector involvement, with the
  creation of IN-SPACe to facilitate and regulate activities.

#### Growth Projections

Projections show the Indian space economy growing at varying annual rates:

- **7.5% YOY Growth**: Reaching approximately $20 billion by 2035.
- **9% YOY Growth**: Reaching approximately $23.6 billion by 2035.
- **16% YOY Growth**: Reaching approximately $49.8 billion by 2035.

## ::financial-chart

title: Projected Indian Market Growth chartType: line chartDataKey: indianMarket

---

::

#### Strategic Focus

- **Satellite Applications**: Expanding into remote sensing, navigation, and Earth observation.
- **Human Spaceflight**: Gaganyaan mission to send Indian astronauts into space.
- **International Collaboration**: Agreements with foreign space agencies and participation in
  global missions.

India's space sector is poised for significant growth, driven by a blend of government support,
technological innovation, and private sector participation. This dynamic ecosystem is expected to
substantially increase India's share of the global space economy by 2035.

**See Appendix for references**
</file>

<file path="apps/admin-dashboard/content/bp/market-size.md">
### Customer Market Size

### Summary of Global Space Sector Workforce (2024) and Projections for 2035

#### Current Workforce (2024):

Based on various sources, the current global space sector workforce in 2024 is estimated to be
between **400,000 to 1 million** employees. This includes roles in government space agencies,
private sector companies, and related industries such as manufacturing, research, and services.

#### Projected Workforce (2035):

By 2035, the global space sector workforce is projected to grow significantly, potentially reaching
between **1.5 million to 2.5 million** employees. This growth is driven by expanding commercial
activities, increased private investment, and government initiatives.

#### Key Factors Influencing Workforce Growth:

| **Key Factor**                           | **Description**                                                                                                      | **Impact on Workforce**                                                                                              |
| ---------------------------------------- | -------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------- |
| **Technological Advances**               | Innovations such as reusable launch vehicles, SmallSats, CubeSats, and satellite constellations.                     | Lower costs and increased demand for technical expertise in manufacturing and operations.                            |
| **Private Sector Investment**            | Significant venture capital and private equity investments driving commercial space ventures.                        | Job creation in startups and established companies focusing on space infrastructure, services, and new applications. |
| **Public-Private Partnerships**          | Collaboration between government agencies and private companies to share costs and risks.                            | Enhanced sustainability and affordability of space missions, leading to steady job growth.                           |
| **Rising Demand for Space Data**         | Increasing use of space data in various sectors including defense, environmental monitoring, and telecommunications. | Growth in jobs related to data analysis, satellite operations, and software development.                             |
| **Space Infrastructure and Services**    | Expansion of satellite communication, Earth observation, and space tourism.                                          | Creation of new jobs in satellite manufacturing, ground services, and customer support.                              |
| **Global Strategic Importance**          | Space activities becoming crucial for national defense, climate monitoring, and connectivity.                        | Increased government spending on space programs, boosting employment in public agencies and defense contractors.     |
| **Educational and Training Initiatives** | Programs to address the skills gap and promote STEM education.                                                       | More qualified professionals entering the space sector, supporting workforce expansion.                              |

#### Key Statistics:

- **U.S. Space Economy (2021)**: 360,000 private industry jobs, significant compensation levels, and
  strong growth in manufacturing and government sectors .
- **Global Space Sector (2023)**: Approximately 400,000 jobs, with projections to reach 1.5 million
  by 2035 due to private investment and new applications .
- **Government Space Agencies**: Employ tens of thousands globally, with significant representation
  in the U.S., Russia, and Europe .

### Conclusion

The global space sector is experiencing robust growth, driven by technological innovations,
increased private investment, and strategic government initiatives. This expansion is expected to
significantly increase the workforce by 2035, creating diverse opportunities across various domains
within the space industry. The collaboration between public and private entities, coupled with
advancements in space technology, will be pivotal in shaping the future job market in this sector.

---

### Researchers

2. **Professional and Educational Sectors:**

   - **Professional Use:** The space sector's professional use includes applications in agriculture,
     construction, insurance, and climate change mitigation. Earth observation satellites provide
     critical data for environmental monitoring, disaster response, and resource management.
   - **Educational Initiatives:** Governments and private entities are increasingly investing in
     space education, recognizing its strategic importance. This is fostering a new generation of
     space professionals and enthusiasts, with programs aimed at students from various educational
     levels.

To estimate the total number of active PhDs in astronomy, we'll use the following steps:

1. **Determine the average length of a professional career.**
2. **Use the annual number of PhDs awarded to calculate the cumulative number of active PhDs.**
3. **Apply the growth rate to account for yearly increases.**

### Data Recap

- **Total degrees awarded in Astronomy & Astrophysics in the US (2022):** 1,396
- **Growth rate in degrees awarded:** 1.53%
- **Average length of a professional career:** Typically around 35-40 years.

### Assumptions

1. **Average career length:** We'll use 37.5 years as the midpoint of the average professional
   career span.
2. **Annual growth:** We'll apply the growth rate annually to account for increases in the number of
   PhDs awarded.

### Calculation Steps

1. **Calculate the cumulative number of active PhDs over 37.5 years.**
2. **Account for the annual growth rate.**

### Step-by-Step Calculation

1. **Cumulative sum without growth:**

\[ \text{Total Active PhDs} = \text{Annual PhDs awarded} \times \text{Average career length} \]

Without accounting for growth:

\[ \text{Total Active PhDs} = 1,396 \times 37.5 = 52,350 \]

2. **Account for growth rate:**

To account for the annual growth rate, we need to sum the geometric series of PhDs awarded over the
career span. The formula for the sum of a geometric series is:

\[ S_n = a \frac{(1 - r^n)}{1 - r} \]

Where:

- \(a\) is the initial number of PhDs awarded annually.
- \(r\) is the growth rate per year.
- \(n\) is the number of years (37.5).

Here, \(a = 1,396\), \(r = 1 + 0.0153 = 1.0153\), and \(n = 37.5\).

\[ S\_{37.5} = 1,396 \frac{(1 - 1.0153^{37.5})}{1 - 1.0153} \]

Calculating the exponent:

\[ 1.0153^{37.5} \approx 1.765 \]

Now, substituting back into the formula:

\[ S\_{37.5} = 1,396 \frac{(1 - 1.765)}{1 - 1.0153} = 1,396 \frac{(-0.765)}{-0.0153} \approx 1,396
\times 50 = 69,800 \]

### Summary

Based on the data provided and assumptions made, the estimated total number of active PhDs in
Astronomy & Astrophysics fields globally, considering an average professional career length of 37.5
years and a growth rate of 1.53%, is approximately **69,800**.
[Estimates based on data from datausa.com](https://datausa.io/profile/cip/astrophysics)

## Amateur Astronomers:

3. **Enthusiast Market:**
   - **Consumer Applications:** The space sector also targets enthusiasts through applications such
     as space tourism, amateur astronomy, and educational content. The decreasing cost of space
     technology is making these activities more accessible to a broader audience.

### Globally

To estimate the global number of amateur astronomers, we can use data from various sources and
extrapolate based on known figures from specific countries. Here's a step-by-step approach to create
an estimation range:

1. **United States Data**:

   - The U.S. has approximately 100,000 active amateur astronomers32source33source.
   - The U.S. population is around 332 million.

2. **Proportion of Amateurs in the U.S.**:

   - Proportion of amateur astronomers in the U.S. = 100,000 / 332,000,000  0.03%.

3. **Extrapolation to Other Developed Countries**:

   - Assuming a similar proportion in other developed countries (e.g., Europe, Japan, Australia):
   - Total population of developed countries (approximate): 1.2 billion.
   - Estimated number of amateur astronomers: 1,200,000,000 \* 0.03% = 360,000.

4. **Adjusting for Global Population**:

   - Global population is approximately 7.8 billion.
   - Developing countries may have lower participation rates due to different socio-economic
     factors. Let's estimate a lower rate (e.g., 0.01%).

5. **Estimations**:
   - Developed countries: 360,000 amateur astronomers.
   - Developing countries: 6.6 billion \* 0.01% = 660,000 amateur astronomers.
   - Total estimated range: 360,000 (developed) + 660,000 (developing) = 1,020,000 amateur
     astronomers globally.

### Estimation Range

Given the variability and uncertainty in participation rates and the broader definitions of what
constitutes an amateur astronomer, it's reasonable to consider a range:

- **Lower Estimate**: 800,000 amateur astronomers globally.
- **Upper Estimate**: 1,500,000 amateur astronomers globally.

### Sources and Considerations:

- **Cloudy Nights Forum Discussions**: Provides anecdotal evidence and estimates based on
  participation in astronomy clubs and societies.
- **Astronomy Clubs and Societies**: Membership numbers can give a snapshot but are often
  underrepresented.
- **Magazine Circulations and Telescope Sales**: Proxy indicators of interest and participation in
  amateur astronomy.

These estimates provide a rough range and should be interpreted with caution due to the diverse and
often informal nature of amateur astronomy communities worldwide.

### India

Based on the global estimation of amateur astronomers, we can use this to estimate the number of
amateur astronomers in India.

### Global Estimation Recap

- **Lower Estimate**: 800,000 amateur astronomers globally.
- **Upper Estimate**: 1,500,000 amateur astronomers globally.

### India's Population Proportion

India accounts for approximately 17.7% of the world's population. We can use this proportion to
estimate the number of amateur astronomers in India.

### Calculation

- **Lower Estimate**:

  - Global estimate: 800,000 amateur astronomers
  - India's share (17.7%): 800,000 \* 0.177  141,600

- **Upper Estimate**:
  - Global estimate: 1,500,000 amateur astronomers
  - India's share (17.7%): 1,500,000 \* 0.177  265,500

### Final Estimation Range for India

Therefore, based on global proportions, the estimated number of amateur astronomers in India would
range from approximately **141,600 to 265,500**.

This estimation provides a reasonable range, considering India's significant population and growing
interest in astronomy, further supported by active astronomy clubs and educational outreach
programs.

## Companies

1. **Commercial Space Sector:**

   - **Private Investment:** The commercial space sector has seen a surge in private investments,
     with entrepreneurs like Elon Musk and Jeff Bezos driving innovation through companies like
     SpaceX and Blue Origin. This influx of capital has led to advancements in reusable rocket
     systems, satellite miniaturization, and autonomous systems, significantly reducing launch costs
     and increasing accessibility.
   - **Satellite Communications:** This segment is expected to grow at a significant CAGR, driven by
     the need for global connectivity, including internet access and data transfer in remote areas.
     Satellite communications support various industries, including telecommunications,
     broadcasting, and disaster communication.

### Market Size and Growth Potential

1. **Market Size:**

   - **Astronomy-related SaaS Products:**
     - The global market for SaaS is projected to grow significantly, with industries like education
       technology seeing a compound annual growth rate (CAGR) of around 20%.
     - The astronomy market although perceived as niche, is expanding rapidly as more institutions,
       professionals, and enthusiasts enter the industry each year. This growth will only increase
       as we see humans return to the Moon, walk on Mars for the first time, events which will
       likely be live streamed to the globe. Not since we went to to the Moon will there be as much
       excitement.
     - Increased demand for reliable, realitime, quality data in this AI world we are moving into.
     - The demoratization of knowledge through AI, and rapidly expanding global connectivity to fast
       reliable internet will bring online the remaining regions of earth, increasing the globally
       accesable market to all of humanity.

2. **Growth Potential:**
   - Factors driving growth include the increasing affordability of telescopes and other astronomy
     equipment, the proliferation of online educational platforms, and the growing interest in STEM
     (science, technology, engineering, and mathematics) education. Advancement in AI, creating
     personalisable tutors in any disipline. Space exploration targets like the Moon, Mars, and
     Asteroids will foster interest.
</file>

<file path="apps/admin-dashboard/content/bp/market-swot.md">
### SWOT Analysis (Example)

1. **Strengths:**

   - Innovative use of AI for summarization and content curation.
   - Comprehensive service offering combining multiple features into one platform.
   - Subscription-based model with tiered pricing, providing flexibility for different user needs.
   - Domain expertise
   - Affordable Access to and Indian talent pool
   - Established Brand and network for growth
   - Focus on automation to reduce manpower needs
   - Unique dataset that enhances the capabilities of LLMs like ChatGPT

2. **Weaknesses:**

   - Limited initial market presence / awareness.
   - No previous experience scaling a company to a global level.
   - Lack of manpower.
   - Lack of experience with largescale software

3. **Opportunities:**

   - Expanding interest in astronomy and space exploration.
   - Growing market for online presence and SaaS solutions.
   - Potential partnerships with educational institutions, research organizations, private
     companies, government organizations, public figures, and expert individuals.
     - **Weaknesses of Competitors:**

- Limited use of AI for personalized content.
- Often focused on a single aspect (e.g., news or courses) rather than an integrated approach.
- Astronomy is often not their primary focus
- Singular domain of expertise, no cross disiplanairy knowledge such as Astronomy, Education,
  Entreprenuership etc.

4. **Threats:**

   - Competitive pressure from established platforms.
   - DDoS attacks and other online security concerns.
   - Rapid technological changes requiring constant innovation.
   - The pace of AI advancements
   - Access to open source data in a world where data is becoming more and more valuable.
   - Regulatory changes affecting data privacy and AI usage.
   - Cost of computation / scaling our systems
   - Security of our network and data
   - **Intense Competition:**

- Strong competition from well-established brands with significant market share.
- **Rapid Technological Changes:**
  - The need to continuously innovate and adapt to new technologies and user expectations.
- **Regulatory and Privacy Concerns:**
  - Compliance with data protection regulations and ensuring user privacy and security.
- **Dependence on External Content Sources:**

  - Reliance on external sources for content, which may affect the consistency and availability of
    information.
</file>

<file path="apps/admin-dashboard/content/bp/market-trends.md">
#### Key Trends and Opportunities

1. **Technological Advancements:**

   - **Reusable Rockets:** Innovations in reusable rocket technology have drastically reduced the
     cost of access to space, enabling more frequent and affordable launches.
   - **Data and AI Integration:** Advances in data processing and AI are enhancing the capabilities
     of Earth observation and navigation applications, driving growth in geospatial analytics and
     other data-intensive sectors.

2. **Economic Impact:**

   - **Diverse Applications:** Space technologies are increasingly being used in non-traditional
     sectors such as retail, consumer goods, and transportation, contributing significantly to the
     space economy's growth.
   - **Cost Reduction:** Ongoing commercial innovations and the decrease in launch costs are making
     space-based services more affordable and accessible, fostering growth across various
     industries.

3. **Current Trends:**

   - **Astronomy Sector:**

     - Increasing public interest in space exploration driven by missions from agencies like NASA
       and private companies like SpaceX.
     - Growth in online astronomy communities and educational content.
     - Advancements in AI and machine learning for data analysis in astronomy.
     - We need specific growth numbers here.

   - **SaaS Sector:**
     - Rapid adoption of cloud-based services across various industries.
     - Rapid growth and improvement of AI.
     - Emphasis on AI and automation through AI agents to enhance and customize a unique user
       experience.
     - Growing acceptance of AI and understanding of it's value.
     - Democratization of skills through AI.
     - Reduction in manpower needs due to automation.
     - Reduction in cost of AI / Cloud based systems.
     - Increasing importance of data security and privacy.
</file>

<file path="apps/admin-dashboard/content/bp/marketing-collaborations.md">
#### Partnerships and Collaborations

1. **Potential Partners:**

   - Influencers
   - Sponsoring local organizations
   - Educational institutions
   - Non-profits
   - Environmentalist organizations

2. **Collaboration Opportunities:**

   - Co-branded content
   - Sponsored advertising
   - Connecting universities to companies for internships

3. **Benefits of Partnerships:**
   - Expanded reach
   - Enhanced credibility
   - Additional resources

---

## Version 2

#### Partnerships and Collaborations

1. **Potential Partners:**

   - Expand potential partner list to include tech companies, online learning platforms, and content
     creators in related fields.

2. **Collaboration Opportunities:**

   - Develop joint ventures with educational institutions to offer exclusive content or
     certifications.
   - Explore co-hosted events and webinars with industry partners to expand reach and authority.

3. **Benefits of Partnerships:**
   - Highlight specific benefits such as shared marketing efforts, increased customer trust, and
     access to new market segments.
</file>

<file path="apps/admin-dashboard/content/bp/marketing-customer-aquisition.md">
#### Customer Acquisition Strategies

- **Astronomy Professionals:** Direct outreach to networks and on linkedin.
- **Students:** Direct outreach through UCLan portal, Shweta is a student there so has direct
  access.
- **Science Communicators/Influencers:** Influence network on Instagram
- **Astronomy Businesses:** Use our database and scraped contacts / social profiles for founders to
  reach out directly.
- **Enthusiasts:** Social media marketing, AstronEra existing email list. Organization
  collaborations, partnerships with companies we have onboarded.

2. **Acquisition Channels:**

   - Social media promotion (Twitter, LinkedIn, Instagram, YouTube)
   - Networks: Conferences, IAU OAD network, RAS network, Dark Sky Network, New Space India Network,
     Linkedin hunt, Institutions websites, UCLan.
   - Influencer marketing
   - Organic traffic via blog
   - Paid social media advertising
   - Our company database
   - Email marketing (list building, converting free users to paying users)
   - Direct contact via social or email using sourced user data from astronomy-related websites

3. **Incentives:**
   - 14-day free trial
   - Offer discount coupons to select people
   - Refer-a-friend program
   - Affilaite prizes for top referrers
   - Limited number of premium users initially

---

## Version 2

#### Customer Acquisition Strategies

1. **Target Segments:**

   - **Astronomy Professionals:** Engage through LinkedIn outreach, industry-specific forums, and
     direct emails.
   - **Students:** Leverage UCLan portal and other educational platforms to promote the product.
   - **Science Communicators/Influencers:** Partner with influencers on Instagram and YouTube to
     reach a broader audience.
   - **Astronomy Businesses:** Utilize existing databases and social profiles for direct outreach.
   - **Enthusiasts:** Implement targeted social media campaigns and collaborate with organizations
     already onboarded.

2. **Acquisition Channels:**

   - Prioritize high-impact channels like LinkedIn, Instagram, YouTube, and direct outreach at
     industry conferences. Maintain a balanced approach between organic and paid traffic.

3. **Incentives:**
   - Enhance incentive programs by adding personalized onboarding sessions, loyalty rewards, and
     limited-time offers to create urgency and exclusivity.
</file>

<file path="apps/admin-dashboard/content/bp/marketing-funnel.md">
#### Sales Funnel and Conversion Strategy

1. **Sales Funnel Stages:**
   - Driving traffic to the landing page
   - Converting visitors to users
   - Upselling through software use and email marketing
   - Notifications and direct messages on the website
2. **Conversion Tactics:**
   - Tracking specific pipelines on the website using events
   - Affiliates
   - Enhanced features to encourage upgrades
   - Popups, content teases (e.g., blurred out premium content)
   - **Retention:**
     - Value offering, gamification, daily quizzes, competitions

---

## Version 2

#### Sales Funnel and Conversion Strategy

1. **Sales Funnel Stages:**

   - Streamline the funnel by focusing on high-impact touchpoints and optimizing the user journey
     with personalized experiences.
   - Utilize data analytics to identify drop-off points and implement strategies to mitigate them.

2. **Conversion Tactics:**

   - Introduce dynamic pricing models based on user behavior and preferences.
   - Enhance the website with interactive elements like quizzes and product demos to engage
     visitors.

3. **Retention:**
   - Develop a loyalty program with tiered rewards to incentivize long-term engagement.
   - Use customer feedback to continuously improve the product and customer experience.
</file>

<file path="apps/admin-dashboard/content/bp/marketing-objectives.md">
#### Marketing Objectives and Goals

1. **Initial User Acquisition:**
   - Primary focus on acquiring initial users through social media, email marketing etc. and
     converting them to paying customers.
2. **Customer Conversion:**
   - Converting free users to paying customers through targeted email marketing and website
     notifications / pop ups / push notifications
3. **Key Performance Indicators (KPIs):**

   - Monthly Active Users (MAU)
   - Customer Churn Rate (CCR)
   - Monthly Recurring Revenue (MRR)
   - Customer Acquisition Cost (CAC)
   - Website Bounce Rate
   - Organic Traffic
   - Paid Traffic
   - Virality Score
   - Backlinks
   - Social Mentions
   - Conversion Rate
   - Average User Engagement
   - Average Session Duration
   - Average Customer Lifetime Value

   ***

   ## Version 2

   #### Marketing Objectives and Goals

4. **Initial User Acquisition:**

   - Focus on acquiring initial users through a mix of social media campaigns, email marketing,
     influencer partnerships, and SEO efforts to drive organic traffic.

5. **Customer Conversion:**

   - Utilize personalized email marketing campaigns, targeted website notifications, pop-ups, and
     push notifications to convert free users into paying customers. Incorporate A/B testing to
     optimize these strategies.

6. **Key Performance Indicators (KPIs):**
   - Simplify the list to focus on the most impactful KPIs: Monthly Active Users (MAU), Customer
     Acquisition Cost (CAC), Customer Lifetime Value (CLV), Conversion Rate, and Monthly Recurring
     Revenue (MRR). This will allow for more focused and actionable insights.
</file>

<file path="apps/admin-dashboard/content/bp/marketing-plan.md">
#### Digital Marketing and SEO Plans

1. **Content Strategy:**

   - Increase the diversity of content types by including webinars, whitepapers, and user-generated
     content.
   - Adjust publishing frequency to ensure quality over quantity, especially for blog posts and
     guest blogs.

2. **SEO Strategy:**

   - Focus on long-tail keywords and create cornerstone content to improve organic search rankings.
     Regularly update older content to keep it relevant.
   - Establish a robust internal linking strategy to improve user experience and SEO performance.

3. **Online Advertising:**
   - Expand advertising to include search engine marketing (SEM) and consider retargeting campaigns
     to re-engage visitors who did not convert initially.
   - Implement a test-and-learn approach to continuously optimize ad spend and targeting.

#### Social Media and Community Engagement

1. **Engagement Strategies:**

   - Incorporate user-generated content to foster a sense of community and authenticity.
   - Use social media analytics to refine and personalize engagement strategies based on user
     behavior and preferences.

2. **Community Building:**
   - Launch a dedicated online community or forum for users to share experiences, ask questions, and
     network.
   - Host regular virtual events, such as webinars and Q&A sessions, to maintain high engagement
     levels.
</file>

<file path="apps/admin-dashboard/content/bp/operations-automation.md">
#### AI Agents for Content Updates and Automation

1. **AI Capabilities:**

   - **Content Curation/Rating/Cleaning:** Automate the process to ensure consistent quality.
   - **Markdown to Structured JSON Conversion:** Streamline data extraction for better usability.
   - **Summarization:** Enhance AI models to improve the accuracy and relevance of summaries.

2. **Automation Processes:**

   - **Content Summarization:** Continuously improve AI models based on user feedback.
   - **Behind-the-Scenes Work:** Implement robust moderation tools to ensure content quality and
     compliance.

3. **Maintenance:**
   - **Quality Control:** Regularly update AI models and perform manual reviews to ensure
     high-quality output.

#### Content Sourcing and Quality Control

1. **Content Sources:**

   - Diversify content sources to include reputable news sites, industry blogs, and academic
     publications. Encourage user-generated content with moderation to maintain quality.

2. **Quality Control:**

   - Implement a multi-layered review process, combining AI checks, manual reviews, and user
     feedback.

3. **Content Updates:**
   - Increase frequency of updates and use AI to identify and prioritize trending topics for content
     creation.
</file>

<file path="apps/admin-dashboard/content/bp/operations-growth-1.md">
#### Phase 1: Enhancements and Immediate Expansions (Year 1)

1. **AI and Content Enhancement:**

   - **AI Model Upgrades:** Continuously improve the accuracy and capabilities of our AI models by
     integrating advanced machine learning techniques and user feedback.
   - **Content Diversification:** Expand the range of content to include more interactive and
     multimedia elements, such as videos, webinars, and interactive simulations.

2. **User Engagement and Retention:**

   - **Gamification:** Introduce gamification elements to enhance user engagement, such as quizzes,
     badges, and leaderboards.
   - **Loyalty Programs:** Implement loyalty programs to reward long-term users and incentivize
     frequent usage.

3. **Platform Optimization:**

   - **Scalability Enhancements:** Optimize our cloud infrastructure to handle increased traffic and
     ensure smooth performance.
   - **User Interface Improvements:** Regularly update the user interface to enhance usability and
     user experience.
   - **Progressive Web App (PWA):** Develop and launch a PWA to provide a seamless mobile experience
     without the need for native app development.

4. **Market Expansion:**

   - **Educational Partnerships:** Partner with educational institutions to provide exclusive
     content and promote our platform among students.
   - **Community Building:** Foster a strong community through forums, social media groups, and
     user-generated content initiatives.

5. **Data Sourcing and Processing:**
   - **Data Quality Improvements:** Focus on sourcing high-quality data, improving data processing,
     and cleaning mechanisms. Implement robust labeling and scoring systems for better data accuracy
     and relevance.
</file>

<file path="apps/admin-dashboard/content/bp/operations-growth-2.md">
#### Phase 2: Advanced Features and Market Penetration (Years 2-3)

1. **Advanced AI Capabilities:**

   - **AI Personalization:** Develop AI-driven personalization features to provide tailored content
     and recommendations based on user behavior and preferences.
   - **Enhanced AI Agents:** Introduce more sophisticated AI agents capable of handling complex
     queries and providing in-depth analysis.

2. **New Revenue Streams:**

   - **Consulting Services:** Offer consulting services to businesses and educational institutions
     leveraging our AI and data insights.
   - **Premium Content:** Expand premium content offerings, such as exclusive webinars, research
     reports, and advanced data insights.

3. **Global Expansion:**
   - **Multilingual Support:** Add support for multiple languages to cater to a global audience.
   - **International Partnerships:** Form partnerships with international space agencies,
     educational institutions, and businesses to expand our reach.
</file>

<file path="apps/admin-dashboard/content/bp/operations-growth-3.md">
#### Phase 3: Innovation and Long-term Growth (Years 4-5)

1. **Cutting-Edge Technology Integration:**

   - **Augmented Reality (AR) and Virtual Reality (VR):** Integrate AR and VR technologies to
     provide immersive learning experiences and interactive content.

2. **User-Generated Content:**

   - **UGC Platform:** Develop a platform for users to create and share their content, fostering
     community engagement and diversifying our content offerings.
   - **Incentive Programs:** Implement incentive programs to encourage high-quality user-generated
     content.

3. **Sustainability and Social Impact:**

   - **Educational Initiatives:** Launch initiatives aimed at promoting space education in
     underprivileged communities, enhancing our social impact.
   - **Sustainability Projects:** Partner with organizations to use space technology for
     sustainability projects, such as climate monitoring and disaster management.

4. **Continuous Improvement:**
   - **Feedback Loops:** Establish continuous feedback loops with users to regularly gather insights
     and improve our services.
   - **Data-Driven Decision Making:** Utilize data analytics to make informed decisions about
     feature rollouts and market strategies.
</file>

<file path="apps/admin-dashboard/content/bp/operations-growth-extra.md">
#### Additional Growth Areas

1. **Dark Sky Certification - C Tier:**

   - **Strategy:** Create content around dark sky certification to build traction. Collaborate with
     Sonam Wangchuk and HIAL to potentially declare villages in Ladakh as dark sky reserves, setting
     up our own criteria for certification.

2. **AstroTribe Training Courses - B Tier:**

   - **Collaboration:** Continue collaborating with HIAL in Ladakh to teach a course on astronomy
     and train astro-guides. Finalize a digital version of the curriculum by 2025 for beta testing,
     with a full launch in 2026, including potential final examinations conducted via Zoom.
   - **Licensing:** License the training to third parties, translating it into multiple languages
     over time to reach a global audience.

3. **Resource Licensing - C Tier:**

   - **Development:** Collate business documents, education templates, and courses for licensing.
     Allow users to create and post their own resources on our platform, taking a commission on each
     sale.

4. **Proposal Vetting/Refining - C Tier:**

   - **Service:** Accept applications with proposals, refine them, and connect with relevant
     agencies or investors for funding. Target startups, non-profits, and research projects,
     facilitating connections with organizations like IAU and private investors.

5. **Integrate Chatbot for Companies - B Tier:**
   - **Integration:** Allow companies to use our data for their website visitors to ask questions,
     providing answers based on our comprehensive data sets, including news, business documents, and
     more.
</file>

<file path="apps/admin-dashboard/content/bp/operations-tech.md">
#### Technology Stack and Infrastructure

1. **Core Technologies:**

   - **Frontend:** Vue 3, Nuxt 3, TypeScript
   - **Backend:** Nitro for Nuxt Server, Dockerized TypeScript Node server for scraping and AI
     agents
   - **Scraping:** Playwright, Cheerio, Node.js
   - **AI:** ChatGPT, OpenAI embeddings, Llama 3 through GroqAPI, OpenAI small-text-embeddings model
   - **Database:** PostgreSQL hosted by Supabase, PG Vector for storing embeddings
   - **Authentication:** Supabase Auth
   - **Storage:** Supabase storage via S3
   - **User Queries:** Supabase edge functions for embedding queries
   - **Future Plans:** Relational Graph Database for scaling RAG system, LlamaParse for PDF to
     Markdown extraction, Python for scaling scraping server and AI agents.

2. **Infrastructure:**

   - **Database/File Storage/Auth:** Supabase
   - **Hosting:** Vercel
   - **Logging and Monitoring:** Logtail
   - **Metrics and Event Capture:** PostHog (already implemented, with plans to expand events and
     pipelines tracked)
   - **Scraping Server:** Digital Ocean App platform

3. **Scalability:**
   - The platform is designed to scale past 1 million users. Infrastructure elements like Supabase,
     Vercel, and Logtail are inherently scalable. Implementing limits to prevent unexpected bills
     due to cyber attacks or massive unexpected virality overnight. In-house scaling for scraping
     and data ingestion will be developed as needed.
</file>

<file path="apps/admin-dashboard/content/bp/operations-workflow.md">
### Business Operations and Workflow

1. **Day-to-Day Operations:**

   - **Content Writing:** Content will go through an automation process where an AI agent takes the
     content title, performs research on target keywords, aggregates top search results, formulates
     a draft post using SEO best practices and company-specific instructions, generates a featured
     image, and publishes it as a draft for review and finishing touches by our content team.
   - **Social Media Management:** Initially managed through platform-specific UI, with the potential
     to adopt third-party software or develop an in-house solution in the future.
   - **Customer Support:** Implement a ticketing system using our own database to track and
     prioritize inquiries.
   - **DevOps:** Automate infrastructure management and deployments using CI/CD pipelines.
   - **Technical Operations:** Use GitHub and GitHub Projects for project management, monitor
     feedback and metrics, and create prioritized tasks for development.
   - **Management:** Schedule regular strategy and performance review meetings to align operations
     with business goals.

2. **Workflow Processes:**

   - **Managing Content:** Implement a content management system (CMS) to streamline content
     creation, approval, and publishing. Include a rich text editor for users to manage content
     easily, changing status from Draft to Published when required.
   - **User Interaction:** Use analytics tools (e.g., PostHog) to track user behavior and feedback.
     Implement user feedback loops for continuous improvement.
   - **Technical Operations:** Use GitHub and GitHub Projects for project management, monitor
     feedback and metrics, and create prioritized tasks for development.

3. **Operational Goals:**
   - Achieve 10k Monthly Active Users (MAU) after 1 year, 50k MAU after 2 years.
   - End-to-end team support.
   - Scale operations by 50% Year Over Year (YOY).
   - Improve user-to-customer conversion rate by 100% from starting metrics.
   - Improve data processing rates and reduce technical and financial costs by 100%.
</file>

<file path="apps/admin-dashboard/content/bp/products-companies.md">
### Company Profiles

1. **Content:**

   - **Included Information:**
     - Founding date
     - Company name
     - Short description
     - Vision
     - Founding team
     - Funding
     - Employee count
     - Job opportunities
     - Events/public engagement
     - Products/services
     - Social media links
     - Industry category
   - **Selection Criteria:**
     - Must be a registered company with a website.
     - Must be in the space/astronomy domain.
     - No defense contractors or political companies.
     - Website review for inclusion.

2. **Features:**
   - **Interactive Features:**
     - News updates from company blogs/newsrooms.
     - Social media content scraping and display (paid feature, free for space agencies).
     - Job listings from company websites/LinkedIn.
     - Event and product scraping if available.

### Company Profiles

Detailed profiles of space and astronomy companies are available on AstronEra, featuring information
such as founding date, company name, vision, team, funding, employee count, job opportunities, and
social media links. Only registered companies in the space/astronomy domain are included, ensuring a
focus on relevant and credible organizations. Interactive features keep users updated on news,
events, and job listings from these companies.
</file>

<file path="apps/admin-dashboard/content/bp/products-courses.md">
### Courses

1. **Course Content:**

   - **Types of Courses:**
     - Hobbyist
     - Academic
     - Prerequisite-based
     - Beginner, intermediate, and advanced levels

2. **Development and Sourcing:**

   - Sourced from universities, experts, and course hosting platforms.
   - AstronEra-generated content.

3. **Learning Experience:**
   - Interactive modules, quizzes, certificates.
   - Varies based on course hosting (online, in-person).

### Courses

The AstronEra platform offers a range of courses for hobbyists, students, and professionals. Courses
are sourced from universities, experts, and course hosting platforms, with some content generated by
AstronEra. The learning experience includes interactive modules, quizzes, and certificates, tailored
to different levels of expertise and learning preferences.
</file>

<file path="apps/admin-dashboard/content/bp/products-jobs.md">
### Jobs Portal

1. **Job Listings:**

   - **Types of Jobs:**
     - Science communication
       - Content writing
       - Graphic designing
     - Engineers/computer science experts
     - Startup opportunities
     - Academic/non-academic positions
     - Citizen science
   - **Sourcing and Updates:**
     - LinkedIn
     - Company websites
     - Future consideration for direct posting

2. **Features:**
   - Bookmarking
   - Displaying most relevant listings
   - Search by location/type/salary

### MVP

- Listing card for each job will have to have displaying the: position / location / published_at /
  link
-

### Jobs Portal

AstronEras dedicated jobs portal lists a variety of opportunities in science communication,
engineering, startups, academia, and citizen science. Sourced from LinkedIn and company websites,
the portal allows users to bookmark listings and search by location, type, and salary, ensuring they
can find the most relevant job opportunities.
</file>

<file path="apps/admin-dashboard/content/bp/products-misc.md">
### Space Policies by Country (start with India)

#### Satellites:

- https://www.heavens-above.com/Satellites.aspx

#### History

- History of space agency by companies http://www.astronautix.com/index.html

#### Astronomy Calendar

- http://www.seasky.org/astronomy/astronomy-calendar-2024.html
</file>

<file path="apps/admin-dashboard/content/bp/products-news.md">
## Basic Product

1. Scrape News from various sources:

- IAU: https://iau.org/news/pressreleases/ & https://iau.org/news/announcements/
- OAD: https://www.astro4dev.org/category/2024/ (change the year for all news)
- OAE: https://www.astro4edu.org/news/ (?page=7 for pagination)
- OAO: Nothing yet, PDFs.
- IUCAA: https://www.iucaa.in/en/about/news (all on one page)
- Space Generation: https://spacegeneration.org/news/page/2 (just 2 pages)
- International Astronomical Federation ASTRO: https://www.iafastro.org/news (?page=2 for
  pagination), website will be good for events and other info in the future, lots of PDFs

#### Agencies

- ISRO: https://www.isro.gov.in/Archives.html (Archive of all press releases, already scraping)
- ESA: news archive from all categories https://www.esa.int/Space_Safety/(archive)/0,
- https://www.spacedaily.com/reports/  
  https://www.esa.int/Science_Exploration/(archive)/0, https://www.esa.int/Applications/(archive)/0,
  https://www.esa.int/Enabling_Support/(archive)/0,
- NASA: https://www.nasa.gov/news/all-news/ (all news from all nasa websites, JPL etc.)
- JAXA: https://global.jaxa.jp/press/2024/
- ROSCOSMOS: https://tass.com/space-programs (not official link, banned in India)
- CSA: https://www.asc-csa.gc.ca/eng/news/articles/
- CNSA: https://www.cnsa.gov.cn/english/n6465652/n6465653/index.html

#### News

- https://ras.ac.uk/news-and-press/latest-news?page=10 (110 articles)
- https://phys.org/space-news/sort/date/all/page2.html (400 articles)
<!--  -->
- https://www.spacefoundation.org/news/page/2/ ??

<!-- working on -->

- Dark Skies.org: https://darksky.org/news/ 670 articles - (page/2/ for pagination, archive of all
  news)
- https://astronomynow.com/category/news/page/2/ (2k articles)
- SETI: https://www.seti.org/news (?page=1 for pagination)

<!-- done -->

- Universe Today: https://www.universetoday.com/ 27k articles (page/2/ for pagination)
- Space.com https://www.space.com 10K + articles (/space-exploration/ for category, archive/2024/06
  for pagination)
- Planetary.org: https://www.planetary.org/articles 6k articles (/p2#list for pagination)
- https://www.astronomy.com/ 12k + (science/stars/page/2/ cat/sub-cat/pagi)
- https://spaceq.ca/category/news 3k (/page/2/ pagination) good for canadian news
- https://earthsky.org/space/ 4.5k (/page/2/ pagi)
- https://skyandtelescope.org/astronomy-news/page/2/ (6k articles)
- https://spacenews.com/section/news-archive/page/2/ (26k articles)
  https://www.kaggle.com/datasets/patrickfleith/space-news-dataset
- https://spaceflightnow.com/category/news-archive/page/2/ (6k articles)
- https://spaceref.com/2023/page/3/ 3k+
- http://www.collectspace.com/news/ (3k articles)

## What will the user see NOW

- **Layout**
  - Ability to quickly switch between categories (or set their preferences)
  - A newsfeed with all the news, filtered by categories
  - Searchbar to search for article
  - Switch between a listview and gridview
- **Card**
  - Category
  - Tags
  - Title
  - Description (or summary of article)
  - Published Date
  - Bookmark
  - NEW if < 24 hours old

## What will user see in future

- **Card**
  - Comments
  - Like / Dislike
  - Share
  - Wordcount / Readtime
  - Credability Score
  - Links to sources (multiple sources)
- **Layout**
  - Summary Newsletter in the left panel
  - Discussions / Activity in the right panel (active comment threads / trending articles)

## Technical Improvements

- Use Dalle 3 to generate images on the fly ($0.080-0.120 USD per image)
- Add article merging for news about the same thing, use K-nearest neighbour, this will be needed to
  show multiple sources for the same article.
-

## Basic Plan

## Pro Plan

## Expert Plan

## Data Storage

## Scraping Requirements

## Our USP
</file>

<file path="apps/admin-dashboard/content/bp/products-personalization.md">
- Users can select categories of interest to customize their newsfeed and summaries.
  - Customized AI agents can answer questions about specific news articles, research papers,
    companies, courses, etc.
</file>

<file path="apps/admin-dashboard/content/bp/products-research.md">
## Sources:

- Indian Academy of Sciences - JOURNAL OF ASTROPHYSICS AND ASTRONOMY
  https://www.ias.ac.in/listing/articles/joaa/045

## Basic Product

- Access all abstracts for scraped papers
- Store them in DB
- Create embeddings for all Research Abstracts, store in new table
- Connect Frontend searchbox to Supabase openai endpoint
- Create as postgres function to join the research table with research_embeddings results.
- Display the results to the user
- enable user interaction with data

## What will the user see NOW

#### General UI

- Search Box
- Have a group of buttons to configure the output. eg. Research, Direct, Summary to determine if the
  search responds with only the related content, or if it feeds it into the LLM for summarization.
- Example searches, to help them get started (clicking on this should send the query)
- Show copy button, downvote etc. (copy what chatGPT has at bottom of message), also allow users to
  star / bookmark messages to save them.
- inline LaTeX converted to equations
- Search History

#### Research Search

- User searches, and gets back N structured responses in a grid or table. No summary.
- Allow users to set their preference for grid / table

#### Direct Search

- Allow Search Filters For:
  - Dates
  - Author
  - Keywords
  - Category
  - DOI

#### Search Result (Direct & Research)

- Paper titles
- Authors (name and link)
- Figure / Page / Table # counts (as tags)
- Abstract (full or summarized)
- Link to PDF document
- Link to Arxiv (potentially)
- Published In (journal etc)
- Category

## Summary Search

- User asks a question
- N related abstracts are returned
- user should be able to configure the LLM base prompt (use presets)
  - You are a science communicator
  - You are a research writer
- The response is displayed in a chat interface
- If flagged the question / N related docs / LLM Response are stored in a table for review.

**consider creating script to extract published in from comment**

## What will user see in future

- PDF fully extracted, show full paper as HTML with LaTeX inline
- Full List of Citations, users can choose Citation Type
- Search can respond with segments of the full paper
- Extracted Keywords are displayed
- Bookmark icon for bookmarking / adding to bookmark group
- Show sources
- Show References to Tools / Institutions / Tables / Figures etc
- Ability to switch between table and grid display
- Share button for search
- Share collections of papers
- add comments under papers
- Button to "Cite"
- Ability to upload and interact with papers

## Technical Improvements

- Save all users searches (this can be used to provide recommendations to the user)
- Save flagged papers to
- Additional sources, other than ARXIV.
- Create AI agent that ranks papers based on a number of factors such as # of citations, author
  credability, published_in etc.
- Allow users to upvote
- Integrate translations API, allow users to translate N articles per month (store translations to
  benefit other users as time goes on)
  - Hire professional translators to review

## Basic Plan

- How many responses per search (can have different tiers)

## Pro Plan

## Expert Plan

## Data Storage

- Message history is temporarily stored, only starred messages are saved.
- Flagged messages are stored for review
- All questions are stored, as they will have to be vectorized, so we can save cost by storing the
  embedding for common questions.
- Storage of 300k PDFs will be approx. 1.2TB, this can be done in supabase for ~$30 a month ($25 per
  1TB)
-

## Scraping Requirements

- We may be able to use the arxiv api to get the latest articles once per day
- if not we will start by scraping the arxiv archive pages once a month or week depending on
  difficulty

## Our USP

- User Preferences (most websites cator to one type of user, researchers mostly)
- Summarization using configurable AI
- Accessablility / Saving Time
- Improved results over time using AI ranking / user feedback
</file>

<file path="apps/admin-dashboard/content/bp/products-search.md">
### AI RAG Search for Scraped Content

1. **Search Functionality:**

   - **How It Works:**
     - Find credible sources of research papers, journals, news, etc.
     - Fetch web pages or PDFs, convert to Markdown, and store in the database.
     - Chunk content into similar-sized pieces, extracting and replacing authors, citations,
       figures, equations, tables, etc.
     - Create embeddings from chunks using OpenAI's small-embeddings API.
     - Free users get 10 related documents; paid users get more, with placeholders converted to
       extracted content.
     - Queries, related documents, references, and responses are stored for quality control.

2. **Types of Content Searchable:**

   - Research papers
   - News (recent and historical for expert plans)
   - Launch updates
   - Conferences
   - Events
   - Companies
   - Funding opportunities
   - Job opportunities
   - Astronomy facts and history
   - Textbooks
   - Social media posts
   - User-generated content, including profiles
   - Tools/software
   - Rocket launches/missions
   - Astronomy figures (researchers, astrophysicists, astronauts)
   - Dark sky reserves/observatories
   - Astrotourism destinations/packages
   - Products and trusted dealers
   - Pop culture references to astronomy
   - Courses/institutions

3. **User Benefits:**
   - Filtered search for relevant content.
   - Attached relevant sources for comprehensive understanding.

### AI RAG Search for Scraped Content

AstronEras advanced search functionality leverages AI to find credible sources of research papers,
journals, news, and more. Content is meticulously scraped, converted to a standardized format, and
indexed for efficient retrieval. This feature provides users with filtered search results and
comprehensive understanding through attached references, enhancing their research and learning
experience.
</file>

<file path="apps/admin-dashboard/content/bp/products-social.md">
### Social Interaction with Content

1. **User Interaction:**

   - **Types of Interactions:**
     - Comments, likes, shares, discussions under articles, research papers, etc.
     - Pro+ users can automatically share posts to linked social profiles.
     - User-generated posts (images, written content, polls, Q&A, videos).
   - **Moderation and Management:**
     - Combination of automated moderation tools and human oversight to ensure quality and
       relevance.

2. **Community Features:**
   - **Community-driven Events/Projects:**
     - Collaborative real-time writing of research papers.
     - User-proposed projects, potentially funded by the community or private investors.
     - Onsite stargazing events.
     - Live webinars with experts.
     - Conferences and fostering company collaboration.
     - Astrotourism and institutional visits to dark sky reserves and observatories.

### Social Interaction with Content

AstronEra users can engage with content through comments, likes, shares, and discussions under
articles and research papers. Pro+ users have the added ability to share posts automatically to
their linked social profiles. The platform supports user-generated posts, including images, written
content, polls, Q&A, and videos, fostering a vibrant and interactive community. A combination of
automated moderation tools and human oversight ensures the quality and relevance of interactions.
</file>

<file path="apps/admin-dashboard/content/bp/products-subscription.md">
### Tiered Subscription Model (Free, Pro, Expert)

1. **Features:**

   - **Free Tier:**
     - Basic news summarization, basic AI questions, limited agents, access to root content.
   - **Pro Tier ($30/month):**
     - Advanced AI questions, enhanced content summarization, premium news, company insights, job
       listings, events, and social media integration.
   - **Expert Tier ($50/month):**
     - Full AI capabilities, extensive AI agents, comprehensive content summarization, advanced
       search capabilities, exclusive webinars, collaborative research tools, advanced data
       insights, personalized content.

2. **User Segmentation:**

   - **Target Users:**
     - **Free Tier:** Hobbyists, casual enthusiasts.
     - **Pro Tier:** Students, intermediate learners, professionals seeking advanced tools.
     - **Expert Tier:** Professionals, researchers, institutions requiring comprehensive tools and
       insights.

3. **Conversion Strategies:**
   - Limited access to functionalities/features for different tiers.
   - Limited access to information for different tiers.
   - Networking abilities for different tiers.
   - Targeted marketing.
   - Free trial periods.

### Tiered Subscription Model

AstronEra offers a tiered subscription model to cater to different user needs:

- **Free Tier:** Basic news summarization, AI questions, and limited agents.
- **Pro Tier ($30/month):** Advanced AI features, premium content, job listings, events, and social
  media integration.
- **Expert Tier ($50/month):** Full AI capabilities, comprehensive content summarization, advanced
  search, exclusive webinars, and collaborative research tools.
</file>

<file path="apps/admin-dashboard/content/bp/products-summaries.md">
### AI-driven Summarization

1. **Functionality:**

   - **How It Works:**
     - Free versions use the best available free algorithm; paid versions use the latest version of
       ChatGPT.
     - Retrieval-augmented search algorithm to retrieve specific context from the user's question.
     - Summarizes content at beginner, intermediate, and expert levels based on the user's
       subscription plan.
     - K-nearest neighbors search algorithm returns related documents based on the user's plan.
     - References within documents are displayed for paid plans to speed up the research process.
     - References are rated/reviewed by users and AI agents, allowing sorting based on helpfulness.

2. **Types of Content Summarized:**

   - News articles
   - Research papers

3. **User Benefits:**
   - Saves time by summarizing large amounts of information.
   - Distills complex concepts for general understanding.
   - Increases content consumption efficiency.
   - Allows bookmarking and saving of necessary information.
   - Provides a unique combination of specific information tailored to the user's level of
     understanding.
   - Converts information into knowledge through user interaction and curated content.

### Summarised Content

The AstronEra platform is a comprehensive online hub designed to democratize access to astronomy
knowledge and resources, empowering users to deepen their understanding of the universe. With a
mission to enhance humanitys grasp of cosmic phenomena, AstronEra offers a seamless user journey
where individuals can sign up, select their interests, and receive personalized newsfeeds,
summaries, and updates. Customized AI agents are available to answer specific queries, and users can
actively participate in community-driven events, discussions, and projects.

### AI-driven Summarization

AstronEra employs cutting-edge AI to summarize vast amounts of information, making complex concepts
accessible at beginner, intermediate, and expert levels. This feature is tailored to save time,
increase content consumption efficiency, and convert information into actionable knowledge. Users
can bookmark and save essential information, with paid plans offering advanced summarization and
document references for enhanced research capabilities.
</file>

<file path="apps/admin-dashboard/content/bp/products-why-us.md">
### Unique Value Proposition and Features

1. **Differentiation:**

   - **Unique Features:**
     - Comprehensive astronomy platform serving diverse user segments.
     - Unique combination of astronomy expertise and AI knowledge.
     - Established brand with significant experience and partnerships in the astronomy industry.
     - One-stop shop for astronomy, accessible to all levels of users.
     - Focus on sustainable development and conservation of the night sky.
   - **Addressing Specific Needs:**
     - Centralized access to all aspects of astronomy.
     - Simplified, streamlined, and auditable research processes.
     - Credible information from diverse sources.
     - Knowledge communicated at different expertise levels.
     - Awareness of opportunities like jobs, courses, internships.
     - Promotion of scientific temperament and reduction of superstitions.

2. **Innovation:**
   - **Technologies/Approaches:**
     - AI Copilot for astronomy tasks.
     - Curated content based on user needs.
     - Comprehensive platform integrating various astronomy-related resources.
   - **Staying Ahead:**
     - Continuous updates with advancing technologies.
     - Hiring fresh talent driven by passion and innovation.
     - Connecting technology and information to everyday life.
</file>

<file path="apps/admin-dashboard/content/bp/risk-customer.md">
6. **Customer Risks:**

   - **User Adoption and Retention:**
     - **Risk:** Difficulty in attracting and retaining users.
     - **Mitigation:** Implement high engagement features and user feedback mechanisms.
     - **Assumption:** High churn rates in the initial stages.
   - **Negative Feedback:**

     - **Risk:** Handling negative feedback or dissatisfaction.
     - **Mitigation:** Proactively engage with users and address issues promptly.
     - **Assumption:** User expectations might not align with the initial offering.

     #### Mitigation Strategies

7. **Customer Risks:**
   - **User Engagement:**
     - Implementing user feedback mechanisms and improving user experience.
   - **Handling Feedback:**
     - Having a dedicated customer support team to address issues.

#### Contingency Plans

6. **Customer Risks:**
   - **Adoption Drops:**
     - Introducing new features and improvements to attract users.
   - **Negative Feedback:**
     - Proactively managing feedback and making necessary changes.
</file>

<file path="apps/admin-dashboard/content/bp/risk-financial.md">
2. **Financial Risks:**

   - **Funding and Cash Flow:**
     - **Risk:** Difficulty in securing initial and ongoing funding.
     - **Mitigation:** Build strong relationships with investors, present a clear and compelling
       business case.
     - **Assumption:** Initial funding rounds might be challenging due to market competition and
       investor skepticism.
   - **Economic Downturns:**
     - **Risk:** Impact of global or regional economic downturns on user subscriptions and
       advertising revenue.
     - **Mitigation:** Diversify revenue streams and maintain a financial buffer.
     - **Assumption:** Economic instability could reduce discretionary spending on subscription
       services.

#### Mitigation Strategies

2. **Financial Risks:**

   - **Securing Funding:**
     - Building a solid business case and engaging with multiple investor channels.
   - **Financial Management:**
     - Implementing strict budget controls and financial monitoring.
     - Regular financial reviews to ensure cash flow stability.

#### Contingency Plans

2. **Financial Risks:**

   - **Backup Funding:**
     - Maintaining relationships with multiple funding sources.
   - **Cost Management:**
     - Reducing non-essential expenses during financial constraints.
</file>

<file path="apps/admin-dashboard/content/bp/risk-market.md">
1. **Market Risks:**

   - **Changes in Market Demand:**
     - **Risk:** Potential changes in public interest in astronomy and space-related content.
     - **Mitigation:** Regularly monitor trends and adjust content strategies accordingly.
     - **Assumption:** The increasing interest in space exploration (e.g., SpaceX, NASA missions)
       will continue to drive demand.
   - **Competition:**
     - **Risk:** High competition from existing platforms offering similar content (e.g., Sky &
       Telescope, Universe Today).
     - **Mitigation:** Differentiate through unique features, advanced AI-driven content, and a
       strong value proposition.
     - **Assumption:** Competitors have established user bases and content libraries.
   - **Emerging Technologies:**
     - **Risk:** New technologies (e.g., advanced AI, alternative content platforms) could disrupt
       the market.
     - **Mitigation:** Stay abreast of technological advancements and incorporate relevant
       innovations.
     - **Assumption:** Continuous advancements in AI and machine learning could create more
       sophisticated content aggregation and summarization tools.

#### Mitigation Strategies

1. **Market Risks:**

   - **Staying Competitive:**
     - Continuous innovation and feature improvements.
     - Regular market research to stay ahead of trends.
   - **Differentiation:**
     - Unique value propositions such as advanced AI-driven features and comprehensive content
       aggregation.

#### Contingency Plans

1. **Market Risks:**

   - **Alternative Strategies:**
     - Diversifying content and services to appeal to a broader audience.
   - **Adaptation:**
     - Quick adaptation to market changes and emerging technologies.
</file>

<file path="apps/admin-dashboard/content/bp/risk-operational.md">
3. **Operational Risks:**

   - **Scaling Operations:**
     - **Risk:** Challenges in scaling the platform to handle a growing user base.
     - **Mitigation:** Use scalable cloud infrastructure and plan for modular architecture.
     - **Assumption:** Infrastructure needs to be robust and scalable from the start.
   - **Platform Reliability:**
     - **Risk:** Ensuring uptime and performance of the platform.
     - **Mitigation:** Implement robust monitoring, alert systems, and redundancy.
     - **Assumption:** Dependence on third-party services (e.g., Supabase, Vercel) could introduce
       risks.
   - **Data Security and Privacy:**
     - **Risk:** Potential data breaches or non-compliance with data protection regulations.
     - **Mitigation:** Adopt industry-standard security practices and conduct regular audits.
     - **Assumption:** Handling sensitive user data and compliance with global regulations.

#### Mitigation Strategies

3. **Operational Risks:**

   - **Scalability:**
     - Using scalable cloud infrastructure and modular architecture.
   - **Reliability:**
     - Implementing robust monitoring and alert systems.
   - **Data Security:**
     - Adopting industry-standard security practices and regular audits.

#### Contingency Plans

3. **Operational Risks:**

   - **Operational Failures:**
     - Having backup systems and disaster recovery plans.
   - **Business Continuity:**
     - Ensuring critical operations can continue during disruptions.
</file>

<file path="apps/admin-dashboard/content/bp/risk-regulatory.md">
5. **Regulatory Risks:**

   - **Compliance:**
     - **Risk:** Navigating global and regional data protection and privacy regulations.
     - **Mitigation:** Regularly review and update compliance policies.
     - **Assumption:** Regulations like GDPR, CCPA, and others will impact operations.
   - **Changes in Regulations:**
     - **Risk:** New regulations could be introduced, requiring changes in operations.
     - **Mitigation:** Build flexibility into operations to quickly adapt.
     - **Assumption:** Regulatory landscape is constantly evolving, necessitating agile responses.

#### Mitigation Strategies

5. **Regulatory Risks:**

   - **Compliance Measures:**
     - Regularly reviewing and updating compliance policies.
   - **Agility:**
     - Building flexibility into operations to quickly adapt to regulatory changes.

#### Contingency Plans

5. **Regulatory Risks:**

   - **Regulatory Changes:**
     - Staying informed about potential changes and preparing accordingly.
   - **Non-compliance:**
     - Immediate action plans to address non-compliance issues.
</file>

<file path="apps/admin-dashboard/content/bp/risk-technical.md">
4. **Technical Risks:**

   - **AI Integration:**
     - **Risk:** Challenges in integrating and maintaining AI technologies.
     - **Mitigation:** Use phased integration of AI features and continuous model updates.
     - **Assumption:** AI models need constant updates and improvements.
   - **Accuracy and Performance:**
     - **Risk:** Ensuring the AI models provide accurate and relevant summaries and answers.
     - **Mitigation:** Continuous training and leveraging user feedback for improvements.
     - **Assumption:** Initial models might have lower accuracy that improves over time with more
       data.

#### Mitigation Strategies

4. **Technical Risks:**

   - **AI Accuracy:**
     - Continuous training and updating of AI models.
   - **Integration:**
     - Phased integration of AI features to manage risks.

#### Contingency Plans

4. **Technical Risks:**

   - **Technical Issues:**
     - Having a dedicated technical support team to address major issues.
   - **Continuous Improvement:**
     - Regular updates and improvements to AI models and infrastructure.
</file>

<file path="apps/admin-dashboard/content/bp/summary-financials.md">
#### Summary of Financial Projections and Funding Requirements

- **Revenue Model:**

  - Free Tier: Access to basic features.
  - Pro Tier ($30/month): Advanced AI features, extra context for AI search, premium content access.
  - Expert Tier ($50/month): Comprehensive AI capabilities, exclusive content, and tools.

- **Financial Projections:**

  - **Year 1:** Revenue - $330,000 | Expenses - $324,010 | Net Profit - $5,990
  - **Year 2:** Revenue - $1,725,000 | Expenses - $595,510 | Net Profit - $1,129,490
  - **Year 3:** Revenue - $9,000,000 | Expenses - $1,573,510 | Net Profit - $7,426,490

- **Funding Requirements:**
  - Estimated funding needs: $300,000 to cover initial costs and provide a buffer for unforeseen
    expenses.
  - **Use of Funds:** Allocation for product development, marketing, operations, and key hires to
    support growth.
</file>

<file path="apps/admin-dashboard/content/bp/summary-market.md">
#### Market Opportunity

The global space economy is projected to reach $1.8 trillion by 2035, driven by advancements in
space-enabled technologies and increasing interest in astronomy. AstronEra is well-positioned to
capture a significant share of this growing market by providing a comprehensive and innovative
platform for astronomy enthusiasts and professionals.

#### Competitive Landscape

Key competitors include platforms like Sky & Telescope and Universe Today. AstronEras competitive
advantage lies in its integrated approach, combining news aggregation, AI-driven tools, and
community engagement in a single platform.
</file>

<file path="apps/admin-dashboard/content/bp/summary-milestones.md">
#### Traction

- Early achievements include partnerships with leading universities and space agencies.
- Positive user testimonials and growing community engagement.
- Successful pilot programs demonstrating the platforms value and effectiveness.

#### Key Highlights and Milestones

- **User Growth:**

  - Year 1: 10k free users, 600 paid users (Pro and Expert 50/50).
  - Year 2: 50k free users, 3,000 paid users.
  - Year 3: 200k free users, 12,000 paid users.

- **Product Development:**

  - Launched initial platform with core features.
  - Continuous enhancement of AI-driven tools and content offerings.
  - Increasing dataset size, so AI has a large pool to draw from.
  - Integration of advanced search capabilities and community features.

- **Market Position:**

  - Established as a comprehensive platform for astronomy content and tools.
  - Differentiated by innovative AI applications and a broad range of services.

- **Operational Excellence:**
  - Scalable infrastructure and robust data security measures.
  - Strong customer support and community engagement strategies.
</file>

<file path="apps/admin-dashboard/content/bp/summary-problem-solution.md">
#### Problem Statement

Many astronomy enthusiasts and professionals face difficulties in accessing consolidated and
high-quality astronomy content, tools, and opportunities. The fragmented nature of current resources
hinders efficient learning, research, and community building.

#### Solution Explanation

AstronEra solves this problem by offering an integrated platform that consolidates news, research,
company profiles, social interactions, and educational resources. Our AI-driven tools enhance
content accessibility and comprehension, providing tailored summaries and advanced search
capabilities to support various user needs.
</file>

<file path="apps/admin-dashboard/content/bp/summary-products.md">
#### Overview of Services and Product Offerings

- **News and Research Aggregation:** Daily updates from scientific journals, research papers, space
  company blogs, news agencies, social media of major space agencies, research institutions, and
  events.
- **Company Profiles:** Detailed profiles of space-related companies including founding date,
  vision, team, funding, job opportunities, events, products, and more.
- **Social Interaction:** Features for commenting, liking, sharing content, and creating user posts,
  with community-driven events like webinars, stargazing, and collaborative research projects.
- **AI-driven Summarization:** Summarization of news articles and research papers, providing
  beginner, intermediate, and expert level summaries.
- **Jobs Portal:** Listings for academic positions, industry roles, startup opportunities, and
  citizen science projects.
- **Courses:** A wide range of courses sourced from universities, experts, and course hosting
  platforms, covering levels from hobbyist to advanced.
- **Custom AI Search:** Advanced search capabilities leveraging AI to retrieve and summarize content
  from our dataset to enhance research and learning.
</file>

<file path="apps/admin-dashboard/content/bp/summary-usp.md">
#### Unique Selling Proposition (USP)

AstronEra differentiates itself through its innovative use of AI for content summarization and
search, a comprehensive range of services, and a focus on community building. Our platform combines
expert curation with cutting-edge technology to deliver unparalleled value to users.
</file>

<file path="apps/admin-dashboard/content/bp/summary-vision.md">
#### Vision and Mission Statement

**Vision:** To accelerate sustainable development through astronomy via our premier global platform,
and to foster a deeper understanding and appreciation of the universe, and dark skies.

**Mission:** To aggregate and curate high-quality astronomy content, provide innovative AI-driven
tools, and build a vibrant community that connects users with the latest developments,
opportunities, and resources in the field of astronomy.
</file>

<file path="apps/admin-dashboard/financials/analytics.ts">
import { USD2INR } from './helpers'

export interface AnalyticsResult {
  total: number
  events: {
    usage: number
    cost: number
  }
  recordings: {
    usage: number
    cost: number
  }
  featureRequests: {
    usage: number
    cost: number
  }
  surveyResponses: {
    usage: number
    cost: number
  }
}

function calculateTieredCost(quantity: number, tiers: { limit: number, price: number }[]) {
  let cost = 0
  let remainingQuantity = quantity

  for (const tier of tiers) {
    const applicableQuantity = Math.min(remainingQuantity, tier.limit)
    cost += applicableQuantity * tier.price
    remainingQuantity -= applicableQuantity
    if (remainingQuantity <= 0) break
  }

  return cost
}

const POSTHOG_ANALYTICS_TIERS = [
  { limit: 1000000, price: 0 },
  { limit: 1000000, price: 0.00005 },
  { limit: 13000000, price: 0.0000343 },
  { limit: 35000000, price: 0.0000295 },
  { limit: 50000000, price: 0.0000218 },
  { limit: 150000000, price: 0.000015 },
  { limit: Infinity, price: 0.000009 },
]

function calculateProductAnalyticsCost(events: number) {
  return calculateTieredCost(events, POSTHOG_ANALYTICS_TIERS)
}

const POSTHOG_REPLAY_TIERS = [
  { limit: 5000, price: 0 },
  { limit: 10000, price: 0.04 },
  { limit: 35000, price: 0.003 },
  { limit: 100000, price: 0.0027 },
  { limit: 350000, price: 0.0025 },
  { limit: Infinity, price: 0.002 },
]

function calculateSessionReplayCost(recordings: number) {
  return calculateTieredCost(recordings, POSTHOG_REPLAY_TIERS)
}

const POSTHOG_FEAT_FLAG_TIERS = [
  { limit: 1000000, price: 0 },
  { limit: 1000000, price: 0.0001 },
  { limit: 8000000, price: 0.000045 },
  { limit: 40000000, price: 0.000025 },
  { limit: Infinity, price: 0.00001 },
]

function calculateFeatureFlagsCost(requests: number) {
  return calculateTieredCost(requests, POSTHOG_FEAT_FLAG_TIERS)
}

const POSTHOG_SURVEY_TIERS = [
  { limit: 250, price: 0 },
  { limit: 250, price: 0.2 },
  { limit: 500, price: 0.1 },
  { limit: 9000, price: 0.035 },
  { limit: 10000, price: 0.015 },
  { limit: Infinity, price: 0.01 },
]

function calculateSurveysCost(responses: number) {
  return calculateTieredCost(responses, POSTHOG_SURVEY_TIERS)
}

export function calculateAnalyticsCost({
  MAU,
  month,
  avgMauUsage,
}: UsageEstimationParams): AnalyticsResult {
  const { events, recordings, featureRequests, surveyResponses } = estimateUsage({
    MAU,
    month,
    avgMauUsage,
  })

  const eventsCost = calculateProductAnalyticsCost(events)
  const recordingsCost = calculateSessionReplayCost(recordings)
  const featureRequestsCost = calculateFeatureFlagsCost(featureRequests)
  const surveysCost = calculateSurveysCost(surveyResponses)

  console.log(
    'Calculate Analytics Cost:',
    MAU,
    eventsCost,
    recordingsCost,
    featureRequestsCost,
    surveysCost,
  )

  const totalCost = eventsCost + recordingsCost + featureRequestsCost + surveysCost
  console.log(
    'Calculate Analytics Cost:',
    MAU,
    eventsCost,
    recordingsCost,
    featureRequestsCost,
    surveysCost,
    totalCost,
    USD2INR(totalCost),
  )

  return {
    total: USD2INR(totalCost),
    events: {
      cost: USD2INR(eventsCost),
      usage: events,
    },
    recordings: {
      cost: USD2INR(recordingsCost),
      usage: recordings,
    },
    featureRequests: {
      cost: USD2INR(featureRequestsCost),
      usage: featureRequests,
    },
    surveyResponses: {
      cost: USD2INR(surveysCost),
      usage: surveyResponses,
    },
  }
}

type UsageEstimationParams = {
  MAU: number
  month: number
  avgMauUsage: number
}

const FREE_TIER_MONTHS = 4

function estimateUsage({ MAU, month, avgMauUsage }: UsageEstimationParams): EstimatedUsage {
  const isFreeTier = month < FREE_TIER_MONTHS
  const scaleFactor = isFreeTier ? 0.1 : 1

  const events = Math.min(MAU * avgMauUsage * scaleFactor, 1000000 * (month + 1)) || 0
  const recordings = Math.min(MAU * 0.1 * scaleFactor, 5000 * (month + 1)) || 0
  const featureRequests = Math.min(MAU * 0.05 * scaleFactor, 100000 * (month + 1)) || 0
  const surveyResponses = Math.min(MAU * 0.08 * scaleFactor, 1000 * (month + 1)) || 0

  console.log('Estimate Usage:', MAU, events, recordings, featureRequests, surveyResponses)
  return {
    total: Math.round(events + recordings + featureRequests + surveyResponses),
    events: Math.round(events),
    recordings: Math.round(recordings),
    featureRequests: Math.round(featureRequests),
    surveyResponses: Math.round(surveyResponses),
  }
}

type EstimatedUsage = {
  total: number
  events: number
  recordings: number
  featureRequests: number
  surveyResponses: number
}
</file>

<file path="apps/admin-dashboard/financials/capital.ts">
import { ROUND0 } from './helpers'

interface InitialLoanParams {
  loan: number
  annualInterestRate: number
  termInYears: number
}

export interface LoanResult {
  principal: number
  termInYears: number
  annualInterestRate: number
  monthlyInterestOnlyPayment: number
  monthlyTotalPayment: number
  monthlyPrincipalPayment: number
}

export function calculateInitialLoan({
  loan,
  annualInterestRate,
  termInYears,
}: InitialLoanParams): LoanResult {
  const interestRateDecimal = annualInterestRate > 1 ? annualInterestRate / 100 : annualInterestRate

  // Convert annual interest rate to monthly rate
  const monthlyInterestRate = interestRateDecimal / 12

  // Convert loan term from years to months
  const numberOfPayments = termInYears * 12

  // Calculate monthly interest-only payment
  const monthlyInterestOnlyPayment = loan * monthlyInterestRate

  // Calculate total monthly payment using the loan amortization formula
  const monthlyTotalPayment
    = (loan * (monthlyInterestRate * Math.pow(1 + monthlyInterestRate, numberOfPayments)))
    / (Math.pow(1 + monthlyInterestRate, numberOfPayments) - 1)

  // Calculate the principal payment
  const monthlyPrincipalPayment = monthlyTotalPayment - monthlyInterestOnlyPayment

  return {
    principal: loan,
    termInYears,
    annualInterestRate,
    monthlyInterestOnlyPayment: Math.round(monthlyInterestOnlyPayment * 100) / 100,
    monthlyTotalPayment: Math.round(monthlyTotalPayment * 100) / 100,
    monthlyPrincipalPayment: Math.round(monthlyPrincipalPayment * 100) / 100,
  }
}

function calculateBurnRate(totalExpenses: number, MRR: number) {
  return ROUND0(totalExpenses - MRR)
}

function calculateRunway(currentBalance: number, burnRate: number): number {
  if (burnRate === 0) {
    return Infinity // or a large number to indicate no burn
  }
  return parseInt((currentBalance / Math.abs(burnRate)).toFixed(0))
}

export interface CapitalResult {
  loan: LoanResult
  runway: number
  burnRate: number
  balance: {
    start: number
    end: number
  }
}

interface LoanRepaymentParams {
  month: number
  loan: {
    AMOUNT: number
    ANNUAL_INTEREST_RATE: number
    TERM_IN_YEARS: number
  }
  expenses: number
  income: number
  bootstrapMonths: number
  initialCapital: number
}

let balanceRemaining = 0
let loanStarted = {
  principal: 0,
  termInYears: 0,
  annualInterestRate: 0,
  monthlyInterestOnlyPayment: 0,
  monthlyTotalPayment: 0,
  monthlyPrincipalPayment: 0,
}

export function calculateRemainingBalance({
  month,
  expenses,
  income,
  bootstrapMonths,
  initialCapital,
  loan,
}: LoanRepaymentParams): CapitalResult {
  if (month === 1) {
    balanceRemaining = initialCapital
  }

  if (month === bootstrapMonths) {
    balanceRemaining += loan.AMOUNT
    loanStarted = calculateInitialLoan({
      loan: loan.AMOUNT,
      annualInterestRate: loan.ANNUAL_INTEREST_RATE,
      termInYears: loan.TERM_IN_YEARS,
    })
  }

  const burnRate = calculateBurnRate(expenses, income)
  balanceRemaining -= burnRate

  const adjustedBurn = burnRate < 0 ? 0 : burnRate
  const runway = calculateRunway(balanceRemaining, adjustedBurn)

  return {
    loan: loanStarted,
    runway,
    burnRate,
    balance: {
      start: balanceRemaining + burnRate,
      end: balanceRemaining,
    },
  }
}
</file>

<file path="apps/admin-dashboard/financials/customers.ts">
import { USD2INR, ROUND0, EFFICIENCY_FACTOR } from './helpers'
import { metricConfig } from './totals'

export const INCOME_STREAMS = {
  subscription: {
    pro: {
      price: 20, // USD
      conversion: {
        current: 0,
        pessimistic: 0.018,
        optimistic: 0.05,
      },
      refund: {
        yearly: {
          pessimistic: 0.12, // Yearly refund rate
          optimistic: 0.06,
        },
      },
    },
    expert: {
      price: 50, // USD
      conversion: {
        current: 0,
        pessimistic: 0.005,
        optimistic: 0.025,
      },
      refund: {
        yearly: {
          pessimistic: 0.12, // Yearly refund rate
          optimistic: 0.06,
        },
      },
    },
  },
  advertising: 0.04, // USD per MAU
  promotion: 0.03, // USD per MAU
  affiliate: 0.02, // USD per MAU
}

function adjustConversionRates(MAU: number) {
  const { subscription } = INCOME_STREAMS
  subscription.pro.conversion.current = Math.min(
    subscription.pro.conversion.pessimistic
    + (MAU / 150000)
    * (subscription.pro.conversion.optimistic - subscription.pro.conversion.pessimistic),
    subscription.pro.conversion.optimistic,
  )

  subscription.expert.conversion.current
    = MAU >= 5000
      ? Math.min(
        subscription.expert.conversion.pessimistic
        + (MAU / 100000)
        * (subscription.expert.conversion.optimistic
          - subscription.expert.conversion.pessimistic),
        subscription.expert.conversion.optimistic,
      )
      : 0
}

function newMauToCustomers(MAU: number) {
  const { subscription } = INCOME_STREAMS
  let proCustomers = ROUND0(MAU * subscription.pro.conversion.current)
  const expertFromMau = ROUND0(MAU * subscription.expert.conversion.current) // Small percentage directly from MAU
  const proUpgrades = ROUND0(proCustomers * subscription.expert.conversion.current) // Small percentage from Pro users upgrading
  const expertCustomers = expertFromMau + proUpgrades
  proCustomers = proCustomers - proUpgrades
  return { proCustomers, expertCustomers }
}

function subscriptionRevenueFromCustomers(proCustomers: number, expertCustomers: number) {
  const { subscription } = INCOME_STREAMS
  const proRevenue = proCustomers * subscription.pro.price
  const expertRevenue = expertCustomers * subscription.expert.price
  return { proRevenue, expertRevenue }
}

function calculateAdditionalRevenue(users: { free: number, pro: number, expert: number }) {
  const totalUsers = users.free + users.pro + users.expert
  return {
    advertisingRevenue: {
      total: totalUsers * INCOME_STREAMS.advertising,
      free: users.free * INCOME_STREAMS.advertising,
      pro: users.pro * INCOME_STREAMS.advertising,
      expert: users.expert * INCOME_STREAMS.advertising,
    },
    affiliateRevenue: {
      total: totalUsers * INCOME_STREAMS.affiliate,
      free: users.free * INCOME_STREAMS.affiliate,
      pro: users.pro * INCOME_STREAMS.affiliate,
      expert: users.expert * INCOME_STREAMS.affiliate,
    },
    promotionRevenue: {
      total: totalUsers * INCOME_STREAMS.promotion,
      free: users.free * INCOME_STREAMS.promotion,
      pro: users.pro * INCOME_STREAMS.promotion,
      expert: users.expert * INCOME_STREAMS.promotion,
    },
  }
}

interface RevenueParams {
  mau: {
    total: number
    new: number
  }
  customers: {
    pro: number
    expert: number
  }
}

export function calculateRevenue({ mau, customers }: RevenueParams): RevenueResult {
  adjustConversionRates(mau.total)
  const { subscription } = INCOME_STREAMS

  const { proCustomers, expertCustomers } = newMauToCustomers(mau.new)

  const totalPro = proCustomers + customers.pro
  const totalExpert = expertCustomers + customers.expert

  const { proRevenue, expertRevenue } = subscriptionRevenueFromCustomers(totalPro, totalExpert)

  const { advertisingRevenue, affiliateRevenue, promotionRevenue } = calculateAdditionalRevenue({
    free: mau.total - totalPro - totalExpert,
    pro: totalPro,
    expert: totalExpert,
  })

  const proExtraRevenue = affiliateRevenue.pro + promotionRevenue.pro + advertisingRevenue.pro
  const expertExtraRevenue
    = affiliateRevenue.expert + promotionRevenue.expert + advertisingRevenue.expert
  const freeExtraRevenue = affiliateRevenue.free + promotionRevenue.free + advertisingRevenue.free

  const proTotalRevenue = proRevenue + proExtraRevenue
  const expertTotalRevenue = expertRevenue + expertExtraRevenue
  const totalAdditionalRevenue
    = advertisingRevenue.total + affiliateRevenue.total + promotionRevenue.total
  const totalRevenue = proRevenue + expertRevenue + totalAdditionalRevenue

  return {
    total: {
      revenue: USD2INR(totalRevenue),
      free: USD2INR(freeExtraRevenue),
      pro: USD2INR(proTotalRevenue),
      expert: USD2INR(expertTotalRevenue),
      advertising: USD2INR(advertisingRevenue.total),
      affiliate: USD2INR(affiliateRevenue.total),
      promotion: USD2INR(promotionRevenue.total),
    },
    customers: {
      free: {
        revenue: USD2INR(freeExtraRevenue),
        advertising: USD2INR(advertisingRevenue.free),
        affiliate: USD2INR(affiliateRevenue.free),
        promotion: USD2INR(promotionRevenue.free),
      },
      pro: {
        count: totalPro,
        new: proCustomers,
        revenue: USD2INR(proRevenue),
        price: subscription.pro.price,
        conversion: parseFloat((subscription.pro.conversion.current * 100).toFixed(2)),
        affiliate: USD2INR(affiliateRevenue.pro),
        advertising: USD2INR(advertisingRevenue.pro),
        promotion: USD2INR(promotionRevenue.pro),
      },
      expert: {
        count: totalExpert,
        new: expertCustomers,
        revenue: USD2INR(expertRevenue),
        price: subscription.expert.price,
        conversion: parseFloat((subscription.expert.conversion.current * 100).toFixed(2)),
        advertising: USD2INR(advertisingRevenue.expert),
        affiliate: USD2INR(affiliateRevenue.expert),
        promotion: USD2INR(promotionRevenue.expert),
      },
    },
  }
}

export interface RevenueResult {
  total: {
    revenue: number
    free: number
    pro: number
    expert: number
    advertising: number
    affiliate: number
    promotion: number
  }
  customers: {
    free: {
      revenue: number
      advertising: number
      affiliate: number
      promotion: number
    }
    pro: {
      count: number
      new: number
      revenue: number
      price: number
      conversion: number
      advertising: number
      affiliate: number
      promotion: number
    }
    expert: {
      count: number
      new: number
      revenue: number
      price: number
      conversion: number
      advertising: number
      affiliate: number
      promotion: number
    }
  }
}
</file>

<file path="apps/admin-dashboard/financials/dev-ops.ts">
import { USD2INR, ROUND2 } from './helpers'
import { metricConfig } from './totals'

const DEVOPS = {
  HOURS_PER_MONTH: 730, // 24 hours * 30 days
  AWS_EC2_COST_PER_HOUR: 0.24, // $0.24 per hour per instance
  AWS_S3_COST_PER_GB: 0.021, // $0.021 per GB
  AWS_DATA_TRANSFER_COST_PER_GB: 0.07, // $0.07 per GB
  EKS_CLUSTER_COST_PER_HOUR: 0.2, // $0.20 per hour for EKS cluster
  PROMETHEUS_GRAFANA_COST_PER_MONTH: 7000, // $7,000 per month
  CLOUD_FLARE_COST_PER_GB: 0.015, // $0.015 per GB
}

function calculateEC2Cost(mau: number): number {
  const instancesNeeded = Math.ceil(mau / 5000) // More instances for redundancy
  return instancesNeeded * DEVOPS.AWS_EC2_COST_PER_HOUR * DEVOPS.HOURS_PER_MONTH
}

function calculateS3Cost(storageGB: number): number {
  return storageGB * DEVOPS.AWS_S3_COST_PER_GB
}

function calculateDataTransferCost(dataTransferGB: number): number {
  return dataTransferGB * DEVOPS.AWS_DATA_TRANSFER_COST_PER_GB
}

function calculateEKSCost(mau: number): number {
  const clustersNeeded = Math.ceil(mau / 25000) // More clusters for redundancy
  return clustersNeeded * DEVOPS.EKS_CLUSTER_COST_PER_HOUR * DEVOPS.HOURS_PER_MONTH
}

function calculateCloudflareCDNCost(dataTransferGB: number): number {
  return dataTransferGB * DEVOPS.CLOUD_FLARE_COST_PER_GB
}

interface DevopsInhouseResult {
  total: number
  efficiencyFactor: number
  ec2Cost: number
  s3Cost: number
  dataTransferCost: number
  eksCost: number
  prometheusGrafanaCost: number
  cloudflareCost: number
}

function calculateInHouseCosts(
  mau: number,
  storageGB: number,
  dataTransferGB: number,
): DevopsInhouseResult {
  const efficiencyFactor = calculateEfficiencyFactor(mau)

  const ec2Cost = calculateEC2Cost(mau)
  const s3Cost = calculateS3Cost(storageGB)
  const dataTransferCost = calculateDataTransferCost(dataTransferGB)
  const eksCost = calculateEKSCost(mau)
  const prometheusGrafanaCost = DEVOPS.PROMETHEUS_GRAFANA_COST_PER_MONTH
  const cloudflareCost = calculateCloudflareCDNCost(dataTransferGB)

  const total
    = ec2Cost
    + s3Cost
    + dataTransferCost
    + eksCost
    + prometheusGrafanaCost
    + cloudflareCost * efficiencyFactor

  return {
    total: USD2INR(total),
    efficiencyFactor: ROUND2(efficiencyFactor),
    ec2Cost: USD2INR(ec2Cost * efficiencyFactor),
    s3Cost: USD2INR(s3Cost * efficiencyFactor),
    dataTransferCost: USD2INR(dataTransferCost * efficiencyFactor),
    eksCost: USD2INR(eksCost * efficiencyFactor),
    prometheusGrafanaCost: USD2INR(prometheusGrafanaCost * efficiencyFactor),
    cloudflareCost: USD2INR(cloudflareCost * efficiencyFactor),
  }
}

// extract to main file
function calculateUsageByMAU(mau: number) {
  const avgUserMonthlyHours = calculateDailyUsagePerUser(mau) // Use the previously defined function
  const dataTransferGB = usageByHour.dataTransferGB * avgUserMonthlyHours * mau
  const storageGB = 0.1 * mau // Assume 100 MB per user
  return { avgUserMonthlyHours, dataTransferGB, storageGB }
}

// Last Updated 6th July 2024
export const vercelConfig = {
  basePrice: 20,
  dataTransfer: {
    includedGB: 1000, // 1 TB
    pricePerGB: 0.15,
  },
  originTransfer: {
    includedGB: 100,
    pricePerGB: 0.06,
  },
  edgeRequests: {
    includedRequests: 10_000_000,
    pricePerMillion: 2,
  },
  middlewareInvocations: {
    includedInvocations: 1_000_000,
    pricePerMillion: 0.65,
  },
  sourceImages: {
    includedImages: 5000,
    pricePerThousand: 5,
  },
  functionInvocations: {
    includedInvocations: 1_000_000,
    pricePerMillion: 0.6,
  },
  functionDuration: {
    includedGBHours: 1000,
    pricePerGBHour: 0.18,
  },
  edgeFunctionExecutions: {
    includedExecutions: 1_000_000,
    pricePerMillion: 2,
  },
  dataCacheReads: {
    includedReads: 10_000_000,
    pricePerMillion: 0.4,
  },
  dataCacheWrites: {
    includedWrites: 2_000_000,
    pricePerMillion: 4,
  },
  edgeConfigReads: {
    includedReads: 1_000_000,
    pricePerMillion: 3,
  },
  edgeConfigWrites: {
    includedWrites: 1000,
    pricePer500Writes: 5,
  },
  monitoring: {
    baseFee: 10,
    pricePerMillionEvents: 9,
  },
  speedInsights: {
    includedDataPoints: 10_000,
    pricePer10kEvents: 0.65,
  },
  webAnalytics: {
    includedEvents: 25_000,
    pricePer100kEvents: 14,
  },
}

/**
 * Calculate the cost for serverless function executions.
 *
 * @param {number} memoryInMB - The memory allocated to the function in MB.
 * @param {number} invocations - Number of times the function is invoked.
 * @param {number} durationInSeconds - Duration of each invocation in seconds.
 * @param {number} pricePerGBHour - Cost per GB-hour as specified by the provider.
 * @returns {number} - The cost of executions in USD.
 */
function calculateFunctionCost(
  memoryInMB: number,
  invocations: number,
  durationInSeconds: number,
  pricePerGBHour: number,
): number {
  // Convert memory from MB to GB
  const memoryInGB = memoryInMB / 1024

  // Calculate total seconds of execution
  const totalSeconds = invocations * durationInSeconds

  // Convert total execution time to GB-seconds
  const totalGBSeconds = memoryInGB * totalSeconds

  // Convert GB-seconds to GB-hours
  const totalGBHours = totalGBSeconds / 3600

  // Calculate the cost
  const cost = totalGBHours * pricePerGBHour

  return cost
}

const usageByHour = {
  dataTransferGB: 0.015, // 15 MB per hour per user
  originTransferGB: 0.001, // 1 MB per hour per user
  edgeRequests: 150, // 150 requests per hour per user
  middlewareInvocations: 75, // 75 middleware invocations per hour per user
  sourceImages: 0, // Assume no usage, handled by supabase
  functionInvocations: 75, // 75 function invocations per hour per user
  functionDurationGBHours: 0.025596, // Assuming 360 calls/hour of a 256MB Ram Function (1 every 10 seconds per user)
  edgeFunctionExecutions: 75, // 75 edge function executions per hour per user
  dataCacheReads: 800, // Adjusted to 800 data cache reads per hour per user
  dataCacheWrites: 75, // 75 data cache writes per hour per user
  edgeConfigReads: 50, // Adjusted to 50 edge config reads per hour per user
  edgeConfigWrites: 0.1, // Adjusted to 0.1 edge config writes per hour per user
  monitoringEvents: 0, // Use posthog instead
  speedInsightsDataPoints: 0, // Not using
  webAnalyticsEvents: 0, // Not using
}

type VercelUsageParams = {
  efficiencyFactor: number
  avgUserMonthlyHours: number
  dataTransferGB: number
  originTransferGB: number
  edgeRequests: number
  middlewareInvocations: number
  sourceImages: number
  functionInvocations: number
  functionDurationGBHours: number
  edgeFunctionExecutions: number
  dataCacheReads: number
  dataCacheWrites: number
  edgeConfigReads: number
  edgeConfigWrites: number
  monitoringEvents: number
  speedInsightsDataPoints: number
  webAnalyticsEvents: number
}

interface VercelResult {
  total: number
  efficiencyFactor: number
  avgUserMonthlyHours: number
  breakdown: {
    base: number
    dataTransfer: number
    originTransfer: number
    edgeRequests: number
    middlewareInvocations: number
    sourceImages: number
    functionInvocations: number
    functionDuration: number
    edgeFunctionExecutions: number
    dataCacheReads: number
    dataCacheWrites: number
    edgeConfigReads: number
    edgeConfigWrites: number
    monitoring: number
    speedInsights: number
    webAnalytics: number
  }
}

function calculateEfficiencyFactor(mau: number) {
  const baseMAU = 1000
  const logBase10 = Math.log(10)
  const efficiencyLog = Math.log(mau / baseMAU) / logBase10
  const efficiencyFactor = 1 - 0.1 * efficiencyLog // Adjust 0.1 to fine-tune efficiency improvement

  return efficiencyFactor
}

function calculateDailyUsagePerUser(mau: number) {
  const additionalHours = (mau / 5000) * metricConfig.PROJECTION.USAGE_GROWTH_FACTOR
  const dailyUsage = metricConfig.PROJECTION.USAGE_HOURS_PER_DAY + additionalHours
  return Math.min(dailyUsage, metricConfig.PROJECTION.MAX_DAILY_USAGE) * 30
}

function calculateVercelUsage(mau: number): VercelUsageParams {
  const efficiencyFactor = calculateEfficiencyFactor(mau)
  const avgUserMonthlyHours = calculateDailyUsagePerUser(mau)

  const calcTotal = (usage: number) => usage * avgUserMonthlyHours * mau * efficiencyFactor

  const invocationsPerMonthPerUser = (0.08 * avgUserMonthlyHours * 3600) / (0.256 * 1)
  console.log(
    `Estimated Function Invocations per Month per User: ${invocationsPerMonthPerUser} in Hours: ${avgUserMonthlyHours}`,
  )

  return {
    efficiencyFactor: ROUND2(efficiencyFactor),
    avgUserMonthlyHours,
    dataTransferGB: calcTotal(usageByHour.dataTransferGB),
    originTransferGB: calcTotal(usageByHour.originTransferGB),
    edgeRequests: calcTotal(usageByHour.edgeRequests),
    middlewareInvocations: calcTotal(usageByHour.middlewareInvocations),
    sourceImages: calcTotal(usageByHour.sourceImages),
    functionInvocations: calcTotal(usageByHour.functionInvocations),
    functionDurationGBHours: calcTotal(usageByHour.functionDurationGBHours),
    edgeFunctionExecutions: calcTotal(usageByHour.edgeFunctionExecutions),
    dataCacheReads: calcTotal(usageByHour.dataCacheReads),
    dataCacheWrites: calcTotal(usageByHour.dataCacheWrites),
    edgeConfigReads: calcTotal(usageByHour.edgeConfigReads),
    edgeConfigWrites: calcTotal(usageByHour.edgeConfigWrites),
    monitoringEvents: calcTotal(usageByHour.monitoringEvents),
    speedInsightsDataPoints: calcTotal(usageByHour.speedInsightsDataPoints),
    webAnalyticsEvents: calcTotal(usageByHour.webAnalyticsEvents),
  }
}

function calculateVercelCost(params: VercelUsageParams): VercelResult {
  const {
    efficiencyFactor,
    avgUserMonthlyHours,
    dataTransferGB,
    originTransferGB,
    edgeRequests,
    middlewareInvocations,
    sourceImages,
    functionInvocations,
    functionDurationGBHours,
    edgeFunctionExecutions,
    dataCacheReads,
    dataCacheWrites,
    edgeConfigReads,
    edgeConfigWrites,
    monitoringEvents,
    speedInsightsDataPoints,
    webAnalyticsEvents,
  } = params

  const {
    basePrice,
    dataTransfer,
    originTransfer,
    edgeRequests: edgeReq,
    middlewareInvocations: midInvocations,
    sourceImages: srcImages,
    functionInvocations: funcInvocations,
    functionDuration: funcDuration,
    edgeFunctionExecutions: edgeExec,
    dataCacheReads: cacheReads,
    dataCacheWrites: cacheWrites,
    edgeConfigReads: configReads,
    edgeConfigWrites: configWrites,
    monitoring,
    speedInsights,
    webAnalytics,
  } = vercelConfig

  const dataTransferCost
    = dataTransferGB > dataTransfer.includedGB
      ? (dataTransferGB - dataTransfer.includedGB) * dataTransfer.pricePerGB
      : 0

  const originTransferCost
    = originTransferGB > originTransfer.includedGB
      ? (originTransferGB - originTransfer.includedGB) * originTransfer.pricePerGB
      : 0

  const edgeRequestsCost
    = edgeRequests > edgeReq.includedRequests
      ? ((edgeRequests - edgeReq.includedRequests) / 1_000_000) * edgeReq.pricePerMillion
      : 0

  const middlewareInvocationsCost
    = middlewareInvocations > midInvocations.includedInvocations
      ? ((middlewareInvocations - midInvocations.includedInvocations) / 1_000_000)
      * midInvocations.pricePerMillion
      : 0

  const sourceImagesCost
    = sourceImages > srcImages.includedImages
      ? ((sourceImages - srcImages.includedImages) / 1_000) * srcImages.pricePerThousand
      : 0

  const functionInvocationsCost
    = functionInvocations > funcInvocations.includedInvocations
      ? ((functionInvocations - funcInvocations.includedInvocations) / 1_000_000)
      * funcInvocations.pricePerMillion
      : 0

  const functionDurationCost
    = functionDurationGBHours > funcDuration.includedGBHours
      ? (functionDurationGBHours - funcDuration.includedGBHours) * funcDuration.pricePerGBHour
      : 0

  const edgeFunctionExecutionsCost
    = edgeFunctionExecutions > edgeExec.includedExecutions
      ? ((edgeFunctionExecutions - edgeExec.includedExecutions) / 1_000_000)
      * edgeExec.pricePerMillion
      : 0

  const dataCacheReadsCost
    = dataCacheReads > cacheReads.includedReads
      ? ((dataCacheReads - cacheReads.includedReads) / 1_000_000) * cacheReads.pricePerMillion
      : 0

  const dataCacheWritesCost
    = dataCacheWrites > cacheWrites.includedWrites
      ? ((dataCacheWrites - cacheWrites.includedWrites) / 1_000_000) * cacheWrites.pricePerMillion
      : 0

  const edgeConfigReadsCost
    = edgeConfigReads > configReads.includedReads
      ? ((edgeConfigReads - configReads.includedReads) / 1_000_000) * configReads.pricePerMillion
      : 0

  const edgeConfigWritesCost
    = edgeConfigWrites > configWrites.includedWrites
      ? ((edgeConfigWrites - configWrites.includedWrites) / 500) * configWrites.pricePer500Writes
      : 0

  const monitoringCost
    = monitoringEvents > 0
      ? monitoring.baseFee + (monitoringEvents / 1_000_000) * monitoring.pricePerMillionEvents
      : 0

  const speedInsightsCost
    = speedInsightsDataPoints > speedInsights.includedDataPoints
      ? ((speedInsightsDataPoints - speedInsights.includedDataPoints) / 10_000)
      * speedInsights.pricePer10kEvents
      : 0

  const webAnalyticsCost
    = webAnalyticsEvents > webAnalytics.includedEvents
      ? ((webAnalyticsEvents - webAnalytics.includedEvents) / 100_000)
      * webAnalytics.pricePer100kEvents
      : 0

  const totalCost
    = basePrice
    + dataTransferCost
    + originTransferCost
    + edgeRequestsCost
    + middlewareInvocationsCost
    + sourceImagesCost
    + functionInvocationsCost
    + functionDurationCost
    + edgeFunctionExecutionsCost
    + dataCacheReadsCost
    + dataCacheWritesCost
    + edgeConfigReadsCost
    + edgeConfigWritesCost
    + monitoringCost
    + speedInsightsCost
    + webAnalyticsCost

  return {
    total: USD2INR(totalCost),
    efficiencyFactor,
    avgUserMonthlyHours,
    breakdown: {
      base: USD2INR(basePrice),
      dataTransfer: USD2INR(dataTransferCost),
      originTransfer: USD2INR(originTransferCost),
      edgeRequests: USD2INR(edgeRequestsCost),
      middlewareInvocations: USD2INR(middlewareInvocationsCost),
      sourceImages: USD2INR(sourceImagesCost),
      functionInvocations: USD2INR(functionInvocationsCost),
      functionDuration: USD2INR(functionDurationCost),
      edgeFunctionExecutions: USD2INR(edgeFunctionExecutionsCost),
      dataCacheReads: USD2INR(dataCacheReadsCost),
      dataCacheWrites: USD2INR(dataCacheWritesCost),
      edgeConfigReads: USD2INR(edgeConfigReadsCost),
      edgeConfigWrites: USD2INR(edgeConfigWritesCost),
      monitoring: USD2INR(monitoringCost),
      speedInsights: USD2INR(speedInsightsCost),
      webAnalytics: USD2INR(webAnalyticsCost),
    },
  }
}

export interface DevopsResult {
  vercel: {
    cost: VercelResult
    usage: VercelUsageParams
  }
  inhouse: {
    cost: DevopsInhouseResult
    usage: {
      dataTransferGB: number
      storageGB: number
    }
  }
}

export function calculateDevopsCosts(mau: number): DevopsResult {
  const { dataTransferGB, storageGB } = calculateUsageByMAU(mau)
  const vercelUsage = calculateVercelUsage(mau)
  return {
    vercel: {
      cost: calculateVercelCost(vercelUsage),
      usage: vercelUsage,
    },
    inhouse: {
      cost: calculateInHouseCosts(mau, storageGB, dataTransferGB),
      usage: { dataTransferGB, storageGB },
    },
  }
}

type Summary = {
  name: string
  value: number | string
}

export interface DevOpsSummaries {
  vercel: Summary[]
  vercelPricing: Summary[]
  inhouse: Summary[]
}

export function generateDevOpsSummaries() {
  const configSummaries = {
    vercel: [] as Summary[],
    vercelPricing: [] as Summary[],
    inhouse: [] as Summary[],
  }

  const addConfigSummary = (config: any, group: 'vercel' | 'vercelPricing' | 'inhouse') => {
    for (const [key, value] of Object.entries(config)) {
      if (typeof value === 'object' && value !== null) {
        configSummaries[group].push({ name: key, value: JSON.stringify(value) })
      } else {
        configSummaries[group].push({ name: key, value: Number(value) })
      }
    }
  }

  addConfigSummary(vercelConfig, 'vercelPricing')
  addConfigSummary(usageByHour, 'vercel')

  const {
    AWS_DATA_TRANSFER_COST_PER_GB,
    AWS_EC2_COST_PER_HOUR,
    AWS_S3_COST_PER_GB,
    CLOUD_FLARE_COST_PER_GB,
    EKS_CLUSTER_COST_PER_HOUR,
    HOURS_PER_MONTH,
    PROMETHEUS_GRAFANA_COST_PER_MONTH,
  } = DEVOPS

  addConfigSummary(
    {
      HOURS_PER_MONTH,
      AWS_EC2_COST_PER_HOUR,
      AWS_S3_COST_PER_GB,
      AWS_DATA_TRANSFER_COST_PER_GB,
      EKS_CLUSTER_COST_PER_HOUR,
      PROMETHEUS_GRAFANA_COST_PER_MONTH,
      CLOUD_FLARE_COST_PER_GB,
    },
    'inhouse',
  )

  return configSummaries
}
</file>

<file path="apps/admin-dashboard/financials/digital-ocean.ts">
import { USD2INR } from './helpers'

type DOPlan = '1vcpu-1gb' | '2vcpu-2gb' | '4vcpu-8gb' | '8vcpu-16gb' | '16vcpu-32gb'

export const digitalOceanConfig = {
  plans: {
    '1vcpu-1gb': {
      monthlyCost: 12.0,
      ram: '1 GB',
      vCPU: 1,
      bandwidthGB: 150,
    },
    '2vcpu-2gb': {
      monthlyCost: 24.0,
      ram: '2 GB',
      vCPU: 2,
      bandwidthGB: 200,
    },
    '4vcpu-8gb': {
      monthlyCost: 48.0,
      ram: '8 GB',
      vCPU: 4,
      bandwidthGB: 300,
    },
    '8vcpu-16gb': {
      monthlyCost: 96.0,
      ram: '16 GB',
      vCPU: 8,
      bandwidthGB: 500,
    },
    '16vcpu-32gb': {
      monthlyCost: 192.0,
      ram: '32 GB',
      vCPU: 16,
      bandwidthGB: 1000,
    },
  },
}

type DigitalOceanCostParams = {
  bandwidthGB: number
}

export interface DigitalOceanResult {
  plan: DOPlan
  cost: number
  ram: string
  vCPU: number
  bandwidthGB: number
}

function calculatePlan(bandwidthGB: number): DOPlan {
  if (bandwidthGB <= 200) {
    return '2vcpu-2gb'
  } else if (bandwidthGB <= 300) {
    return '4vcpu-8gb'
  } else if (bandwidthGB <= 500) {
    return '8vcpu-16gb'
  } else {
    return '16vcpu-32gb'
  }
}

export function calculateDigitalOceanCost(params: DigitalOceanCostParams): DigitalOceanResult {
  const plan = calculatePlan(params.bandwidthGB || 150)
  console.log('digital ocean storage: ', params.bandwidthGB, plan)
  const planDetails = digitalOceanConfig.plans[plan]

  if (!planDetails) {
    throw new Error('Unsupported Digital Ocean plan')
  }

  return {
    plan,
    cost: USD2INR(planDetails.monthlyCost),
    ram: planDetails.ram,
    vCPU: planDetails.vCPU,
    bandwidthGB: planDetails.bandwidthGB,
  }
}
</file>

<file path="apps/admin-dashboard/financials/employee.ts">
import { USD2INR, ROUND0 } from './helpers'

const BASE_EMPLOYEE_COUNT = {
  support: 0,
  core: 0,
  experts: 3,
  founders: 2,
}

export const EMPLOYEE_CONFIG = {
  start: {
    support: {
      salary: 10_000,
    },
    core: {
      salary: 10_000,
    },
    experts: {
      salary: 25_000,
    },
    founders: {
      salary: 25_000,
    },
  },
  growth: {
    support: {
      salary: 15_000,
    },
    core: {
      salary: 24_000,
    },
    experts: {
      salary: 40_000,
    },
    founders: {
      salary: 50_000,
    },
  },
  scaling: {
    support: {
      salary: 20_000,
    },
    core: {
      salary: 36_000,
    },
    experts: {
      salary: 50_000,
    },
    founders: {
      salary: 120_000,
    },
  },
  secure: {
    support: {
      salary: 30_000,
    },
    core: {
      salary: 50_000,
    },
    experts: {
      salary: 100_000,
    },
    founders: {
      salary: 400_000,
    },
  },
}

const EMPLOYEE_EXTRAS = {
  recruitment: 500,
  turnover: 1000,
  legal: 1000,
  technology: 1000,
}

// Function to calculate benefits as a percentage of salary
function calculateBenefits(salary: number, employeeCount: number): number {
  if (employeeCount <= 10) return 0
  return salary * 0.15 // Assuming 15% of salary as benefits
}

// Function to calculate legal fees based on number of employees
function calculateLegalFees(employeeCount: number): number {
  const baseLegalFee = EMPLOYEE_EXTRAS.legal
  return baseLegalFee * employeeCount
}

// Function to calculate turnover costs
function calculateTurnoverCosts(employeeCount: number): number {
  const baseTurnoverCost = EMPLOYEE_EXTRAS.turnover
  const industryAverageAttrition = 0.15 // 15% annual attrition rate
  return baseTurnoverCost * employeeCount * industryAverageAttrition
}

type EmployeeType = 'support' | 'core' | 'experts' | 'founders'

export type EmployeeConfig = {
  employeeCount: number
  total: number
  totalSalary: number
  totalExtras: number
  salary: number
  benefits: number
  turnover: number
  legal: number
  recruitment: number
  technology: number
  mauRatio?: number
}

interface EmployeeCostParams {
  mau: number
  stage: keyof typeof EMPLOYEE_CONFIG
  month: number
  bootstrapMonths: number
}

export function calculateEmployeeCost({
  mau,
  stage,
  month,
  bootstrapMonths,
}: EmployeeCostParams): EmployeeResult {
  const baseCount = BASE_EMPLOYEE_COUNT
  const stageConfig = EMPLOYEE_CONFIG[stage]

  if (month < bootstrapMonths) {
    // Return base employees and their expenses during bootstrap months
    const calculateBaseCost = (count: number, salary: number) => {
      const totalSalary = count * salary
      const legal = calculateLegalFees(count)
      const technology = EMPLOYEE_EXTRAS.technology * count
      const totalExtras = legal + technology

      return {
        employeeCount: count,
        total: totalSalary + totalExtras,
        totalSalary,
        totalExtras,
        salary,
        turnover: 0,
        legal: legal / count,
        benefits: 0,
        recruitment: 0,
        technology: technology / count,
        mauRatio: undefined,
      }
    }

    const experts = calculateBaseCost(baseCount.experts, stageConfig.experts.salary)
    const founders = calculateBaseCost(baseCount.founders, stageConfig.founders.salary)

    const totalCost = experts.total + founders.total
    const totalEmployees = baseCount.experts + baseCount.founders

    return {
      totalCost,
      efficiency: 0,
      totalCount: totalEmployees,
      support: calculateBaseCost(0, stageConfig.support.salary),
      core: calculateBaseCost(0, stageConfig.core.salary),
      experts,
      founders,
    }
  }

  const efficiency = (mau / 1000) * 0.01
  const supportRatio = 7000 + 2500 * efficiency
  const coreRatio = 8500 + 5000 * efficiency
  const expertsRatio = 15000 + 10000 * efficiency

  const supportCount = baseCount.support + Math.round(mau / supportRatio)
  const coreCount = baseCount.core + Math.round(mau / coreRatio)
  const expertsCount = baseCount.experts + Math.round(mau / expertsRatio)
  const totalEmployees = supportCount + coreCount + expertsCount + baseCount.founders

  const calculateCost = (count: number, salary: number, mauRatio?: number) => {
    const totalSalary = count * salary
    const benefits = calculateBenefits(salary, totalEmployees)
    const legal = calculateLegalFees(count)
    const turnover = calculateTurnoverCosts(count)
    const recruitment = EMPLOYEE_EXTRAS.recruitment * count
    const technology = EMPLOYEE_EXTRAS.technology * count
    const totalExtras = turnover + legal + recruitment + technology + benefits * count

    return {
      employeeCount: count,
      total: totalSalary + totalExtras,
      totalSalary,
      totalExtras,
      salary,
      turnover: turnover / count,
      legal: legal / count,
      benefits: benefits,
      recruitment: recruitment / count,
      technology: technology / count,
      mauRatio,
    }
  }

  const support = calculateCost(supportCount, stageConfig.support.salary, supportRatio)
  const core = calculateCost(coreCount, stageConfig.core.salary, coreRatio)
  const experts = calculateCost(expertsCount, stageConfig.experts.salary, expertsRatio)
  const founders = calculateCost(baseCount.founders, stageConfig.founders.salary)

  const totalCost = support.total + core.total + experts.total + founders.total

  return {
    totalCost,
    efficiency,
    totalCount: totalEmployees,
    support,
    core,
    experts,
    founders,
  }
}

export type EmployeeResult = {
  totalCost: number
  totalCount: number
  efficiency: number
  support: EmployeeConfig
  core: EmployeeConfig
  experts: EmployeeConfig
  founders: EmployeeConfig
}
</file>

<file path="apps/admin-dashboard/financials/gen-info.ts">
import { generateDevOpsSummaries, type DevOpsSummaries } from './dev-ops'

export interface InfoResult {
  devops: DevOpsSummaries
}

export function generateInfo() {
  const devOpsSummaries = generateDevOpsSummaries()

  return {
    devops: devOpsSummaries,
  }
}
</file>

<file path="apps/admin-dashboard/financials/gpt.ts">
import { request } from 'http'
import type { ProcessdContentConfig, StageConfig } from './totals'
import { USD2INR } from './helpers'

type EmbeddingModel = 'text-embedding-3-small' | 'text-embedding-3-large'

type ChatModel = 'gpt-4o' | 'gpt-4o-mini' | 'gpt-3.5-turbo-0125'

const PERCENTAGE_MAU_USING_CHAT = 0.5 // 50%
const AVG_FREE_REQUESTS_PER_USER = 50
const PRO_REQUESTS_CAP = 150
const EXPERT_REQUESTS_CAP = 300

interface CostConfig {
  embedding: Record<EmbeddingModel, Record<'live' | 'batch', number>>
  chat: Record<ChatModel, Record<'live' | 'batch', { input: number, output: number }>>
}

// groq for free
interface GroqModelConfig {
  id: string
  requestsPerMinute: number
  requestsPerDay: number
  tokensPerMinute: number
}

const GROQ_MODELS: Record<string, GroqModelConfig> = {
  gemma7b: {
    id: 'gemma-7b-it',
    requestsPerMinute: 30,
    requestsPerDay: 14400,
    tokensPerMinute: 15000,
  },
  gemma29b: {
    id: 'gemma2-9b-it',
    requestsPerMinute: 30,
    requestsPerDay: 14400,
    tokensPerMinute: 15000,
  },
  llama70b: {
    id: 'llama3-70b-8192',
    requestsPerMinute: 30,
    requestsPerDay: 14400,
    tokensPerMinute: 6000,
  },
  llama8b: {
    id: 'llama3-8b-8192',
    requestsPerMinute: 30,
    requestsPerDay: 14400,
    tokensPerMinute: 30000,
  },
  llama70bPreview: {
    id: 'llama3-groq-70b-8192-tool-use-preview',
    requestsPerMinute: 30,
    requestsPerDay: 14400,
    tokensPerMinute: 15000,
  },
  llama8bPreview: {
    id: 'llama3-groq-8b-8192-tool-use-preview',
    requestsPerMinute: 30,
    requestsPerDay: 14400,
    tokensPerMinute: 15000,
  },
  mixtral8x7b: {
    id: 'mixtral-8x7b-32768',
    requestsPerMinute: 30,
    requestsPerDay: 14400,
    tokensPerMinute: 5000,
  },
}

const FREE_MODEL = GROQ_MODELS.llama70b

function calculateHourlyRate(
  numItems: number,
  totalTokens: number,
): { requestsPerHour: number[], tokensPerHour: number[] } {
  const daysInMonth = 30.5
  const hoursPerDay = 24
  const quarters = [
    { hours: 6, distribution: 0.1 }, // First 6 hours: 10% of traffic
    { hours: 6, distribution: 0.2 }, // Next 6 hours: 20% of traffic
    { hours: 6, distribution: 0.3 }, // Next 6 hours: 30% of traffic
    { hours: 6, distribution: 0.4 }, // Last 6 hours: 40% of traffic
  ]

  const requestsPerHour = new Array(hoursPerDay).fill(0)
  const tokensPerHour = new Array(hoursPerDay).fill(0)
  let currentHour = 0

  quarters.forEach((quarter) => {
    const requestsThisQuarter = (numItems / daysInMonth) * quarter.distribution // Requests for this quarter per day
    const tokensThisQuarter = (totalTokens / daysInMonth) * quarter.distribution // Tokens for this quarter per day
    const requestsPerHourThisQuarter = requestsThisQuarter / quarter.hours // Average per hour in this quarter
    const tokensPerHourThisQuarter = tokensThisQuarter / quarter.hours // Average per hour in this quarter

    for (let i = 0; i < quarter.hours; i++) {
      requestsPerHour[currentHour] = requestsPerHourThisQuarter
      tokensPerHour[currentHour] = tokensPerHourThisQuarter
      currentHour++
    }
  })

  return {
    requestsPerHour: requestsPerHour,
    tokensPerHour: tokensPerHour,
  }
}

function determineGroqModel(
  hourlyRates: { requestsPerHour: number[], tokensPerHour: number[] },
  currentModel: GroqModelConfig = GROQ_MODELS.llama70b,
): GroqModelConfig {
  const models = Object.values(GROQ_MODELS) // Convert model object to array for easier processing

  // Find the peak rates for the entire day
  const peakRequestsPerHour = Math.max(...hourlyRates.requestsPerHour)
  const peakTokensPerHour = Math.max(...hourlyRates.tokensPerHour)

  // Find a model that can handle the peak hourly request and token rates
  const suitableModel = models.find(
    (model) =>
      model.requestsPerMinute * 60 >= peakRequestsPerHour
      && model.tokensPerMinute * 60 >= peakTokensPerHour,
  )

  return suitableModel || currentModel // Return the found model or default back to the current if none found
}

// END FREE

export const COST_CONFIG: CostConfig = {
  embedding: {
    'text-embedding-3-small': {
      live: 0.02,
      batch: 0.01,
    },
    'text-embedding-3-large': {
      live: 0.13,
      batch: 0.07,
    },
  },
  chat: {
    'gpt-4o': {
      live: {
        input: 5.0,
        output: 15.0,
      },
      batch: {
        input: 2.5,
        output: 7.5,
      },
    },
    'gpt-4o-mini': {
      live: {
        input: 0.15,
        output: 0.6,
      },
      batch: {
        input: 0.075,
        output: 0.3,
      },
    },
    'gpt-3.5-turbo-0125': {
      live: {
        input: 0.5,
        output: 1.5,
      },
      batch: {
        input: 0.25,
        output: 0.75,
      },
    },
  },
}

type CostParams = {
  numItems: number
  charsPerItem: number
  charsForPrompt?: number
  charsPerOutput?: number
  modelType: EmbeddingModel | ChatModel
  costType: 'live' | 'batch'
  taskType: 'embedding' | 'chat' | 'summary'
  isPremium: boolean
}

const CHARS_PER_TOKEN = 4
function calculateTokens(chars: number): number {
  return chars / CHARS_PER_TOKEN
}

function calculateCostPerMillionTokens(tokens: number, pricePerMillionTokens: number): number {
  return (tokens / 1_000_000) * pricePerMillionTokens
}

function calculateEmbeddingCost(params: CostParams): {
  total: number
  tokens: { total: number }
} {
  const { numItems, charsPerItem, modelType, costType } = params
  const totalTokens = numItems * calculateTokens(charsPerItem)
  const pricePerMillionTokens = COST_CONFIG.embedding[modelType as EmbeddingModel][costType]
  const totalCostUSD = calculateCostPerMillionTokens(totalTokens, pricePerMillionTokens)
  return {
    total: USD2INR(totalCostUSD),
    tokens: { total: totalTokens },
  }
}

function calculateTotalChatCost(params: CostParams): {
  cost: {
    total: number
    input: number
    output: number
  }
  tokens: {
    total: number
    input: number
    inputCPM: number
    output: number
    outputCPM: number
  }
} {
  const {
    numItems,
    charsPerItem,
    charsForPrompt = 0,
    charsPerOutput = 0,
    modelType,
    costType,
    isPremium,
  } = params
  const totalInputTokens = numItems * calculateTokens(charsPerItem + charsForPrompt)
  const totalOutputTokens = numItems * calculateTokens(charsPerOutput)

  if (isPremium) {
    // Premium users use a different costing model potentially
    const pricePerMillionInputTokens = COST_CONFIG.chat[modelType as ChatModel][costType].input
    const pricePerMillionOutputTokens = COST_CONFIG.chat[modelType as ChatModel][costType].output

    const inputCost = calculateCostPerMillionTokens(totalInputTokens, pricePerMillionInputTokens)
    const outputCost = calculateCostPerMillionTokens(totalOutputTokens, pricePerMillionOutputTokens)

    return {
      cost: {
        total: USD2INR(inputCost + outputCost),
        input: USD2INR(inputCost),
        output: USD2INR(outputCost),
      },
      tokens: {
        total: totalInputTokens + totalOutputTokens,
        inputCPM: USD2INR(pricePerMillionInputTokens),
        input: totalInputTokens,
        outputCPM: USD2INR(pricePerMillionOutputTokens),
        output: totalOutputTokens,
      },
    }
  } else {
    // Free users utilize Groq models
    // Implement logic to calculate the hourly request and token rate
    const hourlyRate = calculateHourlyRate(numItems, totalInputTokens + totalOutputTokens)
    const currentGroqModel = determineGroqModel(hourlyRate)

    // Mock calculation assuming free model has no cost in monetary terms but has other limits
    return {
      cost: {
        total: 0,
        input: 0,
        output: 0,
      },
      tokens: {
        total: totalInputTokens + totalOutputTokens,
        inputCPM: 0,
        input: totalInputTokens,
        outputCPM: 0,
        output: totalOutputTokens,
      },
    }
  }
}

function calculateTotalCost(params: CostParams): any {
  if (params.taskType === 'embedding') {
    return calculateEmbeddingCost(params)
  } else if (params.taskType === 'chat') {
    return calculateTotalChatCost(params)
  } else if (params.taskType === 'summary') {
    return calculateTotalChatCost(params)
  } else {
    throw new Error('Unsupported task type')
  }
}

export interface ChatGPTResult {
  totalCost: number
  totalTokens: number
  free: {
    cost: {
      total: number
      input: number
      output: number
    }
    tokens: {
      total: number
      input: number
      inputCPM: number
      output: number
      outputCPM: number
    }
    model: ChatModel
    requests: number
  }
  pro: {
    cost: {
      total: number
      input: number
      output: number
    }
    tokens: {
      total: number
      input: number
      inputCPM: number
      output: number
      outputCPM: number
    }
    model: ChatModel
    requests: number
  }
  expert: {
    cost: {
      total: number
      input: number
      output: number
    }
    tokens: {
      total: number
      input: number
      inputCPM: number
      output: number
      outputCPM: number
    }
    model: ChatModel
    requests: number
  }
}

function calculateChatGPTUsageCost(
  freeUsers: number,
  customers: { pro: number, expert: number },
): ChatGPTResult {
  const totalMauUsingChatGPT = Math.floor(freeUsers * PERCENTAGE_MAU_USING_CHAT)
  const totalFreeRequests = totalMauUsingChatGPT * AVG_FREE_REQUESTS_PER_USER
  const totalExpertRequests = customers.expert * EXPERT_REQUESTS_CAP
  const totalProRequests = customers.pro * PRO_REQUESTS_CAP

  const freeModel: ChatModel = 'gpt-3.5-turbo-0125'
  const premiumModel: ChatModel = 'gpt-4o-mini'

  const freeCost = calculateTotalChatCost({
    numItems: totalFreeRequests,
    charsPerItem: 0,
    charsForPrompt: 240,
    charsPerOutput: 1000,
    modelType: freeModel,
    costType: 'live',
    taskType: 'chat',
    isPremium: false,
  })

  const proCost = calculateTotalChatCost({
    numItems: totalProRequests,
    charsPerItem: 0,
    charsForPrompt: 240,
    charsPerOutput: 1200,
    modelType: premiumModel,
    costType: 'live',
    taskType: 'chat',
    isPremium: true,
  })

  const expertCost = calculateTotalChatCost({
    numItems: totalExpertRequests,
    charsPerItem: 0,
    charsForPrompt: 240,
    charsPerOutput: 1600,
    modelType: premiumModel,
    costType: 'live',
    taskType: 'chat',
    isPremium: true,
  })

  const totalCost = freeCost.cost.total + proCost.cost.total + expertCost.cost.total
  const totalTokens = freeCost.tokens.total + proCost.tokens.total + expertCost.tokens.total

  return {
    totalCost: totalCost,
    totalTokens: totalTokens,
    free: {
      ...freeCost,
      model: freeModel,
      requests: totalFreeRequests,
    },
    pro: {
      ...proCost,
      model: premiumModel,
      requests: totalProRequests,
    },
    expert: {
      ...expertCost,
      model: premiumModel,
      requests: totalExpertRequests,
    },
  }
}

interface AiBreakdown {
  type: string
  embedding: {
    totalCost: number
    tokens: {
      total: number
    }
    model: EmbeddingModel
    batch: 'batch' | 'live'
  }
  summary: {
    cost: {
      total: number
      input: number
      output: number
    }
    tokens: {
      total: number
      input: number
      output: number
    }
    model: ChatModel
    batch: 'batch' | 'live'
  }
}

export interface AiCostResult {
  cost: {
    total: number
    embedding: number
    summary: number
    chat: number
  }
  tokens: {
    total: number
    embedding: number
    summary: number
    chat: number
  }
  breakdown: AiBreakdown[]
  chat: ChatGPTResult
}

const EMBEDDING_MODEL: EmbeddingModel = 'text-embedding-3-small'
const SUMMARY_MODEL: ChatModel = 'gpt-4o-mini'

interface CalculateAiCostParams {
  mau: number
  customers: {
    pro: number
    expert: number
  }
  isBatch?: boolean
  CONTENT_CONFIG: StageConfig
}

export function calculateAiCost({
  mau,
  customers,
  isBatch = true,
  CONTENT_CONFIG,
}: CalculateAiCostParams): AiCostResult {
  const freeUsers = mau - (customers.expert + customers.pro)
  const chat = calculateChatGPTUsageCost(freeUsers, customers)

  const breakdown = [] as AiBreakdown[]
  let totalEmbeddingsCost = 0
  let totalEmbeddingTokens = 0
  let totalSummaryCost = 0
  let totalSummaryTokens = 0

  for (const contentType in CONTENT_CONFIG) {
    const content = CONTENT_CONFIG[contentType as keyof typeof CONTENT_CONFIG]

    // Calculate embedding cost
    const contentEmbeddingCost = calculateTotalCost({
      numItems: content.PROCESSED_MONTHLY,
      charsPerItem: content.CHARS.CONTENT,
      modelType: EMBEDDING_MODEL,
      costType: isBatch ? 'batch' : 'live',
      taskType: 'embedding',
      isPremium: true,
    })

    const contentSummaryCost = calculateTotalCost({
      numItems: content.PROCESSED_MONTHLY,
      charsPerItem: content.CHARS.CONTENT,
      charsForPrompt: content.CHARS.PROMPT,
      charsPerOutput: content.CHARS.OUTPUT,
      modelType: SUMMARY_MODEL,
      costType: isBatch ? 'batch' : 'live',
      taskType: 'summary',
      isPremium: true,
    })

    totalEmbeddingsCost += contentEmbeddingCost.total
    totalEmbeddingTokens += contentEmbeddingCost.tokens.total
    totalSummaryTokens += contentSummaryCost.tokens.total
    totalSummaryCost += contentSummaryCost.cost.total

    breakdown.push({
      type: contentType,
      embedding: {
        totalCost: contentEmbeddingCost.total,
        tokens: {
          total: contentEmbeddingCost.tokens.total,
        },
        model: EMBEDDING_MODEL,
        batch: isBatch ? 'batch' : 'live',
      },
      summary: {
        cost: {
          total: contentSummaryCost.cost.total,
          input: contentSummaryCost.cost.input,
          output: contentSummaryCost.cost.output,
        },
        tokens: contentSummaryCost.tokens,
        model: SUMMARY_MODEL,
        batch: isBatch ? 'batch' : 'live',
      },
    })
  }

  console.log(
    'Total Costs:',
    totalEmbeddingsCost.toFixed(0),
    totalSummaryCost.toFixed(0),
    chat.totalCost.toFixed(0),
  )

  return {
    cost: {
      total: totalEmbeddingsCost + totalSummaryCost + chat.totalCost,
      embedding: totalEmbeddingsCost,
      summary: totalSummaryCost,
      chat: chat.totalCost,
    },
    tokens: {
      total: totalEmbeddingTokens + totalSummaryTokens + chat.totalTokens,
      embedding: totalEmbeddingTokens,
      summary: totalSummaryTokens,
      chat: chat.totalTokens,
    },
    breakdown,
    chat,
  }
}
</file>

<file path="apps/admin-dashboard/financials/helpers.ts">
const CHAR_CHUNK_SIZE = 1024
const AVG_CHAR_PER_WORD = 4.7

export function USD2INR(usd: number, USD_TO_INR: number = 75.0) {
  return parseFloat((usd * USD_TO_INR).toFixed(2))
}

export function ROUND0(value: number) {
  return parseInt(value.toFixed(0))
}

export function ROUND2(value: number) {
  return parseFloat(value.toFixed(2))
}
export const WORDS_TO_CHAR_CHUNKS = (words: number) =>
  Math.ceil((words * AVG_CHAR_PER_WORD) / CHAR_CHUNK_SIZE)

export const WORDS_TO_CHARS = (words: number) => Math.ceil(words * AVG_CHAR_PER_WORD)

interface RefundEfficiencyParams {
  currentMonth: number
  pessimistic: number
  optimistic: number
}

export function EFFICIENCY_FACTOR({
  currentMonth,
  pessimistic,
  optimistic,
}: RefundEfficiencyParams): number {
  const midpoint = 6 // Midpoint of 12 months for gradual change
  const steepness = 0.1 // Steepness of the curve
  const factor = 1 / (1 + Math.exp(-steepness * (currentMonth - midpoint))) // S-curve scaling
  return pessimistic - factor * (pessimistic - optimistic)
}

export function CHURN_TO_LIFESPAN_MONTHS(monthlyChurnRate: number): number {
  const averageLifespanMonths = 1 / monthlyChurnRate
  return averageLifespanMonths
}
</file>

<file path="apps/admin-dashboard/financials/logging.ts">
import { USD2INR } from './helpers'

// Updated configuration to include metrics and analytics pricing
export const LOGS_CONFIG = {
  includedGB: 50,
  additionalGBPrice: 0.45,
  retentionIncludedDays: 30,
  retentionPricePerGBPerMonth: 0.1,
  minimumCharge: 34,
}

export const LOGS_METRIC_CONFIG = {
  includedDataPoints: 10_000_000,
  additionalDataPointsPrice: 10, // Price per additional 10M data points
}

export const LOGS_ANALYTICS_CONFIG = {
  pricePerMember: 5, // Price per member per month
}

type LogsCostParams = {
  MAU: number
  month: number
  avgMauUsage: number
  teamMembers: number
}

export interface LoggingResult {
  total: number
  ingested: number
  retention: number
  metrics: number
  analytics: number
}

type UsageParams = {
  MAU: number
  month: number
  avgMauUsage: number
  teamMembers: number
  ingestedGB: number
  additionalIngestedGB: number
  retentionGB: number
  metricsIngestedDataPoints: number
  additionalMetricsDataPoints: number
}

function estimateUsage(params: LogsCostParams): UsageParams {
  const { MAU, month, avgMauUsage, teamMembers } = params

  const ingestedGB = MAU * avgMauUsage
  const additionalIngestedGB
    = ingestedGB > LOGS_CONFIG.includedGB ? ingestedGB - LOGS_CONFIG.includedGB : 0

  const retentionGB = ingestedGB * (month > 6 ? 1 : 0) // Retention is applied only after the first 6 months

  const metricsIngestedDataPoints = MAU * 300 // Assuming 300 data points per MAU, 30 per day
  const additionalMetricsDataPoints
    = metricsIngestedDataPoints > LOGS_METRIC_CONFIG.includedDataPoints
      ? metricsIngestedDataPoints - LOGS_METRIC_CONFIG.includedDataPoints
      : 0

  return {
    MAU,
    month,
    avgMauUsage,
    teamMembers,
    ingestedGB,
    additionalIngestedGB,
    retentionGB,
    metricsIngestedDataPoints,
    additionalMetricsDataPoints,
  }
}

export function calculateLogsCost(params: LogsCostParams): LoggingResult {
  const usage = estimateUsage(params)

  const {
    month,
    ingestedGB,
    additionalIngestedGB,
    retentionGB,
    metricsIngestedDataPoints,
    additionalMetricsDataPoints,
    teamMembers,
  } = usage

  if (month <= 6) {
    // Free tier conditions
    const freeIncludedGB = 3
    const freeRetentionDays = 3
    const retentionCost = 0
    const metricsCost = 0
    const analyticsCost = 0

    const additionalIngestedGB = ingestedGB > freeIncludedGB ? ingestedGB - freeIncludedGB : 0
    const ingestedCost = 0 // Free tier so ingested cost is $0

    return {
      total: USD2INR(0), // Free tier so total cost is $0
      ingested: USD2INR(ingestedCost),
      retention: USD2INR(retentionCost),
      metrics: USD2INR(metricsCost),
      analytics: USD2INR(analyticsCost),
    }
  } else {
    const { includedGB, additionalGBPrice, retentionPricePerGBPerMonth, minimumCharge }
      = LOGS_CONFIG

    // Calculate ingested cost
    const ingestedCost = additionalIngestedGB * additionalGBPrice

    // Calculate retention cost
    const retentionCost = retentionGB * retentionPricePerGBPerMonth

    // Calculate metrics cost
    const metricsCost
      = (additionalMetricsDataPoints / 10_000_000) * LOGS_METRIC_CONFIG.additionalDataPointsPrice

    // Calculate analytics cost
    const analyticsCost = teamMembers * LOGS_ANALYTICS_CONFIG.pricePerMember

    // Calculate total cost
    const totalCost = ingestedCost + retentionCost + metricsCost + analyticsCost

    // Ensure the cost is not below the minimum charge
    const costMinusMinimum = totalCost > minimumCharge ? totalCost : minimumCharge

    return {
      total: USD2INR(costMinusMinimum),
      ingested: USD2INR(ingestedCost),
      retention: USD2INR(retentionCost),
      metrics: USD2INR(metricsCost),
      analytics: USD2INR(analyticsCost),
    }
  }
}
</file>

<file path="apps/admin-dashboard/financials/marketing.ts">
type MarketingCostParams = {
  mrr: number
  percentage: number
}

export function calculateMarketingCost({ mrr, percentage }: MarketingCostParams): number {
  if (mrr < 0) {
    throw new Error(
      'Invalid input: MRR and percentage must be positive and percentage must be between 0 and 100.',
    )
  }

  const marketingCost = mrr * percentage

  return marketingCost
}
</file>

<file path="apps/admin-dashboard/financials/metrics-users.ts">
export type CostCategory =
  | 'infrastructure'
  | 'thirdPartyServices'
  | 'support'
  | 'development'
  | 'marketing'

interface CostDetails {
  total: number
  singleCost: number
}

interface UserTierCost {
  free: CostDetails
  pro: CostDetails
  expert: CostDetails
}

interface AllocateCostParams {
  totalCosts: {
    free: number
    pro: number
    expert: number
  }
  users: {
    free: number
    pro: number
    expert: number
  }
}

function allocateCostsToTiers({ totalCosts, users }: AllocateCostParams): UserTierCost {
  const totalUsers = users.free + users.pro + users.expert

  const costs: UserTierCost = {
    free: { total: 0, singleCost: 0 },
    pro: { total: 0, singleCost: 0 },
    expert: { total: 0, singleCost: 0 },
  }

  // Allocate infrastructure costs
  const costPerFreeUser = totalCosts.free / totalUsers
  const costPerProUser = totalCosts.pro / totalUsers
  const costPerExpertUser = totalCosts.expert / totalUsers

  costs.free.total = costPerFreeUser * users.free
  costs.pro.total = costPerProUser * users.pro
  costs.expert.total = costPerExpertUser * users.expert

  costs.free.singleCost = costPerFreeUser
  costs.pro.singleCost = costPerProUser
  costs.expert.singleCost = costPerExpertUser

  return costs
}

export interface CalculateCostParams {
  users: {
    free: number
    pro: number
    expert: number
  }
  totalCosts: {
    free: number
    pro: number
    expert: number
  }
}

export function calculateCostPerUser({ users, totalCosts }: CalculateCostParams): CostPerUser {
  const costs = allocateCostsToTiers({
    totalCosts,
    users,
  })

  return {
    total: totalCosts.free + totalCosts.pro + totalCosts.expert,
    totalCount: users.free + users.pro + users.expert,
    customerCount: users.pro + users.expert,
    free: {
      count: users.free,
      totalCost: costs.free.total,
      singleCost: costs.free.singleCost,
    },
    pro: {
      count: users.pro,
      totalCost: costs.pro.total,
      singleCost: costs.pro.singleCost,
    },
    expert: {
      count: users.expert,
      totalCost: costs.expert.total,
      singleCost: costs.expert.singleCost,
    },
  }
}

export interface CostPerUser {
  total: number
  totalCount: number
  customerCount: number
  free: {
    count: number
    totalCost: number
    singleCost: number
  }
  pro: {
    count: number
    totalCost: number
    singleCost: number
  }
  expert: {
    count: number
    totalCost: number
    singleCost: number
  }
}
</file>

<file path="apps/admin-dashboard/financials/metrics.ts">
import { ROUND0, USD2INR, ROUND2, CHURN_TO_LIFESPAN_MONTHS, EFFICIENCY_FACTOR } from './helpers'
import { calculateCostPerUser, type CostPerUser } from './metrics-users'
import { INCOME_STREAMS } from './customers'
import { metricConfig } from './totals'

function calculateRecurringRevenue(revenue: { free: number, pro: number, expert: number }) {
  const freeMRR = revenue.free
  const proMRR = revenue.pro
  const expertMRR = revenue.expert

  const freeARR = freeMRR * 12
  const proARR = proMRR * 12
  const expertARR = expertMRR * 12

  return {
    totalMRR: freeMRR + proMRR + expertMRR,
    totalARR: freeARR + proARR + expertARR,
    free: {
      monthly: freeMRR,
      annual: freeARR,
    },
    pro: {
      monthly: proMRR,
      annual: proARR,
    },
    expert: {
      monthly: expertMRR,
      annual: expertARR,
    },
  }
}

interface ARPU {
  MRR: { free: number, pro: number, expert: number }
  users: { free: number, pro: number, expert: number }
}
function calculateAverageRevenuePerUser({ MRR, users }: ARPU) {
  const totalUsers = users.free + users.pro + users.expert
  const monthlyRecurringRevenue = MRR.free + MRR.pro + MRR.expert

  return {
    total: totalUsers > 0 ? ROUND0(monthlyRecurringRevenue / totalUsers) : 0,
    free: users.free > 0 ? ROUND0(MRR.free / users.free) : 0,
    pro: users.pro > 0 ? ROUND0(MRR.pro / users.pro) : 0,
    expert: users.expert > 0 ? ROUND0(MRR.expert / users.expert) : 0,
  }
}
interface CLVParams {
  avgRevenue: {
    free: number
    pro: number
    expert: number
  }
  lifespan: { free: number, pro: number, expert: number }
}

function calculateCustomerLifetimeValue(params: CLVParams) {
  const freeCLV = params.avgRevenue.free * params.lifespan.free
  const proCLV = params.avgRevenue.pro * params.lifespan.pro
  const expertCLV = params.avgRevenue.expert * params.lifespan.expert
  return {
    average: ROUND2(freeCLV + proCLV + expertCLV) / 3,
    free: ROUND2(freeCLV),
    pro: ROUND2(proCLV),
    expert: ROUND2(expertCLV),
  }
}

interface CACParams {
  totalMarketingCosts: number
  newUsers: { free: number, pro: number, expert: number }
}

function calculateCustomerAcquisitionCost({ totalMarketingCosts, newUsers }: CACParams) {
  const { free, pro, expert } = newUsers
  const newCustomers = free + pro + expert

  const averageCAC = newCustomers > 0 ? Math.round(totalMarketingCosts / newCustomers) : 0
  const freeCAC = free > 0 ? Math.round(totalMarketingCosts / free) : 0
  const proCAC = pro > 0 ? Math.round(totalMarketingCosts / pro) : 0
  const expertCAC = expert > 0 ? Math.round(totalMarketingCosts / expert) : 0

  return {
    average: averageCAC,
    free: freeCAC,
    pro: proCAC,
    expert: expertCAC,
  }
}

function calculateRetentionRate(churnRate: { free: number, pro: number, expert: number }) {
  return {
    average: 100 - ((churnRate.free + churnRate.pro + churnRate.expert) * 100) / 3,
    free: 100 - churnRate.free * 100,
    pro: 100 - churnRate.pro * 100,
    expert: 100 - churnRate.expert * 100,
  }
}

function calculateConversionRates(users: {
  mau: number
  free: number
  pro: number
  expert: number
}) {
  return users.mau > 0
    ? {
        total: parseInt((((users.pro + users.expert) / users.mau) * 100).toFixed(0)),
        pro: parseInt(((users.pro / users.mau) * 100).toFixed(0)),
        expert: parseInt(((users.expert / users.mau) * 100).toFixed(0)),
      }
    : { total: 0, pro: 0, expert: 0 }
}

function calculateGrossMargin(revenue: number, costOfGoodsSold: number) {
  return revenue > 0 ? parseInt((((revenue - costOfGoodsSold) / revenue) * 100).toFixed(0)) : 0
}

function calculateMarketingSpendEfficiency(totalMarketingCosts: number, revenue: number) {
  return revenue > 0 ? parseInt(((revenue / totalMarketingCosts) * 100).toFixed(0)) : 0
}

interface ChurnRefundParams {
  currentMonth: number
  users: {
    free: number
    pro: number
    expert: number
  }
  revenue: {
    pro: number
    expert: number
  }
}

function calculateChurnAndRefunds({ currentMonth, users, revenue }: ChurnRefundParams) {
  const { subscription } = INCOME_STREAMS

  const { PRO, EXPERT } = metricConfig.MONTHLY_CHURN

  const freeChurnRate = EFFICIENCY_FACTOR({
    currentMonth,
    pessimistic: metricConfig.MONTHLY_CHURN.MAU.PESSIMISTIC,
    optimistic: metricConfig.MONTHLY_CHURN.MAU.OPTIMISTIC,
  })

  const proChurnRate = EFFICIENCY_FACTOR({
    currentMonth,
    pessimistic: PRO.PESSIMISTIC,
    optimistic: PRO.OPTIMISTIC,
  })

  const expertChurnRate = EFFICIENCY_FACTOR({
    currentMonth,
    pessimistic: EXPERT.PESSIMISTIC,
    optimistic: EXPERT.OPTIMISTIC,
  })

  const proRefundRate = EFFICIENCY_FACTOR({
    currentMonth,
    pessimistic: subscription.pro.refund.yearly.pessimistic,
    optimistic: subscription.pro.refund.yearly.optimistic,
  })

  const expertRefundRate = EFFICIENCY_FACTOR({
    currentMonth,
    pessimistic: subscription.expert.refund.yearly.pessimistic,
    optimistic: subscription.expert.refund.yearly.optimistic,
  })

  const proRefundCost = revenue.pro * proRefundRate
  const expertRefundCost = revenue.expert * expertRefundRate
  const totalRefundAmount = proRefundCost + expertRefundCost

  const proChurnedUsers = users.pro * proChurnRate
  const expertChurnedUsers = users.expert * expertChurnRate

  const totalChurnedUsers = proChurnedUsers + expertChurnedUsers

  const proRefundUsers = users.pro * proRefundRate
  const expertRefundUsers = users.expert * expertRefundRate
  const totalRefundedUsers = proRefundUsers + expertRefundUsers

  const proChurnCost = revenue.pro * proChurnRate
  const expertChurnCost = revenue.expert * expertChurnRate
  const totalChurnCost = proChurnCost + expertChurnCost

  return {
    refund: {
      total: {
        cost: totalRefundAmount,
        rate: (proRefundRate + expertRefundRate) * 100,
        count: totalRefundedUsers,
      },
      pro: {
        count: proRefundUsers,
        cost: proRefundCost,
        rate: proRefundRate,
      },
      expert: {
        count: expertRefundUsers,
        cost: expertRefundCost,
        rate: expertRefundRate,
      },
    },
    churn: {
      total: {
        cost: totalChurnCost,
        rate: proChurnRate + expertChurnRate,
        count: totalChurnedUsers,
      },
      free: {
        rate: freeChurnRate,
        count: users.free * freeChurnRate,
      },
      pro: {
        count: proChurnedUsers,
        cost: proChurnCost,
        rate: proChurnRate,
      },
      expert: {
        count: expertChurnedUsers,
        cost: expertChurnCost,
        rate: expertChurnRate,
      },
    },
  }
}

interface AllMetricsParams {
  currentMonth: number
  marketing: {
    cost: number
    leads: number
  }
  expenses: {
    total: number
    free: number
    pro: number
    expert: number
  }
  revenue: {
    free: number
    pro: number
    expert: number
  }
  users: {
    mau: number
    free: number
    pro: number
    expert: number
    totalCustomers: number
    new: number
    newCustomers: number
  }
}

export function calculateAllMetrics(params: AllMetricsParams): AllMetrics {
  const { marketing, expenses, revenue, users, currentMonth } = params

  const { churn, refund } = calculateChurnAndRefunds({
    currentMonth,
    users,
    revenue: {
      pro: revenue.pro,
      expert: revenue.expert,
    },
  })

  const effectiveRevenue
    = revenue.free + revenue.pro + revenue.expert - refund.total.cost - churn.total.cost
  const recurringRevenue = calculateRecurringRevenue(revenue)

  const freeLifespan = CHURN_TO_LIFESPAN_MONTHS(churn.free.rate)
  const proLifespan = CHURN_TO_LIFESPAN_MONTHS(churn.pro.rate)
  const expertLifespan = CHURN_TO_LIFESPAN_MONTHS(churn.expert.rate)

  const avgRevenue = calculateAverageRevenuePerUser({
    MRR: {
      free: recurringRevenue.free.monthly,
      pro: recurringRevenue.pro.monthly,
      expert: recurringRevenue.expert.monthly,
    },
    users,
  })

  const lifetimeValue = calculateCustomerLifetimeValue({
    avgRevenue: {
      free: avgRevenue.free,
      pro: avgRevenue.pro,
      expert: avgRevenue.expert,
    },
    lifespan: {
      free: freeLifespan,
      pro: proLifespan,
      expert: expertLifespan,
    },
  })

  const customerAcquisitionCost = calculateCustomerAcquisitionCost({
    totalMarketingCosts: marketing.cost,
    newUsers: {
      free: users.free,
      pro: users.pro,
      expert: users.expert,
    },
  })

  const retentionRate = calculateRetentionRate({
    free: churn.free.rate,
    pro: churn.pro.rate,
    expert: churn.expert.rate,
  })

  const totalConversionRate = calculateConversionRates(users)

  const grossMargin = calculateGrossMargin(effectiveRevenue, expenses.total)

  const marketingSpendEfficiency = calculateMarketingSpendEfficiency(
    marketing.cost,
    effectiveRevenue,
  )

  const userCost = calculateCostPerUser({
    users,
    totalCosts: {
      free: expenses.free,
      pro: expenses.pro,
      expert: expenses.expert,
    },
  })

  console.log('PLMargin', effectiveRevenue, expenses.total)

  return {
    mau: {
      total: users.mau,
      new: users.new,
      churned: churn.total.count,
      free: users.free,
      pro: users.pro,
      expert: users.expert,
      customers: users.totalCustomers,
    },
    monthlyRecurringRevenue: {
      effective: effectiveRevenue,
      free: recurringRevenue.free.monthly,
      pro: recurringRevenue.pro.monthly,
      expert: recurringRevenue.expert.monthly,
    },
    annualRecurringRevenue: {
      effective: effectiveRevenue * 12,
      free: recurringRevenue.free.annual,
      pro: recurringRevenue.pro.annual,
      expert: recurringRevenue.expert.annual,
    },
    averageRevenuePerUser: {
      total: avgRevenue.total,
      free: avgRevenue.free,
      pro: avgRevenue.pro,
      expert: avgRevenue.expert,
    },
    customerLifetimeValue: lifetimeValue,
    customerAcquisitionCost: customerAcquisitionCost,
    customerLifespan: {
      average: (freeLifespan + proLifespan + expertLifespan) / 3,
      free: freeLifespan,
      pro: proLifespan,
      expert: expertLifespan,
    },
    retentionRate: {
      average: retentionRate.average,
      free: retentionRate.free,
      pro: retentionRate.pro,
      expert: retentionRate.expert,
    },
    refund,
    churn,
    userCost,
    conversionRate: {
      total: totalConversionRate.total,
      pro: totalConversionRate.pro,
      expert: totalConversionRate.expert,
    },
    grossMargin,
    marketingSpendEfficiency,
    profitLossMargin: parseFloat(
      (((effectiveRevenue - expenses.total) / expenses.total) * 100).toFixed(1),
    ),
  }
}

export interface AllMetrics {
  mau: {
    total: number
    new: number
    churned: number
    free: number
    pro: number
    expert: number
    customers: number
  }
  monthlyRecurringRevenue: {
    effective: number
    free: number
    pro: number
    expert: number
  }
  annualRecurringRevenue: {
    effective: number
    free: number
    pro: number
    expert: number
  }
  averageRevenuePerUser: {
    total: number
    free: number
    pro: number
    expert: number
  }
  customerLifetimeValue: {
    average: number
    free: number
    pro: number
    expert: number
  }
  customerAcquisitionCost: {
    average: number
    free: number
    pro: number
    expert: number
  }
  customerLifespan: {
    average: number
    free: number
    pro: number
    expert: number
  }
  retentionRate: {
    average: number
    free: number
    pro: number
    expert: number
  }
  refund: {
    total: {
      cost: number
      rate: number
      count: number
    }
    pro: {
      count: number
      cost: number
      rate: number
    }
    expert: {
      count: number
      cost: number
      rate: number
    }
  }
  churn: {
    total: {
      cost: number
      rate: number
      count: number
    }
    free: {
      rate: number
      count: number
    }
    pro: {
      count: number
      cost: number
      rate: number
    }
    expert: {
      count: number
      cost: number
      rate: number
    }
  }
  userCost: CostPerUser
  conversionRate: {
    total: number
    pro: number
    expert: number
  }
  grossMargin: number
  marketingSpendEfficiency: number
  profitLossMargin: number
}
</file>

<file path="apps/admin-dashboard/financials/office.ts">
const OFFICE_SPACE = {
  sqMetersPerEmployee: 8,
  costPerSqMeter: 2360, // averaged from 40 offices in Pune
  maxEmployees: 35, // Maximum number of employees for full office
  costPerEmployee: (haveCoworking: boolean, haveOffice: boolean, employees: number): number => {
    if (haveOffice) {
      const totalSqMeters = OFFICE_SPACE.maxEmployees * OFFICE_SPACE.sqMetersPerEmployee
      return totalSqMeters * OFFICE_SPACE.costPerSqMeter
    } else if (haveCoworking) {
      return 8000 * employees
    } else {
      return 0
    }
  },
  insurance: 50000,
  internet: 2000,
  cleaning: 5000,
  maintenance: 5000,
}

const OFFICE_EXPENSES = {
  supplies: 800,
  utilities: 400,
  snacks: 300,
  misc: 1000,
}

export interface OfficeResult {
  total: number
  officeSpace: number
  supplies: number
  utilities: number
  snacks: number
  miscellaneous: number
  internet: number
  cleaning: number
  insurance: number
  maintenance: number
}

export function calculateOfficeCosts(employees: number): OfficeResult {
  console.log('officeCost1', employees)
  const minEmployeesForCoworking = 10
  const minEmployeesForOffice = 20
  const haveOffice = employees > minEmployeesForOffice
  const haveCoworking = employees > minEmployeesForCoworking && employees < minEmployeesForOffice

  const spaceCost = OFFICE_SPACE.costPerEmployee(haveCoworking, haveOffice, employees)
  const officeSuppliesCost = employees * OFFICE_EXPENSES.supplies
  const utilitiesCost = employees * OFFICE_EXPENSES.utilities
  const snacksCoffeeCost = employees * OFFICE_EXPENSES.snacks
  const miscellaneousCost = employees * OFFICE_EXPENSES.misc

  const internetPhoneCost = haveOffice ? OFFICE_SPACE.internet : 0
  const cleaningServicesCost = haveOffice ? OFFICE_SPACE.cleaning : 0
  const insuranceCost = haveOffice ? OFFICE_SPACE.insurance : 0
  const maintenanceCost = haveOffice ? OFFICE_SPACE.maintenance : 0

  const total
    = spaceCost
    + officeSuppliesCost
    + utilitiesCost
    + snacksCoffeeCost
    + miscellaneousCost
    + internetPhoneCost
    + cleaningServicesCost
    + insuranceCost
    + maintenanceCost

  console.log('officeCost', {
    total,
    spaceCost,
    officeSuppliesCost,
    utilitiesCost,
    snacksCoffeeCost,
    miscellaneousCost,
    internetPhoneCost,
    cleaningServicesCost,
    insuranceCost,
    maintenanceCost,
  })

  return {
    total: parseInt(total.toFixed(0)),
    officeSpace: parseInt(spaceCost.toFixed(0)),
    supplies: parseInt(officeSuppliesCost.toFixed(0)),
    utilities: parseInt(utilitiesCost.toFixed(0)),
    snacks: parseInt(snacksCoffeeCost.toFixed(0)),
    miscellaneous: parseInt(miscellaneousCost.toFixed(0)),
    internet: parseInt(internetPhoneCost.toFixed(0)),
    cleaning: parseInt(cleaningServicesCost.toFixed(0)),
    insurance: parseInt(insuranceCost.toFixed(0)),
    maintenance: parseInt(maintenanceCost.toFixed(0)),
  }
}
</file>

<file path="apps/admin-dashboard/financials/payments.ts">
import { USD2INR } from './helpers'

type PaymentProvider = 'Razorpay' | 'Stripe'
type SubscriptionType = 'Pro' | 'Expert'
type PaymentFrequency = 'Monthly' | 'Annual'

type DomesticPaymentMethod = 'Visa' | 'MasterCard' | 'UPI'
type InternationalPaymentMethod = 'MasterCardVisa' | 'AmericanExpress' | 'InternationalCard'

const subscriptionPrices: Record<SubscriptionType, number> = {
  Pro: 20,
  Expert: 50,
}

const paymentMethodDistribution = {
  domestic: {
    Visa: 25,
    MasterCard: 15,
    UPI: 60,
  },
  international: {
    MasterCardVisa: 50,
    AmericanExpress: 30,
    InternationalCard: 20,
  },
}

function distributeCustomers(
  numCustomers: number,
  distribution: Record<string, number>,
): Record<string, number> {
  const result: Record<string, number> = {}
  let totalAssigned = 0
  let fractionalPart = 0

  Object.keys(distribution).forEach((method, index, array) => {
    const proportion = distribution[method] / 100
    const calculated = numCustomers * proportion + fractionalPart
    const count = Math.floor(calculated)

    fractionalPart = calculated - count // Keep track of fractional part for more precise distribution
    result[method] = count
    totalAssigned += count

    // Distribute any remaining customers more evenly
    if (index === array.length - 1 && totalAssigned < numCustomers) {
      result[method] += numCustomers - totalAssigned
    }
  })

  return result
}

const razorpayConfig = {
  platformFeePercentage: 0.02,
  gstPercentage: 0.18,
  subscription: {
    Visa: {
      baseFeePercentage: 0.009,
      additionalFees1kInrPlus: {
        registration: 7,
        autoDebit: 17,
      },
    },
    MasterCard: {
      baseFeePercentage: 0.005,
      additionalFees1kInrPlus: {
        registration: 7,
        autoDebit: 17,
      },
    },
    UPI: {
      baseFeePercentage: 0.0099,
      additionalFees1kInrPlus: {
        registration: 7,
        autoDebit: 17,
      },
    },
  },
}

const stripeConfig = {
  international: {
    MasterCardVisa: {
      platformFeePercentage: 0.03,
      conversionFeePercentage: 0.02,
    },
    AmericanExpress: {
      platformFeePercentage: 0.035,
      conversionFeePercentage: 0.02,
    },
    InternationalCard: {
      platformFeePercentage: 0.043,
      conversionFeePercentage: 0.02,
    },
  },
  billing: {
    subscriptionFeePercentage: 0.007,
  },
}

interface PaymentCostsInput {
  numCustomers: number
  priceInUSD: number
  subscriptionFee: number
  platformFee: number
  gst: number
  additionalFees:
    | {
      registration: number
      autoDebit: number
    }
    | { conversionFee: number }
}

interface PaymentCosts {
  numCustomers: number
  totalCost: number
  percentage: number
  fees: {
    platform: number
    subscription: number
    gst: number
    additionalFees: number
  }
}

function calculatePaymentCosts({
  numCustomers,
  priceInUSD,
  subscriptionFee,
  platformFee,
  gst,
  additionalFees,
}: PaymentCostsInput): PaymentCosts {
  const platformCost = USD2INR(priceInUSD * platformFee)
  const subscriptionCost = USD2INR(priceInUSD * subscriptionFee)
  const gstCost = (platformCost + subscriptionCost) * gst

  let costPerCustomer = platformCost + gstCost + subscriptionCost
  let extraCost = 0

  if ('conversionFee' in additionalFees) {
    const conversionFee = USD2INR(priceInUSD * additionalFees.conversionFee)
    extraCost += conversionFee
    costPerCustomer += conversionFee
  } else {
    extraCost = additionalFees.registration + additionalFees.autoDebit
    costPerCustomer += extraCost
  }

  return {
    numCustomers,
    totalCost: costPerCustomer * numCustomers,
    percentage: (costPerCustomer / priceInUSD) * 100,
    fees: {
      platform: platformCost * numCustomers,
      subscription: subscriptionCost * numCustomers,
      gst: gstCost * numCustomers,
      additionalFees: extraCost * numCustomers,
    },
  }
}

interface PlatformFeesInput {
  numCustomers: number
  paymentMethod: DomesticPaymentMethod | InternationalPaymentMethod
  amountInUSD: number
  frequency: PaymentFrequency
}

// Stripe

function calculateFees({
  numCustomers,
  paymentMethod,
  amountInUSD,
  frequency,
}: PlatformFeesInput): PaymentCosts {
  let subscriptionFee, platformFee, additionalFees, gst

  if (paymentMethod in razorpayConfig.subscription) {
    // Handle Razorpay fees
    const methodConfig = razorpayConfig.subscription[paymentMethod as DomesticPaymentMethod]
    platformFee = razorpayConfig.platformFeePercentage
    subscriptionFee = methodConfig.baseFeePercentage
    additionalFees = methodConfig.additionalFees1kInrPlus // Specific for Razorpay domestic methods
    gst = (platformFee + subscriptionFee) * razorpayConfig.gstPercentage
  } else {
    // Handle Stripe fees
    const methodConfig = stripeConfig.international[paymentMethod as InternationalPaymentMethod]
    platformFee = methodConfig.platformFeePercentage
    subscriptionFee = stripeConfig.billing.subscriptionFeePercentage // Using a generic subscription fee for all Stripe methods
    additionalFees = { conversionFee: methodConfig.conversionFeePercentage } // Specific for Stripe international methods
    gst = 0
  }

  // Call calculatePaymentCosts for detailed fee calculation
  return calculatePaymentCosts({
    numCustomers,
    priceInUSD: amountInUSD,
    subscriptionFee,
    platformFee,
    gst,
    additionalFees,
  })
}

function getRandomInt(min: number, max: number): number {
  min = Math.ceil(min)
  max = Math.floor(max)
  return Math.floor(Math.random() * (max - min + 1)) + min
}

interface HandleSubscriptionParams {
  numCustomers: {
    pro: number
    expert: number
  }
  isInternational: boolean
  frequency: PaymentFrequency
}

export function handleSubscriptions({
  numCustomers,
  isInternational,
  frequency,
}: HandleSubscriptionParams): ProviderChunk {
  const paymentDistribution = isInternational
    ? paymentMethodDistribution.international
    : paymentMethodDistribution.domestic

  const proDistribution = distributeCustomers(numCustomers.pro, paymentDistribution)
  const expertDistribution = distributeCustomers(numCustomers.expert, paymentDistribution)

  let totalCost = 0
  let totalCustomers = 0
  const provider = isInternational ? 'Stripe' : 'Razorpay'

  const combinedResults: TransactionChunk[] = []

  console.log('Distributed Customers:', proDistribution, expertDistribution)

  Object.keys(paymentDistribution).forEach((paymentMethod) => {
    const proCount = proDistribution[paymentMethod] || 0
    const expertCount = expertDistribution[paymentMethod] || 0

    const blankTransaction = {
      totalCost: 0,
      numCustomers: 0,
      percentage: 0,
      fees: {
        platform: 0,
        subscription: 0,
        gst: 0,
        additionalFees: 0,
      },
    }

    if (proCount > 0 || expertCount > 0) {
      const transactionDetailsPro = calculateFees({
        numCustomers: proCount,
        paymentMethod: paymentMethod as DomesticPaymentMethod | InternationalPaymentMethod,
        amountInUSD: subscriptionPrices.Pro,
        frequency,
      })

      const transactionDetailsExpert = calculateFees({
        numCustomers: expertCount,
        paymentMethod: paymentMethod as DomesticPaymentMethod | InternationalPaymentMethod,
        amountInUSD: subscriptionPrices.Expert,
        frequency,
      })

      totalCost += transactionDetailsPro.totalCost + transactionDetailsExpert.totalCost
      totalCustomers += proCount + expertCount
      combinedResults.push({
        paymentMethod: paymentMethod as DomesticPaymentMethod | InternationalPaymentMethod,
        methodCost: transactionDetailsPro.totalCost + transactionDetailsExpert.totalCost,
        methodCustomers: proCount + expertCount,
        frequency,
        pro: transactionDetailsPro,
        expert: transactionDetailsExpert,
      })
    } else {
      combinedResults.push({
        paymentMethod: paymentMethod as DomesticPaymentMethod | InternationalPaymentMethod,
        methodCost: 0,
        methodCustomers: 0,
        frequency,
        pro: blankTransaction,
        expert: blankTransaction,
      })
    }
  })

  return {
    provider,
    totalCustomers,
    totalCost,
    transactions: combinedResults,
  }
}

interface SimulatePurchasesParams {
  newCustomers: {
    pro: number
    expert: number
  }
  frequency: PaymentFrequency
}

export function simulateRealWorldPurchases({
  newCustomers,
  frequency,
}: SimulatePurchasesParams): TransactionDetails {
  const razorpayPercentage = getRandomInt(50, 60)
  const stripePercentage = 100 - razorpayPercentage

  const razorpayProCustomers = Math.floor(newCustomers.pro * (razorpayPercentage / 100))
  const stripeProCustomers = newCustomers.pro - razorpayProCustomers

  const razorpayExpertCustomers = Math.floor(newCustomers.expert * (razorpayPercentage / 100))
  const stripeExpertCustomers = newCustomers.expert - razorpayExpertCustomers

  const razorpayTransactions = handleSubscriptions({
    numCustomers: {
      pro: razorpayProCustomers,
      expert: razorpayExpertCustomers,
    },
    isInternational: false,
    frequency,
  })

  const stripeTransaction = handleSubscriptions({
    numCustomers: {
      pro: stripeProCustomers,
      expert: stripeExpertCustomers,
    },
    isInternational: true,
    frequency,
  })

  return {
    totalCost: razorpayTransactions.totalCost + stripeTransaction.totalCost,
    totalCustomers: razorpayTransactions.totalCustomers + stripeTransaction.totalCustomers,
    razorpay: razorpayTransactions,
    stripe: stripeTransaction,
  }
}

export interface TransactionDetails {
  totalCost: number
  totalCustomers: number
  razorpay: ProviderChunk
  stripe: ProviderChunk
}

export interface ProviderChunk {
  provider: PaymentProvider
  totalCustomers: number
  totalCost: number
  transactions: TransactionChunk[]
}

export interface TransactionChunk {
  paymentMethod: DomesticPaymentMethod | InternationalPaymentMethod
  frequency: PaymentFrequency
  methodCost: number
  methodCustomers: number
  pro: PaymentCosts
  expert: PaymentCosts
}
</file>

<file path="apps/admin-dashboard/financials/software.ts">
import { ROUND0, USD2INR } from './helpers'

type Subscription = {
  name: string
  baseCost: number
  seatCost: number
  annualDiscount: number
  seatRatio: number
}

const SOFTWARE: Subscription[] = [
  {
    name: 'ChatGPT',
    baseCost: 30,
    seatCost: 30,
    annualDiscount: 5,
    seatRatio: 1,
  },
  {
    name: 'GitHub Teams',
    baseCost: 4,
    seatCost: 4,
    annualDiscount: 0,
    seatRatio: 0.65,
  },
  {
    name: 'GitHub Copilot',
    baseCost: 19,
    seatCost: 19,
    annualDiscount: 0,
    seatRatio: 0.65,
  },
  {
    name: 'Adobe',
    baseCost: 25,
    seatCost: 25,
    annualDiscount: 0,
    seatRatio: 0.15,
  },
  {
    name: 'Google Business',
    baseCost: 7.2,
    seatCost: 7.2,
    annualDiscount: 0,
    seatRatio: 1,
  },
  {
    name: 'Posthog',
    baseCost: 0,
    seatCost: 19,
    annualDiscount: 0,
    seatRatio: 0.15,
  },
]

function calculateMonthlyCost(subscription: Subscription, seats: number): number {
  return USD2INR(subscription.baseCost + subscription.seatCost * seats)
}

function calculateAnnualCost(subscription: Subscription, seats: number): number {
  return (subscription.seatCost - subscription.annualDiscount) * seats
}

export interface SoftwareCosts {
  totalCost: number
  serviceCosts: {
    name: string
    seats: number
    cost: number
  }[]
}

export function calculateSubscriptionCosts(totalEmployees: number): SoftwareCosts {
  const serviceCosts = []
  let totalCost = 0
  for (const subscription of SOFTWARE) {
    const numberOfSeats = ROUND0(Math.ceil(totalEmployees * subscription.seatRatio))
    const cost = calculateMonthlyCost(subscription, numberOfSeats)
    totalCost += cost
    serviceCosts.push({ name: subscription.name, seats: numberOfSeats, cost: ROUND0(cost) })
    // const annualCost = calculateAnnualCost(subscription, numberOfSeats);
  }

  return { totalCost: ROUND0(totalCost), serviceCosts }
}
</file>

<file path="apps/admin-dashboard/financials/storage.ts">
import type { Content, ContentParams } from './totals'
import { USD2INR } from './helpers'

export const SUPABASE_CONFIG = {
  pro: {
    basePrice: 25,
    mauIncluded: 100000,
    mauPrice: 0.00325,
    dbIncludedGB: 8,
    dbPricePerGB: 0.125,
    bandwidthIncludedGB: 250,
    bandwidthPricePerGB: 0.09,
    storageIncludedGB: 100,
    storagePricePerGB: 0.021,
  },
}

type SBPlan =
  | 'nano'
  | 'micro'
  | 'small'
  | 'medium'
  | 'large'
  | 'xl'
  | '2xl'
  | '4xl'
  | '8xl'
  | '12xl'
  | '16xl'

export const SUPABASE_COMPUTE_CONFIG = {
  plans: {
    'nano': {
      hourly: 0,
      monthly: 0,
      cpu: 'Shared',
      memory: 'Up to 0.5 GB',
      directConnections: 60,
      poolerConnections: 200,
      maxDbSizeGB: 0.5,
    },
    'micro': {
      hourly: 0.01344,
      monthly: 10,
      cpu: '2-core ARM (shared)',
      memory: '1 GB',
      directConnections: 60,
      poolerConnections: 200,
      maxDbSizeGB: 10,
    },
    'small': {
      hourly: 0.0206,
      monthly: 15,
      cpu: '2-core ARM (shared)',
      memory: '2 GB',
      directConnections: 90,
      poolerConnections: 400,
      maxDbSizeGB: 50,
    },
    'medium': {
      hourly: 0.0822,
      monthly: 60,
      cpu: '2-core ARM (shared)',
      memory: '4 GB',
      directConnections: 120,
      poolerConnections: 600,
      maxDbSizeGB: 100,
    },
    'large': {
      hourly: 0.1517,
      monthly: 110,
      cpu: '2-core ARM (dedicated)',
      memory: '8 GB',
      directConnections: 160,
      poolerConnections: 800,
      maxDbSizeGB: 200,
    },
    'xl': {
      hourly: 0.2877,
      monthly: 210,
      cpu: '4-core ARM (dedicated)',
      memory: '16 GB',
      directConnections: 240,
      poolerConnections: 1000,
      maxDbSizeGB: 500,
    },
    '2xl': {
      hourly: 0.562,
      monthly: 410,
      cpu: '8-core ARM (dedicated)',
      memory: '32 GB',
      directConnections: 380,
      poolerConnections: 1500,
      maxDbSizeGB: 1000,
    },
    '4xl': {
      hourly: 1.32,
      monthly: 960,
      cpu: '16-core ARM (dedicated)',
      memory: '64 GB',
      directConnections: 480,
      poolerConnections: 3000,
      maxDbSizeGB: 2000,
    },
    '8xl': {
      hourly: 2.562,
      monthly: 1870,
      cpu: '32-core ARM (dedicated)',
      memory: '128 GB',
      directConnections: 490,
      poolerConnections: 6000,
      maxDbSizeGB: 4000,
    },
    '12xl': {
      hourly: 3.836,
      monthly: 2800,
      cpu: '48-core ARM (dedicated)',
      memory: '192 GB',
      directConnections: 500,
      poolerConnections: 9000,
      maxDbSizeGB: 6000,
    },
    '16xl': {
      hourly: 5.12,
      monthly: 3730,
      cpu: '64-core ARM (dedicated)',
      memory: '256 GB',
      directConnections: 500,
      poolerConnections: 12000,
      maxDbSizeGB: 10000,
    },
  },
}

const VECTOR_SIZES = {
  large: 1536,
  small: 724,
}

const AVG_CHARS_PER_WORD = 4.7
const BYTES_PER_GB = 1024 ** 3

export function calculateVectorStorage(
  vectorSize: number,
  numItems: number,
  isBinary: boolean = false,
): number {
  const bytesPerItem = isBinary ? Math.ceil(vectorSize / 8) : vectorSize * 4
  const totalBytes = bytesPerItem * numItems
  const totalGB = totalBytes / BYTES_PER_GB
  return parseFloat(totalGB.toFixed(3))
}

export function calculateContentStorage(numItems: number, contentChars: number): number {
  const bytesPerItem = contentChars
  const totalBytes = bytesPerItem * numItems
  const totalGB = totalBytes / BYTES_PER_GB
  return parseFloat(totalGB.toFixed(3))
}

type SupabaseCostParams = {
  monthlyActiveUsers: number
  dbStorageGB: number
  bandwidthGB: number
  fileStorageGB: number
}

type ComputeCostParams = {
  plan: SBPlan
  hoursUsed: number
}

function calculateComputeCost(params: ComputeCostParams): {
  total: number
  hourly: number
  monthly: number
} {
  const { plan, hoursUsed } = params
  const planDetails = SUPABASE_COMPUTE_CONFIG.plans[plan]

  if (!planDetails) {
    throw new Error('Unsupported compute plan')
  }

  const hourlyCost = planDetails.hourly * hoursUsed
  const monthlyCost = planDetails.monthly
  return {
    total: hourlyCost + monthlyCost,
    hourly: hourlyCost,
    monthly: monthlyCost,
  }
}

interface SupabaseCostBreakdown {
  total: number
  base: number
  mau: number
  dbStorage: number
  bandwidth: number
  fileStorage: number
}

function calculateStorageCost(params: SupabaseCostParams): SupabaseCostBreakdown {
  const { monthlyActiveUsers, dbStorageGB, bandwidthGB, fileStorageGB } = params

  const {
    basePrice,
    mauIncluded,
    mauPrice,
    dbIncludedGB,
    dbPricePerGB,
    bandwidthIncludedGB,
    bandwidthPricePerGB,
    storageIncludedGB,
    storagePricePerGB,
  } = SUPABASE_CONFIG.pro

  const additionalMauCost
    = monthlyActiveUsers > mauIncluded ? (monthlyActiveUsers - mauIncluded) * mauPrice : 0

  const additionalDbStorageCost
    = dbStorageGB > dbIncludedGB ? (dbStorageGB - dbIncludedGB) * dbPricePerGB : 0

  const additionalBandwidthCost
    = bandwidthGB > bandwidthIncludedGB
      ? (bandwidthGB - bandwidthIncludedGB) * bandwidthPricePerGB
      : 0

  const additionalFileStorageCost
    = fileStorageGB > storageIncludedGB ? (fileStorageGB - storageIncludedGB) * storagePricePerGB : 0

  const totalCost
    = basePrice
    + additionalMauCost
    + additionalDbStorageCost
    + additionalBandwidthCost
    + additionalFileStorageCost

  return {
    total: parseFloat(totalCost.toFixed(3)),
    base: parseFloat(basePrice.toFixed(3)),
    mau: parseFloat(additionalMauCost.toFixed(3)),
    dbStorage: parseFloat(additionalDbStorageCost.toFixed(3)),
    bandwidth: parseFloat(additionalBandwidthCost.toFixed(3)),
    fileStorage: parseFloat(additionalFileStorageCost.toFixed(3)),
  }
}

function determineComputePlan(dbStorageGB: number): SBPlan {
  console.log('DB Storage:', dbStorageGB)
  const plans = Object.keys(SUPABASE_COMPUTE_CONFIG.plans) as SBPlan[]
  for (const plan of plans) {
    const maxDbSize = SUPABASE_COMPUTE_CONFIG.plans[plan].maxDbSizeGB
    if (dbStorageGB <= maxDbSize) {
      return plan
    }
  }
  return '16xl'
}

interface StorageResult {
  total: number
  db: number
  vector: number
  details: {
    content: {
      type: string
      count: number
      avgChars: number
      totalChars: number
    }
    storage: {
      total: number
      db: number
      vector: number
    }
  }[]
}

function calculateStorageUsage(
  contentParams: ContentParams[],
  currentMonth: number,
): StorageResult {
  let totalDbStorageGB = 0
  let totalVectorStorageGB = 0

  const details = []

  for (const { CONTENT_TYPE, TOTAL, CHARS, PROCESSED } of contentParams) {
    // console.log('DATABASE', CONTENT_TYPE, TOTAL, WORDS, PROCESSED)
    const contentStorage = calculateContentStorage(TOTAL, CHARS.CONTENT + CHARS.OUTPUT)
    const vectorStorage = calculateVectorStorage(VECTOR_SIZES.large, CHARS.CHUNKS * PROCESSED)

    totalDbStorageGB += contentStorage
    totalVectorStorageGB += vectorStorage

    details.push({
      content: {
        type: CONTENT_TYPE,
        count: TOTAL,
        avgChars: CHARS.CONTENT,
        totalChars: CHARS.CONTENT * TOTAL,
        totalChunks: CHARS.CHUNKS * TOTAL,
      },
      storage: {
        total: contentStorage + vectorStorage,
        db: contentStorage,
        vector: vectorStorage,
      },
    })
  }

  return {
    total: parseFloat((totalDbStorageGB + totalVectorStorageGB).toFixed(3)),
    db: parseFloat(totalDbStorageGB.toFixed(3)),
    vector: parseFloat(totalVectorStorageGB.toFixed(3)),
    details,
  }
}

export function calculateSupabaseCosts(
  mau: number,
  currentMonth: number,
  contentParams: ContentParams[],
): StorageCostResult {
  console.log('Content Params:', contentParams, mau)
  const storage = calculateStorageUsage(contentParams, currentMonth)
  const computePlan = determineComputePlan(storage.total)

  console.log('Compute Plan:', computePlan)

  const computeCost = calculateComputeCost({
    plan: computePlan,
    hoursUsed: 730, // Assuming 24/7 usage, can we make dynamic?
  })

  // Calculate bandwidth and file storage dynamically based on MAU
  // EXTRACT
  const bandwidthGB = Math.max(250, mau * 0.05)
  const fileStorageGB = Math.max(100, mau * 0.01)

  const storageCost = calculateStorageCost({
    monthlyActiveUsers: mau,
    dbStorageGB: storage.total,
    bandwidthGB,
    fileStorageGB,
  })

  return {
    totalCost: USD2INR(computeCost.total + storageCost.total),
    storage: {
      cost: {
        total: USD2INR(storageCost.total),
        base: USD2INR(storageCost.base),
        mau: USD2INR(storageCost.mau),
        db: USD2INR(storageCost.dbStorage),
        bandwidth: USD2INR(storageCost.bandwidth),
        fileStorage: USD2INR(storageCost.fileStorage),
      },
      data: storage,
    },
    compute: {
      plan: computePlan,
      cost: {
        total: USD2INR(computeCost.total),
        hourly: USD2INR(computeCost.hourly),
        monthly: USD2INR(computeCost.monthly),
      },
    },
  }
}

export interface StorageCostResult {
  totalCost: number
  storage: {
    cost: {
      total: number
      base: number
      mau: number
      db: number
      bandwidth: number
      fileStorage: number
    }
    data: StorageResult
  }
  compute: {
    plan: SBPlan
    cost: {
      total: number
      hourly: number
      monthly: number
    }
  }
}
</file>

<file path="apps/admin-dashboard/financials/totals.ts">
import fs from 'fs/promises'
import path from 'path'
import { calculateSupabaseCosts } from './storage'
import { calculateAiCost, COST_CONFIG } from './gpt'
import { calculateDigitalOceanCost } from './digital-ocean'
import { calculateLogsCost, type LoggingResult } from './logging'
import { calculateDevopsCosts } from './dev-ops'
import { calculateEmployeeCost } from './employee'
import { calculateSubscriptionCosts, type SoftwareCosts } from './software'
import { calculateOfficeCosts } from './office'
import { calculateInitialLoan, calculateRemainingBalance } from './capital'
import { calculateRevenue, INCOME_STREAMS } from './customers'
import { calculateAllMetrics } from './metrics'
import { generateInfo } from './gen-info'
import { calculateCostPerUser } from './metrics-users'
import { calculateMarketingCost } from './marketing'
import { simulateRealWorldPurchases, type TransactionDetails } from './payments'
import { calculateAnalyticsCost, type AnalyticsResult } from './analytics'

import type { AllMetrics } from './metrics'
import type { CapitalResult, LoanResult } from './capital'
import type { StorageCostResult } from './storage'
import type { DigitalOceanResult } from './digital-ocean'
import type { DevopsResult } from './dev-ops'
import type { OfficeResult } from './office'
import type { EmployeeResult } from './employee'
import type { AiCostResult } from './gpt'
import type { RevenueResult } from './customers'
import type { InfoResult } from './gen-info'

import {
  EFFICIENCY_FACTOR,
  CHURN_TO_LIFESPAN_MONTHS,
  WORDS_TO_CHAR_CHUNKS,
  WORDS_TO_CHARS,
} from './helpers'

// set hard limits for devops usage

// we should cap free users usage wherever possible, removing any paid services if possible.

// Consider capping the total number of free users for different stages, eg Alpha, Beta, etc.

// only run this function once, use a button to trigger it

// extract configs where possible, should be easy to update in one place

// Try to narrow down the margin per user, how many free users will be paid users allow.
// This can be used to create our minimum conversion threshold

// include daily active users, this can be used to narrow down the difference between highly active users and slightly active users.

// incorporate discounts / promotions for free use of paid products, trials etc.
// Calculate revenue per user in each tier, for example free / pro / expert. free will still generate revenue through ads, etc.

// estimate Customer Acquisition Cost (CAC): Cost to acquire a new paying user. (use cost based on employee, software and average)
// estimate Customer Lifetime Value (CLV): Revenue generated by a user over their lifetime. (need to research averages)
// We need to factor in a payment gateway and any associated costs
// Mailchimp or some other email marketing platform should be considered
// Email automation for supabase signups, sendgrid is what we use (I think)
// switch to Cloudflare for the CDN, this will save vs Vercel
// Sentry for error tracking, may not need if we can use BetterStack
// Break-even Point try to calculate this exactly, so we can display on a chart
// seperate expenses into Fixed Costs, Variable Costs, Infrastructure, Third-Party Service, Support

// STILL TO FIX
// Razorpay is only showing transactions to the 21st month
// input and output cost for GPT is the same??

export type CompanyStage = 'start' | 'growth' | 'scaling' | 'secure'
export type Content = 'NEWS' | 'RESEARCH_ABSTRACTS' | 'RESEARCH_PAPERS' | 'JOBS' | 'COMPANIES'
export type StageConfig = Record<Content, ProcessdContentConfig>

export type ContentScalingRules = {
  [key in Content]: {
    totalContentStored: number
    totalVectorStored: number
    sourceGrowthRate: number // Growth rate for sources
    additionsGrowthRate: number // Growth rate for per source additions
    monthlyProcessingGrowthRate: number // Growth rate for monthly processed items
  }
}

function scaleContentConfig(
  CONTENT_CONFIG: StageConfig,
  currentMonth: number,
  rules: ContentScalingRules,
): StageConfig {
  const scaledConfig: StageConfig = JSON.parse(JSON.stringify(CONTENT_CONFIG)) // Deep copy to avoid mutations

  for (const contentType in scaledConfig) {
    const content = scaledConfig[contentType as keyof StageConfig]
    const rule = rules[contentType as Content]

    // Calculate scaling factors for the month
    const sourceFactor = 1 + rule.sourceGrowthRate * currentMonth
    const additionsFactor = 1 + rule.additionsGrowthRate * currentMonth
    const monthlyProcessingFactor = 1 + rule.monthlyProcessingGrowthRate * currentMonth

    // console.log('Scaling Factors:', sourceFactor, additionsFactor, monthlyProcessingFactor)

    if (currentMonth === 1) {
      // Initialize totals for the first month
      rule.totalVectorStored = content.PROCESSED
      rule.totalContentStored = content.TOTAL
    }

    // Scale the sources and per source additions
    content.SOURCES = Math.ceil(content.SOURCES * sourceFactor)
    content.PER_SOURCE_ADDITIONS = Math.ceil(content.PER_SOURCE_ADDITIONS * additionsFactor)

    // Calculate new content added and processed this month
    const newContentAdded = content.SOURCES * content.PER_SOURCE_ADDITIONS
    const newContentProcessed = Math.ceil(content.PROCESSED_MONTHLY * monthlyProcessingFactor)

    // Update total content and vectors stored
    rule.totalContentStored += newContentAdded
    rule.totalVectorStored += newContentProcessed

    // Update the content configuration
    content.PROCESSED_MONTHLY = newContentProcessed
    content.PROCESSED = rule.totalVectorStored
    content.TOTAL = rule.totalContentStored
  }

  console.log('Scaled Content Config for Month:', currentMonth, scaledConfig)
  return scaledConfig
}

function determineCompanyStage(mau: number): CompanyStage {
  if (mau < 10000) return 'start'
  if (mau < 100000) return 'growth'
  if (mau < 500000) return 'scaling'
  return 'secure'
}

interface Growth {
  mau: {
    total: number
    new: number
    existing: number
    churned: number
  }
  revenue: RevenueResult
}

interface AllCost {
  totals: {
    monthlyINR: number
    employees: number
    office: number
    storage: number
    digitalOcean: number
    logging: number
    devOps: number
    openAI: number
    loan: number
    analytics: number
    marketing: number
    software: number
    payments: number
  }
  employees: EmployeeResult
  office: OfficeResult
  storage: StorageCostResult
  digitalOcean: DigitalOceanResult
  logging: LoggingResult
  devOps: DevopsResult
  openAI: AiCostResult
  loan: LoanResult
  analytics: AnalyticsResult
  software: SoftwareCosts
  payments: TransactionDetails
}

export type ContentParams = {
  CONTENT_TYPE: Content
  TOTAL: number
  PROCESSED: number
  CHARS: {
    CONTENT: number
    CHUNKS: number
    PROMPT: number
    OUTPUT: number
  }
}

const AVG_MAU_USAGE = 0.01

export interface AllData {
  mau: any[]
  customers: any[]
  capital: CapitalResult[]
  revenue: RevenueResult[]
  affiliate: any[]
  advertising: any[]
  promotion: any[]
  totals: any[]
  employees: any[]
  office: any[]
  storage: any[]
  digitalOcean: any[]
  logging: any[]
  analytics: any[]
  software: SoftwareCosts[]
  devOps: any[]
  payments: any[]
  openAI: any[]
  metrics: AllMetrics[]
  months: number[]
  stages: CompanyStage[]
}

export function calculateBusinessMetrics(params: BusinessMetricsConfig): AllData {
  const allData: AllData = {
    mau: [],
    customers: [],
    capital: [],
    revenue: [],
    affiliate: [],
    advertising: [],
    promotion: [],
    totals: [],
    employees: [],
    office: [],
    storage: [],
    digitalOcean: [],
    logging: [],
    analytics: [],
    devOps: [],
    software: [],
    payments: [],
    openAI: [],
    metrics: [],
    months: [],
    stages: [],
  }

  let previousMonth = {
    revenue: 0,
    effectiveRevenue: 0,
    expenses: 0,
    balance: 0,
    mau: {
      total: 0,
      new: 0,
      churned: 0,
      churnRate: 0,
    },
    customers: {
      all: 0,
      pro: 0,
      expert: 0,
    },
  }

  for (let month = 1; month <= params.PROJECTION.MONTHS; month++) {
    const marketingCost = calculateMarketingCost({
      mrr: previousMonth.revenue,
      percentage: params.MRR_MARKETING_PERCENTAGE_SPEND,
    })

    const scaledContentConfig = scaleContentConfig(
      params.CONTENT_CONFIG,
      month,
      params.SCALING_RULES,
    )

    // Calculate new MAU
    let mau = Math.ceil(
      previousMonth.mau.total * (1 + params.PROJECTION.MONTHLY_GROWTH_RATE)
      + params.PROJECTION.MANUAL_GROWTH_RATE * month,
    )

    const churnedMAU = Math.ceil(previousMonth.mau.total * previousMonth.mau.churnRate)
    const newMAU = mau - (previousMonth.mau.total - churnedMAU)
    mau -= churnedMAU

    const companyStage = determineCompanyStage(previousMonth.mau.total)

    const revenue = calculateRevenue({
      mau: {
        total: mau,
        new: newMAU,
      },
      customers: {
        pro: previousMonth.customers.pro,
        expert: previousMonth.customers.expert,
      },
    })

    const payments = simulateRealWorldPurchases({
      newCustomers: {
        pro: revenue.customers.pro.new,
        expert: revenue.customers.expert.new,
      },
      frequency: 'Monthly',
    })

    const logging = calculateLogsCost({
      MAU: mau,
      avgMauUsage: AVG_MAU_USAGE,
      month,
      teamMembers: 1,
    })
    const devOps = calculateDevopsCosts(mau)
    const openAI = calculateAiCost({
      mau,
      customers: {
        pro: revenue.customers.pro.count,
        expert: revenue.customers.expert.count,
      },
      isBatch: false,
      CONTENT_CONFIG: scaledContentConfig,
    })

    const contentParams = Object.entries(scaledContentConfig).map(
      ([contentType, contentConfig]) => ({
        CONTENT_TYPE: contentType as Content,
        CHARS: contentConfig.CHARS,
        TOTAL: contentConfig.TOTAL,
        PROCESSED: contentConfig.PROCESSED,
      }),
    )
    const supabase = calculateSupabaseCosts(mau, month, contentParams)

    const analytics = calculateAnalyticsCost({
      MAU: mau,
      month,
      avgMauUsage: 300,
    })

    const employees = calculateEmployeeCost({
      mau,
      stage: companyStage,
      month: month,
      bootstrapMonths: params.BOOTSTRAP_MONTHS,
    })

    const office = calculateOfficeCosts(employees.totalCount)
    const digitalOcean = calculateDigitalOceanCost({ bandwidthGB: supabase.storage.data.total * 2 })
    const devOpsCost = mau > 100_000 ? devOps.inhouse.cost.total : devOps.vercel.cost.total
    const software = calculateSubscriptionCosts(employees.totalCount)

    const userExpenses
      = supabase.totalCost
      + digitalOcean.cost
      + logging.total
      + devOpsCost
      + analytics.total
      + marketingCost

    const monthlyExpenses
      = employees.totalCost
      + supabase.totalCost
      + devOpsCost
      + digitalOcean.cost
      + logging.total
      + openAI.cost.total
      + office.total
      + analytics.total
      + software.totalCost
      + marketingCost
      + payments.totalCost

    console.log('Monthly Expenses:', {
      employees: employees.totalCost,
      supabase: supabase.totalCost,
      devOps: devOpsCost,
      digitalOcean: digitalOcean.cost,
      logging: logging.total,
      openAI: openAI.cost.total,
      office: office.total,
      analytics: analytics.total,
      software: software.totalCost,
      marketing: marketingCost,
      payments: payments.totalCost,
    })

    const totalCustomers = revenue.customers.pro.count + revenue.customers.expert.count
    const metrics = calculateAllMetrics({
      marketing: {
        cost: marketingCost,
        leads: 0,
      },
      currentMonth: month,
      expenses: {
        total: monthlyExpenses,
        free: userExpenses + openAI.chat.free.cost.total,
        pro: userExpenses + openAI.chat.pro.cost.total,
        expert: userExpenses + openAI.chat.expert.cost.total,
      },
      revenue: {
        free: revenue.total.free,
        pro: revenue.customers.pro.revenue,
        expert: revenue.customers.expert.revenue,
      },
      users: {
        mau,
        free: mau - totalCustomers,
        pro: revenue.customers.pro.count,
        expert: revenue.customers.expert.count,
        totalCustomers: totalCustomers,
        new: newMAU,
        newCustomers: revenue.customers.pro.new + revenue.customers.expert.new,
      },
    })

    const capital = calculateRemainingBalance({
      loan: params.LOAN,
      month,
      initialCapital: params.INITIAL_CAPITAL,
      bootstrapMonths: params.BOOTSTRAP_MONTHS,
      expenses: monthlyExpenses,
      income: metrics.monthlyRecurringRevenue.effective,
    })

    allData.totals.push({
      expenses: {
        total: parseInt(monthlyExpenses.toFixed(0)),
      },
      income: {
        total: revenue.total.revenue,
        effective: metrics.monthlyRecurringRevenue.effective,
      },
      employees: employees.totalCost,
      office: office.total,
      storage: supabase.totalCost,
      digitalOcean: digitalOcean.cost,
      logging: logging.total,
      devOps: devOpsCost,
      openAI: openAI.cost.total,
      loan: capital.loan.monthlyInterestOnlyPayment,
      analytics: analytics.total,
      marketing: marketingCost,
      software: software.totalCost,
      payments: payments.totalCost,
    })
    allData.metrics.push(metrics)
    allData.employees.push(employees)
    allData.office.push(office)
    allData.storage.push(supabase)
    allData.digitalOcean.push(digitalOcean)
    allData.logging.push(logging)
    allData.devOps.push(devOps)
    allData.openAI.push(openAI)
    allData.capital.push(capital)
    allData.analytics.push(analytics)
    allData.software.push(software)
    allData.payments.push(payments)
    allData.revenue.push(revenue)
    allData.customers.push(revenue.customers)
    allData.months.push(month)
    allData.stages.push(companyStage)

    previousMonth = {
      revenue: metrics.monthlyRecurringRevenue.effective,
      effectiveRevenue: metrics.monthlyRecurringRevenue.effective,
      expenses: monthlyExpenses,
      balance: capital.balance.end,
      mau: {
        total: mau,
        new: newMAU,
        churned: churnedMAU,
        churnRate: metrics.churn.free.rate,
      },
      customers: {
        all: totalCustomers,
        pro: revenue.customers.pro.count,
        expert: revenue.customers.expert.count,
      },
    }
  }

  return allData
}

type ScalingRules = {
  [key in Content]: {
    totalContentStored: number
    totalVectorStored: number
    sourceGrowthRate: number
    additionsGrowthRate: number
    monthlyProcessingGrowthRate: number
  }
}

type BusinessMetricsConfig = {
  BOOTSTRAP_MONTHS: number
  INITIAL_CAPITAL: number
  MRR_MARKETING_PERCENTAGE_SPEND: number
  MONTHLY_CHURN: {
    MAU: {
      PESSIMISTIC: number
      OPTIMISTIC: number
    }
    CUSTOMERS: {
      PESSIMISTIC: number
      OPTIMISTIC: number
    }
  }
  CURRENT: {
    MAU: number
    USD_TO_INR: number
    EXPENSES: number
    REVENUE: number
  }
  LOAN: {
    AMOUNT: number
    ANNUAL_INTEREST_RATE: number
    TERM_IN_YEARS: number
  }
  PROJECTION: {
    MONTHS: number
    MONTHLY_GROWTH_RATE: number
    MANUAL_GROWTH_RATE: number
    USAGE_HOURS_PER_DAY: number
    USAGE_GROWTH_FACTOR: number
    MAX_DAILY_USAGE: number
  }
  DEVOPS_USAGE: {
    DATA_TRANSFER_GB: number
    ORIGIN_TRANSFER_GB: number
    EDGE_REQUESTS: number
    MIDDLEWARE_INVOCATIONS: number
    SOURCE_IMAGES: number
    FUNCTION_INVOCATIONS: number
    FUNCTION_DURATION_GB_HOURS: number
    EDGE_FUNCTION_EXECUTIONS: number
    DATA_CACHE_READS: number
    DATA_CACHE_WRITES: number
    EDGE_CONFIG_READS: number
    EDGE_CONFIG_WRITES: number
    MONITORING_EVENTS: number
    SPEED_INSIGHTS_DATA_POINTS: number
    WEB_ANALYTICS_EVENTS: number
  }
  CONTENT_CONFIG: {
    NEWS: ProcessdContentConfig
    // RESEARCH_ABSTRACTS: ProcessdContentConfig
    // RESEARCH_PAPERS: ProcessdContentConfig
    COMPANIES: ProcessdContentConfig
    JOBS: ProcessdContentConfig
  }
  SCALING_RULES: ScalingRules
}

export type ProcessdContentConfig = {
  PROCESSED: number
  TOTAL: number
  SOURCES: number
  PER_SOURCE_ADDITIONS: number
  PROCESSED_MONTHLY: number
  CHARS: {
    CONTENT: number
    CHUNKS: number
    PROMPT: number
    OUTPUT: number
  }
}

export const metricConfig = {
  BOOTSTRAP_MONTHS: 12,
  INITIAL_CAPITAL: 1_40_000,
  MRR_MARKETING_PERCENTAGE_SPEND: 0.1,
  MONTHLY_CHURN: {
    MAU: {
      PESSIMISTIC: 0.1,
      OPTIMISTIC: 0.05,
    },
    PRO: {
      PESSIMISTIC: 0.1,
      OPTIMISTIC: 0.04,
    },
    EXPERT: {
      PESSIMISTIC: 0.09,
      OPTIMISTIC: 0.04,
    },
  },
  CURRENT: {
    MAU: 100,
    USD_TO_INR: 83.4,
    REVENUE: 0,
  },
  LOAN: {
    AMOUNT: 10_00_000,
    ANNUAL_INTEREST_RATE: 0.0,
    TERM_IN_YEARS: 2,
    GRACE_PERIOD: 7,
  },
  PROJECTION: {
    MONTHS: 12,
    MONTHLY_GROWTH_RATE: 0.2,
    MANUAL_GROWTH_RATE: 100,
    USAGE_HOURS_PER_DAY: 0.1,
    USAGE_GROWTH_FACTOR: 0.1,
    MAX_DAILY_USAGE: 1.5,
  },
  DEVOPS_USAGE: {
    DATA_TRANSFER_GB: 0.015,
    ORIGIN_TRANSFER_GB: 0.001,
    EDGE_REQUESTS: 150,
    MIDDLEWARE_INVOCATIONS: 75,
    SOURCE_IMAGES: 0,
    FUNCTION_INVOCATIONS: 75,
    FUNCTION_DURATION_GB_HOURS: 0.08,
    EDGE_FUNCTION_EXECUTIONS: 75,
    DATA_CACHE_READS: 800,
    DATA_CACHE_WRITES: 75,
    EDGE_CONFIG_READS: 50,
    EDGE_CONFIG_WRITES: 0.1,
    MONITORING_EVENTS: 0,
    SPEED_INSIGHTS_DATA_POINTS: 0,
    WEB_ANALYTICS_EVENTS: 0,
  },
  CONTENT_CONFIG: {
    NEWS: {
      PROCESSED: 0,
      TOTAL: 120_000,
      SOURCES: 15,
      PER_SOURCE_ADDITIONS: 30,
      PROCESSED_MONTHLY: 2_000,
      CHARS: {
        CONTENT: WORDS_TO_CHARS(1000),
        CHUNKS: WORDS_TO_CHAR_CHUNKS(1000),
        PROMPT: WORDS_TO_CHARS(100),
        OUTPUT: WORDS_TO_CHARS(240),
      },
    },
    // RESEARCH_ABSTRACTS: {
    //   PROCESSED: 0,
    //   TOTAL: 2_400_000,
    //   SOURCES: 2,
    //   PER_SOURCE_ADDITIONS: 1_300,
    //   PROCESSED_MONTHLY: 10_000,
    //   CHARS: {
    //     CONTENT: WORDS_TO_CHARS(280),
    //     CHUNKS: WORDS_TO_CHAR_CHUNKS(280),
    //     PROMPT: WORDS_TO_CHARS(50),
    //     OUTPUT: WORDS_TO_CHARS(60)
    //   }
    // },
    // RESEARCH_PAPERS: {
    //   PROCESSED: 0,
    //   TOTAL: 1000,
    //   SOURCES: 2,
    //   PER_SOURCE_ADDITIONS: 10_000,
    //   PROCESSED_MONTHLY: 10_000,
    //   CHARS: {
    //     CONTENT: WORDS_TO_CHARS(10_000),
    //     CHUNKS: WORDS_TO_CHAR_CHUNKS(10_000),
    //     PROMPT: WORDS_TO_CHARS(100),
    //     OUTPUT: WORDS_TO_CHARS(400)
    //   }
    // },
    COMPANIES: {
      PROCESSED: 0,
      TOTAL: 4_500,
      SOURCES: 1,
      PER_SOURCE_ADDITIONS: 150,
      PROCESSED_MONTHLY: 500,
      CHARS: {
        CONTENT: WORDS_TO_CHARS(20_000),
        CHUNKS: WORDS_TO_CHAR_CHUNKS(20_000),
        PROMPT: WORDS_TO_CHARS(200),
        OUTPUT: WORDS_TO_CHARS(1_000),
      },
    },
    JOBS: {
      PROCESSED: 0,
      TOTAL: 3_000,
      SOURCES: 5,
      PER_SOURCE_ADDITIONS: 30,
      PROCESSED_MONTHLY: 2_000,
      CHARS: {
        CONTENT: WORDS_TO_CHARS(1_000),
        CHUNKS: WORDS_TO_CHAR_CHUNKS(1_000),
        PROMPT: WORDS_TO_CHARS(120),
        OUTPUT: WORDS_TO_CHARS(100),
      },
    },
  },
  SCALING_RULES: {
    // 0.1 = 10%
    NEWS: {
      totalContentStored: 0,
      totalVectorStored: 0,
      sourceGrowthRate: 0.15,
      additionsGrowthRate: 0.15,
      monthlyProcessingGrowthRate: 0.1,
    },
    // RESEARCH_ABSTRACTS: {
    //   totalContentStored: 0,
    //   totalVectorStored: 0,
    //   sourceGrowthRate: 0.02,
    //   additionsGrowthRate: 0.02,
    //   monthlyProcessingGrowthRate: 0.07
    // },
    // RESEARCH_PAPERS: {
    //   totalContentStored: 0,
    //   totalVectorStored: 0,
    //   sourceGrowthRate: 0.01,
    //   additionsGrowthRate: 0.01,
    //   monthlyProcessingGrowthRate: 0.02
    // },
    COMPANIES: {
      totalContentStored: 0,
      totalVectorStored: 0,
      sourceGrowthRate: 0.005,
      additionsGrowthRate: 0.06,
      monthlyProcessingGrowthRate: 0.05,
    },
    JOBS: {
      totalContentStored: 0,
      totalVectorStored: 0,
      sourceGrowthRate: 0.05,
      additionsGrowthRate: 0.1,
      monthlyProcessingGrowthRate: 0.05,
    },
  },
}

export async function generateBusinessMetrics() {
  const data = calculateBusinessMetrics(metricConfig)

  try {
    // Ensure the directory exists
    await fs.mkdir(path.dirname('./assets/business-financials.json'), { recursive: true })

    // Write the data to a JSON file
    await fs.writeFile('./financials/business-financials.json', JSON.stringify(data, null, 2))
    console.log('Business metrics data has been written to business-metrics.json')
  } catch (error) {
    console.error('Error writing business metrics data to file:', error)
  }
}

// Only run this when called directly
if (require.main === module) {
  generateBusinessMetrics()
}
</file>

<file path="apps/admin-dashboard/layouts/default.vue">
<script setup lang="ts">
const { aeAppUrl } = useRuntimeConfig().public

const adminLinks = ref([
  {
    id: 0,
    label: 'App',
    slug: aeAppUrl,
    icon: 'mdi:application',
  },
  {
    id: 1,
    label: 'Growth',
    slug: '/growth',
    icon: 'mdi:account',
    children: [],
  },
  {
    id: 2,
    label: 'Dashboard',
    slug: '/',
    icon: 'mdi:view-dashboard',
    children: [],
  },
  {
    id: 3,
    label: 'Users',
    slug: '/users',
    icon: 'mdi:account',
    children: [],
  },
  {
    id: 4,
    label: 'Analytics',
    slug: '/analytics',
    icon: 'mdi:chart-bar',
    children: [],
  },
  // {
  //   id: 6,
  //   label: 'BP',
  //   slug: '/business-plan',
  //   icon: 'mdi:chat',
  //   children: [],
  // },

  // {
  //   id: 7,
  //   label: 'Spider',
  //   slug: '/spider',
  //   icon: 'mdi:chat',
  //   children: [],
  // },
  // {
  //   id: 8,
  //   label: 'Cache',
  //   slug: '/redis',
  //   icon: 'mdi:chat',
  //   children: [],
  // },
  {
    id: 9,
    label: 'Errors',
    slug: '/errors',
    icon: 'mdi:bug',
    children: [],
  },
  {
    id: 11,
    label: 'Financials',
    slug: '/financials',
    icon: 'material-symbols:attach-money',
    children: [],
  },
  {
    id: 12,
    label: 'Classifier',
    slug: '/classifier',
    icon: 'mdi:application',
  },
  // {
  //   id: 11,
  //   label: 'Systems',
  //   slug: '/business-systems',
  //   icon: 'mdi:chat',
  //   children: [
  //     {
  //       id: 71,
  //       label: 'Users',
  //       slug: '/business-systems/users',
  //       icon: 'mdi:account',
  //       children: [],
  //     },
  //   ],
  // },
])
const { isSidebarOpen, isMobileSidebarOpen, isMobile } = useNavigation()
</script>

<template>
  <div class="background relative flex h-screen w-full lg:p-4 lg:pl-0">
    <IBSideNav
      v-model:is-sidebar-open="isSidebarOpen"
      v-model:is-mobile-sidebar-open="isMobileSidebarOpen"
      :categories="adminLinks"
      :is-mobile="isMobile"
    />
    <div class="foreground h-full w-full overflow-y-scroll rounded-lg md:ml-[64px]">
      <slot />
    </div>
  </div>
</template>

<style scoped></style>
</file>

<file path="apps/admin-dashboard/middleware/auth.global.ts">
import { defineNuxtRouteMiddleware, navigateTo, useCookie } from '#app'
import { useRuntimeConfig } from '#imports'

export default defineNuxtRouteMiddleware(async (to, from) => {
  const config = useRuntimeConfig()
  const { aeLoginUrl, aeAuthUrl } = config.public

  try {
    const user = useSupabaseUser()

    if (!user.value) {
      console.log('USER_NOT_LOGGED_IN', aeAuthUrl, aeLoginUrl)

      return navigateTo(String(`${aeAuthUrl}${aeLoginUrl}`), { external: true })
    } else {
      console.log('USER_LOGGED_IN', user.value)
    }
  } catch (error: any) {
    console.error('redirect error', `${aeAuthUrl}${aeLoginUrl}`)
    return navigateTo(String(`${aeAuthUrl}${aeLoginUrl}`), { external: true })
  }
})
</file>

<file path="apps/admin-dashboard/middleware/is-admin.ts">
// const isAdmin = (role: string) => role === 'admin' || role === 'super_admin'

export default defineNuxtRouteMiddleware((to, from) => {
  // const user = useSupabaseUser()
  // const authUrl = useRuntimeConfig().public.aeAuthUrl
  // if (!isAdmin(user.value?.app_metadata.role)) {
  //   return navigateTo(authUrl, { external: true })
  // }
})
</file>

<file path="apps/admin-dashboard/pages/business-systems/index.vue">
<script setup lang="ts">
definePageMeta({
  layoutTransition: false,
  name: 'Business Systems',
})

const systemsTabs = [
  {
    title: 'Auth',
    slotName: 'auth',
    value: '0',
    system: 'authentication-flow',
  },
  {
    title: 'News',
    slotName: 'news',
    value: '1',
    system: 'news-feed',
  },
]
</script>

<template>
  <div>
    <IBTabView
      ref="analyticsTabView"
      :tabs="systemsTabs"
    >
      <template
        v-for="tab in systemsTabs"
        :key="tab.slotName"
        #[tab.slotName]
      >
        <BusinessSystems :system-name="tab.system" />
      </template>
    </IBTabView>
  </div>
</template>

<style scoped></style>
</file>

<file path="apps/admin-dashboard/pages/analytics.vue">
<script setup lang="ts">
const analyticsTabs = [
  {
    title: 'Realtime',
    slotName: 'realtime',
    value: '0',
    src: 'https://us.posthog.com/embedded/qZ7aQk6ZyuCEp0npTLkWkOu3geB5eA?whitelabel',
  },
  {
    title: 'Dashboard',
    slotName: 'dashboard',
    value: '1',
    src: 'https://us.posthog.com/embedded/Za4dgg7lpaDSZhmoPIlJE8-724hqiw?whitelabel',
  },
  {
    title: 'Landing Page',
    slotName: 'landingPage',
    value: '2',
    src: 'https://us.posthog.com/embedded/6suXX7B2fY6uvr1oCCVo-KsU3g--1A?whitelabel',
  },
  {
    title: 'Growth',
    slotName: 'growth',
    value: '3',
    src: 'https://us.posthog.com/embedded/5U8l5Qu1ougk0m5i_RvLgMAPWnXx5A?whitelabel',
  },
  {
    title: 'Users',
    slotName: 'users',
    value: '4',
    src: 'https://us.posthog.com/embedded/5_O5m7upw1QjlBHMIcr0MVp_Q_HX8w?whitelabel',
  },
]

const analyticsTabView = ref<HTMLElement | null>(null)
const activeTab = ref('0')
const analyticsHeight = ref(500) // Start with a default height

const updateHeight = async () => {
  await nextTick()
  if (analyticsTabView.value) {
    const newHeight = analyticsTabView.value.clientHeight
    analyticsHeight.value = newHeight > 0 ? newHeight : analyticsHeight.value
  }
}

// Update height when tab changes
watch(activeTab, updateHeight)

// Initial height update
onMounted(() => {
  updateHeight()
  window.addEventListener('resize', updateHeight)
})

definePageMeta({
  layoutTransition: false,
  name: 'Analytics',
})
</script>

<template>
  <IBTabView
    ref="analyticsTabView"
    :tabs="analyticsTabs"
  >
    <template
      v-for="tab in analyticsTabs"
      :key="tab.slotName"
      #[tab.slotName]
    >
      <div class="h-full min-h-full">
        <iframe
          class="p-4 invert"
          width="100%"
          height="100%"
          :src="tab.src"
          frameborder="0"
          allowfullscreen
        ></iframe>
      </div>
    </template>
  </IBTabView>
</template>

<style scoped></style>
</file>

<file path="apps/admin-dashboard/pages/business-plan.vue">
<script setup lang="ts">
definePageMeta({
  layoutTransition: false,
  name: 'BusinessPlan',
})

const businessPlanSections = [
  'executive-summary',
  'summary',
  'description',
  'market-analysis',
  'products',
  'marketing',
  'management-operations',
  'financials',
  'risk-analysis',
  'roadmap',
  'appendix',
  'ideas',
]

const businessPlanTabs = businessPlanSections.map((section, index) => ({
  value: `${index}`,
  title: section.replace(/-/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase()),
  slotName: section,
}))
</script>

<template>
  <div class="relative h-full max-h-full pb-4 xl:pb-8">
    <IBTabView
      ref="businessPlanTabView"
      :tabs="businessPlanTabs"
      class="relative h-full w-full pb-4"
    >
      <template
        v-for="tab in businessPlanTabs"
        :key="tab.slotName"
        #[tab.slotName]
      >
        <BusinessPlan
          :bp-section="tab.slotName"
          class="relative flex h-auto flex-col gap-4 p-4 xl:gap-8 xl:p-8"
        />
      </template>
    </IBTabView>
  </div>
</template>

<style scoped></style>
</file>

<file path="apps/admin-dashboard/pages/classifier.vue">
<script setup lang="ts">
definePageMeta({
  layoutTransition: false,
  name: 'Classifier',
})

const contentTypes = [
  { label: 'News', value: 'news' },
  { label: 'Events', value: 'events' },
  { label: 'Jobs', value: 'jobs' },
  { label: 'Research', value: 'research' },
  { label: 'Companies', value: 'companies' },
  { label: 'Unknown', value: 'unknown' },
]

const notification = useNotification()
const selectedUrls = ref([])

const {
  store: urlStore,
  loadMore,
  refresh,
  isSelecting,
} = useSelectData('classified_urls', {
  initialFetch: true,
  columns: '*',
  orderBy: { column: 'created_at', ascending: false },
  pagination: { page: 1, limit: 99 },
})

// Updating data
const { updateData, isUpdating } = useUpdateData('classified_urls')

// Function to update actual category
const updateActualCategory = async (id: number, category: string) => {
  notification.info({
    summary: 'Updating category',
    message: 'Category update in progress. Click to cancel.',
  })

  const timeoutId = setTimeout(async () => {
    try {
      await updateData(id, { id, actual_category: category, is_reviewed: true })
      notification.success({
        summary: 'Category updated',
        message: 'The category has been successfully updated.',
      })
    } catch (error) {
      notification.error({
        summary: 'Update failed',
        message: 'Failed to update the category. Please try again.',
      })
    }
  }, 3000)

  return () => {
    if (timeoutId) {
      clearTimeout(timeoutId)
      notification.info({
        summary: 'Update cancelled',
        message: 'The category update has been cancelled.',
      })
    }
  }
}

const markAsReviewed = async () => {
  const ids = selectedUrls.value.map((row) => row.id)
  for (const id of ids) {
    await updateData(id, { is_reviewed: true })
  }
  // Refresh data after updating
  await refresh()
}

// Delete URLs
const deleteUrls = async () => {
  const ids = selectedUrls.value.map((row) => row.id)
  try {
    await $fetch('/api/classifier/delete', {
      body: { ids },
    })
    // Refresh data after operation
    await refresh()
  } catch (error) {
    console.error('Error deleting URLs:', error)
  }
}

const addToTrainingData = async (rows) => {
  const ids = rows.map((row) => row.id)
  console.log('Adding to training data:', ids)

  try {
    await $fetch('/api/classifier/insert', {
      body: { ids },
    })
    // Optionally refresh data after operation
    await refresh()
  } catch (error) {
    console.error('Error adding to training data:', error)
  }
}

const fetchedUrls = ref([])
const uniqueLabels = ref(new Set())
const labelSeverities = ref({})

onMounted(async () => {
  await selectUrls()
  processUrls()
})

const selectUrls = async () => {
  try {
    const data = await $fetch('/api/classifier/select', {
      method: 'POST',
    })
    fetchedUrls.value = data.data // Assuming the response structure matches
    console.log('Training Urls', fetchedUrls.value)
  } catch (error) {
    console.error('Error fetching URLs:', error)
  }
}

const severities = ['primary', 'secondary', 'success', 'info', 'warning', 'danger', 'contrast']

const labelCounts = computed(() => {
  const counts = {}
  fetchedUrls.value?.forEach((url) => {
    counts[url.label] = (counts[url.label] || 0) + 1
  })
  return counts
})

const totalUrls = computed(() => fetchedUrls.value.length)

const processUrls = () => {
  uniqueLabels.value = new Set(fetchedUrls.value?.map((item) => item.label))

  Array.from(uniqueLabels.value).forEach((label, index) => {
    labelSeverities.value[label] = severities[index % severities.length]
  })
}

const getLabelSeverity = (label) => {
  return labelSeverities.value[label] || 'info'
}
</script>

<template>
  <div class="flex h-full flex-col">
    <PrimeSplitter class="h-full border-color">
      <PrimeSplitterPanel
        class="h-full overflow-scroll p-4"
        :size="25"
      >
        <div class="flex h-full flex-col">
          <h2 class="mb-4 text-2xl font-bold"> Training URLs </h2>

          <!-- Label Summary Metrics -->
          <div class="mb-6 grid grid-cols-2 gap-4 sm:grid-cols-2">
            <PrimeCard
              v-for="(count, label) in labelCounts"
              :key="label"
              class="border-color rounded-md border text-center"
            >
              <template #title>
                <PrimeTag
                  :value="label"
                  :severity="getLabelSeverity(label)"
                />
              </template>
              <template #content>
                <div class="text-2xl font-bold">
                  {{ count }}
                </div>
                <div class="text-sm text-gray-500">
                  {{ ((count / totalUrls) * 100).toFixed(1) }}%
                </div>
              </template>
            </PrimeCard>
          </div>

          <PrimeDataTable
            :value="fetchedUrls"
            size="small"
            class="text-sm"
            :pt="{
              header: ({ props }) => ({
                cell: '!bg-transparent',
              }),
              thead: ({ context }) => ({
                class: '!bg-transparent',
              }),
              tbody: ({ instance, context }) => ({
                class: '!bg-transparent',
              }),
            }"
            :pt-options="{ mergeSections: true, mergeProps: true }"
          >
            <PrimeColumn
              field="url"
              header="URL"
            >
              <template #body="slotProps">
                <a
                  :href="slotProps.data.url"
                  target="_blank"
                >
                  {{ slotProps.data.url }}
                </a>
              </template>
            </PrimeColumn>
            <PrimeColumn
              field="label"
              header="Label"
            >
              <template #body="slotProps">
                <PrimeTag
                  :value="slotProps.data.label"
                  :severity="getLabelSeverity(slotProps.data.label)"
                />
              </template>
            </PrimeColumn>
          </PrimeDataTable>
        </div>
      </PrimeSplitterPanel>
      <PrimeSplitterPanel
        class="h-full w-full overflow-scroll p-4"
        :size="75"
      >
        <PrimeToolbar class="mb-8 w-full">
          <template #start>
            <div class="flex gap-2">
              <PrimeButton
                :disabled="!selectedUrls.length"
                label="Add"
                @click="addToTrainingData"
              >
                <template #icon>
                  <Icon name="mdi:plus" />
                </template>
              </PrimeButton>

              <PrimeButton
                :disabled="!selectedUrls.length"
                label="Reviewed"
                @click="markAsReviewed"
              >
                <template #icon>
                  <Icon name="mdi:check" />
                </template>
              </PrimeButton>

              <PrimeButton
                :disabled="!selectedUrls.length"
                label="Delete"
                severity="danger"
                @click="deleteUrls"
              >
                <template #icon>
                  <Icon name="mdi:delete" />
                </template>
              </PrimeButton>
            </div>
          </template>
          <template #end> </template>
        </PrimeToolbar>

        <PrimeDataTable
          v-model:selection="selectedUrls"
          :value="urlStore.items"
          selection-mode="multiple"
          data-key="id"
          size="small"
          show-gridlines
          :pt="{
            root: 'text-sm',
            thead: { class: 'bg-primary-900' },
            bodycell: { class: 'p-2 border-b' },
          }"
          :pt-options="{ mergeSections: true, mergeProps: true }"
        >
          <PrimeColumn
            selection-mode="multiple"
            style="width: 2em"
          ></PrimeColumn>
          <PrimeColumn
            field="url"
            header="URL"
            body="urlTemplate"
          ></PrimeColumn>
          <PrimeColumn
            field="predicted_category"
            header="Predicted Category"
          ></PrimeColumn>
          <PrimeColumn
            field="actual_category"
            header="Actual Category"
            style="width: 10em"
          >
            <template #body="slotProps">
              <PrimeSelect
                v-model="slotProps.data.actual_category"
                class="relative z-50 w-full"
                :options="contentTypes"
                option-label="label"
                option-value="value"
                placeholder="Select a category"
                @change="updateActualCategory(slotProps.data.id, $event.value)"
              />
            </template>
          </PrimeColumn>
          <PrimeColumn
            field="is_reviewed"
            header="Reviewed"
            body="reviewedTemplate"
          ></PrimeColumn>
          <PrimeColumn body="actionTemplate"></PrimeColumn>
        </PrimeDataTable>
      </PrimeSplitterPanel>
    </PrimeSplitter>
  </div>
</template>

<style scoped></style>
</file>

<file path="apps/admin-dashboard/pages/errors.vue">
<script setup lang="ts">
definePageMeta({
  layoutTransition: false,
  name: 'Errors',
})
</script>

<template>
  <div class="relative h-full max-h-full">
    <ServerErrors />
  </div>
</template>

<style scoped></style>
</file>

<file path="apps/admin-dashboard/pages/financials.vue">
<script setup lang="ts">
import {
  FinancialTotals,
  FinancialOperations,
  FinancialEmployees,
  FinancialStorage,
  FinancialAnalytics,
  FinancialDevOps,
  FinancialOpenAI,
  FinancialPayments,
  FinancialLogging,
  // FinancialData
} from '#components'

definePageMeta({
  layoutTransition: false,
  name: 'Financials',
})

const { updateGlobalRange, haveData } = useFinancials()

const financialTabs = [
  {
    title: 'Totals',
    slotName: 'totals',
    value: '0',
    component: FinancialTotals,
  },
  {
    title: 'Operations',
    slotName: 'operations',
    value: '2',
    component: FinancialOperations,
  },
  {
    title: 'Employees',
    slotName: 'employees',
    value: '4',
    component: FinancialEmployees,
  },
  {
    title: 'Storage',
    slotName: 'storage',
    value: '5',
    component: FinancialStorage,
  },
  {
    title: 'Analytics',
    slotName: 'analytics',
    value: '6',
    component: FinancialAnalytics,
  },
  {
    title: 'DevOps',
    slotName: 'devops',
    value: '7',
    component: FinancialDevOps,
  },
  {
    title: 'OpenAI',
    slotName: 'openai',
    value: '8',
    component: FinancialOpenAI,
  },
  {
    title: 'Payments',
    slotName: 'payments',
    value: '9',
    component: FinancialPayments,
  },
  {
    title: 'Logging',
    slotName: 'logging',
    value: '10',
    component: FinancialLogging,
  },
  // {
  //   title: 'Data',
  //   slotName: 'data',
  //   value: '11',
  //   component: FinancialData,
  // }
]

const range = ref([0, 12])

watch(
  range,
  (newVal) => {
    console.log('range', newVal)
    updateGlobalRange({ start: newVal[0], end: newVal[1] })
  },
  { deep: true },
)

const visibleRight = ref(false)
</script>

<template>
  <div class="relative h-full max-h-full">
    <IBTabView
      v-if="haveData"
      ref="financialsTabView"
      :tabs="financialTabs"
      class="h-full w-full"
    >
      <template
        v-for="tab in financialTabs"
        :key="tab.slotName"
        #[tab.slotName]
      >
        <div class="relative flex h-auto flex-col gap-4 p-4 xl:gap-8 xl:p-8">
          <div>
            <PrimeButton @click="visibleRight = true"> Options </PrimeButton>
          </div>

          <PrimeDrawer
            v-model:visible="visibleRight"
            header="Right Drawer"
            position="right"
          >
            <div class="flex h-full gap-4">
              <div class="flex flex-col items-center gap-2">
                <p class="text-sm font-semibold"> Start </p>
                <PrimeInputNumber
                  v-model="range[0]"
                  show-buttons
                  button-layout="vertical"
                  style="width: 3rem"
                  input-id="minmax"
                  :min="1"
                  :max="23"
                />
              </div>
              <div class="flex flex-col items-center gap-2">
                <p class="text-sm font-semibold"> End </p>
                <PrimeInputNumber
                  v-model="range[1]"
                  show-buttons
                  button-layout="vertical"
                  style="width: 3rem"
                  input-id="minmax"
                  :min="2"
                  :max="24"
                />
              </div>
            </div>
          </PrimeDrawer>
          <component
            :is="tab.component"
            lazy
          />
        </div>
      </template>
    </IBTabView>
  </div>
</template>

<style scoped></style>
</file>

<file path="apps/admin-dashboard/pages/growth.vue">
<script setup lang="ts">
definePageMeta({
  layoutTransition: false,
  name: 'Growth',
})
</script>

<template>
  <div>
    <!-- <GrowthMetrics /> -->
    <TableGrowth />
  </div>
</template>

<style scoped></style>
</file>

<file path="apps/admin-dashboard/pages/index.vue">
<script setup lang="ts">
definePageMeta({
  layoutTransition: false,
  name: 'AdminDashboard',
})

const outputData = ref('')

const scrapeNewsLinks = async () => {
  try {
    const data = await $fetch('/api/cron-jobs', {
      method: 'POST',
      body: { action: 'scrapeNewsLinks' },
    })
    outputData.value = JSON.stringify(data, null, 2)
  } catch (error) {
    console.error('Error scraping news links:', error)
    outputData.value = 'Error scraping news links. Check console for details.'
  }
}

const scrapeNewsArticles = async () => {
  try {
    const data = await $fetch('/api/cron-jobs', {
      method: 'POST',
      body: { action: 'scrapeNewsArticles' },
    })
    outputData.value = JSON.stringify(data, null, 2)
  } catch (error) {
    console.error('Error scraping news articles:', error)
    outputData.value = 'Error scraping news articles. Check console for details.'
  }
}
</script>

<template>
  <div class="relative h-full max-h-full p-4">
    <!-- <div class="flex flex-col gap-8">
      <div class="flex gap-4">
        <PrimeButton @click="scrapeNewsLinks">Scrape News Links</PrimeButton>
        <PrimeButton @click="scrapeNewsArticles">Scrape News Articles</PrimeButton>
      </div>
      <p>{{ outputData }}</p>
    </div> -->
    <ServerJobs />
  </div>
</template>

<style scoped></style>
</file>

<file path="apps/admin-dashboard/pages/redis.vue">
<script setup lang="ts">
definePageMeta({
  layoutTransition: false,
  name: 'Redis',
})
</script>

<template>
  <div class="relative h-full max-h-full">
    <RedisManagement />
  </div>
</template>

<style scoped></style>
</file>

<file path="apps/admin-dashboard/pages/socials.vue">
<script setup lang="ts">
import {
  LazySocialOverview,
  LazySocialYoutube,
  LazySocialInstagram,
  LazySocialLinkedin,
  LazySocialTwitter,
} from '#components'

definePageMeta({
  layoutTransition: false,
  name: 'Socials',
})

// todo:med:hard:8 create tables for and store social snapshots in the database
// probably monthly would be enough, not sure exactly how I would do this, possibly a simple cron would work
const socialsTabs = [
  {
    tabTitle: 'Overview',
    tabName: 'overview',
    id: 'AstronEra',
    component: LazySocialOverview,
  },
  {
    tabTitle: 'Youtube',
    tabName: 'youtube',
    id: 'AstronEra',
    component: LazySocialYoutube,
  },
  {
    tabTitle: 'Instagram',
    tabName: 'instagram',
    id: 'AstronEra',
    component: LazySocialInstagram,
  },
  {
    tabTitle: 'Linkedin',
    tabName: 'linkedin',
    id: 'AstronEra',
    component: LazySocialLinkedin,
  },
  {
    tabTitle: 'Twitter',
    tabName: 'twitter',
    id: 'AstronEra',
    component: LazySocialTwitter,
  },
]
</script>

<template>
  <div class="h-full w-full">
    <IBTabView
      :tabs="socialsTabs"
      class="h-full w-full"
    >
      <template
        v-for="tab in socialsTabs"
        :key="tab.tabName"
        #[tab.tabName]
      >
        <div class="h-full p-4">
          <component
            :is="tab.component"
            :id="tab.id"
          />
        </div>
      </template>
    </IBTabView>
  </div>
</template>

<style scoped></style>
</file>

<file path="apps/admin-dashboard/pages/spider.vue">
<script setup lang="ts">
definePageMeta({
  layoutTransition: false,
  name: 'Spider',
})
</script>

<template>
  <div class="relative h-full max-h-full">
    <SpiderAnalytics />
  </div>
</template>

<style scoped></style>
</file>

<file path="apps/admin-dashboard/pages/timeline.vue">
<script setup lang="ts">
definePageMeta({
  layoutTransition: false,
  name: 'Timeline',
})
</script>

<template>
  <div class="p-4">
    <TasksCalendar />
  </div>
</template>

<style scoped></style>
</file>

<file path="apps/admin-dashboard/pages/upload.vue">
<script setup lang="ts">
definePageMeta({
  layoutTransition: false,
  name: 'Upload',
})
</script>

<template>
  <div class="flex flex-col gap-4 p-4">
    <!-- <IBUpload
      name="user-images"
      url="/api/users/bulk-upload"
      accept="image/*"
      :maxFileSize="50000000"
      :multiple="true"
    /> -->

    <Upload />
  </div>
</template>

<style scoped></style>
</file>

<file path="apps/admin-dashboard/pages/users.vue">
<script setup lang="ts">
import Select from 'primevue/select'
import DatePicker from 'primevue/datepicker'
import { z } from 'zod'
import { createCRUDComposable, type CRUDOptions } from '../composables/crud-factory'
import { createAdminDashboard } from '../composables/createAdminDashboard'

definePageMeta({
  layoutTransition: false,
  name: 'Users',
})

const app_plan_enum = z.enum(['free', 'basic', 'intermediate', 'premium', 'enterprise', 'custom'])

const app_role_enum = z.enum([
  'guest',
  'user',
  'astroguide',
  'mentor',
  'moderator',
  'tenant_member',
  'tenant_admin',
  'tenant_super_admin',
  'admin',
  'super_admin',
])

const userProfileSchema = z.object({
  id: z.string(),
  email: z.string().email().optional(),
  given_name: z.string().nullable().optional(),
  surname: z.string().nullable().optional(),
  username: z.string().nullable().optional(),
  dob: z.date().nullable().optional(),
  gender_id: z.string().nullable().optional(),
  created_at: z.date().nullable().optional(),
  updated_at: z.date().nullable().optional(),
  last_seen: z.date().nullable().optional(),
  avatar: z.string().nullable().optional(),
  introduction: z.string().nullable().optional(),
  quote: z.string().nullable().optional(),
  followed_count: z.number().nullable().optional(),
  followers_count: z.number().nullable().optional(),
  plan: app_plan_enum.nullable().optional(),
  role: app_role_enum.optional(),
})

// Infer TypeScript type from Zod schema
type UserProfile = z.infer<typeof userProfileSchema>

const createDateEditor = () => {
  return (slotProps: any) =>
    h(DatePicker, {
      'modelValue': slotProps.data[slotProps.field],
      'onUpdate:modelValue': (value: any) => {
        slotProps.data[slotProps.field] = value
      },
      'editorSaveCallback': slotProps.editorSaveCallback,
    })
}

const createSelectEditor = (options: any[], placeholder: string) => {
  return (slotProps: any) =>
    h(Select, {
      'modelValue': slotProps.data[slotProps.field],
      'onUpdate:modelValue': (value: any) => {
        slotProps.data[slotProps.field] = value
      },
      options,
      placeholder,
      'editorSaveCallback': slotProps.editorSaveCallback,
    })
}

const userProfileOptions: CRUDOptions<UserProfile> = {
  orderBy: { column: 'created_at' as keyof UserProfile, ascending: false },
  customSelectLogic: (data: UserProfile[]) => data.filter((user) => user.role !== 'super_admin'),
  validateInsert: (data: Omit<UserProfile, 'id'>) => {
    const result = userProfileSchema.omit({ id: true }).safeParse(data)
    return result.success
  },
  validateUpdate: (data: Partial<UserProfile>) => {
    const result = userProfileSchema.partial().safeParse(data)
    return result.success
  },
  afterUpdate: async (updatedUser: UserProfile) => {
    // Perform actions after update, e.g., send notification
    console.log('User updated:', updatedUser)
  },
}

const useUserProfiles = createCRUDComposable<UserProfile>('user_profiles', userProfileOptions)

const userColumns = [
  { field: 'email', header: 'Email', sortable: true },
  { field: 'given_name', header: 'First Name', sortable: true },
  { field: 'surname', header: 'Last Name', sortable: true },
  { field: 'username', header: 'Username', sortable: true },
  {
    field: 'dob',
    header: 'Date of Birth',
    sortable: true,
    editComponent: createDateEditor(),
  },
  { field: 'gender_id', header: 'Gender ID', sortable: true },
  { field: 'created_at', header: 'Created At', sortable: true },
  { field: 'last_seen', header: 'Last Seen', sortable: true },
  { field: 'avatar', header: 'Avatar' },
  { field: 'introduction', header: 'Introduction' },
  { field: 'quote', header: 'Quote' },
  { field: 'followed_count', header: 'Followed Count', sortable: true },
  { field: 'followers_count', header: 'Followers Count', sortable: true },
  {
    field: 'plan',
    header: 'Plan',
    sortable: true,
    editComponent: createSelectEditor(app_plan_enum.options, 'Select a Plan'),
  },
  {
    field: 'role',
    header: 'Role',
    sortable: true,
    editComponent: createSelectEditor(app_role_enum.options, 'Select a Role'),
  },
]

const UserProfilesAdminDashboard = createAdminDashboard(
  'userProfiles',
  userColumns,
  useUserProfiles,
)
</script>

<template>
  <div class="border-color h-full overflow-scroll rounded-lg border">
    <UserProfilesAdminDashboard>
      <template #title>
        <div class="flex items-center">
          <h2 class="text-2xl font-bold mr-4">Custom Title</h2>
        </div>
      </template>
    </UserProfilesAdminDashboard>
  </div>
</template>

<style scoped></style>
</file>

<file path="apps/admin-dashboard/plugins/dev-helper.ts">
import { useLogger } from '@ib/logger'

const logger = useLogger('devHelper')

export default defineNuxtPlugin((nuxtApp) => {
  const config = useRuntimeConfig()

  const DevHelper = {
    features: { ...config.public.devHelper.features },

    toggleFeature(feature: string, enabled: boolean) {
      if (feature in this.features) {
        this.features[feature] = enabled
        logger.info(`Feature '${feature}' ${enabled ? 'enabled' : 'disabled'}`)

        // Reinitialize the feature if it's being enabled
        if (enabled) {
          const initMethod =
            `init${feature.charAt(0).toUpperCase() + feature.slice(1)}` as keyof typeof DevHelper
          if (typeof this[initMethod] === 'function') {
            ;(this[initMethod] as () => void)()
          }
        }
      }
    },
    initNetworkErrorClassifier() {
      if (!this.features.networkErrorClassifier) return

      const errorCategories = {
        timeout: ['ECONNABORTED'],
        serverError: ['500', '501', '502', '503', '504', '505'],
        clientError: [
          '400',
          '401',
          '403',
          '404',
          '405',
          '406',
          '407',
          '408',
          '409',
          '410',
          '411',
          '412',
          '413',
          '414',
          '415',
        ],
        networkError: [
          'ECONNRESET',
          'ENOTFOUND',
          'ESOCKETTIMEDOUT',
          'ETIMEDOUT',
          'ECONNREFUSED',
          'EHOSTUNREACH',
          'EPIPE',
          'EAI_AGAIN',
        ],
      }

      nuxtApp.hook('app:error', (error) => {
        let category = 'unknown'
        const errorCode = error.statusCode?.toString() || error.name

        for (const [key, codes] of Object.entries(errorCategories)) {
          if (codes.includes(errorCode)) {
            category = key
            break
          }
        }

        logger.error(` Network Error (${category}):`, {
          message: error.message,
          code: errorCode,
          stack: error.stack,
        })
      })

      logger.info(' Network Error Classifier initialized')
    },

    initInfiniteLoopDetector() {
      if (!this.features.infiniteLoopDetector) return
      if (!import.meta.client) return

      const MAX_ITERATIONS = 1000000
      const TIME_THRESHOLD = 100 // ms

      const originalSetTimeout = window.setTimeout
      window.setTimeout = function (
        this: typeof window,
        handler: TimerHandler,
        timeout?: number,
        ...args: any[]
      ): number {
        const start = Date.now()
        let iterationCount = 0

        const wrappedCallback = function (this: typeof window) {
          iterationCount++
          if (
            iterationCount > MAX_ITERATIONS ||
            (Date.now() - start > TIME_THRESHOLD && iterationCount > 1000)
          ) {
            logger.warn(' Potential infinite loop detected:', {
              iterations: iterationCount,
              time: Date.now() - start,
              stack: new Error().stack,
            })
          }
          if (typeof handler === 'function') {
            return handler.apply(this, args)
          } else {
            return Function(handler as string).apply(this, args)
          }
        }

        return Number(originalSetTimeout.call(this, wrappedCallback, timeout))
      }

      logger.info(' Infinite Loop Detector initialized')
    },

    initUnhandledPromiseRejectionTracker() {
      if (!this.features.unhandledPromiseRejectionTracker) return
      if (!import.meta.client) return

      window.addEventListener('unhandledrejection', (event) => {
        logger.error(' Unhandled Promise Rejection:', {
          reason: event.reason,
          stack: event.reason.stack || new Error().stack,
          event: event,
        })
      })

      logger.info(' Unhandled Promise Rejection Tracker initialized')
    },

    checkEnvironmentConsistency() {
      if (!this.features.environmentConsistencyChecker) return

      const requiredVars = ['API_URL', 'AUTH_SECRET', 'DB_CONNECTION']
      const missingVars = requiredVars.filter((varName) => !config.public[varName])

      if (missingVars.length > 0) {
        logger.warn(' Missing required environment variables:', missingVars)
      } else {
        logger.info(' All required environment variables are set')
      }
    },
  }

  if (import.meta.dev && config.public.devHelper.enabled) {
    logger.info(' DevHelper: Initializing...')
    try {
      DevHelper.initNetworkErrorClassifier()
      DevHelper.initInfiniteLoopDetector()
      DevHelper.initUnhandledPromiseRejectionTracker()
      DevHelper.checkEnvironmentConsistency()
      logger.info('Initialization complete')
    } catch (error) {
      logger.error('Initialization failed:', error)
    }
  } else {
    logger.info('Initialization skipped (not in dev mode or devHelper not enabled)')
  }

  return {
    provide: {
      devHelper: DevHelper,
    },
  }
})
</file>

<file path="apps/admin-dashboard/server/api/classifier/[action].ts">
import { defineEventHandler, getRouterParam, createError } from 'h3'
import jwt from 'jsonwebtoken'

export default defineEventHandler(async (event) => {
  const config = useRuntimeConfig()
  const action = getRouterParam(event, 'action')
  console.log('Classifier action:', action)

  let url: string
  let label: string
  let id: string

  if (action !== 'select') {
    const body = await readBody(event)
    url = body.url
    label = body.label
    id = body.id
  }

  if (!action) {
    throw createError({
      statusCode: 400,
      statusMessage: 'Action is required',
    })
  }

  try {
    const token = jwt.sign({ sender: 'AstronEra' }, config.scraperKey, {
      algorithm: 'HS256',
    })

    if (action === 'insert') {
      const response = await $fetch(`${config.public.scraperUrl}/api/classifier/urls`, {
        method: 'POST',
        headers: {
          Authorization: `Bearer ${token}`,
        },
        body: JSON.stringify({ url, label }),
      })

      return {
        data: response,
      }
    } else if (action === 'delete') {
      const response = await $fetch(`${config.public.scraperUrl}/api/classifier/urls/${id}`, {
        method: 'DELETE',
        headers: {
          Authorization: `Bearer ${token}`,
        },
      })

      return {
        data: response,
      }
    } else if (action === 'select') {
      const response = await $fetch(`${config.public.scraperUrl}/api/classifier/urls`, {
        method: 'GET',
        headers: {
          Authorization: `Bearer ${token}`,
        },
      })

      return {
        data: response,
      }
    }

    throw createError({
      statusCode: 400,
      statusMessage: 'Invalid action',
    })
  } catch (error: any) {
    console.error(`Error in classifier ${action}:`, error)

    throw createError({
      statusCode: 500,
      statusMessage: 'Internal Server Error',
    })
  }
})
</file>

<file path="apps/admin-dashboard/server/api/create/many-public-users.post.ts">
export default defineEventHandler(async (event) => {
  const users = await readBody(event)
  const client = dbClient(event)
  let message
  let status

  // Function to insert users from JSON file
  if (users.length > 0) {
    const mappedUsers = users.map((user) => {
      if (user.dob !== null) {
        user.dob = new Date(user.dob).toISOString()
      }
      user.created_at = new Date().toISOString()
      user.updated_at = new Date().toISOString()
      user.last_seen = new Date().toISOString()
      return {
        ...user,
      }
    })

    const { data, error } = await client
      .from('user_profiles')
      .createMany({ data: [...mappedUsers] })
      .select('*')

    status = 200
    message = 'Users have been inserted successfully'
  } else {
    console.error('no users to add')
    status = 200
    message = 'no users to add'
  }

  return {
    status,
    message,
  }
})
</file>

<file path="apps/admin-dashboard/server/api/create/roles.post.ts">
import type { Role } from '@/types/roles'

export default defineEventHandler(async (event) => {
  const client = dbClient(event)

  const { roles }: { roles: Role[] } = await readBody(event)
  // const env = useRuntimeConfig().public

  // Function to insert users from JSON file
  // !TODO: use transforms from types foler to handle date/string conversion
  if (roles.length > 0) {
    const mappedRoles = roles.map((role) => {
      role.created_at = new Date(role.created_at).toISOString()
      return {
        ...role,
      }
    })

    await client.roles.createMany({ data: [...mappedRoles] })
  }

  return {
    status: 200,
    message: 'Users have been inserted successfully',
  }
})
</file>

<file path="apps/admin-dashboard/server/api/error/[type].ts">
import { defineEventHandler, getRouterParam, createError } from 'h3'
import jwt from 'jsonwebtoken'

export default defineEventHandler(async (event) => {
  const config = useRuntimeConfig()
  const type = getRouterParam(event, 'type')

  if (!type) {
    throw createError({
      statusCode: 400,
      statusMessage: 'Error type is required',
    })
  }

  console.log(`Sending error event to scraper for type: ${type}`)

  try {
    const token = jwt.sign({ sender: 'AstronEra' }, config.scraperKey, {
      algorithm: 'HS256',
    })

    const response = await $fetch(`${config.public.scraperUrl}/api/error/${type}`, {
      headers: {
        Authorization: `Bearer ${token}`,
      },
    })

    return {
      data: response,
    }
  } catch (error: any) {
    console.error(`Error fetching ${type} data:`, error)

    if (error.response) {
      // The request was made and the server responded with a status code
      // that falls out of the range of 2xx
      if (error.response.status === 404) {
        // Handle 404 Not Found error
        return {
          data: null,
          error: `No ${type} data found for the specified parameters`,
        }
      } else {
        // Handle other error statuses
        throw createError({
          statusCode: error.response.status,
          statusMessage: error.response.statusText || `Error fetching ${type} data`,
        })
      }
    } else if (error.request) {
      // The request was made but no response was received
      throw createError({
        statusCode: 503,
        statusMessage: 'Service Unavailable',
      })
    } else {
      // Something happened in setting up the request that triggered an Error
      throw createError({
        statusCode: 500,
        statusMessage: 'Internal Server Error',
      })
    }
  }
})
</file>

<file path="apps/admin-dashboard/server/api/social/instagram/analytics.ts">
import { defineEventHandler, getQuery } from 'h3'
import { useLoggerAsync, useErrorHandler } from '@ib/logger'
import { useInstagramAnalytics } from '#imports'

const PREFIX = 'social/instagram/insights'

export default defineEventHandler(async (event) => {
  const log = await useLoggerAsync(PREFIX)
  const errors = await useErrorHandler(PREFIX)

  const { userId } = getQuery(event) as { userId: string }

  log.info(`userId: ${userId}`)

  try {
    const instagram = useInstagramAnalytics()
    const businessAnalytics = await instagram.fetchBusinessAnalytics(userId)

    log.info(businessAnalytics)

    return {
      status: 200,
      message: 'Profile businessAnalytics returned from Instagram',
      data: businessAnalytics,
    }
  } catch (error: any) {
    errors.handleError({
      error,
      devMessage: 'Error fetching Instagram insights',
      userMessage: 'Error fetching Instagram insights',
    })
  }
})
</file>

<file path="apps/admin-dashboard/server/api/social/linkedin/analytics.ts">
import { useErrorHandler, useLoggerAsync } from '@ib/logger'
import { useLinkedinAnalytics } from '#imports'

const PREFIX = 'social/linkedin/analytics'

export default defineEventHandler(async (event) => {
  const log = await useLoggerAsync(PREFIX)
  const errors = useErrorHandler(PREFIX)

  const { postId } = getQuery(event) as { postId: string }

  log.info(`postId: ${postId}`)

  try {
    const linkedin = useLinkedinAnalytics(postId)
    const postAnalytics = await linkedin.fetchPostAnalytics()
    log.info(postAnalytics)

    return {
      status: 200,
      message: 'Post analytics returned from LinkedIn',
      data: postAnalytics,
    }
  } catch (error: any) {
    errors.handleError({
      error,
      devMessage: 'Error fetching LinkedIn analytics',
      userMessage: 'Error fetching LinkedIn analytics',
    })
  }
})
</file>

<file path="apps/admin-dashboard/server/api/social/twitter/analytics.ts">
import { defineEventHandler, getQuery } from 'h3'
import { useErrorHandler, useLoggerAsync } from '@ib/logger'
import { useTwitterAnalytics } from '#imports'

const PREFIX = 'social/twitter/analytics'

export default defineEventHandler(async (event) => {
  const log = await useLoggerAsync(PREFIX)
  const errors = useErrorHandler(PREFIX)

  const { postId } = getQuery(event) as { postId: string }

  log.info(`postId: ${postId}`)

  try {
    const twitter = useTwitterAnalytics(postId)
    const userAnalytics = await twitter.fetchUserProfile()
    log.info(userAnalytics)

    return {
      status: 200,
      message: 'Post analytics returned from Twitter',
      data: userAnalytics,
    }
  } catch (error: any) {
    errors.handleError({
      error,
      devMessage: 'Error fetching Twitter analytics',
      userMessage: 'Error fetching Twitter analytics',
    })
  }
})
</file>

<file path="apps/admin-dashboard/server/api/social/youtube/analytics.ts">
import { useErrorHandler, useLoggerAsync } from '@ib/logger'
import { useYoutubeChannel } from '#imports'

const PREFIX = 'social/youtube/analytics'

export default defineEventHandler(async (event) => {
  const log = await useLoggerAsync(PREFIX)
  const errors = useErrorHandler(PREFIX)

  const { channelName } = getQuery(event) as { channelName: string }

  log.info(`channelName: ${channelName}`)

  try {
    const youtube = useYoutubeChannel(channelName)
    const channelStatistics = await youtube.fetchChannelStatistics()
    log.info(channelStatistics)
    const videoItems = await youtube.fetchChannelVideos()
    log.info(videoItems)
    const videoStatsPromises = videoItems.map(async (video: any) => {
      const stats = await youtube.fetchVideoStatistics(video.id.videoId)
      log.info(stats)
      return { ...video, statistics: stats }
    })
    const videos = await Promise.all(videoStatsPromises)

    log.info('returning videos')
    return {
      status: 200,
      message: 'Videos returned from youtube',
      data: {
        channelStatistics,
        videos,
      },
    }
  } catch (error: any) {
    errors.handleError({
      error,
      devMessage: 'error fetching youtube analytics',
      userMessage: 'error fetching youtube analytics',
    })
  }
})
</file>

<file path="apps/admin-dashboard/server/api/social/youtube/channel-videos.ts">
export default defineEventHandler(async (event) => {
  const { channelName } = getQuery(event)

  console.log('channelName', channelName)

  try {
    const videos = await getYoutubeContent(String(channelName))

    console.log('returnedData', videos)
    return {
      status: 200,
      message: 'Videos returned from youtube',
      data: videos,
    }
  } catch (error: any) {
    console.error('social/youtube error', error.message)
    return {
      status: 500,
      message: 'Error retrieving videos',
      data: null,
      error,
    }
  }
})
</file>

<file path="apps/admin-dashboard/server/api/update/user-profile.post.ts">
export default defineEventHandler(async (event) => {
  const { userId, profile }: { userId: string; profile: any } = await readBody(event)
  const client = await dbClient(event)

  // Function to insert users from JSON file
  try {
    if (profile.dob) {
      console.log('profile.dob:', profile.dob)
      profile.dob = new Date(profile.dob).toISOString()
    }

    if (!profile) {
      return {
        status: 400,
        message: 'No user profile provided',
      }
    }

    console.log(`attempting to update ${profile.given_name} with id ${userId}`)
    const { data, error } = await client
      .from('user_profiles')
      .update(profile)
      .eq('email', profile.email)
      .select()

    if (error) {
      throw createError({ message: `error updating users: ${error.message}` })
    }

    console.log(`User ${data.email} updated successfully`)

    return {
      status: 200,
      message: 'Users have been inserted successfully',
      data,
    }
  } catch (error) {
    console.error(`Error updating user ${userId}:`, error)
    return {
      status: 500,
      message: 'Error updating user profile',
    }
  }
})
</file>

<file path="apps/admin-dashboard/server/api/users/bulk-upload.ts">
import { readMultipartFormData, type MultiPartData } from 'h3'
import { serverSupabaseServiceRole } from '#supabase/server'

async function upload(path: string, file: MultiPartData) {
  const supabase = serverSupabaseServiceRole(useEvent())
  const { data, error } = await supabase.storage.from('profile-public').upload(path, file.data, {
    cacheControl: '3600',
    contentType: file.type,
    upsert: true,
  })
  console.log('uploadResponse', data, error)
}

export default defineEventHandler(async (event) => {
  console.log('upload eventHandler')
  const form = await readMultipartFormData(event)
  console.log('workingUpload', form)
  if (!form?.length) {
    return console.log('no form data')
  }

  console.log('file', form)

  // we would need to fetch all users based on the file name

  try {
    const userRepository = new UserRepository()
    const users = await userRepository.selectMany<'user_profiles'>({
      tableName: 'user_profiles',
      selectStatement: 'id, given_name, surname',
    })

    form.forEach(async (file) => {
      console.log('uploading file', file)
      const fileName = file.filename
      if (!fileName) {
        console.log('no filename found')
        return
      }
      const fullName = fileName.split('.')[0]
      const [given_name, surname] = fullName.split('-')
      console.log('searching for', given_name, surname)
      const userId = users.find((user) => {
        if (!user.given_name || !user.surname) {
          return false
        }
        return (
          user.given_name.toLowerCase() === given_name && user.surname.toLowerCase() === surname
        )
      })?.id

      if (!userId) {
        console.log('no user found for', given_name, surname)
        return
      }
      console.log('name and id', given_name, surname, userId)
      console.log('uploading file for', userId, fileName)
      const newFileName = `avatar_${userId}.jpg`
      await upload(`${userId}/avatar/${newFileName}`, file)
    })
  } catch (error) {
    console.log('upload error', error)
    throw createError({ statusMessage: error.message })
  }

  return {
    statusCode: 200,
    message: 'successfully uploaded files',
  }
})
</file>

<file path="apps/admin-dashboard/server/api/users/update.ts">
export default defineEventHandler(async (event) => {
  console.log('update user endpoint fired')
  const { id, data } = await readBody(event)

  console.log('have body', data)

  try {
    return {
      error: null,
      data: [],
      status: 200,
      message: 'User fetched',
    }
  } catch (error: any) {
    console.error('update user error', error.message)
    return {
      error,
      data: null,
      status: 500,
      message: error.message,
    }
  }
})
</file>

<file path="apps/admin-dashboard/server/api/_ws.ts">
export default defineWebSocketHandler({
  open(peer) {
    console.log('[ws] open', peer)
  },

  message(peer, message) {
    console.log('[ws] message', peer, message)
    if (message.text().includes('ping')) {
      peer.send('pong')
    }
  },

  close(peer, event) {
    console.log('[ws] close', peer, event)
  },

  error(peer, error) {
    console.log('[ws] error', peer, error)
  },
})
</file>

<file path="apps/admin-dashboard/server/api/cron-jobs.post.ts">
import jwt from 'jsonwebtoken'

export default defineEventHandler(async (event) => {
  const body = await readBody(event)
  const { action } = body

  const scraperKey = useRuntimeConfig().scraperKey
  const token = jwt.sign({ sender: 'AstronEra' }, scraperKey, {
    algorithm: 'HS256',
  })

  const scraperBaseURL = useRuntimeConfig().public.scraperUrl

  let endpoint = ''
  switch (action) {
    case 'scrapeNewsLinks':
      endpoint = '/trigger/news_links'
      break
    case 'scrapeNewsArticles':
      endpoint = '/trigger/news_pages'
      break
    default:
      throw createError({
        statusCode: 400,
        statusMessage: 'Invalid action',
      })
  }

  try {
    const response = await $fetch(`${scraperBaseURL}${endpoint}`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json',
      },
    })

    return response
  } catch (error) {
    console.error(`Error in scraper request: ${error}`)
    throw createError({
      statusCode: 500,
      statusMessage: 'Error communicating with scraper',
    })
  }
})
</file>

<file path="apps/admin-dashboard/server/api/execute-script.ts">
import { execFile } from 'child_process'
import { promisify } from 'util'
import path from 'path'
import fs from 'fs'

const execFileAsync = promisify(execFile)

type ScriptName = 'build-all' | 'db-setup' | 'generate-lazy-routes' | 'clean-packages'

const scriptConfigs = {
  'build-all': { type: 'sh', file: 'build-all.sh' },
  'db-setup': { type: 'ts', file: 'db-setup.ts' },
  'generate-lazy-routes': { type: 'ts', file: 'generate-lazy-routes.ts' },
  'clean-packages': { type: 'sh', file: 'clean-packages.sh' },
  // Add more scripts as needed
}

export default defineEventHandler(async (event) => {
  const { scriptName } = (await readBody(event)) as { scriptName: ScriptName }

  if (!scriptConfigs[scriptName]) {
    throw createError({
      statusCode: 400,
      statusMessage: 'Invalid script name',
    })
  }

  const { type, file } = scriptConfigs[scriptName]

  const baseDir = process.cwd()
  const scriptPath = path.join('/app', 'scripts', file)

  console.log(`Current working directory: ${process.cwd()}`)
  console.log(`Script path: ${scriptPath}`)
  console.log('Files in current directory:', fs.readdirSync(process.cwd()))
  console.log('Files in /app/scripts:', fs.readdirSync('/app/scripts'))
  console.log(`Current working directory: ${baseDir}`)
  console.log(`Attempting to execute script: ${scriptPath}`)

  // Check if the script file exists
  if (!fs.existsSync(scriptPath)) {
    console.error(`Script file not found: ${scriptPath}`)
    throw createError({
      statusCode: 500,
      statusMessage: 'Script file not found',
    })
  }

  try {
    let output
    if (type === 'sh') {
      const { stdout, stderr } = await execFileAsync('sh', [scriptPath], { cwd: baseDir })
      output = stdout + stderr
    } else if (type === 'ts') {
      const { stdout, stderr } = await execFileAsync('npx', ['tsx', scriptPath], { cwd: baseDir })
      output = stdout + stderr
    } else {
      throw new Error('Unsupported script type')
    }

    console.log(`Script execution completed: ${scriptName}`)
    return { output }
  } catch (error) {
    console.error(`Error executing script ${scriptName}:`, error)
    throw createError({
      statusCode: 500,
      statusMessage: 'Error executing script',
    })
  }
})
</file>

<file path="apps/admin-dashboard/server/api/goals.ts">
import { promises as fs } from 'fs'
import { resolve } from 'path'
import { defineEventHandler, readBody } from 'h3'

const goalsFilePath = resolve(process.cwd(), 'data', 'tasks/goals.json')

export interface Goal {
  id: number
  title: string
  date: string
  category: 'financial' | 'metrics' | 'hiring' | 'events' | 'development' | 'milestone'
  assigneeId: number
  completed: boolean
  progress: number
  priority: 'low' | 'medium' | 'high'
  timeSpent: number
  description: string
  milestoneId?: number
  recurrence?: {
    frequency: 'daily' | 'weekly' | 'monthly' | 'yearly'
    interval: number
    endDate?: string
  }
}

export default defineEventHandler(async (event) => {
  const body = await readBody(event)
  const { action, goal } = body

  async function readGoals(): Promise<Goal[]> {
    try {
      const data = await fs.readFile(goalsFilePath, 'utf-8')
      return JSON.parse(data)
    } catch (error) {
      if (error.code === 'ENOENT') {
        return []
      }
      throw error
    }
  }

  async function writeGoals(goals: Goal[]): Promise<void> {
    await fs.writeFile(goalsFilePath, JSON.stringify(goals, null, 2), 'utf-8')
  }

  try {
    let goals = await readGoals()

    switch (action) {
      case 'read':
        return {
          success: true,
          goals: goals,
          totalCount: goals.length,
        }
      case 'create':
        goals.push(goal)
        await writeGoals(goals)
        break
      case 'update':
        const index = goals.findIndex((g) => g.id === goal.id)
        if (index !== -1) {
          goals[index] = { ...goals[index], ...goal }
          await writeGoals(goals)
        }
        break
      case 'delete':
        goals = goals.filter((g) => g.id !== goal.id)
        await writeGoals(goals)
        break
      default:
        throw new Error(`Invalid action: ${action}`)
    }

    return {
      success: true,
      message: action === 'read' ? 'Goals fetched successfully' : `Goal ${action}d successfully`,
    }
  } catch (error) {
    console.error('Error performing goal action:', error)
    return { success: false, message: `Failed to ${action} goal`, error: error.message }
  }
})
</file>

<file path="apps/admin-dashboard/server/api/healthy.ts">
import { defineEventHandler } from 'h3'

export default defineEventHandler(async (event) => {
  const startTime = Date.now()
  const env = useRuntimeConfig().public
  const port = process.env.PORT

  try {
    // You can add more checks here, e.g., Redis connection, external API calls, etc.

    const uptime = process.uptime()
    const memoryUsage = process.memoryUsage()

    console.log('Health check successful', env)
    console.log('Process Port:', port)
    console.log('Nitro Port: ')

    return {
      status: 'healthy',
      timestamp: new Date().toISOString(),
      uptime: uptime,
      memory: {
        rss: memoryUsage.rss,
        heapTotal: memoryUsage.heapTotal,
        heapUsed: memoryUsage.heapUsed,
        external: memoryUsage.external,
      },
      environment: process.env.NODE_ENV,
      databaseConnection: 'ok',
      responseTime: Date.now() - startTime,
    }
  } catch (error: any) {
    console.error('Health check failed:', error)

    return {
      status: 'unhealthy',
      timestamp: new Date().toISOString(),
      error: error.message,
      responseTime: Date.now() - startTime,
    }
  }
})
</file>

<file path="apps/admin-dashboard/server/api/milestones.ts">
import { promises as fs } from 'fs'
import { resolve } from 'path'
import { defineEventHandler, readBody } from 'h3'

const milestonesFilePath = resolve(process.cwd(), 'data', 'tasks', 'milestones.json')

export default defineEventHandler(async (event) => {
  const method = event.node.req.method

  if (method === 'GET') {
    try {
      const data = await fs.readFile(milestonesFilePath, 'utf-8')
      return JSON.parse(data)
    } catch (error) {
      console.error('Error reading milestones:', error)
      throw createError({
        statusCode: 500,
        statusMessage: 'Failed to read milestones',
      })
    }
  } else if (method === 'POST') {
    const body = await readBody(event)
    const { action, milestone } = body

    try {
      const data = await fs.readFile(milestonesFilePath, 'utf-8')
      let milestones = JSON.parse(data)

      switch (action) {
        case 'create':
          milestone.id = Math.max(...milestones.map((m: Milestone) => m.id)) + 1
          milestones.push(milestone)
          break
        case 'update':
          const index = milestones.findIndex((m: Milestone) => m.id === milestone.id)
          if (index !== -1) {
            milestones[index] = milestone
          }
          break
        case 'delete':
          milestones = milestones.filter((m: Milestone) => m.id !== milestone.id)
          break
        default:
          throw new Error(`Invalid action: ${action}`)
      }

      await fs.writeFile(milestonesFilePath, JSON.stringify(milestones, null, 2), 'utf-8')
      return { success: true, message: `Milestone ${action}d successfully` }
    } catch (error) {
      console.error(`Error ${action}ing milestone:`, error)
      throw createError({
        statusCode: 500,
        statusMessage: `Failed to ${action} milestone`,
      })
    }
  }
})
</file>

<file path="apps/admin-dashboard/server/api/server-jobs.ts">
import { defineWebSocketHandler } from 'h3'
import { WebSocket } from 'ws'
import jwt from 'jsonwebtoken'

const clients = new Set()
let serverWs: WebSocket | null = null
let reconnectTimeout: NodeJS.Timeout | null = null
let reconnectAttempts = 0
const maxReconnectAttempts = 5
let reconnectInterval = 5000 // 5 seconds

let selectedMetrics: string[] = ['all']

const connectToAnalyticsServer = () => {
  if (reconnectAttempts >= maxReconnectAttempts) {
    console.log('Max reconnect attempts reached. Stopping reconnection attempts.')
    return
  }

  const scraperKey = useRuntimeConfig().scraperKey
  const token = jwt.sign({ sender: 'AstronEra' }, scraperKey, {
    algorithm: 'HS256',
  })

  const scraperBaseURL = useRuntimeConfig().public.scraperUrl
  const wsUrl = `${scraperBaseURL.replace(/^http/, 'ws')}/analytics`

  console.log(`Connecting to WebSocket URL: ${wsUrl}`)

  serverWs = new WebSocket(wsUrl, {
    headers: { Authorization: `Bearer ${token}` },
  })

  serverWs.on('open', () => {
    console.log('Connected to Analytics WebSocket server')
    reconnectAttempts = 0
    if (reconnectTimeout) {
      clearTimeout(reconnectTimeout)
      reconnectTimeout = null
    }
    // Send initial subscription with the selected metrics

    console.log('Subscribing to metrics:', selectedMetrics)
    serverWs.send(
      JSON.stringify({
        action: 'subscribe',
        metrics: selectedMetrics,
      }),
    )
  })

  serverWs.on('message', (data) => {
    // Broadcast the message to all connected Nuxt clients
    console.log('Received message from Analytics server:', data.toString())
    for (const client of clients) {
      client.send(data)
    }
  })

  serverWs.on('close', (code, reason) => {
    console.log(`Disconnected from Analytics WebSocket server: ${code} - ${reason}`)
    serverWs = null
    scheduleReconnect()
  })

  serverWs.on('error', (error) => {
    console.error('Error with Analytics WebSocket connection:', error)
    if (serverWs) {
      serverWs.close()
    }
  })
}

const scheduleReconnect = () => {
  if (reconnectAttempts < maxReconnectAttempts) {
    reconnectAttempts++
    console.log(
      `Scheduling reconnection attempt ${reconnectAttempts}/${maxReconnectAttempts} in ${reconnectInterval}ms`,
    )
    reconnectTimeout = setTimeout(() => {
      console.log(`Executing reconnection attempt ${reconnectAttempts}`)
      connectToAnalyticsServer()
    }, reconnectInterval)
  } else {
    console.log('Max reconnect attempts reached. Please check the server.')
  }
}

export default defineWebSocketHandler({
  async open(peer) {
    console.log('Nuxt client connected')
    clients.add(peer)

    if (!serverWs) {
      connectToAnalyticsServer()
    }
  },

  message(peer, message) {
    console.log('Received message from Nuxt client:', message)
    try {
      const parsedMessage = JSON.parse(message)
      selectedMetrics = parsedMessage.metrics
      console.log('Updated selectedMetrics:', selectedMetrics)

      if (serverWs && serverWs.readyState === WebSocket.OPEN) {
        console.log(
          'Forwarding message to Analytics server:',
          JSON.stringify({
            action: 'subscribe',
            subscribedMetrics: parsedMessage.metrics,
          }),
        )
        serverWs.send(
          JSON.stringify({
            action: 'subscribe',
            subscribedMetrics: parsedMessage.metrics,
          }),
        )
      } else {
        console.log(
          'Cannot forward message: serverWs not ready. Current state:',
          serverWs ? serverWs.readyState : 'null',
        )
      }
    } catch (error) {
      console.error('Error parsing or handling message:', error)
    }
  },

  close(peer) {
    console.log('Nuxt client disconnected')
    clients.delete(peer)

    if (clients.size === 0 && serverWs) {
      console.log('No more clients, closing server connection')
      serverWs.close()
      serverWs = null
      if (reconnectInterval) {
        clearInterval(reconnectInterval)
        reconnectInterval = null
      }
    }
  },

  error(peer, error) {
    console.error('Error with Nuxt client connection:', error)
    clients.delete(peer)
  },
})
</file>

<file path="apps/admin-dashboard/server/api/store-image.ts">
export default defineEventHandler(async (event) => {
  try {
    console.log('store-image start')
    // !todo: I envision this endpoint being called, fetching all the image URLs that need to be stored
    // We would need to check if we have already stored the image, and if not, fetch and store it
    // When storing it would need to be stored in a folder using the news.id as the folder name
    // image name doesn't matter
    // then we would need to update the news.featured_image with the new URL

    // Fetch the image as a blob
    const imgBlob = await $fetch(
      'https://cdn.mos.cms.futurecdn.net/594rdNk4Ci9qT8e2XKsQ7Q-970-80.jpg.webp',
      { responseType: 'blob' },
    )

    console.log('Image fetched', imgBlob)

    // Get the Supabase client
    const supabase = await dbClient(event)

    // Upload the blob to Supabase Storage
    const { data, error } = await supabase.storage.from('posts').upload('public/test.webp', imgBlob)

    if (error) {
      throw createError({ message: `Error uploading image: ${error.message}` })
    }

    console.log('Image uploaded successfully')

    return {
      status: 200,
      message: 'Image Stored',
    }
  } catch (error: any) {
    console.error('store-image error', error.message)
    return {
      status: 500,
      message: 'Error Storing Image',
      error,
    }
  }
})
</file>

<file path="apps/admin-dashboard/server/utils/socials/getYoutubeContent.ts">
import { useErrorHandler } from '@ib/logger'

interface YouTubeVideo {
  title: string
  description: string
  publishedAt: string
  videoId: string
}

interface YouTubeProfile {
  name: string
  description: string
  subscriberCount: number
  videos: YouTubeVideo[]
}

const YOUTUBE_API_URL = 'https://www.googleapis.com/youtube/v3/'
const GOOGLE_API_KEY = useRuntimeConfig().googleApiKey

export async function getYoutubeContent(username: string): Promise<YouTubeProfile | null> {
  try {
    // Fetch the channel details by username
    const channelResponse = await $fetch(`${YOUTUBE_API_URL}channels`, {
      params: {
        forHandle: username,
        part: 'snippet,contentDetails,statistics',
        key: GOOGLE_API_KEY,
      },
    })

    console.log('channelRes', channelResponse)

    if (channelResponse.items.length === 0) {
      return null
      // No channel found
    }

    const channel = channelResponse.items[0]
    const uploadsPlaylistId = channel.contentDetails.relatedPlaylists.uploads

    // Fetch the latest videos from the uploads playlist
    const videosResponse = await $fetch(`${YOUTUBE_API_URL}playlistItems`, {
      params: {
        part: 'id,snippet,contentDetails',
        maxResults: 12,
        playlistId: uploadsPlaylistId,
        key: GOOGLE_API_KEY,
      },
    })

    const videos = videosResponse.items.map((item: any) => ({
      title: item.snippet.title,
      description: item.snippet.description,
      publishedAt: item.snippet.publishedAt,
      videoId: item.contentDetails.videoId,
    }))

    console.log('videos', videos)

    return {
      name: channel.snippet.title,
      description: channel.snippet.description,
      subscriberCount: channel.statistics.subscriberCount,
      videos,
    }
  } catch (error) {
    console.error('Failed to fetch YouTube profile details:', error)
    return null
  }
}

export function useYoutubeChannel(channelId: string) {
  const errors = useErrorHandler('getYoutubeChannelAnalytics')

  async function fetchChannelStatistics() {
    const url = `${YOUTUBE_API_URL}channels?part=statistics&id=${channelId}&key=${GOOGLE_API_KEY}`
    const response = await $fetch(url)
    const data = errors.handleFetchError({
      response,
      devMessage: `Failed to fetch channel statistics for ${channelId}`,
      userMessage: `Failed to fetch statistics for channel ${channelId}`,
    })
    return data.items[0].statistics
  }

  async function fetchChannelVideos() {
    const url = `${YOUTUBE_API_URL}search?key=${GOOGLE_API_KEY}&channelId=${channelId}&part=snippet,id&order=date&maxResults=5`
    const response = await $fetch(url)
    const data = errors.handleFetchError({
      response,
      devMessage: `Failed to fetch channel videos for ${channelId}`,
      userMessage: `Failed to fetch videos for channel ${channelId}`,
    })

    return data.items
  }

  async function fetchVideoStatistics(videoId: string) {
    const url = `${YOUTUBE_API_URL}videos?part=statistics&id=${videoId}&key=${GOOGLE_API_KEY}`
    const response = await $fetch(url)
    const data = errors.handleFetchError({
      response,
      devMessage: `Failed to fetch video statistics for ${channelId}`,
      userMessage: `Failed to fetch video statistics for channel ${channelId}`,
    })
    return data.items[0].statistics
  }

  return {
    fetchChannelStatistics,
    fetchChannelVideos,
    fetchVideoStatistics,
  }
}
</file>

<file path="apps/admin-dashboard/server/utils/socials/useInstagramAnalytics.ts">
import { useErrorHandler, useLoggerAsync } from '@ib/logger'

const INSTAGRAM_API_URL = 'https://graph.instagram.com'
const ACCESS_TOKEN = 'YOUR_INSTAGRAM_ACCESS_TOKEN'
const PREFIX = 'useInstagramAnalytics'

export async function useInstagramAnalytics() {
  const log = await useLoggerAsync(PREFIX)
  const errors = useErrorHandler(PREFIX)

  async function fetchProfileStatistics(userId: string) {
    log.info(`Fetching instagram profile statistics for: ${userId}`)
    const url = `${INSTAGRAM_API_URL}/${userId}?fields=id,username,media_count,followers_count,follows_count&access_token=${ACCESS_TOKEN}`
    const response = await $fetch(url)
    const data = errors.handleFetchError({
      response,
      devMessage: `Failed to fetch profile statistics for ${userId}`,
      userMessage: `Failed to fetch statistics for profile ${userId}`,
    })
    return data
  }

  async function fetchBusinessAnalytics(username: string) {
    const url = `${INSTAGRAM_API_URL}/${userId}?fields=business_discovery.username(${username}){followers_count,media_count,media{comments_count,like_count}}&access_token=${ACCESS_TOKEN}`
    const response = await $fetch(url, {
      headers: {
        Authorization: `Bearer ${ACCESS_TOKEN}`,
      },
    })
    const data = errors.handleFetchError({
      response,
      devMessage: `Failed to fetch business analytics for ${username}`,
      userMessage: `Failed to fetch analytics for ${username}`,
    })
    return {
      followers_count: data.business_discovery.followers_count,
      media_count: data.business_discovery.media_count,
      media: data.business_discovery.media.data.map((mediaItem: any) => ({
        id: mediaItem.id,
        comments_count: mediaItem.comments_count,
        like_count: mediaItem.like_count,
      })),
    }
  }

  return {
    fetchProfileStatistics,
    fetchBusinessAnalytics,
  }
}
</file>

<file path="apps/admin-dashboard/server/utils/socials/useLinkedinAnalytics.ts">
import { useErrorHandler } from '@ib/logger'

const LINKEDIN_API_URL = 'https://api.linkedin.com/rest/dmaOrganizationalPageContentAnalytics'
const ACCESS_TOKEN = 'YOUR_LINKEDIN_ACCESS_TOKEN'

export function useLinkedinAnalytics(postId: string) {
  const errors = useErrorHandler('getLinkedInPageAnalytics')

  // https://learn.microsoft.com/en-us/linkedin/dma/analytics/organizational-page-content-analytics?tabs=http%2Cnon-obfuscated
  async function fetchPostAnalytics() {
    const url = `${LINKEDIN_API_URL}?q=postDimension&sourcePostEntity=${postId}&metricType=IMPRESSIONS,REPOSTS,COMMENTS,REACTIONS&dimensionType=STAFF_COUNT_RANGE&access_token=${ACCESS_TOKEN}`
    const response = await $fetch(url, {
      headers: {
        Authorization: `Bearer ${ACCESS_TOKEN}`,
      },
    })
    const data = errors.handleFetchError({
      response,
      devMessage: `Failed to fetch post analytics for ${postId}`,
      userMessage: `Failed to fetch analytics for post ${postId}`,
    })
    return data.elements.map((element: any) => ({
      type: element.type,
      value: element.metric.value.totalCount.long,
    }))
  }

  // Fetch trend data for the LinkedIn organizational page
  async function fetchTrendAnalytics(startDate: number, endDate: number, pageId: string) {
    const url = `${LINKEDIN_API_URL}?q=trend&sourceEntity=urn:li:organizationalPage:${pageId}&metricTypes=List(IMPRESSIONS,COMMENTS,REACTIONS,REPOSTS,ENGAGEMENT_RATE,CTR,ACQUIRED_FOLLOWS)&timeIntervals=(timeRange:(start:${startDate},end:${endDate}))`

    const response = await $fetch(url, {
      headers: {
        Authorization: `Bearer ${ACCESS_TOKEN}`,
      },
    })

    const data = errors.handleFetchError({
      response,
      devMessage: `Failed to fetch trend analytics for page ${pageId}`,
      userMessage: `Failed to fetch trend analytics for page ${pageId}`,
    })

    return data.elements.map((element: any) => ({
      type: element.type,
      value: element.metric.value.totalCount.long || element.metric.value.totalCount.bigDecimal,
    }))
  }

  return {
    fetchPostAnalytics,
    fetchTrendAnalytics,
  }
}
</file>

<file path="apps/admin-dashboard/server/utils/socials/useTwitterAnalytics.ts">
import { useErrorHandler } from '@ib/logger'

// user tweet timeline
// https://developer.twitter.com/en/docs/twitter-api/tweets/timelines/api-reference/get-users-id-tweets

// mentions timeline
// https://developer.twitter.com/en/docs/twitter-api/tweets/timelines/api-reference/get-users-id-mentions

// api reference
// https://github.com/xdevplatform/twitter-api-typescript-sdk

// LINKEDIN

// MANAGE ACCOUNTS
// https://github.com/linkedin-developers/linkedin-api-js-client

// NON OFFICIAL API: https://github.com/tomquirk/linkedin-api

const TWITTER_API_URL = 'https://api.twitter.com/2/tweets'
const BEARER_TOKEN = 'YOUR_TWITTER_BEARER_TOKEN'

export function useTwitterAnalytics(postId: string) {
  const errors = useErrorHandler('getTwitterPostAnalytics')

  //
  async function fetchPostAnalytics() {
    const url = `${TWITTER_API_URL}/${postId}?tweet.fields=non_public_metrics,organic_metrics&expansions=attachments.media_keys&media.fields=non_public_metrics,organic_metrics`
    const response = await $fetch(url, {
      headers: {
        Authorization: `Bearer ${BEARER_TOKEN}`,
      },
    })
    const data = errors.handleFetchError({
      response,
      devMessage: `Failed to fetch post analytics for ${postId}`,
      userMessage: `Failed to fetch analytics for post ${postId}`,
    })
    return {
      impression_count: data.data.non_public_metrics.impression_count,
      like_count: data.data.organic_metrics.like_count,
      reply_count: data.data.organic_metrics.reply_count,
      retweet_count: data.data.organic_metrics.retweet_count,
      quote_count: data.data.public_metrics.quote_count,
      url_link_clicks: data.data.non_public_metrics.url_link_clicks,
      user_profile_clicks: data.data.non_public_metrics.user_profile_clicks,
      media: data.includes.media,
    }
  }

  async function fetchUserProfile(userId: string) {
    const url = `${TWITTER_API_URL}/users/${userId}?user.fields=created_at,description,entities,id,location,name,pinned_tweet_id,profile_image_url,protected,url,username,verified,withheld&expansions=pinned_tweet_id`
    const response = await $fetch(url, {
      headers: {
        Authorization: `Bearer ${BEARER_TOKEN}`,
      },
    })
    const data = errors.handleFetchError({
      response,
      devMessage: `Failed to fetch user profile for ${userId}`,
      userMessage: `Failed to fetch profile for user ${userId}`,
    })
    return {
      id: data.data.id,
      name: data.data.name,
      username: data.data.username,
      created_at: data.data.created_at,
      description: data.data.description,
      entities: data.data.entities,
      location: data.data.location,
      pinned_tweet_id: data.data.pinned_tweet_id,
      profile_image_url: data.data.profile_image_url,
      protected: data.data.protected,
      url: data.data.url,
      verified: data.data.verified,
      withheld: data.data.withheld,
      pinned_tweet: data.includes.tweets ? data.includes.tweets[0] : null,
    }
  }

  return {
    fetchPostAnalytics,
    fetchUserProfile,
  }
}
</file>

<file path="apps/admin-dashboard/app.vue">
<script setup lang="ts">
import { onMounted, onUnmounted } from 'vue'
import { useServerAnalyticsStore } from '#imports'

const serverAnalyticsStore = useServerAnalyticsStore()

onMounted(() => {
  serverAnalyticsStore.connectWebSocket()
  serverAnalyticsStore.subscribeToMetrics(['all'])
})

onUnmounted(() => {
  serverAnalyticsStore.disconnectWebSocket()
})
</script>

<template>
  <div class="h-full w-full">
    <NuxtLoadingIndicator />
    <NuxtLayout>
      <NuxtPage />
    </NuxtLayout>
    <PrimeToast position="bottom-right" />
  </div>
</template>

<style>
html {
  margin: 0;
  padding: 0;
}

#__nuxt {
  width: 100%;
  height: 100%;
  padding: 0;
  margin: 0;
}

.layout-enter-active,
.layout-leave-active {
  transition: all 0.4s;
}

.layout-enter-from,
.layout-leave-to {
  opacity: 0;
  filter: blur(1rem);
}
</style>
</file>

<file path="apps/admin-dashboard/nuxt.config.ts">
import { fileURLToPath } from 'url'
import { dirname, join, resolve } from 'path'
import { defineNuxtConfig } from 'nuxt/config'
import runtimeConfig from '../../shared-runtime.config'

const currentDir = dirname(fileURLToPath(import.meta.url))

export default defineNuxtConfig({
  workspaceDir: '../../',
  srcDir: '.',
  extends: ['../../layers/base', '../../layers/auth', '../../layers/crud', '../../layers/advert'],
  modules: [
    '@nuxt/devtools',
    '@vueuse/nuxt',
    '@nuxt/content',
    '@nuxt/image',
    '@pinia/nuxt',
    '@nuxt/icon',
    '@nuxt/eslint',
    '@nuxtjs/tailwindcss',
    '@nuxtjs/supabase',
    '@primevue/nuxt-module',
  ],

  ssr: false,

  nitro: {
    experimental: {
      websocket: true,
    },
  },

  // tailwindcss: {
  //   configPath: `${currentDir}/tailwind.config.ts`,
  // cssPath: [`${currentDir}/assets/css/tailwind.css`, { injectPosition: 0 }],
  //   exposeConfig: true,
  //   viewer: true,
  // },

  primevue: {
    importPT: { from: resolve(currentDir, '../../theme/index.js') },
    autoImport: true,
    components: {
      prefix: 'Prime',
      include: '*',
      exclude: ['Editor'],
    },

    composables: {
      include: '*',
    },

    options: {
      ripple: true,
      unstyled: true,
      theme: {
        options: {
          cssLayer: {
            name: 'primevue',
            order: 'tailwind-base, primevue, tailwind-utilities',
          },
        },
      },
    },
  },

  ...runtimeConfig,
})
</file>

<file path="apps/admin-dashboard/tailwind.config.ts">
import { fileURLToPath } from 'url'
import { dirname, resolve } from 'path'
import type { Config } from 'tailwindcss'
import baseConfig from '../../tailwind.config.base'

const currentDir = dirname(fileURLToPath(import.meta.url))

const config: Partial<Config> = {
  presets: [baseConfig],
  content: [
    resolve(currentDir, 'pages/**/*.{js,vue,ts}'),
    resolve(currentDir, 'layouts/**/*.{js,vue,ts}'),
    resolve(currentDir, 'composables/**/*.{js,vue,ts}'),
    resolve(currentDir, 'components/**/*.{js,vue,ts}'),
    '../../theme/**/*.{js,css,ts}',
  ],
  exclude: ['server/**/*'],
}

export default config
</file>

<file path="shared-runtime.config.ts">
import { config } from 'dotenv'

config()

export default defineNuxtConfig({
  runtimeConfig: {
    public: {
      strapiUrl: process.env.NUXT_PUBLIC_STRAPI_URL,
      formbricksEnvironment: process.env.NUXT_PUBLIC_FORMBRICKS_ENVIRONMENT,
      formbricksHost: process.env.NUXT_PUBLIC_FORMBRICKS_HOST,
      supabaseUrl: process.env.NUXT_PUBLIC_SUPABASE_URL,
      supabaseKey: process.env.NUXT_PUBLIC_SUPABASE_KEY,
      aeAuthUrl: process.env.NUXT_PUBLIC_AE_AUTH_URL,
      aeLoginUrl: process.env.NUXT_PUBLIC_AE_LOGIN_URL,
      aeAppUrl: process.env.NUXT_PUBLIC_AE_APP_URL,
      aeAdminUrl: process.env.NUXT_PUBLIC_AE_ADMIN_URL,
      aeMonitoringUrl: process.env.NUXT_PUBLIC_AE_MONITORING_URL,
      aeWebsiteUrl: process.env.NUXT_PUBLIC_AE_WEBSITE_URL,
      nodeEnv: process.env.NUXT_PUBLIC_NODE_ENV,
      logLevel: process.env.NUXT_PUBLIC_LOG_LEVEL,
      posthogKey: process.env.NUXT_PUBLIC_POSTHOG_KEY,
      posthogUrl: process.env.NUXT_PUBLIC_POSTHOG_URL,
      studioTokens: process.env.NUXT_PUBLIC_STUDIO_TOKENS,
      scraperUrl: process.env.NUXT_PUBLIC_SCRAPER_URL,
      devHelper: {
        enabled: true,
        features: {
          networkErrorClassifier: true,
          infiniteLoopDetector: true,
          unhandledPromiseRejectionTracker: true,
          environmentConsistencyChecker: true,
        },
      },
    },
    strapiUrl: process.env.NUXT_STRAPI_URL,
    supabaseServiceKey: process.env.NUXT_SUPABASE_SERVICE_KEY,
    googleApiKey: process.env.NUXT_GOOGLE_API_KEY,
    nasaApiKey: process.env.NUXT_NASA_API_KEY,
    openaiApiKey: process.env.NUXT_OPENAI_API_KEY,
    openaiOrg: process.env.NUXT_OPENAI_ORG,
    redisFlushKey: process.env.NUXT_REDIS_FLUSH_KEY,
    scraperKey: process.env.NUXT_SCRAPER_KEY,
    razorpayKey: process.env.NUXT_RAZORPAY_KEY,
    razorpaySecret: process.env.NUXT_RAZORPAY_SECRET,
    razorpayTestKey: process.env.NUXT_RAZORPAY_TEST_KEY,
    razorpayTestSecret: process.env.NUXT_RAZORPAY_TEST_SECRET,
  },
})
</file>

</repository_files>
