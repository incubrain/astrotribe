This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-11-21T14:48:12.590Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>

<additional_info>

For more information about Repomix, visit: https://github.com/yamadashy/repomix
</additional_info>

</file_summary>

<repository_structure>
apps/
  monitoring-dashboard/
    components/
      LogList.vue
    layouts/
      default.vue
    middleware/
      is-super-admin.ts
    pages/
      index.vue
      not-authorized.vue
    server/
      api/
        logs.get.ts
    types/
      auth.ts
    app.vue
    nuxt.config.ts
    README.md
    tailwind.config.ts
shared-runtime.config.ts
</repository_structure>

<repository_files>
This section contains the contents of the repository's files.

<file path="apps/monitoring-dashboard/components/LogList.vue">
<script setup lang="ts">
const logs = ref([])

onMounted(async () => {
  const response = await $fetch('/api/logs', { method: 'GET' })
  logs.value = response
})
</script>

<template>
  <div>
    <h2>Logs</h2>
    <ul>
      <li
        v-for="log in logs"
        :key="log._time"
      >
        {{ log._time }} - {{ log.message }}
      </li>
    </ul>
  </div>
</template>
</file>

<file path="apps/monitoring-dashboard/layouts/default.vue">
<script setup lang="ts"></script>

<template>
  <div class="relative flex h-full min-h-screen w-full items-center justify-start">
    <slot />
  </div>
</template>

<style scoped></style>
</file>

<file path="apps/monitoring-dashboard/middleware/is-super-admin.ts">
export default defineNuxtRouteMiddleware(async (to, from) => {
  const user = useSupabaseUser()

  // Check for super_admin role
  const role = user.app_metadata?.role || []
  if (role !== 'super_admin') {
    console.log('Not super_admin')
    // return navigateTo('/not-authorized')
  }
})
</file>

<file path="apps/monitoring-dashboard/pages/index.vue">
<script lang="ts" setup></script>

<template>
  <div>
    <h1>Logging Dashboard</h1>
    <LogList />
  </div>
</template>

<style></style>
</file>

<file path="apps/monitoring-dashboard/pages/not-authorized.vue">
<template>
  <div> you are not authorized to see this </div>
</template>

<script setup lang="ts"></script>

<style scoped></style>
</file>

<file path="apps/monitoring-dashboard/server/api/logs.get.ts">
// server/api/logs.get.ts

import { defineEventHandler } from 'h3'
import { InfluxDB } from '@influxdata/influxdb-client'

export default defineEventHandler(async (event) => {
  const config = useRuntimeConfig()

  // Create InfluxDB client
  const influxDB = new InfluxDB({
    url: config.influxUrl,
    token: config.influxToken,
  })

  const queryApi = influxDB.getQueryApi(config.influxOrg)

  // Extract query parameters if needed
  const queryParams = getQuery(event)

  // Build InfluxDB query
  const query = `from(bucket: "${config.influxBucket}")
    |> range(start: -1h)
    |> filter(fn: (r) => r._measurement == "logs")`

  const data = []
  await queryApi.collectRows(query, {
    next: (row) => data.push(row),
    error: (error) => console.error(error),
    complete: () => console.log('Query completed'),
  })

  return data
})
</file>

<file path="apps/monitoring-dashboard/types/auth.ts">
import { z } from 'zod'

export const identitySchema = z.object({
  id: z.string(),
  user_id: z.string(),
  identity_data: z.object({
    email: z.string().email(),
    sub: z.string(),
  }),
  provider: z.string(),
  last_sign_in_at: z.string(),
  created_at: z.string(),
  updated_at: z.string(),
})

export const emailUnvalidatedUserSchema = z.object({
  id: z.string(),
  aud: z.string(),
  role: z.string(),
  email: z.string().email(),
  phone: z.string().optional(),
  confirmation_sent_at: z.string().optional(),
  app_metadata: z.object({
    provider: z.string(),
    providers: z.array(z.string()),
  }),
  user_metadata: z.record(z.any()).optional(),
  identities: z.array(identitySchema),
  created_at: z.string().optional(),
  updated_at: z.string().optional(),
})

export const userSchema = z.object({
  id: z.string(),
  aud: z.string(),
  role: z.string().optional(),
  email: z.string().email().optional(),
  email_confirmed_at: z.string().optional(),
  phone: z.string().optional(),
  confirmation_sent_at: z.string().optional(),
  confirmed_at: z.string().optional(),
  last_sign_in_at: z.string().optional(),
  app_metadata: z.object({
    provider: z.string().optional(),
    providers: z.array(z.string()).optional(),
  }),
  user_metadata: z.record(z.any()),
  identities: z.array(identitySchema).optional(),
  created_at: z.string().optional(),
  updated_at: z.string().optional(),
})

export const sessionSchema = z.object({
  access_token: z.string(),
  refresh_token: z.string(),
  user: userSchema.optional(),
  token_type: z.string(),
  expires_in: z.number(),
  expires_at: z.number().optional(),
})

export const authSchema = z.object({
  user: userSchema,
  session: sessionSchema,
})

export const simpleUserSchema = z.object({
  email: z.string().email(),
  password: z.string(),
})

// Infer the types
export type AuthTypeType = z.infer<typeof authSchema>
export type SimpleUserTypeType = z.infer<typeof simpleUserSchema>
export type EmailUnvalidatedUserTypeType = z.infer<typeof emailUnvalidatedUserSchema>
export type UserTypeType = z.infer<typeof userSchema>
export type SessionTypeType = z.infer<typeof sessionSchema>
</file>

<file path="apps/monitoring-dashboard/app.vue">
<template>
  <div class="h-full w-full">
    <NuxtLoadingIndicator />
    <NuxtLayout>
      <NuxtPage />
    </NuxtLayout>
    <PrimeToast position="bottom-right" />
  </div>
</template>

<style>
html {
  margin: 0;
  padding: 0;
}

#__nuxt {
  width: 100%;
  height: 100%;
  padding: 0;
  margin: 0;
}

.layout-enter-active,
.layout-leave-active {
  transition: all 0.4s;
}

.layout-enter-from,
.layout-leave-to {
  opacity: 0;
  filter: blur(1rem);
}
</style>
</file>

<file path="apps/monitoring-dashboard/nuxt.config.ts">
import { fileURLToPath } from 'url'
import { dirname, join, resolve } from 'path'
import { defineNuxtConfig } from 'nuxt/config'
import runtimeConfig from '../../shared-runtime.config'

const currentDir = dirname(fileURLToPath(import.meta.url))

export default defineNuxtConfig({
  workspaceDir: '../../',
  srcDir: '.',
  extends: ['../../layers/base', '../../layers/auth'],
  modules: ['@primevue/nuxt-module'],

  routeRules: {
    '/**': { appMiddleware: 'auth' },
  },

  tailwindcss: {
    configPath: `${currentDir}/tailwind.config.ts`,
    cssPath: [`${currentDir}/assets/css/tailwind.css`, { injectPosition: 0 }],
    exposeConfig: true,
    viewer: true,
  },

  primevue: {
    importPT: { from: resolve(currentDir, '../../theme/index.js') },
    autoImport: true,
    components: {
      prefix: 'Prime',
      include: '*',
      exclude: ['Editor'],
    },

    composables: {
      include: '*',
    },

    options: {
      ripple: true,
      unstyled: true,
      theme: {
        options: {
          cssLayer: {
            name: 'primevue',
            order: 'tailwind-base, primevue, tailwind-utilities',
          },
        },
      },
    },
  },

  imports: {
    autoImport: true,
  },

  ...runtimeConfig,
})
</file>

<file path="apps/monitoring-dashboard/README.md">
# Nuxt 3 Minimal Starter

Look at the [Nuxt 3 documentation](https://nuxt.com/docs/getting-started/introduction) to learn
more.

## Setup

Make sure to install the dependencies:

```bash
# npm
npm install

# pnpm
pnpm install

# yarn
yarn install

# bun
bun install
```

## Development Server

Start the development server on `http://localhost:3000`:

```bash
# npm
npm run dev

# pnpm
pnpm run dev

# yarn
yarn dev

# bun
bun run dev
```

## Production

Build the application for production:

```bash
# npm
npm run build

# pnpm
pnpm run build

# yarn
yarn build

# bun
bun run build
```

Locally preview production build:

```bash
# npm
npm run preview

# pnpm
pnpm run preview

# yarn
yarn preview

# bun
bun run preview
```

Check out the [deployment documentation](https://nuxt.com/docs/getting-started/deployment) for more
information.
</file>

<file path="apps/monitoring-dashboard/tailwind.config.ts">
import { fileURLToPath } from 'url'
import { dirname, resolve } from 'path'
import type { Config } from 'tailwindcss'
import baseConfig from '../../tailwind.config.base'

const currentDir = dirname(fileURLToPath(import.meta.url))

const config: Partial<Config> = {
  presets: [baseConfig],
  theme: {
    extend: {
      // Add app-specific extensions here
    },
  },
  content: [resolve(currentDir, '**/*.{js,vue,ts}'), '../../theme/**/*.{js,css,ts}'],
}

export default config
</file>

<file path="shared-runtime.config.ts">
import { config } from 'dotenv'

config()

export default defineNuxtConfig({
  runtimeConfig: {
    public: {
      strapiUrl: process.env.NUXT_PUBLIC_STRAPI_URL,
      formbricksEnvironment: process.env.NUXT_PUBLIC_FORMBRICKS_ENVIRONMENT,
      formbricksHost: process.env.NUXT_PUBLIC_FORMBRICKS_HOST,
      supabaseUrl: process.env.NUXT_PUBLIC_SUPABASE_URL,
      supabaseKey: process.env.NUXT_PUBLIC_SUPABASE_KEY,
      aeAuthUrl: process.env.NUXT_PUBLIC_AE_AUTH_URL,
      aeLoginUrl: process.env.NUXT_PUBLIC_AE_LOGIN_URL,
      aeAppUrl: process.env.NUXT_PUBLIC_AE_APP_URL,
      aeAdminUrl: process.env.NUXT_PUBLIC_AE_ADMIN_URL,
      aeMonitoringUrl: process.env.NUXT_PUBLIC_AE_MONITORING_URL,
      aeWebsiteUrl: process.env.NUXT_PUBLIC_AE_WEBSITE_URL,
      nodeEnv: process.env.NUXT_PUBLIC_NODE_ENV,
      logLevel: process.env.NUXT_PUBLIC_LOG_LEVEL,
      posthogKey: process.env.NUXT_PUBLIC_POSTHOG_KEY,
      posthogUrl: process.env.NUXT_PUBLIC_POSTHOG_URL,
      studioTokens: process.env.NUXT_PUBLIC_STUDIO_TOKENS,
      scraperUrl: process.env.NUXT_PUBLIC_SCRAPER_URL,
      devHelper: {
        enabled: true,
        features: {
          networkErrorClassifier: true,
          infiniteLoopDetector: true,
          unhandledPromiseRejectionTracker: true,
          environmentConsistencyChecker: true,
        },
      },
    },
    strapiUrl: process.env.NUXT_STRAPI_URL,
    supabaseServiceKey: process.env.NUXT_SUPABASE_SERVICE_KEY,
    googleApiKey: process.env.NUXT_GOOGLE_API_KEY,
    nasaApiKey: process.env.NUXT_NASA_API_KEY,
    openaiApiKey: process.env.NUXT_OPENAI_API_KEY,
    openaiOrg: process.env.NUXT_OPENAI_ORG,
    redisFlushKey: process.env.NUXT_REDIS_FLUSH_KEY,
    scraperKey: process.env.NUXT_SCRAPER_KEY,
    razorpayKey: process.env.NUXT_RAZORPAY_KEY,
    razorpaySecret: process.env.NUXT_RAZORPAY_SECRET,
    razorpayTestKey: process.env.NUXT_RAZORPAY_TEST_KEY,
    razorpayTestSecret: process.env.NUXT_RAZORPAY_TEST_SECRET,
  },
})
</file>

</repository_files>
