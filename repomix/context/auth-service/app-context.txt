This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-11-21T14:47:33.470Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>

<additional_info>

For more information about Repomix, visit: https://github.com/yamadashy/repomix
</additional_info>

</file_summary>

<repository_structure>
apps/
  auth-service/
    components/
      form/
        FormPassword.vue
      AuthCard.vue
      AuthRegisterWith.vue
      AuthSocialButton.vue
      AuthVerifiedWith.vue
    composables/
      auth.composable.ts
    layouts/
      default.vue
    middleware/
      auth.global.ts
    pages/
      forgot-password.vue
      index.vue
      login.vue
      register.vue
      success.vue
    server/
      routes/
        session.ts
        signin.post.ts
      utils/
        getUserSession.ts
        secretManager.ts
    types/
      auth.ts
    app.vue
    nuxt.config.ts
    README.md
    tailwind.config.ts
shared-runtime.config.ts
</repository_structure>

<repository_files>
This section contains the contents of the repository's files.

<file path="apps/auth-service/components/form/FormPassword.vue">
<script setup lang="ts">
interface Props {
  modelValue: string
  id?: string
  suggestions?: string[]
  invalid?: boolean
  placeholder?: string
  disabled?: boolean
  required?: boolean
  inputClass?: string
  label?: string
  mediumRegex?: string
  strongRegex?: string
  feedback?: boolean
}

const props = withDefaults(defineProps<Props>(), {
  label: undefined,
  id: 'password',
  suggestions: () => [
    'At least one lowercase',
    'At least one uppercase',
    'At least one numeric',
    'Minimum 6 characters',
  ],
  invalid: false,
  feedback: true,
  placeholder: undefined,
  disabled: false,
  required: false,
  inputClass: 'w-full',
  mediumRegex:
    '^(((?=.*[a-z])(?=.*[A-Z]))|((?=.*[a-z])(?=.*[0-9]))|((?=.*[A-Z])(?=.*[0-9])))(?=.{6,})',
  strongRegex: '^(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9])(?=.{8,})',
})

const emit = defineEmits<{
  (e: 'update:modelValue', value: string): void
}>()

const onPasswordChange = (value: string) => {
  emit('update:modelValue', value)
}
</script>

<template>
  <label
    v-if="label"
    :for="id"
    >{{ label }}</label
  >
  <PrimePassword
    :id="id"
    class="w-full"
    :input-class="inputClass"
    :feedback="props.feedback"
    :model-value="modelValue"
    :invalid="invalid"
    :disabled="disabled"
    :required="required"
    :placeholder="placeholder"
    :label="props.label"
    @update:model-value="onPasswordChange"
  >
    <template #footer>
      <PrimeDivider />
      <p class="mt-2"> Suggestions </p>
      <ul
        class="ml-2 mt-0 pl-2"
        style="line-height: 1.5"
      >
        <li
          v-for="suggestion in props.suggestions"
          :key="suggestion"
        >
          {{ suggestion }}
        </li>
      </ul>
    </template>
  </PrimePassword>
</template>

<style scoped></style>
</file>

<file path="apps/auth-service/components/AuthCard.vue">
<script setup lang="ts">
import type { TitleType } from '@/types/content'

defineProps({
  title: {
    type: Object as PropType<TitleType>,
    default: () => ({
      main: 'main title',
      subtitle: 'subtitle',
      label: 'label',
    }),
  },
  helpUrl: {
    type: String,
    default: '/login',
  },
  showTitle: {
    type: Boolean,
    default: false,
  },
})

// const currentUser = useCurrentUser()
// const { haveUserSession } = storeToRefs(currentUser)
</script>

<template>
  <div class="space-between flex min-h-full flex-col space-y-4">
    <div class="flex h-full w-full flex-row items-center justify-center gap-4 py-8 text-white">
      <div class="border-color group relative rounded-full border bg-white p-4 hover:invert">
        <NuxtLink
          to="/"
          class="flex items-center justify-center"
        >
          <IBImage
            class="group-hover:opacity-0"
            :img="{
              src: 'astronera-logo.jpg',
              alt: 'AstronEra Logo',
              width: '60',
              height: '60',
            }"
          />
          <p class="absolute mx-auto my-auto hidden text-black group-hover:flex"> Go Home </p>
        </NuxtLink>
      </div>
      <div class="w-full">
        <h2 class="text-3xl font-extrabold lg:text-center">
          {{ title.main }}
        </h2>
        <span class="flex items-center gap-4 text-center font-bold lg:justify-center">
          {{ title.subtitle }}
          <NuxtLink
            v-if="helpUrl && title.label"
            :to="helpUrl"
            class="text-primary-500 underline"
          >
            <PrimeButton>
              {{ title.label }}
            </PrimeButton>
          </NuxtLink>
        </span>
      </div>
    </div>
    <PrimeCard>
      <!-- <template
        v-if="showTitle && haveUserSession"
        #title
      >
        <div class="flex flex-col gap-4 xl:gap-6">
          <div>
            <AuthVerifiedWith class="w-full" />

            <div class="w-full pt-4">
              <PrimeDivider
                layout="horizontal"
                class="justify-left flex items-center"
              >
                <p>Or Login with</p>
              </PrimeDivider>
            </div>
          </div>
        </div>
      </template> -->
      <template #content>
        <div class="flex flex-col gap-4 xl:gap-6">
          <slot name="content" />
        </div>
      </template>
      <template #footer>
        <slot name="footer" />
      </template>
    </PrimeCard>
  </div>
</template>

<style scoped></style>
</file>

<file path="apps/auth-service/components/AuthRegisterWith.vue">
<script setup lang="ts">
const auth = useUserAuth()
</script>

<template>
  <div class="w-full h-full">
    <div class="w-full">
      <PrimeDivider
        layout="horizontal"
        class="flex justify-left items-center"
      >
        <p>Or continue with</p>
      </PrimeDivider>
    </div>
    <div class="flex gap-4 xl:gap-6 w-full pt-4">
      <AuthSocialButton
        provider="twitter"
        @social-login="auth.loginSocial('twitter')"
      />
      <AuthSocialButton
        provider="linkedin"
        @social-login="auth.loginSocial('linkedin_oidc')"
      />
    </div>
  </div>
</template>

<style></style>
</file>

<file path="apps/auth-service/components/AuthSocialButton.vue">
<script setup lang="ts">
type Provider = 'twitter' | 'linkedin'

defineProps({
  provider: {
    type: String as PropType<Provider>,
    required: true,
  },
})

const emit = defineEmits(['social-login'])

const socialLogin = () => {
  emit('social-login')
}
</script>

<template>
  <PrimeButton @click="socialLogin">
    <span>
      <Icon
        class="flex items-center justify-center"
        :name="`mdi:${provider}`"
        size="30px"
      />
    </span>
  </PrimeButton>
</template>
</file>

<file path="apps/auth-service/components/AuthVerifiedWith.vue">
<script setup lang="ts">
import { useChangeCase } from '@vueuse/integrations/useChangeCase'

const currentUser = useCurrentUser()
const { haveUserSession, registeredWithProvider } = storeToRefs(currentUser)

const currentProvider = computed(() => {
  return useChangeCase(registeredWithProvider.value, 'capitalCase').value
})

const verifiedIcon = computed(() => {
  if (registeredWithProvider.value === 'email') {
    return 'mdi:email'
  } else if (registeredWithProvider.value === 'google') {
    return 'mdi:google'
  } else if (registeredWithProvider.value === 'facebook') {
    return 'mdi:facebook'
  } else if (registeredWithProvider.value === 'twitter') {
    return 'mdi:twitter'
  } else if (registeredWithProvider.value === 'linkedin_oidc') {
    return 'mdi:linkedin'
  } else {
    return 'mdi:account'
  }
})
</script>

<template>
  <div
    v-if="haveUserSession"
    class="flex items-center justify-start"
  >
    <div class="flex flex-col items-center">
      <NuxtLink
        v-ripple
        to="/"
      >
        <PrimeButton>
          Visit Dashboard
          <Icon
            name="mdi:play"
            size="24px"
          />
        </PrimeButton>
      </NuxtLink>
    </div>
  </div>
</template>

<style scoped></style>
</file>

<file path="apps/auth-service/composables/auth.composable.ts">
import { z } from 'zod'
import { useLogger } from '@ib/logger'

const passwordValidation = z
  .string()
  .min(8, 'Password must contain 6 characters')
  .regex(/[A-Z]/, 'Password must contain an uppercase letter')
  .regex(/[^a-zA-Z0-9]/, 'Password must contain a special character')

export const SettingsPasswordValidation = z
  .object({
    currentPassword: passwordValidation,
    newPassword: passwordValidation,
    confirmNewPassword: passwordValidation,
  })
  .refine((data) => data.newPassword === data.confirmNewPassword, {
    message: "Passwords don't match",
    path: ['confirmNewPassword'],
  })

export type SettingsPasswordType = z.infer<typeof SettingsPasswordValidation>

export function useUserAuth() {
  const { aeAuthUrl, aeAppUrl } = useRuntimeConfig().public
  const authUrl = aeAuthUrl
  const appUrl = `${aeAppUrl}/auth-callback`

  const logger = useLogger('auth')
  const toast = useNotification()
  const supabase = useSupabaseClient()

  const loading = useLoadingStore()

  // !todo:bug - I believe there is an issue where the token expires for Social login but it doesn't refresh
  // !todo:high - retrieve current user profile

  const userPasswordSettings = reactive({
    currentPassword: 'current password',
    newPassword: 'new password',
    confirmNewPassword: 'confirm new password',
  })

  interface RegisterWithEmail {
    email: string
    password: string
    confirmPassword: string
    given_name: string
    surname: string
  }

  async function registerWithEmail({ email, password, given_name, surname }: RegisterWithEmail) {
    if (loading.isLoading('auth')) {
      return
    }

    loading.setLoading('auth', true)
    console.log('registerWithEmail', email, password, given_name, surname)
    const { error } = await supabase.auth.signUp({
      email,
      password,
      options: {
        data: {
          given_name,
          surname,
        },
      },
    })

    if (error) {
      console.error(error.message)
      toast.error({ summary: 'Register with email', message: error.message })
    } else {
      console.log('success')
      navigateTo('/success')
    }
    loading.setLoading('auth', false)
  }

  async function loginWithEmail(email: string, password: string) {
    const { error } = await supabase.auth.signInWithPassword({
      email,
      password,
    })

    if (error) {
      console.error(error.message)
      toast.error({ summary: 'Login with password', message: error.message })
    } else {
      toast.success({ summary: 'Authenticated', message: 'Logging In...' })
      await new Promise((resolve) => setTimeout(resolve, 1000))
      navigateTo(aeAppUrl, { external: true })
    }
  }

  async function loginSocial(provider: 'linkedin_oidc' | 'twitter') {
    const { data: user, error } = await supabase.auth.signInWithOAuth({
      provider,
      options: {
        redirectTo: appUrl,
      },
    })

    if (error?.message) {
      console.error({ message: error.message })
      toast.error({ summary: `${provider} login:`, message: error.message })
    }

    if (!user) {
      console.error({ message: 'Login failed' })
      toast.error({
        summary: 'Login failed',
        message: `there was an error logging in with ${provider}, no user returned`,
      })
    }
  }

  async function forgotPassword(email: string) {
    // infra:critical:easy:1 - add correct redirect for userId/settings/password
    const { error } = await supabase.auth.resetPasswordForEmail(email, {
      redirectTo: `${authUrl}settings/password`,
    })

    if (error) {
      console.error('Forgot password failed:', error)
      toast.error({ summary: 'Password Reset Failed', message: error.message })
    } else {
      toast.success({
        summary: 'Email Sent',
        message: 'Check your email for a password reset link',
      })
    }
  }

  async function updatePassword(newPassword: string) {
    const { error } = await supabase.auth.updateUser({ password: newPassword })

    if (error) {
      console.error('Password update failed:', error)
      toast.error({ summary: 'Password Update Failed', message: error.message })
    } else {
      toast.success({ summary: 'Password Updated', message: 'Your password has been updated' })
    }
  }

  async function logout() {
    const { error } = await supabase.auth.signOut()
    if (error) {
      console.error('Logout failed:', error)
      toast.error({ summary: 'Logout Failed', message: error.message })
    } else {
      toast.success({ summary: 'You Logged Out', message: 'You have been logged out' })
      navigateTo(aeAuthUrl, { external: true })
    }
  }

  return {
    registerWithEmail,
    loginWithEmail,
    loginSocial,
    logout,
    password: {
      forgot: forgotPassword,
      update: updatePassword,
    },
  }
}
</file>

<file path="apps/auth-service/layouts/default.vue">
<script setup lang="ts">
const isAuthenticating = ref(true)
onMounted(async () => {
  const toast = useNotification()
  const supabase = useSupabaseClient()
  const { data, error } = await supabase.auth.getSession()
  if (!data.session || error) {
    isAuthenticating.value = false
  } else {
    toast.success({ summary: 'Authenticated', message: 'Found user session' })
    await new Promise((resolve) => setTimeout(resolve, 1000))
  }
})

// !todo:consider:2 - add a delay to function execution, fade out the auth cards so the bg image is fully visible for a few seconds, then execute
// !todo:low:1 - add transitions to the auth cards
// !todo:high:1 - add subtitle prompt to all auth cards
// !todo:med:2 - handle session expired, redirect to login with explanation
</script>

<template>
  <div
    v-if="isAuthenticating"
    class="text-white w-screen flex justify-center items-center absolute h-screen z-50 bg-black bg-opacity-50"
    >Looking for a session...</div
  >
  <div
    :class="{ 'pointer-events-none': isAuthenticating }"
    class="relative flex h-full min-h-screen w-full items-center justify-start"
  >
    <div class="foreground relative z-20 min-h-lvh w-full min-w-[340px] max-w-[540px] p-4 lg:p-8">
      <ClientOnly>
        <slot />
      </ClientOnly>
    </div>
    <div class="absolute left-0 top-0 flex h-full w-full">
      <div class="absolute left-0 top-0 h-full w-full bg-black/40" />
      <IBBackground class="left-0 top-0 z-0 hidden lg:fixed lg:block" />

      <IBImage
        :img="{
          src: '/astron-era-hero.jpg',
          alt: '',
        }"
        class="min-h-full w-full object-cover object-center"
      />
    </div>
  </div>
</template>

<style scoped>
::-webkit-scrollbar {
  display: none;
}
</style>
</file>

<file path="apps/auth-service/middleware/auth.global.ts">
import { defineNuxtRouteMiddleware, navigateTo } from '#app'
import { useRuntimeConfig, useSupabaseClient } from '#imports'

export default defineNuxtRouteMiddleware(async (to) => {
  const config = useRuntimeConfig()
  const { aeAppUrl } = config.public
  const supabase = useSupabaseClient()

  const { data, error } = await supabase.auth.getSession()

  if (error || !data.session) {
    console.log('USER_NOT_LOGGED_IN')
  } else {
    console.log('USER_LOGGED_IN', data.session)
    navigateTo(aeAppUrl, { external: true })
  }
})
</file>

<file path="apps/auth-service/pages/forgot-password.vue">
<script setup lang="ts">
// If you use PKCE (default), this link only works on the device or browser where the original reset request was made. Display a message to the user to make sure they don't change devices or browsers.
// redirectTo page (password reset) should require auth to view (should be secure)

const form = reactive({
  email: '',
})

const auth = useUserAuth()

definePageMeta({
  name: 'ForgotPassword',
})
</script>

<template>
  <AuthCard
    :show-title="false"
    :title="{
      main: 'Request Magic Link',
      subtitle: 'Enter your email to get a reset link.',
    }"
  >
    <template #content>
      <div class="flex flex-col gap-4 xl:gap-6">
        <PrimeFloatLabel class="flex flex-col w-full">
          <PrimeInputText
            id="username"
            v-model="form.email"
          />
          <label for="username">Your Registered Email</label>
        </PrimeFloatLabel>
      </div>
    </template>
    <template #footer>
      <PrimeButton
        class="w-full flex justify-center"
        @click="auth.password.forgot(form.email)"
      >
        Request Reset Email
      </PrimeButton>
    </template>
  </AuthCard>
</template>
</file>

<file path="apps/auth-service/pages/index.vue">
<script lang="ts" setup></script>

<template>
  <div> </div>
</template>

<style></style>
</file>

<file path="apps/auth-service/pages/login.vue">
<script setup lang="ts">
const form = ref({
  email: '',
  password: '',
  rememberMe: false,
})

const auth = useUserAuth()

const currentUser = useCurrentUser()
const { haveUserSession } = storeToRefs(currentUser)

definePageMeta({
  name: 'Login',
})
</script>

<template>
  <AuthCard
    :title="{
      main: 'Login to AstronEra',
      subtitle: 'Don\'t have an account?',
      label: 'Sign up',
    }"
    help-url="/register"
  >
    <template #title>
      <div v-if="haveUserSession">
        <AuthVerifiedWith class="w-full" />

        <div class="w-full pt-4">
          <PrimeDivider
            layout="horizontal"
            class="flex justify-left items-center"
          >
            <p>Or Login with</p>
          </PrimeDivider>
        </div>
      </div>
    </template>
    <template #content>
      <PrimeFloatLabel class="flex flex-col w-full">
        <PrimeInputText
          id="username"
          v-model="form.email"
        />
        <label for="username">Username</label>
      </PrimeFloatLabel>

      <PrimeFloatLabel class="flex flex-col w-full">
        <FormPassword v-model="form.password" :feedback="false"/>
        <label for="password">Password</label>
      </PrimeFloatLabel>

      <div class="w-full py-2 flex justify-between">
        <div class="flex gap-2 items-center">
          <PrimeCheckbox
            v-model="form.rememberMe"
            :binary="true"
            value="newsletter"
          />
          <label
            for="ingredient1"
            class="text-sm"
          >
            Newsletter signup
          </label>
        </div>
        <p class="text-sm">
          <NuxtLink to="/forgot-password"> Forgot Password? </NuxtLink>
        </p>
      </div>

      <PrimeButton
        class="justify-center link"
        @click="auth.loginWithEmail(form.email, form.password)"
      >
        Sign in with email
      </PrimeButton>
    </template>
    <template #footer>
      <AuthRegisterWith />
    </template>
  </AuthCard>
</template>
</file>

<file path="apps/auth-service/pages/register.vue">
<script setup lang="ts">
const form = reactive({
  given_name: '',
  surname: '',
  email: '',
  password: '',
  confirmPassword: '',
})

const auth = useUserAuth()

const isPasswordEntered = computed(() => {
  return !!form.password && !!form.confirmPassword
})

const isPasswordValid = computed(() => {
  return form.password === form.confirmPassword && !!form.password && !!form.confirmPassword
})

const isEmailValid = computed(() => {
  return form.email.includes('@') && form.email.includes('.')
})

const isFormValid = computed(() => {
  return isPasswordValid.value && isEmailValid.value && !!form.given_name && !!form.surname
})

definePageMeta({
  name: 'Register',
})
</script>

<template>
  <AuthCard
    :title="{
      main: 'Create an Account',
      subtitle: 'Already have an account?',
      label: 'Login',
    }"
    help-url="/login"
  >
    <template #content>
      <div class="flex flex-col gap-4">
        <div class="flex w-full gap-4">
          <PrimeFloatLabel class="flex w-full flex-col">
            <PrimeInputText
              id="given_name"
              v-model="form.given_name"
              :pt="{ root: 'w-full' }"
              :pt-options="{ mergeProps: true, mergeSections: true }"
            />
            <label for="given_name">Given Name</label>
          </PrimeFloatLabel>
          <PrimeFloatLabel class="flex w-full flex-col">
            <PrimeInputText
              id="surname"
              v-model="form.surname"
              :pt="{ root: 'w-full' }"
              :pt-options="{ mergeProps: true, mergeSections: true }"
            />
            <label for="surname">Surname</label>
          </PrimeFloatLabel>
        </div>
        <PrimeFloatLabel class="flex w-full flex-col">
          <PrimeInputText
            id="email"
            v-model="form.email"
          />
          <label for="email">Email</label>
        </PrimeFloatLabel>
        <FormPassword
          id="user-password"
          v-model="form.password"
          label="Enter your password"
        />
        <FormPassword
          id="confirm-password"
          v-model="form.confirmPassword!"
          label="Confirm password"
          :invalid="!isPasswordValid && isPasswordEntered"
          :feedback="false"
        />
        <PrimeButton
          class="justify-center"
          :disabled="!isFormValid"
          @click="auth.registerWithEmail(form!)"
        >
          Sign up with email
        </PrimeButton>
        <PrimeMessage
          v-show="!isPasswordValid && isPasswordEntered"
          severity="error"
        >
          Passwords do not match
        </PrimeMessage>
      </div>
    </template>
    <template #footer>
      <AuthRegisterWith />
    </template>
  </AuthCard>
</template>
</file>

<file path="apps/auth-service/pages/success.vue">
<script setup lang="ts">
const userStore = useCurrentUser()
const { profile } = storeToRefs(userStore)

definePageMeta({
  name: 'Success',
})
</script>

<template>
  <PrimeCard>
    <template #title>
      <h2 class="text-primary-700 pb-2 text-3xl font-semibold"> SUCCESS! </h2>
    </template>
    <template #subtitle>
      <PrimeMessage
        severity="info"
        class="text-white"
      >
        Please confirm your email
      </PrimeMessage>
    </template>
    <template #content>
      <div class="pt-2">
        <p> We’ve sent a message to your email address: </p>
        <p>
          <strong>{{ profile?.email }}</strong>
        </p>
        <p> with a link to activate your account. </p>
        <div class="w-auto space-x-2 py-4">
          <PrimeTag>
            <a
              target="_blank"
              href="https://mail.google.com/mail/u/0/"
              rel="noopener noreferrer"
            >
              Open Gmail
            </a>
          </PrimeTag>
          <PrimeTag>
            <a
              target="_blank"
              href="https://outlook.live.com/mail/0/inbox"
              rel="noopener noreferrer"
            >
              Open Outlook
            </a>
          </PrimeTag>
        </div>
        <p>Didn’t get an email? Please check your spam folder.</p>
        <p>
          Still nothing?
          <NuxtLink
            class="text-primary-500 underline"
            to="/forgot-password"
          >
            Request another.
          </NuxtLink>
        </p>
      </div>
    </template>
  </PrimeCard>
</template>

<style scoped></style>
</file>

<file path="apps/auth-service/server/routes/session.ts">
export default defineEventHandler(async (event) => {
  try {
    console.log('FETCHING USER SESSION ON SERVER')
    const session = await validateAndUpdateSession()

    if (!session) {
      console.log('No user user session found')
      return {
        error: null,
        status: 200,
        message: 'No user session found',
        data: null,
      }
    }

    return {
      error: null,
      status: 200,
      message: 'User session fetched from session',
      data: session.user,
    }
  } catch (error: any) {
    console.error('session error', error.message)
    return {
      error,
      status: 500,
      message: error.message,
      data: null,
    }
  }
})
</file>

<file path="apps/auth-service/server/routes/signin.post.ts">
export default defineEventHandler(async (event) => {
  if (authenticated) {
    setCookie(event, 'auth_token', token, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      maxAge: 60 * 60 * 24 * 7, // 1 week
      path: '/',
      domain: '.domain.com',
    })
  }
})
</file>

<file path="apps/auth-service/server/utils/getUserSession.ts">
import { getCurrentSecret } from './secretManager'
import { serverSupabaseSession, serverSupabaseClient } from '#supabase/server'

async function fetchPermissions(userPlan: string, userRole: string) {
  const event = useEvent()
  try {
    const supabase = await serverSupabaseClient(event)
    console.log('fetching permissions for: ', userPlan, userRole)
    const { data: planPermissions, error: planError } = await supabase
      .from('plan_permissions')
      .select('*')
      .eq('plan', userPlan)

    const { data: rolePermissions, error: roleError } = await supabase
      .from('role_permissions')
      .select('*')
      .eq('role', userRole)

    if (roleError || planError) {
      console.error('error fetching permission', roleError, planError)
    }

    return {
      role: rolePermissions,
      plan: planPermissions,
    }
  } catch (error: any) {
    console.error('Error fetching permissions:', error.message)
    return null // Return null to indicate failure
  }
}

async function getSession() {
  const event = useEvent()
  const session = await serverSupabaseSession(event)
  return session
}

interface StoredSession {
  refresh_token: string
  expires_at: number
  user: any
}

type Operation = 'select' | 'update' | 'insert' | 'delete'

interface Permission {
  role: string
  table_name: string
  conditions: any
  permissions: Operation[]
}

interface StoredPermissions {
  refresh_token: string
  expires_at: number
  user: {
    email: string | undefined
    auth_role: string | undefined
    confirmation_sent_at: string | undefined
    confirmed_at: string | undefined
    provider: string | undefined
    providers: string[]
    identities: string[] | undefined
    avatar: string | undefined
    full_name: string
    given_name: string
    surname: string
    username: string
    user_id: string
    user_role: string
    user_plan: string
  }
  plan_permissions: Permission[] | undefined
  role_permissions: Permission[] | undefined
}

export async function validateAndUpdateSession() {
  const session = await getSession()
  if (!session) {
    return
  }

  const { user, refresh_token } = session
  if (!user || !refresh_token) {
    throw createError({
      message: `user: ${user.id} or refresh_token: ${refresh_token.length} undefined in session`,
    })
  }

  // SESSION
  const storage = useStorage('session')
  const secretKey = getCurrentSecret()
  const storageKey = `${user.id}:${secretKey}`

  // PERMISSIONS
  const storedPermissions = await storage.getItem<StoredPermissions>(`permissions:${storageKey}`)
  if (
    !storedPermissions ||
    storedPermissions.expires_at < Date.now() ||
    storedPermissions.refresh_token !== refresh_token
  ) {
    const { role: user_role, plan: user_plan } = user.app_metadata

    if (!user_role || !user_plan) {
      throw createError({
        message: `missing user_role: ${user_role} or user_plan: ${user_plan}, unable to fetch user permissions`,
      })

      // redirect to login page
      // clear the cookies
    }

    const permissions = await fetchPermissions(user_plan, user_role)

    if (!permissions) {
      console.error('Failed to fetch new permissions')
      return
    }

    await storage.setItem<StoredPermissions>(`permissions:${storageKey}`, {
      refresh_token,
      expires_at: Date.now() + 60 * 60 * 24 * 7 * 1000, // 1 week in milliseconds
      user: {
        ...user,
        user_id: user.id,
        user_role,
        user_plan,
        email: user.email,
        auth_role: user.role,
        confirmation_sent_at: user.confirmation_sent_at,
        confirmed_at: user.confirmed_at,
        provider: user.app_metadata.provider,
        providers: user.app_metadata.providers,
        identities: user.identities,
        // avatar: formatAvatarUrl({ avatar: user.user_metadata.avatar, id: user.id }),
        full_name: user.user_metadata.full_name,
        given_name: user.user_metadata.given_name ?? user.user_metadata.given_name,
        surname: user.user_metadata.surname ?? user.user_metadata.surname,
        username: user.user_metadata.username,
      },
      plan_permissions: permissions.plan,
      role_permissions: permissions.role,
    })
  } else {
    console.log('Current permissions are valid and do not need updates.')
  }

  return await storage.getItem<StoredPermissions>(`permissions:${storageKey}`)
}

export async function removeSession() {
  const event = useEvent()
  const userId = getRequestHeader(event, 'X-USER-ID')
  const storage = useStorage('session')
  const secretKey = getCurrentSecret()
  const storageKey = `${userId}:${secretKey}`

  console.log('removing session', storageKey)
  await storage.removeItem(`permissions:${storageKey}`)
}

export async function getUserRolePlan() {
  const event = useEvent()
  const userId = getRequestHeader(event, 'X-USER-ID')
  const secretKey = getCurrentSecret()
  const storageKey = `${userId}:${secretKey}`

  console.log('getting user role plan', storageKey)
  const storage = useStorage('session')

  return await storage.getItem<StoredSession>(`user:${storageKey}`)
}

export async function getUserPermissions() {
  const event = useEvent()
  const userId = getRequestHeader(event, 'X-USER-ID')
  const secretKey = getCurrentSecret()
  const storageKey = `${userId}:${secretKey}`

  console.log('getting user permissions', storageKey)
  const storage = useStorage('session')

  return await storage.getItem<StoredPermissions>(`permissions:${storageKey}`)
}

// these belong somewhere else

export async function hasDBPermission(
  tableName: string,
  operation: 'select' | 'update' | 'insert' | 'delete',
): Promise<boolean> {
  const permissions = await getUserPermissions()

  if (!permissions?.role_permissions) {
    console.log('no role permissions found')
    return false
  }

  const tablePermissions = permissions.role_permissions.find(
    (item) => item.table_name === tableName,
  )

  if (!tablePermissions) {
    throw createError({
      message: `${tableName} is not a valid table_name`,
    })
  }

  return tablePermissions.permissions.includes(operation)
}

export async function hasFeaturePermission(
  feature: string,
  action: 'select' | 'update' | 'insert' | 'delete',
): Promise<boolean> {
  const permissions = await getUserPermissions()

  if (!permissions?.plan_permissions) {
    console.log('no plan permissions found')
    return false
  }

  const featurePermissions = permissions.plan_permissions.find((item) => item.feature === feature)

  if (!featurePermissions) {
    throw createError({
      message: `${feature} is not a valid feature name`,
    })
  }

  return featurePermissions[action]
}
</file>

<file path="apps/auth-service/server/utils/secretManager.ts">
import * as uuid from 'uuid'

class SecretManager {
  private currentSecret: string
  private previousSecret: string
  private rotationInterval: number

  constructor() {
    this.currentSecret = this.generateSecret()
    this.previousSecret = this.currentSecret // Initially, they are the same
    this.rotationInterval = 604800000 // Rotate weekly, in milliseconds
    setInterval(() => this.rotateSecret(), this.rotationInterval)
  }

  private generateSecret(): string {
    return uuid.v4()
  }

  private rotateSecret() {
    this.previousSecret = this.currentSecret // Update previous secret
    this.currentSecret = this.generateSecret()
    console.log('Secret rotated')
  }

  getSecret() {
    return this.currentSecret
  }

  getPreviousSecret() {
    return this.previousSecret
  }
}

const secretManager = new SecretManager()

export function getCurrentSecret() {
  return secretManager.getSecret()
}

export function getPreviousSecret() {
  return secretManager.getPreviousSecret()
}
</file>

<file path="apps/auth-service/types/auth.ts">
import { z } from 'zod'

export const identitySchema = z.object({
  id: z.string(),
  user_id: z.string(),
  identity_data: z.object({
    email: z.string().email(),
    sub: z.string(),
  }),
  provider: z.string(),
  last_sign_in_at: z.string(),
  created_at: z.string(),
  updated_at: z.string(),
})

export const emailUnvalidatedUserSchema = z.object({
  id: z.string(),
  aud: z.string(),
  role: z.string(),
  email: z.string().email(),
  phone: z.string().optional(),
  confirmation_sent_at: z.string().optional(),
  app_metadata: z.object({
    provider: z.string(),
    providers: z.array(z.string()),
  }),
  user_metadata: z.record(z.any()).optional(),
  identities: z.array(identitySchema),
  created_at: z.string().optional(),
  updated_at: z.string().optional(),
})

export const userSchema = z.object({
  id: z.string(),
  aud: z.string(),
  role: z.string().optional(),
  email: z.string().email().optional(),
  email_confirmed_at: z.string().optional(),
  phone: z.string().optional(),
  confirmation_sent_at: z.string().optional(),
  confirmed_at: z.string().optional(),
  last_sign_in_at: z.string().optional(),
  app_metadata: z.object({
    provider: z.string().optional(),
    providers: z.array(z.string()).optional(),
  }),
  user_metadata: z.record(z.any()),
  identities: z.array(identitySchema).optional(),
  created_at: z.string().optional(),
  updated_at: z.string().optional(),
})

export const sessionSchema = z.object({
  access_token: z.string(),
  refresh_token: z.string(),
  user: userSchema.optional(),
  token_type: z.string(),
  expires_in: z.number(),
  expires_at: z.number().optional(),
})

export const authSchema = z.object({
  user: userSchema,
  session: sessionSchema,
})

export const simpleUserSchema = z.object({
  email: z.string().email(),
  password: z.string(),
})

// Infer the types
export type AuthTypeType = z.infer<typeof authSchema>
export type SimpleUserTypeType = z.infer<typeof simpleUserSchema>
export type EmailUnvalidatedUserTypeType = z.infer<typeof emailUnvalidatedUserSchema>
export type UserTypeType = z.infer<typeof userSchema>
export type SessionTypeType = z.infer<typeof sessionSchema>
</file>

<file path="apps/auth-service/app.vue">
<template>
  <div class="h-full w-full">
    <NuxtLoadingIndicator />
    <NuxtLayout>
      <NuxtPage />
    </NuxtLayout>
    <PrimeToast position="bottom-right" />
  </div>
</template>

<style>
html {
  margin: 0;
  padding: 0;
}

#__nuxt {
  width: 100%;
  height: 100%;
  padding: 0;
  margin: 0;
}

.layout-enter-active,
.layout-leave-active {
  transition: all 0.4s;
}

.layout-enter-from,
.layout-leave-to {
  opacity: 0;
  filter: blur(1rem);
}
</style>
</file>

<file path="apps/auth-service/nuxt.config.ts">
import { fileURLToPath } from 'url'
import { dirname, join, resolve } from 'path'
import { defineNuxtConfig } from 'nuxt/config'
import runtimeConfig from '../../shared-runtime.config'

const currentDir = dirname(fileURLToPath(import.meta.url))

export default defineNuxtConfig({
  workspaceDir: '../../',
  srcDir: '.',
  extends: ['../../layers/base', '../../layers/auth', '../../layers/crud'],
  build: {
    transpile: ['../../layers/base', '../../layers/auth', '../../layers/crud'],
  },
  modules: [
    '@nuxt/devtools',
    '@vueuse/nuxt',
    '@nuxt/image',
    '@pinia/nuxt',
    '@nuxt/icon',
    '@nuxt/eslint',
    '@nuxtjs/tailwindcss',
    '@primevue/nuxt-module',
  ],

  devServer: {
    host: 'localhost',
    port: 3009,
  },

  ssr: false,

  primevue: {
    importPT: { from: resolve(currentDir, '../../theme/index.js') },
    autoImport: true,
    components: {
      prefix: 'Prime',
      include: '*',
      exclude: ['Editor'],
    },

    composables: {
      include: '*',
    },

    options: {
      ripple: true,
      unstyled: true,
      theme: {
        options: {
          cssLayer: {
            name: 'primevue',
            order: 'tailwind-base, primevue, tailwind-utilities',
          },
        },
      },
    },
  },

  routeRules: {
    '/': { redirect: '/login' },
  },

  compatibilityDate: '2024-10-03',

  ...runtimeConfig,
})
</file>

<file path="apps/auth-service/README.md">
# Nuxt 3 Minimal Starter

Look at the [Nuxt 3 documentation](https://nuxt.com/docs/getting-started/introduction) to learn
more.

## Setup

Make sure to install the dependencies:

```bash
# npm
npm install

# pnpm
pnpm install

# yarn
yarn install

# bun
bun install
```

## Development Server

Start the development server on `http://localhost:3000`:

```bash
# npm
npm run dev

# pnpm
pnpm run dev

# yarn
yarn dev

# bun
bun run dev
```

## Production

Build the application for production:

```bash
# npm
npm run build

# pnpm
pnpm run build

# yarn
yarn build

# bun
bun run build
```

Locally preview production build:

```bash
# npm
npm run preview

# pnpm
pnpm run preview

# yarn
yarn preview

# bun
bun run preview
```

Check out the [deployment documentation](https://nuxt.com/docs/getting-started/deployment) for more
information.
</file>

<file path="apps/auth-service/tailwind.config.ts">
import { fileURLToPath } from 'url'
import { dirname, resolve } from 'path'
import type { Config } from 'tailwindcss'

const currentDir = dirname(fileURLToPath(import.meta.url))

const config: Partial<Config> = {
  presets: [require('../../tailwind.config.base')],
  theme: {
    extend: {
      // Add app-specific extensions here
    },
  },
  content: [resolve(currentDir, '**/*.{js,vue,ts}'), '../../theme/**/*.{js,css,ts}'],
}

export default config
</file>

<file path="shared-runtime.config.ts">
import { config } from 'dotenv'

config()

export default defineNuxtConfig({
  runtimeConfig: {
    public: {
      strapiUrl: process.env.NUXT_PUBLIC_STRAPI_URL,
      formbricksEnvironment: process.env.NUXT_PUBLIC_FORMBRICKS_ENVIRONMENT,
      formbricksHost: process.env.NUXT_PUBLIC_FORMBRICKS_HOST,
      supabaseUrl: process.env.NUXT_PUBLIC_SUPABASE_URL,
      supabaseKey: process.env.NUXT_PUBLIC_SUPABASE_KEY,
      aeAuthUrl: process.env.NUXT_PUBLIC_AE_AUTH_URL,
      aeLoginUrl: process.env.NUXT_PUBLIC_AE_LOGIN_URL,
      aeAppUrl: process.env.NUXT_PUBLIC_AE_APP_URL,
      aeAdminUrl: process.env.NUXT_PUBLIC_AE_ADMIN_URL,
      aeMonitoringUrl: process.env.NUXT_PUBLIC_AE_MONITORING_URL,
      aeWebsiteUrl: process.env.NUXT_PUBLIC_AE_WEBSITE_URL,
      nodeEnv: process.env.NUXT_PUBLIC_NODE_ENV,
      logLevel: process.env.NUXT_PUBLIC_LOG_LEVEL,
      posthogKey: process.env.NUXT_PUBLIC_POSTHOG_KEY,
      posthogUrl: process.env.NUXT_PUBLIC_POSTHOG_URL,
      studioTokens: process.env.NUXT_PUBLIC_STUDIO_TOKENS,
      scraperUrl: process.env.NUXT_PUBLIC_SCRAPER_URL,
      devHelper: {
        enabled: true,
        features: {
          networkErrorClassifier: true,
          infiniteLoopDetector: true,
          unhandledPromiseRejectionTracker: true,
          environmentConsistencyChecker: true,
        },
      },
    },
    strapiUrl: process.env.NUXT_STRAPI_URL,
    supabaseServiceKey: process.env.NUXT_SUPABASE_SERVICE_KEY,
    googleApiKey: process.env.NUXT_GOOGLE_API_KEY,
    nasaApiKey: process.env.NUXT_NASA_API_KEY,
    openaiApiKey: process.env.NUXT_OPENAI_API_KEY,
    openaiOrg: process.env.NUXT_OPENAI_ORG,
    redisFlushKey: process.env.NUXT_REDIS_FLUSH_KEY,
    scraperKey: process.env.NUXT_SCRAPER_KEY,
    razorpayKey: process.env.NUXT_RAZORPAY_KEY,
    razorpaySecret: process.env.NUXT_RAZORPAY_SECRET,
    razorpayTestKey: process.env.NUXT_RAZORPAY_TEST_KEY,
    razorpayTestSecret: process.env.NUXT_RAZORPAY_TEST_SECRET,
  },
})
</file>

</repository_files>
